begin_unit
begin_package
DECL|package|org.apache.lucene.codecs
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|codecs
package|;
end_package
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ByteArrayOutputStream
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|PrintStream
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeMap
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|DocsAndPositionsEnum
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|DocsEnum
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|FieldInfo
operator|.
name|IndexOptions
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|FieldInfo
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|FieldInfos
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|FieldsEnum
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|IndexFileNames
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|SegmentInfo
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|TermState
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|Terms
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|TermsEnum
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|ByteArrayDataInput
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|Directory
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|IOContext
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|IndexInput
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|ArrayUtil
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|Bits
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|BytesRef
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|CodecUtil
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|IOUtils
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|RamUsageEstimator
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|StringHelper
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|automaton
operator|.
name|CompiledAutomaton
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|automaton
operator|.
name|RunAutomaton
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|automaton
operator|.
name|Transition
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|fst
operator|.
name|ByteSequenceOutputs
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|fst
operator|.
name|FST
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|fst
operator|.
name|Outputs
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|fst
operator|.
name|Util
import|;
end_import
begin_comment
comment|/** A block-based terms index and dictionary that assigns  *  terms to variable length blocks according to how they  *  share prefixes.  The terms index is a prefix trie  *  whose leaves are term blocks.  The advantage of this  *  approach is that seekExact is often able to  *  determine a term cannot exist without doing any IO, and  *  intersection with Automata is very fast.  Note that this  *  terms dictionary has it's own fixed terms index (ie, it  *  does not support a pluggable terms index  *  implementation).  *  *<p><b>NOTE</b>: this terms dictionary does not support  *  index divisor when opening an IndexReader.  Instead, you  *  can change the min/maxItemsPerBlock during indexing.</p>  *  *<p>The data structure used by this implementation is very  *  similar to a burst trie  *  (http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.18.3499),  *  but with added logic to break up too-large blocks of all  *  terms sharing a given prefix into smaller ones.</p>  *  *<p>Use {@link org.apache.lucene.index.CheckIndex} with the<code>-verbose</code>  *  option to see summary statistics on the blocks in the  *  dictionary.  *  *  See {@link BlockTreeTermsWriter}.  *  * @lucene.experimental  */
end_comment
begin_class
DECL|class|BlockTreeTermsReader
specifier|public
class|class
name|BlockTreeTermsReader
extends|extends
name|FieldsProducer
block|{
comment|// Open input to the main terms dict file (_X.tib)
DECL|field|in
specifier|private
specifier|final
name|IndexInput
name|in
decl_stmt|;
comment|//private static final boolean DEBUG = BlockTreeTermsWriter.DEBUG;
comment|// Reads the terms dict entries, to gather state to
comment|// produce DocsEnum on demand
DECL|field|postingsReader
specifier|private
specifier|final
name|PostingsReaderBase
name|postingsReader
decl_stmt|;
DECL|field|fields
specifier|private
specifier|final
name|TreeMap
argument_list|<
name|String
argument_list|,
name|FieldReader
argument_list|>
name|fields
init|=
operator|new
name|TreeMap
argument_list|<
name|String
argument_list|,
name|FieldReader
argument_list|>
argument_list|()
decl_stmt|;
comment|// keeps the dirStart offset
DECL|field|dirOffset
specifier|protected
name|long
name|dirOffset
decl_stmt|;
DECL|field|indexDirOffset
specifier|protected
name|long
name|indexDirOffset
decl_stmt|;
DECL|field|segment
specifier|private
name|String
name|segment
decl_stmt|;
DECL|method|BlockTreeTermsReader
specifier|public
name|BlockTreeTermsReader
parameter_list|(
name|Directory
name|dir
parameter_list|,
name|FieldInfos
name|fieldInfos
parameter_list|,
name|String
name|segment
parameter_list|,
name|PostingsReaderBase
name|postingsReader
parameter_list|,
name|IOContext
name|ioContext
parameter_list|,
name|String
name|segmentSuffix
parameter_list|,
name|int
name|indexDivisor
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|postingsReader
operator|=
name|postingsReader
expr_stmt|;
name|this
operator|.
name|segment
operator|=
name|segment
expr_stmt|;
name|in
operator|=
name|dir
operator|.
name|openInput
argument_list|(
name|IndexFileNames
operator|.
name|segmentFileName
argument_list|(
name|segment
argument_list|,
name|segmentSuffix
argument_list|,
name|BlockTreeTermsWriter
operator|.
name|TERMS_EXTENSION
argument_list|)
argument_list|,
name|ioContext
argument_list|)
expr_stmt|;
name|boolean
name|success
init|=
literal|false
decl_stmt|;
name|IndexInput
name|indexIn
init|=
literal|null
decl_stmt|;
try|try
block|{
name|readHeader
argument_list|(
name|in
argument_list|)
expr_stmt|;
if|if
condition|(
name|indexDivisor
operator|!=
operator|-
literal|1
condition|)
block|{
name|indexIn
operator|=
name|dir
operator|.
name|openInput
argument_list|(
name|IndexFileNames
operator|.
name|segmentFileName
argument_list|(
name|segment
argument_list|,
name|segmentSuffix
argument_list|,
name|BlockTreeTermsWriter
operator|.
name|TERMS_INDEX_EXTENSION
argument_list|)
argument_list|,
name|ioContext
argument_list|)
expr_stmt|;
name|readIndexHeader
argument_list|(
name|indexIn
argument_list|)
expr_stmt|;
block|}
comment|// Have PostingsReader init itself
name|postingsReader
operator|.
name|init
argument_list|(
name|in
argument_list|)
expr_stmt|;
comment|// Read per-field details
name|seekDir
argument_list|(
name|in
argument_list|,
name|dirOffset
argument_list|)
expr_stmt|;
if|if
condition|(
name|indexDivisor
operator|!=
operator|-
literal|1
condition|)
block|{
name|seekDir
argument_list|(
name|indexIn
argument_list|,
name|indexDirOffset
argument_list|)
expr_stmt|;
block|}
specifier|final
name|int
name|numFields
init|=
name|in
operator|.
name|readVInt
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numFields
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|int
name|field
init|=
name|in
operator|.
name|readVInt
argument_list|()
decl_stmt|;
specifier|final
name|long
name|numTerms
init|=
name|in
operator|.
name|readVLong
argument_list|()
decl_stmt|;
assert|assert
name|numTerms
operator|>=
literal|0
assert|;
specifier|final
name|int
name|numBytes
init|=
name|in
operator|.
name|readVInt
argument_list|()
decl_stmt|;
specifier|final
name|BytesRef
name|rootCode
init|=
operator|new
name|BytesRef
argument_list|(
operator|new
name|byte
index|[
name|numBytes
index|]
argument_list|)
decl_stmt|;
name|in
operator|.
name|readBytes
argument_list|(
name|rootCode
operator|.
name|bytes
argument_list|,
literal|0
argument_list|,
name|numBytes
argument_list|)
expr_stmt|;
name|rootCode
operator|.
name|length
operator|=
name|numBytes
expr_stmt|;
specifier|final
name|FieldInfo
name|fieldInfo
init|=
name|fieldInfos
operator|.
name|fieldInfo
argument_list|(
name|field
argument_list|)
decl_stmt|;
assert|assert
name|fieldInfo
operator|!=
literal|null
operator|:
literal|"field="
operator|+
name|field
assert|;
specifier|final
name|long
name|sumTotalTermFreq
init|=
name|fieldInfo
operator|.
name|getIndexOptions
argument_list|()
operator|==
name|IndexOptions
operator|.
name|DOCS_ONLY
condition|?
operator|-
literal|1
else|:
name|in
operator|.
name|readVLong
argument_list|()
decl_stmt|;
specifier|final
name|long
name|sumDocFreq
init|=
name|in
operator|.
name|readVLong
argument_list|()
decl_stmt|;
specifier|final
name|int
name|docCount
init|=
name|in
operator|.
name|readVInt
argument_list|()
decl_stmt|;
specifier|final
name|long
name|indexStartFP
init|=
name|indexDivisor
operator|!=
operator|-
literal|1
condition|?
name|indexIn
operator|.
name|readVLong
argument_list|()
else|:
literal|0
decl_stmt|;
assert|assert
operator|!
name|fields
operator|.
name|containsKey
argument_list|(
name|fieldInfo
operator|.
name|name
argument_list|)
assert|;
name|fields
operator|.
name|put
argument_list|(
name|fieldInfo
operator|.
name|name
argument_list|,
operator|new
name|FieldReader
argument_list|(
name|fieldInfo
argument_list|,
name|numTerms
argument_list|,
name|rootCode
argument_list|,
name|sumTotalTermFreq
argument_list|,
name|sumDocFreq
argument_list|,
name|docCount
argument_list|,
name|indexStartFP
argument_list|,
name|indexIn
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|success
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
operator|!
name|success
condition|)
block|{
name|IOUtils
operator|.
name|closeWhileHandlingException
argument_list|(
name|indexIn
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|indexDivisor
operator|!=
operator|-
literal|1
condition|)
block|{
name|indexIn
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
block|}
DECL|method|readHeader
specifier|protected
name|void
name|readHeader
parameter_list|(
name|IndexInput
name|input
parameter_list|)
throws|throws
name|IOException
block|{
name|CodecUtil
operator|.
name|checkHeader
argument_list|(
name|input
argument_list|,
name|BlockTreeTermsWriter
operator|.
name|TERMS_CODEC_NAME
argument_list|,
name|BlockTreeTermsWriter
operator|.
name|TERMS_VERSION_START
argument_list|,
name|BlockTreeTermsWriter
operator|.
name|TERMS_VERSION_CURRENT
argument_list|)
expr_stmt|;
name|dirOffset
operator|=
name|input
operator|.
name|readLong
argument_list|()
expr_stmt|;
block|}
DECL|method|readIndexHeader
specifier|protected
name|void
name|readIndexHeader
parameter_list|(
name|IndexInput
name|input
parameter_list|)
throws|throws
name|IOException
block|{
name|CodecUtil
operator|.
name|checkHeader
argument_list|(
name|input
argument_list|,
name|BlockTreeTermsWriter
operator|.
name|TERMS_INDEX_CODEC_NAME
argument_list|,
name|BlockTreeTermsWriter
operator|.
name|TERMS_INDEX_VERSION_START
argument_list|,
name|BlockTreeTermsWriter
operator|.
name|TERMS_INDEX_VERSION_CURRENT
argument_list|)
expr_stmt|;
name|indexDirOffset
operator|=
name|input
operator|.
name|readLong
argument_list|()
expr_stmt|;
block|}
DECL|method|seekDir
specifier|protected
name|void
name|seekDir
parameter_list|(
name|IndexInput
name|input
parameter_list|,
name|long
name|dirOffset
parameter_list|)
throws|throws
name|IOException
block|{
name|input
operator|.
name|seek
argument_list|(
name|dirOffset
argument_list|)
expr_stmt|;
block|}
comment|// for debugging
comment|// private static String toHex(int v) {
comment|//   return "0x" + Integer.toHexString(v);
comment|// }
annotation|@
name|Override
DECL|method|close
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
try|try
block|{
name|IOUtils
operator|.
name|close
argument_list|(
name|in
argument_list|,
name|postingsReader
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
comment|// Clear so refs to terms index is GCable even if
comment|// app hangs onto us:
name|fields
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|files
specifier|public
specifier|static
name|void
name|files
parameter_list|(
name|SegmentInfo
name|segmentInfo
parameter_list|,
name|String
name|segmentSuffix
parameter_list|,
name|Collection
argument_list|<
name|String
argument_list|>
name|files
parameter_list|)
block|{
name|files
operator|.
name|add
argument_list|(
name|IndexFileNames
operator|.
name|segmentFileName
argument_list|(
name|segmentInfo
operator|.
name|name
argument_list|,
name|segmentSuffix
argument_list|,
name|BlockTreeTermsWriter
operator|.
name|TERMS_EXTENSION
argument_list|)
argument_list|)
expr_stmt|;
name|files
operator|.
name|add
argument_list|(
name|IndexFileNames
operator|.
name|segmentFileName
argument_list|(
name|segmentInfo
operator|.
name|name
argument_list|,
name|segmentSuffix
argument_list|,
name|BlockTreeTermsWriter
operator|.
name|TERMS_INDEX_EXTENSION
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|iterator
specifier|public
name|FieldsEnum
name|iterator
parameter_list|()
block|{
return|return
operator|new
name|TermFieldsEnum
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|terms
specifier|public
name|Terms
name|terms
parameter_list|(
name|String
name|field
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|field
operator|!=
literal|null
assert|;
return|return
name|fields
operator|.
name|get
argument_list|(
name|field
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|size
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|fields
operator|.
name|size
argument_list|()
return|;
block|}
comment|// Iterates through all fields
DECL|class|TermFieldsEnum
specifier|private
class|class
name|TermFieldsEnum
extends|extends
name|FieldsEnum
block|{
DECL|field|it
specifier|final
name|Iterator
argument_list|<
name|FieldReader
argument_list|>
name|it
decl_stmt|;
DECL|field|current
name|FieldReader
name|current
decl_stmt|;
DECL|method|TermFieldsEnum
name|TermFieldsEnum
parameter_list|()
block|{
name|it
operator|=
name|fields
operator|.
name|values
argument_list|()
operator|.
name|iterator
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|next
specifier|public
name|String
name|next
parameter_list|()
block|{
if|if
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|current
operator|=
name|it
operator|.
name|next
argument_list|()
expr_stmt|;
return|return
name|current
operator|.
name|fieldInfo
operator|.
name|name
return|;
block|}
else|else
block|{
name|current
operator|=
literal|null
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|terms
specifier|public
name|Terms
name|terms
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|current
return|;
block|}
block|}
comment|// for debugging
DECL|method|brToString
name|String
name|brToString
parameter_list|(
name|BytesRef
name|b
parameter_list|)
block|{
if|if
condition|(
name|b
operator|==
literal|null
condition|)
block|{
return|return
literal|"null"
return|;
block|}
else|else
block|{
try|try
block|{
return|return
name|b
operator|.
name|utf8ToString
argument_list|()
operator|+
literal|" "
operator|+
name|b
return|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
comment|// If BytesRef isn't actually UTF8, or it's eg a
comment|// prefix of UTF8 that ends mid-unicode-char, we
comment|// fallback to hex:
return|return
name|b
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
block|}
comment|/**    * BlockTree statistics for a single field     * returned by {@link FieldReader#computeStats()}.    */
DECL|class|Stats
specifier|public
specifier|static
class|class
name|Stats
block|{
DECL|field|indexNodeCount
specifier|public
name|int
name|indexNodeCount
decl_stmt|;
DECL|field|indexArcCount
specifier|public
name|int
name|indexArcCount
decl_stmt|;
DECL|field|indexNumBytes
specifier|public
name|int
name|indexNumBytes
decl_stmt|;
DECL|field|totalTermCount
specifier|public
name|long
name|totalTermCount
decl_stmt|;
DECL|field|totalTermBytes
specifier|public
name|long
name|totalTermBytes
decl_stmt|;
DECL|field|nonFloorBlockCount
specifier|public
name|int
name|nonFloorBlockCount
decl_stmt|;
DECL|field|floorBlockCount
specifier|public
name|int
name|floorBlockCount
decl_stmt|;
DECL|field|floorSubBlockCount
specifier|public
name|int
name|floorSubBlockCount
decl_stmt|;
DECL|field|mixedBlockCount
specifier|public
name|int
name|mixedBlockCount
decl_stmt|;
DECL|field|termsOnlyBlockCount
specifier|public
name|int
name|termsOnlyBlockCount
decl_stmt|;
DECL|field|subBlocksOnlyBlockCount
specifier|public
name|int
name|subBlocksOnlyBlockCount
decl_stmt|;
DECL|field|totalBlockCount
specifier|public
name|int
name|totalBlockCount
decl_stmt|;
DECL|field|blockCountByPrefixLen
specifier|public
name|int
index|[]
name|blockCountByPrefixLen
init|=
operator|new
name|int
index|[
literal|10
index|]
decl_stmt|;
DECL|field|startBlockCount
specifier|private
name|int
name|startBlockCount
decl_stmt|;
DECL|field|endBlockCount
specifier|private
name|int
name|endBlockCount
decl_stmt|;
DECL|field|totalBlockSuffixBytes
specifier|public
name|long
name|totalBlockSuffixBytes
decl_stmt|;
DECL|field|totalBlockStatsBytes
specifier|public
name|long
name|totalBlockStatsBytes
decl_stmt|;
comment|// Postings impl plus the other few vInts stored in
comment|// the frame:
DECL|field|totalBlockOtherBytes
specifier|public
name|long
name|totalBlockOtherBytes
decl_stmt|;
DECL|field|segment
specifier|public
specifier|final
name|String
name|segment
decl_stmt|;
DECL|field|field
specifier|public
specifier|final
name|String
name|field
decl_stmt|;
DECL|method|Stats
specifier|public
name|Stats
parameter_list|(
name|String
name|segment
parameter_list|,
name|String
name|field
parameter_list|)
block|{
name|this
operator|.
name|segment
operator|=
name|segment
expr_stmt|;
name|this
operator|.
name|field
operator|=
name|field
expr_stmt|;
block|}
DECL|method|startBlock
name|void
name|startBlock
parameter_list|(
name|FieldReader
operator|.
name|SegmentTermsEnum
operator|.
name|Frame
name|frame
parameter_list|,
name|boolean
name|isFloor
parameter_list|)
block|{
name|totalBlockCount
operator|++
expr_stmt|;
if|if
condition|(
name|isFloor
condition|)
block|{
if|if
condition|(
name|frame
operator|.
name|fp
operator|==
name|frame
operator|.
name|fpOrig
condition|)
block|{
name|floorBlockCount
operator|++
expr_stmt|;
block|}
name|floorSubBlockCount
operator|++
expr_stmt|;
block|}
else|else
block|{
name|nonFloorBlockCount
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|blockCountByPrefixLen
operator|.
name|length
operator|<=
name|frame
operator|.
name|prefix
condition|)
block|{
name|blockCountByPrefixLen
operator|=
name|ArrayUtil
operator|.
name|grow
argument_list|(
name|blockCountByPrefixLen
argument_list|,
literal|1
operator|+
name|frame
operator|.
name|prefix
argument_list|)
expr_stmt|;
block|}
name|blockCountByPrefixLen
index|[
name|frame
operator|.
name|prefix
index|]
operator|++
expr_stmt|;
name|startBlockCount
operator|++
expr_stmt|;
name|totalBlockSuffixBytes
operator|+=
name|frame
operator|.
name|suffixesReader
operator|.
name|length
argument_list|()
expr_stmt|;
name|totalBlockStatsBytes
operator|+=
name|frame
operator|.
name|statsReader
operator|.
name|length
argument_list|()
expr_stmt|;
block|}
DECL|method|endBlock
name|void
name|endBlock
parameter_list|(
name|FieldReader
operator|.
name|SegmentTermsEnum
operator|.
name|Frame
name|frame
parameter_list|)
block|{
specifier|final
name|int
name|termCount
init|=
name|frame
operator|.
name|isLeafBlock
condition|?
name|frame
operator|.
name|entCount
else|:
name|frame
operator|.
name|state
operator|.
name|termBlockOrd
decl_stmt|;
specifier|final
name|int
name|subBlockCount
init|=
name|frame
operator|.
name|entCount
operator|-
name|termCount
decl_stmt|;
name|totalTermCount
operator|+=
name|termCount
expr_stmt|;
if|if
condition|(
name|termCount
operator|!=
literal|0
operator|&&
name|subBlockCount
operator|!=
literal|0
condition|)
block|{
name|mixedBlockCount
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|termCount
operator|!=
literal|0
condition|)
block|{
name|termsOnlyBlockCount
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|subBlockCount
operator|!=
literal|0
condition|)
block|{
name|subBlocksOnlyBlockCount
operator|++
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|()
throw|;
block|}
name|endBlockCount
operator|++
expr_stmt|;
specifier|final
name|long
name|otherBytes
init|=
name|frame
operator|.
name|fpEnd
operator|-
name|frame
operator|.
name|fp
operator|-
name|frame
operator|.
name|suffixesReader
operator|.
name|length
argument_list|()
operator|-
name|frame
operator|.
name|statsReader
operator|.
name|length
argument_list|()
decl_stmt|;
assert|assert
name|otherBytes
operator|>
literal|0
operator|:
literal|"otherBytes="
operator|+
name|otherBytes
operator|+
literal|" frame.fp="
operator|+
name|frame
operator|.
name|fp
operator|+
literal|" frame.fpEnd="
operator|+
name|frame
operator|.
name|fpEnd
assert|;
name|totalBlockOtherBytes
operator|+=
name|otherBytes
expr_stmt|;
block|}
DECL|method|term
name|void
name|term
parameter_list|(
name|BytesRef
name|term
parameter_list|)
block|{
name|totalTermBytes
operator|+=
name|term
operator|.
name|length
expr_stmt|;
block|}
DECL|method|finish
name|void
name|finish
parameter_list|()
block|{
assert|assert
name|startBlockCount
operator|==
name|endBlockCount
operator|:
literal|"startBlockCount="
operator|+
name|startBlockCount
operator|+
literal|" endBlockCount="
operator|+
name|endBlockCount
assert|;
assert|assert
name|totalBlockCount
operator|==
name|floorSubBlockCount
operator|+
name|nonFloorBlockCount
operator|:
literal|"floorSubBlockCount="
operator|+
name|floorSubBlockCount
operator|+
literal|" nonFloorBlockCount="
operator|+
name|nonFloorBlockCount
operator|+
literal|" totalBlockCount="
operator|+
name|totalBlockCount
assert|;
assert|assert
name|totalBlockCount
operator|==
name|mixedBlockCount
operator|+
name|termsOnlyBlockCount
operator|+
name|subBlocksOnlyBlockCount
operator|:
literal|"totalBlockCount="
operator|+
name|totalBlockCount
operator|+
literal|" mixedBlockCount="
operator|+
name|mixedBlockCount
operator|+
literal|" subBlocksOnlyBlockCount="
operator|+
name|subBlocksOnlyBlockCount
operator|+
literal|" termsOnlyBlockCount="
operator|+
name|termsOnlyBlockCount
assert|;
block|}
annotation|@
name|Override
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
specifier|final
name|ByteArrayOutputStream
name|bos
init|=
operator|new
name|ByteArrayOutputStream
argument_list|(
literal|1024
argument_list|)
decl_stmt|;
specifier|final
name|PrintStream
name|out
init|=
operator|new
name|PrintStream
argument_list|(
name|bos
argument_list|)
decl_stmt|;
name|out
operator|.
name|println
argument_list|(
literal|"  index FST:"
argument_list|)
expr_stmt|;
name|out
operator|.
name|println
argument_list|(
literal|"    "
operator|+
name|indexNodeCount
operator|+
literal|" nodes"
argument_list|)
expr_stmt|;
name|out
operator|.
name|println
argument_list|(
literal|"    "
operator|+
name|indexArcCount
operator|+
literal|" arcs"
argument_list|)
expr_stmt|;
name|out
operator|.
name|println
argument_list|(
literal|"    "
operator|+
name|indexNumBytes
operator|+
literal|" bytes"
argument_list|)
expr_stmt|;
name|out
operator|.
name|println
argument_list|(
literal|"  terms:"
argument_list|)
expr_stmt|;
name|out
operator|.
name|println
argument_list|(
literal|"    "
operator|+
name|totalTermCount
operator|+
literal|" terms"
argument_list|)
expr_stmt|;
name|out
operator|.
name|println
argument_list|(
literal|"    "
operator|+
name|totalTermBytes
operator|+
literal|" bytes"
operator|+
operator|(
name|totalTermCount
operator|!=
literal|0
condition|?
literal|" ("
operator|+
name|String
operator|.
name|format
argument_list|(
literal|"%.1f"
argument_list|,
operator|(
operator|(
name|double
operator|)
name|totalTermBytes
operator|)
operator|/
name|totalTermCount
argument_list|)
operator|+
literal|" bytes/term)"
else|:
literal|""
operator|)
argument_list|)
expr_stmt|;
name|out
operator|.
name|println
argument_list|(
literal|"  blocks:"
argument_list|)
expr_stmt|;
name|out
operator|.
name|println
argument_list|(
literal|"    "
operator|+
name|totalBlockCount
operator|+
literal|" blocks"
argument_list|)
expr_stmt|;
name|out
operator|.
name|println
argument_list|(
literal|"    "
operator|+
name|termsOnlyBlockCount
operator|+
literal|" terms-only blocks"
argument_list|)
expr_stmt|;
name|out
operator|.
name|println
argument_list|(
literal|"    "
operator|+
name|subBlocksOnlyBlockCount
operator|+
literal|" sub-block-only blocks"
argument_list|)
expr_stmt|;
name|out
operator|.
name|println
argument_list|(
literal|"    "
operator|+
name|mixedBlockCount
operator|+
literal|" mixed blocks"
argument_list|)
expr_stmt|;
name|out
operator|.
name|println
argument_list|(
literal|"    "
operator|+
name|floorBlockCount
operator|+
literal|" floor blocks"
argument_list|)
expr_stmt|;
name|out
operator|.
name|println
argument_list|(
literal|"    "
operator|+
operator|(
name|totalBlockCount
operator|-
name|floorSubBlockCount
operator|)
operator|+
literal|" non-floor blocks"
argument_list|)
expr_stmt|;
name|out
operator|.
name|println
argument_list|(
literal|"    "
operator|+
name|floorSubBlockCount
operator|+
literal|" floor sub-blocks"
argument_list|)
expr_stmt|;
name|out
operator|.
name|println
argument_list|(
literal|"    "
operator|+
name|totalBlockSuffixBytes
operator|+
literal|" term suffix bytes"
operator|+
operator|(
name|totalBlockCount
operator|!=
literal|0
condition|?
literal|" ("
operator|+
name|String
operator|.
name|format
argument_list|(
literal|"%.1f"
argument_list|,
operator|(
operator|(
name|double
operator|)
name|totalBlockSuffixBytes
operator|)
operator|/
name|totalBlockCount
argument_list|)
operator|+
literal|" suffix-bytes/block)"
else|:
literal|""
operator|)
argument_list|)
expr_stmt|;
name|out
operator|.
name|println
argument_list|(
literal|"    "
operator|+
name|totalBlockStatsBytes
operator|+
literal|" term stats bytes"
operator|+
operator|(
name|totalBlockCount
operator|!=
literal|0
condition|?
literal|" ("
operator|+
name|String
operator|.
name|format
argument_list|(
literal|"%.1f"
argument_list|,
operator|(
operator|(
name|double
operator|)
name|totalBlockStatsBytes
operator|)
operator|/
name|totalBlockCount
argument_list|)
operator|+
literal|" stats-bytes/block)"
else|:
literal|""
operator|)
argument_list|)
expr_stmt|;
name|out
operator|.
name|println
argument_list|(
literal|"    "
operator|+
name|totalBlockOtherBytes
operator|+
literal|" other bytes"
operator|+
operator|(
name|totalBlockCount
operator|!=
literal|0
condition|?
literal|" ("
operator|+
name|String
operator|.
name|format
argument_list|(
literal|"%.1f"
argument_list|,
operator|(
operator|(
name|double
operator|)
name|totalBlockOtherBytes
operator|)
operator|/
name|totalBlockCount
argument_list|)
operator|+
literal|" other-bytes/block)"
else|:
literal|""
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|totalBlockCount
operator|!=
literal|0
condition|)
block|{
name|out
operator|.
name|println
argument_list|(
literal|"    by prefix length:"
argument_list|)
expr_stmt|;
name|int
name|total
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|prefix
init|=
literal|0
init|;
name|prefix
operator|<
name|blockCountByPrefixLen
operator|.
name|length
condition|;
name|prefix
operator|++
control|)
block|{
specifier|final
name|int
name|blockCount
init|=
name|blockCountByPrefixLen
index|[
name|prefix
index|]
decl_stmt|;
name|total
operator|+=
name|blockCount
expr_stmt|;
if|if
condition|(
name|blockCount
operator|!=
literal|0
condition|)
block|{
name|out
operator|.
name|println
argument_list|(
literal|"      "
operator|+
name|String
operator|.
name|format
argument_list|(
literal|"%2d"
argument_list|,
name|prefix
argument_list|)
operator|+
literal|": "
operator|+
name|blockCount
argument_list|)
expr_stmt|;
block|}
block|}
assert|assert
name|totalBlockCount
operator|==
name|total
assert|;
block|}
return|return
name|bos
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
DECL|field|fstOutputs
specifier|final
name|Outputs
argument_list|<
name|BytesRef
argument_list|>
name|fstOutputs
init|=
name|ByteSequenceOutputs
operator|.
name|getSingleton
argument_list|()
decl_stmt|;
DECL|field|NO_OUTPUT
specifier|final
name|BytesRef
name|NO_OUTPUT
init|=
name|fstOutputs
operator|.
name|getNoOutput
argument_list|()
decl_stmt|;
DECL|class|FieldReader
specifier|public
specifier|final
class|class
name|FieldReader
extends|extends
name|Terms
block|{
DECL|field|numTerms
specifier|final
name|long
name|numTerms
decl_stmt|;
DECL|field|fieldInfo
specifier|final
name|FieldInfo
name|fieldInfo
decl_stmt|;
DECL|field|sumTotalTermFreq
specifier|final
name|long
name|sumTotalTermFreq
decl_stmt|;
DECL|field|sumDocFreq
specifier|final
name|long
name|sumDocFreq
decl_stmt|;
DECL|field|docCount
specifier|final
name|int
name|docCount
decl_stmt|;
DECL|field|indexStartFP
specifier|final
name|long
name|indexStartFP
decl_stmt|;
DECL|field|rootBlockFP
specifier|final
name|long
name|rootBlockFP
decl_stmt|;
DECL|field|rootCode
specifier|final
name|BytesRef
name|rootCode
decl_stmt|;
DECL|field|index
specifier|private
specifier|final
name|FST
argument_list|<
name|BytesRef
argument_list|>
name|index
decl_stmt|;
comment|//private boolean DEBUG;
DECL|method|FieldReader
name|FieldReader
parameter_list|(
name|FieldInfo
name|fieldInfo
parameter_list|,
name|long
name|numTerms
parameter_list|,
name|BytesRef
name|rootCode
parameter_list|,
name|long
name|sumTotalTermFreq
parameter_list|,
name|long
name|sumDocFreq
parameter_list|,
name|int
name|docCount
parameter_list|,
name|long
name|indexStartFP
parameter_list|,
name|IndexInput
name|indexIn
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|numTerms
operator|>
literal|0
assert|;
name|this
operator|.
name|fieldInfo
operator|=
name|fieldInfo
expr_stmt|;
comment|//DEBUG = BlockTreeTermsReader.DEBUG&& fieldInfo.name.equals("id");
name|this
operator|.
name|numTerms
operator|=
name|numTerms
expr_stmt|;
name|this
operator|.
name|sumTotalTermFreq
operator|=
name|sumTotalTermFreq
expr_stmt|;
name|this
operator|.
name|sumDocFreq
operator|=
name|sumDocFreq
expr_stmt|;
name|this
operator|.
name|docCount
operator|=
name|docCount
expr_stmt|;
name|this
operator|.
name|indexStartFP
operator|=
name|indexStartFP
expr_stmt|;
name|this
operator|.
name|rootCode
operator|=
name|rootCode
expr_stmt|;
comment|// if (DEBUG) {
comment|//   System.out.println("BTTR: seg=" + segment + " field=" + fieldInfo.name + " rootBlockCode=" + rootCode + " divisor=" + indexDivisor);
comment|// }
name|rootBlockFP
operator|=
operator|(
operator|new
name|ByteArrayDataInput
argument_list|(
name|rootCode
operator|.
name|bytes
argument_list|,
name|rootCode
operator|.
name|offset
argument_list|,
name|rootCode
operator|.
name|length
argument_list|)
operator|)
operator|.
name|readVLong
argument_list|()
operator|>>>
name|BlockTreeTermsWriter
operator|.
name|OUTPUT_FLAGS_NUM_BITS
expr_stmt|;
if|if
condition|(
name|indexIn
operator|!=
literal|null
condition|)
block|{
specifier|final
name|IndexInput
name|clone
init|=
operator|(
name|IndexInput
operator|)
name|indexIn
operator|.
name|clone
argument_list|()
decl_stmt|;
comment|//System.out.println("start=" + indexStartFP + " field=" + fieldInfo.name);
name|clone
operator|.
name|seek
argument_list|(
name|indexStartFP
argument_list|)
expr_stmt|;
name|index
operator|=
operator|new
name|FST
argument_list|<
name|BytesRef
argument_list|>
argument_list|(
name|clone
argument_list|,
name|ByteSequenceOutputs
operator|.
name|getSingleton
argument_list|()
argument_list|)
expr_stmt|;
comment|/*         if (false) {           final String dotFileName = segment + "_" + fieldInfo.name + ".dot";           Writer w = new OutputStreamWriter(new FileOutputStream(dotFileName));           Util.toDot(index, w, false, false);           System.out.println("FST INDEX: SAVED to " + dotFileName);           w.close();         }         */
block|}
else|else
block|{
name|index
operator|=
literal|null
expr_stmt|;
block|}
block|}
comment|/** For debugging -- used by CheckIndex too*/
comment|// TODO: maybe push this into Terms?
DECL|method|computeStats
specifier|public
name|Stats
name|computeStats
parameter_list|()
throws|throws
name|IOException
block|{
return|return
operator|new
name|SegmentTermsEnum
argument_list|()
operator|.
name|computeBlockStats
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|getComparator
specifier|public
name|Comparator
argument_list|<
name|BytesRef
argument_list|>
name|getComparator
parameter_list|()
block|{
return|return
name|BytesRef
operator|.
name|getUTF8SortedAsUnicodeComparator
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|iterator
specifier|public
name|TermsEnum
name|iterator
parameter_list|(
name|TermsEnum
name|reuse
parameter_list|)
throws|throws
name|IOException
block|{
return|return
operator|new
name|SegmentTermsEnum
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|size
specifier|public
name|long
name|size
parameter_list|()
block|{
return|return
name|numTerms
return|;
block|}
annotation|@
name|Override
DECL|method|getSumTotalTermFreq
specifier|public
name|long
name|getSumTotalTermFreq
parameter_list|()
block|{
return|return
name|sumTotalTermFreq
return|;
block|}
annotation|@
name|Override
DECL|method|getSumDocFreq
specifier|public
name|long
name|getSumDocFreq
parameter_list|()
block|{
return|return
name|sumDocFreq
return|;
block|}
annotation|@
name|Override
DECL|method|getDocCount
specifier|public
name|int
name|getDocCount
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|docCount
return|;
block|}
annotation|@
name|Override
DECL|method|intersect
specifier|public
name|TermsEnum
name|intersect
parameter_list|(
name|CompiledAutomaton
name|compiled
parameter_list|,
name|BytesRef
name|startTerm
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|compiled
operator|.
name|type
operator|!=
name|CompiledAutomaton
operator|.
name|AUTOMATON_TYPE
operator|.
name|NORMAL
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"please use CompiledAutomaton.getTermsEnum instead"
argument_list|)
throw|;
block|}
return|return
operator|new
name|IntersectEnum
argument_list|(
name|compiled
argument_list|,
name|startTerm
argument_list|)
return|;
block|}
comment|// NOTE: cannot seek!
DECL|class|IntersectEnum
specifier|private
specifier|final
class|class
name|IntersectEnum
extends|extends
name|TermsEnum
block|{
DECL|field|in
specifier|private
specifier|final
name|IndexInput
name|in
decl_stmt|;
DECL|field|stack
specifier|private
name|Frame
index|[]
name|stack
decl_stmt|;
DECL|field|arcs
annotation|@
name|SuppressWarnings
argument_list|(
block|{
literal|"rawtypes"
block|,
literal|"unchecked"
block|}
argument_list|)
specifier|private
name|FST
operator|.
name|Arc
argument_list|<
name|BytesRef
argument_list|>
index|[]
name|arcs
init|=
operator|new
name|FST
operator|.
name|Arc
index|[
literal|5
index|]
decl_stmt|;
DECL|field|runAutomaton
specifier|private
specifier|final
name|RunAutomaton
name|runAutomaton
decl_stmt|;
DECL|field|compiledAutomaton
specifier|private
specifier|final
name|CompiledAutomaton
name|compiledAutomaton
decl_stmt|;
DECL|field|currentFrame
specifier|private
name|Frame
name|currentFrame
decl_stmt|;
DECL|field|term
specifier|private
specifier|final
name|BytesRef
name|term
init|=
operator|new
name|BytesRef
argument_list|()
decl_stmt|;
DECL|field|fstReader
specifier|private
specifier|final
name|FST
operator|.
name|BytesReader
name|fstReader
decl_stmt|;
comment|// TODO: can we share this with the frame in STE?
DECL|class|Frame
specifier|private
specifier|final
class|class
name|Frame
block|{
DECL|field|ord
specifier|final
name|int
name|ord
decl_stmt|;
DECL|field|fp
name|long
name|fp
decl_stmt|;
DECL|field|fpOrig
name|long
name|fpOrig
decl_stmt|;
DECL|field|fpEnd
name|long
name|fpEnd
decl_stmt|;
DECL|field|lastSubFP
name|long
name|lastSubFP
decl_stmt|;
comment|// State in automaton
DECL|field|state
name|int
name|state
decl_stmt|;
DECL|field|metaDataUpto
name|int
name|metaDataUpto
decl_stmt|;
DECL|field|suffixBytes
name|byte
index|[]
name|suffixBytes
init|=
operator|new
name|byte
index|[
literal|128
index|]
decl_stmt|;
DECL|field|suffixesReader
specifier|final
name|ByteArrayDataInput
name|suffixesReader
init|=
operator|new
name|ByteArrayDataInput
argument_list|()
decl_stmt|;
DECL|field|statBytes
name|byte
index|[]
name|statBytes
init|=
operator|new
name|byte
index|[
literal|64
index|]
decl_stmt|;
DECL|field|statsReader
specifier|final
name|ByteArrayDataInput
name|statsReader
init|=
operator|new
name|ByteArrayDataInput
argument_list|()
decl_stmt|;
DECL|field|floorData
name|byte
index|[]
name|floorData
init|=
operator|new
name|byte
index|[
literal|32
index|]
decl_stmt|;
DECL|field|floorDataReader
specifier|final
name|ByteArrayDataInput
name|floorDataReader
init|=
operator|new
name|ByteArrayDataInput
argument_list|()
decl_stmt|;
comment|// Length of prefix shared by all terms in this block
DECL|field|prefix
name|int
name|prefix
decl_stmt|;
comment|// Number of entries (term or sub-block) in this block
DECL|field|entCount
name|int
name|entCount
decl_stmt|;
comment|// Which term we will next read
DECL|field|nextEnt
name|int
name|nextEnt
decl_stmt|;
comment|// True if this block is either not a floor block,
comment|// or, it's the last sub-block of a floor block
DECL|field|isLastInFloor
name|boolean
name|isLastInFloor
decl_stmt|;
comment|// True if all entries are terms
DECL|field|isLeafBlock
name|boolean
name|isLeafBlock
decl_stmt|;
DECL|field|numFollowFloorBlocks
name|int
name|numFollowFloorBlocks
decl_stmt|;
DECL|field|nextFloorLabel
name|int
name|nextFloorLabel
decl_stmt|;
DECL|field|transitions
name|Transition
index|[]
name|transitions
decl_stmt|;
DECL|field|curTransitionMax
name|int
name|curTransitionMax
decl_stmt|;
DECL|field|transitionIndex
name|int
name|transitionIndex
decl_stmt|;
DECL|field|arc
name|FST
operator|.
name|Arc
argument_list|<
name|BytesRef
argument_list|>
name|arc
decl_stmt|;
DECL|field|termState
specifier|final
name|BlockTermState
name|termState
decl_stmt|;
comment|// Cumulative output so far
DECL|field|outputPrefix
name|BytesRef
name|outputPrefix
decl_stmt|;
DECL|field|startBytePos
specifier|private
name|int
name|startBytePos
decl_stmt|;
DECL|field|suffix
specifier|private
name|int
name|suffix
decl_stmt|;
DECL|method|Frame
specifier|public
name|Frame
parameter_list|(
name|int
name|ord
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|ord
operator|=
name|ord
expr_stmt|;
name|termState
operator|=
name|postingsReader
operator|.
name|newTermState
argument_list|()
expr_stmt|;
name|termState
operator|.
name|totalTermFreq
operator|=
operator|-
literal|1
expr_stmt|;
block|}
DECL|method|loadNextFloorBlock
name|void
name|loadNextFloorBlock
parameter_list|()
throws|throws
name|IOException
block|{
assert|assert
name|numFollowFloorBlocks
operator|>
literal|0
assert|;
comment|//if (DEBUG) System.out.println("    loadNextFoorBlock trans=" + transitions[transitionIndex]);
do|do
block|{
name|fp
operator|=
name|fpOrig
operator|+
operator|(
name|floorDataReader
operator|.
name|readVLong
argument_list|()
operator|>>>
literal|1
operator|)
expr_stmt|;
name|numFollowFloorBlocks
operator|--
expr_stmt|;
comment|// if (DEBUG) System.out.println("    skip floor block2!  nextFloorLabel=" + (char) nextFloorLabel + " vs target=" + (char) transitions[transitionIndex].getMin() + " newFP=" + fp + " numFollowFloorBlocks=" + numFollowFloorBlocks);
if|if
condition|(
name|numFollowFloorBlocks
operator|!=
literal|0
condition|)
block|{
name|nextFloorLabel
operator|=
name|floorDataReader
operator|.
name|readByte
argument_list|()
operator|&
literal|0xff
expr_stmt|;
block|}
else|else
block|{
name|nextFloorLabel
operator|=
literal|256
expr_stmt|;
block|}
comment|// if (DEBUG) System.out.println("    nextFloorLabel=" + (char) nextFloorLabel);
block|}
do|while
condition|(
name|numFollowFloorBlocks
operator|!=
literal|0
operator|&&
name|nextFloorLabel
operator|<=
name|transitions
index|[
name|transitionIndex
index|]
operator|.
name|getMin
argument_list|()
condition|)
do|;
name|load
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
DECL|method|setState
specifier|public
name|void
name|setState
parameter_list|(
name|int
name|state
parameter_list|)
block|{
name|this
operator|.
name|state
operator|=
name|state
expr_stmt|;
name|transitionIndex
operator|=
literal|0
expr_stmt|;
name|transitions
operator|=
name|compiledAutomaton
operator|.
name|sortedTransitions
index|[
name|state
index|]
expr_stmt|;
if|if
condition|(
name|transitions
operator|.
name|length
operator|!=
literal|0
condition|)
block|{
name|curTransitionMax
operator|=
name|transitions
index|[
literal|0
index|]
operator|.
name|getMax
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|curTransitionMax
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
DECL|method|load
name|void
name|load
parameter_list|(
name|BytesRef
name|frameIndexData
parameter_list|)
throws|throws
name|IOException
block|{
comment|// if (DEBUG) System.out.println("    load fp=" + fp + " fpOrig=" + fpOrig + " frameIndexData=" + frameIndexData + " trans=" + (transitions.length != 0 ? transitions[0] : "n/a" + " state=" + state));
if|if
condition|(
name|frameIndexData
operator|!=
literal|null
operator|&&
name|transitions
operator|.
name|length
operator|!=
literal|0
condition|)
block|{
comment|// Floor frame
if|if
condition|(
name|floorData
operator|.
name|length
operator|<
name|frameIndexData
operator|.
name|length
condition|)
block|{
name|this
operator|.
name|floorData
operator|=
operator|new
name|byte
index|[
name|ArrayUtil
operator|.
name|oversize
argument_list|(
name|frameIndexData
operator|.
name|length
argument_list|,
literal|1
argument_list|)
index|]
expr_stmt|;
block|}
name|System
operator|.
name|arraycopy
argument_list|(
name|frameIndexData
operator|.
name|bytes
argument_list|,
name|frameIndexData
operator|.
name|offset
argument_list|,
name|floorData
argument_list|,
literal|0
argument_list|,
name|frameIndexData
operator|.
name|length
argument_list|)
expr_stmt|;
name|floorDataReader
operator|.
name|reset
argument_list|(
name|floorData
argument_list|,
literal|0
argument_list|,
name|frameIndexData
operator|.
name|length
argument_list|)
expr_stmt|;
comment|// Skip first long -- has redundant fp, hasTerms
comment|// flag, isFloor flag
specifier|final
name|long
name|code
init|=
name|floorDataReader
operator|.
name|readVLong
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|code
operator|&
name|BlockTreeTermsWriter
operator|.
name|OUTPUT_FLAG_IS_FLOOR
operator|)
operator|!=
literal|0
condition|)
block|{
name|numFollowFloorBlocks
operator|=
name|floorDataReader
operator|.
name|readVInt
argument_list|()
expr_stmt|;
name|nextFloorLabel
operator|=
name|floorDataReader
operator|.
name|readByte
argument_list|()
operator|&
literal|0xff
expr_stmt|;
comment|// if (DEBUG) System.out.println("    numFollowFloorBlocks=" + numFollowFloorBlocks + " nextFloorLabel=" + nextFloorLabel);
comment|// If current state is accept, we must process
comment|// first block in case it has empty suffix:
if|if
condition|(
operator|!
name|runAutomaton
operator|.
name|isAccept
argument_list|(
name|state
argument_list|)
condition|)
block|{
comment|// Maybe skip floor blocks:
while|while
condition|(
name|numFollowFloorBlocks
operator|!=
literal|0
operator|&&
name|nextFloorLabel
operator|<=
name|transitions
index|[
literal|0
index|]
operator|.
name|getMin
argument_list|()
condition|)
block|{
name|fp
operator|=
name|fpOrig
operator|+
operator|(
name|floorDataReader
operator|.
name|readVLong
argument_list|()
operator|>>>
literal|1
operator|)
expr_stmt|;
name|numFollowFloorBlocks
operator|--
expr_stmt|;
comment|// if (DEBUG) System.out.println("    skip floor block!  nextFloorLabel=" + (char) nextFloorLabel + " vs target=" + (char) transitions[0].getMin() + " newFP=" + fp + " numFollowFloorBlocks=" + numFollowFloorBlocks);
if|if
condition|(
name|numFollowFloorBlocks
operator|!=
literal|0
condition|)
block|{
name|nextFloorLabel
operator|=
name|floorDataReader
operator|.
name|readByte
argument_list|()
operator|&
literal|0xff
expr_stmt|;
block|}
else|else
block|{
name|nextFloorLabel
operator|=
literal|256
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
name|in
operator|.
name|seek
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|int
name|code
init|=
name|in
operator|.
name|readVInt
argument_list|()
decl_stmt|;
name|entCount
operator|=
name|code
operator|>>>
literal|1
expr_stmt|;
assert|assert
name|entCount
operator|>
literal|0
assert|;
name|isLastInFloor
operator|=
operator|(
name|code
operator|&
literal|1
operator|)
operator|!=
literal|0
expr_stmt|;
comment|// term suffixes:
name|code
operator|=
name|in
operator|.
name|readVInt
argument_list|()
expr_stmt|;
name|isLeafBlock
operator|=
operator|(
name|code
operator|&
literal|1
operator|)
operator|!=
literal|0
expr_stmt|;
name|int
name|numBytes
init|=
name|code
operator|>>>
literal|1
decl_stmt|;
comment|// if (DEBUG) System.out.println("      entCount=" + entCount + " lastInFloor?=" + isLastInFloor + " leafBlock?=" + isLeafBlock + " numSuffixBytes=" + numBytes);
if|if
condition|(
name|suffixBytes
operator|.
name|length
operator|<
name|numBytes
condition|)
block|{
name|suffixBytes
operator|=
operator|new
name|byte
index|[
name|ArrayUtil
operator|.
name|oversize
argument_list|(
name|numBytes
argument_list|,
literal|1
argument_list|)
index|]
expr_stmt|;
block|}
name|in
operator|.
name|readBytes
argument_list|(
name|suffixBytes
argument_list|,
literal|0
argument_list|,
name|numBytes
argument_list|)
expr_stmt|;
name|suffixesReader
operator|.
name|reset
argument_list|(
name|suffixBytes
argument_list|,
literal|0
argument_list|,
name|numBytes
argument_list|)
expr_stmt|;
comment|// stats
name|numBytes
operator|=
name|in
operator|.
name|readVInt
argument_list|()
expr_stmt|;
if|if
condition|(
name|statBytes
operator|.
name|length
operator|<
name|numBytes
condition|)
block|{
name|statBytes
operator|=
operator|new
name|byte
index|[
name|ArrayUtil
operator|.
name|oversize
argument_list|(
name|numBytes
argument_list|,
literal|1
argument_list|)
index|]
expr_stmt|;
block|}
name|in
operator|.
name|readBytes
argument_list|(
name|statBytes
argument_list|,
literal|0
argument_list|,
name|numBytes
argument_list|)
expr_stmt|;
name|statsReader
operator|.
name|reset
argument_list|(
name|statBytes
argument_list|,
literal|0
argument_list|,
name|numBytes
argument_list|)
expr_stmt|;
name|metaDataUpto
operator|=
literal|0
expr_stmt|;
name|termState
operator|.
name|termBlockOrd
operator|=
literal|0
expr_stmt|;
name|nextEnt
operator|=
literal|0
expr_stmt|;
name|postingsReader
operator|.
name|readTermsBlock
argument_list|(
name|in
argument_list|,
name|fieldInfo
argument_list|,
name|termState
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isLastInFloor
condition|)
block|{
comment|// Sub-blocks of a single floor block are always
comment|// written one after another -- tail recurse:
name|fpEnd
operator|=
name|in
operator|.
name|getFilePointer
argument_list|()
expr_stmt|;
block|}
block|}
comment|// TODO: maybe add scanToLabel; should give perf boost
DECL|method|next
specifier|public
name|boolean
name|next
parameter_list|()
block|{
return|return
name|isLeafBlock
condition|?
name|nextLeaf
argument_list|()
else|:
name|nextNonLeaf
argument_list|()
return|;
block|}
comment|// Decodes next entry; returns true if it's a sub-block
DECL|method|nextLeaf
specifier|public
name|boolean
name|nextLeaf
parameter_list|()
block|{
comment|//if (DEBUG) System.out.println("  frame.next ord=" + ord + " nextEnt=" + nextEnt + " entCount=" + entCount);
assert|assert
name|nextEnt
operator|!=
operator|-
literal|1
operator|&&
name|nextEnt
operator|<
name|entCount
operator|:
literal|"nextEnt="
operator|+
name|nextEnt
operator|+
literal|" entCount="
operator|+
name|entCount
operator|+
literal|" fp="
operator|+
name|fp
assert|;
name|nextEnt
operator|++
expr_stmt|;
name|suffix
operator|=
name|suffixesReader
operator|.
name|readVInt
argument_list|()
expr_stmt|;
name|startBytePos
operator|=
name|suffixesReader
operator|.
name|getPosition
argument_list|()
expr_stmt|;
name|suffixesReader
operator|.
name|skipBytes
argument_list|(
name|suffix
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
DECL|method|nextNonLeaf
specifier|public
name|boolean
name|nextNonLeaf
parameter_list|()
block|{
comment|//if (DEBUG) System.out.println("  frame.next ord=" + ord + " nextEnt=" + nextEnt + " entCount=" + entCount);
assert|assert
name|nextEnt
operator|!=
operator|-
literal|1
operator|&&
name|nextEnt
operator|<
name|entCount
operator|:
literal|"nextEnt="
operator|+
name|nextEnt
operator|+
literal|" entCount="
operator|+
name|entCount
operator|+
literal|" fp="
operator|+
name|fp
assert|;
name|nextEnt
operator|++
expr_stmt|;
specifier|final
name|int
name|code
init|=
name|suffixesReader
operator|.
name|readVInt
argument_list|()
decl_stmt|;
name|suffix
operator|=
name|code
operator|>>>
literal|1
expr_stmt|;
name|startBytePos
operator|=
name|suffixesReader
operator|.
name|getPosition
argument_list|()
expr_stmt|;
name|suffixesReader
operator|.
name|skipBytes
argument_list|(
name|suffix
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|code
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
block|{
comment|// A normal term
name|termState
operator|.
name|termBlockOrd
operator|++
expr_stmt|;
return|return
literal|false
return|;
block|}
else|else
block|{
comment|// A sub-block; make sub-FP absolute:
name|lastSubFP
operator|=
name|fp
operator|-
name|suffixesReader
operator|.
name|readVLong
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
DECL|method|getTermBlockOrd
specifier|public
name|int
name|getTermBlockOrd
parameter_list|()
block|{
return|return
name|isLeafBlock
condition|?
name|nextEnt
else|:
name|termState
operator|.
name|termBlockOrd
return|;
block|}
DECL|method|decodeMetaData
specifier|public
name|void
name|decodeMetaData
parameter_list|()
throws|throws
name|IOException
block|{
comment|// lazily catch up on metadata decode:
specifier|final
name|int
name|limit
init|=
name|getTermBlockOrd
argument_list|()
decl_stmt|;
assert|assert
name|limit
operator|>
literal|0
assert|;
comment|// We must set/incr state.termCount because
comment|// postings impl can look at this
name|termState
operator|.
name|termBlockOrd
operator|=
name|metaDataUpto
expr_stmt|;
comment|// TODO: better API would be "jump straight to term=N"???
while|while
condition|(
name|metaDataUpto
operator|<
name|limit
condition|)
block|{
comment|// TODO: we could make "tiers" of metadata, ie,
comment|// decode docFreq/totalTF but don't decode postings
comment|// metadata; this way caller could get
comment|// docFreq/totalTF w/o paying decode cost for
comment|// postings
comment|// TODO: if docFreq were bulk decoded we could
comment|// just skipN here:
name|termState
operator|.
name|docFreq
operator|=
name|statsReader
operator|.
name|readVInt
argument_list|()
expr_stmt|;
comment|//if (DEBUG) System.out.println("    dF=" + state.docFreq);
if|if
condition|(
name|fieldInfo
operator|.
name|getIndexOptions
argument_list|()
operator|!=
name|IndexOptions
operator|.
name|DOCS_ONLY
condition|)
block|{
name|termState
operator|.
name|totalTermFreq
operator|=
name|termState
operator|.
name|docFreq
operator|+
name|statsReader
operator|.
name|readVLong
argument_list|()
expr_stmt|;
comment|//if (DEBUG) System.out.println("    totTF=" + state.totalTermFreq);
block|}
name|postingsReader
operator|.
name|nextTerm
argument_list|(
name|fieldInfo
argument_list|,
name|termState
argument_list|)
expr_stmt|;
name|metaDataUpto
operator|++
expr_stmt|;
name|termState
operator|.
name|termBlockOrd
operator|++
expr_stmt|;
block|}
block|}
block|}
DECL|field|savedStartTerm
specifier|private
name|BytesRef
name|savedStartTerm
decl_stmt|;
comment|// TODO: in some cases we can filter by length?  eg
comment|// regexp foo*bar must be at least length 6 bytes
DECL|method|IntersectEnum
specifier|public
name|IntersectEnum
parameter_list|(
name|CompiledAutomaton
name|compiled
parameter_list|,
name|BytesRef
name|startTerm
parameter_list|)
throws|throws
name|IOException
block|{
comment|// if (DEBUG) {
comment|//   System.out.println("\nintEnum.init seg=" + segment + " commonSuffix=" + brToString(compiled.commonSuffixRef));
comment|// }
name|runAutomaton
operator|=
name|compiled
operator|.
name|runAutomaton
expr_stmt|;
name|compiledAutomaton
operator|=
name|compiled
expr_stmt|;
name|in
operator|=
operator|(
name|IndexInput
operator|)
name|BlockTreeTermsReader
operator|.
name|this
operator|.
name|in
operator|.
name|clone
argument_list|()
expr_stmt|;
name|stack
operator|=
operator|new
name|Frame
index|[
literal|5
index|]
expr_stmt|;
for|for
control|(
name|int
name|idx
init|=
literal|0
init|;
name|idx
operator|<
name|stack
operator|.
name|length
condition|;
name|idx
operator|++
control|)
block|{
name|stack
index|[
name|idx
index|]
operator|=
operator|new
name|Frame
argument_list|(
name|idx
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|arcIdx
init|=
literal|0
init|;
name|arcIdx
operator|<
name|arcs
operator|.
name|length
condition|;
name|arcIdx
operator|++
control|)
block|{
name|arcs
index|[
name|arcIdx
index|]
operator|=
operator|new
name|FST
operator|.
name|Arc
argument_list|<
name|BytesRef
argument_list|>
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|index
operator|==
literal|null
condition|)
block|{
name|fstReader
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
name|fstReader
operator|=
name|index
operator|.
name|getBytesReader
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|// TODO: if the automaton is "smallish" we really
comment|// should use the terms index to seek at least to
comment|// the initial term and likely to subsequent terms
comment|// (or, maybe just fallback to ATE for such cases).
comment|// Else the seek cost of loading the frames will be
comment|// too costly.
specifier|final
name|FST
operator|.
name|Arc
argument_list|<
name|BytesRef
argument_list|>
name|arc
init|=
name|index
operator|.
name|getFirstArc
argument_list|(
name|arcs
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
comment|// Empty string prefix must have an output in the index!
assert|assert
name|arc
operator|.
name|isFinal
argument_list|()
assert|;
comment|// Special pushFrame since it's the first one:
specifier|final
name|Frame
name|f
init|=
name|stack
index|[
literal|0
index|]
decl_stmt|;
name|f
operator|.
name|fp
operator|=
name|f
operator|.
name|fpOrig
operator|=
name|rootBlockFP
expr_stmt|;
name|f
operator|.
name|prefix
operator|=
literal|0
expr_stmt|;
name|f
operator|.
name|setState
argument_list|(
name|runAutomaton
operator|.
name|getInitialState
argument_list|()
argument_list|)
expr_stmt|;
name|f
operator|.
name|arc
operator|=
name|arc
expr_stmt|;
name|f
operator|.
name|outputPrefix
operator|=
name|arc
operator|.
name|output
expr_stmt|;
name|f
operator|.
name|load
argument_list|(
name|rootCode
argument_list|)
expr_stmt|;
comment|// for assert:
assert|assert
name|setSavedStartTerm
argument_list|(
name|startTerm
argument_list|)
assert|;
name|currentFrame
operator|=
name|f
expr_stmt|;
if|if
condition|(
name|startTerm
operator|!=
literal|null
condition|)
block|{
name|seekToStartTerm
argument_list|(
name|startTerm
argument_list|)
expr_stmt|;
block|}
block|}
comment|// only for assert:
DECL|method|setSavedStartTerm
specifier|private
name|boolean
name|setSavedStartTerm
parameter_list|(
name|BytesRef
name|startTerm
parameter_list|)
block|{
name|savedStartTerm
operator|=
name|startTerm
operator|==
literal|null
condition|?
literal|null
else|:
name|BytesRef
operator|.
name|deepCopyOf
argument_list|(
name|startTerm
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
annotation|@
name|Override
DECL|method|termState
specifier|public
name|TermState
name|termState
parameter_list|()
throws|throws
name|IOException
block|{
name|currentFrame
operator|.
name|decodeMetaData
argument_list|()
expr_stmt|;
return|return
name|currentFrame
operator|.
name|termState
operator|.
name|clone
argument_list|()
return|;
block|}
DECL|method|getFrame
specifier|private
name|Frame
name|getFrame
parameter_list|(
name|int
name|ord
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|ord
operator|>=
name|stack
operator|.
name|length
condition|)
block|{
specifier|final
name|Frame
index|[]
name|next
init|=
operator|new
name|Frame
index|[
name|ArrayUtil
operator|.
name|oversize
argument_list|(
literal|1
operator|+
name|ord
argument_list|,
name|RamUsageEstimator
operator|.
name|NUM_BYTES_OBJECT_REF
argument_list|)
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|stack
argument_list|,
literal|0
argument_list|,
name|next
argument_list|,
literal|0
argument_list|,
name|stack
operator|.
name|length
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|stackOrd
init|=
name|stack
operator|.
name|length
init|;
name|stackOrd
operator|<
name|next
operator|.
name|length
condition|;
name|stackOrd
operator|++
control|)
block|{
name|next
index|[
name|stackOrd
index|]
operator|=
operator|new
name|Frame
argument_list|(
name|stackOrd
argument_list|)
expr_stmt|;
block|}
name|stack
operator|=
name|next
expr_stmt|;
block|}
assert|assert
name|stack
index|[
name|ord
index|]
operator|.
name|ord
operator|==
name|ord
assert|;
return|return
name|stack
index|[
name|ord
index|]
return|;
block|}
DECL|method|getArc
specifier|private
name|FST
operator|.
name|Arc
argument_list|<
name|BytesRef
argument_list|>
name|getArc
parameter_list|(
name|int
name|ord
parameter_list|)
block|{
if|if
condition|(
name|ord
operator|>=
name|arcs
operator|.
name|length
condition|)
block|{
annotation|@
name|SuppressWarnings
argument_list|(
block|{
literal|"rawtypes"
block|,
literal|"unchecked"
block|}
argument_list|)
specifier|final
name|FST
operator|.
name|Arc
argument_list|<
name|BytesRef
argument_list|>
index|[]
name|next
init|=
operator|new
name|FST
operator|.
name|Arc
index|[
name|ArrayUtil
operator|.
name|oversize
argument_list|(
literal|1
operator|+
name|ord
argument_list|,
name|RamUsageEstimator
operator|.
name|NUM_BYTES_OBJECT_REF
argument_list|)
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|arcs
argument_list|,
literal|0
argument_list|,
name|next
argument_list|,
literal|0
argument_list|,
name|arcs
operator|.
name|length
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|arcOrd
init|=
name|arcs
operator|.
name|length
init|;
name|arcOrd
operator|<
name|next
operator|.
name|length
condition|;
name|arcOrd
operator|++
control|)
block|{
name|next
index|[
name|arcOrd
index|]
operator|=
operator|new
name|FST
operator|.
name|Arc
argument_list|<
name|BytesRef
argument_list|>
argument_list|()
expr_stmt|;
block|}
name|arcs
operator|=
name|next
expr_stmt|;
block|}
return|return
name|arcs
index|[
name|ord
index|]
return|;
block|}
DECL|method|pushFrame
specifier|private
name|Frame
name|pushFrame
parameter_list|(
name|int
name|state
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|Frame
name|f
init|=
name|getFrame
argument_list|(
name|currentFrame
operator|==
literal|null
condition|?
literal|0
else|:
literal|1
operator|+
name|currentFrame
operator|.
name|ord
argument_list|)
decl_stmt|;
name|f
operator|.
name|fp
operator|=
name|f
operator|.
name|fpOrig
operator|=
name|currentFrame
operator|.
name|lastSubFP
expr_stmt|;
name|f
operator|.
name|prefix
operator|=
name|currentFrame
operator|.
name|prefix
operator|+
name|currentFrame
operator|.
name|suffix
expr_stmt|;
comment|// if (DEBUG) System.out.println("    pushFrame state=" + state + " prefix=" + f.prefix);
name|f
operator|.
name|setState
argument_list|(
name|state
argument_list|)
expr_stmt|;
comment|// Walk the arc through the index -- we only
comment|// "bother" with this so we can get the floor data
comment|// from the index and skip floor blocks when
comment|// possible:
name|FST
operator|.
name|Arc
argument_list|<
name|BytesRef
argument_list|>
name|arc
init|=
name|currentFrame
operator|.
name|arc
decl_stmt|;
name|int
name|idx
init|=
name|currentFrame
operator|.
name|prefix
decl_stmt|;
assert|assert
name|currentFrame
operator|.
name|suffix
operator|>
literal|0
assert|;
name|BytesRef
name|output
init|=
name|currentFrame
operator|.
name|outputPrefix
decl_stmt|;
while|while
condition|(
name|idx
operator|<
name|f
operator|.
name|prefix
condition|)
block|{
specifier|final
name|int
name|target
init|=
name|term
operator|.
name|bytes
index|[
name|idx
index|]
operator|&
literal|0xff
decl_stmt|;
comment|// TODO: we could be more efficient for the next()
comment|// case by using current arc as starting point,
comment|// passed to findTargetArc
name|arc
operator|=
name|index
operator|.
name|findTargetArc
argument_list|(
name|target
argument_list|,
name|arc
argument_list|,
name|getArc
argument_list|(
literal|1
operator|+
name|idx
argument_list|)
argument_list|,
name|fstReader
argument_list|)
expr_stmt|;
assert|assert
name|arc
operator|!=
literal|null
assert|;
name|output
operator|=
name|fstOutputs
operator|.
name|add
argument_list|(
name|output
argument_list|,
name|arc
operator|.
name|output
argument_list|)
expr_stmt|;
name|idx
operator|++
expr_stmt|;
block|}
name|f
operator|.
name|arc
operator|=
name|arc
expr_stmt|;
name|f
operator|.
name|outputPrefix
operator|=
name|output
expr_stmt|;
assert|assert
name|arc
operator|.
name|isFinal
argument_list|()
assert|;
name|f
operator|.
name|load
argument_list|(
name|fstOutputs
operator|.
name|add
argument_list|(
name|output
argument_list|,
name|arc
operator|.
name|nextFinalOutput
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|f
return|;
block|}
annotation|@
name|Override
DECL|method|term
specifier|public
name|BytesRef
name|term
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|term
return|;
block|}
annotation|@
name|Override
DECL|method|docFreq
specifier|public
name|int
name|docFreq
parameter_list|()
throws|throws
name|IOException
block|{
comment|//if (DEBUG) System.out.println("BTIR.docFreq");
name|currentFrame
operator|.
name|decodeMetaData
argument_list|()
expr_stmt|;
comment|//if (DEBUG) System.out.println("  return " + currentFrame.termState.docFreq);
return|return
name|currentFrame
operator|.
name|termState
operator|.
name|docFreq
return|;
block|}
annotation|@
name|Override
DECL|method|totalTermFreq
specifier|public
name|long
name|totalTermFreq
parameter_list|()
throws|throws
name|IOException
block|{
name|currentFrame
operator|.
name|decodeMetaData
argument_list|()
expr_stmt|;
return|return
name|currentFrame
operator|.
name|termState
operator|.
name|totalTermFreq
return|;
block|}
annotation|@
name|Override
DECL|method|docs
specifier|public
name|DocsEnum
name|docs
parameter_list|(
name|Bits
name|skipDocs
parameter_list|,
name|DocsEnum
name|reuse
parameter_list|,
name|boolean
name|needsFreqs
parameter_list|)
throws|throws
name|IOException
block|{
name|currentFrame
operator|.
name|decodeMetaData
argument_list|()
expr_stmt|;
return|return
name|postingsReader
operator|.
name|docs
argument_list|(
name|fieldInfo
argument_list|,
name|currentFrame
operator|.
name|termState
argument_list|,
name|skipDocs
argument_list|,
name|reuse
argument_list|,
name|needsFreqs
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|docsAndPositions
specifier|public
name|DocsAndPositionsEnum
name|docsAndPositions
parameter_list|(
name|Bits
name|skipDocs
parameter_list|,
name|DocsAndPositionsEnum
name|reuse
parameter_list|,
name|boolean
name|needsOffsets
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|fieldInfo
operator|.
name|getIndexOptions
argument_list|()
operator|.
name|compareTo
argument_list|(
name|IndexOptions
operator|.
name|DOCS_AND_FREQS_AND_POSITIONS
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|// Positions were not indexed:
return|return
literal|null
return|;
block|}
if|if
condition|(
name|needsOffsets
operator|&&
name|fieldInfo
operator|.
name|getIndexOptions
argument_list|()
operator|.
name|compareTo
argument_list|(
name|IndexOptions
operator|.
name|DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|// Offsets were not indexed:
return|return
literal|null
return|;
block|}
name|currentFrame
operator|.
name|decodeMetaData
argument_list|()
expr_stmt|;
return|return
name|postingsReader
operator|.
name|docsAndPositions
argument_list|(
name|fieldInfo
argument_list|,
name|currentFrame
operator|.
name|termState
argument_list|,
name|skipDocs
argument_list|,
name|reuse
argument_list|,
name|needsOffsets
argument_list|)
return|;
block|}
DECL|method|getState
specifier|private
name|int
name|getState
parameter_list|()
block|{
name|int
name|state
init|=
name|currentFrame
operator|.
name|state
decl_stmt|;
for|for
control|(
name|int
name|idx
init|=
literal|0
init|;
name|idx
operator|<
name|currentFrame
operator|.
name|suffix
condition|;
name|idx
operator|++
control|)
block|{
name|state
operator|=
name|runAutomaton
operator|.
name|step
argument_list|(
name|state
argument_list|,
name|currentFrame
operator|.
name|suffixBytes
index|[
name|currentFrame
operator|.
name|startBytePos
operator|+
name|idx
index|]
operator|&
literal|0xff
argument_list|)
expr_stmt|;
assert|assert
name|state
operator|!=
operator|-
literal|1
assert|;
block|}
return|return
name|state
return|;
block|}
comment|// NOTE: specialized to only doing the first-time
comment|// seek, but we could generalize it to allow
comment|// arbitrary seekExact/Ceil.  Note that this is a
comment|// seekFloor!
DECL|method|seekToStartTerm
specifier|private
name|void
name|seekToStartTerm
parameter_list|(
name|BytesRef
name|target
parameter_list|)
throws|throws
name|IOException
block|{
comment|//if (DEBUG) System.out.println("seek to startTerm=" + target.utf8ToString());
assert|assert
name|currentFrame
operator|.
name|ord
operator|==
literal|0
assert|;
if|if
condition|(
name|term
operator|.
name|length
operator|<
name|target
operator|.
name|length
condition|)
block|{
name|term
operator|.
name|bytes
operator|=
name|ArrayUtil
operator|.
name|grow
argument_list|(
name|term
operator|.
name|bytes
argument_list|,
name|target
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
name|FST
operator|.
name|Arc
argument_list|<
name|BytesRef
argument_list|>
name|arc
init|=
name|arcs
index|[
literal|0
index|]
decl_stmt|;
assert|assert
name|arc
operator|==
name|currentFrame
operator|.
name|arc
assert|;
for|for
control|(
name|int
name|idx
init|=
literal|0
init|;
name|idx
operator|<=
name|target
operator|.
name|length
condition|;
name|idx
operator|++
control|)
block|{
while|while
condition|(
literal|true
condition|)
block|{
specifier|final
name|int
name|savePos
init|=
name|currentFrame
operator|.
name|suffixesReader
operator|.
name|getPosition
argument_list|()
decl_stmt|;
specifier|final
name|int
name|saveStartBytePos
init|=
name|currentFrame
operator|.
name|startBytePos
decl_stmt|;
specifier|final
name|int
name|saveSuffix
init|=
name|currentFrame
operator|.
name|suffix
decl_stmt|;
specifier|final
name|long
name|saveLastSubFP
init|=
name|currentFrame
operator|.
name|lastSubFP
decl_stmt|;
specifier|final
name|int
name|saveTermBlockOrd
init|=
name|currentFrame
operator|.
name|termState
operator|.
name|termBlockOrd
decl_stmt|;
specifier|final
name|boolean
name|isSubBlock
init|=
name|currentFrame
operator|.
name|next
argument_list|()
decl_stmt|;
comment|//if (DEBUG) System.out.println("    cycle ent=" + currentFrame.nextEnt + " (of " + currentFrame.entCount + ") prefix=" + currentFrame.prefix + " suffix=" + currentFrame.suffix + " isBlock=" + isSubBlock + " firstLabel=" + (currentFrame.suffix == 0 ? "" : (currentFrame.suffixBytes[currentFrame.startBytePos])&0xff));
name|term
operator|.
name|length
operator|=
name|currentFrame
operator|.
name|prefix
operator|+
name|currentFrame
operator|.
name|suffix
expr_stmt|;
if|if
condition|(
name|term
operator|.
name|bytes
operator|.
name|length
operator|<
name|term
operator|.
name|length
condition|)
block|{
name|term
operator|.
name|bytes
operator|=
name|ArrayUtil
operator|.
name|grow
argument_list|(
name|term
operator|.
name|bytes
argument_list|,
name|term
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
name|System
operator|.
name|arraycopy
argument_list|(
name|currentFrame
operator|.
name|suffixBytes
argument_list|,
name|currentFrame
operator|.
name|startBytePos
argument_list|,
name|term
operator|.
name|bytes
argument_list|,
name|currentFrame
operator|.
name|prefix
argument_list|,
name|currentFrame
operator|.
name|suffix
argument_list|)
expr_stmt|;
if|if
condition|(
name|isSubBlock
operator|&&
name|StringHelper
operator|.
name|startsWith
argument_list|(
name|target
argument_list|,
name|term
argument_list|)
condition|)
block|{
comment|// Recurse
comment|//if (DEBUG) System.out.println("      recurse!");
name|currentFrame
operator|=
name|pushFrame
argument_list|(
name|getState
argument_list|()
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
block|{
specifier|final
name|int
name|cmp
init|=
name|term
operator|.
name|compareTo
argument_list|(
name|target
argument_list|)
decl_stmt|;
if|if
condition|(
name|cmp
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|currentFrame
operator|.
name|nextEnt
operator|==
name|currentFrame
operator|.
name|entCount
condition|)
block|{
if|if
condition|(
operator|!
name|currentFrame
operator|.
name|isLastInFloor
condition|)
block|{
comment|//if (DEBUG) System.out.println("  load floorBlock");
name|currentFrame
operator|.
name|loadNextFloorBlock
argument_list|()
expr_stmt|;
continue|continue;
block|}
else|else
block|{
comment|//if (DEBUG) System.out.println("  return term=" + brToString(term));
return|return;
block|}
block|}
continue|continue;
block|}
elseif|else
if|if
condition|(
name|cmp
operator|==
literal|0
condition|)
block|{
comment|//if (DEBUG) System.out.println("  return term=" + brToString(term));
return|return;
block|}
else|else
block|{
comment|// Fallback to prior entry: the semantics of
comment|// this method is that the first call to
comment|// next() will return the term after the
comment|// requested term
name|currentFrame
operator|.
name|nextEnt
operator|--
expr_stmt|;
name|currentFrame
operator|.
name|lastSubFP
operator|=
name|saveLastSubFP
expr_stmt|;
name|currentFrame
operator|.
name|startBytePos
operator|=
name|saveStartBytePos
expr_stmt|;
name|currentFrame
operator|.
name|suffix
operator|=
name|saveSuffix
expr_stmt|;
name|currentFrame
operator|.
name|suffixesReader
operator|.
name|setPosition
argument_list|(
name|savePos
argument_list|)
expr_stmt|;
name|currentFrame
operator|.
name|termState
operator|.
name|termBlockOrd
operator|=
name|saveTermBlockOrd
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|currentFrame
operator|.
name|suffixBytes
argument_list|,
name|currentFrame
operator|.
name|startBytePos
argument_list|,
name|term
operator|.
name|bytes
argument_list|,
name|currentFrame
operator|.
name|prefix
argument_list|,
name|currentFrame
operator|.
name|suffix
argument_list|)
expr_stmt|;
name|term
operator|.
name|length
operator|=
name|currentFrame
operator|.
name|prefix
operator|+
name|currentFrame
operator|.
name|suffix
expr_stmt|;
comment|// If the last entry was a block we don't
comment|// need to bother recursing and pushing to
comment|// the last term under it because the first
comment|// next() will simply skip the frame anyway
return|return;
block|}
block|}
block|}
block|}
assert|assert
literal|false
assert|;
block|}
annotation|@
name|Override
DECL|method|next
specifier|public
name|BytesRef
name|next
parameter_list|()
throws|throws
name|IOException
block|{
comment|// if (DEBUG) {
comment|//   System.out.println("\nintEnum.next seg=" + segment);
comment|//   System.out.println("  frame ord=" + currentFrame.ord + " prefix=" + brToString(new BytesRef(term.bytes, term.offset, currentFrame.prefix)) + " state=" + currentFrame.state + " lastInFloor?=" + currentFrame.isLastInFloor + " fp=" + currentFrame.fp + " trans=" + (currentFrame.transitions.length == 0 ? "n/a" : currentFrame.transitions[currentFrame.transitionIndex]) + " outputPrefix=" + currentFrame.outputPrefix);
comment|// }
name|nextTerm
label|:
while|while
condition|(
literal|true
condition|)
block|{
comment|// Pop finished frames
while|while
condition|(
name|currentFrame
operator|.
name|nextEnt
operator|==
name|currentFrame
operator|.
name|entCount
condition|)
block|{
if|if
condition|(
operator|!
name|currentFrame
operator|.
name|isLastInFloor
condition|)
block|{
comment|//if (DEBUG) System.out.println("    next-floor-block");
name|currentFrame
operator|.
name|loadNextFloorBlock
argument_list|()
expr_stmt|;
comment|//if (DEBUG) System.out.println("\n  frame ord=" + currentFrame.ord + " prefix=" + brToString(new BytesRef(term.bytes, term.offset, currentFrame.prefix)) + " state=" + currentFrame.state + " lastInFloor?=" + currentFrame.isLastInFloor + " fp=" + currentFrame.fp + " trans=" + (currentFrame.transitions.length == 0 ? "n/a" : currentFrame.transitions[currentFrame.transitionIndex]) + " outputPrefix=" + currentFrame.outputPrefix);
block|}
else|else
block|{
comment|//if (DEBUG) System.out.println("  pop frame");
if|if
condition|(
name|currentFrame
operator|.
name|ord
operator|==
literal|0
condition|)
block|{
return|return
literal|null
return|;
block|}
specifier|final
name|long
name|lastFP
init|=
name|currentFrame
operator|.
name|fpOrig
decl_stmt|;
name|currentFrame
operator|=
name|stack
index|[
name|currentFrame
operator|.
name|ord
operator|-
literal|1
index|]
expr_stmt|;
assert|assert
name|currentFrame
operator|.
name|lastSubFP
operator|==
name|lastFP
assert|;
comment|//if (DEBUG) System.out.println("\n  frame ord=" + currentFrame.ord + " prefix=" + brToString(new BytesRef(term.bytes, term.offset, currentFrame.prefix)) + " state=" + currentFrame.state + " lastInFloor?=" + currentFrame.isLastInFloor + " fp=" + currentFrame.fp + " trans=" + (currentFrame.transitions.length == 0 ? "n/a" : currentFrame.transitions[currentFrame.transitionIndex]) + " outputPrefix=" + currentFrame.outputPrefix);
block|}
block|}
specifier|final
name|boolean
name|isSubBlock
init|=
name|currentFrame
operator|.
name|next
argument_list|()
decl_stmt|;
comment|// if (DEBUG) {
comment|//   final BytesRef suffixRef = new BytesRef();
comment|//   suffixRef.bytes = currentFrame.suffixBytes;
comment|//   suffixRef.offset = currentFrame.startBytePos;
comment|//   suffixRef.length = currentFrame.suffix;
comment|//   System.out.println("    " + (isSubBlock ? "sub-block" : "term") + " " + currentFrame.nextEnt + " (of " + currentFrame.entCount + ") suffix=" + brToString(suffixRef));
comment|// }
if|if
condition|(
name|currentFrame
operator|.
name|suffix
operator|!=
literal|0
condition|)
block|{
specifier|final
name|int
name|label
init|=
name|currentFrame
operator|.
name|suffixBytes
index|[
name|currentFrame
operator|.
name|startBytePos
index|]
operator|&
literal|0xff
decl_stmt|;
while|while
condition|(
name|label
operator|>
name|currentFrame
operator|.
name|curTransitionMax
condition|)
block|{
if|if
condition|(
name|currentFrame
operator|.
name|transitionIndex
operator|>=
name|currentFrame
operator|.
name|transitions
operator|.
name|length
operator|-
literal|1
condition|)
block|{
comment|// Stop processing this frame -- no further
comment|// matches are possible because we've moved
comment|// beyond what the max transition will allow
comment|//if (DEBUG) System.out.println("      break: trans=" + (currentFrame.transitions.length == 0 ? "n/a" : currentFrame.transitions[currentFrame.transitionIndex]));
comment|// sneaky!  forces a pop above
name|currentFrame
operator|.
name|isLastInFloor
operator|=
literal|true
expr_stmt|;
name|currentFrame
operator|.
name|nextEnt
operator|=
name|currentFrame
operator|.
name|entCount
expr_stmt|;
continue|continue
name|nextTerm
continue|;
block|}
name|currentFrame
operator|.
name|transitionIndex
operator|++
expr_stmt|;
name|currentFrame
operator|.
name|curTransitionMax
operator|=
name|currentFrame
operator|.
name|transitions
index|[
name|currentFrame
operator|.
name|transitionIndex
index|]
operator|.
name|getMax
argument_list|()
expr_stmt|;
comment|//if (DEBUG) System.out.println("      next trans=" + currentFrame.transitions[currentFrame.transitionIndex]);
block|}
block|}
comment|// First test the common suffix, if set:
if|if
condition|(
name|compiledAutomaton
operator|.
name|commonSuffixRef
operator|!=
literal|null
operator|&&
operator|!
name|isSubBlock
condition|)
block|{
specifier|final
name|int
name|termLen
init|=
name|currentFrame
operator|.
name|prefix
operator|+
name|currentFrame
operator|.
name|suffix
decl_stmt|;
if|if
condition|(
name|termLen
operator|<
name|compiledAutomaton
operator|.
name|commonSuffixRef
operator|.
name|length
condition|)
block|{
comment|// No match
comment|// if (DEBUG) {
comment|//   System.out.println("      skip: common suffix length");
comment|// }
continue|continue
name|nextTerm
continue|;
block|}
specifier|final
name|byte
index|[]
name|suffixBytes
init|=
name|currentFrame
operator|.
name|suffixBytes
decl_stmt|;
specifier|final
name|byte
index|[]
name|commonSuffixBytes
init|=
name|compiledAutomaton
operator|.
name|commonSuffixRef
operator|.
name|bytes
decl_stmt|;
specifier|final
name|int
name|lenInPrefix
init|=
name|compiledAutomaton
operator|.
name|commonSuffixRef
operator|.
name|length
operator|-
name|currentFrame
operator|.
name|suffix
decl_stmt|;
assert|assert
name|compiledAutomaton
operator|.
name|commonSuffixRef
operator|.
name|offset
operator|==
literal|0
assert|;
name|int
name|suffixBytesPos
decl_stmt|;
name|int
name|commonSuffixBytesPos
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|lenInPrefix
operator|>
literal|0
condition|)
block|{
comment|// A prefix of the common suffix overlaps with
comment|// the suffix of the block prefix so we first
comment|// test whether the prefix part matches:
specifier|final
name|byte
index|[]
name|termBytes
init|=
name|term
operator|.
name|bytes
decl_stmt|;
name|int
name|termBytesPos
init|=
name|currentFrame
operator|.
name|prefix
operator|-
name|lenInPrefix
decl_stmt|;
assert|assert
name|termBytesPos
operator|>=
literal|0
assert|;
specifier|final
name|int
name|termBytesPosEnd
init|=
name|currentFrame
operator|.
name|prefix
decl_stmt|;
while|while
condition|(
name|termBytesPos
operator|<
name|termBytesPosEnd
condition|)
block|{
if|if
condition|(
name|termBytes
index|[
name|termBytesPos
operator|++
index|]
operator|!=
name|commonSuffixBytes
index|[
name|commonSuffixBytesPos
operator|++
index|]
condition|)
block|{
comment|// if (DEBUG) {
comment|//   System.out.println("      skip: common suffix mismatch (in prefix)");
comment|// }
continue|continue
name|nextTerm
continue|;
block|}
block|}
name|suffixBytesPos
operator|=
name|currentFrame
operator|.
name|startBytePos
expr_stmt|;
block|}
else|else
block|{
name|suffixBytesPos
operator|=
name|currentFrame
operator|.
name|startBytePos
operator|+
name|currentFrame
operator|.
name|suffix
operator|-
name|compiledAutomaton
operator|.
name|commonSuffixRef
operator|.
name|length
expr_stmt|;
block|}
comment|// Test overlapping suffix part:
specifier|final
name|int
name|commonSuffixBytesPosEnd
init|=
name|compiledAutomaton
operator|.
name|commonSuffixRef
operator|.
name|length
decl_stmt|;
while|while
condition|(
name|commonSuffixBytesPos
operator|<
name|commonSuffixBytesPosEnd
condition|)
block|{
if|if
condition|(
name|suffixBytes
index|[
name|suffixBytesPos
operator|++
index|]
operator|!=
name|commonSuffixBytes
index|[
name|commonSuffixBytesPos
operator|++
index|]
condition|)
block|{
comment|// if (DEBUG) {
comment|//   System.out.println("      skip: common suffix mismatch");
comment|// }
continue|continue
name|nextTerm
continue|;
block|}
block|}
block|}
comment|// TODO: maybe we should do the same linear test
comment|// that AutomatonTermsEnum does, so that if we
comment|// reach a part of the automaton where .* is
comment|// "temporarily" accepted, we just blindly .next()
comment|// until the limit
comment|// See if the term prefix matches the automaton:
name|int
name|state
init|=
name|currentFrame
operator|.
name|state
decl_stmt|;
for|for
control|(
name|int
name|idx
init|=
literal|0
init|;
name|idx
operator|<
name|currentFrame
operator|.
name|suffix
condition|;
name|idx
operator|++
control|)
block|{
name|state
operator|=
name|runAutomaton
operator|.
name|step
argument_list|(
name|state
argument_list|,
name|currentFrame
operator|.
name|suffixBytes
index|[
name|currentFrame
operator|.
name|startBytePos
operator|+
name|idx
index|]
operator|&
literal|0xff
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|==
operator|-
literal|1
condition|)
block|{
comment|// No match
comment|//System.out.println("    no s=" + state);
continue|continue
name|nextTerm
continue|;
block|}
else|else
block|{
comment|//System.out.println("    c s=" + state);
block|}
block|}
if|if
condition|(
name|isSubBlock
condition|)
block|{
comment|// Match!  Recurse:
comment|//if (DEBUG) System.out.println("      sub-block match to state=" + state + "; recurse fp=" + currentFrame.lastSubFP);
name|copyTerm
argument_list|()
expr_stmt|;
name|currentFrame
operator|=
name|pushFrame
argument_list|(
name|state
argument_list|)
expr_stmt|;
comment|//if (DEBUG) System.out.println("\n  frame ord=" + currentFrame.ord + " prefix=" + brToString(new BytesRef(term.bytes, term.offset, currentFrame.prefix)) + " state=" + currentFrame.state + " lastInFloor?=" + currentFrame.isLastInFloor + " fp=" + currentFrame.fp + " trans=" + (currentFrame.transitions.length == 0 ? "n/a" : currentFrame.transitions[currentFrame.transitionIndex]) + " outputPrefix=" + currentFrame.outputPrefix);
block|}
elseif|else
if|if
condition|(
name|runAutomaton
operator|.
name|isAccept
argument_list|(
name|state
argument_list|)
condition|)
block|{
name|copyTerm
argument_list|()
expr_stmt|;
comment|//if (DEBUG) System.out.println("      term match to state=" + state + "; return term=" + brToString(term));
assert|assert
name|savedStartTerm
operator|==
literal|null
operator|||
name|term
operator|.
name|compareTo
argument_list|(
name|savedStartTerm
argument_list|)
operator|>
literal|0
operator|:
literal|"saveStartTerm="
operator|+
name|savedStartTerm
operator|.
name|utf8ToString
argument_list|()
operator|+
literal|" term="
operator|+
name|term
operator|.
name|utf8ToString
argument_list|()
assert|;
return|return
name|term
return|;
block|}
else|else
block|{
comment|//System.out.println("    no s=" + state);
block|}
block|}
block|}
DECL|method|copyTerm
specifier|private
name|void
name|copyTerm
parameter_list|()
block|{
comment|//System.out.println("      copyTerm cur.prefix=" + currentFrame.prefix + " cur.suffix=" + currentFrame.suffix + " first=" + (char) currentFrame.suffixBytes[currentFrame.startBytePos]);
specifier|final
name|int
name|len
init|=
name|currentFrame
operator|.
name|prefix
operator|+
name|currentFrame
operator|.
name|suffix
decl_stmt|;
if|if
condition|(
name|term
operator|.
name|bytes
operator|.
name|length
operator|<
name|len
condition|)
block|{
name|term
operator|.
name|bytes
operator|=
name|ArrayUtil
operator|.
name|grow
argument_list|(
name|term
operator|.
name|bytes
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
name|System
operator|.
name|arraycopy
argument_list|(
name|currentFrame
operator|.
name|suffixBytes
argument_list|,
name|currentFrame
operator|.
name|startBytePos
argument_list|,
name|term
operator|.
name|bytes
argument_list|,
name|currentFrame
operator|.
name|prefix
argument_list|,
name|currentFrame
operator|.
name|suffix
argument_list|)
expr_stmt|;
name|term
operator|.
name|length
operator|=
name|len
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|getComparator
specifier|public
name|Comparator
argument_list|<
name|BytesRef
argument_list|>
name|getComparator
parameter_list|()
block|{
return|return
name|BytesRef
operator|.
name|getUTF8SortedAsUnicodeComparator
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|seekExact
specifier|public
name|boolean
name|seekExact
parameter_list|(
name|BytesRef
name|text
parameter_list|,
name|boolean
name|useCache
parameter_list|)
throws|throws
name|IOException
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
DECL|method|seekExact
specifier|public
name|void
name|seekExact
parameter_list|(
name|long
name|ord
parameter_list|)
throws|throws
name|IOException
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
DECL|method|ord
specifier|public
name|long
name|ord
parameter_list|()
throws|throws
name|IOException
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
DECL|method|seekCeil
specifier|public
name|SeekStatus
name|seekCeil
parameter_list|(
name|BytesRef
name|text
parameter_list|,
name|boolean
name|useCache
parameter_list|)
throws|throws
name|IOException
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
block|}
comment|// Iterates through terms in this field
DECL|class|SegmentTermsEnum
specifier|private
specifier|final
class|class
name|SegmentTermsEnum
extends|extends
name|TermsEnum
block|{
DECL|field|in
specifier|private
name|IndexInput
name|in
decl_stmt|;
DECL|field|stack
specifier|private
name|Frame
index|[]
name|stack
decl_stmt|;
DECL|field|staticFrame
specifier|private
specifier|final
name|Frame
name|staticFrame
decl_stmt|;
DECL|field|currentFrame
specifier|private
name|Frame
name|currentFrame
decl_stmt|;
DECL|field|termExists
specifier|private
name|boolean
name|termExists
decl_stmt|;
DECL|field|targetBeforeCurrentLength
specifier|private
name|int
name|targetBeforeCurrentLength
decl_stmt|;
DECL|field|scratchReader
specifier|private
specifier|final
name|ByteArrayDataInput
name|scratchReader
init|=
operator|new
name|ByteArrayDataInput
argument_list|()
decl_stmt|;
comment|// What prefix of the current term was present in the index:
DECL|field|validIndexPrefix
specifier|private
name|int
name|validIndexPrefix
decl_stmt|;
comment|// assert only:
DECL|field|eof
specifier|private
name|boolean
name|eof
decl_stmt|;
DECL|field|term
specifier|final
name|BytesRef
name|term
init|=
operator|new
name|BytesRef
argument_list|()
decl_stmt|;
DECL|field|fstReader
specifier|private
specifier|final
name|FST
operator|.
name|BytesReader
name|fstReader
decl_stmt|;
DECL|field|arcs
annotation|@
name|SuppressWarnings
argument_list|(
block|{
literal|"rawtypes"
block|,
literal|"unchecked"
block|}
argument_list|)
specifier|private
name|FST
operator|.
name|Arc
argument_list|<
name|BytesRef
argument_list|>
index|[]
name|arcs
init|=
operator|new
name|FST
operator|.
name|Arc
index|[
literal|1
index|]
decl_stmt|;
DECL|method|SegmentTermsEnum
specifier|public
name|SegmentTermsEnum
parameter_list|()
throws|throws
name|IOException
block|{
comment|//if (DEBUG) System.out.println("BTTR.init seg=" + segment);
name|stack
operator|=
operator|new
name|Frame
index|[
literal|0
index|]
expr_stmt|;
comment|// Used to hold seek by TermState, or cached seek
name|staticFrame
operator|=
operator|new
name|Frame
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|==
literal|null
condition|)
block|{
name|fstReader
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
name|fstReader
operator|=
name|index
operator|.
name|getBytesReader
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|// Init w/ root block; don't use index since it may
comment|// not (and need not) have been loaded
for|for
control|(
name|int
name|arcIdx
init|=
literal|0
init|;
name|arcIdx
operator|<
name|arcs
operator|.
name|length
condition|;
name|arcIdx
operator|++
control|)
block|{
name|arcs
index|[
name|arcIdx
index|]
operator|=
operator|new
name|FST
operator|.
name|Arc
argument_list|<
name|BytesRef
argument_list|>
argument_list|()
expr_stmt|;
block|}
name|currentFrame
operator|=
name|staticFrame
expr_stmt|;
specifier|final
name|FST
operator|.
name|Arc
argument_list|<
name|BytesRef
argument_list|>
name|arc
decl_stmt|;
if|if
condition|(
name|index
operator|!=
literal|null
condition|)
block|{
name|arc
operator|=
name|index
operator|.
name|getFirstArc
argument_list|(
name|arcs
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|// Empty string prefix must have an output in the index!
assert|assert
name|arc
operator|.
name|isFinal
argument_list|()
assert|;
block|}
else|else
block|{
name|arc
operator|=
literal|null
expr_stmt|;
block|}
name|currentFrame
operator|=
name|staticFrame
expr_stmt|;
comment|//currentFrame = pushFrame(arc, rootCode, 0);
comment|//currentFrame.loadBlock();
name|validIndexPrefix
operator|=
literal|0
expr_stmt|;
comment|// if (DEBUG) {
comment|//   System.out.println("init frame state " + currentFrame.ord);
comment|//   printSeekState();
comment|// }
comment|//System.out.println();
comment|// computeBlockStats().print(System.out);
block|}
comment|// Not private to avoid synthetic access$NNN methods
DECL|method|initIndexInput
name|void
name|initIndexInput
parameter_list|()
block|{
if|if
condition|(
name|this
operator|.
name|in
operator|==
literal|null
condition|)
block|{
name|this
operator|.
name|in
operator|=
operator|(
name|IndexInput
operator|)
name|BlockTreeTermsReader
operator|.
name|this
operator|.
name|in
operator|.
name|clone
argument_list|()
expr_stmt|;
block|}
block|}
comment|/** Runs next() through the entire terms dict,        *  computing aggregate statistics. */
DECL|method|computeBlockStats
specifier|public
name|Stats
name|computeBlockStats
parameter_list|()
throws|throws
name|IOException
block|{
name|Stats
name|stats
init|=
operator|new
name|Stats
argument_list|(
name|segment
argument_list|,
name|fieldInfo
operator|.
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|index
operator|!=
literal|null
condition|)
block|{
name|stats
operator|.
name|indexNodeCount
operator|=
name|index
operator|.
name|getNodeCount
argument_list|()
expr_stmt|;
name|stats
operator|.
name|indexArcCount
operator|=
name|index
operator|.
name|getArcCount
argument_list|()
expr_stmt|;
name|stats
operator|.
name|indexNumBytes
operator|=
name|index
operator|.
name|sizeInBytes
argument_list|()
expr_stmt|;
block|}
name|currentFrame
operator|=
name|staticFrame
expr_stmt|;
name|FST
operator|.
name|Arc
argument_list|<
name|BytesRef
argument_list|>
name|arc
decl_stmt|;
if|if
condition|(
name|index
operator|!=
literal|null
condition|)
block|{
name|arc
operator|=
name|index
operator|.
name|getFirstArc
argument_list|(
name|arcs
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|// Empty string prefix must have an output in the index!
assert|assert
name|arc
operator|.
name|isFinal
argument_list|()
assert|;
block|}
else|else
block|{
name|arc
operator|=
literal|null
expr_stmt|;
block|}
comment|// Empty string prefix must have an output in the
comment|// index!
name|currentFrame
operator|=
name|pushFrame
argument_list|(
name|arc
argument_list|,
name|rootCode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|currentFrame
operator|.
name|fpOrig
operator|=
name|currentFrame
operator|.
name|fp
expr_stmt|;
name|currentFrame
operator|.
name|loadBlock
argument_list|()
expr_stmt|;
name|validIndexPrefix
operator|=
literal|0
expr_stmt|;
name|stats
operator|.
name|startBlock
argument_list|(
name|currentFrame
argument_list|,
operator|!
name|currentFrame
operator|.
name|isLastInFloor
argument_list|)
expr_stmt|;
name|allTerms
label|:
while|while
condition|(
literal|true
condition|)
block|{
comment|// Pop finished blocks
while|while
condition|(
name|currentFrame
operator|.
name|nextEnt
operator|==
name|currentFrame
operator|.
name|entCount
condition|)
block|{
name|stats
operator|.
name|endBlock
argument_list|(
name|currentFrame
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|currentFrame
operator|.
name|isLastInFloor
condition|)
block|{
name|currentFrame
operator|.
name|loadNextFloorBlock
argument_list|()
expr_stmt|;
name|stats
operator|.
name|startBlock
argument_list|(
name|currentFrame
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|currentFrame
operator|.
name|ord
operator|==
literal|0
condition|)
block|{
break|break
name|allTerms
break|;
block|}
specifier|final
name|long
name|lastFP
init|=
name|currentFrame
operator|.
name|fpOrig
decl_stmt|;
name|currentFrame
operator|=
name|stack
index|[
name|currentFrame
operator|.
name|ord
operator|-
literal|1
index|]
expr_stmt|;
assert|assert
name|lastFP
operator|==
name|currentFrame
operator|.
name|lastSubFP
assert|;
comment|// if (DEBUG) {
comment|//   System.out.println("  reset validIndexPrefix=" + validIndexPrefix);
comment|// }
block|}
block|}
while|while
condition|(
literal|true
condition|)
block|{
if|if
condition|(
name|currentFrame
operator|.
name|next
argument_list|()
condition|)
block|{
comment|// Push to new block:
name|currentFrame
operator|=
name|pushFrame
argument_list|(
literal|null
argument_list|,
name|currentFrame
operator|.
name|lastSubFP
argument_list|,
name|term
operator|.
name|length
argument_list|)
expr_stmt|;
name|currentFrame
operator|.
name|fpOrig
operator|=
name|currentFrame
operator|.
name|fp
expr_stmt|;
comment|// This is a "next" frame -- even if it's
comment|// floor'd we must pretend it isn't so we don't
comment|// try to scan to the right floor frame:
name|currentFrame
operator|.
name|isFloor
operator|=
literal|false
expr_stmt|;
comment|//currentFrame.hasTerms = true;
name|currentFrame
operator|.
name|loadBlock
argument_list|()
expr_stmt|;
name|stats
operator|.
name|startBlock
argument_list|(
name|currentFrame
argument_list|,
operator|!
name|currentFrame
operator|.
name|isLastInFloor
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|stats
operator|.
name|term
argument_list|(
name|term
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
name|stats
operator|.
name|finish
argument_list|()
expr_stmt|;
comment|// Put root frame back:
name|currentFrame
operator|=
name|staticFrame
expr_stmt|;
if|if
condition|(
name|index
operator|!=
literal|null
condition|)
block|{
name|arc
operator|=
name|index
operator|.
name|getFirstArc
argument_list|(
name|arcs
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|// Empty string prefix must have an output in the index!
assert|assert
name|arc
operator|.
name|isFinal
argument_list|()
assert|;
block|}
else|else
block|{
name|arc
operator|=
literal|null
expr_stmt|;
block|}
name|currentFrame
operator|=
name|pushFrame
argument_list|(
name|arc
argument_list|,
name|rootCode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|currentFrame
operator|.
name|rewind
argument_list|()
expr_stmt|;
name|currentFrame
operator|.
name|loadBlock
argument_list|()
expr_stmt|;
name|validIndexPrefix
operator|=
literal|0
expr_stmt|;
name|term
operator|.
name|length
operator|=
literal|0
expr_stmt|;
return|return
name|stats
return|;
block|}
DECL|method|getFrame
specifier|private
name|Frame
name|getFrame
parameter_list|(
name|int
name|ord
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|ord
operator|>=
name|stack
operator|.
name|length
condition|)
block|{
specifier|final
name|Frame
index|[]
name|next
init|=
operator|new
name|Frame
index|[
name|ArrayUtil
operator|.
name|oversize
argument_list|(
literal|1
operator|+
name|ord
argument_list|,
name|RamUsageEstimator
operator|.
name|NUM_BYTES_OBJECT_REF
argument_list|)
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|stack
argument_list|,
literal|0
argument_list|,
name|next
argument_list|,
literal|0
argument_list|,
name|stack
operator|.
name|length
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|stackOrd
init|=
name|stack
operator|.
name|length
init|;
name|stackOrd
operator|<
name|next
operator|.
name|length
condition|;
name|stackOrd
operator|++
control|)
block|{
name|next
index|[
name|stackOrd
index|]
operator|=
operator|new
name|Frame
argument_list|(
name|stackOrd
argument_list|)
expr_stmt|;
block|}
name|stack
operator|=
name|next
expr_stmt|;
block|}
assert|assert
name|stack
index|[
name|ord
index|]
operator|.
name|ord
operator|==
name|ord
assert|;
return|return
name|stack
index|[
name|ord
index|]
return|;
block|}
DECL|method|getArc
specifier|private
name|FST
operator|.
name|Arc
argument_list|<
name|BytesRef
argument_list|>
name|getArc
parameter_list|(
name|int
name|ord
parameter_list|)
block|{
if|if
condition|(
name|ord
operator|>=
name|arcs
operator|.
name|length
condition|)
block|{
annotation|@
name|SuppressWarnings
argument_list|(
block|{
literal|"rawtypes"
block|,
literal|"unchecked"
block|}
argument_list|)
specifier|final
name|FST
operator|.
name|Arc
argument_list|<
name|BytesRef
argument_list|>
index|[]
name|next
init|=
operator|new
name|FST
operator|.
name|Arc
index|[
name|ArrayUtil
operator|.
name|oversize
argument_list|(
literal|1
operator|+
name|ord
argument_list|,
name|RamUsageEstimator
operator|.
name|NUM_BYTES_OBJECT_REF
argument_list|)
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|arcs
argument_list|,
literal|0
argument_list|,
name|next
argument_list|,
literal|0
argument_list|,
name|arcs
operator|.
name|length
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|arcOrd
init|=
name|arcs
operator|.
name|length
init|;
name|arcOrd
operator|<
name|next
operator|.
name|length
condition|;
name|arcOrd
operator|++
control|)
block|{
name|next
index|[
name|arcOrd
index|]
operator|=
operator|new
name|FST
operator|.
name|Arc
argument_list|<
name|BytesRef
argument_list|>
argument_list|()
expr_stmt|;
block|}
name|arcs
operator|=
name|next
expr_stmt|;
block|}
return|return
name|arcs
index|[
name|ord
index|]
return|;
block|}
annotation|@
name|Override
DECL|method|getComparator
specifier|public
name|Comparator
argument_list|<
name|BytesRef
argument_list|>
name|getComparator
parameter_list|()
block|{
return|return
name|BytesRef
operator|.
name|getUTF8SortedAsUnicodeComparator
argument_list|()
return|;
block|}
comment|// Pushes a frame we seek'd to
DECL|method|pushFrame
name|Frame
name|pushFrame
parameter_list|(
name|FST
operator|.
name|Arc
argument_list|<
name|BytesRef
argument_list|>
name|arc
parameter_list|,
name|BytesRef
name|frameData
parameter_list|,
name|int
name|length
parameter_list|)
throws|throws
name|IOException
block|{
name|scratchReader
operator|.
name|reset
argument_list|(
name|frameData
operator|.
name|bytes
argument_list|,
name|frameData
operator|.
name|offset
argument_list|,
name|frameData
operator|.
name|length
argument_list|)
expr_stmt|;
specifier|final
name|long
name|code
init|=
name|scratchReader
operator|.
name|readVLong
argument_list|()
decl_stmt|;
specifier|final
name|long
name|fpSeek
init|=
name|code
operator|>>>
name|BlockTreeTermsWriter
operator|.
name|OUTPUT_FLAGS_NUM_BITS
decl_stmt|;
specifier|final
name|Frame
name|f
init|=
name|getFrame
argument_list|(
literal|1
operator|+
name|currentFrame
operator|.
name|ord
argument_list|)
decl_stmt|;
name|f
operator|.
name|hasTerms
operator|=
operator|(
name|code
operator|&
name|BlockTreeTermsWriter
operator|.
name|OUTPUT_FLAG_HAS_TERMS
operator|)
operator|!=
literal|0
expr_stmt|;
name|f
operator|.
name|hasTermsOrig
operator|=
name|f
operator|.
name|hasTerms
expr_stmt|;
name|f
operator|.
name|isFloor
operator|=
operator|(
name|code
operator|&
name|BlockTreeTermsWriter
operator|.
name|OUTPUT_FLAG_IS_FLOOR
operator|)
operator|!=
literal|0
expr_stmt|;
if|if
condition|(
name|f
operator|.
name|isFloor
condition|)
block|{
name|f
operator|.
name|setFloorData
argument_list|(
name|scratchReader
argument_list|,
name|frameData
argument_list|)
expr_stmt|;
block|}
name|pushFrame
argument_list|(
name|arc
argument_list|,
name|fpSeek
argument_list|,
name|length
argument_list|)
expr_stmt|;
return|return
name|f
return|;
block|}
comment|// Pushes next'd frame or seek'd frame; we later
comment|// lazy-load the frame only when needed
DECL|method|pushFrame
name|Frame
name|pushFrame
parameter_list|(
name|FST
operator|.
name|Arc
argument_list|<
name|BytesRef
argument_list|>
name|arc
parameter_list|,
name|long
name|fp
parameter_list|,
name|int
name|length
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|Frame
name|f
init|=
name|getFrame
argument_list|(
literal|1
operator|+
name|currentFrame
operator|.
name|ord
argument_list|)
decl_stmt|;
name|f
operator|.
name|arc
operator|=
name|arc
expr_stmt|;
if|if
condition|(
name|f
operator|.
name|fpOrig
operator|==
name|fp
operator|&&
name|f
operator|.
name|nextEnt
operator|!=
operator|-
literal|1
condition|)
block|{
comment|//if (DEBUG) System.out.println("      push reused frame ord=" + f.ord + " fp=" + f.fp + " isFloor?=" + f.isFloor + " hasTerms=" + f.hasTerms + " pref=" + term + " nextEnt=" + f.nextEnt + " targetBeforeCurrentLength=" + targetBeforeCurrentLength + " term.length=" + term.length + " vs prefix=" + f.prefix);
if|if
condition|(
name|f
operator|.
name|prefix
operator|>
name|targetBeforeCurrentLength
condition|)
block|{
name|f
operator|.
name|rewind
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|// if (DEBUG) {
comment|//   System.out.println("        skip rewind!");
comment|// }
block|}
assert|assert
name|length
operator|==
name|f
operator|.
name|prefix
assert|;
block|}
else|else
block|{
name|f
operator|.
name|nextEnt
operator|=
operator|-
literal|1
expr_stmt|;
name|f
operator|.
name|prefix
operator|=
name|length
expr_stmt|;
name|f
operator|.
name|state
operator|.
name|termBlockOrd
operator|=
literal|0
expr_stmt|;
name|f
operator|.
name|fpOrig
operator|=
name|f
operator|.
name|fp
operator|=
name|fp
expr_stmt|;
name|f
operator|.
name|lastSubFP
operator|=
operator|-
literal|1
expr_stmt|;
comment|// if (DEBUG) {
comment|//   final int sav = term.length;
comment|//   term.length = length;
comment|//   System.out.println("      push new frame ord=" + f.ord + " fp=" + f.fp + " hasTerms=" + f.hasTerms + " isFloor=" + f.isFloor + " pref=" + brToString(term));
comment|//   term.length = sav;
comment|// }
block|}
return|return
name|f
return|;
block|}
comment|// asserts only
DECL|method|clearEOF
specifier|private
name|boolean
name|clearEOF
parameter_list|()
block|{
name|eof
operator|=
literal|false
expr_stmt|;
return|return
literal|true
return|;
block|}
comment|// asserts only
DECL|method|setEOF
specifier|private
name|boolean
name|setEOF
parameter_list|()
block|{
name|eof
operator|=
literal|true
expr_stmt|;
return|return
literal|true
return|;
block|}
annotation|@
name|Override
DECL|method|seekExact
specifier|public
name|boolean
name|seekExact
parameter_list|(
specifier|final
name|BytesRef
name|target
parameter_list|,
specifier|final
name|boolean
name|useCache
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|index
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"terms index was not loaded"
argument_list|)
throw|;
block|}
if|if
condition|(
name|term
operator|.
name|bytes
operator|.
name|length
operator|<=
name|target
operator|.
name|length
condition|)
block|{
name|term
operator|.
name|bytes
operator|=
name|ArrayUtil
operator|.
name|grow
argument_list|(
name|term
operator|.
name|bytes
argument_list|,
literal|1
operator|+
name|target
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
assert|assert
name|clearEOF
argument_list|()
assert|;
comment|// if (DEBUG) {
comment|//   System.out.println("\nBTTR.seekExact seg=" + segment + " target=" + fieldInfo.name + ":" + brToString(target) + " current=" + brToString(term) + " (exists?=" + termExists + ") validIndexPrefix=" + validIndexPrefix);
comment|//   printSeekState();
comment|// }
name|FST
operator|.
name|Arc
argument_list|<
name|BytesRef
argument_list|>
name|arc
decl_stmt|;
name|int
name|targetUpto
decl_stmt|;
name|BytesRef
name|output
decl_stmt|;
name|targetBeforeCurrentLength
operator|=
name|currentFrame
operator|.
name|ord
expr_stmt|;
if|if
condition|(
name|currentFrame
operator|!=
name|staticFrame
condition|)
block|{
comment|// We are already seek'd; find the common
comment|// prefix of new seek term vs current term and
comment|// re-use the corresponding seek state.  For
comment|// example, if app first seeks to foobar, then
comment|// seeks to foobaz, we can re-use the seek state
comment|// for the first 5 bytes.
comment|// if (DEBUG) {
comment|//   System.out.println("  re-use current seek state validIndexPrefix=" + validIndexPrefix);
comment|// }
name|arc
operator|=
name|arcs
index|[
literal|0
index|]
expr_stmt|;
assert|assert
name|arc
operator|.
name|isFinal
argument_list|()
assert|;
name|output
operator|=
name|arc
operator|.
name|output
expr_stmt|;
name|targetUpto
operator|=
literal|0
expr_stmt|;
name|Frame
name|lastFrame
init|=
name|stack
index|[
literal|0
index|]
decl_stmt|;
assert|assert
name|validIndexPrefix
operator|<=
name|term
operator|.
name|length
assert|;
specifier|final
name|int
name|targetLimit
init|=
name|Math
operator|.
name|min
argument_list|(
name|target
operator|.
name|length
argument_list|,
name|validIndexPrefix
argument_list|)
decl_stmt|;
name|int
name|cmp
init|=
literal|0
decl_stmt|;
comment|// TODO: reverse vLong byte order for better FST
comment|// prefix output sharing
comment|// First compare up to valid seek frames:
while|while
condition|(
name|targetUpto
operator|<
name|targetLimit
condition|)
block|{
name|cmp
operator|=
operator|(
name|term
operator|.
name|bytes
index|[
name|targetUpto
index|]
operator|&
literal|0xFF
operator|)
operator|-
operator|(
name|target
operator|.
name|bytes
index|[
name|target
operator|.
name|offset
operator|+
name|targetUpto
index|]
operator|&
literal|0xFF
operator|)
expr_stmt|;
comment|// if (DEBUG) {
comment|//   System.out.println("    cycle targetUpto=" + targetUpto + " (vs limit=" + targetLimit + ") cmp=" + cmp + " (targetLabel=" + (char) (target.bytes[target.offset + targetUpto]) + " vs termLabel=" + (char) (term.bytes[targetUpto]) + ")"   + " arc.output=" + arc.output + " output=" + output);
comment|// }
if|if
condition|(
name|cmp
operator|!=
literal|0
condition|)
block|{
break|break;
block|}
name|arc
operator|=
name|arcs
index|[
literal|1
operator|+
name|targetUpto
index|]
expr_stmt|;
comment|//if (arc.label != (target.bytes[target.offset + targetUpto]& 0xFF)) {
comment|//System.out.println("FAIL: arc.label=" + (char) arc.label + " targetLabel=" + (char) (target.bytes[target.offset + targetUpto]& 0xFF));
comment|//}
assert|assert
name|arc
operator|.
name|label
operator|==
operator|(
name|target
operator|.
name|bytes
index|[
name|target
operator|.
name|offset
operator|+
name|targetUpto
index|]
operator|&
literal|0xFF
operator|)
operator|:
literal|"arc.label="
operator|+
operator|(
name|char
operator|)
name|arc
operator|.
name|label
operator|+
literal|" targetLabel="
operator|+
call|(
name|char
call|)
argument_list|(
name|target
operator|.
name|bytes
index|[
name|target
operator|.
name|offset
operator|+
name|targetUpto
index|]
operator|&
literal|0xFF
argument_list|)
assert|;
if|if
condition|(
name|arc
operator|.
name|output
operator|!=
name|NO_OUTPUT
condition|)
block|{
name|output
operator|=
name|fstOutputs
operator|.
name|add
argument_list|(
name|output
argument_list|,
name|arc
operator|.
name|output
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|arc
operator|.
name|isFinal
argument_list|()
condition|)
block|{
name|lastFrame
operator|=
name|stack
index|[
literal|1
operator|+
name|lastFrame
operator|.
name|ord
index|]
expr_stmt|;
block|}
name|targetUpto
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|cmp
operator|==
literal|0
condition|)
block|{
specifier|final
name|int
name|targetUptoMid
init|=
name|targetUpto
decl_stmt|;
comment|// Second compare the rest of the term, but
comment|// don't save arc/output/frame; we only do this
comment|// to find out if the target term is before,
comment|// equal or after the current term
specifier|final
name|int
name|targetLimit2
init|=
name|Math
operator|.
name|min
argument_list|(
name|target
operator|.
name|length
argument_list|,
name|term
operator|.
name|length
argument_list|)
decl_stmt|;
while|while
condition|(
name|targetUpto
operator|<
name|targetLimit2
condition|)
block|{
name|cmp
operator|=
operator|(
name|term
operator|.
name|bytes
index|[
name|targetUpto
index|]
operator|&
literal|0xFF
operator|)
operator|-
operator|(
name|target
operator|.
name|bytes
index|[
name|target
operator|.
name|offset
operator|+
name|targetUpto
index|]
operator|&
literal|0xFF
operator|)
expr_stmt|;
comment|// if (DEBUG) {
comment|//   System.out.println("    cycle2 targetUpto=" + targetUpto + " (vs limit=" + targetLimit + ") cmp=" + cmp + " (targetLabel=" + (char) (target.bytes[target.offset + targetUpto]) + " vs termLabel=" + (char) (term.bytes[targetUpto]) + ")");
comment|// }
if|if
condition|(
name|cmp
operator|!=
literal|0
condition|)
block|{
break|break;
block|}
name|targetUpto
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|cmp
operator|==
literal|0
condition|)
block|{
name|cmp
operator|=
name|term
operator|.
name|length
operator|-
name|target
operator|.
name|length
expr_stmt|;
block|}
name|targetUpto
operator|=
name|targetUptoMid
expr_stmt|;
block|}
if|if
condition|(
name|cmp
operator|<
literal|0
condition|)
block|{
comment|// Common case: target term is after current
comment|// term, ie, app is seeking multiple terms
comment|// in sorted order
comment|// if (DEBUG) {
comment|//   System.out.println("  target is after current (shares prefixLen=" + targetUpto + "); frame.ord=" + lastFrame.ord);
comment|// }
name|currentFrame
operator|=
name|lastFrame
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cmp
operator|>
literal|0
condition|)
block|{
comment|// Uncommon case: target term
comment|// is before current term; this means we can
comment|// keep the currentFrame but we must rewind it
comment|// (so we scan from the start)
name|targetBeforeCurrentLength
operator|=
literal|0
expr_stmt|;
comment|// if (DEBUG) {
comment|//   System.out.println("  target is before current (shares prefixLen=" + targetUpto + "); rewind frame ord=" + lastFrame.ord);
comment|// }
name|currentFrame
operator|=
name|lastFrame
expr_stmt|;
name|currentFrame
operator|.
name|rewind
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|// Target is exactly the same as current term
assert|assert
name|term
operator|.
name|length
operator|==
name|target
operator|.
name|length
assert|;
if|if
condition|(
name|termExists
condition|)
block|{
comment|// if (DEBUG) {
comment|//   System.out.println("  target is same as current; return true");
comment|// }
return|return
literal|true
return|;
block|}
else|else
block|{
comment|// if (DEBUG) {
comment|//   System.out.println("  target is same as current but term doesn't exist");
comment|// }
block|}
comment|//validIndexPrefix = currentFrame.depth;
comment|//term.length = target.length;
comment|//return termExists;
block|}
block|}
else|else
block|{
name|targetBeforeCurrentLength
operator|=
operator|-
literal|1
expr_stmt|;
name|arc
operator|=
name|index
operator|.
name|getFirstArc
argument_list|(
name|arcs
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|// Empty string prefix must have an output (block) in the index!
assert|assert
name|arc
operator|.
name|isFinal
argument_list|()
assert|;
assert|assert
name|arc
operator|.
name|output
operator|!=
literal|null
assert|;
comment|// if (DEBUG) {
comment|//   System.out.println("    no seek state; push root frame");
comment|// }
name|output
operator|=
name|arc
operator|.
name|output
expr_stmt|;
name|currentFrame
operator|=
name|staticFrame
expr_stmt|;
comment|//term.length = 0;
name|targetUpto
operator|=
literal|0
expr_stmt|;
name|currentFrame
operator|=
name|pushFrame
argument_list|(
name|arc
argument_list|,
name|fstOutputs
operator|.
name|add
argument_list|(
name|output
argument_list|,
name|arc
operator|.
name|nextFinalOutput
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|// if (DEBUG) {
comment|//   System.out.println("  start index loop targetUpto=" + targetUpto + " output=" + output + " currentFrame.ord=" + currentFrame.ord + " targetBeforeCurrentLength=" + targetBeforeCurrentLength);
comment|// }
while|while
condition|(
name|targetUpto
operator|<
name|target
operator|.
name|length
condition|)
block|{
specifier|final
name|int
name|targetLabel
init|=
name|target
operator|.
name|bytes
index|[
name|target
operator|.
name|offset
operator|+
name|targetUpto
index|]
operator|&
literal|0xFF
decl_stmt|;
specifier|final
name|FST
operator|.
name|Arc
argument_list|<
name|BytesRef
argument_list|>
name|nextArc
init|=
name|index
operator|.
name|findTargetArc
argument_list|(
name|targetLabel
argument_list|,
name|arc
argument_list|,
name|getArc
argument_list|(
literal|1
operator|+
name|targetUpto
argument_list|)
argument_list|,
name|fstReader
argument_list|)
decl_stmt|;
if|if
condition|(
name|nextArc
operator|==
literal|null
condition|)
block|{
comment|// Index is exhausted
comment|// if (DEBUG) {
comment|//   System.out.println("    index: index exhausted label=" + ((char) targetLabel) + " " + toHex(targetLabel));
comment|// }
name|validIndexPrefix
operator|=
name|currentFrame
operator|.
name|prefix
expr_stmt|;
comment|//validIndexPrefix = targetUpto;
name|currentFrame
operator|.
name|scanToFloorFrame
argument_list|(
name|target
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|currentFrame
operator|.
name|hasTerms
condition|)
block|{
name|termExists
operator|=
literal|false
expr_stmt|;
name|term
operator|.
name|bytes
index|[
name|targetUpto
index|]
operator|=
operator|(
name|byte
operator|)
name|targetLabel
expr_stmt|;
name|term
operator|.
name|length
operator|=
literal|1
operator|+
name|targetUpto
expr_stmt|;
comment|// if (DEBUG) {
comment|//   System.out.println("  FAST NOT_FOUND term=" + brToString(term));
comment|// }
return|return
literal|false
return|;
block|}
name|currentFrame
operator|.
name|loadBlock
argument_list|()
expr_stmt|;
specifier|final
name|SeekStatus
name|result
init|=
name|currentFrame
operator|.
name|scanToTerm
argument_list|(
name|target
argument_list|,
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|==
name|SeekStatus
operator|.
name|FOUND
condition|)
block|{
comment|// if (DEBUG) {
comment|//   System.out.println("  return FOUND term=" + term.utf8ToString() + " " + term);
comment|// }
return|return
literal|true
return|;
block|}
else|else
block|{
comment|// if (DEBUG) {
comment|//   System.out.println("  got " + result + "; return NOT_FOUND term=" + brToString(term));
comment|// }
return|return
literal|false
return|;
block|}
block|}
else|else
block|{
comment|// Follow this arc
name|arc
operator|=
name|nextArc
expr_stmt|;
name|term
operator|.
name|bytes
index|[
name|targetUpto
index|]
operator|=
operator|(
name|byte
operator|)
name|targetLabel
expr_stmt|;
comment|// Aggregate output as we go:
assert|assert
name|arc
operator|.
name|output
operator|!=
literal|null
assert|;
if|if
condition|(
name|arc
operator|.
name|output
operator|!=
name|NO_OUTPUT
condition|)
block|{
name|output
operator|=
name|fstOutputs
operator|.
name|add
argument_list|(
name|output
argument_list|,
name|arc
operator|.
name|output
argument_list|)
expr_stmt|;
block|}
comment|// if (DEBUG) {
comment|//   System.out.println("    index: follow label=" + toHex(target.bytes[target.offset + targetUpto]&0xff) + " arc.output=" + arc.output + " arc.nfo=" + arc.nextFinalOutput);
comment|// }
name|targetUpto
operator|++
expr_stmt|;
if|if
condition|(
name|arc
operator|.
name|isFinal
argument_list|()
condition|)
block|{
comment|//if (DEBUG) System.out.println("    arc is final!");
name|currentFrame
operator|=
name|pushFrame
argument_list|(
name|arc
argument_list|,
name|fstOutputs
operator|.
name|add
argument_list|(
name|output
argument_list|,
name|arc
operator|.
name|nextFinalOutput
argument_list|)
argument_list|,
name|targetUpto
argument_list|)
expr_stmt|;
comment|//if (DEBUG) System.out.println("    curFrame.ord=" + currentFrame.ord + " hasTerms=" + currentFrame.hasTerms);
block|}
block|}
block|}
comment|//validIndexPrefix = targetUpto;
name|validIndexPrefix
operator|=
name|currentFrame
operator|.
name|prefix
expr_stmt|;
name|currentFrame
operator|.
name|scanToFloorFrame
argument_list|(
name|target
argument_list|)
expr_stmt|;
comment|// Target term is entirely contained in the index:
if|if
condition|(
operator|!
name|currentFrame
operator|.
name|hasTerms
condition|)
block|{
name|termExists
operator|=
literal|false
expr_stmt|;
name|term
operator|.
name|length
operator|=
name|targetUpto
expr_stmt|;
comment|// if (DEBUG) {
comment|//   System.out.println("  FAST NOT_FOUND term=" + brToString(term));
comment|// }
return|return
literal|false
return|;
block|}
name|currentFrame
operator|.
name|loadBlock
argument_list|()
expr_stmt|;
specifier|final
name|SeekStatus
name|result
init|=
name|currentFrame
operator|.
name|scanToTerm
argument_list|(
name|target
argument_list|,
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|==
name|SeekStatus
operator|.
name|FOUND
condition|)
block|{
comment|// if (DEBUG) {
comment|//   System.out.println("  return FOUND term=" + term.utf8ToString() + " " + term);
comment|// }
return|return
literal|true
return|;
block|}
else|else
block|{
comment|// if (DEBUG) {
comment|//   System.out.println("  got result " + result + "; return NOT_FOUND term=" + term.utf8ToString());
comment|// }
return|return
literal|false
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|seekCeil
specifier|public
name|SeekStatus
name|seekCeil
parameter_list|(
specifier|final
name|BytesRef
name|target
parameter_list|,
specifier|final
name|boolean
name|useCache
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|index
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"terms index was not loaded"
argument_list|)
throw|;
block|}
if|if
condition|(
name|term
operator|.
name|bytes
operator|.
name|length
operator|<=
name|target
operator|.
name|length
condition|)
block|{
name|term
operator|.
name|bytes
operator|=
name|ArrayUtil
operator|.
name|grow
argument_list|(
name|term
operator|.
name|bytes
argument_list|,
literal|1
operator|+
name|target
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
assert|assert
name|clearEOF
argument_list|()
assert|;
comment|//if (DEBUG) {
comment|//System.out.println("\nBTTR.seekCeil seg=" + segment + " target=" + fieldInfo.name + ":" + target.utf8ToString() + " " + target + " current=" + brToString(term) + " (exists?=" + termExists + ") validIndexPrefix=  " + validIndexPrefix);
comment|//printSeekState();
comment|//}
name|FST
operator|.
name|Arc
argument_list|<
name|BytesRef
argument_list|>
name|arc
decl_stmt|;
name|int
name|targetUpto
decl_stmt|;
name|BytesRef
name|output
decl_stmt|;
name|targetBeforeCurrentLength
operator|=
name|currentFrame
operator|.
name|ord
expr_stmt|;
if|if
condition|(
name|currentFrame
operator|!=
name|staticFrame
condition|)
block|{
comment|// We are already seek'd; find the common
comment|// prefix of new seek term vs current term and
comment|// re-use the corresponding seek state.  For
comment|// example, if app first seeks to foobar, then
comment|// seeks to foobaz, we can re-use the seek state
comment|// for the first 5 bytes.
comment|//if (DEBUG) {
comment|//System.out.println("  re-use current seek state validIndexPrefix=" + validIndexPrefix);
comment|//}
name|arc
operator|=
name|arcs
index|[
literal|0
index|]
expr_stmt|;
assert|assert
name|arc
operator|.
name|isFinal
argument_list|()
assert|;
name|output
operator|=
name|arc
operator|.
name|output
expr_stmt|;
name|targetUpto
operator|=
literal|0
expr_stmt|;
name|Frame
name|lastFrame
init|=
name|stack
index|[
literal|0
index|]
decl_stmt|;
assert|assert
name|validIndexPrefix
operator|<=
name|term
operator|.
name|length
assert|;
specifier|final
name|int
name|targetLimit
init|=
name|Math
operator|.
name|min
argument_list|(
name|target
operator|.
name|length
argument_list|,
name|validIndexPrefix
argument_list|)
decl_stmt|;
name|int
name|cmp
init|=
literal|0
decl_stmt|;
comment|// TOOD: we should write our vLong backwards (MSB
comment|// first) to get better sharing from the FST
comment|// First compare up to valid seek frames:
while|while
condition|(
name|targetUpto
operator|<
name|targetLimit
condition|)
block|{
name|cmp
operator|=
operator|(
name|term
operator|.
name|bytes
index|[
name|targetUpto
index|]
operator|&
literal|0xFF
operator|)
operator|-
operator|(
name|target
operator|.
name|bytes
index|[
name|target
operator|.
name|offset
operator|+
name|targetUpto
index|]
operator|&
literal|0xFF
operator|)
expr_stmt|;
comment|//if (DEBUG) {
comment|//System.out.println("    cycle targetUpto=" + targetUpto + " (vs limit=" + targetLimit + ") cmp=" + cmp + " (targetLabel=" + (char) (target.bytes[target.offset + targetUpto]) + " vs termLabel=" + (char) (term.bytes[targetUpto]) + ")"   + " arc.output=" + arc.output + " output=" + output);
comment|//}
if|if
condition|(
name|cmp
operator|!=
literal|0
condition|)
block|{
break|break;
block|}
name|arc
operator|=
name|arcs
index|[
literal|1
operator|+
name|targetUpto
index|]
expr_stmt|;
assert|assert
name|arc
operator|.
name|label
operator|==
operator|(
name|target
operator|.
name|bytes
index|[
name|target
operator|.
name|offset
operator|+
name|targetUpto
index|]
operator|&
literal|0xFF
operator|)
operator|:
literal|"arc.label="
operator|+
operator|(
name|char
operator|)
name|arc
operator|.
name|label
operator|+
literal|" targetLabel="
operator|+
call|(
name|char
call|)
argument_list|(
name|target
operator|.
name|bytes
index|[
name|target
operator|.
name|offset
operator|+
name|targetUpto
index|]
operator|&
literal|0xFF
argument_list|)
assert|;
comment|// TOOD: we could save the outputs in local
comment|// byte[][] instead of making new objs ever
comment|// seek; but, often the FST doesn't have any
comment|// shared bytes (but this could change if we
comment|// reverse vLong byte order)
if|if
condition|(
name|arc
operator|.
name|output
operator|!=
name|NO_OUTPUT
condition|)
block|{
name|output
operator|=
name|fstOutputs
operator|.
name|add
argument_list|(
name|output
argument_list|,
name|arc
operator|.
name|output
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|arc
operator|.
name|isFinal
argument_list|()
condition|)
block|{
name|lastFrame
operator|=
name|stack
index|[
literal|1
operator|+
name|lastFrame
operator|.
name|ord
index|]
expr_stmt|;
block|}
name|targetUpto
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|cmp
operator|==
literal|0
condition|)
block|{
specifier|final
name|int
name|targetUptoMid
init|=
name|targetUpto
decl_stmt|;
comment|// Second compare the rest of the term, but
comment|// don't save arc/output/frame:
specifier|final
name|int
name|targetLimit2
init|=
name|Math
operator|.
name|min
argument_list|(
name|target
operator|.
name|length
argument_list|,
name|term
operator|.
name|length
argument_list|)
decl_stmt|;
while|while
condition|(
name|targetUpto
operator|<
name|targetLimit2
condition|)
block|{
name|cmp
operator|=
operator|(
name|term
operator|.
name|bytes
index|[
name|targetUpto
index|]
operator|&
literal|0xFF
operator|)
operator|-
operator|(
name|target
operator|.
name|bytes
index|[
name|target
operator|.
name|offset
operator|+
name|targetUpto
index|]
operator|&
literal|0xFF
operator|)
expr_stmt|;
comment|//if (DEBUG) {
comment|//System.out.println("    cycle2 targetUpto=" + targetUpto + " (vs limit=" + targetLimit + ") cmp=" + cmp + " (targetLabel=" + (char) (target.bytes[target.offset + targetUpto]) + " vs termLabel=" + (char) (term.bytes[targetUpto]) + ")");
comment|//}
if|if
condition|(
name|cmp
operator|!=
literal|0
condition|)
block|{
break|break;
block|}
name|targetUpto
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|cmp
operator|==
literal|0
condition|)
block|{
name|cmp
operator|=
name|term
operator|.
name|length
operator|-
name|target
operator|.
name|length
expr_stmt|;
block|}
name|targetUpto
operator|=
name|targetUptoMid
expr_stmt|;
block|}
if|if
condition|(
name|cmp
operator|<
literal|0
condition|)
block|{
comment|// Common case: target term is after current
comment|// term, ie, app is seeking multiple terms
comment|// in sorted order
comment|//if (DEBUG) {
comment|//System.out.println("  target is after current (shares prefixLen=" + targetUpto + "); clear frame.scanned ord=" + lastFrame.ord);
comment|//}
name|currentFrame
operator|=
name|lastFrame
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cmp
operator|>
literal|0
condition|)
block|{
comment|// Uncommon case: target term
comment|// is before current term; this means we can
comment|// keep the currentFrame but we must rewind it
comment|// (so we scan from the start)
name|targetBeforeCurrentLength
operator|=
literal|0
expr_stmt|;
comment|//if (DEBUG) {
comment|//System.out.println("  target is before current (shares prefixLen=" + targetUpto + "); rewind frame ord=" + lastFrame.ord);
comment|//}
name|currentFrame
operator|=
name|lastFrame
expr_stmt|;
name|currentFrame
operator|.
name|rewind
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|// Target is exactly the same as current term
assert|assert
name|term
operator|.
name|length
operator|==
name|target
operator|.
name|length
assert|;
if|if
condition|(
name|termExists
condition|)
block|{
comment|//if (DEBUG) {
comment|//System.out.println("  target is same as current; return FOUND");
comment|//}
return|return
name|SeekStatus
operator|.
name|FOUND
return|;
block|}
else|else
block|{
comment|//if (DEBUG) {
comment|//System.out.println("  target is same as current but term doesn't exist");
comment|//}
block|}
block|}
block|}
else|else
block|{
name|targetBeforeCurrentLength
operator|=
operator|-
literal|1
expr_stmt|;
name|arc
operator|=
name|index
operator|.
name|getFirstArc
argument_list|(
name|arcs
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|// Empty string prefix must have an output (block) in the index!
assert|assert
name|arc
operator|.
name|isFinal
argument_list|()
assert|;
assert|assert
name|arc
operator|.
name|output
operator|!=
literal|null
assert|;
comment|//if (DEBUG) {
comment|//System.out.println("    no seek state; push root frame");
comment|//}
name|output
operator|=
name|arc
operator|.
name|output
expr_stmt|;
name|currentFrame
operator|=
name|staticFrame
expr_stmt|;
comment|//term.length = 0;
name|targetUpto
operator|=
literal|0
expr_stmt|;
name|currentFrame
operator|=
name|pushFrame
argument_list|(
name|arc
argument_list|,
name|fstOutputs
operator|.
name|add
argument_list|(
name|output
argument_list|,
name|arc
operator|.
name|nextFinalOutput
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|//if (DEBUG) {
comment|//System.out.println("  start index loop targetUpto=" + targetUpto + " output=" + output + " currentFrame.ord+1=" + currentFrame.ord + " targetBeforeCurrentLength=" + targetBeforeCurrentLength);
comment|//}
while|while
condition|(
name|targetUpto
operator|<
name|target
operator|.
name|length
condition|)
block|{
specifier|final
name|int
name|targetLabel
init|=
name|target
operator|.
name|bytes
index|[
name|target
operator|.
name|offset
operator|+
name|targetUpto
index|]
operator|&
literal|0xFF
decl_stmt|;
specifier|final
name|FST
operator|.
name|Arc
argument_list|<
name|BytesRef
argument_list|>
name|nextArc
init|=
name|index
operator|.
name|findTargetArc
argument_list|(
name|targetLabel
argument_list|,
name|arc
argument_list|,
name|getArc
argument_list|(
literal|1
operator|+
name|targetUpto
argument_list|)
argument_list|,
name|fstReader
argument_list|)
decl_stmt|;
if|if
condition|(
name|nextArc
operator|==
literal|null
condition|)
block|{
comment|// Index is exhausted
comment|// if (DEBUG) {
comment|//   System.out.println("    index: index exhausted label=" + ((char) targetLabel) + " " + toHex(targetLabel));
comment|// }
name|validIndexPrefix
operator|=
name|currentFrame
operator|.
name|prefix
expr_stmt|;
comment|//validIndexPrefix = targetUpto;
name|currentFrame
operator|.
name|scanToFloorFrame
argument_list|(
name|target
argument_list|)
expr_stmt|;
name|currentFrame
operator|.
name|loadBlock
argument_list|()
expr_stmt|;
specifier|final
name|SeekStatus
name|result
init|=
name|currentFrame
operator|.
name|scanToTerm
argument_list|(
name|target
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|==
name|SeekStatus
operator|.
name|END
condition|)
block|{
name|term
operator|.
name|copyBytes
argument_list|(
name|target
argument_list|)
expr_stmt|;
name|termExists
operator|=
literal|false
expr_stmt|;
if|if
condition|(
name|next
argument_list|()
operator|!=
literal|null
condition|)
block|{
comment|//if (DEBUG) {
comment|//System.out.println("  return NOT_FOUND term=" + brToString(term) + " " + term);
comment|//}
return|return
name|SeekStatus
operator|.
name|NOT_FOUND
return|;
block|}
else|else
block|{
comment|//if (DEBUG) {
comment|//System.out.println("  return END");
comment|//}
return|return
name|SeekStatus
operator|.
name|END
return|;
block|}
block|}
else|else
block|{
comment|//if (DEBUG) {
comment|//System.out.println("  return " + result + " term=" + brToString(term) + " " + term);
comment|//}
return|return
name|result
return|;
block|}
block|}
else|else
block|{
comment|// Follow this arc
name|term
operator|.
name|bytes
index|[
name|targetUpto
index|]
operator|=
operator|(
name|byte
operator|)
name|targetLabel
expr_stmt|;
name|arc
operator|=
name|nextArc
expr_stmt|;
comment|// Aggregate output as we go:
assert|assert
name|arc
operator|.
name|output
operator|!=
literal|null
assert|;
if|if
condition|(
name|arc
operator|.
name|output
operator|!=
name|NO_OUTPUT
condition|)
block|{
name|output
operator|=
name|fstOutputs
operator|.
name|add
argument_list|(
name|output
argument_list|,
name|arc
operator|.
name|output
argument_list|)
expr_stmt|;
block|}
comment|//if (DEBUG) {
comment|//System.out.println("    index: follow label=" + toHex(target.bytes[target.offset + targetUpto]&0xff) + " arc.output=" + arc.output + " arc.nfo=" + arc.nextFinalOutput);
comment|//}
name|targetUpto
operator|++
expr_stmt|;
if|if
condition|(
name|arc
operator|.
name|isFinal
argument_list|()
condition|)
block|{
comment|//if (DEBUG) System.out.println("    arc is final!");
name|currentFrame
operator|=
name|pushFrame
argument_list|(
name|arc
argument_list|,
name|fstOutputs
operator|.
name|add
argument_list|(
name|output
argument_list|,
name|arc
operator|.
name|nextFinalOutput
argument_list|)
argument_list|,
name|targetUpto
argument_list|)
expr_stmt|;
comment|//if (DEBUG) System.out.println("    curFrame.ord=" + currentFrame.ord + " hasTerms=" + currentFrame.hasTerms);
block|}
block|}
block|}
comment|//validIndexPrefix = targetUpto;
name|validIndexPrefix
operator|=
name|currentFrame
operator|.
name|prefix
expr_stmt|;
name|currentFrame
operator|.
name|scanToFloorFrame
argument_list|(
name|target
argument_list|)
expr_stmt|;
name|currentFrame
operator|.
name|loadBlock
argument_list|()
expr_stmt|;
specifier|final
name|SeekStatus
name|result
init|=
name|currentFrame
operator|.
name|scanToTerm
argument_list|(
name|target
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|==
name|SeekStatus
operator|.
name|END
condition|)
block|{
name|term
operator|.
name|copyBytes
argument_list|(
name|target
argument_list|)
expr_stmt|;
name|termExists
operator|=
literal|false
expr_stmt|;
if|if
condition|(
name|next
argument_list|()
operator|!=
literal|null
condition|)
block|{
comment|//if (DEBUG) {
comment|//System.out.println("  return NOT_FOUND term=" + term.utf8ToString() + " " + term);
comment|//}
return|return
name|SeekStatus
operator|.
name|NOT_FOUND
return|;
block|}
else|else
block|{
comment|//if (DEBUG) {
comment|//System.out.println("  return END");
comment|//}
return|return
name|SeekStatus
operator|.
name|END
return|;
block|}
block|}
else|else
block|{
return|return
name|result
return|;
block|}
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unused"
argument_list|)
DECL|method|printSeekState
specifier|private
name|void
name|printSeekState
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|currentFrame
operator|==
name|staticFrame
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"  no prior seek"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"  prior seek state:"
argument_list|)
expr_stmt|;
name|int
name|ord
init|=
literal|0
decl_stmt|;
name|boolean
name|isSeekFrame
init|=
literal|true
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|Frame
name|f
init|=
name|getFrame
argument_list|(
name|ord
argument_list|)
decl_stmt|;
assert|assert
name|f
operator|!=
literal|null
assert|;
specifier|final
name|BytesRef
name|prefix
init|=
operator|new
name|BytesRef
argument_list|(
name|term
operator|.
name|bytes
argument_list|,
literal|0
argument_list|,
name|f
operator|.
name|prefix
argument_list|)
decl_stmt|;
if|if
condition|(
name|f
operator|.
name|nextEnt
operator|==
operator|-
literal|1
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"    frame "
operator|+
operator|(
name|isSeekFrame
condition|?
literal|"(seek)"
else|:
literal|"(next)"
operator|)
operator|+
literal|" ord="
operator|+
name|ord
operator|+
literal|" fp="
operator|+
name|f
operator|.
name|fp
operator|+
operator|(
name|f
operator|.
name|isFloor
condition|?
operator|(
literal|" (fpOrig="
operator|+
name|f
operator|.
name|fpOrig
operator|+
literal|")"
operator|)
else|:
literal|""
operator|)
operator|+
literal|" prefixLen="
operator|+
name|f
operator|.
name|prefix
operator|+
literal|" prefix="
operator|+
name|prefix
operator|+
operator|(
name|f
operator|.
name|nextEnt
operator|==
operator|-
literal|1
condition|?
literal|""
else|:
operator|(
literal|" (of "
operator|+
name|f
operator|.
name|entCount
operator|+
literal|")"
operator|)
operator|)
operator|+
literal|" hasTerms="
operator|+
name|f
operator|.
name|hasTerms
operator|+
literal|" isFloor="
operator|+
name|f
operator|.
name|isFloor
operator|+
literal|" code="
operator|+
operator|(
operator|(
name|f
operator|.
name|fp
operator|<<
name|BlockTreeTermsWriter
operator|.
name|OUTPUT_FLAGS_NUM_BITS
operator|)
operator|+
operator|(
name|f
operator|.
name|hasTerms
condition|?
name|BlockTreeTermsWriter
operator|.
name|OUTPUT_FLAG_HAS_TERMS
else|:
literal|0
operator|)
operator|+
operator|(
name|f
operator|.
name|isFloor
condition|?
name|BlockTreeTermsWriter
operator|.
name|OUTPUT_FLAG_IS_FLOOR
else|:
literal|0
operator|)
operator|)
operator|+
literal|" isLastInFloor="
operator|+
name|f
operator|.
name|isLastInFloor
operator|+
literal|" mdUpto="
operator|+
name|f
operator|.
name|metaDataUpto
operator|+
literal|" tbOrd="
operator|+
name|f
operator|.
name|getTermBlockOrd
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"    frame "
operator|+
operator|(
name|isSeekFrame
condition|?
literal|"(seek, loaded)"
else|:
literal|"(next, loaded)"
operator|)
operator|+
literal|" ord="
operator|+
name|ord
operator|+
literal|" fp="
operator|+
name|f
operator|.
name|fp
operator|+
operator|(
name|f
operator|.
name|isFloor
condition|?
operator|(
literal|" (fpOrig="
operator|+
name|f
operator|.
name|fpOrig
operator|+
literal|")"
operator|)
else|:
literal|""
operator|)
operator|+
literal|" prefixLen="
operator|+
name|f
operator|.
name|prefix
operator|+
literal|" prefix="
operator|+
name|prefix
operator|+
literal|" nextEnt="
operator|+
name|f
operator|.
name|nextEnt
operator|+
operator|(
name|f
operator|.
name|nextEnt
operator|==
operator|-
literal|1
condition|?
literal|""
else|:
operator|(
literal|" (of "
operator|+
name|f
operator|.
name|entCount
operator|+
literal|")"
operator|)
operator|)
operator|+
literal|" hasTerms="
operator|+
name|f
operator|.
name|hasTerms
operator|+
literal|" isFloor="
operator|+
name|f
operator|.
name|isFloor
operator|+
literal|" code="
operator|+
operator|(
operator|(
name|f
operator|.
name|fp
operator|<<
name|BlockTreeTermsWriter
operator|.
name|OUTPUT_FLAGS_NUM_BITS
operator|)
operator|+
operator|(
name|f
operator|.
name|hasTerms
condition|?
name|BlockTreeTermsWriter
operator|.
name|OUTPUT_FLAG_HAS_TERMS
else|:
literal|0
operator|)
operator|+
operator|(
name|f
operator|.
name|isFloor
condition|?
name|BlockTreeTermsWriter
operator|.
name|OUTPUT_FLAG_IS_FLOOR
else|:
literal|0
operator|)
operator|)
operator|+
literal|" lastSubFP="
operator|+
name|f
operator|.
name|lastSubFP
operator|+
literal|" isLastInFloor="
operator|+
name|f
operator|.
name|isLastInFloor
operator|+
literal|" mdUpto="
operator|+
name|f
operator|.
name|metaDataUpto
operator|+
literal|" tbOrd="
operator|+
name|f
operator|.
name|getTermBlockOrd
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|index
operator|!=
literal|null
condition|)
block|{
assert|assert
operator|!
name|isSeekFrame
operator|||
name|f
operator|.
name|arc
operator|!=
literal|null
operator|:
literal|"isSeekFrame="
operator|+
name|isSeekFrame
operator|+
literal|" f.arc="
operator|+
name|f
operator|.
name|arc
assert|;
if|if
condition|(
name|f
operator|.
name|prefix
operator|>
literal|0
operator|&&
name|isSeekFrame
operator|&&
name|f
operator|.
name|arc
operator|.
name|label
operator|!=
operator|(
name|term
operator|.
name|bytes
index|[
name|f
operator|.
name|prefix
operator|-
literal|1
index|]
operator|&
literal|0xFF
operator|)
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"      broken seek state: arc.label="
operator|+
operator|(
name|char
operator|)
name|f
operator|.
name|arc
operator|.
name|label
operator|+
literal|" vs term byte="
operator|+
call|(
name|char
call|)
argument_list|(
name|term
operator|.
name|bytes
index|[
name|f
operator|.
name|prefix
operator|-
literal|1
index|]
operator|&
literal|0xFF
argument_list|)
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"seek state is broken"
argument_list|)
throw|;
block|}
name|BytesRef
name|output
init|=
name|Util
operator|.
name|get
argument_list|(
name|index
argument_list|,
name|prefix
argument_list|)
decl_stmt|;
if|if
condition|(
name|output
operator|==
literal|null
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"      broken seek state: prefix is not final in index"
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"seek state is broken"
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
name|isSeekFrame
operator|&&
operator|!
name|f
operator|.
name|isFloor
condition|)
block|{
specifier|final
name|ByteArrayDataInput
name|reader
init|=
operator|new
name|ByteArrayDataInput
argument_list|(
name|output
operator|.
name|bytes
argument_list|,
name|output
operator|.
name|offset
argument_list|,
name|output
operator|.
name|length
argument_list|)
decl_stmt|;
specifier|final
name|long
name|codeOrig
init|=
name|reader
operator|.
name|readVLong
argument_list|()
decl_stmt|;
specifier|final
name|long
name|code
init|=
operator|(
name|f
operator|.
name|fp
operator|<<
name|BlockTreeTermsWriter
operator|.
name|OUTPUT_FLAGS_NUM_BITS
operator|)
operator||
operator|(
name|f
operator|.
name|hasTerms
condition|?
name|BlockTreeTermsWriter
operator|.
name|OUTPUT_FLAG_HAS_TERMS
else|:
literal|0
operator|)
operator||
operator|(
name|f
operator|.
name|isFloor
condition|?
name|BlockTreeTermsWriter
operator|.
name|OUTPUT_FLAG_IS_FLOOR
else|:
literal|0
operator|)
decl_stmt|;
if|if
condition|(
name|codeOrig
operator|!=
name|code
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"      broken seek state: output code="
operator|+
name|codeOrig
operator|+
literal|" doesn't match frame code="
operator|+
name|code
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"seek state is broken"
argument_list|)
throw|;
block|}
block|}
block|}
if|if
condition|(
name|f
operator|==
name|currentFrame
condition|)
block|{
break|break;
block|}
if|if
condition|(
name|f
operator|.
name|prefix
operator|==
name|validIndexPrefix
condition|)
block|{
name|isSeekFrame
operator|=
literal|false
expr_stmt|;
block|}
name|ord
operator|++
expr_stmt|;
block|}
block|}
block|}
comment|/* Decodes only the term bytes of the next term.  If caller then asks for          metadata, ie docFreq, totalTermFreq or pulls a D/&PEnum, we then (lazily)          decode all metadata up to the current term. */
annotation|@
name|Override
DECL|method|next
specifier|public
name|BytesRef
name|next
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|in
operator|==
literal|null
condition|)
block|{
comment|// Fresh TermsEnum; seek to first term:
specifier|final
name|FST
operator|.
name|Arc
argument_list|<
name|BytesRef
argument_list|>
name|arc
decl_stmt|;
if|if
condition|(
name|index
operator|!=
literal|null
condition|)
block|{
name|arc
operator|=
name|index
operator|.
name|getFirstArc
argument_list|(
name|arcs
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|// Empty string prefix must have an output in the index!
assert|assert
name|arc
operator|.
name|isFinal
argument_list|()
assert|;
block|}
else|else
block|{
name|arc
operator|=
literal|null
expr_stmt|;
block|}
name|currentFrame
operator|=
name|pushFrame
argument_list|(
name|arc
argument_list|,
name|rootCode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|currentFrame
operator|.
name|loadBlock
argument_list|()
expr_stmt|;
block|}
name|targetBeforeCurrentLength
operator|=
name|currentFrame
operator|.
name|ord
expr_stmt|;
assert|assert
operator|!
name|eof
assert|;
comment|//if (DEBUG) {
comment|//System.out.println("\nBTTR.next seg=" + segment + " term=" + brToString(term) + " termExists?=" + termExists + " field=" + fieldInfo.name + " termBlockOrd=" + currentFrame.state.termBlockOrd + " validIndexPrefix=" + validIndexPrefix);
comment|//printSeekState();
comment|//}
if|if
condition|(
name|currentFrame
operator|==
name|staticFrame
condition|)
block|{
comment|// If seek was previously called and the term was
comment|// cached, or seek(TermState) was called, usually
comment|// caller is just going to pull a D/&PEnum or get
comment|// docFreq, etc.  But, if they then call next(),
comment|// this method catches up all internal state so next()
comment|// works properly:
comment|//if (DEBUG) System.out.println("  re-seek to pending term=" + term.utf8ToString() + " " + term);
specifier|final
name|boolean
name|result
init|=
name|seekExact
argument_list|(
name|term
argument_list|,
literal|false
argument_list|)
decl_stmt|;
assert|assert
name|result
assert|;
block|}
comment|// Pop finished blocks
while|while
condition|(
name|currentFrame
operator|.
name|nextEnt
operator|==
name|currentFrame
operator|.
name|entCount
condition|)
block|{
if|if
condition|(
operator|!
name|currentFrame
operator|.
name|isLastInFloor
condition|)
block|{
name|currentFrame
operator|.
name|loadNextFloorBlock
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|//if (DEBUG) System.out.println("  pop frame");
if|if
condition|(
name|currentFrame
operator|.
name|ord
operator|==
literal|0
condition|)
block|{
comment|//if (DEBUG) System.out.println("  return null");
assert|assert
name|setEOF
argument_list|()
assert|;
name|term
operator|.
name|length
operator|=
literal|0
expr_stmt|;
name|validIndexPrefix
operator|=
literal|0
expr_stmt|;
name|currentFrame
operator|.
name|rewind
argument_list|()
expr_stmt|;
name|termExists
operator|=
literal|false
expr_stmt|;
return|return
literal|null
return|;
block|}
specifier|final
name|long
name|lastFP
init|=
name|currentFrame
operator|.
name|fpOrig
decl_stmt|;
name|currentFrame
operator|=
name|stack
index|[
name|currentFrame
operator|.
name|ord
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|currentFrame
operator|.
name|nextEnt
operator|==
operator|-
literal|1
operator|||
name|currentFrame
operator|.
name|lastSubFP
operator|!=
name|lastFP
condition|)
block|{
comment|// We popped into a frame that's not loaded
comment|// yet or not scan'd to the right entry
name|currentFrame
operator|.
name|scanToFloorFrame
argument_list|(
name|term
argument_list|)
expr_stmt|;
name|currentFrame
operator|.
name|loadBlock
argument_list|()
expr_stmt|;
name|currentFrame
operator|.
name|scanToSubBlock
argument_list|(
name|lastFP
argument_list|)
expr_stmt|;
block|}
comment|// Note that the seek state (last seek) has been
comment|// invalidated beyond this depth
name|validIndexPrefix
operator|=
name|Math
operator|.
name|min
argument_list|(
name|validIndexPrefix
argument_list|,
name|currentFrame
operator|.
name|prefix
argument_list|)
expr_stmt|;
comment|//if (DEBUG) {
comment|//System.out.println("  reset validIndexPrefix=" + validIndexPrefix);
comment|//}
block|}
block|}
while|while
condition|(
literal|true
condition|)
block|{
if|if
condition|(
name|currentFrame
operator|.
name|next
argument_list|()
condition|)
block|{
comment|// Push to new block:
comment|//if (DEBUG) System.out.println("  push frame");
name|currentFrame
operator|=
name|pushFrame
argument_list|(
literal|null
argument_list|,
name|currentFrame
operator|.
name|lastSubFP
argument_list|,
name|term
operator|.
name|length
argument_list|)
expr_stmt|;
comment|// This is a "next" frame -- even if it's
comment|// floor'd we must pretend it isn't so we don't
comment|// try to scan to the right floor frame:
name|currentFrame
operator|.
name|isFloor
operator|=
literal|false
expr_stmt|;
comment|//currentFrame.hasTerms = true;
name|currentFrame
operator|.
name|loadBlock
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|//if (DEBUG) System.out.println("  return term=" + term.utf8ToString() + " " + term + " currentFrame.ord=" + currentFrame.ord);
return|return
name|term
return|;
block|}
block|}
block|}
annotation|@
name|Override
DECL|method|term
specifier|public
name|BytesRef
name|term
parameter_list|()
block|{
assert|assert
operator|!
name|eof
assert|;
return|return
name|term
return|;
block|}
annotation|@
name|Override
DECL|method|docFreq
specifier|public
name|int
name|docFreq
parameter_list|()
throws|throws
name|IOException
block|{
assert|assert
operator|!
name|eof
assert|;
comment|//if (DEBUG) System.out.println("BTR.docFreq");
name|currentFrame
operator|.
name|decodeMetaData
argument_list|()
expr_stmt|;
comment|//if (DEBUG) System.out.println("  return " + currentFrame.state.docFreq);
return|return
name|currentFrame
operator|.
name|state
operator|.
name|docFreq
return|;
block|}
annotation|@
name|Override
DECL|method|totalTermFreq
specifier|public
name|long
name|totalTermFreq
parameter_list|()
throws|throws
name|IOException
block|{
assert|assert
operator|!
name|eof
assert|;
name|currentFrame
operator|.
name|decodeMetaData
argument_list|()
expr_stmt|;
return|return
name|currentFrame
operator|.
name|state
operator|.
name|totalTermFreq
return|;
block|}
annotation|@
name|Override
DECL|method|docs
specifier|public
name|DocsEnum
name|docs
parameter_list|(
name|Bits
name|skipDocs
parameter_list|,
name|DocsEnum
name|reuse
parameter_list|,
name|boolean
name|needsFreqs
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
operator|!
name|eof
assert|;
comment|//if (DEBUG) {
comment|//System.out.println("BTTR.docs seg=" + segment);
comment|//}
name|currentFrame
operator|.
name|decodeMetaData
argument_list|()
expr_stmt|;
comment|//if (DEBUG) {
comment|//System.out.println("  state=" + currentFrame.state);
comment|//}
return|return
name|postingsReader
operator|.
name|docs
argument_list|(
name|fieldInfo
argument_list|,
name|currentFrame
operator|.
name|state
argument_list|,
name|skipDocs
argument_list|,
name|reuse
argument_list|,
name|needsFreqs
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|docsAndPositions
specifier|public
name|DocsAndPositionsEnum
name|docsAndPositions
parameter_list|(
name|Bits
name|skipDocs
parameter_list|,
name|DocsAndPositionsEnum
name|reuse
parameter_list|,
name|boolean
name|needsOffsets
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|fieldInfo
operator|.
name|getIndexOptions
argument_list|()
operator|.
name|compareTo
argument_list|(
name|IndexOptions
operator|.
name|DOCS_AND_FREQS_AND_POSITIONS
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|// Positions were not indexed:
return|return
literal|null
return|;
block|}
if|if
condition|(
name|needsOffsets
operator|&&
name|fieldInfo
operator|.
name|getIndexOptions
argument_list|()
operator|.
name|compareTo
argument_list|(
name|IndexOptions
operator|.
name|DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|// Offsets were not indexed:
return|return
literal|null
return|;
block|}
assert|assert
operator|!
name|eof
assert|;
name|currentFrame
operator|.
name|decodeMetaData
argument_list|()
expr_stmt|;
return|return
name|postingsReader
operator|.
name|docsAndPositions
argument_list|(
name|fieldInfo
argument_list|,
name|currentFrame
operator|.
name|state
argument_list|,
name|skipDocs
argument_list|,
name|reuse
argument_list|,
name|needsOffsets
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|seekExact
specifier|public
name|void
name|seekExact
parameter_list|(
name|BytesRef
name|target
parameter_list|,
name|TermState
name|otherState
parameter_list|)
throws|throws
name|IOException
block|{
comment|// if (DEBUG) {
comment|//   System.out.println("BTTR.seekExact termState seg=" + segment + " target=" + target.utf8ToString() + " " + target + " state=" + otherState);
comment|// }
assert|assert
name|clearEOF
argument_list|()
assert|;
if|if
condition|(
name|target
operator|.
name|compareTo
argument_list|(
name|term
argument_list|)
operator|!=
literal|0
operator|||
operator|!
name|termExists
condition|)
block|{
assert|assert
name|otherState
operator|!=
literal|null
operator|&&
name|otherState
operator|instanceof
name|BlockTermState
assert|;
name|currentFrame
operator|=
name|staticFrame
expr_stmt|;
name|currentFrame
operator|.
name|state
operator|.
name|copyFrom
argument_list|(
name|otherState
argument_list|)
expr_stmt|;
name|term
operator|.
name|copyBytes
argument_list|(
name|target
argument_list|)
expr_stmt|;
name|currentFrame
operator|.
name|metaDataUpto
operator|=
name|currentFrame
operator|.
name|getTermBlockOrd
argument_list|()
expr_stmt|;
assert|assert
name|currentFrame
operator|.
name|metaDataUpto
operator|>
literal|0
assert|;
name|validIndexPrefix
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|// if (DEBUG) {
comment|//   System.out.println("  skip seek: already on target state=" + currentFrame.state);
comment|// }
block|}
block|}
annotation|@
name|Override
DECL|method|termState
specifier|public
name|TermState
name|termState
parameter_list|()
throws|throws
name|IOException
block|{
assert|assert
operator|!
name|eof
assert|;
name|currentFrame
operator|.
name|decodeMetaData
argument_list|()
expr_stmt|;
name|TermState
name|ts
init|=
name|currentFrame
operator|.
name|state
operator|.
name|clone
argument_list|()
decl_stmt|;
comment|//if (DEBUG) System.out.println("BTTR.termState seg=" + segment + " state=" + ts);
return|return
name|ts
return|;
block|}
annotation|@
name|Override
DECL|method|seekExact
specifier|public
name|void
name|seekExact
parameter_list|(
name|long
name|ord
parameter_list|)
throws|throws
name|IOException
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
DECL|method|ord
specifier|public
name|long
name|ord
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
comment|// Not static -- references term, postingsReader,
comment|// fieldInfo, in
DECL|class|Frame
specifier|private
specifier|final
class|class
name|Frame
block|{
comment|// Our index in stack[]:
DECL|field|ord
specifier|final
name|int
name|ord
decl_stmt|;
DECL|field|hasTerms
name|boolean
name|hasTerms
decl_stmt|;
DECL|field|hasTermsOrig
name|boolean
name|hasTermsOrig
decl_stmt|;
DECL|field|isFloor
name|boolean
name|isFloor
decl_stmt|;
DECL|field|arc
name|FST
operator|.
name|Arc
argument_list|<
name|BytesRef
argument_list|>
name|arc
decl_stmt|;
comment|// File pointer where this block was loaded from
DECL|field|fp
name|long
name|fp
decl_stmt|;
DECL|field|fpOrig
name|long
name|fpOrig
decl_stmt|;
DECL|field|fpEnd
name|long
name|fpEnd
decl_stmt|;
DECL|field|suffixBytes
name|byte
index|[]
name|suffixBytes
init|=
operator|new
name|byte
index|[
literal|128
index|]
decl_stmt|;
DECL|field|suffixesReader
specifier|final
name|ByteArrayDataInput
name|suffixesReader
init|=
operator|new
name|ByteArrayDataInput
argument_list|()
decl_stmt|;
DECL|field|statBytes
name|byte
index|[]
name|statBytes
init|=
operator|new
name|byte
index|[
literal|64
index|]
decl_stmt|;
DECL|field|statsReader
specifier|final
name|ByteArrayDataInput
name|statsReader
init|=
operator|new
name|ByteArrayDataInput
argument_list|()
decl_stmt|;
DECL|field|floorData
name|byte
index|[]
name|floorData
init|=
operator|new
name|byte
index|[
literal|32
index|]
decl_stmt|;
DECL|field|floorDataReader
specifier|final
name|ByteArrayDataInput
name|floorDataReader
init|=
operator|new
name|ByteArrayDataInput
argument_list|()
decl_stmt|;
comment|// Length of prefix shared by all terms in this block
DECL|field|prefix
name|int
name|prefix
decl_stmt|;
comment|// Number of entries (term or sub-block) in this block
DECL|field|entCount
name|int
name|entCount
decl_stmt|;
comment|// Which term we will next read, or -1 if the block
comment|// isn't loaded yet
DECL|field|nextEnt
name|int
name|nextEnt
decl_stmt|;
comment|// True if this block is either not a floor block,
comment|// or, it's the last sub-block of a floor block
DECL|field|isLastInFloor
name|boolean
name|isLastInFloor
decl_stmt|;
comment|// True if all entries are terms
DECL|field|isLeafBlock
name|boolean
name|isLeafBlock
decl_stmt|;
DECL|field|lastSubFP
name|long
name|lastSubFP
decl_stmt|;
DECL|field|nextFloorLabel
name|int
name|nextFloorLabel
decl_stmt|;
DECL|field|numFollowFloorBlocks
name|int
name|numFollowFloorBlocks
decl_stmt|;
comment|// Next term to decode metaData; we decode metaData
comment|// lazily so that scanning to find the matching term is
comment|// fast and only if you find a match and app wants the
comment|// stats or docs/positions enums, will we decode the
comment|// metaData
DECL|field|metaDataUpto
name|int
name|metaDataUpto
decl_stmt|;
DECL|field|state
specifier|final
name|BlockTermState
name|state
decl_stmt|;
DECL|method|Frame
specifier|public
name|Frame
parameter_list|(
name|int
name|ord
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|ord
operator|=
name|ord
expr_stmt|;
name|state
operator|=
name|postingsReader
operator|.
name|newTermState
argument_list|()
expr_stmt|;
name|state
operator|.
name|totalTermFreq
operator|=
operator|-
literal|1
expr_stmt|;
block|}
DECL|method|setFloorData
specifier|public
name|void
name|setFloorData
parameter_list|(
name|ByteArrayDataInput
name|in
parameter_list|,
name|BytesRef
name|source
parameter_list|)
block|{
specifier|final
name|int
name|numBytes
init|=
name|source
operator|.
name|length
operator|-
operator|(
name|in
operator|.
name|getPosition
argument_list|()
operator|-
name|source
operator|.
name|offset
operator|)
decl_stmt|;
if|if
condition|(
name|numBytes
operator|>
name|floorData
operator|.
name|length
condition|)
block|{
name|floorData
operator|=
operator|new
name|byte
index|[
name|ArrayUtil
operator|.
name|oversize
argument_list|(
name|numBytes
argument_list|,
literal|1
argument_list|)
index|]
expr_stmt|;
block|}
name|System
operator|.
name|arraycopy
argument_list|(
name|source
operator|.
name|bytes
argument_list|,
name|source
operator|.
name|offset
operator|+
name|in
operator|.
name|getPosition
argument_list|()
argument_list|,
name|floorData
argument_list|,
literal|0
argument_list|,
name|numBytes
argument_list|)
expr_stmt|;
name|floorDataReader
operator|.
name|reset
argument_list|(
name|floorData
argument_list|,
literal|0
argument_list|,
name|numBytes
argument_list|)
expr_stmt|;
name|numFollowFloorBlocks
operator|=
name|floorDataReader
operator|.
name|readVInt
argument_list|()
expr_stmt|;
name|nextFloorLabel
operator|=
name|floorDataReader
operator|.
name|readByte
argument_list|()
operator|&
literal|0xff
expr_stmt|;
comment|//if (DEBUG) {
comment|//System.out.println("    setFloorData fpOrig=" + fpOrig + " bytes=" + new BytesRef(source.bytes, source.offset + in.getPosition(), numBytes) + " numFollowFloorBlocks=" + numFollowFloorBlocks + " nextFloorLabel=" + toHex(nextFloorLabel));
comment|//}
block|}
DECL|method|getTermBlockOrd
specifier|public
name|int
name|getTermBlockOrd
parameter_list|()
block|{
return|return
name|isLeafBlock
condition|?
name|nextEnt
else|:
name|state
operator|.
name|termBlockOrd
return|;
block|}
DECL|method|loadNextFloorBlock
name|void
name|loadNextFloorBlock
parameter_list|()
throws|throws
name|IOException
block|{
comment|//if (DEBUG) {
comment|//System.out.println("    loadNextFloorBlock fp=" + fp + " fpEnd=" + fpEnd);
comment|//}
assert|assert
name|arc
operator|==
literal|null
operator|||
name|isFloor
operator|:
literal|"arc="
operator|+
name|arc
operator|+
literal|" isFloor="
operator|+
name|isFloor
assert|;
name|fp
operator|=
name|fpEnd
expr_stmt|;
name|nextEnt
operator|=
operator|-
literal|1
expr_stmt|;
name|loadBlock
argument_list|()
expr_stmt|;
block|}
comment|/* Does initial decode of next block of terms; this            doesn't actually decode the docFreq, totalTermFreq,            postings details (frq/prx offset, etc.) metadata;            it just loads them as byte[] blobs which are then                  decoded on-demand if the metadata is ever requested            for any term in this block.  This enables terms-only            intensive consumes (eg certain MTQs, respelling) to            not pay the price of decoding metadata they won't            use. */
DECL|method|loadBlock
name|void
name|loadBlock
parameter_list|()
throws|throws
name|IOException
block|{
comment|// Clone the IndexInput lazily, so that consumers
comment|// that just pull a TermsEnum to
comment|// seekExact(TermState) don't pay this cost:
name|initIndexInput
argument_list|()
expr_stmt|;
if|if
condition|(
name|nextEnt
operator|!=
operator|-
literal|1
condition|)
block|{
comment|// Already loaded
return|return;
block|}
comment|//System.out.println("blc=" + blockLoadCount);
name|in
operator|.
name|seek
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|int
name|code
init|=
name|in
operator|.
name|readVInt
argument_list|()
decl_stmt|;
name|entCount
operator|=
name|code
operator|>>>
literal|1
expr_stmt|;
assert|assert
name|entCount
operator|>
literal|0
assert|;
name|isLastInFloor
operator|=
operator|(
name|code
operator|&
literal|1
operator|)
operator|!=
literal|0
expr_stmt|;
assert|assert
name|arc
operator|==
literal|null
operator|||
operator|(
name|isLastInFloor
operator|||
name|isFloor
operator|)
assert|;
comment|// TODO: if suffixes were stored in random-access
comment|// array structure, then we could do binary search
comment|// instead of linear scan to find target term; eg
comment|// we could have simple array of offsets
comment|// term suffixes:
name|code
operator|=
name|in
operator|.
name|readVInt
argument_list|()
expr_stmt|;
name|isLeafBlock
operator|=
operator|(
name|code
operator|&
literal|1
operator|)
operator|!=
literal|0
expr_stmt|;
name|int
name|numBytes
init|=
name|code
operator|>>>
literal|1
decl_stmt|;
if|if
condition|(
name|suffixBytes
operator|.
name|length
operator|<
name|numBytes
condition|)
block|{
name|suffixBytes
operator|=
operator|new
name|byte
index|[
name|ArrayUtil
operator|.
name|oversize
argument_list|(
name|numBytes
argument_list|,
literal|1
argument_list|)
index|]
expr_stmt|;
block|}
name|in
operator|.
name|readBytes
argument_list|(
name|suffixBytes
argument_list|,
literal|0
argument_list|,
name|numBytes
argument_list|)
expr_stmt|;
name|suffixesReader
operator|.
name|reset
argument_list|(
name|suffixBytes
argument_list|,
literal|0
argument_list|,
name|numBytes
argument_list|)
expr_stmt|;
comment|/*if (DEBUG) {             if (arc == null) {               System.out.println("    loadBlock (next) fp=" + fp + " entCount=" + entCount + " prefixLen=" + prefix + " isLastInFloor=" + isLastInFloor + " leaf?=" + isLeafBlock);             } else {               System.out.println("    loadBlock (seek) fp=" + fp + " entCount=" + entCount + " prefixLen=" + prefix + " hasTerms?=" + hasTerms + " isFloor?=" + isFloor + " isLastInFloor=" + isLastInFloor + " leaf?=" + isLeafBlock);             }             }*/
comment|// stats
name|numBytes
operator|=
name|in
operator|.
name|readVInt
argument_list|()
expr_stmt|;
if|if
condition|(
name|statBytes
operator|.
name|length
operator|<
name|numBytes
condition|)
block|{
name|statBytes
operator|=
operator|new
name|byte
index|[
name|ArrayUtil
operator|.
name|oversize
argument_list|(
name|numBytes
argument_list|,
literal|1
argument_list|)
index|]
expr_stmt|;
block|}
name|in
operator|.
name|readBytes
argument_list|(
name|statBytes
argument_list|,
literal|0
argument_list|,
name|numBytes
argument_list|)
expr_stmt|;
name|statsReader
operator|.
name|reset
argument_list|(
name|statBytes
argument_list|,
literal|0
argument_list|,
name|numBytes
argument_list|)
expr_stmt|;
name|metaDataUpto
operator|=
literal|0
expr_stmt|;
name|state
operator|.
name|termBlockOrd
operator|=
literal|0
expr_stmt|;
name|nextEnt
operator|=
literal|0
expr_stmt|;
name|lastSubFP
operator|=
operator|-
literal|1
expr_stmt|;
comment|// TODO: we could skip this if !hasTerms; but
comment|// that's rare so won't help much
name|postingsReader
operator|.
name|readTermsBlock
argument_list|(
name|in
argument_list|,
name|fieldInfo
argument_list|,
name|state
argument_list|)
expr_stmt|;
comment|// Sub-blocks of a single floor block are always
comment|// written one after another -- tail recurse:
name|fpEnd
operator|=
name|in
operator|.
name|getFilePointer
argument_list|()
expr_stmt|;
comment|// if (DEBUG) {
comment|//   System.out.println("      fpEnd=" + fpEnd);
comment|// }
block|}
DECL|method|rewind
name|void
name|rewind
parameter_list|()
throws|throws
name|IOException
block|{
comment|// Force reload:
name|fp
operator|=
name|fpOrig
expr_stmt|;
name|nextEnt
operator|=
operator|-
literal|1
expr_stmt|;
name|hasTerms
operator|=
name|hasTermsOrig
expr_stmt|;
if|if
condition|(
name|isFloor
condition|)
block|{
name|floorDataReader
operator|.
name|rewind
argument_list|()
expr_stmt|;
name|numFollowFloorBlocks
operator|=
name|floorDataReader
operator|.
name|readVInt
argument_list|()
expr_stmt|;
name|nextFloorLabel
operator|=
name|floorDataReader
operator|.
name|readByte
argument_list|()
operator|&
literal|0xff
expr_stmt|;
block|}
comment|/*           //System.out.println("rewind");           // Keeps the block loaded, but rewinds its state:           if (nextEnt> 0 || fp != fpOrig) {             if (DEBUG) {               System.out.println("      rewind frame ord=" + ord + " fpOrig=" + fpOrig + " fp=" + fp + " hasTerms?=" + hasTerms + " isFloor?=" + isFloor + " nextEnt=" + nextEnt + " prefixLen=" + prefix);             }             if (fp != fpOrig) {               fp = fpOrig;               nextEnt = -1;             } else {               nextEnt = 0;             }             hasTerms = hasTermsOrig;             if (isFloor) {               floorDataReader.rewind();               numFollowFloorBlocks = floorDataReader.readVInt();               nextFloorLabel = floorDataReader.readByte()& 0xff;             }             assert suffixBytes != null;             suffixesReader.rewind();             assert statBytes != null;             statsReader.rewind();             metaDataUpto = 0;             state.termBlockOrd = 0;             // TODO: skip this if !hasTerms?  Then postings             // impl wouldn't have to write useless 0 byte             postingsReader.resetTermsBlock(fieldInfo, state);             lastSubFP = -1;           } else if (DEBUG) {             System.out.println("      skip rewind fp=" + fp + " fpOrig=" + fpOrig + " nextEnt=" + nextEnt + " ord=" + ord);           }           */
block|}
DECL|method|next
specifier|public
name|boolean
name|next
parameter_list|()
block|{
return|return
name|isLeafBlock
condition|?
name|nextLeaf
argument_list|()
else|:
name|nextNonLeaf
argument_list|()
return|;
block|}
comment|// Decodes next entry; returns true if it's a sub-block
DECL|method|nextLeaf
specifier|public
name|boolean
name|nextLeaf
parameter_list|()
block|{
comment|//if (DEBUG) System.out.println("  frame.next ord=" + ord + " nextEnt=" + nextEnt + " entCount=" + entCount);
assert|assert
name|nextEnt
operator|!=
operator|-
literal|1
operator|&&
name|nextEnt
operator|<
name|entCount
operator|:
literal|"nextEnt="
operator|+
name|nextEnt
operator|+
literal|" entCount="
operator|+
name|entCount
operator|+
literal|" fp="
operator|+
name|fp
assert|;
name|nextEnt
operator|++
expr_stmt|;
name|suffix
operator|=
name|suffixesReader
operator|.
name|readVInt
argument_list|()
expr_stmt|;
name|startBytePos
operator|=
name|suffixesReader
operator|.
name|getPosition
argument_list|()
expr_stmt|;
name|term
operator|.
name|length
operator|=
name|prefix
operator|+
name|suffix
expr_stmt|;
if|if
condition|(
name|term
operator|.
name|bytes
operator|.
name|length
operator|<
name|term
operator|.
name|length
condition|)
block|{
name|term
operator|.
name|grow
argument_list|(
name|term
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
name|suffixesReader
operator|.
name|readBytes
argument_list|(
name|term
operator|.
name|bytes
argument_list|,
name|prefix
argument_list|,
name|suffix
argument_list|)
expr_stmt|;
comment|// A normal term
name|termExists
operator|=
literal|true
expr_stmt|;
return|return
literal|false
return|;
block|}
DECL|method|nextNonLeaf
specifier|public
name|boolean
name|nextNonLeaf
parameter_list|()
block|{
comment|//if (DEBUG) System.out.println("  frame.next ord=" + ord + " nextEnt=" + nextEnt + " entCount=" + entCount);
assert|assert
name|nextEnt
operator|!=
operator|-
literal|1
operator|&&
name|nextEnt
operator|<
name|entCount
operator|:
literal|"nextEnt="
operator|+
name|nextEnt
operator|+
literal|" entCount="
operator|+
name|entCount
operator|+
literal|" fp="
operator|+
name|fp
assert|;
name|nextEnt
operator|++
expr_stmt|;
specifier|final
name|int
name|code
init|=
name|suffixesReader
operator|.
name|readVInt
argument_list|()
decl_stmt|;
name|suffix
operator|=
name|code
operator|>>>
literal|1
expr_stmt|;
name|startBytePos
operator|=
name|suffixesReader
operator|.
name|getPosition
argument_list|()
expr_stmt|;
name|term
operator|.
name|length
operator|=
name|prefix
operator|+
name|suffix
expr_stmt|;
if|if
condition|(
name|term
operator|.
name|bytes
operator|.
name|length
operator|<
name|term
operator|.
name|length
condition|)
block|{
name|term
operator|.
name|grow
argument_list|(
name|term
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
name|suffixesReader
operator|.
name|readBytes
argument_list|(
name|term
operator|.
name|bytes
argument_list|,
name|prefix
argument_list|,
name|suffix
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|code
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
block|{
comment|// A normal term
name|termExists
operator|=
literal|true
expr_stmt|;
name|subCode
operator|=
literal|0
expr_stmt|;
name|state
operator|.
name|termBlockOrd
operator|++
expr_stmt|;
return|return
literal|false
return|;
block|}
else|else
block|{
comment|// A sub-block; make sub-FP absolute:
name|termExists
operator|=
literal|false
expr_stmt|;
name|subCode
operator|=
name|suffixesReader
operator|.
name|readVLong
argument_list|()
expr_stmt|;
name|lastSubFP
operator|=
name|fp
operator|-
name|subCode
expr_stmt|;
comment|//if (DEBUG) {
comment|//System.out.println("    lastSubFP=" + lastSubFP);
comment|//}
return|return
literal|true
return|;
block|}
block|}
comment|// TODO: make this array'd so we can do bin search?
comment|// likely not worth it?  need to measure how many
comment|// floor blocks we "typically" get
DECL|method|scanToFloorFrame
specifier|public
name|void
name|scanToFloorFrame
parameter_list|(
name|BytesRef
name|target
parameter_list|)
block|{
if|if
condition|(
operator|!
name|isFloor
operator|||
name|target
operator|.
name|length
operator|<=
name|prefix
condition|)
block|{
comment|// if (DEBUG) {
comment|//   System.out.println("    scanToFloorFrame skip: isFloor=" + isFloor + " target.length=" + target.length + " vs prefix=" + prefix);
comment|// }
return|return;
block|}
specifier|final
name|int
name|targetLabel
init|=
name|target
operator|.
name|bytes
index|[
name|target
operator|.
name|offset
operator|+
name|prefix
index|]
operator|&
literal|0xFF
decl_stmt|;
comment|// if (DEBUG) {
comment|//   System.out.println("    scanToFloorFrame fpOrig=" + fpOrig + " targetLabel=" + toHex(targetLabel) + " vs nextFloorLabel=" + toHex(nextFloorLabel) + " numFollowFloorBlocks=" + numFollowFloorBlocks);
comment|// }
if|if
condition|(
name|targetLabel
operator|<
name|nextFloorLabel
condition|)
block|{
comment|// if (DEBUG) {
comment|//   System.out.println("      already on correct block");
comment|// }
return|return;
block|}
assert|assert
name|numFollowFloorBlocks
operator|!=
literal|0
assert|;
name|long
name|newFP
init|=
name|fpOrig
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
specifier|final
name|long
name|code
init|=
name|floorDataReader
operator|.
name|readVLong
argument_list|()
decl_stmt|;
name|newFP
operator|=
name|fpOrig
operator|+
operator|(
name|code
operator|>>>
literal|1
operator|)
expr_stmt|;
name|hasTerms
operator|=
operator|(
name|code
operator|&
literal|1
operator|)
operator|!=
literal|0
expr_stmt|;
comment|// if (DEBUG) {
comment|//   System.out.println("      label=" + toHex(nextFloorLabel) + " fp=" + newFP + " hasTerms?=" + hasTerms + " numFollowFloor=" + numFollowFloorBlocks);
comment|// }
name|isLastInFloor
operator|=
name|numFollowFloorBlocks
operator|==
literal|1
expr_stmt|;
name|numFollowFloorBlocks
operator|--
expr_stmt|;
if|if
condition|(
name|isLastInFloor
condition|)
block|{
name|nextFloorLabel
operator|=
literal|256
expr_stmt|;
comment|// if (DEBUG) {
comment|//   System.out.println("        stop!  last block nextFloorLabel=" + toHex(nextFloorLabel));
comment|// }
break|break;
block|}
else|else
block|{
name|nextFloorLabel
operator|=
name|floorDataReader
operator|.
name|readByte
argument_list|()
operator|&
literal|0xff
expr_stmt|;
if|if
condition|(
name|targetLabel
operator|<
name|nextFloorLabel
condition|)
block|{
comment|// if (DEBUG) {
comment|//   System.out.println("        stop!  nextFloorLabel=" + toHex(nextFloorLabel));
comment|// }
break|break;
block|}
block|}
block|}
if|if
condition|(
name|newFP
operator|!=
name|fp
condition|)
block|{
comment|// Force re-load of the block:
comment|// if (DEBUG) {
comment|//   System.out.println("      force switch to fp=" + newFP + " oldFP=" + fp);
comment|// }
name|nextEnt
operator|=
operator|-
literal|1
expr_stmt|;
name|fp
operator|=
name|newFP
expr_stmt|;
block|}
else|else
block|{
comment|// if (DEBUG) {
comment|//   System.out.println("      stay on same fp=" + newFP);
comment|// }
block|}
block|}
DECL|method|decodeMetaData
specifier|public
name|void
name|decodeMetaData
parameter_list|()
throws|throws
name|IOException
block|{
comment|//if (DEBUG) System.out.println("\nBTTR.decodeMetadata seg=" + segment + " mdUpto=" + metaDataUpto + " vs termBlockOrd=" + state.termBlockOrd);
comment|// lazily catch up on metadata decode:
specifier|final
name|int
name|limit
init|=
name|getTermBlockOrd
argument_list|()
decl_stmt|;
assert|assert
name|limit
operator|>
literal|0
assert|;
comment|// We must set/incr state.termCount because
comment|// postings impl can look at this
name|state
operator|.
name|termBlockOrd
operator|=
name|metaDataUpto
expr_stmt|;
comment|// TODO: better API would be "jump straight to term=N"???
while|while
condition|(
name|metaDataUpto
operator|<
name|limit
condition|)
block|{
comment|// TODO: we could make "tiers" of metadata, ie,
comment|// decode docFreq/totalTF but don't decode postings
comment|// metadata; this way caller could get
comment|// docFreq/totalTF w/o paying decode cost for
comment|// postings
comment|// TODO: if docFreq were bulk decoded we could
comment|// just skipN here:
name|state
operator|.
name|docFreq
operator|=
name|statsReader
operator|.
name|readVInt
argument_list|()
expr_stmt|;
comment|//if (DEBUG) System.out.println("    dF=" + state.docFreq);
if|if
condition|(
name|fieldInfo
operator|.
name|getIndexOptions
argument_list|()
operator|!=
name|IndexOptions
operator|.
name|DOCS_ONLY
condition|)
block|{
name|state
operator|.
name|totalTermFreq
operator|=
name|state
operator|.
name|docFreq
operator|+
name|statsReader
operator|.
name|readVLong
argument_list|()
expr_stmt|;
comment|//if (DEBUG) System.out.println("    totTF=" + state.totalTermFreq);
block|}
name|postingsReader
operator|.
name|nextTerm
argument_list|(
name|fieldInfo
argument_list|,
name|state
argument_list|)
expr_stmt|;
name|metaDataUpto
operator|++
expr_stmt|;
name|state
operator|.
name|termBlockOrd
operator|++
expr_stmt|;
block|}
block|}
comment|// Used only by assert
DECL|method|prefixMatches
specifier|private
name|boolean
name|prefixMatches
parameter_list|(
name|BytesRef
name|target
parameter_list|)
block|{
for|for
control|(
name|int
name|bytePos
init|=
literal|0
init|;
name|bytePos
operator|<
name|prefix
condition|;
name|bytePos
operator|++
control|)
block|{
if|if
condition|(
name|target
operator|.
name|bytes
index|[
name|target
operator|.
name|offset
operator|+
name|bytePos
index|]
operator|!=
name|term
operator|.
name|bytes
index|[
name|bytePos
index|]
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
comment|// Scans to sub-block that has this target fp; only
comment|// called by next(); NOTE: does not set
comment|// startBytePos/suffix as a side effect
DECL|method|scanToSubBlock
specifier|public
name|void
name|scanToSubBlock
parameter_list|(
name|long
name|subFP
parameter_list|)
block|{
assert|assert
operator|!
name|isLeafBlock
assert|;
comment|//if (DEBUG) System.out.println("  scanToSubBlock fp=" + fp + " subFP=" + subFP + " entCount=" + entCount + " lastSubFP=" + lastSubFP);
comment|//assert nextEnt == 0;
if|if
condition|(
name|lastSubFP
operator|==
name|subFP
condition|)
block|{
comment|//if (DEBUG) System.out.println("    already positioned");
return|return;
block|}
assert|assert
name|subFP
operator|<
name|fp
operator|:
literal|"fp="
operator|+
name|fp
operator|+
literal|" subFP="
operator|+
name|subFP
assert|;
specifier|final
name|long
name|targetSubCode
init|=
name|fp
operator|-
name|subFP
decl_stmt|;
comment|//if (DEBUG) System.out.println("    targetSubCode=" + targetSubCode);
while|while
condition|(
literal|true
condition|)
block|{
assert|assert
name|nextEnt
operator|<
name|entCount
assert|;
name|nextEnt
operator|++
expr_stmt|;
specifier|final
name|int
name|code
init|=
name|suffixesReader
operator|.
name|readVInt
argument_list|()
decl_stmt|;
name|suffixesReader
operator|.
name|skipBytes
argument_list|(
name|isLeafBlock
condition|?
name|code
else|:
name|code
operator|>>>
literal|1
argument_list|)
expr_stmt|;
comment|//if (DEBUG) System.out.println("    " + nextEnt + " (of " + entCount + ") ent isSubBlock=" + ((code&1)==1));
if|if
condition|(
operator|(
name|code
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
block|{
specifier|final
name|long
name|subCode
init|=
name|suffixesReader
operator|.
name|readVLong
argument_list|()
decl_stmt|;
comment|//if (DEBUG) System.out.println("      subCode=" + subCode);
if|if
condition|(
name|targetSubCode
operator|==
name|subCode
condition|)
block|{
comment|//if (DEBUG) System.out.println("        match!");
name|lastSubFP
operator|=
name|subFP
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
name|state
operator|.
name|termBlockOrd
operator|++
expr_stmt|;
block|}
block|}
block|}
comment|// NOTE: sets startBytePos/suffix as a side effect
DECL|method|scanToTerm
specifier|public
name|SeekStatus
name|scanToTerm
parameter_list|(
name|BytesRef
name|target
parameter_list|,
name|boolean
name|exactOnly
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|isLeafBlock
condition|?
name|scanToTermLeaf
argument_list|(
name|target
argument_list|,
name|exactOnly
argument_list|)
else|:
name|scanToTermNonLeaf
argument_list|(
name|target
argument_list|,
name|exactOnly
argument_list|)
return|;
block|}
DECL|field|startBytePos
specifier|private
name|int
name|startBytePos
decl_stmt|;
DECL|field|suffix
specifier|private
name|int
name|suffix
decl_stmt|;
DECL|field|subCode
specifier|private
name|long
name|subCode
decl_stmt|;
comment|// Target's prefix matches this block's prefix; we
comment|// scan the entries check if the suffix matches.
DECL|method|scanToTermLeaf
specifier|public
name|SeekStatus
name|scanToTermLeaf
parameter_list|(
name|BytesRef
name|target
parameter_list|,
name|boolean
name|exactOnly
parameter_list|)
throws|throws
name|IOException
block|{
comment|// if (DEBUG) System.out.println("    scanToTermLeaf: block fp=" + fp + " prefix=" + prefix + " nextEnt=" + nextEnt + " (of " + entCount + ") target=" + brToString(target) + " term=" + brToString(term));
assert|assert
name|nextEnt
operator|!=
operator|-
literal|1
assert|;
name|termExists
operator|=
literal|true
expr_stmt|;
name|subCode
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|nextEnt
operator|==
name|entCount
condition|)
block|{
if|if
condition|(
name|exactOnly
condition|)
block|{
name|fillTerm
argument_list|()
expr_stmt|;
block|}
return|return
name|SeekStatus
operator|.
name|END
return|;
block|}
assert|assert
name|prefixMatches
argument_list|(
name|target
argument_list|)
assert|;
comment|// Loop over each entry (term or sub-block) in this block:
comment|//nextTerm: while(nextEnt< entCount) {
name|nextTerm
label|:
while|while
condition|(
literal|true
condition|)
block|{
name|nextEnt
operator|++
expr_stmt|;
name|suffix
operator|=
name|suffixesReader
operator|.
name|readVInt
argument_list|()
expr_stmt|;
comment|// if (DEBUG) {
comment|//   BytesRef suffixBytesRef = new BytesRef();
comment|//   suffixBytesRef.bytes = suffixBytes;
comment|//   suffixBytesRef.offset = suffixesReader.getPosition();
comment|//   suffixBytesRef.length = suffix;
comment|//   System.out.println("      cycle: term " + (nextEnt-1) + " (of " + entCount + ") suffix=" + brToString(suffixBytesRef));
comment|// }
specifier|final
name|int
name|termLen
init|=
name|prefix
operator|+
name|suffix
decl_stmt|;
name|startBytePos
operator|=
name|suffixesReader
operator|.
name|getPosition
argument_list|()
expr_stmt|;
name|suffixesReader
operator|.
name|skipBytes
argument_list|(
name|suffix
argument_list|)
expr_stmt|;
specifier|final
name|int
name|targetLimit
init|=
name|target
operator|.
name|offset
operator|+
operator|(
name|target
operator|.
name|length
operator|<
name|termLen
condition|?
name|target
operator|.
name|length
else|:
name|termLen
operator|)
decl_stmt|;
name|int
name|targetPos
init|=
name|target
operator|.
name|offset
operator|+
name|prefix
decl_stmt|;
comment|// Loop over bytes in the suffix, comparing to
comment|// the target
name|int
name|bytePos
init|=
name|startBytePos
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
specifier|final
name|int
name|cmp
decl_stmt|;
specifier|final
name|boolean
name|stop
decl_stmt|;
if|if
condition|(
name|targetPos
operator|<
name|targetLimit
condition|)
block|{
name|cmp
operator|=
operator|(
name|suffixBytes
index|[
name|bytePos
operator|++
index|]
operator|&
literal|0xFF
operator|)
operator|-
operator|(
name|target
operator|.
name|bytes
index|[
name|targetPos
operator|++
index|]
operator|&
literal|0xFF
operator|)
expr_stmt|;
name|stop
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
assert|assert
name|targetPos
operator|==
name|targetLimit
assert|;
name|cmp
operator|=
name|termLen
operator|-
name|target
operator|.
name|length
expr_stmt|;
name|stop
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|cmp
operator|<
literal|0
condition|)
block|{
comment|// Current entry is still before the target;
comment|// keep scanning
if|if
condition|(
name|nextEnt
operator|==
name|entCount
condition|)
block|{
if|if
condition|(
name|exactOnly
condition|)
block|{
name|fillTerm
argument_list|()
expr_stmt|;
block|}
comment|// We are done scanning this block
break|break
name|nextTerm
break|;
block|}
else|else
block|{
continue|continue
name|nextTerm
continue|;
block|}
block|}
elseif|else
if|if
condition|(
name|cmp
operator|>
literal|0
condition|)
block|{
comment|// Done!  Current entry is after target --
comment|// return NOT_FOUND:
name|fillTerm
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|exactOnly
operator|&&
operator|!
name|termExists
condition|)
block|{
comment|// We are on a sub-block, and caller wants
comment|// us to position to the next term after
comment|// the target, so we must recurse into the
comment|// sub-frame(s):
name|currentFrame
operator|=
name|pushFrame
argument_list|(
literal|null
argument_list|,
name|currentFrame
operator|.
name|lastSubFP
argument_list|,
name|termLen
argument_list|)
expr_stmt|;
name|currentFrame
operator|.
name|loadBlock
argument_list|()
expr_stmt|;
while|while
condition|(
name|currentFrame
operator|.
name|next
argument_list|()
condition|)
block|{
name|currentFrame
operator|=
name|pushFrame
argument_list|(
literal|null
argument_list|,
name|currentFrame
operator|.
name|lastSubFP
argument_list|,
name|term
operator|.
name|length
argument_list|)
expr_stmt|;
name|currentFrame
operator|.
name|loadBlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|//if (DEBUG) System.out.println("        not found");
return|return
name|SeekStatus
operator|.
name|NOT_FOUND
return|;
block|}
elseif|else
if|if
condition|(
name|stop
condition|)
block|{
comment|// Exact match!
comment|// This cannot be a sub-block because we
comment|// would have followed the index to this
comment|// sub-block from the start:
assert|assert
name|termExists
assert|;
name|fillTerm
argument_list|()
expr_stmt|;
comment|//if (DEBUG) System.out.println("        found!");
return|return
name|SeekStatus
operator|.
name|FOUND
return|;
block|}
block|}
block|}
comment|// It is possible (and OK) that terms index pointed us
comment|// at this block, but, we scanned the entire block and
comment|// did not find the term to position to.  This happens
comment|// when the target is after the last term in the block
comment|// (but, before the next term in the index).  EG
comment|// target could be foozzz, and terms index pointed us
comment|// to the foo* block, but the last term in this block
comment|// was fooz (and, eg, first term in the next block will
comment|// bee fop).
comment|//if (DEBUG) System.out.println("      block end");
if|if
condition|(
name|exactOnly
condition|)
block|{
name|fillTerm
argument_list|()
expr_stmt|;
block|}
comment|// TODO: not consistent that in the
comment|// not-exact case we don't next() into the next
comment|// frame here
return|return
name|SeekStatus
operator|.
name|END
return|;
block|}
comment|// Target's prefix matches this block's prefix; we
comment|// scan the entries check if the suffix matches.
DECL|method|scanToTermNonLeaf
specifier|public
name|SeekStatus
name|scanToTermNonLeaf
parameter_list|(
name|BytesRef
name|target
parameter_list|,
name|boolean
name|exactOnly
parameter_list|)
throws|throws
name|IOException
block|{
comment|//if (DEBUG) System.out.println("    scanToTermNonLeaf: block fp=" + fp + " prefix=" + prefix + " nextEnt=" + nextEnt + " (of " + entCount + ") target=" + brToString(target) + " term=" + brToString(term));
assert|assert
name|nextEnt
operator|!=
operator|-
literal|1
assert|;
if|if
condition|(
name|nextEnt
operator|==
name|entCount
condition|)
block|{
if|if
condition|(
name|exactOnly
condition|)
block|{
name|fillTerm
argument_list|()
expr_stmt|;
name|termExists
operator|=
name|subCode
operator|==
literal|0
expr_stmt|;
block|}
return|return
name|SeekStatus
operator|.
name|END
return|;
block|}
assert|assert
name|prefixMatches
argument_list|(
name|target
argument_list|)
assert|;
comment|// Loop over each entry (term or sub-block) in this block:
comment|//nextTerm: while(nextEnt< entCount) {
name|nextTerm
label|:
while|while
condition|(
literal|true
condition|)
block|{
name|nextEnt
operator|++
expr_stmt|;
specifier|final
name|int
name|code
init|=
name|suffixesReader
operator|.
name|readVInt
argument_list|()
decl_stmt|;
name|suffix
operator|=
name|code
operator|>>>
literal|1
expr_stmt|;
comment|// if (DEBUG) {
comment|//   BytesRef suffixBytesRef = new BytesRef();
comment|//   suffixBytesRef.bytes = suffixBytes;
comment|//   suffixBytesRef.offset = suffixesReader.getPosition();
comment|//   suffixBytesRef.length = suffix;
comment|//   System.out.println("      cycle: " + ((code&1)==1 ? "sub-block" : "term") + " " + (nextEnt-1) + " (of " + entCount + ") suffix=" + brToString(suffixBytesRef));
comment|// }
name|termExists
operator|=
operator|(
name|code
operator|&
literal|1
operator|)
operator|==
literal|0
expr_stmt|;
specifier|final
name|int
name|termLen
init|=
name|prefix
operator|+
name|suffix
decl_stmt|;
name|startBytePos
operator|=
name|suffixesReader
operator|.
name|getPosition
argument_list|()
expr_stmt|;
name|suffixesReader
operator|.
name|skipBytes
argument_list|(
name|suffix
argument_list|)
expr_stmt|;
if|if
condition|(
name|termExists
condition|)
block|{
name|state
operator|.
name|termBlockOrd
operator|++
expr_stmt|;
name|subCode
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|subCode
operator|=
name|suffixesReader
operator|.
name|readVLong
argument_list|()
expr_stmt|;
name|lastSubFP
operator|=
name|fp
operator|-
name|subCode
expr_stmt|;
block|}
specifier|final
name|int
name|targetLimit
init|=
name|target
operator|.
name|offset
operator|+
operator|(
name|target
operator|.
name|length
operator|<
name|termLen
condition|?
name|target
operator|.
name|length
else|:
name|termLen
operator|)
decl_stmt|;
name|int
name|targetPos
init|=
name|target
operator|.
name|offset
operator|+
name|prefix
decl_stmt|;
comment|// Loop over bytes in the suffix, comparing to
comment|// the target
name|int
name|bytePos
init|=
name|startBytePos
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
specifier|final
name|int
name|cmp
decl_stmt|;
specifier|final
name|boolean
name|stop
decl_stmt|;
if|if
condition|(
name|targetPos
operator|<
name|targetLimit
condition|)
block|{
name|cmp
operator|=
operator|(
name|suffixBytes
index|[
name|bytePos
operator|++
index|]
operator|&
literal|0xFF
operator|)
operator|-
operator|(
name|target
operator|.
name|bytes
index|[
name|targetPos
operator|++
index|]
operator|&
literal|0xFF
operator|)
expr_stmt|;
name|stop
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
assert|assert
name|targetPos
operator|==
name|targetLimit
assert|;
name|cmp
operator|=
name|termLen
operator|-
name|target
operator|.
name|length
expr_stmt|;
name|stop
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|cmp
operator|<
literal|0
condition|)
block|{
comment|// Current entry is still before the target;
comment|// keep scanning
if|if
condition|(
name|nextEnt
operator|==
name|entCount
condition|)
block|{
if|if
condition|(
name|exactOnly
condition|)
block|{
name|fillTerm
argument_list|()
expr_stmt|;
comment|//termExists = true;
block|}
comment|// We are done scanning this block
break|break
name|nextTerm
break|;
block|}
else|else
block|{
continue|continue
name|nextTerm
continue|;
block|}
block|}
elseif|else
if|if
condition|(
name|cmp
operator|>
literal|0
condition|)
block|{
comment|// Done!  Current entry is after target --
comment|// return NOT_FOUND:
name|fillTerm
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|exactOnly
operator|&&
operator|!
name|termExists
condition|)
block|{
comment|// We are on a sub-block, and caller wants
comment|// us to position to the next term after
comment|// the target, so we must recurse into the
comment|// sub-frame(s):
name|currentFrame
operator|=
name|pushFrame
argument_list|(
literal|null
argument_list|,
name|currentFrame
operator|.
name|lastSubFP
argument_list|,
name|termLen
argument_list|)
expr_stmt|;
name|currentFrame
operator|.
name|loadBlock
argument_list|()
expr_stmt|;
while|while
condition|(
name|currentFrame
operator|.
name|next
argument_list|()
condition|)
block|{
name|currentFrame
operator|=
name|pushFrame
argument_list|(
literal|null
argument_list|,
name|currentFrame
operator|.
name|lastSubFP
argument_list|,
name|term
operator|.
name|length
argument_list|)
expr_stmt|;
name|currentFrame
operator|.
name|loadBlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|//if (DEBUG) System.out.println("        not found");
return|return
name|SeekStatus
operator|.
name|NOT_FOUND
return|;
block|}
elseif|else
if|if
condition|(
name|stop
condition|)
block|{
comment|// Exact match!
comment|// This cannot be a sub-block because we
comment|// would have followed the index to this
comment|// sub-block from the start:
assert|assert
name|termExists
assert|;
name|fillTerm
argument_list|()
expr_stmt|;
comment|//if (DEBUG) System.out.println("        found!");
return|return
name|SeekStatus
operator|.
name|FOUND
return|;
block|}
block|}
block|}
comment|// It is possible (and OK) that terms index pointed us
comment|// at this block, but, we scanned the entire block and
comment|// did not find the term to position to.  This happens
comment|// when the target is after the last term in the block
comment|// (but, before the next term in the index).  EG
comment|// target could be foozzz, and terms index pointed us
comment|// to the foo* block, but the last term in this block
comment|// was fooz (and, eg, first term in the next block will
comment|// bee fop).
comment|//if (DEBUG) System.out.println("      block end");
if|if
condition|(
name|exactOnly
condition|)
block|{
name|fillTerm
argument_list|()
expr_stmt|;
block|}
comment|// TODO: not consistent that in the
comment|// not-exact case we don't next() into the next
comment|// frame here
return|return
name|SeekStatus
operator|.
name|END
return|;
block|}
DECL|method|fillTerm
specifier|private
name|void
name|fillTerm
parameter_list|()
block|{
specifier|final
name|int
name|termLength
init|=
name|prefix
operator|+
name|suffix
decl_stmt|;
name|term
operator|.
name|length
operator|=
name|prefix
operator|+
name|suffix
expr_stmt|;
if|if
condition|(
name|term
operator|.
name|bytes
operator|.
name|length
operator|<
name|termLength
condition|)
block|{
name|term
operator|.
name|grow
argument_list|(
name|termLength
argument_list|)
expr_stmt|;
block|}
name|System
operator|.
name|arraycopy
argument_list|(
name|suffixBytes
argument_list|,
name|startBytePos
argument_list|,
name|term
operator|.
name|bytes
argument_list|,
name|prefix
argument_list|,
name|suffix
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
end_class
end_unit
