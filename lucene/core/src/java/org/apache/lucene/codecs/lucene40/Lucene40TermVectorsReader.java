begin_unit
begin_package
DECL|package|org.apache.lucene.codecs.lucene40
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|codecs
operator|.
name|lucene40
package|;
end_package
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|codecs
operator|.
name|TermVectorsReader
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|CorruptIndexException
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|DocsAndPositionsEnum
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|DocsEnum
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|FieldInfo
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|FieldInfos
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|Fields
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|FieldsEnum
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|IndexFileNames
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|IndexFormatTooNewException
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|IndexFormatTooOldException
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|SegmentInfo
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|Terms
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|TermsEnum
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|Directory
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|IOContext
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|IndexInput
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|Bits
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|BytesRef
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|IOUtils
import|;
end_import
begin_comment
comment|/**  * Lucene 4.0 Term Vectors reader.  *<p>  * It reads .tvd, .tvf, and .tvx files.  *   * @see Lucene40TermVectorsFormat  */
end_comment
begin_class
DECL|class|Lucene40TermVectorsReader
specifier|public
class|class
name|Lucene40TermVectorsReader
extends|extends
name|TermVectorsReader
block|{
comment|// NOTE: if you make a new format, it must be larger than
comment|// the current format
comment|// Changed strings to UTF8 with length-in-bytes not length-in-chars
DECL|field|FORMAT_UTF8_LENGTH_IN_BYTES
specifier|static
specifier|final
name|int
name|FORMAT_UTF8_LENGTH_IN_BYTES
init|=
literal|4
decl_stmt|;
comment|// NOTE: always change this if you switch to a new format!
comment|// whenever you add a new format, make it 1 larger (positive version logic)!
DECL|field|FORMAT_CURRENT
specifier|static
specifier|final
name|int
name|FORMAT_CURRENT
init|=
name|FORMAT_UTF8_LENGTH_IN_BYTES
decl_stmt|;
comment|// when removing support for old versions, leave the last supported version here
DECL|field|FORMAT_MINIMUM
specifier|static
specifier|final
name|int
name|FORMAT_MINIMUM
init|=
name|FORMAT_UTF8_LENGTH_IN_BYTES
decl_stmt|;
comment|//The size in bytes that the FORMAT_VERSION will take up at the beginning of each file
DECL|field|FORMAT_SIZE
specifier|static
specifier|final
name|int
name|FORMAT_SIZE
init|=
literal|4
decl_stmt|;
DECL|field|STORE_POSITIONS_WITH_TERMVECTOR
specifier|static
specifier|final
name|byte
name|STORE_POSITIONS_WITH_TERMVECTOR
init|=
literal|0x1
decl_stmt|;
DECL|field|STORE_OFFSET_WITH_TERMVECTOR
specifier|static
specifier|final
name|byte
name|STORE_OFFSET_WITH_TERMVECTOR
init|=
literal|0x2
decl_stmt|;
comment|/** Extension of vectors fields file */
DECL|field|VECTORS_FIELDS_EXTENSION
specifier|static
specifier|final
name|String
name|VECTORS_FIELDS_EXTENSION
init|=
literal|"tvf"
decl_stmt|;
comment|/** Extension of vectors documents file */
DECL|field|VECTORS_DOCUMENTS_EXTENSION
specifier|static
specifier|final
name|String
name|VECTORS_DOCUMENTS_EXTENSION
init|=
literal|"tvd"
decl_stmt|;
comment|/** Extension of vectors index file */
DECL|field|VECTORS_INDEX_EXTENSION
specifier|static
specifier|final
name|String
name|VECTORS_INDEX_EXTENSION
init|=
literal|"tvx"
decl_stmt|;
DECL|field|fieldInfos
specifier|private
name|FieldInfos
name|fieldInfos
decl_stmt|;
DECL|field|tvx
specifier|private
name|IndexInput
name|tvx
decl_stmt|;
DECL|field|tvd
specifier|private
name|IndexInput
name|tvd
decl_stmt|;
DECL|field|tvf
specifier|private
name|IndexInput
name|tvf
decl_stmt|;
DECL|field|size
specifier|private
name|int
name|size
decl_stmt|;
DECL|field|numTotalDocs
specifier|private
name|int
name|numTotalDocs
decl_stmt|;
DECL|field|format
specifier|private
specifier|final
name|int
name|format
decl_stmt|;
comment|// used by clone
DECL|method|Lucene40TermVectorsReader
name|Lucene40TermVectorsReader
parameter_list|(
name|FieldInfos
name|fieldInfos
parameter_list|,
name|IndexInput
name|tvx
parameter_list|,
name|IndexInput
name|tvd
parameter_list|,
name|IndexInput
name|tvf
parameter_list|,
name|int
name|size
parameter_list|,
name|int
name|numTotalDocs
parameter_list|,
name|int
name|format
parameter_list|)
block|{
name|this
operator|.
name|fieldInfos
operator|=
name|fieldInfos
expr_stmt|;
name|this
operator|.
name|tvx
operator|=
name|tvx
expr_stmt|;
name|this
operator|.
name|tvd
operator|=
name|tvd
expr_stmt|;
name|this
operator|.
name|tvf
operator|=
name|tvf
expr_stmt|;
name|this
operator|.
name|size
operator|=
name|size
expr_stmt|;
name|this
operator|.
name|numTotalDocs
operator|=
name|numTotalDocs
expr_stmt|;
name|this
operator|.
name|format
operator|=
name|format
expr_stmt|;
block|}
DECL|method|Lucene40TermVectorsReader
specifier|public
name|Lucene40TermVectorsReader
parameter_list|(
name|Directory
name|d
parameter_list|,
name|SegmentInfo
name|si
parameter_list|,
name|FieldInfos
name|fieldInfos
parameter_list|,
name|IOContext
name|context
parameter_list|)
throws|throws
name|CorruptIndexException
throws|,
name|IOException
block|{
specifier|final
name|String
name|segment
init|=
name|si
operator|.
name|name
decl_stmt|;
specifier|final
name|int
name|size
init|=
name|si
operator|.
name|docCount
decl_stmt|;
name|boolean
name|success
init|=
literal|false
decl_stmt|;
try|try
block|{
name|String
name|idxName
init|=
name|IndexFileNames
operator|.
name|segmentFileName
argument_list|(
name|segment
argument_list|,
literal|""
argument_list|,
name|VECTORS_INDEX_EXTENSION
argument_list|)
decl_stmt|;
name|tvx
operator|=
name|d
operator|.
name|openInput
argument_list|(
name|idxName
argument_list|,
name|context
argument_list|)
expr_stmt|;
name|format
operator|=
name|checkValidFormat
argument_list|(
name|tvx
argument_list|)
expr_stmt|;
name|String
name|fn
init|=
name|IndexFileNames
operator|.
name|segmentFileName
argument_list|(
name|segment
argument_list|,
literal|""
argument_list|,
name|VECTORS_DOCUMENTS_EXTENSION
argument_list|)
decl_stmt|;
name|tvd
operator|=
name|d
operator|.
name|openInput
argument_list|(
name|fn
argument_list|,
name|context
argument_list|)
expr_stmt|;
specifier|final
name|int
name|tvdFormat
init|=
name|checkValidFormat
argument_list|(
name|tvd
argument_list|)
decl_stmt|;
name|fn
operator|=
name|IndexFileNames
operator|.
name|segmentFileName
argument_list|(
name|segment
argument_list|,
literal|""
argument_list|,
name|VECTORS_FIELDS_EXTENSION
argument_list|)
expr_stmt|;
name|tvf
operator|=
name|d
operator|.
name|openInput
argument_list|(
name|fn
argument_list|,
name|context
argument_list|)
expr_stmt|;
specifier|final
name|int
name|tvfFormat
init|=
name|checkValidFormat
argument_list|(
name|tvf
argument_list|)
decl_stmt|;
assert|assert
name|format
operator|==
name|tvdFormat
assert|;
assert|assert
name|format
operator|==
name|tvfFormat
assert|;
name|numTotalDocs
operator|=
call|(
name|int
call|)
argument_list|(
name|tvx
operator|.
name|length
argument_list|()
operator|>>
literal|4
argument_list|)
expr_stmt|;
name|this
operator|.
name|size
operator|=
name|numTotalDocs
expr_stmt|;
assert|assert
name|size
operator|==
literal|0
operator|||
name|numTotalDocs
operator|==
name|size
assert|;
name|this
operator|.
name|fieldInfos
operator|=
name|fieldInfos
expr_stmt|;
name|success
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
comment|// With lock-less commits, it's entirely possible (and
comment|// fine) to hit a FileNotFound exception above. In
comment|// this case, we want to explicitly close any subset
comment|// of things that were opened so that we don't have to
comment|// wait for a GC to do so.
if|if
condition|(
operator|!
name|success
condition|)
block|{
name|close
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|// Used for bulk copy when merging
DECL|method|getTvdStream
name|IndexInput
name|getTvdStream
parameter_list|()
block|{
return|return
name|tvd
return|;
block|}
comment|// Used for bulk copy when merging
DECL|method|getTvfStream
name|IndexInput
name|getTvfStream
parameter_list|()
block|{
return|return
name|tvf
return|;
block|}
comment|// Not private to avoid synthetic access$NNN methods
DECL|method|seekTvx
name|void
name|seekTvx
parameter_list|(
specifier|final
name|int
name|docNum
parameter_list|)
throws|throws
name|IOException
block|{
name|tvx
operator|.
name|seek
argument_list|(
name|docNum
operator|*
literal|16L
operator|+
name|FORMAT_SIZE
argument_list|)
expr_stmt|;
block|}
DECL|method|canReadRawDocs
name|boolean
name|canReadRawDocs
parameter_list|()
block|{
comment|// we can always read raw docs, unless the term vectors
comment|// didn't exist
return|return
name|format
operator|!=
literal|0
return|;
block|}
comment|/** Retrieve the length (in bytes) of the tvd and tvf    *  entries for the next numDocs starting with    *  startDocID.  This is used for bulk copying when    *  merging segments, if the field numbers are    *  congruent.  Once this returns, the tvf& tvd streams    *  are seeked to the startDocID. */
DECL|method|rawDocs
specifier|final
name|void
name|rawDocs
parameter_list|(
name|int
index|[]
name|tvdLengths
parameter_list|,
name|int
index|[]
name|tvfLengths
parameter_list|,
name|int
name|startDocID
parameter_list|,
name|int
name|numDocs
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|tvx
operator|==
literal|null
condition|)
block|{
name|Arrays
operator|.
name|fill
argument_list|(
name|tvdLengths
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|Arrays
operator|.
name|fill
argument_list|(
name|tvfLengths
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
name|seekTvx
argument_list|(
name|startDocID
argument_list|)
expr_stmt|;
name|long
name|tvdPosition
init|=
name|tvx
operator|.
name|readLong
argument_list|()
decl_stmt|;
name|tvd
operator|.
name|seek
argument_list|(
name|tvdPosition
argument_list|)
expr_stmt|;
name|long
name|tvfPosition
init|=
name|tvx
operator|.
name|readLong
argument_list|()
decl_stmt|;
name|tvf
operator|.
name|seek
argument_list|(
name|tvfPosition
argument_list|)
expr_stmt|;
name|long
name|lastTvdPosition
init|=
name|tvdPosition
decl_stmt|;
name|long
name|lastTvfPosition
init|=
name|tvfPosition
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|count
operator|<
name|numDocs
condition|)
block|{
specifier|final
name|int
name|docID
init|=
name|startDocID
operator|+
name|count
operator|+
literal|1
decl_stmt|;
assert|assert
name|docID
operator|<=
name|numTotalDocs
assert|;
if|if
condition|(
name|docID
operator|<
name|numTotalDocs
condition|)
block|{
name|tvdPosition
operator|=
name|tvx
operator|.
name|readLong
argument_list|()
expr_stmt|;
name|tvfPosition
operator|=
name|tvx
operator|.
name|readLong
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|tvdPosition
operator|=
name|tvd
operator|.
name|length
argument_list|()
expr_stmt|;
name|tvfPosition
operator|=
name|tvf
operator|.
name|length
argument_list|()
expr_stmt|;
assert|assert
name|count
operator|==
name|numDocs
operator|-
literal|1
assert|;
block|}
name|tvdLengths
index|[
name|count
index|]
operator|=
call|(
name|int
call|)
argument_list|(
name|tvdPosition
operator|-
name|lastTvdPosition
argument_list|)
expr_stmt|;
name|tvfLengths
index|[
name|count
index|]
operator|=
call|(
name|int
call|)
argument_list|(
name|tvfPosition
operator|-
name|lastTvfPosition
argument_list|)
expr_stmt|;
name|count
operator|++
expr_stmt|;
name|lastTvdPosition
operator|=
name|tvdPosition
expr_stmt|;
name|lastTvfPosition
operator|=
name|tvfPosition
expr_stmt|;
block|}
block|}
DECL|method|checkValidFormat
specifier|private
name|int
name|checkValidFormat
parameter_list|(
name|IndexInput
name|in
parameter_list|)
throws|throws
name|CorruptIndexException
throws|,
name|IOException
block|{
name|int
name|format
init|=
name|in
operator|.
name|readInt
argument_list|()
decl_stmt|;
if|if
condition|(
name|format
operator|<
name|FORMAT_MINIMUM
condition|)
throw|throw
operator|new
name|IndexFormatTooOldException
argument_list|(
name|in
argument_list|,
name|format
argument_list|,
name|FORMAT_MINIMUM
argument_list|,
name|FORMAT_CURRENT
argument_list|)
throw|;
if|if
condition|(
name|format
operator|>
name|FORMAT_CURRENT
condition|)
throw|throw
operator|new
name|IndexFormatTooNewException
argument_list|(
name|in
argument_list|,
name|format
argument_list|,
name|FORMAT_MINIMUM
argument_list|,
name|FORMAT_CURRENT
argument_list|)
throw|;
return|return
name|format
return|;
block|}
DECL|method|close
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
name|IOUtils
operator|.
name|close
argument_list|(
name|tvx
argument_list|,
name|tvd
argument_list|,
name|tvf
argument_list|)
expr_stmt|;
block|}
comment|/**    *     * @return The number of documents in the reader    */
DECL|method|size
name|int
name|size
parameter_list|()
block|{
return|return
name|size
return|;
block|}
DECL|class|TVFields
specifier|private
class|class
name|TVFields
extends|extends
name|Fields
block|{
DECL|field|fieldNumbers
specifier|private
specifier|final
name|int
index|[]
name|fieldNumbers
decl_stmt|;
DECL|field|fieldFPs
specifier|private
specifier|final
name|long
index|[]
name|fieldFPs
decl_stmt|;
DECL|field|fieldNumberToIndex
specifier|private
specifier|final
name|Map
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|fieldNumberToIndex
init|=
operator|new
name|HashMap
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
DECL|method|TVFields
specifier|public
name|TVFields
parameter_list|(
name|int
name|docID
parameter_list|)
throws|throws
name|IOException
block|{
name|seekTvx
argument_list|(
name|docID
argument_list|)
expr_stmt|;
name|tvd
operator|.
name|seek
argument_list|(
name|tvx
operator|.
name|readLong
argument_list|()
argument_list|)
expr_stmt|;
specifier|final
name|int
name|fieldCount
init|=
name|tvd
operator|.
name|readVInt
argument_list|()
decl_stmt|;
assert|assert
name|fieldCount
operator|>=
literal|0
assert|;
if|if
condition|(
name|fieldCount
operator|!=
literal|0
condition|)
block|{
name|fieldNumbers
operator|=
operator|new
name|int
index|[
name|fieldCount
index|]
expr_stmt|;
name|fieldFPs
operator|=
operator|new
name|long
index|[
name|fieldCount
index|]
expr_stmt|;
for|for
control|(
name|int
name|fieldUpto
init|=
literal|0
init|;
name|fieldUpto
operator|<
name|fieldCount
condition|;
name|fieldUpto
operator|++
control|)
block|{
specifier|final
name|int
name|fieldNumber
init|=
name|tvd
operator|.
name|readVInt
argument_list|()
decl_stmt|;
name|fieldNumbers
index|[
name|fieldUpto
index|]
operator|=
name|fieldNumber
expr_stmt|;
name|fieldNumberToIndex
operator|.
name|put
argument_list|(
name|fieldNumber
argument_list|,
name|fieldUpto
argument_list|)
expr_stmt|;
block|}
name|long
name|position
init|=
name|tvx
operator|.
name|readLong
argument_list|()
decl_stmt|;
name|fieldFPs
index|[
literal|0
index|]
operator|=
name|position
expr_stmt|;
for|for
control|(
name|int
name|fieldUpto
init|=
literal|1
init|;
name|fieldUpto
operator|<
name|fieldCount
condition|;
name|fieldUpto
operator|++
control|)
block|{
name|position
operator|+=
name|tvd
operator|.
name|readVLong
argument_list|()
expr_stmt|;
name|fieldFPs
index|[
name|fieldUpto
index|]
operator|=
name|position
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// TODO: we can improve writer here, eg write 0 into
comment|// tvx file, so we know on first read from tvx that
comment|// this doc has no TVs
name|fieldNumbers
operator|=
literal|null
expr_stmt|;
name|fieldFPs
operator|=
literal|null
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|iterator
specifier|public
name|FieldsEnum
name|iterator
parameter_list|()
throws|throws
name|IOException
block|{
return|return
operator|new
name|FieldsEnum
argument_list|()
block|{
specifier|private
name|int
name|fieldUpto
decl_stmt|;
annotation|@
name|Override
specifier|public
name|String
name|next
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|fieldNumbers
operator|!=
literal|null
operator|&&
name|fieldUpto
operator|<
name|fieldNumbers
operator|.
name|length
condition|)
block|{
return|return
name|fieldInfos
operator|.
name|fieldName
argument_list|(
name|fieldNumbers
index|[
name|fieldUpto
operator|++
index|]
argument_list|)
return|;
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|Terms
name|terms
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|TVFields
operator|.
name|this
operator|.
name|terms
argument_list|(
name|fieldInfos
operator|.
name|fieldName
argument_list|(
name|fieldNumbers
index|[
name|fieldUpto
operator|-
literal|1
index|]
argument_list|)
argument_list|)
return|;
block|}
block|}
return|;
block|}
annotation|@
name|Override
DECL|method|terms
specifier|public
name|Terms
name|terms
parameter_list|(
name|String
name|field
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|FieldInfo
name|fieldInfo
init|=
name|fieldInfos
operator|.
name|fieldInfo
argument_list|(
name|field
argument_list|)
decl_stmt|;
if|if
condition|(
name|fieldInfo
operator|==
literal|null
condition|)
block|{
comment|// No such field
return|return
literal|null
return|;
block|}
specifier|final
name|Integer
name|fieldIndex
init|=
name|fieldNumberToIndex
operator|.
name|get
argument_list|(
name|fieldInfo
operator|.
name|number
argument_list|)
decl_stmt|;
if|if
condition|(
name|fieldIndex
operator|==
literal|null
condition|)
block|{
comment|// Term vectors were not indexed for this field
return|return
literal|null
return|;
block|}
return|return
operator|new
name|TVTerms
argument_list|(
name|fieldFPs
index|[
name|fieldIndex
index|]
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|size
specifier|public
name|int
name|size
parameter_list|()
block|{
if|if
condition|(
name|fieldNumbers
operator|==
literal|null
condition|)
block|{
return|return
literal|0
return|;
block|}
else|else
block|{
return|return
name|fieldNumbers
operator|.
name|length
return|;
block|}
block|}
block|}
DECL|class|TVTerms
specifier|private
class|class
name|TVTerms
extends|extends
name|Terms
block|{
DECL|field|numTerms
specifier|private
specifier|final
name|int
name|numTerms
decl_stmt|;
DECL|field|tvfFPStart
specifier|private
specifier|final
name|long
name|tvfFPStart
decl_stmt|;
DECL|method|TVTerms
specifier|public
name|TVTerms
parameter_list|(
name|long
name|tvfFP
parameter_list|)
throws|throws
name|IOException
block|{
name|tvf
operator|.
name|seek
argument_list|(
name|tvfFP
argument_list|)
expr_stmt|;
name|numTerms
operator|=
name|tvf
operator|.
name|readVInt
argument_list|()
expr_stmt|;
name|tvfFPStart
operator|=
name|tvf
operator|.
name|getFilePointer
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|iterator
specifier|public
name|TermsEnum
name|iterator
parameter_list|(
name|TermsEnum
name|reuse
parameter_list|)
throws|throws
name|IOException
block|{
name|TVTermsEnum
name|termsEnum
decl_stmt|;
if|if
condition|(
name|reuse
operator|instanceof
name|TVTermsEnum
condition|)
block|{
name|termsEnum
operator|=
operator|(
name|TVTermsEnum
operator|)
name|reuse
expr_stmt|;
if|if
condition|(
operator|!
name|termsEnum
operator|.
name|canReuse
argument_list|(
name|tvf
argument_list|)
condition|)
block|{
name|termsEnum
operator|=
operator|new
name|TVTermsEnum
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
name|termsEnum
operator|=
operator|new
name|TVTermsEnum
argument_list|()
expr_stmt|;
block|}
name|termsEnum
operator|.
name|reset
argument_list|(
name|numTerms
argument_list|,
name|tvfFPStart
argument_list|)
expr_stmt|;
return|return
name|termsEnum
return|;
block|}
annotation|@
name|Override
DECL|method|size
specifier|public
name|long
name|size
parameter_list|()
block|{
return|return
name|numTerms
return|;
block|}
annotation|@
name|Override
DECL|method|getSumTotalTermFreq
specifier|public
name|long
name|getSumTotalTermFreq
parameter_list|()
block|{
return|return
operator|-
literal|1
return|;
block|}
annotation|@
name|Override
DECL|method|getSumDocFreq
specifier|public
name|long
name|getSumDocFreq
parameter_list|()
block|{
comment|// Every term occurs in just one doc:
return|return
name|numTerms
return|;
block|}
annotation|@
name|Override
DECL|method|getDocCount
specifier|public
name|int
name|getDocCount
parameter_list|()
block|{
return|return
literal|1
return|;
block|}
annotation|@
name|Override
DECL|method|getComparator
specifier|public
name|Comparator
argument_list|<
name|BytesRef
argument_list|>
name|getComparator
parameter_list|()
block|{
comment|// TODO: really indexer hardwires
comment|// this...?  I guess codec could buffer and re-sort...
return|return
name|BytesRef
operator|.
name|getUTF8SortedAsUnicodeComparator
argument_list|()
return|;
block|}
block|}
DECL|class|TVTermsEnum
specifier|private
class|class
name|TVTermsEnum
extends|extends
name|TermsEnum
block|{
DECL|field|origTVF
specifier|private
specifier|final
name|IndexInput
name|origTVF
decl_stmt|;
DECL|field|tvf
specifier|private
specifier|final
name|IndexInput
name|tvf
decl_stmt|;
DECL|field|numTerms
specifier|private
name|int
name|numTerms
decl_stmt|;
DECL|field|nextTerm
specifier|private
name|int
name|nextTerm
decl_stmt|;
DECL|field|freq
specifier|private
name|int
name|freq
decl_stmt|;
DECL|field|lastTerm
specifier|private
name|BytesRef
name|lastTerm
init|=
operator|new
name|BytesRef
argument_list|()
decl_stmt|;
DECL|field|term
specifier|private
name|BytesRef
name|term
init|=
operator|new
name|BytesRef
argument_list|()
decl_stmt|;
DECL|field|storePositions
specifier|private
name|boolean
name|storePositions
decl_stmt|;
DECL|field|storeOffsets
specifier|private
name|boolean
name|storeOffsets
decl_stmt|;
DECL|field|tvfFP
specifier|private
name|long
name|tvfFP
decl_stmt|;
DECL|field|positions
specifier|private
name|int
index|[]
name|positions
decl_stmt|;
DECL|field|startOffsets
specifier|private
name|int
index|[]
name|startOffsets
decl_stmt|;
DECL|field|endOffsets
specifier|private
name|int
index|[]
name|endOffsets
decl_stmt|;
comment|// NOTE: tvf is pre-positioned by caller
DECL|method|TVTermsEnum
specifier|public
name|TVTermsEnum
parameter_list|()
throws|throws
name|IOException
block|{
name|this
operator|.
name|origTVF
operator|=
name|Lucene40TermVectorsReader
operator|.
name|this
operator|.
name|tvf
expr_stmt|;
name|tvf
operator|=
operator|(
name|IndexInput
operator|)
name|origTVF
operator|.
name|clone
argument_list|()
expr_stmt|;
block|}
DECL|method|canReuse
specifier|public
name|boolean
name|canReuse
parameter_list|(
name|IndexInput
name|tvf
parameter_list|)
block|{
return|return
name|tvf
operator|==
name|origTVF
return|;
block|}
DECL|method|reset
specifier|public
name|void
name|reset
parameter_list|(
name|int
name|numTerms
parameter_list|,
name|long
name|tvfFPStart
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|numTerms
operator|=
name|numTerms
expr_stmt|;
name|nextTerm
operator|=
literal|0
expr_stmt|;
name|tvf
operator|.
name|seek
argument_list|(
name|tvfFPStart
argument_list|)
expr_stmt|;
specifier|final
name|byte
name|bits
init|=
name|tvf
operator|.
name|readByte
argument_list|()
decl_stmt|;
name|storePositions
operator|=
operator|(
name|bits
operator|&
name|STORE_POSITIONS_WITH_TERMVECTOR
operator|)
operator|!=
literal|0
expr_stmt|;
name|storeOffsets
operator|=
operator|(
name|bits
operator|&
name|STORE_OFFSET_WITH_TERMVECTOR
operator|)
operator|!=
literal|0
expr_stmt|;
name|tvfFP
operator|=
literal|1
operator|+
name|tvfFPStart
expr_stmt|;
name|positions
operator|=
literal|null
expr_stmt|;
name|startOffsets
operator|=
literal|null
expr_stmt|;
name|endOffsets
operator|=
literal|null
expr_stmt|;
block|}
comment|// NOTE: slow!  (linear scan)
annotation|@
name|Override
DECL|method|seekCeil
specifier|public
name|SeekStatus
name|seekCeil
parameter_list|(
name|BytesRef
name|text
parameter_list|,
name|boolean
name|useCache
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|nextTerm
operator|!=
literal|0
condition|)
block|{
specifier|final
name|int
name|cmp
init|=
name|text
operator|.
name|compareTo
argument_list|(
name|term
argument_list|)
decl_stmt|;
if|if
condition|(
name|cmp
operator|<
literal|0
condition|)
block|{
name|nextTerm
operator|=
literal|0
expr_stmt|;
name|tvf
operator|.
name|seek
argument_list|(
name|tvfFP
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cmp
operator|==
literal|0
condition|)
block|{
return|return
name|SeekStatus
operator|.
name|FOUND
return|;
block|}
block|}
while|while
condition|(
name|next
argument_list|()
operator|!=
literal|null
condition|)
block|{
specifier|final
name|int
name|cmp
init|=
name|text
operator|.
name|compareTo
argument_list|(
name|term
argument_list|)
decl_stmt|;
if|if
condition|(
name|cmp
operator|<
literal|0
condition|)
block|{
return|return
name|SeekStatus
operator|.
name|NOT_FOUND
return|;
block|}
elseif|else
if|if
condition|(
name|cmp
operator|==
literal|0
condition|)
block|{
return|return
name|SeekStatus
operator|.
name|FOUND
return|;
block|}
block|}
return|return
name|SeekStatus
operator|.
name|END
return|;
block|}
annotation|@
name|Override
DECL|method|seekExact
specifier|public
name|void
name|seekExact
parameter_list|(
name|long
name|ord
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
DECL|method|next
specifier|public
name|BytesRef
name|next
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|nextTerm
operator|>=
name|numTerms
condition|)
block|{
return|return
literal|null
return|;
block|}
name|term
operator|.
name|copyBytes
argument_list|(
name|lastTerm
argument_list|)
expr_stmt|;
specifier|final
name|int
name|start
init|=
name|tvf
operator|.
name|readVInt
argument_list|()
decl_stmt|;
specifier|final
name|int
name|deltaLen
init|=
name|tvf
operator|.
name|readVInt
argument_list|()
decl_stmt|;
name|term
operator|.
name|length
operator|=
name|start
operator|+
name|deltaLen
expr_stmt|;
name|term
operator|.
name|grow
argument_list|(
name|term
operator|.
name|length
argument_list|)
expr_stmt|;
name|tvf
operator|.
name|readBytes
argument_list|(
name|term
operator|.
name|bytes
argument_list|,
name|start
argument_list|,
name|deltaLen
argument_list|)
expr_stmt|;
name|freq
operator|=
name|tvf
operator|.
name|readVInt
argument_list|()
expr_stmt|;
if|if
condition|(
name|storePositions
condition|)
block|{
comment|// TODO: we could maybe reuse last array, if we can
comment|// somehow be careful about consumer never using two
comment|// D&PEnums at once...
name|positions
operator|=
operator|new
name|int
index|[
name|freq
index|]
expr_stmt|;
name|int
name|pos
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|posUpto
init|=
literal|0
init|;
name|posUpto
operator|<
name|freq
condition|;
name|posUpto
operator|++
control|)
block|{
name|pos
operator|+=
name|tvf
operator|.
name|readVInt
argument_list|()
expr_stmt|;
name|positions
index|[
name|posUpto
index|]
operator|=
name|pos
expr_stmt|;
block|}
block|}
if|if
condition|(
name|storeOffsets
condition|)
block|{
name|startOffsets
operator|=
operator|new
name|int
index|[
name|freq
index|]
expr_stmt|;
name|endOffsets
operator|=
operator|new
name|int
index|[
name|freq
index|]
expr_stmt|;
name|int
name|offset
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|posUpto
init|=
literal|0
init|;
name|posUpto
operator|<
name|freq
condition|;
name|posUpto
operator|++
control|)
block|{
name|startOffsets
index|[
name|posUpto
index|]
operator|=
name|offset
operator|+
name|tvf
operator|.
name|readVInt
argument_list|()
expr_stmt|;
name|offset
operator|=
name|endOffsets
index|[
name|posUpto
index|]
operator|=
name|startOffsets
index|[
name|posUpto
index|]
operator|+
name|tvf
operator|.
name|readVInt
argument_list|()
expr_stmt|;
block|}
block|}
name|lastTerm
operator|.
name|copyBytes
argument_list|(
name|term
argument_list|)
expr_stmt|;
name|nextTerm
operator|++
expr_stmt|;
return|return
name|term
return|;
block|}
annotation|@
name|Override
DECL|method|term
specifier|public
name|BytesRef
name|term
parameter_list|()
block|{
return|return
name|term
return|;
block|}
annotation|@
name|Override
DECL|method|ord
specifier|public
name|long
name|ord
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
DECL|method|docFreq
specifier|public
name|int
name|docFreq
parameter_list|()
block|{
return|return
literal|1
return|;
block|}
annotation|@
name|Override
DECL|method|totalTermFreq
specifier|public
name|long
name|totalTermFreq
parameter_list|()
block|{
return|return
name|freq
return|;
block|}
annotation|@
name|Override
DECL|method|docs
specifier|public
name|DocsEnum
name|docs
parameter_list|(
name|Bits
name|liveDocs
parameter_list|,
name|DocsEnum
name|reuse
parameter_list|,
name|boolean
name|needsFreqs
comment|/* ignored */
parameter_list|)
throws|throws
name|IOException
block|{
name|TVDocsEnum
name|docsEnum
decl_stmt|;
if|if
condition|(
name|reuse
operator|!=
literal|null
operator|&&
name|reuse
operator|instanceof
name|TVDocsEnum
condition|)
block|{
name|docsEnum
operator|=
operator|(
name|TVDocsEnum
operator|)
name|reuse
expr_stmt|;
block|}
else|else
block|{
name|docsEnum
operator|=
operator|new
name|TVDocsEnum
argument_list|()
expr_stmt|;
block|}
name|docsEnum
operator|.
name|reset
argument_list|(
name|liveDocs
argument_list|,
name|freq
argument_list|)
expr_stmt|;
return|return
name|docsEnum
return|;
block|}
annotation|@
name|Override
DECL|method|docsAndPositions
specifier|public
name|DocsAndPositionsEnum
name|docsAndPositions
parameter_list|(
name|Bits
name|liveDocs
parameter_list|,
name|DocsAndPositionsEnum
name|reuse
parameter_list|,
name|boolean
name|needsOffsets
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|needsOffsets
operator|&&
operator|!
name|storeOffsets
condition|)
block|{
return|return
literal|null
return|;
block|}
if|if
condition|(
operator|!
name|storePositions
operator|&&
operator|!
name|storeOffsets
condition|)
block|{
return|return
literal|null
return|;
block|}
name|TVDocsAndPositionsEnum
name|docsAndPositionsEnum
decl_stmt|;
if|if
condition|(
name|reuse
operator|!=
literal|null
operator|&&
name|reuse
operator|instanceof
name|TVDocsAndPositionsEnum
condition|)
block|{
name|docsAndPositionsEnum
operator|=
operator|(
name|TVDocsAndPositionsEnum
operator|)
name|reuse
expr_stmt|;
block|}
else|else
block|{
name|docsAndPositionsEnum
operator|=
operator|new
name|TVDocsAndPositionsEnum
argument_list|()
expr_stmt|;
block|}
name|docsAndPositionsEnum
operator|.
name|reset
argument_list|(
name|liveDocs
argument_list|,
name|positions
argument_list|,
name|startOffsets
argument_list|,
name|endOffsets
argument_list|)
expr_stmt|;
return|return
name|docsAndPositionsEnum
return|;
block|}
annotation|@
name|Override
DECL|method|getComparator
specifier|public
name|Comparator
argument_list|<
name|BytesRef
argument_list|>
name|getComparator
parameter_list|()
block|{
comment|// TODO: really indexer hardwires
comment|// this...?  I guess codec could buffer and re-sort...
return|return
name|BytesRef
operator|.
name|getUTF8SortedAsUnicodeComparator
argument_list|()
return|;
block|}
block|}
comment|// NOTE: sort of a silly class, since you can get the
comment|// freq() already by TermsEnum.totalTermFreq
DECL|class|TVDocsEnum
specifier|private
specifier|static
class|class
name|TVDocsEnum
extends|extends
name|DocsEnum
block|{
DECL|field|didNext
specifier|private
name|boolean
name|didNext
decl_stmt|;
DECL|field|doc
specifier|private
name|int
name|doc
init|=
operator|-
literal|1
decl_stmt|;
DECL|field|freq
specifier|private
name|int
name|freq
decl_stmt|;
DECL|field|liveDocs
specifier|private
name|Bits
name|liveDocs
decl_stmt|;
annotation|@
name|Override
DECL|method|freq
specifier|public
name|int
name|freq
parameter_list|()
block|{
return|return
name|freq
return|;
block|}
annotation|@
name|Override
DECL|method|docID
specifier|public
name|int
name|docID
parameter_list|()
block|{
return|return
name|doc
return|;
block|}
annotation|@
name|Override
DECL|method|nextDoc
specifier|public
name|int
name|nextDoc
parameter_list|()
block|{
if|if
condition|(
operator|!
name|didNext
operator|&&
operator|(
name|liveDocs
operator|==
literal|null
operator|||
name|liveDocs
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|)
condition|)
block|{
name|didNext
operator|=
literal|true
expr_stmt|;
return|return
operator|(
name|doc
operator|=
literal|0
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
name|doc
operator|=
name|NO_MORE_DOCS
operator|)
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|advance
specifier|public
name|int
name|advance
parameter_list|(
name|int
name|target
parameter_list|)
block|{
if|if
condition|(
operator|!
name|didNext
operator|&&
name|target
operator|==
literal|0
condition|)
block|{
return|return
name|nextDoc
argument_list|()
return|;
block|}
else|else
block|{
return|return
operator|(
name|doc
operator|=
name|NO_MORE_DOCS
operator|)
return|;
block|}
block|}
DECL|method|reset
specifier|public
name|void
name|reset
parameter_list|(
name|Bits
name|liveDocs
parameter_list|,
name|int
name|freq
parameter_list|)
block|{
name|this
operator|.
name|liveDocs
operator|=
name|liveDocs
expr_stmt|;
name|this
operator|.
name|freq
operator|=
name|freq
expr_stmt|;
name|this
operator|.
name|doc
operator|=
operator|-
literal|1
expr_stmt|;
name|didNext
operator|=
literal|false
expr_stmt|;
block|}
block|}
DECL|class|TVDocsAndPositionsEnum
specifier|private
specifier|static
class|class
name|TVDocsAndPositionsEnum
extends|extends
name|DocsAndPositionsEnum
block|{
DECL|field|didNext
specifier|private
name|boolean
name|didNext
decl_stmt|;
DECL|field|doc
specifier|private
name|int
name|doc
init|=
operator|-
literal|1
decl_stmt|;
DECL|field|nextPos
specifier|private
name|int
name|nextPos
decl_stmt|;
DECL|field|liveDocs
specifier|private
name|Bits
name|liveDocs
decl_stmt|;
DECL|field|positions
specifier|private
name|int
index|[]
name|positions
decl_stmt|;
DECL|field|startOffsets
specifier|private
name|int
index|[]
name|startOffsets
decl_stmt|;
DECL|field|endOffsets
specifier|private
name|int
index|[]
name|endOffsets
decl_stmt|;
annotation|@
name|Override
DECL|method|freq
specifier|public
name|int
name|freq
parameter_list|()
block|{
if|if
condition|(
name|positions
operator|!=
literal|null
condition|)
block|{
return|return
name|positions
operator|.
name|length
return|;
block|}
else|else
block|{
assert|assert
name|startOffsets
operator|!=
literal|null
assert|;
return|return
name|startOffsets
operator|.
name|length
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|docID
specifier|public
name|int
name|docID
parameter_list|()
block|{
return|return
name|doc
return|;
block|}
annotation|@
name|Override
DECL|method|nextDoc
specifier|public
name|int
name|nextDoc
parameter_list|()
block|{
if|if
condition|(
operator|!
name|didNext
operator|&&
operator|(
name|liveDocs
operator|==
literal|null
operator|||
name|liveDocs
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|)
condition|)
block|{
name|didNext
operator|=
literal|true
expr_stmt|;
return|return
operator|(
name|doc
operator|=
literal|0
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
name|doc
operator|=
name|NO_MORE_DOCS
operator|)
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|advance
specifier|public
name|int
name|advance
parameter_list|(
name|int
name|target
parameter_list|)
block|{
if|if
condition|(
operator|!
name|didNext
operator|&&
name|target
operator|==
literal|0
condition|)
block|{
return|return
name|nextDoc
argument_list|()
return|;
block|}
else|else
block|{
return|return
operator|(
name|doc
operator|=
name|NO_MORE_DOCS
operator|)
return|;
block|}
block|}
DECL|method|reset
specifier|public
name|void
name|reset
parameter_list|(
name|Bits
name|liveDocs
parameter_list|,
name|int
index|[]
name|positions
parameter_list|,
name|int
index|[]
name|startOffsets
parameter_list|,
name|int
index|[]
name|endOffsets
parameter_list|)
block|{
name|this
operator|.
name|liveDocs
operator|=
name|liveDocs
expr_stmt|;
name|this
operator|.
name|positions
operator|=
name|positions
expr_stmt|;
name|this
operator|.
name|startOffsets
operator|=
name|startOffsets
expr_stmt|;
name|this
operator|.
name|endOffsets
operator|=
name|endOffsets
expr_stmt|;
name|this
operator|.
name|doc
operator|=
operator|-
literal|1
expr_stmt|;
name|didNext
operator|=
literal|false
expr_stmt|;
name|nextPos
operator|=
literal|0
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|getPayload
specifier|public
name|BytesRef
name|getPayload
parameter_list|()
block|{
return|return
literal|null
return|;
block|}
annotation|@
name|Override
DECL|method|hasPayload
specifier|public
name|boolean
name|hasPayload
parameter_list|()
block|{
return|return
literal|false
return|;
block|}
annotation|@
name|Override
DECL|method|nextPosition
specifier|public
name|int
name|nextPosition
parameter_list|()
block|{
assert|assert
operator|(
name|positions
operator|!=
literal|null
operator|&&
name|nextPos
operator|<
name|positions
operator|.
name|length
operator|)
operator|||
name|startOffsets
operator|!=
literal|null
operator|&&
name|nextPos
operator|<
name|startOffsets
operator|.
name|length
assert|;
if|if
condition|(
name|positions
operator|!=
literal|null
condition|)
block|{
return|return
name|positions
index|[
name|nextPos
operator|++
index|]
return|;
block|}
else|else
block|{
name|nextPos
operator|++
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|startOffset
specifier|public
name|int
name|startOffset
parameter_list|()
block|{
assert|assert
name|startOffsets
operator|!=
literal|null
assert|;
return|return
name|startOffsets
index|[
name|nextPos
operator|-
literal|1
index|]
return|;
block|}
annotation|@
name|Override
DECL|method|endOffset
specifier|public
name|int
name|endOffset
parameter_list|()
block|{
assert|assert
name|endOffsets
operator|!=
literal|null
assert|;
return|return
name|endOffsets
index|[
name|nextPos
operator|-
literal|1
index|]
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|get
specifier|public
name|Fields
name|get
parameter_list|(
name|int
name|docID
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|docID
operator|<
literal|0
operator|||
name|docID
operator|>=
name|numTotalDocs
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"doID="
operator|+
name|docID
operator|+
literal|" is out of bounds [0.."
operator|+
operator|(
name|numTotalDocs
operator|-
literal|1
operator|)
operator|+
literal|"]"
argument_list|)
throw|;
block|}
if|if
condition|(
name|tvx
operator|!=
literal|null
condition|)
block|{
name|Fields
name|fields
init|=
operator|new
name|TVFields
argument_list|(
name|docID
argument_list|)
decl_stmt|;
if|if
condition|(
name|fields
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
comment|// TODO: we can improve writer here, eg write 0 into
comment|// tvx file, so we know on first read from tvx that
comment|// this doc has no TVs
return|return
literal|null
return|;
block|}
else|else
block|{
return|return
name|fields
return|;
block|}
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|clone
specifier|public
name|TermVectorsReader
name|clone
parameter_list|()
block|{
name|IndexInput
name|cloneTvx
init|=
literal|null
decl_stmt|;
name|IndexInput
name|cloneTvd
init|=
literal|null
decl_stmt|;
name|IndexInput
name|cloneTvf
init|=
literal|null
decl_stmt|;
comment|// These are null when a TermVectorsReader was created
comment|// on a segment that did not have term vectors saved
if|if
condition|(
name|tvx
operator|!=
literal|null
operator|&&
name|tvd
operator|!=
literal|null
operator|&&
name|tvf
operator|!=
literal|null
condition|)
block|{
name|cloneTvx
operator|=
operator|(
name|IndexInput
operator|)
name|tvx
operator|.
name|clone
argument_list|()
expr_stmt|;
name|cloneTvd
operator|=
operator|(
name|IndexInput
operator|)
name|tvd
operator|.
name|clone
argument_list|()
expr_stmt|;
name|cloneTvf
operator|=
operator|(
name|IndexInput
operator|)
name|tvf
operator|.
name|clone
argument_list|()
expr_stmt|;
block|}
return|return
operator|new
name|Lucene40TermVectorsReader
argument_list|(
name|fieldInfos
argument_list|,
name|cloneTvx
argument_list|,
name|cloneTvd
argument_list|,
name|cloneTvf
argument_list|,
name|size
argument_list|,
name|numTotalDocs
argument_list|,
name|format
argument_list|)
return|;
block|}
DECL|method|files
specifier|public
specifier|static
name|void
name|files
parameter_list|(
name|SegmentInfo
name|info
parameter_list|,
name|Set
argument_list|<
name|String
argument_list|>
name|files
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|info
operator|.
name|getHasVectors
argument_list|()
condition|)
block|{
name|files
operator|.
name|add
argument_list|(
name|IndexFileNames
operator|.
name|segmentFileName
argument_list|(
name|info
operator|.
name|name
argument_list|,
literal|""
argument_list|,
name|VECTORS_INDEX_EXTENSION
argument_list|)
argument_list|)
expr_stmt|;
name|files
operator|.
name|add
argument_list|(
name|IndexFileNames
operator|.
name|segmentFileName
argument_list|(
name|info
operator|.
name|name
argument_list|,
literal|""
argument_list|,
name|VECTORS_FIELDS_EXTENSION
argument_list|)
argument_list|)
expr_stmt|;
name|files
operator|.
name|add
argument_list|(
name|IndexFileNames
operator|.
name|segmentFileName
argument_list|(
name|info
operator|.
name|name
argument_list|,
literal|""
argument_list|,
name|VECTORS_DOCUMENTS_EXTENSION
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_class
end_unit
