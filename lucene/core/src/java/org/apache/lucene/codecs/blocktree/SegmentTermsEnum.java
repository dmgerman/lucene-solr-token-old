begin_unit
begin_package
DECL|package|org.apache.lucene.codecs.blocktree
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|codecs
operator|.
name|blocktree
package|;
end_package
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|PrintStream
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|codecs
operator|.
name|BlockTermState
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|DocsAndPositionsEnum
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|DocsEnum
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|FieldInfo
operator|.
name|IndexOptions
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|TermState
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|TermsEnum
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|ByteArrayDataInput
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|IndexInput
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|ArrayUtil
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|Bits
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|BytesRef
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|RamUsageEstimator
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|fst
operator|.
name|ByteSequenceOutputs
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|fst
operator|.
name|FST
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|fst
operator|.
name|Outputs
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|fst
operator|.
name|Util
import|;
end_import
begin_comment
comment|/** Iterates through terms in this field */
end_comment
begin_class
DECL|class|SegmentTermsEnum
specifier|final
class|class
name|SegmentTermsEnum
extends|extends
name|TermsEnum
block|{
comment|// Lazy init:
DECL|field|in
name|IndexInput
name|in
decl_stmt|;
DECL|field|stack
specifier|private
name|SegmentTermsEnumFrame
index|[]
name|stack
decl_stmt|;
DECL|field|staticFrame
specifier|private
specifier|final
name|SegmentTermsEnumFrame
name|staticFrame
decl_stmt|;
DECL|field|currentFrame
name|SegmentTermsEnumFrame
name|currentFrame
decl_stmt|;
DECL|field|termExists
name|boolean
name|termExists
decl_stmt|;
DECL|field|fr
specifier|final
name|FieldReader
name|fr
decl_stmt|;
DECL|field|targetBeforeCurrentLength
specifier|private
name|int
name|targetBeforeCurrentLength
decl_stmt|;
comment|// static boolean DEBUG = false;
DECL|field|scratchReader
specifier|private
specifier|final
name|ByteArrayDataInput
name|scratchReader
init|=
operator|new
name|ByteArrayDataInput
argument_list|()
decl_stmt|;
comment|// What prefix of the current term was present in the index; when we only next() through the index, this stays at 0.  It's only set when
comment|// we seekCeil/Exact:
DECL|field|validIndexPrefix
specifier|private
name|int
name|validIndexPrefix
decl_stmt|;
comment|// assert only:
DECL|field|eof
specifier|private
name|boolean
name|eof
decl_stmt|;
DECL|field|term
specifier|final
name|BytesRef
name|term
init|=
operator|new
name|BytesRef
argument_list|()
decl_stmt|;
DECL|field|fstReader
specifier|private
specifier|final
name|FST
operator|.
name|BytesReader
name|fstReader
decl_stmt|;
DECL|field|arcs
annotation|@
name|SuppressWarnings
argument_list|(
block|{
literal|"rawtypes"
block|,
literal|"unchecked"
block|}
argument_list|)
specifier|private
name|FST
operator|.
name|Arc
argument_list|<
name|BytesRef
argument_list|>
index|[]
name|arcs
init|=
operator|new
name|FST
operator|.
name|Arc
index|[
literal|1
index|]
decl_stmt|;
DECL|method|SegmentTermsEnum
specifier|public
name|SegmentTermsEnum
parameter_list|(
name|FieldReader
name|fr
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|fr
operator|=
name|fr
expr_stmt|;
comment|// if (DEBUG) {
comment|//   System.out.println("BTTR.init seg=" + fr.parent.segment);
comment|// }
name|stack
operator|=
operator|new
name|SegmentTermsEnumFrame
index|[
literal|0
index|]
expr_stmt|;
comment|// Used to hold seek by TermState, or cached seek
name|staticFrame
operator|=
operator|new
name|SegmentTermsEnumFrame
argument_list|(
name|this
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|fr
operator|.
name|index
operator|==
literal|null
condition|)
block|{
name|fstReader
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
name|fstReader
operator|=
name|fr
operator|.
name|index
operator|.
name|getBytesReader
argument_list|()
expr_stmt|;
block|}
comment|// Init w/ root block; don't use index since it may
comment|// not (and need not) have been loaded
for|for
control|(
name|int
name|arcIdx
init|=
literal|0
init|;
name|arcIdx
operator|<
name|arcs
operator|.
name|length
condition|;
name|arcIdx
operator|++
control|)
block|{
name|arcs
index|[
name|arcIdx
index|]
operator|=
operator|new
name|FST
operator|.
name|Arc
argument_list|<>
argument_list|()
expr_stmt|;
block|}
name|currentFrame
operator|=
name|staticFrame
expr_stmt|;
specifier|final
name|FST
operator|.
name|Arc
argument_list|<
name|BytesRef
argument_list|>
name|arc
decl_stmt|;
if|if
condition|(
name|fr
operator|.
name|index
operator|!=
literal|null
condition|)
block|{
name|arc
operator|=
name|fr
operator|.
name|index
operator|.
name|getFirstArc
argument_list|(
name|arcs
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|// Empty string prefix must have an output in the index!
assert|assert
name|arc
operator|.
name|isFinal
argument_list|()
assert|;
block|}
else|else
block|{
name|arc
operator|=
literal|null
expr_stmt|;
block|}
comment|//currentFrame = pushFrame(arc, rootCode, 0);
comment|//currentFrame.loadBlock();
name|validIndexPrefix
operator|=
literal|0
expr_stmt|;
comment|// if (DEBUG) {
comment|//   System.out.println("init frame state " + currentFrame.ord);
comment|//   printSeekState();
comment|// }
comment|//System.out.println();
comment|// computeBlockStats().print(System.out);
block|}
comment|// Not private to avoid synthetic access$NNN methods
DECL|method|initIndexInput
name|void
name|initIndexInput
parameter_list|()
block|{
if|if
condition|(
name|this
operator|.
name|in
operator|==
literal|null
condition|)
block|{
name|this
operator|.
name|in
operator|=
name|fr
operator|.
name|parent
operator|.
name|in
operator|.
name|clone
argument_list|()
expr_stmt|;
block|}
block|}
comment|/** Runs next() through the entire terms dict,    *  computing aggregate statistics. */
DECL|method|computeBlockStats
specifier|public
name|Stats
name|computeBlockStats
parameter_list|()
throws|throws
name|IOException
block|{
name|Stats
name|stats
init|=
operator|new
name|Stats
argument_list|(
name|fr
operator|.
name|parent
operator|.
name|segment
argument_list|,
name|fr
operator|.
name|fieldInfo
operator|.
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|fr
operator|.
name|index
operator|!=
literal|null
condition|)
block|{
name|stats
operator|.
name|indexNodeCount
operator|=
name|fr
operator|.
name|index
operator|.
name|getNodeCount
argument_list|()
expr_stmt|;
name|stats
operator|.
name|indexArcCount
operator|=
name|fr
operator|.
name|index
operator|.
name|getArcCount
argument_list|()
expr_stmt|;
name|stats
operator|.
name|indexNumBytes
operator|=
name|fr
operator|.
name|index
operator|.
name|ramBytesUsed
argument_list|()
expr_stmt|;
block|}
name|currentFrame
operator|=
name|staticFrame
expr_stmt|;
name|FST
operator|.
name|Arc
argument_list|<
name|BytesRef
argument_list|>
name|arc
decl_stmt|;
if|if
condition|(
name|fr
operator|.
name|index
operator|!=
literal|null
condition|)
block|{
name|arc
operator|=
name|fr
operator|.
name|index
operator|.
name|getFirstArc
argument_list|(
name|arcs
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|// Empty string prefix must have an output in the index!
assert|assert
name|arc
operator|.
name|isFinal
argument_list|()
assert|;
block|}
else|else
block|{
name|arc
operator|=
literal|null
expr_stmt|;
block|}
comment|// Empty string prefix must have an output in the
comment|// index!
name|currentFrame
operator|=
name|pushFrame
argument_list|(
name|arc
argument_list|,
name|fr
operator|.
name|rootCode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|currentFrame
operator|.
name|fpOrig
operator|=
name|currentFrame
operator|.
name|fp
expr_stmt|;
name|currentFrame
operator|.
name|loadBlock
argument_list|()
expr_stmt|;
name|validIndexPrefix
operator|=
literal|0
expr_stmt|;
name|stats
operator|.
name|startBlock
argument_list|(
name|currentFrame
argument_list|,
operator|!
name|currentFrame
operator|.
name|isLastInFloor
argument_list|)
expr_stmt|;
name|allTerms
label|:
while|while
condition|(
literal|true
condition|)
block|{
comment|// Pop finished blocks
while|while
condition|(
name|currentFrame
operator|.
name|nextEnt
operator|==
name|currentFrame
operator|.
name|entCount
condition|)
block|{
name|stats
operator|.
name|endBlock
argument_list|(
name|currentFrame
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|currentFrame
operator|.
name|isLastInFloor
condition|)
block|{
name|currentFrame
operator|.
name|loadNextFloorBlock
argument_list|()
expr_stmt|;
name|stats
operator|.
name|startBlock
argument_list|(
name|currentFrame
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|currentFrame
operator|.
name|ord
operator|==
literal|0
condition|)
block|{
break|break
name|allTerms
break|;
block|}
specifier|final
name|long
name|lastFP
init|=
name|currentFrame
operator|.
name|fpOrig
decl_stmt|;
name|currentFrame
operator|=
name|stack
index|[
name|currentFrame
operator|.
name|ord
operator|-
literal|1
index|]
expr_stmt|;
assert|assert
name|lastFP
operator|==
name|currentFrame
operator|.
name|lastSubFP
assert|;
comment|// if (DEBUG) {
comment|//   System.out.println("  reset validIndexPrefix=" + validIndexPrefix);
comment|// }
block|}
block|}
while|while
condition|(
literal|true
condition|)
block|{
if|if
condition|(
name|currentFrame
operator|.
name|next
argument_list|()
condition|)
block|{
comment|// Push to new block:
name|currentFrame
operator|=
name|pushFrame
argument_list|(
literal|null
argument_list|,
name|currentFrame
operator|.
name|lastSubFP
argument_list|,
name|term
operator|.
name|length
argument_list|)
expr_stmt|;
name|currentFrame
operator|.
name|fpOrig
operator|=
name|currentFrame
operator|.
name|fp
expr_stmt|;
comment|// This is a "next" frame -- even if it's
comment|// floor'd we must pretend it isn't so we don't
comment|// try to scan to the right floor frame:
name|currentFrame
operator|.
name|isFloor
operator|=
literal|false
expr_stmt|;
comment|//currentFrame.hasTerms = true;
name|currentFrame
operator|.
name|loadBlock
argument_list|()
expr_stmt|;
name|stats
operator|.
name|startBlock
argument_list|(
name|currentFrame
argument_list|,
operator|!
name|currentFrame
operator|.
name|isLastInFloor
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|stats
operator|.
name|term
argument_list|(
name|term
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
name|stats
operator|.
name|finish
argument_list|()
expr_stmt|;
comment|// Put root frame back:
name|currentFrame
operator|=
name|staticFrame
expr_stmt|;
if|if
condition|(
name|fr
operator|.
name|index
operator|!=
literal|null
condition|)
block|{
name|arc
operator|=
name|fr
operator|.
name|index
operator|.
name|getFirstArc
argument_list|(
name|arcs
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|// Empty string prefix must have an output in the index!
assert|assert
name|arc
operator|.
name|isFinal
argument_list|()
assert|;
block|}
else|else
block|{
name|arc
operator|=
literal|null
expr_stmt|;
block|}
name|currentFrame
operator|=
name|pushFrame
argument_list|(
name|arc
argument_list|,
name|fr
operator|.
name|rootCode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|currentFrame
operator|.
name|rewind
argument_list|()
expr_stmt|;
name|currentFrame
operator|.
name|loadBlock
argument_list|()
expr_stmt|;
name|validIndexPrefix
operator|=
literal|0
expr_stmt|;
name|term
operator|.
name|length
operator|=
literal|0
expr_stmt|;
return|return
name|stats
return|;
block|}
DECL|method|getFrame
specifier|private
name|SegmentTermsEnumFrame
name|getFrame
parameter_list|(
name|int
name|ord
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|ord
operator|>=
name|stack
operator|.
name|length
condition|)
block|{
specifier|final
name|SegmentTermsEnumFrame
index|[]
name|next
init|=
operator|new
name|SegmentTermsEnumFrame
index|[
name|ArrayUtil
operator|.
name|oversize
argument_list|(
literal|1
operator|+
name|ord
argument_list|,
name|RamUsageEstimator
operator|.
name|NUM_BYTES_OBJECT_REF
argument_list|)
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|stack
argument_list|,
literal|0
argument_list|,
name|next
argument_list|,
literal|0
argument_list|,
name|stack
operator|.
name|length
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|stackOrd
init|=
name|stack
operator|.
name|length
init|;
name|stackOrd
operator|<
name|next
operator|.
name|length
condition|;
name|stackOrd
operator|++
control|)
block|{
name|next
index|[
name|stackOrd
index|]
operator|=
operator|new
name|SegmentTermsEnumFrame
argument_list|(
name|this
argument_list|,
name|stackOrd
argument_list|)
expr_stmt|;
block|}
name|stack
operator|=
name|next
expr_stmt|;
block|}
assert|assert
name|stack
index|[
name|ord
index|]
operator|.
name|ord
operator|==
name|ord
assert|;
return|return
name|stack
index|[
name|ord
index|]
return|;
block|}
DECL|method|getArc
specifier|private
name|FST
operator|.
name|Arc
argument_list|<
name|BytesRef
argument_list|>
name|getArc
parameter_list|(
name|int
name|ord
parameter_list|)
block|{
if|if
condition|(
name|ord
operator|>=
name|arcs
operator|.
name|length
condition|)
block|{
annotation|@
name|SuppressWarnings
argument_list|(
block|{
literal|"rawtypes"
block|,
literal|"unchecked"
block|}
argument_list|)
specifier|final
name|FST
operator|.
name|Arc
argument_list|<
name|BytesRef
argument_list|>
index|[]
name|next
init|=
operator|new
name|FST
operator|.
name|Arc
index|[
name|ArrayUtil
operator|.
name|oversize
argument_list|(
literal|1
operator|+
name|ord
argument_list|,
name|RamUsageEstimator
operator|.
name|NUM_BYTES_OBJECT_REF
argument_list|)
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|arcs
argument_list|,
literal|0
argument_list|,
name|next
argument_list|,
literal|0
argument_list|,
name|arcs
operator|.
name|length
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|arcOrd
init|=
name|arcs
operator|.
name|length
init|;
name|arcOrd
operator|<
name|next
operator|.
name|length
condition|;
name|arcOrd
operator|++
control|)
block|{
name|next
index|[
name|arcOrd
index|]
operator|=
operator|new
name|FST
operator|.
name|Arc
argument_list|<>
argument_list|()
expr_stmt|;
block|}
name|arcs
operator|=
name|next
expr_stmt|;
block|}
return|return
name|arcs
index|[
name|ord
index|]
return|;
block|}
comment|// Pushes a frame we seek'd to
DECL|method|pushFrame
name|SegmentTermsEnumFrame
name|pushFrame
parameter_list|(
name|FST
operator|.
name|Arc
argument_list|<
name|BytesRef
argument_list|>
name|arc
parameter_list|,
name|BytesRef
name|frameData
parameter_list|,
name|int
name|length
parameter_list|)
throws|throws
name|IOException
block|{
name|scratchReader
operator|.
name|reset
argument_list|(
name|frameData
operator|.
name|bytes
argument_list|,
name|frameData
operator|.
name|offset
argument_list|,
name|frameData
operator|.
name|length
argument_list|)
expr_stmt|;
specifier|final
name|long
name|code
init|=
name|scratchReader
operator|.
name|readVLong
argument_list|()
decl_stmt|;
specifier|final
name|long
name|fpSeek
init|=
name|code
operator|>>>
name|BlockTreeTermsWriter
operator|.
name|OUTPUT_FLAGS_NUM_BITS
decl_stmt|;
specifier|final
name|SegmentTermsEnumFrame
name|f
init|=
name|getFrame
argument_list|(
literal|1
operator|+
name|currentFrame
operator|.
name|ord
argument_list|)
decl_stmt|;
name|f
operator|.
name|hasTerms
operator|=
operator|(
name|code
operator|&
name|BlockTreeTermsWriter
operator|.
name|OUTPUT_FLAG_HAS_TERMS
operator|)
operator|!=
literal|0
expr_stmt|;
name|f
operator|.
name|hasTermsOrig
operator|=
name|f
operator|.
name|hasTerms
expr_stmt|;
name|f
operator|.
name|isFloor
operator|=
operator|(
name|code
operator|&
name|BlockTreeTermsWriter
operator|.
name|OUTPUT_FLAG_IS_FLOOR
operator|)
operator|!=
literal|0
expr_stmt|;
if|if
condition|(
name|f
operator|.
name|isFloor
condition|)
block|{
name|f
operator|.
name|setFloorData
argument_list|(
name|scratchReader
argument_list|,
name|frameData
argument_list|)
expr_stmt|;
block|}
name|pushFrame
argument_list|(
name|arc
argument_list|,
name|fpSeek
argument_list|,
name|length
argument_list|)
expr_stmt|;
return|return
name|f
return|;
block|}
comment|// Pushes next'd frame or seek'd frame; we later
comment|// lazy-load the frame only when needed
DECL|method|pushFrame
name|SegmentTermsEnumFrame
name|pushFrame
parameter_list|(
name|FST
operator|.
name|Arc
argument_list|<
name|BytesRef
argument_list|>
name|arc
parameter_list|,
name|long
name|fp
parameter_list|,
name|int
name|length
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|SegmentTermsEnumFrame
name|f
init|=
name|getFrame
argument_list|(
literal|1
operator|+
name|currentFrame
operator|.
name|ord
argument_list|)
decl_stmt|;
name|f
operator|.
name|arc
operator|=
name|arc
expr_stmt|;
if|if
condition|(
name|f
operator|.
name|fpOrig
operator|==
name|fp
operator|&&
name|f
operator|.
name|nextEnt
operator|!=
operator|-
literal|1
condition|)
block|{
comment|//if (DEBUG) System.out.println("      push reused frame ord=" + f.ord + " fp=" + f.fp + " isFloor?=" + f.isFloor + " hasTerms=" + f.hasTerms + " pref=" + term + " nextEnt=" + f.nextEnt + " targetBeforeCurrentLength=" + targetBeforeCurrentLength + " term.length=" + term.length + " vs prefix=" + f.prefix);
comment|//if (f.prefix> targetBeforeCurrentLength) {
if|if
condition|(
name|f
operator|.
name|ord
operator|>
name|targetBeforeCurrentLength
condition|)
block|{
name|f
operator|.
name|rewind
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|// if (DEBUG) {
comment|//   System.out.println("        skip rewind!");
comment|// }
block|}
assert|assert
name|length
operator|==
name|f
operator|.
name|prefix
assert|;
block|}
else|else
block|{
name|f
operator|.
name|nextEnt
operator|=
operator|-
literal|1
expr_stmt|;
name|f
operator|.
name|prefix
operator|=
name|length
expr_stmt|;
name|f
operator|.
name|state
operator|.
name|termBlockOrd
operator|=
literal|0
expr_stmt|;
name|f
operator|.
name|fpOrig
operator|=
name|f
operator|.
name|fp
operator|=
name|fp
expr_stmt|;
name|f
operator|.
name|lastSubFP
operator|=
operator|-
literal|1
expr_stmt|;
comment|// if (DEBUG) {
comment|//   final int sav = term.length;
comment|//   term.length = length;
comment|//   System.out.println("      push new frame ord=" + f.ord + " fp=" + f.fp + " hasTerms=" + f.hasTerms + " isFloor=" + f.isFloor + " pref=" + brToString(term));
comment|//   term.length = sav;
comment|// }
block|}
return|return
name|f
return|;
block|}
comment|// asserts only
DECL|method|clearEOF
specifier|private
name|boolean
name|clearEOF
parameter_list|()
block|{
name|eof
operator|=
literal|false
expr_stmt|;
return|return
literal|true
return|;
block|}
comment|// asserts only
DECL|method|setEOF
specifier|private
name|boolean
name|setEOF
parameter_list|()
block|{
name|eof
operator|=
literal|true
expr_stmt|;
return|return
literal|true
return|;
block|}
comment|// for debugging
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unused"
argument_list|)
DECL|method|brToString
specifier|static
name|String
name|brToString
parameter_list|(
name|BytesRef
name|b
parameter_list|)
block|{
try|try
block|{
return|return
name|b
operator|.
name|utf8ToString
argument_list|()
operator|+
literal|" "
operator|+
name|b
return|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
comment|// If BytesRef isn't actually UTF8, or it's eg a
comment|// prefix of UTF8 that ends mid-unicode-char, we
comment|// fallback to hex:
return|return
name|b
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|seekExact
specifier|public
name|boolean
name|seekExact
parameter_list|(
specifier|final
name|BytesRef
name|target
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|fr
operator|.
name|index
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"terms index was not loaded"
argument_list|)
throw|;
block|}
if|if
condition|(
name|term
operator|.
name|bytes
operator|.
name|length
operator|<=
name|target
operator|.
name|length
condition|)
block|{
name|term
operator|.
name|bytes
operator|=
name|ArrayUtil
operator|.
name|grow
argument_list|(
name|term
operator|.
name|bytes
argument_list|,
literal|1
operator|+
name|target
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
assert|assert
name|clearEOF
argument_list|()
assert|;
comment|// if (DEBUG) {
comment|//   System.out.println("\nBTTR.seekExact seg=" + fr.parent.segment + " target=" + fr.fieldInfo.name + ":" + brToString(target) + " current=" + brToString(term) + " (exists?=" + termExists + ") validIndexPrefix=" + validIndexPrefix);
comment|//   printSeekState(System.out);
comment|// }
name|FST
operator|.
name|Arc
argument_list|<
name|BytesRef
argument_list|>
name|arc
decl_stmt|;
name|int
name|targetUpto
decl_stmt|;
name|BytesRef
name|output
decl_stmt|;
name|targetBeforeCurrentLength
operator|=
name|currentFrame
operator|.
name|ord
expr_stmt|;
if|if
condition|(
name|currentFrame
operator|!=
name|staticFrame
condition|)
block|{
comment|// We are already seek'd; find the common
comment|// prefix of new seek term vs current term and
comment|// re-use the corresponding seek state.  For
comment|// example, if app first seeks to foobar, then
comment|// seeks to foobaz, we can re-use the seek state
comment|// for the first 5 bytes.
comment|// if (DEBUG) {
comment|//   System.out.println("  re-use current seek state validIndexPrefix=" + validIndexPrefix);
comment|// }
name|arc
operator|=
name|arcs
index|[
literal|0
index|]
expr_stmt|;
assert|assert
name|arc
operator|.
name|isFinal
argument_list|()
assert|;
name|output
operator|=
name|arc
operator|.
name|output
expr_stmt|;
name|targetUpto
operator|=
literal|0
expr_stmt|;
name|SegmentTermsEnumFrame
name|lastFrame
init|=
name|stack
index|[
literal|0
index|]
decl_stmt|;
assert|assert
name|validIndexPrefix
operator|<=
name|term
operator|.
name|length
assert|;
specifier|final
name|int
name|targetLimit
init|=
name|Math
operator|.
name|min
argument_list|(
name|target
operator|.
name|length
argument_list|,
name|validIndexPrefix
argument_list|)
decl_stmt|;
name|int
name|cmp
init|=
literal|0
decl_stmt|;
comment|// TODO: reverse vLong byte order for better FST
comment|// prefix output sharing
comment|// First compare up to valid seek frames:
while|while
condition|(
name|targetUpto
operator|<
name|targetLimit
condition|)
block|{
name|cmp
operator|=
operator|(
name|term
operator|.
name|bytes
index|[
name|targetUpto
index|]
operator|&
literal|0xFF
operator|)
operator|-
operator|(
name|target
operator|.
name|bytes
index|[
name|target
operator|.
name|offset
operator|+
name|targetUpto
index|]
operator|&
literal|0xFF
operator|)
expr_stmt|;
comment|// if (DEBUG) {
comment|//    System.out.println("    cycle targetUpto=" + targetUpto + " (vs limit=" + targetLimit + ") cmp=" + cmp + " (targetLabel=" + (char) (target.bytes[target.offset + targetUpto]) + " vs termLabel=" + (char) (term.bytes[targetUpto]) + ")"   + " arc.output=" + arc.output + " output=" + output);
comment|// }
if|if
condition|(
name|cmp
operator|!=
literal|0
condition|)
block|{
break|break;
block|}
name|arc
operator|=
name|arcs
index|[
literal|1
operator|+
name|targetUpto
index|]
expr_stmt|;
assert|assert
name|arc
operator|.
name|label
operator|==
operator|(
name|target
operator|.
name|bytes
index|[
name|target
operator|.
name|offset
operator|+
name|targetUpto
index|]
operator|&
literal|0xFF
operator|)
operator|:
literal|"arc.label="
operator|+
operator|(
name|char
operator|)
name|arc
operator|.
name|label
operator|+
literal|" targetLabel="
operator|+
call|(
name|char
call|)
argument_list|(
name|target
operator|.
name|bytes
index|[
name|target
operator|.
name|offset
operator|+
name|targetUpto
index|]
operator|&
literal|0xFF
argument_list|)
assert|;
if|if
condition|(
name|arc
operator|.
name|output
operator|!=
name|BlockTreeTermsWriter
operator|.
name|NO_OUTPUT
condition|)
block|{
name|output
operator|=
name|BlockTreeTermsWriter
operator|.
name|FST_OUTPUTS
operator|.
name|add
argument_list|(
name|output
argument_list|,
name|arc
operator|.
name|output
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|arc
operator|.
name|isFinal
argument_list|()
condition|)
block|{
name|lastFrame
operator|=
name|stack
index|[
literal|1
operator|+
name|lastFrame
operator|.
name|ord
index|]
expr_stmt|;
block|}
name|targetUpto
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|cmp
operator|==
literal|0
condition|)
block|{
specifier|final
name|int
name|targetUptoMid
init|=
name|targetUpto
decl_stmt|;
comment|// Second compare the rest of the term, but
comment|// don't save arc/output/frame; we only do this
comment|// to find out if the target term is before,
comment|// equal or after the current term
specifier|final
name|int
name|targetLimit2
init|=
name|Math
operator|.
name|min
argument_list|(
name|target
operator|.
name|length
argument_list|,
name|term
operator|.
name|length
argument_list|)
decl_stmt|;
while|while
condition|(
name|targetUpto
operator|<
name|targetLimit2
condition|)
block|{
name|cmp
operator|=
operator|(
name|term
operator|.
name|bytes
index|[
name|targetUpto
index|]
operator|&
literal|0xFF
operator|)
operator|-
operator|(
name|target
operator|.
name|bytes
index|[
name|target
operator|.
name|offset
operator|+
name|targetUpto
index|]
operator|&
literal|0xFF
operator|)
expr_stmt|;
comment|// if (DEBUG) {
comment|//    System.out.println("    cycle2 targetUpto=" + targetUpto + " (vs limit=" + targetLimit + ") cmp=" + cmp + " (targetLabel=" + (char) (target.bytes[target.offset + targetUpto]) + " vs termLabel=" + (char) (term.bytes[targetUpto]) + ")");
comment|// }
if|if
condition|(
name|cmp
operator|!=
literal|0
condition|)
block|{
break|break;
block|}
name|targetUpto
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|cmp
operator|==
literal|0
condition|)
block|{
name|cmp
operator|=
name|term
operator|.
name|length
operator|-
name|target
operator|.
name|length
expr_stmt|;
block|}
name|targetUpto
operator|=
name|targetUptoMid
expr_stmt|;
block|}
if|if
condition|(
name|cmp
operator|<
literal|0
condition|)
block|{
comment|// Common case: target term is after current
comment|// term, ie, app is seeking multiple terms
comment|// in sorted order
comment|// if (DEBUG) {
comment|//   System.out.println("  target is after current (shares prefixLen=" + targetUpto + "); frame.ord=" + lastFrame.ord);
comment|// }
name|currentFrame
operator|=
name|lastFrame
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cmp
operator|>
literal|0
condition|)
block|{
comment|// Uncommon case: target term
comment|// is before current term; this means we can
comment|// keep the currentFrame but we must rewind it
comment|// (so we scan from the start)
name|targetBeforeCurrentLength
operator|=
name|lastFrame
operator|.
name|ord
expr_stmt|;
comment|// if (DEBUG) {
comment|//   System.out.println("  target is before current (shares prefixLen=" + targetUpto + "); rewind frame ord=" + lastFrame.ord);
comment|// }
name|currentFrame
operator|=
name|lastFrame
expr_stmt|;
name|currentFrame
operator|.
name|rewind
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|// Target is exactly the same as current term
assert|assert
name|term
operator|.
name|length
operator|==
name|target
operator|.
name|length
assert|;
if|if
condition|(
name|termExists
condition|)
block|{
comment|// if (DEBUG) {
comment|//   System.out.println("  target is same as current; return true");
comment|// }
return|return
literal|true
return|;
block|}
else|else
block|{
comment|// if (DEBUG) {
comment|//   System.out.println("  target is same as current but term doesn't exist");
comment|// }
block|}
comment|//validIndexPrefix = currentFrame.depth;
comment|//term.length = target.length;
comment|//return termExists;
block|}
block|}
else|else
block|{
name|targetBeforeCurrentLength
operator|=
operator|-
literal|1
expr_stmt|;
name|arc
operator|=
name|fr
operator|.
name|index
operator|.
name|getFirstArc
argument_list|(
name|arcs
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|// Empty string prefix must have an output (block) in the index!
assert|assert
name|arc
operator|.
name|isFinal
argument_list|()
assert|;
assert|assert
name|arc
operator|.
name|output
operator|!=
literal|null
assert|;
comment|// if (DEBUG) {
comment|//   System.out.println("    no seek state; push root frame");
comment|// }
name|output
operator|=
name|arc
operator|.
name|output
expr_stmt|;
name|currentFrame
operator|=
name|staticFrame
expr_stmt|;
comment|//term.length = 0;
name|targetUpto
operator|=
literal|0
expr_stmt|;
name|currentFrame
operator|=
name|pushFrame
argument_list|(
name|arc
argument_list|,
name|BlockTreeTermsWriter
operator|.
name|FST_OUTPUTS
operator|.
name|add
argument_list|(
name|output
argument_list|,
name|arc
operator|.
name|nextFinalOutput
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|// if (DEBUG) {
comment|//   System.out.println("  start index loop targetUpto=" + targetUpto + " output=" + output + " currentFrame.ord=" + currentFrame.ord + " targetBeforeCurrentLength=" + targetBeforeCurrentLength);
comment|// }
comment|// We are done sharing the common prefix with the incoming target and where we are currently seek'd; now continue walking the index:
while|while
condition|(
name|targetUpto
operator|<
name|target
operator|.
name|length
condition|)
block|{
specifier|final
name|int
name|targetLabel
init|=
name|target
operator|.
name|bytes
index|[
name|target
operator|.
name|offset
operator|+
name|targetUpto
index|]
operator|&
literal|0xFF
decl_stmt|;
specifier|final
name|FST
operator|.
name|Arc
argument_list|<
name|BytesRef
argument_list|>
name|nextArc
init|=
name|fr
operator|.
name|index
operator|.
name|findTargetArc
argument_list|(
name|targetLabel
argument_list|,
name|arc
argument_list|,
name|getArc
argument_list|(
literal|1
operator|+
name|targetUpto
argument_list|)
argument_list|,
name|fstReader
argument_list|)
decl_stmt|;
if|if
condition|(
name|nextArc
operator|==
literal|null
condition|)
block|{
comment|// Index is exhausted
comment|// if (DEBUG) {
comment|//   System.out.println("    index: index exhausted label=" + ((char) targetLabel) + " " + toHex(targetLabel));
comment|// }
name|validIndexPrefix
operator|=
name|currentFrame
operator|.
name|prefix
expr_stmt|;
comment|//validIndexPrefix = targetUpto;
name|currentFrame
operator|.
name|scanToFloorFrame
argument_list|(
name|target
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|currentFrame
operator|.
name|hasTerms
condition|)
block|{
name|termExists
operator|=
literal|false
expr_stmt|;
name|term
operator|.
name|bytes
index|[
name|targetUpto
index|]
operator|=
operator|(
name|byte
operator|)
name|targetLabel
expr_stmt|;
name|term
operator|.
name|length
operator|=
literal|1
operator|+
name|targetUpto
expr_stmt|;
comment|// if (DEBUG) {
comment|//   System.out.println("  FAST NOT_FOUND term=" + brToString(term));
comment|// }
return|return
literal|false
return|;
block|}
name|currentFrame
operator|.
name|loadBlock
argument_list|()
expr_stmt|;
specifier|final
name|SeekStatus
name|result
init|=
name|currentFrame
operator|.
name|scanToTerm
argument_list|(
name|target
argument_list|,
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|==
name|SeekStatus
operator|.
name|FOUND
condition|)
block|{
comment|// if (DEBUG) {
comment|//   System.out.println("  return FOUND term=" + term.utf8ToString() + " " + term);
comment|// }
return|return
literal|true
return|;
block|}
else|else
block|{
comment|// if (DEBUG) {
comment|//   System.out.println("  got " + result + "; return NOT_FOUND term=" + brToString(term));
comment|// }
return|return
literal|false
return|;
block|}
block|}
else|else
block|{
comment|// Follow this arc
name|arc
operator|=
name|nextArc
expr_stmt|;
name|term
operator|.
name|bytes
index|[
name|targetUpto
index|]
operator|=
operator|(
name|byte
operator|)
name|targetLabel
expr_stmt|;
comment|// Aggregate output as we go:
assert|assert
name|arc
operator|.
name|output
operator|!=
literal|null
assert|;
if|if
condition|(
name|arc
operator|.
name|output
operator|!=
name|BlockTreeTermsWriter
operator|.
name|NO_OUTPUT
condition|)
block|{
name|output
operator|=
name|BlockTreeTermsWriter
operator|.
name|FST_OUTPUTS
operator|.
name|add
argument_list|(
name|output
argument_list|,
name|arc
operator|.
name|output
argument_list|)
expr_stmt|;
block|}
comment|// if (DEBUG) {
comment|//   System.out.println("    index: follow label=" + toHex(target.bytes[target.offset + targetUpto]&0xff) + " arc.output=" + arc.output + " arc.nfo=" + arc.nextFinalOutput);
comment|// }
name|targetUpto
operator|++
expr_stmt|;
if|if
condition|(
name|arc
operator|.
name|isFinal
argument_list|()
condition|)
block|{
comment|//if (DEBUG) System.out.println("    arc is final!");
name|currentFrame
operator|=
name|pushFrame
argument_list|(
name|arc
argument_list|,
name|BlockTreeTermsWriter
operator|.
name|FST_OUTPUTS
operator|.
name|add
argument_list|(
name|output
argument_list|,
name|arc
operator|.
name|nextFinalOutput
argument_list|)
argument_list|,
name|targetUpto
argument_list|)
expr_stmt|;
comment|//if (DEBUG) System.out.println("    curFrame.ord=" + currentFrame.ord + " hasTerms=" + currentFrame.hasTerms);
block|}
block|}
block|}
comment|//validIndexPrefix = targetUpto;
name|validIndexPrefix
operator|=
name|currentFrame
operator|.
name|prefix
expr_stmt|;
name|currentFrame
operator|.
name|scanToFloorFrame
argument_list|(
name|target
argument_list|)
expr_stmt|;
comment|// Target term is entirely contained in the index:
if|if
condition|(
operator|!
name|currentFrame
operator|.
name|hasTerms
condition|)
block|{
name|termExists
operator|=
literal|false
expr_stmt|;
name|term
operator|.
name|length
operator|=
name|targetUpto
expr_stmt|;
comment|// if (DEBUG) {
comment|//   System.out.println("  FAST NOT_FOUND term=" + brToString(term));
comment|// }
return|return
literal|false
return|;
block|}
name|currentFrame
operator|.
name|loadBlock
argument_list|()
expr_stmt|;
specifier|final
name|SeekStatus
name|result
init|=
name|currentFrame
operator|.
name|scanToTerm
argument_list|(
name|target
argument_list|,
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|==
name|SeekStatus
operator|.
name|FOUND
condition|)
block|{
comment|// if (DEBUG) {
comment|//   System.out.println("  return FOUND term=" + term.utf8ToString() + " " + term);
comment|// }
return|return
literal|true
return|;
block|}
else|else
block|{
comment|// if (DEBUG) {
comment|//   System.out.println("  got result " + result + "; return NOT_FOUND term=" + term.utf8ToString());
comment|// }
return|return
literal|false
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|seekCeil
specifier|public
name|SeekStatus
name|seekCeil
parameter_list|(
specifier|final
name|BytesRef
name|target
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|fr
operator|.
name|index
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"terms index was not loaded"
argument_list|)
throw|;
block|}
if|if
condition|(
name|term
operator|.
name|bytes
operator|.
name|length
operator|<=
name|target
operator|.
name|length
condition|)
block|{
name|term
operator|.
name|bytes
operator|=
name|ArrayUtil
operator|.
name|grow
argument_list|(
name|term
operator|.
name|bytes
argument_list|,
literal|1
operator|+
name|target
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
assert|assert
name|clearEOF
argument_list|()
assert|;
comment|// if (DEBUG) {
comment|//   System.out.println("\nBTTR.seekCeil seg=" + fr.parent.segment + " target=" + fr.fieldInfo.name + ":" + target.utf8ToString() + " " + target + " current=" + brToString(term) + " (exists?=" + termExists + ") validIndexPrefix=  " + validIndexPrefix);
comment|//   printSeekState(System.out);
comment|// }
name|FST
operator|.
name|Arc
argument_list|<
name|BytesRef
argument_list|>
name|arc
decl_stmt|;
name|int
name|targetUpto
decl_stmt|;
name|BytesRef
name|output
decl_stmt|;
name|targetBeforeCurrentLength
operator|=
name|currentFrame
operator|.
name|ord
expr_stmt|;
if|if
condition|(
name|currentFrame
operator|!=
name|staticFrame
condition|)
block|{
comment|// We are already seek'd; find the common
comment|// prefix of new seek term vs current term and
comment|// re-use the corresponding seek state.  For
comment|// example, if app first seeks to foobar, then
comment|// seeks to foobaz, we can re-use the seek state
comment|// for the first 5 bytes.
comment|//if (DEBUG) {
comment|//System.out.println("  re-use current seek state validIndexPrefix=" + validIndexPrefix);
comment|//}
name|arc
operator|=
name|arcs
index|[
literal|0
index|]
expr_stmt|;
assert|assert
name|arc
operator|.
name|isFinal
argument_list|()
assert|;
name|output
operator|=
name|arc
operator|.
name|output
expr_stmt|;
name|targetUpto
operator|=
literal|0
expr_stmt|;
name|SegmentTermsEnumFrame
name|lastFrame
init|=
name|stack
index|[
literal|0
index|]
decl_stmt|;
assert|assert
name|validIndexPrefix
operator|<=
name|term
operator|.
name|length
assert|;
specifier|final
name|int
name|targetLimit
init|=
name|Math
operator|.
name|min
argument_list|(
name|target
operator|.
name|length
argument_list|,
name|validIndexPrefix
argument_list|)
decl_stmt|;
name|int
name|cmp
init|=
literal|0
decl_stmt|;
comment|// TOOD: we should write our vLong backwards (MSB
comment|// first) to get better sharing from the FST
comment|// First compare up to valid seek frames:
while|while
condition|(
name|targetUpto
operator|<
name|targetLimit
condition|)
block|{
name|cmp
operator|=
operator|(
name|term
operator|.
name|bytes
index|[
name|targetUpto
index|]
operator|&
literal|0xFF
operator|)
operator|-
operator|(
name|target
operator|.
name|bytes
index|[
name|target
operator|.
name|offset
operator|+
name|targetUpto
index|]
operator|&
literal|0xFF
operator|)
expr_stmt|;
comment|//if (DEBUG) {
comment|//System.out.println("    cycle targetUpto=" + targetUpto + " (vs limit=" + targetLimit + ") cmp=" + cmp + " (targetLabel=" + (char) (target.bytes[target.offset + targetUpto]) + " vs termLabel=" + (char) (term.bytes[targetUpto]) + ")"   + " arc.output=" + arc.output + " output=" + output);
comment|//}
if|if
condition|(
name|cmp
operator|!=
literal|0
condition|)
block|{
break|break;
block|}
name|arc
operator|=
name|arcs
index|[
literal|1
operator|+
name|targetUpto
index|]
expr_stmt|;
assert|assert
name|arc
operator|.
name|label
operator|==
operator|(
name|target
operator|.
name|bytes
index|[
name|target
operator|.
name|offset
operator|+
name|targetUpto
index|]
operator|&
literal|0xFF
operator|)
operator|:
literal|"arc.label="
operator|+
operator|(
name|char
operator|)
name|arc
operator|.
name|label
operator|+
literal|" targetLabel="
operator|+
call|(
name|char
call|)
argument_list|(
name|target
operator|.
name|bytes
index|[
name|target
operator|.
name|offset
operator|+
name|targetUpto
index|]
operator|&
literal|0xFF
argument_list|)
assert|;
comment|// TOOD: we could save the outputs in local
comment|// byte[][] instead of making new objs ever
comment|// seek; but, often the FST doesn't have any
comment|// shared bytes (but this could change if we
comment|// reverse vLong byte order)
if|if
condition|(
name|arc
operator|.
name|output
operator|!=
name|BlockTreeTermsWriter
operator|.
name|NO_OUTPUT
condition|)
block|{
name|output
operator|=
name|BlockTreeTermsWriter
operator|.
name|FST_OUTPUTS
operator|.
name|add
argument_list|(
name|output
argument_list|,
name|arc
operator|.
name|output
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|arc
operator|.
name|isFinal
argument_list|()
condition|)
block|{
name|lastFrame
operator|=
name|stack
index|[
literal|1
operator|+
name|lastFrame
operator|.
name|ord
index|]
expr_stmt|;
block|}
name|targetUpto
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|cmp
operator|==
literal|0
condition|)
block|{
specifier|final
name|int
name|targetUptoMid
init|=
name|targetUpto
decl_stmt|;
comment|// Second compare the rest of the term, but
comment|// don't save arc/output/frame:
specifier|final
name|int
name|targetLimit2
init|=
name|Math
operator|.
name|min
argument_list|(
name|target
operator|.
name|length
argument_list|,
name|term
operator|.
name|length
argument_list|)
decl_stmt|;
while|while
condition|(
name|targetUpto
operator|<
name|targetLimit2
condition|)
block|{
name|cmp
operator|=
operator|(
name|term
operator|.
name|bytes
index|[
name|targetUpto
index|]
operator|&
literal|0xFF
operator|)
operator|-
operator|(
name|target
operator|.
name|bytes
index|[
name|target
operator|.
name|offset
operator|+
name|targetUpto
index|]
operator|&
literal|0xFF
operator|)
expr_stmt|;
comment|//if (DEBUG) {
comment|//System.out.println("    cycle2 targetUpto=" + targetUpto + " (vs limit=" + targetLimit + ") cmp=" + cmp + " (targetLabel=" + (char) (target.bytes[target.offset + targetUpto]) + " vs termLabel=" + (char) (term.bytes[targetUpto]) + ")");
comment|//}
if|if
condition|(
name|cmp
operator|!=
literal|0
condition|)
block|{
break|break;
block|}
name|targetUpto
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|cmp
operator|==
literal|0
condition|)
block|{
name|cmp
operator|=
name|term
operator|.
name|length
operator|-
name|target
operator|.
name|length
expr_stmt|;
block|}
name|targetUpto
operator|=
name|targetUptoMid
expr_stmt|;
block|}
if|if
condition|(
name|cmp
operator|<
literal|0
condition|)
block|{
comment|// Common case: target term is after current
comment|// term, ie, app is seeking multiple terms
comment|// in sorted order
comment|//if (DEBUG) {
comment|//System.out.println("  target is after current (shares prefixLen=" + targetUpto + "); clear frame.scanned ord=" + lastFrame.ord);
comment|//}
name|currentFrame
operator|=
name|lastFrame
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cmp
operator|>
literal|0
condition|)
block|{
comment|// Uncommon case: target term
comment|// is before current term; this means we can
comment|// keep the currentFrame but we must rewind it
comment|// (so we scan from the start)
name|targetBeforeCurrentLength
operator|=
literal|0
expr_stmt|;
comment|//if (DEBUG) {
comment|//System.out.println("  target is before current (shares prefixLen=" + targetUpto + "); rewind frame ord=" + lastFrame.ord);
comment|//}
name|currentFrame
operator|=
name|lastFrame
expr_stmt|;
name|currentFrame
operator|.
name|rewind
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|// Target is exactly the same as current term
assert|assert
name|term
operator|.
name|length
operator|==
name|target
operator|.
name|length
assert|;
if|if
condition|(
name|termExists
condition|)
block|{
comment|//if (DEBUG) {
comment|//System.out.println("  target is same as current; return FOUND");
comment|//}
return|return
name|SeekStatus
operator|.
name|FOUND
return|;
block|}
else|else
block|{
comment|//if (DEBUG) {
comment|//System.out.println("  target is same as current but term doesn't exist");
comment|//}
block|}
block|}
block|}
else|else
block|{
name|targetBeforeCurrentLength
operator|=
operator|-
literal|1
expr_stmt|;
name|arc
operator|=
name|fr
operator|.
name|index
operator|.
name|getFirstArc
argument_list|(
name|arcs
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|// Empty string prefix must have an output (block) in the index!
assert|assert
name|arc
operator|.
name|isFinal
argument_list|()
assert|;
assert|assert
name|arc
operator|.
name|output
operator|!=
literal|null
assert|;
comment|//if (DEBUG) {
comment|//System.out.println("    no seek state; push root frame");
comment|//}
name|output
operator|=
name|arc
operator|.
name|output
expr_stmt|;
name|currentFrame
operator|=
name|staticFrame
expr_stmt|;
comment|//term.length = 0;
name|targetUpto
operator|=
literal|0
expr_stmt|;
name|currentFrame
operator|=
name|pushFrame
argument_list|(
name|arc
argument_list|,
name|BlockTreeTermsWriter
operator|.
name|FST_OUTPUTS
operator|.
name|add
argument_list|(
name|output
argument_list|,
name|arc
operator|.
name|nextFinalOutput
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|//if (DEBUG) {
comment|//System.out.println("  start index loop targetUpto=" + targetUpto + " output=" + output + " currentFrame.ord+1=" + currentFrame.ord + " targetBeforeCurrentLength=" + targetBeforeCurrentLength);
comment|//}
comment|// We are done sharing the common prefix with the incoming target and where we are currently seek'd; now continue walking the index:
while|while
condition|(
name|targetUpto
operator|<
name|target
operator|.
name|length
condition|)
block|{
specifier|final
name|int
name|targetLabel
init|=
name|target
operator|.
name|bytes
index|[
name|target
operator|.
name|offset
operator|+
name|targetUpto
index|]
operator|&
literal|0xFF
decl_stmt|;
specifier|final
name|FST
operator|.
name|Arc
argument_list|<
name|BytesRef
argument_list|>
name|nextArc
init|=
name|fr
operator|.
name|index
operator|.
name|findTargetArc
argument_list|(
name|targetLabel
argument_list|,
name|arc
argument_list|,
name|getArc
argument_list|(
literal|1
operator|+
name|targetUpto
argument_list|)
argument_list|,
name|fstReader
argument_list|)
decl_stmt|;
if|if
condition|(
name|nextArc
operator|==
literal|null
condition|)
block|{
comment|// Index is exhausted
comment|// if (DEBUG) {
comment|//   System.out.println("    index: index exhausted label=" + ((char) targetLabel) + " " + toHex(targetLabel));
comment|// }
name|validIndexPrefix
operator|=
name|currentFrame
operator|.
name|prefix
expr_stmt|;
comment|//validIndexPrefix = targetUpto;
name|currentFrame
operator|.
name|scanToFloorFrame
argument_list|(
name|target
argument_list|)
expr_stmt|;
name|currentFrame
operator|.
name|loadBlock
argument_list|()
expr_stmt|;
specifier|final
name|SeekStatus
name|result
init|=
name|currentFrame
operator|.
name|scanToTerm
argument_list|(
name|target
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|==
name|SeekStatus
operator|.
name|END
condition|)
block|{
name|term
operator|.
name|copyBytes
argument_list|(
name|target
argument_list|)
expr_stmt|;
name|termExists
operator|=
literal|false
expr_stmt|;
if|if
condition|(
name|next
argument_list|()
operator|!=
literal|null
condition|)
block|{
comment|//if (DEBUG) {
comment|//System.out.println("  return NOT_FOUND term=" + brToString(term) + " " + term);
comment|//}
return|return
name|SeekStatus
operator|.
name|NOT_FOUND
return|;
block|}
else|else
block|{
comment|//if (DEBUG) {
comment|//System.out.println("  return END");
comment|//}
return|return
name|SeekStatus
operator|.
name|END
return|;
block|}
block|}
else|else
block|{
comment|//if (DEBUG) {
comment|//System.out.println("  return " + result + " term=" + brToString(term) + " " + term);
comment|//}
return|return
name|result
return|;
block|}
block|}
else|else
block|{
comment|// Follow this arc
name|term
operator|.
name|bytes
index|[
name|targetUpto
index|]
operator|=
operator|(
name|byte
operator|)
name|targetLabel
expr_stmt|;
name|arc
operator|=
name|nextArc
expr_stmt|;
comment|// Aggregate output as we go:
assert|assert
name|arc
operator|.
name|output
operator|!=
literal|null
assert|;
if|if
condition|(
name|arc
operator|.
name|output
operator|!=
name|BlockTreeTermsWriter
operator|.
name|NO_OUTPUT
condition|)
block|{
name|output
operator|=
name|BlockTreeTermsWriter
operator|.
name|FST_OUTPUTS
operator|.
name|add
argument_list|(
name|output
argument_list|,
name|arc
operator|.
name|output
argument_list|)
expr_stmt|;
block|}
comment|//if (DEBUG) {
comment|//System.out.println("    index: follow label=" + toHex(target.bytes[target.offset + targetUpto]&0xff) + " arc.output=" + arc.output + " arc.nfo=" + arc.nextFinalOutput);
comment|//}
name|targetUpto
operator|++
expr_stmt|;
if|if
condition|(
name|arc
operator|.
name|isFinal
argument_list|()
condition|)
block|{
comment|//if (DEBUG) System.out.println("    arc is final!");
name|currentFrame
operator|=
name|pushFrame
argument_list|(
name|arc
argument_list|,
name|BlockTreeTermsWriter
operator|.
name|FST_OUTPUTS
operator|.
name|add
argument_list|(
name|output
argument_list|,
name|arc
operator|.
name|nextFinalOutput
argument_list|)
argument_list|,
name|targetUpto
argument_list|)
expr_stmt|;
comment|//if (DEBUG) System.out.println("    curFrame.ord=" + currentFrame.ord + " hasTerms=" + currentFrame.hasTerms);
block|}
block|}
block|}
comment|//validIndexPrefix = targetUpto;
name|validIndexPrefix
operator|=
name|currentFrame
operator|.
name|prefix
expr_stmt|;
name|currentFrame
operator|.
name|scanToFloorFrame
argument_list|(
name|target
argument_list|)
expr_stmt|;
name|currentFrame
operator|.
name|loadBlock
argument_list|()
expr_stmt|;
specifier|final
name|SeekStatus
name|result
init|=
name|currentFrame
operator|.
name|scanToTerm
argument_list|(
name|target
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|==
name|SeekStatus
operator|.
name|END
condition|)
block|{
name|term
operator|.
name|copyBytes
argument_list|(
name|target
argument_list|)
expr_stmt|;
name|termExists
operator|=
literal|false
expr_stmt|;
if|if
condition|(
name|next
argument_list|()
operator|!=
literal|null
condition|)
block|{
comment|//if (DEBUG) {
comment|//System.out.println("  return NOT_FOUND term=" + term.utf8ToString() + " " + term);
comment|//}
return|return
name|SeekStatus
operator|.
name|NOT_FOUND
return|;
block|}
else|else
block|{
comment|//if (DEBUG) {
comment|//System.out.println("  return END");
comment|//}
return|return
name|SeekStatus
operator|.
name|END
return|;
block|}
block|}
else|else
block|{
return|return
name|result
return|;
block|}
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unused"
argument_list|)
DECL|method|printSeekState
specifier|private
name|void
name|printSeekState
parameter_list|(
name|PrintStream
name|out
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|currentFrame
operator|==
name|staticFrame
condition|)
block|{
name|out
operator|.
name|println
argument_list|(
literal|"  no prior seek"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|out
operator|.
name|println
argument_list|(
literal|"  prior seek state:"
argument_list|)
expr_stmt|;
name|int
name|ord
init|=
literal|0
decl_stmt|;
name|boolean
name|isSeekFrame
init|=
literal|true
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|SegmentTermsEnumFrame
name|f
init|=
name|getFrame
argument_list|(
name|ord
argument_list|)
decl_stmt|;
assert|assert
name|f
operator|!=
literal|null
assert|;
specifier|final
name|BytesRef
name|prefix
init|=
operator|new
name|BytesRef
argument_list|(
name|term
operator|.
name|bytes
argument_list|,
literal|0
argument_list|,
name|f
operator|.
name|prefix
argument_list|)
decl_stmt|;
if|if
condition|(
name|f
operator|.
name|nextEnt
operator|==
operator|-
literal|1
condition|)
block|{
name|out
operator|.
name|println
argument_list|(
literal|"    frame "
operator|+
operator|(
name|isSeekFrame
condition|?
literal|"(seek)"
else|:
literal|"(next)"
operator|)
operator|+
literal|" ord="
operator|+
name|ord
operator|+
literal|" fp="
operator|+
name|f
operator|.
name|fp
operator|+
operator|(
name|f
operator|.
name|isFloor
condition|?
operator|(
literal|" (fpOrig="
operator|+
name|f
operator|.
name|fpOrig
operator|+
literal|")"
operator|)
else|:
literal|""
operator|)
operator|+
literal|" prefixLen="
operator|+
name|f
operator|.
name|prefix
operator|+
literal|" prefix="
operator|+
name|prefix
operator|+
operator|(
name|f
operator|.
name|nextEnt
operator|==
operator|-
literal|1
condition|?
literal|""
else|:
operator|(
literal|" (of "
operator|+
name|f
operator|.
name|entCount
operator|+
literal|")"
operator|)
operator|)
operator|+
literal|" hasTerms="
operator|+
name|f
operator|.
name|hasTerms
operator|+
literal|" isFloor="
operator|+
name|f
operator|.
name|isFloor
operator|+
literal|" code="
operator|+
operator|(
operator|(
name|f
operator|.
name|fp
operator|<<
name|BlockTreeTermsWriter
operator|.
name|OUTPUT_FLAGS_NUM_BITS
operator|)
operator|+
operator|(
name|f
operator|.
name|hasTerms
condition|?
name|BlockTreeTermsWriter
operator|.
name|OUTPUT_FLAG_HAS_TERMS
else|:
literal|0
operator|)
operator|+
operator|(
name|f
operator|.
name|isFloor
condition|?
name|BlockTreeTermsWriter
operator|.
name|OUTPUT_FLAG_IS_FLOOR
else|:
literal|0
operator|)
operator|)
operator|+
literal|" isLastInFloor="
operator|+
name|f
operator|.
name|isLastInFloor
operator|+
literal|" mdUpto="
operator|+
name|f
operator|.
name|metaDataUpto
operator|+
literal|" tbOrd="
operator|+
name|f
operator|.
name|getTermBlockOrd
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|out
operator|.
name|println
argument_list|(
literal|"    frame "
operator|+
operator|(
name|isSeekFrame
condition|?
literal|"(seek, loaded)"
else|:
literal|"(next, loaded)"
operator|)
operator|+
literal|" ord="
operator|+
name|ord
operator|+
literal|" fp="
operator|+
name|f
operator|.
name|fp
operator|+
operator|(
name|f
operator|.
name|isFloor
condition|?
operator|(
literal|" (fpOrig="
operator|+
name|f
operator|.
name|fpOrig
operator|+
literal|")"
operator|)
else|:
literal|""
operator|)
operator|+
literal|" prefixLen="
operator|+
name|f
operator|.
name|prefix
operator|+
literal|" prefix="
operator|+
name|prefix
operator|+
literal|" nextEnt="
operator|+
name|f
operator|.
name|nextEnt
operator|+
operator|(
name|f
operator|.
name|nextEnt
operator|==
operator|-
literal|1
condition|?
literal|""
else|:
operator|(
literal|" (of "
operator|+
name|f
operator|.
name|entCount
operator|+
literal|")"
operator|)
operator|)
operator|+
literal|" hasTerms="
operator|+
name|f
operator|.
name|hasTerms
operator|+
literal|" isFloor="
operator|+
name|f
operator|.
name|isFloor
operator|+
literal|" code="
operator|+
operator|(
operator|(
name|f
operator|.
name|fp
operator|<<
name|BlockTreeTermsWriter
operator|.
name|OUTPUT_FLAGS_NUM_BITS
operator|)
operator|+
operator|(
name|f
operator|.
name|hasTerms
condition|?
name|BlockTreeTermsWriter
operator|.
name|OUTPUT_FLAG_HAS_TERMS
else|:
literal|0
operator|)
operator|+
operator|(
name|f
operator|.
name|isFloor
condition|?
name|BlockTreeTermsWriter
operator|.
name|OUTPUT_FLAG_IS_FLOOR
else|:
literal|0
operator|)
operator|)
operator|+
literal|" lastSubFP="
operator|+
name|f
operator|.
name|lastSubFP
operator|+
literal|" isLastInFloor="
operator|+
name|f
operator|.
name|isLastInFloor
operator|+
literal|" mdUpto="
operator|+
name|f
operator|.
name|metaDataUpto
operator|+
literal|" tbOrd="
operator|+
name|f
operator|.
name|getTermBlockOrd
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fr
operator|.
name|index
operator|!=
literal|null
condition|)
block|{
assert|assert
operator|!
name|isSeekFrame
operator|||
name|f
operator|.
name|arc
operator|!=
literal|null
operator|:
literal|"isSeekFrame="
operator|+
name|isSeekFrame
operator|+
literal|" f.arc="
operator|+
name|f
operator|.
name|arc
assert|;
if|if
condition|(
name|f
operator|.
name|prefix
operator|>
literal|0
operator|&&
name|isSeekFrame
operator|&&
name|f
operator|.
name|arc
operator|.
name|label
operator|!=
operator|(
name|term
operator|.
name|bytes
index|[
name|f
operator|.
name|prefix
operator|-
literal|1
index|]
operator|&
literal|0xFF
operator|)
condition|)
block|{
name|out
operator|.
name|println
argument_list|(
literal|"      broken seek state: arc.label="
operator|+
operator|(
name|char
operator|)
name|f
operator|.
name|arc
operator|.
name|label
operator|+
literal|" vs term byte="
operator|+
call|(
name|char
call|)
argument_list|(
name|term
operator|.
name|bytes
index|[
name|f
operator|.
name|prefix
operator|-
literal|1
index|]
operator|&
literal|0xFF
argument_list|)
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"seek state is broken"
argument_list|)
throw|;
block|}
name|BytesRef
name|output
init|=
name|Util
operator|.
name|get
argument_list|(
name|fr
operator|.
name|index
argument_list|,
name|prefix
argument_list|)
decl_stmt|;
if|if
condition|(
name|output
operator|==
literal|null
condition|)
block|{
name|out
operator|.
name|println
argument_list|(
literal|"      broken seek state: prefix is not final in index"
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"seek state is broken"
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
name|isSeekFrame
operator|&&
operator|!
name|f
operator|.
name|isFloor
condition|)
block|{
specifier|final
name|ByteArrayDataInput
name|reader
init|=
operator|new
name|ByteArrayDataInput
argument_list|(
name|output
operator|.
name|bytes
argument_list|,
name|output
operator|.
name|offset
argument_list|,
name|output
operator|.
name|length
argument_list|)
decl_stmt|;
specifier|final
name|long
name|codeOrig
init|=
name|reader
operator|.
name|readVLong
argument_list|()
decl_stmt|;
specifier|final
name|long
name|code
init|=
operator|(
name|f
operator|.
name|fp
operator|<<
name|BlockTreeTermsWriter
operator|.
name|OUTPUT_FLAGS_NUM_BITS
operator|)
operator||
operator|(
name|f
operator|.
name|hasTerms
condition|?
name|BlockTreeTermsWriter
operator|.
name|OUTPUT_FLAG_HAS_TERMS
else|:
literal|0
operator|)
operator||
operator|(
name|f
operator|.
name|isFloor
condition|?
name|BlockTreeTermsWriter
operator|.
name|OUTPUT_FLAG_IS_FLOOR
else|:
literal|0
operator|)
decl_stmt|;
if|if
condition|(
name|codeOrig
operator|!=
name|code
condition|)
block|{
name|out
operator|.
name|println
argument_list|(
literal|"      broken seek state: output code="
operator|+
name|codeOrig
operator|+
literal|" doesn't match frame code="
operator|+
name|code
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"seek state is broken"
argument_list|)
throw|;
block|}
block|}
block|}
if|if
condition|(
name|f
operator|==
name|currentFrame
condition|)
block|{
break|break;
block|}
if|if
condition|(
name|f
operator|.
name|prefix
operator|==
name|validIndexPrefix
condition|)
block|{
name|isSeekFrame
operator|=
literal|false
expr_stmt|;
block|}
name|ord
operator|++
expr_stmt|;
block|}
block|}
block|}
comment|/* Decodes only the term bytes of the next term.  If caller then asks for      metadata, ie docFreq, totalTermFreq or pulls a D/&PEnum, we then (lazily)      decode all metadata up to the current term. */
annotation|@
name|Override
DECL|method|next
specifier|public
name|BytesRef
name|next
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|in
operator|==
literal|null
condition|)
block|{
comment|// Fresh TermsEnum; seek to first term:
specifier|final
name|FST
operator|.
name|Arc
argument_list|<
name|BytesRef
argument_list|>
name|arc
decl_stmt|;
if|if
condition|(
name|fr
operator|.
name|index
operator|!=
literal|null
condition|)
block|{
name|arc
operator|=
name|fr
operator|.
name|index
operator|.
name|getFirstArc
argument_list|(
name|arcs
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|// Empty string prefix must have an output in the index!
assert|assert
name|arc
operator|.
name|isFinal
argument_list|()
assert|;
block|}
else|else
block|{
name|arc
operator|=
literal|null
expr_stmt|;
block|}
name|currentFrame
operator|=
name|pushFrame
argument_list|(
name|arc
argument_list|,
name|fr
operator|.
name|rootCode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|currentFrame
operator|.
name|loadBlock
argument_list|()
expr_stmt|;
block|}
name|targetBeforeCurrentLength
operator|=
name|currentFrame
operator|.
name|ord
expr_stmt|;
assert|assert
operator|!
name|eof
assert|;
comment|// if (DEBUG) {
comment|//   System.out.println("\nBTTR.next seg=" + fr.parent.segment + " term=" + brToString(term) + " termExists?=" + termExists + " field=" + fr.fieldInfo.name + " termBlockOrd=" + currentFrame.state.termBlockOrd + " validIndexPrefix=" + validIndexPrefix);
comment|//   printSeekState(System.out);
comment|// }
if|if
condition|(
name|currentFrame
operator|==
name|staticFrame
condition|)
block|{
comment|// If seek was previously called and the term was
comment|// cached, or seek(TermState) was called, usually
comment|// caller is just going to pull a D/&PEnum or get
comment|// docFreq, etc.  But, if they then call next(),
comment|// this method catches up all internal state so next()
comment|// works properly:
comment|//if (DEBUG) System.out.println("  re-seek to pending term=" + term.utf8ToString() + " " + term);
specifier|final
name|boolean
name|result
init|=
name|seekExact
argument_list|(
name|term
argument_list|)
decl_stmt|;
assert|assert
name|result
assert|;
block|}
comment|// Pop finished blocks
while|while
condition|(
name|currentFrame
operator|.
name|nextEnt
operator|==
name|currentFrame
operator|.
name|entCount
condition|)
block|{
if|if
condition|(
operator|!
name|currentFrame
operator|.
name|isLastInFloor
condition|)
block|{
name|currentFrame
operator|.
name|loadNextFloorBlock
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|//if (DEBUG) System.out.println("  pop frame");
if|if
condition|(
name|currentFrame
operator|.
name|ord
operator|==
literal|0
condition|)
block|{
comment|//if (DEBUG) System.out.println("  return null");
assert|assert
name|setEOF
argument_list|()
assert|;
name|term
operator|.
name|length
operator|=
literal|0
expr_stmt|;
name|validIndexPrefix
operator|=
literal|0
expr_stmt|;
name|currentFrame
operator|.
name|rewind
argument_list|()
expr_stmt|;
name|termExists
operator|=
literal|false
expr_stmt|;
return|return
literal|null
return|;
block|}
specifier|final
name|long
name|lastFP
init|=
name|currentFrame
operator|.
name|fpOrig
decl_stmt|;
name|currentFrame
operator|=
name|stack
index|[
name|currentFrame
operator|.
name|ord
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|currentFrame
operator|.
name|nextEnt
operator|==
operator|-
literal|1
operator|||
name|currentFrame
operator|.
name|lastSubFP
operator|!=
name|lastFP
condition|)
block|{
comment|// We popped into a frame that's not loaded
comment|// yet or not scan'd to the right entry
name|currentFrame
operator|.
name|scanToFloorFrame
argument_list|(
name|term
argument_list|)
expr_stmt|;
name|currentFrame
operator|.
name|loadBlock
argument_list|()
expr_stmt|;
name|currentFrame
operator|.
name|scanToSubBlock
argument_list|(
name|lastFP
argument_list|)
expr_stmt|;
block|}
comment|// Note that the seek state (last seek) has been
comment|// invalidated beyond this depth
name|validIndexPrefix
operator|=
name|Math
operator|.
name|min
argument_list|(
name|validIndexPrefix
argument_list|,
name|currentFrame
operator|.
name|prefix
argument_list|)
expr_stmt|;
comment|//if (DEBUG) {
comment|//System.out.println("  reset validIndexPrefix=" + validIndexPrefix);
comment|//}
block|}
block|}
while|while
condition|(
literal|true
condition|)
block|{
if|if
condition|(
name|currentFrame
operator|.
name|next
argument_list|()
condition|)
block|{
comment|// Push to new block:
comment|//if (DEBUG) System.out.println("  push frame");
name|currentFrame
operator|=
name|pushFrame
argument_list|(
literal|null
argument_list|,
name|currentFrame
operator|.
name|lastSubFP
argument_list|,
name|term
operator|.
name|length
argument_list|)
expr_stmt|;
comment|// This is a "next" frame -- even if it's
comment|// floor'd we must pretend it isn't so we don't
comment|// try to scan to the right floor frame:
name|currentFrame
operator|.
name|isFloor
operator|=
literal|false
expr_stmt|;
comment|//currentFrame.hasTerms = true;
name|currentFrame
operator|.
name|loadBlock
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|//if (DEBUG) System.out.println("  return term=" + term.utf8ToString() + " " + term + " currentFrame.ord=" + currentFrame.ord);
return|return
name|term
return|;
block|}
block|}
block|}
annotation|@
name|Override
DECL|method|term
specifier|public
name|BytesRef
name|term
parameter_list|()
block|{
assert|assert
operator|!
name|eof
assert|;
return|return
name|term
return|;
block|}
annotation|@
name|Override
DECL|method|docFreq
specifier|public
name|int
name|docFreq
parameter_list|()
throws|throws
name|IOException
block|{
assert|assert
operator|!
name|eof
assert|;
comment|//if (DEBUG) System.out.println("BTR.docFreq");
name|currentFrame
operator|.
name|decodeMetaData
argument_list|()
expr_stmt|;
comment|//if (DEBUG) System.out.println("  return " + currentFrame.state.docFreq);
return|return
name|currentFrame
operator|.
name|state
operator|.
name|docFreq
return|;
block|}
annotation|@
name|Override
DECL|method|totalTermFreq
specifier|public
name|long
name|totalTermFreq
parameter_list|()
throws|throws
name|IOException
block|{
assert|assert
operator|!
name|eof
assert|;
name|currentFrame
operator|.
name|decodeMetaData
argument_list|()
expr_stmt|;
return|return
name|currentFrame
operator|.
name|state
operator|.
name|totalTermFreq
return|;
block|}
annotation|@
name|Override
DECL|method|docs
specifier|public
name|DocsEnum
name|docs
parameter_list|(
name|Bits
name|skipDocs
parameter_list|,
name|DocsEnum
name|reuse
parameter_list|,
name|int
name|flags
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
operator|!
name|eof
assert|;
comment|//if (DEBUG) {
comment|//System.out.println("BTTR.docs seg=" + segment);
comment|//}
name|currentFrame
operator|.
name|decodeMetaData
argument_list|()
expr_stmt|;
comment|//if (DEBUG) {
comment|//System.out.println("  state=" + currentFrame.state);
comment|//}
return|return
name|fr
operator|.
name|parent
operator|.
name|postingsReader
operator|.
name|docs
argument_list|(
name|fr
operator|.
name|fieldInfo
argument_list|,
name|currentFrame
operator|.
name|state
argument_list|,
name|skipDocs
argument_list|,
name|reuse
argument_list|,
name|flags
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|docsAndPositions
specifier|public
name|DocsAndPositionsEnum
name|docsAndPositions
parameter_list|(
name|Bits
name|skipDocs
parameter_list|,
name|DocsAndPositionsEnum
name|reuse
parameter_list|,
name|int
name|flags
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|fr
operator|.
name|fieldInfo
operator|.
name|getIndexOptions
argument_list|()
operator|.
name|compareTo
argument_list|(
name|IndexOptions
operator|.
name|DOCS_AND_FREQS_AND_POSITIONS
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|// Positions were not indexed:
return|return
literal|null
return|;
block|}
assert|assert
operator|!
name|eof
assert|;
name|currentFrame
operator|.
name|decodeMetaData
argument_list|()
expr_stmt|;
return|return
name|fr
operator|.
name|parent
operator|.
name|postingsReader
operator|.
name|docsAndPositions
argument_list|(
name|fr
operator|.
name|fieldInfo
argument_list|,
name|currentFrame
operator|.
name|state
argument_list|,
name|skipDocs
argument_list|,
name|reuse
argument_list|,
name|flags
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|seekExact
specifier|public
name|void
name|seekExact
parameter_list|(
name|BytesRef
name|target
parameter_list|,
name|TermState
name|otherState
parameter_list|)
block|{
comment|// if (DEBUG) {
comment|//   System.out.println("BTTR.seekExact termState seg=" + segment + " target=" + target.utf8ToString() + " " + target + " state=" + otherState);
comment|// }
assert|assert
name|clearEOF
argument_list|()
assert|;
if|if
condition|(
name|target
operator|.
name|compareTo
argument_list|(
name|term
argument_list|)
operator|!=
literal|0
operator|||
operator|!
name|termExists
condition|)
block|{
assert|assert
name|otherState
operator|!=
literal|null
operator|&&
name|otherState
operator|instanceof
name|BlockTermState
assert|;
name|currentFrame
operator|=
name|staticFrame
expr_stmt|;
name|currentFrame
operator|.
name|state
operator|.
name|copyFrom
argument_list|(
name|otherState
argument_list|)
expr_stmt|;
name|term
operator|.
name|copyBytes
argument_list|(
name|target
argument_list|)
expr_stmt|;
name|currentFrame
operator|.
name|metaDataUpto
operator|=
name|currentFrame
operator|.
name|getTermBlockOrd
argument_list|()
expr_stmt|;
assert|assert
name|currentFrame
operator|.
name|metaDataUpto
operator|>
literal|0
assert|;
name|validIndexPrefix
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|// if (DEBUG) {
comment|//   System.out.println("  skip seek: already on target state=" + currentFrame.state);
comment|// }
block|}
block|}
annotation|@
name|Override
DECL|method|termState
specifier|public
name|TermState
name|termState
parameter_list|()
throws|throws
name|IOException
block|{
assert|assert
operator|!
name|eof
assert|;
name|currentFrame
operator|.
name|decodeMetaData
argument_list|()
expr_stmt|;
name|TermState
name|ts
init|=
name|currentFrame
operator|.
name|state
operator|.
name|clone
argument_list|()
decl_stmt|;
comment|//if (DEBUG) System.out.println("BTTR.termState seg=" + segment + " state=" + ts);
return|return
name|ts
return|;
block|}
annotation|@
name|Override
DECL|method|seekExact
specifier|public
name|void
name|seekExact
parameter_list|(
name|long
name|ord
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
DECL|method|ord
specifier|public
name|long
name|ord
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
block|}
end_class
end_unit
