begin_unit
begin_package
DECL|package|org.apache.lucene.codecs.blocktree
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|codecs
operator|.
name|blocktree
package|;
end_package
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|PrintStream
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|codecs
operator|.
name|BlockTermState
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|DocsAndPositionsEnum
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|DocsEnum
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|FieldInfo
operator|.
name|IndexOptions
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|TermState
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|TermsEnum
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|ByteArrayDataInput
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|IndexInput
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|ArrayUtil
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|Bits
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|BytesRef
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|RamUsageEstimator
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|fst
operator|.
name|FST
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|fst
operator|.
name|Util
import|;
end_import
begin_comment
comment|/** Iterates through terms in this field */
end_comment
begin_class
DECL|class|SegmentTermsEnum
specifier|final
class|class
name|SegmentTermsEnum
extends|extends
name|TermsEnum
block|{
DECL|field|in
specifier|private
name|IndexInput
name|in
decl_stmt|;
DECL|field|stack
specifier|private
name|Frame
index|[]
name|stack
decl_stmt|;
DECL|field|staticFrame
specifier|private
specifier|final
name|Frame
name|staticFrame
decl_stmt|;
DECL|field|currentFrame
specifier|private
name|Frame
name|currentFrame
decl_stmt|;
DECL|field|termExists
specifier|private
name|boolean
name|termExists
decl_stmt|;
DECL|field|fr
specifier|private
specifier|final
name|FieldReader
name|fr
decl_stmt|;
comment|// nocommit make this public "for casting" and add a getVersion method?
DECL|field|targetBeforeCurrentLength
specifier|private
name|int
name|targetBeforeCurrentLength
decl_stmt|;
DECL|field|scratchReader
specifier|private
specifier|final
name|ByteArrayDataInput
name|scratchReader
init|=
operator|new
name|ByteArrayDataInput
argument_list|()
decl_stmt|;
comment|// What prefix of the current term was present in the index:
DECL|field|validIndexPrefix
specifier|private
name|int
name|validIndexPrefix
decl_stmt|;
comment|// assert only:
DECL|field|eof
specifier|private
name|boolean
name|eof
decl_stmt|;
DECL|field|term
specifier|final
name|BytesRef
name|term
init|=
operator|new
name|BytesRef
argument_list|()
decl_stmt|;
DECL|field|fstReader
specifier|private
specifier|final
name|FST
operator|.
name|BytesReader
name|fstReader
decl_stmt|;
DECL|field|arcs
annotation|@
name|SuppressWarnings
argument_list|(
block|{
literal|"rawtypes"
block|,
literal|"unchecked"
block|}
argument_list|)
specifier|private
name|FST
operator|.
name|Arc
argument_list|<
name|BytesRef
argument_list|>
index|[]
name|arcs
init|=
operator|new
name|FST
operator|.
name|Arc
index|[
literal|1
index|]
decl_stmt|;
DECL|method|SegmentTermsEnum
specifier|public
name|SegmentTermsEnum
parameter_list|(
name|FieldReader
name|fr
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|fr
operator|=
name|fr
expr_stmt|;
comment|//if (DEBUG) System.out.println("BTTR.init seg=" + segment);
name|stack
operator|=
operator|new
name|Frame
index|[
literal|0
index|]
expr_stmt|;
comment|// Used to hold seek by TermState, or cached seek
name|staticFrame
operator|=
operator|new
name|Frame
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|fr
operator|.
name|index
operator|==
literal|null
condition|)
block|{
name|fstReader
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
name|fstReader
operator|=
name|fr
operator|.
name|index
operator|.
name|getBytesReader
argument_list|()
expr_stmt|;
block|}
comment|// Init w/ root block; don't use index since it may
comment|// not (and need not) have been loaded
for|for
control|(
name|int
name|arcIdx
init|=
literal|0
init|;
name|arcIdx
operator|<
name|arcs
operator|.
name|length
condition|;
name|arcIdx
operator|++
control|)
block|{
name|arcs
index|[
name|arcIdx
index|]
operator|=
operator|new
name|FST
operator|.
name|Arc
argument_list|<>
argument_list|()
expr_stmt|;
block|}
name|currentFrame
operator|=
name|staticFrame
expr_stmt|;
specifier|final
name|FST
operator|.
name|Arc
argument_list|<
name|BytesRef
argument_list|>
name|arc
decl_stmt|;
if|if
condition|(
name|fr
operator|.
name|index
operator|!=
literal|null
condition|)
block|{
name|arc
operator|=
name|fr
operator|.
name|index
operator|.
name|getFirstArc
argument_list|(
name|arcs
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|// Empty string prefix must have an output in the index!
assert|assert
name|arc
operator|.
name|isFinal
argument_list|()
assert|;
block|}
else|else
block|{
name|arc
operator|=
literal|null
expr_stmt|;
block|}
name|currentFrame
operator|=
name|staticFrame
expr_stmt|;
comment|//currentFrame = pushFrame(arc, rootCode, 0);
comment|//currentFrame.loadBlock();
name|validIndexPrefix
operator|=
literal|0
expr_stmt|;
comment|// if (DEBUG) {
comment|//   System.out.println("init frame state " + currentFrame.ord);
comment|//   printSeekState();
comment|// }
comment|//System.out.println();
comment|// computeBlockStats().print(System.out);
block|}
comment|// Not private to avoid synthetic access$NNN methods
DECL|method|initIndexInput
name|void
name|initIndexInput
parameter_list|()
block|{
if|if
condition|(
name|this
operator|.
name|in
operator|==
literal|null
condition|)
block|{
name|this
operator|.
name|in
operator|=
name|fr
operator|.
name|parent
operator|.
name|in
operator|.
name|clone
argument_list|()
expr_stmt|;
block|}
block|}
comment|/** Runs next() through the entire terms dict,    *  computing aggregate statistics. */
DECL|method|computeBlockStats
specifier|public
name|Stats
name|computeBlockStats
parameter_list|()
throws|throws
name|IOException
block|{
name|Stats
name|stats
init|=
operator|new
name|Stats
argument_list|(
name|fr
operator|.
name|parent
operator|.
name|segment
argument_list|,
name|fr
operator|.
name|fieldInfo
operator|.
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|fr
operator|.
name|index
operator|!=
literal|null
condition|)
block|{
name|stats
operator|.
name|indexNodeCount
operator|=
name|fr
operator|.
name|index
operator|.
name|getNodeCount
argument_list|()
expr_stmt|;
name|stats
operator|.
name|indexArcCount
operator|=
name|fr
operator|.
name|index
operator|.
name|getArcCount
argument_list|()
expr_stmt|;
name|stats
operator|.
name|indexNumBytes
operator|=
name|fr
operator|.
name|index
operator|.
name|sizeInBytes
argument_list|()
expr_stmt|;
block|}
name|currentFrame
operator|=
name|staticFrame
expr_stmt|;
name|FST
operator|.
name|Arc
argument_list|<
name|BytesRef
argument_list|>
name|arc
decl_stmt|;
if|if
condition|(
name|fr
operator|.
name|index
operator|!=
literal|null
condition|)
block|{
name|arc
operator|=
name|fr
operator|.
name|index
operator|.
name|getFirstArc
argument_list|(
name|arcs
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|// Empty string prefix must have an output in the index!
assert|assert
name|arc
operator|.
name|isFinal
argument_list|()
assert|;
block|}
else|else
block|{
name|arc
operator|=
literal|null
expr_stmt|;
block|}
comment|// Empty string prefix must have an output in the
comment|// index!
name|currentFrame
operator|=
name|pushFrame
argument_list|(
name|arc
argument_list|,
name|fr
operator|.
name|rootCode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|currentFrame
operator|.
name|fpOrig
operator|=
name|currentFrame
operator|.
name|fp
expr_stmt|;
name|currentFrame
operator|.
name|loadBlock
argument_list|()
expr_stmt|;
name|validIndexPrefix
operator|=
literal|0
expr_stmt|;
name|stats
operator|.
name|startBlock
argument_list|(
name|currentFrame
argument_list|,
operator|!
name|currentFrame
operator|.
name|isLastInFloor
argument_list|)
expr_stmt|;
name|allTerms
label|:
while|while
condition|(
literal|true
condition|)
block|{
comment|// Pop finished blocks
while|while
condition|(
name|currentFrame
operator|.
name|nextEnt
operator|==
name|currentFrame
operator|.
name|entCount
condition|)
block|{
name|stats
operator|.
name|endBlock
argument_list|(
name|currentFrame
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|currentFrame
operator|.
name|isLastInFloor
condition|)
block|{
name|currentFrame
operator|.
name|loadNextFloorBlock
argument_list|()
expr_stmt|;
name|stats
operator|.
name|startBlock
argument_list|(
name|currentFrame
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|currentFrame
operator|.
name|ord
operator|==
literal|0
condition|)
block|{
break|break
name|allTerms
break|;
block|}
specifier|final
name|long
name|lastFP
init|=
name|currentFrame
operator|.
name|fpOrig
decl_stmt|;
name|currentFrame
operator|=
name|stack
index|[
name|currentFrame
operator|.
name|ord
operator|-
literal|1
index|]
expr_stmt|;
assert|assert
name|lastFP
operator|==
name|currentFrame
operator|.
name|lastSubFP
assert|;
comment|// if (DEBUG) {
comment|//   System.out.println("  reset validIndexPrefix=" + validIndexPrefix);
comment|// }
block|}
block|}
while|while
condition|(
literal|true
condition|)
block|{
if|if
condition|(
name|currentFrame
operator|.
name|next
argument_list|()
condition|)
block|{
comment|// Push to new block:
name|currentFrame
operator|=
name|pushFrame
argument_list|(
literal|null
argument_list|,
name|currentFrame
operator|.
name|lastSubFP
argument_list|,
name|term
operator|.
name|length
argument_list|)
expr_stmt|;
name|currentFrame
operator|.
name|fpOrig
operator|=
name|currentFrame
operator|.
name|fp
expr_stmt|;
comment|// This is a "next" frame -- even if it's
comment|// floor'd we must pretend it isn't so we don't
comment|// try to scan to the right floor frame:
name|currentFrame
operator|.
name|isFloor
operator|=
literal|false
expr_stmt|;
comment|//currentFrame.hasTerms = true;
name|currentFrame
operator|.
name|loadBlock
argument_list|()
expr_stmt|;
name|stats
operator|.
name|startBlock
argument_list|(
name|currentFrame
argument_list|,
operator|!
name|currentFrame
operator|.
name|isLastInFloor
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|stats
operator|.
name|term
argument_list|(
name|term
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
name|stats
operator|.
name|finish
argument_list|()
expr_stmt|;
comment|// Put root frame back:
name|currentFrame
operator|=
name|staticFrame
expr_stmt|;
if|if
condition|(
name|fr
operator|.
name|index
operator|!=
literal|null
condition|)
block|{
name|arc
operator|=
name|fr
operator|.
name|index
operator|.
name|getFirstArc
argument_list|(
name|arcs
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|// Empty string prefix must have an output in the index!
assert|assert
name|arc
operator|.
name|isFinal
argument_list|()
assert|;
block|}
else|else
block|{
name|arc
operator|=
literal|null
expr_stmt|;
block|}
name|currentFrame
operator|=
name|pushFrame
argument_list|(
name|arc
argument_list|,
name|fr
operator|.
name|rootCode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|currentFrame
operator|.
name|rewind
argument_list|()
expr_stmt|;
name|currentFrame
operator|.
name|loadBlock
argument_list|()
expr_stmt|;
name|validIndexPrefix
operator|=
literal|0
expr_stmt|;
name|term
operator|.
name|length
operator|=
literal|0
expr_stmt|;
return|return
name|stats
return|;
block|}
DECL|method|getFrame
specifier|private
name|Frame
name|getFrame
parameter_list|(
name|int
name|ord
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|ord
operator|>=
name|stack
operator|.
name|length
condition|)
block|{
specifier|final
name|Frame
index|[]
name|next
init|=
operator|new
name|Frame
index|[
name|ArrayUtil
operator|.
name|oversize
argument_list|(
literal|1
operator|+
name|ord
argument_list|,
name|RamUsageEstimator
operator|.
name|NUM_BYTES_OBJECT_REF
argument_list|)
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|stack
argument_list|,
literal|0
argument_list|,
name|next
argument_list|,
literal|0
argument_list|,
name|stack
operator|.
name|length
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|stackOrd
init|=
name|stack
operator|.
name|length
init|;
name|stackOrd
operator|<
name|next
operator|.
name|length
condition|;
name|stackOrd
operator|++
control|)
block|{
name|next
index|[
name|stackOrd
index|]
operator|=
operator|new
name|Frame
argument_list|(
name|stackOrd
argument_list|)
expr_stmt|;
block|}
name|stack
operator|=
name|next
expr_stmt|;
block|}
assert|assert
name|stack
index|[
name|ord
index|]
operator|.
name|ord
operator|==
name|ord
assert|;
return|return
name|stack
index|[
name|ord
index|]
return|;
block|}
DECL|method|getArc
specifier|private
name|FST
operator|.
name|Arc
argument_list|<
name|BytesRef
argument_list|>
name|getArc
parameter_list|(
name|int
name|ord
parameter_list|)
block|{
if|if
condition|(
name|ord
operator|>=
name|arcs
operator|.
name|length
condition|)
block|{
annotation|@
name|SuppressWarnings
argument_list|(
block|{
literal|"rawtypes"
block|,
literal|"unchecked"
block|}
argument_list|)
specifier|final
name|FST
operator|.
name|Arc
argument_list|<
name|BytesRef
argument_list|>
index|[]
name|next
init|=
operator|new
name|FST
operator|.
name|Arc
index|[
name|ArrayUtil
operator|.
name|oversize
argument_list|(
literal|1
operator|+
name|ord
argument_list|,
name|RamUsageEstimator
operator|.
name|NUM_BYTES_OBJECT_REF
argument_list|)
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|arcs
argument_list|,
literal|0
argument_list|,
name|next
argument_list|,
literal|0
argument_list|,
name|arcs
operator|.
name|length
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|arcOrd
init|=
name|arcs
operator|.
name|length
init|;
name|arcOrd
operator|<
name|next
operator|.
name|length
condition|;
name|arcOrd
operator|++
control|)
block|{
name|next
index|[
name|arcOrd
index|]
operator|=
operator|new
name|FST
operator|.
name|Arc
argument_list|<>
argument_list|()
expr_stmt|;
block|}
name|arcs
operator|=
name|next
expr_stmt|;
block|}
return|return
name|arcs
index|[
name|ord
index|]
return|;
block|}
comment|// Pushes a frame we seek'd to
DECL|method|pushFrame
name|Frame
name|pushFrame
parameter_list|(
name|FST
operator|.
name|Arc
argument_list|<
name|BytesRef
argument_list|>
name|arc
parameter_list|,
name|BytesRef
name|frameData
parameter_list|,
name|int
name|length
parameter_list|)
throws|throws
name|IOException
block|{
name|scratchReader
operator|.
name|reset
argument_list|(
name|frameData
operator|.
name|bytes
argument_list|,
name|frameData
operator|.
name|offset
argument_list|,
name|frameData
operator|.
name|length
argument_list|)
expr_stmt|;
specifier|final
name|long
name|code
init|=
name|scratchReader
operator|.
name|readVLong
argument_list|()
decl_stmt|;
specifier|final
name|long
name|fpSeek
init|=
name|code
operator|>>>
name|BlockTreeTermsWriter
operator|.
name|OUTPUT_FLAGS_NUM_BITS
decl_stmt|;
specifier|final
name|Frame
name|f
init|=
name|getFrame
argument_list|(
literal|1
operator|+
name|currentFrame
operator|.
name|ord
argument_list|)
decl_stmt|;
name|f
operator|.
name|hasTerms
operator|=
operator|(
name|code
operator|&
name|BlockTreeTermsWriter
operator|.
name|OUTPUT_FLAG_HAS_TERMS
operator|)
operator|!=
literal|0
expr_stmt|;
name|f
operator|.
name|hasTermsOrig
operator|=
name|f
operator|.
name|hasTerms
expr_stmt|;
name|f
operator|.
name|isFloor
operator|=
operator|(
name|code
operator|&
name|BlockTreeTermsWriter
operator|.
name|OUTPUT_FLAG_IS_FLOOR
operator|)
operator|!=
literal|0
expr_stmt|;
if|if
condition|(
name|f
operator|.
name|isFloor
condition|)
block|{
name|f
operator|.
name|setFloorData
argument_list|(
name|scratchReader
argument_list|,
name|frameData
argument_list|)
expr_stmt|;
block|}
name|pushFrame
argument_list|(
name|arc
argument_list|,
name|fpSeek
argument_list|,
name|length
argument_list|)
expr_stmt|;
return|return
name|f
return|;
block|}
comment|// Pushes next'd frame or seek'd frame; we later
comment|// lazy-load the frame only when needed
DECL|method|pushFrame
name|Frame
name|pushFrame
parameter_list|(
name|FST
operator|.
name|Arc
argument_list|<
name|BytesRef
argument_list|>
name|arc
parameter_list|,
name|long
name|fp
parameter_list|,
name|int
name|length
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|Frame
name|f
init|=
name|getFrame
argument_list|(
literal|1
operator|+
name|currentFrame
operator|.
name|ord
argument_list|)
decl_stmt|;
name|f
operator|.
name|arc
operator|=
name|arc
expr_stmt|;
if|if
condition|(
name|f
operator|.
name|fpOrig
operator|==
name|fp
operator|&&
name|f
operator|.
name|nextEnt
operator|!=
operator|-
literal|1
condition|)
block|{
comment|//if (DEBUG) System.out.println("      push reused frame ord=" + f.ord + " fp=" + f.fp + " isFloor?=" + f.isFloor + " hasTerms=" + f.hasTerms + " pref=" + term + " nextEnt=" + f.nextEnt + " targetBeforeCurrentLength=" + targetBeforeCurrentLength + " term.length=" + term.length + " vs prefix=" + f.prefix);
if|if
condition|(
name|f
operator|.
name|prefix
operator|>
name|targetBeforeCurrentLength
condition|)
block|{
name|f
operator|.
name|rewind
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|// if (DEBUG) {
comment|//   System.out.println("        skip rewind!");
comment|// }
block|}
assert|assert
name|length
operator|==
name|f
operator|.
name|prefix
assert|;
block|}
else|else
block|{
name|f
operator|.
name|nextEnt
operator|=
operator|-
literal|1
expr_stmt|;
name|f
operator|.
name|prefix
operator|=
name|length
expr_stmt|;
name|f
operator|.
name|state
operator|.
name|termBlockOrd
operator|=
literal|0
expr_stmt|;
name|f
operator|.
name|fpOrig
operator|=
name|f
operator|.
name|fp
operator|=
name|fp
expr_stmt|;
name|f
operator|.
name|lastSubFP
operator|=
operator|-
literal|1
expr_stmt|;
comment|// if (DEBUG) {
comment|//   final int sav = term.length;
comment|//   term.length = length;
comment|//   System.out.println("      push new frame ord=" + f.ord + " fp=" + f.fp + " hasTerms=" + f.hasTerms + " isFloor=" + f.isFloor + " pref=" + brToString(term));
comment|//   term.length = sav;
comment|// }
block|}
return|return
name|f
return|;
block|}
comment|// asserts only
DECL|method|clearEOF
specifier|private
name|boolean
name|clearEOF
parameter_list|()
block|{
name|eof
operator|=
literal|false
expr_stmt|;
return|return
literal|true
return|;
block|}
comment|// asserts only
DECL|method|setEOF
specifier|private
name|boolean
name|setEOF
parameter_list|()
block|{
name|eof
operator|=
literal|true
expr_stmt|;
return|return
literal|true
return|;
block|}
comment|// nocommit we need a seekExact(BytesRef target, long minVersion) API?
annotation|@
name|Override
DECL|method|seekExact
specifier|public
name|boolean
name|seekExact
parameter_list|(
specifier|final
name|BytesRef
name|target
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|fr
operator|.
name|index
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"terms index was not loaded"
argument_list|)
throw|;
block|}
if|if
condition|(
name|term
operator|.
name|bytes
operator|.
name|length
operator|<=
name|target
operator|.
name|length
condition|)
block|{
name|term
operator|.
name|bytes
operator|=
name|ArrayUtil
operator|.
name|grow
argument_list|(
name|term
operator|.
name|bytes
argument_list|,
literal|1
operator|+
name|target
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
assert|assert
name|clearEOF
argument_list|()
assert|;
comment|// if (DEBUG) {
comment|//   System.out.println("\nBTTR.seekExact seg=" + segment + " target=" + fieldInfo.name + ":" + brToString(target) + " current=" + brToString(term) + " (exists?=" + termExists + ") validIndexPrefix=" + validIndexPrefix);
comment|//   printSeekState();
comment|// }
name|FST
operator|.
name|Arc
argument_list|<
name|BytesRef
argument_list|>
name|arc
decl_stmt|;
name|int
name|targetUpto
decl_stmt|;
name|BytesRef
name|output
decl_stmt|;
name|targetBeforeCurrentLength
operator|=
name|currentFrame
operator|.
name|ord
expr_stmt|;
if|if
condition|(
name|currentFrame
operator|!=
name|staticFrame
condition|)
block|{
comment|// We are already seek'd; find the common
comment|// prefix of new seek term vs current term and
comment|// re-use the corresponding seek state.  For
comment|// example, if app first seeks to foobar, then
comment|// seeks to foobaz, we can re-use the seek state
comment|// for the first 5 bytes.
comment|// if (DEBUG) {
comment|//   System.out.println("  re-use current seek state validIndexPrefix=" + validIndexPrefix);
comment|// }
name|arc
operator|=
name|arcs
index|[
literal|0
index|]
expr_stmt|;
assert|assert
name|arc
operator|.
name|isFinal
argument_list|()
assert|;
name|output
operator|=
name|arc
operator|.
name|output
expr_stmt|;
name|targetUpto
operator|=
literal|0
expr_stmt|;
name|Frame
name|lastFrame
init|=
name|stack
index|[
literal|0
index|]
decl_stmt|;
assert|assert
name|validIndexPrefix
operator|<=
name|term
operator|.
name|length
assert|;
specifier|final
name|int
name|targetLimit
init|=
name|Math
operator|.
name|min
argument_list|(
name|target
operator|.
name|length
argument_list|,
name|validIndexPrefix
argument_list|)
decl_stmt|;
name|int
name|cmp
init|=
literal|0
decl_stmt|;
comment|// TODO: reverse vLong byte order for better FST
comment|// prefix output sharing
comment|// First compare up to valid seek frames:
while|while
condition|(
name|targetUpto
operator|<
name|targetLimit
condition|)
block|{
name|cmp
operator|=
operator|(
name|term
operator|.
name|bytes
index|[
name|targetUpto
index|]
operator|&
literal|0xFF
operator|)
operator|-
operator|(
name|target
operator|.
name|bytes
index|[
name|target
operator|.
name|offset
operator|+
name|targetUpto
index|]
operator|&
literal|0xFF
operator|)
expr_stmt|;
comment|// if (DEBUG) {
comment|//   System.out.println("    cycle targetUpto=" + targetUpto + " (vs limit=" + targetLimit + ") cmp=" + cmp + " (targetLabel=" + (char) (target.bytes[target.offset + targetUpto]) + " vs termLabel=" + (char) (term.bytes[targetUpto]) + ")"   + " arc.output=" + arc.output + " output=" + output);
comment|// }
if|if
condition|(
name|cmp
operator|!=
literal|0
condition|)
block|{
break|break;
block|}
name|arc
operator|=
name|arcs
index|[
literal|1
operator|+
name|targetUpto
index|]
expr_stmt|;
comment|//if (arc.label != (target.bytes[target.offset + targetUpto]& 0xFF)) {
comment|//System.out.println("FAIL: arc.label=" + (char) arc.label + " targetLabel=" + (char) (target.bytes[target.offset + targetUpto]& 0xFF));
comment|//}
assert|assert
name|arc
operator|.
name|label
operator|==
operator|(
name|target
operator|.
name|bytes
index|[
name|target
operator|.
name|offset
operator|+
name|targetUpto
index|]
operator|&
literal|0xFF
operator|)
operator|:
literal|"arc.label="
operator|+
operator|(
name|char
operator|)
name|arc
operator|.
name|label
operator|+
literal|" targetLabel="
operator|+
call|(
name|char
call|)
argument_list|(
name|target
operator|.
name|bytes
index|[
name|target
operator|.
name|offset
operator|+
name|targetUpto
index|]
operator|&
literal|0xFF
argument_list|)
assert|;
if|if
condition|(
name|arc
operator|.
name|output
operator|!=
name|fr
operator|.
name|parent
operator|.
name|NO_OUTPUT
condition|)
block|{
name|output
operator|=
name|fr
operator|.
name|parent
operator|.
name|fstOutputs
operator|.
name|add
argument_list|(
name|output
argument_list|,
name|arc
operator|.
name|output
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|arc
operator|.
name|isFinal
argument_list|()
condition|)
block|{
name|lastFrame
operator|=
name|stack
index|[
literal|1
operator|+
name|lastFrame
operator|.
name|ord
index|]
expr_stmt|;
block|}
name|targetUpto
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|cmp
operator|==
literal|0
condition|)
block|{
specifier|final
name|int
name|targetUptoMid
init|=
name|targetUpto
decl_stmt|;
comment|// Second compare the rest of the term, but
comment|// don't save arc/output/frame; we only do this
comment|// to find out if the target term is before,
comment|// equal or after the current term
specifier|final
name|int
name|targetLimit2
init|=
name|Math
operator|.
name|min
argument_list|(
name|target
operator|.
name|length
argument_list|,
name|term
operator|.
name|length
argument_list|)
decl_stmt|;
while|while
condition|(
name|targetUpto
operator|<
name|targetLimit2
condition|)
block|{
name|cmp
operator|=
operator|(
name|term
operator|.
name|bytes
index|[
name|targetUpto
index|]
operator|&
literal|0xFF
operator|)
operator|-
operator|(
name|target
operator|.
name|bytes
index|[
name|target
operator|.
name|offset
operator|+
name|targetUpto
index|]
operator|&
literal|0xFF
operator|)
expr_stmt|;
comment|// if (DEBUG) {
comment|//   System.out.println("    cycle2 targetUpto=" + targetUpto + " (vs limit=" + targetLimit + ") cmp=" + cmp + " (targetLabel=" + (char) (target.bytes[target.offset + targetUpto]) + " vs termLabel=" + (char) (term.bytes[targetUpto]) + ")");
comment|// }
if|if
condition|(
name|cmp
operator|!=
literal|0
condition|)
block|{
break|break;
block|}
name|targetUpto
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|cmp
operator|==
literal|0
condition|)
block|{
name|cmp
operator|=
name|term
operator|.
name|length
operator|-
name|target
operator|.
name|length
expr_stmt|;
block|}
name|targetUpto
operator|=
name|targetUptoMid
expr_stmt|;
block|}
if|if
condition|(
name|cmp
operator|<
literal|0
condition|)
block|{
comment|// Common case: target term is after current
comment|// term, ie, app is seeking multiple terms
comment|// in sorted order
comment|// if (DEBUG) {
comment|//   System.out.println("  target is after current (shares prefixLen=" + targetUpto + "); frame.ord=" + lastFrame.ord);
comment|// }
name|currentFrame
operator|=
name|lastFrame
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cmp
operator|>
literal|0
condition|)
block|{
comment|// Uncommon case: target term
comment|// is before current term; this means we can
comment|// keep the currentFrame but we must rewind it
comment|// (so we scan from the start)
name|targetBeforeCurrentLength
operator|=
literal|0
expr_stmt|;
comment|// if (DEBUG) {
comment|//   System.out.println("  target is before current (shares prefixLen=" + targetUpto + "); rewind frame ord=" + lastFrame.ord);
comment|// }
name|currentFrame
operator|=
name|lastFrame
expr_stmt|;
name|currentFrame
operator|.
name|rewind
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|// Target is exactly the same as current term
assert|assert
name|term
operator|.
name|length
operator|==
name|target
operator|.
name|length
assert|;
if|if
condition|(
name|termExists
condition|)
block|{
comment|// if (DEBUG) {
comment|//   System.out.println("  target is same as current; return true");
comment|// }
return|return
literal|true
return|;
block|}
else|else
block|{
comment|// if (DEBUG) {
comment|//   System.out.println("  target is same as current but term doesn't exist");
comment|// }
block|}
comment|//validIndexPrefix = currentFrame.depth;
comment|//term.length = target.length;
comment|//return termExists;
block|}
block|}
else|else
block|{
name|targetBeforeCurrentLength
operator|=
operator|-
literal|1
expr_stmt|;
name|arc
operator|=
name|fr
operator|.
name|index
operator|.
name|getFirstArc
argument_list|(
name|arcs
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|// Empty string prefix must have an output (block) in the index!
assert|assert
name|arc
operator|.
name|isFinal
argument_list|()
assert|;
assert|assert
name|arc
operator|.
name|output
operator|!=
literal|null
assert|;
comment|// if (DEBUG) {
comment|//   System.out.println("    no seek state; push root frame");
comment|// }
name|output
operator|=
name|arc
operator|.
name|output
expr_stmt|;
name|currentFrame
operator|=
name|staticFrame
expr_stmt|;
comment|//term.length = 0;
name|targetUpto
operator|=
literal|0
expr_stmt|;
name|currentFrame
operator|=
name|pushFrame
argument_list|(
name|arc
argument_list|,
name|fr
operator|.
name|parent
operator|.
name|fstOutputs
operator|.
name|add
argument_list|(
name|output
argument_list|,
name|arc
operator|.
name|nextFinalOutput
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|// if (DEBUG) {
comment|//   System.out.println("  start index loop targetUpto=" + targetUpto + " output=" + output + " currentFrame.ord=" + currentFrame.ord + " targetBeforeCurrentLength=" + targetBeforeCurrentLength);
comment|// }
while|while
condition|(
name|targetUpto
operator|<
name|target
operator|.
name|length
condition|)
block|{
specifier|final
name|int
name|targetLabel
init|=
name|target
operator|.
name|bytes
index|[
name|target
operator|.
name|offset
operator|+
name|targetUpto
index|]
operator|&
literal|0xFF
decl_stmt|;
specifier|final
name|FST
operator|.
name|Arc
argument_list|<
name|BytesRef
argument_list|>
name|nextArc
init|=
name|fr
operator|.
name|index
operator|.
name|findTargetArc
argument_list|(
name|targetLabel
argument_list|,
name|arc
argument_list|,
name|getArc
argument_list|(
literal|1
operator|+
name|targetUpto
argument_list|)
argument_list|,
name|fstReader
argument_list|)
decl_stmt|;
if|if
condition|(
name|nextArc
operator|==
literal|null
condition|)
block|{
comment|// Index is exhausted
comment|// if (DEBUG) {
comment|//   System.out.println("    index: index exhausted label=" + ((char) targetLabel) + " " + toHex(targetLabel));
comment|// }
name|validIndexPrefix
operator|=
name|currentFrame
operator|.
name|prefix
expr_stmt|;
comment|//validIndexPrefix = targetUpto;
name|currentFrame
operator|.
name|scanToFloorFrame
argument_list|(
name|target
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|currentFrame
operator|.
name|hasTerms
condition|)
block|{
name|termExists
operator|=
literal|false
expr_stmt|;
name|term
operator|.
name|bytes
index|[
name|targetUpto
index|]
operator|=
operator|(
name|byte
operator|)
name|targetLabel
expr_stmt|;
name|term
operator|.
name|length
operator|=
literal|1
operator|+
name|targetUpto
expr_stmt|;
comment|// if (DEBUG) {
comment|//   System.out.println("  FAST NOT_FOUND term=" + brToString(term));
comment|// }
return|return
literal|false
return|;
block|}
name|currentFrame
operator|.
name|loadBlock
argument_list|()
expr_stmt|;
specifier|final
name|SeekStatus
name|result
init|=
name|currentFrame
operator|.
name|scanToTerm
argument_list|(
name|target
argument_list|,
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|==
name|SeekStatus
operator|.
name|FOUND
condition|)
block|{
comment|// if (DEBUG) {
comment|//   System.out.println("  return FOUND term=" + term.utf8ToString() + " " + term);
comment|// }
return|return
literal|true
return|;
block|}
else|else
block|{
comment|// if (DEBUG) {
comment|//   System.out.println("  got " + result + "; return NOT_FOUND term=" + brToString(term));
comment|// }
return|return
literal|false
return|;
block|}
block|}
else|else
block|{
comment|// Follow this arc
name|arc
operator|=
name|nextArc
expr_stmt|;
name|term
operator|.
name|bytes
index|[
name|targetUpto
index|]
operator|=
operator|(
name|byte
operator|)
name|targetLabel
expr_stmt|;
comment|// Aggregate output as we go:
assert|assert
name|arc
operator|.
name|output
operator|!=
literal|null
assert|;
if|if
condition|(
name|arc
operator|.
name|output
operator|!=
name|fr
operator|.
name|parent
operator|.
name|NO_OUTPUT
condition|)
block|{
name|output
operator|=
name|fr
operator|.
name|parent
operator|.
name|fstOutputs
operator|.
name|add
argument_list|(
name|output
argument_list|,
name|arc
operator|.
name|output
argument_list|)
expr_stmt|;
block|}
comment|// if (DEBUG) {
comment|//   System.out.println("    index: follow label=" + toHex(target.bytes[target.offset + targetUpto]&0xff) + " arc.output=" + arc.output + " arc.nfo=" + arc.nextFinalOutput);
comment|// }
name|targetUpto
operator|++
expr_stmt|;
if|if
condition|(
name|arc
operator|.
name|isFinal
argument_list|()
condition|)
block|{
comment|//if (DEBUG) System.out.println("    arc is final!");
name|currentFrame
operator|=
name|pushFrame
argument_list|(
name|arc
argument_list|,
name|fr
operator|.
name|parent
operator|.
name|fstOutputs
operator|.
name|add
argument_list|(
name|output
argument_list|,
name|arc
operator|.
name|nextFinalOutput
argument_list|)
argument_list|,
name|targetUpto
argument_list|)
expr_stmt|;
comment|//if (DEBUG) System.out.println("    curFrame.ord=" + currentFrame.ord + " hasTerms=" + currentFrame.hasTerms);
block|}
block|}
block|}
comment|//validIndexPrefix = targetUpto;
name|validIndexPrefix
operator|=
name|currentFrame
operator|.
name|prefix
expr_stmt|;
name|currentFrame
operator|.
name|scanToFloorFrame
argument_list|(
name|target
argument_list|)
expr_stmt|;
comment|// Target term is entirely contained in the index:
if|if
condition|(
operator|!
name|currentFrame
operator|.
name|hasTerms
condition|)
block|{
name|termExists
operator|=
literal|false
expr_stmt|;
name|term
operator|.
name|length
operator|=
name|targetUpto
expr_stmt|;
comment|// if (DEBUG) {
comment|//   System.out.println("  FAST NOT_FOUND term=" + brToString(term));
comment|// }
return|return
literal|false
return|;
block|}
name|currentFrame
operator|.
name|loadBlock
argument_list|()
expr_stmt|;
specifier|final
name|SeekStatus
name|result
init|=
name|currentFrame
operator|.
name|scanToTerm
argument_list|(
name|target
argument_list|,
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|==
name|SeekStatus
operator|.
name|FOUND
condition|)
block|{
comment|// if (DEBUG) {
comment|//   System.out.println("  return FOUND term=" + term.utf8ToString() + " " + term);
comment|// }
return|return
literal|true
return|;
block|}
else|else
block|{
comment|// if (DEBUG) {
comment|//   System.out.println("  got result " + result + "; return NOT_FOUND term=" + term.utf8ToString());
comment|// }
return|return
literal|false
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|seekCeil
specifier|public
name|SeekStatus
name|seekCeil
parameter_list|(
specifier|final
name|BytesRef
name|target
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|fr
operator|.
name|index
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"terms index was not loaded"
argument_list|)
throw|;
block|}
if|if
condition|(
name|term
operator|.
name|bytes
operator|.
name|length
operator|<=
name|target
operator|.
name|length
condition|)
block|{
name|term
operator|.
name|bytes
operator|=
name|ArrayUtil
operator|.
name|grow
argument_list|(
name|term
operator|.
name|bytes
argument_list|,
literal|1
operator|+
name|target
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
assert|assert
name|clearEOF
argument_list|()
assert|;
comment|//if (DEBUG) {
comment|//System.out.println("\nBTTR.seekCeil seg=" + segment + " target=" + fieldInfo.name + ":" + target.utf8ToString() + " " + target + " current=" + brToString(term) + " (exists?=" + termExists + ") validIndexPrefix=  " + validIndexPrefix);
comment|//printSeekState();
comment|//}
name|FST
operator|.
name|Arc
argument_list|<
name|BytesRef
argument_list|>
name|arc
decl_stmt|;
name|int
name|targetUpto
decl_stmt|;
name|BytesRef
name|output
decl_stmt|;
name|targetBeforeCurrentLength
operator|=
name|currentFrame
operator|.
name|ord
expr_stmt|;
if|if
condition|(
name|currentFrame
operator|!=
name|staticFrame
condition|)
block|{
comment|// We are already seek'd; find the common
comment|// prefix of new seek term vs current term and
comment|// re-use the corresponding seek state.  For
comment|// example, if app first seeks to foobar, then
comment|// seeks to foobaz, we can re-use the seek state
comment|// for the first 5 bytes.
comment|//if (DEBUG) {
comment|//System.out.println("  re-use current seek state validIndexPrefix=" + validIndexPrefix);
comment|//}
name|arc
operator|=
name|arcs
index|[
literal|0
index|]
expr_stmt|;
assert|assert
name|arc
operator|.
name|isFinal
argument_list|()
assert|;
name|output
operator|=
name|arc
operator|.
name|output
expr_stmt|;
name|targetUpto
operator|=
literal|0
expr_stmt|;
name|Frame
name|lastFrame
init|=
name|stack
index|[
literal|0
index|]
decl_stmt|;
assert|assert
name|validIndexPrefix
operator|<=
name|term
operator|.
name|length
assert|;
specifier|final
name|int
name|targetLimit
init|=
name|Math
operator|.
name|min
argument_list|(
name|target
operator|.
name|length
argument_list|,
name|validIndexPrefix
argument_list|)
decl_stmt|;
name|int
name|cmp
init|=
literal|0
decl_stmt|;
comment|// TOOD: we should write our vLong backwards (MSB
comment|// first) to get better sharing from the FST
comment|// First compare up to valid seek frames:
while|while
condition|(
name|targetUpto
operator|<
name|targetLimit
condition|)
block|{
name|cmp
operator|=
operator|(
name|term
operator|.
name|bytes
index|[
name|targetUpto
index|]
operator|&
literal|0xFF
operator|)
operator|-
operator|(
name|target
operator|.
name|bytes
index|[
name|target
operator|.
name|offset
operator|+
name|targetUpto
index|]
operator|&
literal|0xFF
operator|)
expr_stmt|;
comment|//if (DEBUG) {
comment|//System.out.println("    cycle targetUpto=" + targetUpto + " (vs limit=" + targetLimit + ") cmp=" + cmp + " (targetLabel=" + (char) (target.bytes[target.offset + targetUpto]) + " vs termLabel=" + (char) (term.bytes[targetUpto]) + ")"   + " arc.output=" + arc.output + " output=" + output);
comment|//}
if|if
condition|(
name|cmp
operator|!=
literal|0
condition|)
block|{
break|break;
block|}
name|arc
operator|=
name|arcs
index|[
literal|1
operator|+
name|targetUpto
index|]
expr_stmt|;
assert|assert
name|arc
operator|.
name|label
operator|==
operator|(
name|target
operator|.
name|bytes
index|[
name|target
operator|.
name|offset
operator|+
name|targetUpto
index|]
operator|&
literal|0xFF
operator|)
operator|:
literal|"arc.label="
operator|+
operator|(
name|char
operator|)
name|arc
operator|.
name|label
operator|+
literal|" targetLabel="
operator|+
call|(
name|char
call|)
argument_list|(
name|target
operator|.
name|bytes
index|[
name|target
operator|.
name|offset
operator|+
name|targetUpto
index|]
operator|&
literal|0xFF
argument_list|)
assert|;
comment|// TOOD: we could save the outputs in local
comment|// byte[][] instead of making new objs ever
comment|// seek; but, often the FST doesn't have any
comment|// shared bytes (but this could change if we
comment|// reverse vLong byte order)
if|if
condition|(
name|arc
operator|.
name|output
operator|!=
name|fr
operator|.
name|parent
operator|.
name|NO_OUTPUT
condition|)
block|{
name|output
operator|=
name|fr
operator|.
name|parent
operator|.
name|fstOutputs
operator|.
name|add
argument_list|(
name|output
argument_list|,
name|arc
operator|.
name|output
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|arc
operator|.
name|isFinal
argument_list|()
condition|)
block|{
name|lastFrame
operator|=
name|stack
index|[
literal|1
operator|+
name|lastFrame
operator|.
name|ord
index|]
expr_stmt|;
block|}
name|targetUpto
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|cmp
operator|==
literal|0
condition|)
block|{
specifier|final
name|int
name|targetUptoMid
init|=
name|targetUpto
decl_stmt|;
comment|// Second compare the rest of the term, but
comment|// don't save arc/output/frame:
specifier|final
name|int
name|targetLimit2
init|=
name|Math
operator|.
name|min
argument_list|(
name|target
operator|.
name|length
argument_list|,
name|term
operator|.
name|length
argument_list|)
decl_stmt|;
while|while
condition|(
name|targetUpto
operator|<
name|targetLimit2
condition|)
block|{
name|cmp
operator|=
operator|(
name|term
operator|.
name|bytes
index|[
name|targetUpto
index|]
operator|&
literal|0xFF
operator|)
operator|-
operator|(
name|target
operator|.
name|bytes
index|[
name|target
operator|.
name|offset
operator|+
name|targetUpto
index|]
operator|&
literal|0xFF
operator|)
expr_stmt|;
comment|//if (DEBUG) {
comment|//System.out.println("    cycle2 targetUpto=" + targetUpto + " (vs limit=" + targetLimit + ") cmp=" + cmp + " (targetLabel=" + (char) (target.bytes[target.offset + targetUpto]) + " vs termLabel=" + (char) (term.bytes[targetUpto]) + ")");
comment|//}
if|if
condition|(
name|cmp
operator|!=
literal|0
condition|)
block|{
break|break;
block|}
name|targetUpto
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|cmp
operator|==
literal|0
condition|)
block|{
name|cmp
operator|=
name|term
operator|.
name|length
operator|-
name|target
operator|.
name|length
expr_stmt|;
block|}
name|targetUpto
operator|=
name|targetUptoMid
expr_stmt|;
block|}
if|if
condition|(
name|cmp
operator|<
literal|0
condition|)
block|{
comment|// Common case: target term is after current
comment|// term, ie, app is seeking multiple terms
comment|// in sorted order
comment|//if (DEBUG) {
comment|//System.out.println("  target is after current (shares prefixLen=" + targetUpto + "); clear frame.scanned ord=" + lastFrame.ord);
comment|//}
name|currentFrame
operator|=
name|lastFrame
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cmp
operator|>
literal|0
condition|)
block|{
comment|// Uncommon case: target term
comment|// is before current term; this means we can
comment|// keep the currentFrame but we must rewind it
comment|// (so we scan from the start)
name|targetBeforeCurrentLength
operator|=
literal|0
expr_stmt|;
comment|//if (DEBUG) {
comment|//System.out.println("  target is before current (shares prefixLen=" + targetUpto + "); rewind frame ord=" + lastFrame.ord);
comment|//}
name|currentFrame
operator|=
name|lastFrame
expr_stmt|;
name|currentFrame
operator|.
name|rewind
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|// Target is exactly the same as current term
assert|assert
name|term
operator|.
name|length
operator|==
name|target
operator|.
name|length
assert|;
if|if
condition|(
name|termExists
condition|)
block|{
comment|//if (DEBUG) {
comment|//System.out.println("  target is same as current; return FOUND");
comment|//}
return|return
name|SeekStatus
operator|.
name|FOUND
return|;
block|}
else|else
block|{
comment|//if (DEBUG) {
comment|//System.out.println("  target is same as current but term doesn't exist");
comment|//}
block|}
block|}
block|}
else|else
block|{
name|targetBeforeCurrentLength
operator|=
operator|-
literal|1
expr_stmt|;
name|arc
operator|=
name|fr
operator|.
name|index
operator|.
name|getFirstArc
argument_list|(
name|arcs
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|// Empty string prefix must have an output (block) in the index!
assert|assert
name|arc
operator|.
name|isFinal
argument_list|()
assert|;
assert|assert
name|arc
operator|.
name|output
operator|!=
literal|null
assert|;
comment|//if (DEBUG) {
comment|//System.out.println("    no seek state; push root frame");
comment|//}
name|output
operator|=
name|arc
operator|.
name|output
expr_stmt|;
name|currentFrame
operator|=
name|staticFrame
expr_stmt|;
comment|//term.length = 0;
name|targetUpto
operator|=
literal|0
expr_stmt|;
name|currentFrame
operator|=
name|pushFrame
argument_list|(
name|arc
argument_list|,
name|fr
operator|.
name|parent
operator|.
name|fstOutputs
operator|.
name|add
argument_list|(
name|output
argument_list|,
name|arc
operator|.
name|nextFinalOutput
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|//if (DEBUG) {
comment|//System.out.println("  start index loop targetUpto=" + targetUpto + " output=" + output + " currentFrame.ord+1=" + currentFrame.ord + " targetBeforeCurrentLength=" + targetBeforeCurrentLength);
comment|//}
while|while
condition|(
name|targetUpto
operator|<
name|target
operator|.
name|length
condition|)
block|{
specifier|final
name|int
name|targetLabel
init|=
name|target
operator|.
name|bytes
index|[
name|target
operator|.
name|offset
operator|+
name|targetUpto
index|]
operator|&
literal|0xFF
decl_stmt|;
specifier|final
name|FST
operator|.
name|Arc
argument_list|<
name|BytesRef
argument_list|>
name|nextArc
init|=
name|fr
operator|.
name|index
operator|.
name|findTargetArc
argument_list|(
name|targetLabel
argument_list|,
name|arc
argument_list|,
name|getArc
argument_list|(
literal|1
operator|+
name|targetUpto
argument_list|)
argument_list|,
name|fstReader
argument_list|)
decl_stmt|;
if|if
condition|(
name|nextArc
operator|==
literal|null
condition|)
block|{
comment|// Index is exhausted
comment|// if (DEBUG) {
comment|//   System.out.println("    index: index exhausted label=" + ((char) targetLabel) + " " + toHex(targetLabel));
comment|// }
name|validIndexPrefix
operator|=
name|currentFrame
operator|.
name|prefix
expr_stmt|;
comment|//validIndexPrefix = targetUpto;
name|currentFrame
operator|.
name|scanToFloorFrame
argument_list|(
name|target
argument_list|)
expr_stmt|;
name|currentFrame
operator|.
name|loadBlock
argument_list|()
expr_stmt|;
specifier|final
name|SeekStatus
name|result
init|=
name|currentFrame
operator|.
name|scanToTerm
argument_list|(
name|target
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|==
name|SeekStatus
operator|.
name|END
condition|)
block|{
name|term
operator|.
name|copyBytes
argument_list|(
name|target
argument_list|)
expr_stmt|;
name|termExists
operator|=
literal|false
expr_stmt|;
if|if
condition|(
name|next
argument_list|()
operator|!=
literal|null
condition|)
block|{
comment|//if (DEBUG) {
comment|//System.out.println("  return NOT_FOUND term=" + brToString(term) + " " + term);
comment|//}
return|return
name|SeekStatus
operator|.
name|NOT_FOUND
return|;
block|}
else|else
block|{
comment|//if (DEBUG) {
comment|//System.out.println("  return END");
comment|//}
return|return
name|SeekStatus
operator|.
name|END
return|;
block|}
block|}
else|else
block|{
comment|//if (DEBUG) {
comment|//System.out.println("  return " + result + " term=" + brToString(term) + " " + term);
comment|//}
return|return
name|result
return|;
block|}
block|}
else|else
block|{
comment|// Follow this arc
name|term
operator|.
name|bytes
index|[
name|targetUpto
index|]
operator|=
operator|(
name|byte
operator|)
name|targetLabel
expr_stmt|;
name|arc
operator|=
name|nextArc
expr_stmt|;
comment|// Aggregate output as we go:
assert|assert
name|arc
operator|.
name|output
operator|!=
literal|null
assert|;
if|if
condition|(
name|arc
operator|.
name|output
operator|!=
name|fr
operator|.
name|parent
operator|.
name|NO_OUTPUT
condition|)
block|{
name|output
operator|=
name|fr
operator|.
name|parent
operator|.
name|fstOutputs
operator|.
name|add
argument_list|(
name|output
argument_list|,
name|arc
operator|.
name|output
argument_list|)
expr_stmt|;
block|}
comment|//if (DEBUG) {
comment|//System.out.println("    index: follow label=" + toHex(target.bytes[target.offset + targetUpto]&0xff) + " arc.output=" + arc.output + " arc.nfo=" + arc.nextFinalOutput);
comment|//}
name|targetUpto
operator|++
expr_stmt|;
if|if
condition|(
name|arc
operator|.
name|isFinal
argument_list|()
condition|)
block|{
comment|//if (DEBUG) System.out.println("    arc is final!");
name|currentFrame
operator|=
name|pushFrame
argument_list|(
name|arc
argument_list|,
name|fr
operator|.
name|parent
operator|.
name|fstOutputs
operator|.
name|add
argument_list|(
name|output
argument_list|,
name|arc
operator|.
name|nextFinalOutput
argument_list|)
argument_list|,
name|targetUpto
argument_list|)
expr_stmt|;
comment|//if (DEBUG) System.out.println("    curFrame.ord=" + currentFrame.ord + " hasTerms=" + currentFrame.hasTerms);
block|}
block|}
block|}
comment|//validIndexPrefix = targetUpto;
name|validIndexPrefix
operator|=
name|currentFrame
operator|.
name|prefix
expr_stmt|;
name|currentFrame
operator|.
name|scanToFloorFrame
argument_list|(
name|target
argument_list|)
expr_stmt|;
name|currentFrame
operator|.
name|loadBlock
argument_list|()
expr_stmt|;
specifier|final
name|SeekStatus
name|result
init|=
name|currentFrame
operator|.
name|scanToTerm
argument_list|(
name|target
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|==
name|SeekStatus
operator|.
name|END
condition|)
block|{
name|term
operator|.
name|copyBytes
argument_list|(
name|target
argument_list|)
expr_stmt|;
name|termExists
operator|=
literal|false
expr_stmt|;
if|if
condition|(
name|next
argument_list|()
operator|!=
literal|null
condition|)
block|{
comment|//if (DEBUG) {
comment|//System.out.println("  return NOT_FOUND term=" + term.utf8ToString() + " " + term);
comment|//}
return|return
name|SeekStatus
operator|.
name|NOT_FOUND
return|;
block|}
else|else
block|{
comment|//if (DEBUG) {
comment|//System.out.println("  return END");
comment|//}
return|return
name|SeekStatus
operator|.
name|END
return|;
block|}
block|}
else|else
block|{
return|return
name|result
return|;
block|}
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unused"
argument_list|)
DECL|method|printSeekState
specifier|private
name|void
name|printSeekState
parameter_list|(
name|PrintStream
name|out
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|currentFrame
operator|==
name|staticFrame
condition|)
block|{
name|out
operator|.
name|println
argument_list|(
literal|"  no prior seek"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|out
operator|.
name|println
argument_list|(
literal|"  prior seek state:"
argument_list|)
expr_stmt|;
name|int
name|ord
init|=
literal|0
decl_stmt|;
name|boolean
name|isSeekFrame
init|=
literal|true
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|Frame
name|f
init|=
name|getFrame
argument_list|(
name|ord
argument_list|)
decl_stmt|;
assert|assert
name|f
operator|!=
literal|null
assert|;
specifier|final
name|BytesRef
name|prefix
init|=
operator|new
name|BytesRef
argument_list|(
name|term
operator|.
name|bytes
argument_list|,
literal|0
argument_list|,
name|f
operator|.
name|prefix
argument_list|)
decl_stmt|;
if|if
condition|(
name|f
operator|.
name|nextEnt
operator|==
operator|-
literal|1
condition|)
block|{
name|out
operator|.
name|println
argument_list|(
literal|"    frame "
operator|+
operator|(
name|isSeekFrame
condition|?
literal|"(seek)"
else|:
literal|"(next)"
operator|)
operator|+
literal|" ord="
operator|+
name|ord
operator|+
literal|" fp="
operator|+
name|f
operator|.
name|fp
operator|+
operator|(
name|f
operator|.
name|isFloor
condition|?
operator|(
literal|" (fpOrig="
operator|+
name|f
operator|.
name|fpOrig
operator|+
literal|")"
operator|)
else|:
literal|""
operator|)
operator|+
literal|" prefixLen="
operator|+
name|f
operator|.
name|prefix
operator|+
literal|" prefix="
operator|+
name|prefix
operator|+
operator|(
name|f
operator|.
name|nextEnt
operator|==
operator|-
literal|1
condition|?
literal|""
else|:
operator|(
literal|" (of "
operator|+
name|f
operator|.
name|entCount
operator|+
literal|")"
operator|)
operator|)
operator|+
literal|" hasTerms="
operator|+
name|f
operator|.
name|hasTerms
operator|+
literal|" isFloor="
operator|+
name|f
operator|.
name|isFloor
operator|+
literal|" code="
operator|+
operator|(
operator|(
name|f
operator|.
name|fp
operator|<<
name|BlockTreeTermsWriter
operator|.
name|OUTPUT_FLAGS_NUM_BITS
operator|)
operator|+
operator|(
name|f
operator|.
name|hasTerms
condition|?
name|BlockTreeTermsWriter
operator|.
name|OUTPUT_FLAG_HAS_TERMS
else|:
literal|0
operator|)
operator|+
operator|(
name|f
operator|.
name|isFloor
condition|?
name|BlockTreeTermsWriter
operator|.
name|OUTPUT_FLAG_IS_FLOOR
else|:
literal|0
operator|)
operator|)
operator|+
literal|" isLastInFloor="
operator|+
name|f
operator|.
name|isLastInFloor
operator|+
literal|" mdUpto="
operator|+
name|f
operator|.
name|metaDataUpto
operator|+
literal|" tbOrd="
operator|+
name|f
operator|.
name|getTermBlockOrd
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|out
operator|.
name|println
argument_list|(
literal|"    frame "
operator|+
operator|(
name|isSeekFrame
condition|?
literal|"(seek, loaded)"
else|:
literal|"(next, loaded)"
operator|)
operator|+
literal|" ord="
operator|+
name|ord
operator|+
literal|" fp="
operator|+
name|f
operator|.
name|fp
operator|+
operator|(
name|f
operator|.
name|isFloor
condition|?
operator|(
literal|" (fpOrig="
operator|+
name|f
operator|.
name|fpOrig
operator|+
literal|")"
operator|)
else|:
literal|""
operator|)
operator|+
literal|" prefixLen="
operator|+
name|f
operator|.
name|prefix
operator|+
literal|" prefix="
operator|+
name|prefix
operator|+
literal|" nextEnt="
operator|+
name|f
operator|.
name|nextEnt
operator|+
operator|(
name|f
operator|.
name|nextEnt
operator|==
operator|-
literal|1
condition|?
literal|""
else|:
operator|(
literal|" (of "
operator|+
name|f
operator|.
name|entCount
operator|+
literal|")"
operator|)
operator|)
operator|+
literal|" hasTerms="
operator|+
name|f
operator|.
name|hasTerms
operator|+
literal|" isFloor="
operator|+
name|f
operator|.
name|isFloor
operator|+
literal|" code="
operator|+
operator|(
operator|(
name|f
operator|.
name|fp
operator|<<
name|BlockTreeTermsWriter
operator|.
name|OUTPUT_FLAGS_NUM_BITS
operator|)
operator|+
operator|(
name|f
operator|.
name|hasTerms
condition|?
name|BlockTreeTermsWriter
operator|.
name|OUTPUT_FLAG_HAS_TERMS
else|:
literal|0
operator|)
operator|+
operator|(
name|f
operator|.
name|isFloor
condition|?
name|BlockTreeTermsWriter
operator|.
name|OUTPUT_FLAG_IS_FLOOR
else|:
literal|0
operator|)
operator|)
operator|+
literal|" lastSubFP="
operator|+
name|f
operator|.
name|lastSubFP
operator|+
literal|" isLastInFloor="
operator|+
name|f
operator|.
name|isLastInFloor
operator|+
literal|" mdUpto="
operator|+
name|f
operator|.
name|metaDataUpto
operator|+
literal|" tbOrd="
operator|+
name|f
operator|.
name|getTermBlockOrd
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fr
operator|.
name|index
operator|!=
literal|null
condition|)
block|{
assert|assert
operator|!
name|isSeekFrame
operator|||
name|f
operator|.
name|arc
operator|!=
literal|null
operator|:
literal|"isSeekFrame="
operator|+
name|isSeekFrame
operator|+
literal|" f.arc="
operator|+
name|f
operator|.
name|arc
assert|;
if|if
condition|(
name|f
operator|.
name|prefix
operator|>
literal|0
operator|&&
name|isSeekFrame
operator|&&
name|f
operator|.
name|arc
operator|.
name|label
operator|!=
operator|(
name|term
operator|.
name|bytes
index|[
name|f
operator|.
name|prefix
operator|-
literal|1
index|]
operator|&
literal|0xFF
operator|)
condition|)
block|{
name|out
operator|.
name|println
argument_list|(
literal|"      broken seek state: arc.label="
operator|+
operator|(
name|char
operator|)
name|f
operator|.
name|arc
operator|.
name|label
operator|+
literal|" vs term byte="
operator|+
call|(
name|char
call|)
argument_list|(
name|term
operator|.
name|bytes
index|[
name|f
operator|.
name|prefix
operator|-
literal|1
index|]
operator|&
literal|0xFF
argument_list|)
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"seek state is broken"
argument_list|)
throw|;
block|}
name|BytesRef
name|output
init|=
name|Util
operator|.
name|get
argument_list|(
name|fr
operator|.
name|index
argument_list|,
name|prefix
argument_list|)
decl_stmt|;
if|if
condition|(
name|output
operator|==
literal|null
condition|)
block|{
name|out
operator|.
name|println
argument_list|(
literal|"      broken seek state: prefix is not final in index"
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"seek state is broken"
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
name|isSeekFrame
operator|&&
operator|!
name|f
operator|.
name|isFloor
condition|)
block|{
specifier|final
name|ByteArrayDataInput
name|reader
init|=
operator|new
name|ByteArrayDataInput
argument_list|(
name|output
operator|.
name|bytes
argument_list|,
name|output
operator|.
name|offset
argument_list|,
name|output
operator|.
name|length
argument_list|)
decl_stmt|;
specifier|final
name|long
name|codeOrig
init|=
name|reader
operator|.
name|readVLong
argument_list|()
decl_stmt|;
specifier|final
name|long
name|code
init|=
operator|(
name|f
operator|.
name|fp
operator|<<
name|BlockTreeTermsWriter
operator|.
name|OUTPUT_FLAGS_NUM_BITS
operator|)
operator||
operator|(
name|f
operator|.
name|hasTerms
condition|?
name|BlockTreeTermsWriter
operator|.
name|OUTPUT_FLAG_HAS_TERMS
else|:
literal|0
operator|)
operator||
operator|(
name|f
operator|.
name|isFloor
condition|?
name|BlockTreeTermsWriter
operator|.
name|OUTPUT_FLAG_IS_FLOOR
else|:
literal|0
operator|)
decl_stmt|;
if|if
condition|(
name|codeOrig
operator|!=
name|code
condition|)
block|{
name|out
operator|.
name|println
argument_list|(
literal|"      broken seek state: output code="
operator|+
name|codeOrig
operator|+
literal|" doesn't match frame code="
operator|+
name|code
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"seek state is broken"
argument_list|)
throw|;
block|}
block|}
block|}
if|if
condition|(
name|f
operator|==
name|currentFrame
condition|)
block|{
break|break;
block|}
if|if
condition|(
name|f
operator|.
name|prefix
operator|==
name|validIndexPrefix
condition|)
block|{
name|isSeekFrame
operator|=
literal|false
expr_stmt|;
block|}
name|ord
operator|++
expr_stmt|;
block|}
block|}
block|}
comment|/* Decodes only the term bytes of the next term.  If caller then asks for      metadata, ie docFreq, totalTermFreq or pulls a D/&PEnum, we then (lazily)      decode all metadata up to the current term. */
annotation|@
name|Override
DECL|method|next
specifier|public
name|BytesRef
name|next
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|in
operator|==
literal|null
condition|)
block|{
comment|// Fresh TermsEnum; seek to first term:
specifier|final
name|FST
operator|.
name|Arc
argument_list|<
name|BytesRef
argument_list|>
name|arc
decl_stmt|;
if|if
condition|(
name|fr
operator|.
name|index
operator|!=
literal|null
condition|)
block|{
name|arc
operator|=
name|fr
operator|.
name|index
operator|.
name|getFirstArc
argument_list|(
name|arcs
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|// Empty string prefix must have an output in the index!
assert|assert
name|arc
operator|.
name|isFinal
argument_list|()
assert|;
block|}
else|else
block|{
name|arc
operator|=
literal|null
expr_stmt|;
block|}
name|currentFrame
operator|=
name|pushFrame
argument_list|(
name|arc
argument_list|,
name|fr
operator|.
name|rootCode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|currentFrame
operator|.
name|loadBlock
argument_list|()
expr_stmt|;
block|}
name|targetBeforeCurrentLength
operator|=
name|currentFrame
operator|.
name|ord
expr_stmt|;
assert|assert
operator|!
name|eof
assert|;
comment|//if (DEBUG) {
comment|//System.out.println("\nBTTR.next seg=" + segment + " term=" + brToString(term) + " termExists?=" + termExists + " field=" + fieldInfo.name + " termBlockOrd=" + currentFrame.state.termBlockOrd + " validIndexPrefix=" + validIndexPrefix);
comment|//printSeekState();
comment|//}
if|if
condition|(
name|currentFrame
operator|==
name|staticFrame
condition|)
block|{
comment|// If seek was previously called and the term was
comment|// cached, or seek(TermState) was called, usually
comment|// caller is just going to pull a D/&PEnum or get
comment|// docFreq, etc.  But, if they then call next(),
comment|// this method catches up all internal state so next()
comment|// works properly:
comment|//if (DEBUG) System.out.println("  re-seek to pending term=" + term.utf8ToString() + " " + term);
specifier|final
name|boolean
name|result
init|=
name|seekExact
argument_list|(
name|term
argument_list|)
decl_stmt|;
assert|assert
name|result
assert|;
block|}
comment|// Pop finished blocks
while|while
condition|(
name|currentFrame
operator|.
name|nextEnt
operator|==
name|currentFrame
operator|.
name|entCount
condition|)
block|{
if|if
condition|(
operator|!
name|currentFrame
operator|.
name|isLastInFloor
condition|)
block|{
name|currentFrame
operator|.
name|loadNextFloorBlock
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|//if (DEBUG) System.out.println("  pop frame");
if|if
condition|(
name|currentFrame
operator|.
name|ord
operator|==
literal|0
condition|)
block|{
comment|//if (DEBUG) System.out.println("  return null");
assert|assert
name|setEOF
argument_list|()
assert|;
name|term
operator|.
name|length
operator|=
literal|0
expr_stmt|;
name|validIndexPrefix
operator|=
literal|0
expr_stmt|;
name|currentFrame
operator|.
name|rewind
argument_list|()
expr_stmt|;
name|termExists
operator|=
literal|false
expr_stmt|;
return|return
literal|null
return|;
block|}
specifier|final
name|long
name|lastFP
init|=
name|currentFrame
operator|.
name|fpOrig
decl_stmt|;
name|currentFrame
operator|=
name|stack
index|[
name|currentFrame
operator|.
name|ord
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|currentFrame
operator|.
name|nextEnt
operator|==
operator|-
literal|1
operator|||
name|currentFrame
operator|.
name|lastSubFP
operator|!=
name|lastFP
condition|)
block|{
comment|// We popped into a frame that's not loaded
comment|// yet or not scan'd to the right entry
name|currentFrame
operator|.
name|scanToFloorFrame
argument_list|(
name|term
argument_list|)
expr_stmt|;
name|currentFrame
operator|.
name|loadBlock
argument_list|()
expr_stmt|;
name|currentFrame
operator|.
name|scanToSubBlock
argument_list|(
name|lastFP
argument_list|)
expr_stmt|;
block|}
comment|// Note that the seek state (last seek) has been
comment|// invalidated beyond this depth
name|validIndexPrefix
operator|=
name|Math
operator|.
name|min
argument_list|(
name|validIndexPrefix
argument_list|,
name|currentFrame
operator|.
name|prefix
argument_list|)
expr_stmt|;
comment|//if (DEBUG) {
comment|//System.out.println("  reset validIndexPrefix=" + validIndexPrefix);
comment|//}
block|}
block|}
while|while
condition|(
literal|true
condition|)
block|{
if|if
condition|(
name|currentFrame
operator|.
name|next
argument_list|()
condition|)
block|{
comment|// Push to new block:
comment|//if (DEBUG) System.out.println("  push frame");
name|currentFrame
operator|=
name|pushFrame
argument_list|(
literal|null
argument_list|,
name|currentFrame
operator|.
name|lastSubFP
argument_list|,
name|term
operator|.
name|length
argument_list|)
expr_stmt|;
comment|// This is a "next" frame -- even if it's
comment|// floor'd we must pretend it isn't so we don't
comment|// try to scan to the right floor frame:
name|currentFrame
operator|.
name|isFloor
operator|=
literal|false
expr_stmt|;
comment|//currentFrame.hasTerms = true;
name|currentFrame
operator|.
name|loadBlock
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|//if (DEBUG) System.out.println("  return term=" + term.utf8ToString() + " " + term + " currentFrame.ord=" + currentFrame.ord);
return|return
name|term
return|;
block|}
block|}
block|}
annotation|@
name|Override
DECL|method|term
specifier|public
name|BytesRef
name|term
parameter_list|()
block|{
assert|assert
operator|!
name|eof
assert|;
return|return
name|term
return|;
block|}
annotation|@
name|Override
DECL|method|docFreq
specifier|public
name|int
name|docFreq
parameter_list|()
throws|throws
name|IOException
block|{
assert|assert
operator|!
name|eof
assert|;
comment|//if (DEBUG) System.out.println("BTR.docFreq");
name|currentFrame
operator|.
name|decodeMetaData
argument_list|()
expr_stmt|;
comment|//if (DEBUG) System.out.println("  return " + currentFrame.state.docFreq);
return|return
name|currentFrame
operator|.
name|state
operator|.
name|docFreq
return|;
block|}
annotation|@
name|Override
DECL|method|totalTermFreq
specifier|public
name|long
name|totalTermFreq
parameter_list|()
throws|throws
name|IOException
block|{
assert|assert
operator|!
name|eof
assert|;
name|currentFrame
operator|.
name|decodeMetaData
argument_list|()
expr_stmt|;
return|return
name|currentFrame
operator|.
name|state
operator|.
name|totalTermFreq
return|;
block|}
annotation|@
name|Override
DECL|method|docs
specifier|public
name|DocsEnum
name|docs
parameter_list|(
name|Bits
name|skipDocs
parameter_list|,
name|DocsEnum
name|reuse
parameter_list|,
name|int
name|flags
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
operator|!
name|eof
assert|;
comment|//if (DEBUG) {
comment|//System.out.println("BTTR.docs seg=" + segment);
comment|//}
name|currentFrame
operator|.
name|decodeMetaData
argument_list|()
expr_stmt|;
comment|//if (DEBUG) {
comment|//System.out.println("  state=" + currentFrame.state);
comment|//}
return|return
name|fr
operator|.
name|parent
operator|.
name|postingsReader
operator|.
name|docs
argument_list|(
name|fr
operator|.
name|fieldInfo
argument_list|,
name|currentFrame
operator|.
name|state
argument_list|,
name|skipDocs
argument_list|,
name|reuse
argument_list|,
name|flags
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|docsAndPositions
specifier|public
name|DocsAndPositionsEnum
name|docsAndPositions
parameter_list|(
name|Bits
name|skipDocs
parameter_list|,
name|DocsAndPositionsEnum
name|reuse
parameter_list|,
name|int
name|flags
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|fr
operator|.
name|fieldInfo
operator|.
name|getIndexOptions
argument_list|()
operator|.
name|compareTo
argument_list|(
name|IndexOptions
operator|.
name|DOCS_AND_FREQS_AND_POSITIONS
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|// Positions were not indexed:
return|return
literal|null
return|;
block|}
assert|assert
operator|!
name|eof
assert|;
name|currentFrame
operator|.
name|decodeMetaData
argument_list|()
expr_stmt|;
return|return
name|fr
operator|.
name|parent
operator|.
name|postingsReader
operator|.
name|docsAndPositions
argument_list|(
name|fr
operator|.
name|fieldInfo
argument_list|,
name|currentFrame
operator|.
name|state
argument_list|,
name|skipDocs
argument_list|,
name|reuse
argument_list|,
name|flags
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|seekExact
specifier|public
name|void
name|seekExact
parameter_list|(
name|BytesRef
name|target
parameter_list|,
name|TermState
name|otherState
parameter_list|)
block|{
comment|// if (DEBUG) {
comment|//   System.out.println("BTTR.seekExact termState seg=" + segment + " target=" + target.utf8ToString() + " " + target + " state=" + otherState);
comment|// }
assert|assert
name|clearEOF
argument_list|()
assert|;
if|if
condition|(
name|target
operator|.
name|compareTo
argument_list|(
name|term
argument_list|)
operator|!=
literal|0
operator|||
operator|!
name|termExists
condition|)
block|{
assert|assert
name|otherState
operator|!=
literal|null
operator|&&
name|otherState
operator|instanceof
name|BlockTermState
assert|;
name|currentFrame
operator|=
name|staticFrame
expr_stmt|;
name|currentFrame
operator|.
name|state
operator|.
name|copyFrom
argument_list|(
name|otherState
argument_list|)
expr_stmt|;
name|term
operator|.
name|copyBytes
argument_list|(
name|target
argument_list|)
expr_stmt|;
name|currentFrame
operator|.
name|metaDataUpto
operator|=
name|currentFrame
operator|.
name|getTermBlockOrd
argument_list|()
expr_stmt|;
assert|assert
name|currentFrame
operator|.
name|metaDataUpto
operator|>
literal|0
assert|;
name|validIndexPrefix
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|// if (DEBUG) {
comment|//   System.out.println("  skip seek: already on target state=" + currentFrame.state);
comment|// }
block|}
block|}
annotation|@
name|Override
DECL|method|termState
specifier|public
name|TermState
name|termState
parameter_list|()
throws|throws
name|IOException
block|{
assert|assert
operator|!
name|eof
assert|;
name|currentFrame
operator|.
name|decodeMetaData
argument_list|()
expr_stmt|;
name|TermState
name|ts
init|=
name|currentFrame
operator|.
name|state
operator|.
name|clone
argument_list|()
decl_stmt|;
comment|//if (DEBUG) System.out.println("BTTR.termState seg=" + segment + " state=" + ts);
return|return
name|ts
return|;
block|}
annotation|@
name|Override
DECL|method|seekExact
specifier|public
name|void
name|seekExact
parameter_list|(
name|long
name|ord
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
DECL|method|ord
specifier|public
name|long
name|ord
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
comment|// Not static -- references term, postingsReader,
comment|// fieldInfo, in
DECL|class|Frame
specifier|final
class|class
name|Frame
block|{
comment|// Our index in stack[]:
DECL|field|ord
specifier|final
name|int
name|ord
decl_stmt|;
DECL|field|hasTerms
name|boolean
name|hasTerms
decl_stmt|;
DECL|field|hasTermsOrig
name|boolean
name|hasTermsOrig
decl_stmt|;
DECL|field|isFloor
name|boolean
name|isFloor
decl_stmt|;
DECL|field|arc
name|FST
operator|.
name|Arc
argument_list|<
name|BytesRef
argument_list|>
name|arc
decl_stmt|;
comment|// File pointer where this block was loaded from
DECL|field|fp
name|long
name|fp
decl_stmt|;
DECL|field|fpOrig
name|long
name|fpOrig
decl_stmt|;
DECL|field|fpEnd
name|long
name|fpEnd
decl_stmt|;
DECL|field|suffixBytes
name|byte
index|[]
name|suffixBytes
init|=
operator|new
name|byte
index|[
literal|128
index|]
decl_stmt|;
DECL|field|suffixesReader
specifier|final
name|ByteArrayDataInput
name|suffixesReader
init|=
operator|new
name|ByteArrayDataInput
argument_list|()
decl_stmt|;
DECL|field|statBytes
name|byte
index|[]
name|statBytes
init|=
operator|new
name|byte
index|[
literal|64
index|]
decl_stmt|;
DECL|field|statsReader
specifier|final
name|ByteArrayDataInput
name|statsReader
init|=
operator|new
name|ByteArrayDataInput
argument_list|()
decl_stmt|;
DECL|field|floorData
name|byte
index|[]
name|floorData
init|=
operator|new
name|byte
index|[
literal|32
index|]
decl_stmt|;
DECL|field|floorDataReader
specifier|final
name|ByteArrayDataInput
name|floorDataReader
init|=
operator|new
name|ByteArrayDataInput
argument_list|()
decl_stmt|;
comment|// Length of prefix shared by all terms in this block
DECL|field|prefix
name|int
name|prefix
decl_stmt|;
comment|// Number of entries (term or sub-block) in this block
DECL|field|entCount
name|int
name|entCount
decl_stmt|;
comment|// Which term we will next read, or -1 if the block
comment|// isn't loaded yet
DECL|field|nextEnt
name|int
name|nextEnt
decl_stmt|;
comment|// True if this block is either not a floor block,
comment|// or, it's the last sub-block of a floor block
DECL|field|isLastInFloor
name|boolean
name|isLastInFloor
decl_stmt|;
comment|// True if all entries are terms
DECL|field|isLeafBlock
name|boolean
name|isLeafBlock
decl_stmt|;
DECL|field|lastSubFP
name|long
name|lastSubFP
decl_stmt|;
DECL|field|nextFloorLabel
name|int
name|nextFloorLabel
decl_stmt|;
DECL|field|numFollowFloorBlocks
name|int
name|numFollowFloorBlocks
decl_stmt|;
comment|// Next term to decode metaData; we decode metaData
comment|// lazily so that scanning to find the matching term is
comment|// fast and only if you find a match and app wants the
comment|// stats or docs/positions enums, will we decode the
comment|// metaData
DECL|field|metaDataUpto
name|int
name|metaDataUpto
decl_stmt|;
DECL|field|state
specifier|final
name|BlockTermState
name|state
decl_stmt|;
comment|// metadata buffer, holding monotonic values
DECL|field|longs
specifier|public
name|long
index|[]
name|longs
decl_stmt|;
comment|// metadata buffer, holding general values
DECL|field|bytes
specifier|public
name|byte
index|[]
name|bytes
decl_stmt|;
DECL|field|bytesReader
name|ByteArrayDataInput
name|bytesReader
decl_stmt|;
DECL|method|Frame
specifier|public
name|Frame
parameter_list|(
name|int
name|ord
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|ord
operator|=
name|ord
expr_stmt|;
name|this
operator|.
name|state
operator|=
name|fr
operator|.
name|parent
operator|.
name|postingsReader
operator|.
name|newTermState
argument_list|()
expr_stmt|;
name|this
operator|.
name|state
operator|.
name|totalTermFreq
operator|=
operator|-
literal|1
expr_stmt|;
name|this
operator|.
name|longs
operator|=
operator|new
name|long
index|[
name|fr
operator|.
name|longsSize
index|]
expr_stmt|;
block|}
DECL|method|setFloorData
specifier|public
name|void
name|setFloorData
parameter_list|(
name|ByteArrayDataInput
name|in
parameter_list|,
name|BytesRef
name|source
parameter_list|)
block|{
specifier|final
name|int
name|numBytes
init|=
name|source
operator|.
name|length
operator|-
operator|(
name|in
operator|.
name|getPosition
argument_list|()
operator|-
name|source
operator|.
name|offset
operator|)
decl_stmt|;
if|if
condition|(
name|numBytes
operator|>
name|floorData
operator|.
name|length
condition|)
block|{
name|floorData
operator|=
operator|new
name|byte
index|[
name|ArrayUtil
operator|.
name|oversize
argument_list|(
name|numBytes
argument_list|,
literal|1
argument_list|)
index|]
expr_stmt|;
block|}
name|System
operator|.
name|arraycopy
argument_list|(
name|source
operator|.
name|bytes
argument_list|,
name|source
operator|.
name|offset
operator|+
name|in
operator|.
name|getPosition
argument_list|()
argument_list|,
name|floorData
argument_list|,
literal|0
argument_list|,
name|numBytes
argument_list|)
expr_stmt|;
name|floorDataReader
operator|.
name|reset
argument_list|(
name|floorData
argument_list|,
literal|0
argument_list|,
name|numBytes
argument_list|)
expr_stmt|;
name|numFollowFloorBlocks
operator|=
name|floorDataReader
operator|.
name|readVInt
argument_list|()
expr_stmt|;
name|nextFloorLabel
operator|=
name|floorDataReader
operator|.
name|readByte
argument_list|()
operator|&
literal|0xff
expr_stmt|;
comment|//if (DEBUG) {
comment|//System.out.println("    setFloorData fpOrig=" + fpOrig + " bytes=" + new BytesRef(source.bytes, source.offset + in.getPosition(), numBytes) + " numFollowFloorBlocks=" + numFollowFloorBlocks + " nextFloorLabel=" + toHex(nextFloorLabel));
comment|//}
block|}
DECL|method|getTermBlockOrd
specifier|public
name|int
name|getTermBlockOrd
parameter_list|()
block|{
return|return
name|isLeafBlock
condition|?
name|nextEnt
else|:
name|state
operator|.
name|termBlockOrd
return|;
block|}
DECL|method|loadNextFloorBlock
name|void
name|loadNextFloorBlock
parameter_list|()
throws|throws
name|IOException
block|{
comment|//if (DEBUG) {
comment|//System.out.println("    loadNextFloorBlock fp=" + fp + " fpEnd=" + fpEnd);
comment|//}
assert|assert
name|arc
operator|==
literal|null
operator|||
name|isFloor
operator|:
literal|"arc="
operator|+
name|arc
operator|+
literal|" isFloor="
operator|+
name|isFloor
assert|;
name|fp
operator|=
name|fpEnd
expr_stmt|;
name|nextEnt
operator|=
operator|-
literal|1
expr_stmt|;
name|loadBlock
argument_list|()
expr_stmt|;
block|}
comment|/* Does initial decode of next block of terms; this        doesn't actually decode the docFreq, totalTermFreq,        postings details (frq/prx offset, etc.) metadata;        it just loads them as byte[] blobs which are then              decoded on-demand if the metadata is ever requested        for any term in this block.  This enables terms-only        intensive consumes (eg certain MTQs, respelling) to        not pay the price of decoding metadata they won't        use. */
DECL|method|loadBlock
name|void
name|loadBlock
parameter_list|()
throws|throws
name|IOException
block|{
comment|// Clone the IndexInput lazily, so that consumers
comment|// that just pull a TermsEnum to
comment|// seekExact(TermState) don't pay this cost:
name|initIndexInput
argument_list|()
expr_stmt|;
if|if
condition|(
name|nextEnt
operator|!=
operator|-
literal|1
condition|)
block|{
comment|// Already loaded
return|return;
block|}
comment|//System.out.println("blc=" + blockLoadCount);
name|in
operator|.
name|seek
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|int
name|code
init|=
name|in
operator|.
name|readVInt
argument_list|()
decl_stmt|;
name|entCount
operator|=
name|code
operator|>>>
literal|1
expr_stmt|;
assert|assert
name|entCount
operator|>
literal|0
assert|;
name|isLastInFloor
operator|=
operator|(
name|code
operator|&
literal|1
operator|)
operator|!=
literal|0
expr_stmt|;
assert|assert
name|arc
operator|==
literal|null
operator|||
operator|(
name|isLastInFloor
operator|||
name|isFloor
operator|)
assert|;
comment|// TODO: if suffixes were stored in random-access
comment|// array structure, then we could do binary search
comment|// instead of linear scan to find target term; eg
comment|// we could have simple array of offsets
comment|// term suffixes:
name|code
operator|=
name|in
operator|.
name|readVInt
argument_list|()
expr_stmt|;
name|isLeafBlock
operator|=
operator|(
name|code
operator|&
literal|1
operator|)
operator|!=
literal|0
expr_stmt|;
name|int
name|numBytes
init|=
name|code
operator|>>>
literal|1
decl_stmt|;
if|if
condition|(
name|suffixBytes
operator|.
name|length
operator|<
name|numBytes
condition|)
block|{
name|suffixBytes
operator|=
operator|new
name|byte
index|[
name|ArrayUtil
operator|.
name|oversize
argument_list|(
name|numBytes
argument_list|,
literal|1
argument_list|)
index|]
expr_stmt|;
block|}
name|in
operator|.
name|readBytes
argument_list|(
name|suffixBytes
argument_list|,
literal|0
argument_list|,
name|numBytes
argument_list|)
expr_stmt|;
name|suffixesReader
operator|.
name|reset
argument_list|(
name|suffixBytes
argument_list|,
literal|0
argument_list|,
name|numBytes
argument_list|)
expr_stmt|;
comment|/*if (DEBUG) {         if (arc == null) {         System.out.println("    loadBlock (next) fp=" + fp + " entCount=" + entCount + " prefixLen=" + prefix + " isLastInFloor=" + isLastInFloor + " leaf?=" + isLeafBlock);         } else {         System.out.println("    loadBlock (seek) fp=" + fp + " entCount=" + entCount + " prefixLen=" + prefix + " hasTerms?=" + hasTerms + " isFloor?=" + isFloor + " isLastInFloor=" + isLastInFloor + " leaf?=" + isLeafBlock);         }         }*/
comment|// stats
name|numBytes
operator|=
name|in
operator|.
name|readVInt
argument_list|()
expr_stmt|;
if|if
condition|(
name|statBytes
operator|.
name|length
operator|<
name|numBytes
condition|)
block|{
name|statBytes
operator|=
operator|new
name|byte
index|[
name|ArrayUtil
operator|.
name|oversize
argument_list|(
name|numBytes
argument_list|,
literal|1
argument_list|)
index|]
expr_stmt|;
block|}
name|in
operator|.
name|readBytes
argument_list|(
name|statBytes
argument_list|,
literal|0
argument_list|,
name|numBytes
argument_list|)
expr_stmt|;
name|statsReader
operator|.
name|reset
argument_list|(
name|statBytes
argument_list|,
literal|0
argument_list|,
name|numBytes
argument_list|)
expr_stmt|;
name|metaDataUpto
operator|=
literal|0
expr_stmt|;
name|state
operator|.
name|termBlockOrd
operator|=
literal|0
expr_stmt|;
name|nextEnt
operator|=
literal|0
expr_stmt|;
name|lastSubFP
operator|=
operator|-
literal|1
expr_stmt|;
comment|// TODO: we could skip this if !hasTerms; but
comment|// that's rare so won't help much
comment|// metadata
name|numBytes
operator|=
name|in
operator|.
name|readVInt
argument_list|()
expr_stmt|;
if|if
condition|(
name|bytes
operator|==
literal|null
condition|)
block|{
name|bytes
operator|=
operator|new
name|byte
index|[
name|ArrayUtil
operator|.
name|oversize
argument_list|(
name|numBytes
argument_list|,
literal|1
argument_list|)
index|]
expr_stmt|;
name|bytesReader
operator|=
operator|new
name|ByteArrayDataInput
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bytes
operator|.
name|length
operator|<
name|numBytes
condition|)
block|{
name|bytes
operator|=
operator|new
name|byte
index|[
name|ArrayUtil
operator|.
name|oversize
argument_list|(
name|numBytes
argument_list|,
literal|1
argument_list|)
index|]
expr_stmt|;
block|}
name|in
operator|.
name|readBytes
argument_list|(
name|bytes
argument_list|,
literal|0
argument_list|,
name|numBytes
argument_list|)
expr_stmt|;
name|bytesReader
operator|.
name|reset
argument_list|(
name|bytes
argument_list|,
literal|0
argument_list|,
name|numBytes
argument_list|)
expr_stmt|;
comment|// Sub-blocks of a single floor block are always
comment|// written one after another -- tail recurse:
name|fpEnd
operator|=
name|in
operator|.
name|getFilePointer
argument_list|()
expr_stmt|;
comment|// if (DEBUG) {
comment|//   System.out.println("      fpEnd=" + fpEnd);
comment|// }
block|}
DECL|method|rewind
name|void
name|rewind
parameter_list|()
block|{
comment|// Force reload:
name|fp
operator|=
name|fpOrig
expr_stmt|;
name|nextEnt
operator|=
operator|-
literal|1
expr_stmt|;
name|hasTerms
operator|=
name|hasTermsOrig
expr_stmt|;
if|if
condition|(
name|isFloor
condition|)
block|{
name|floorDataReader
operator|.
name|rewind
argument_list|()
expr_stmt|;
name|numFollowFloorBlocks
operator|=
name|floorDataReader
operator|.
name|readVInt
argument_list|()
expr_stmt|;
name|nextFloorLabel
operator|=
name|floorDataReader
operator|.
name|readByte
argument_list|()
operator|&
literal|0xff
expr_stmt|;
block|}
comment|/*       //System.out.println("rewind");       // Keeps the block loaded, but rewinds its state:       if (nextEnt> 0 || fp != fpOrig) {       if (DEBUG) {       System.out.println("      rewind frame ord=" + ord + " fpOrig=" + fpOrig + " fp=" + fp + " hasTerms?=" + hasTerms + " isFloor?=" + isFloor + " nextEnt=" + nextEnt + " prefixLen=" + prefix);       }       if (fp != fpOrig) {       fp = fpOrig;       nextEnt = -1;       } else {       nextEnt = 0;       }       hasTerms = hasTermsOrig;       if (isFloor) {       floorDataReader.rewind();       numFollowFloorBlocks = floorDataReader.readVInt();       nextFloorLabel = floorDataReader.readByte()& 0xff;       }       assert suffixBytes != null;       suffixesReader.rewind();       assert statBytes != null;       statsReader.rewind();       metaDataUpto = 0;       state.termBlockOrd = 0;       // TODO: skip this if !hasTerms?  Then postings       // impl wouldn't have to write useless 0 byte       postingsReader.resetTermsBlock(fieldInfo, state);       lastSubFP = -1;       } else if (DEBUG) {       System.out.println("      skip rewind fp=" + fp + " fpOrig=" + fpOrig + " nextEnt=" + nextEnt + " ord=" + ord);       }       */
block|}
DECL|method|next
specifier|public
name|boolean
name|next
parameter_list|()
block|{
return|return
name|isLeafBlock
condition|?
name|nextLeaf
argument_list|()
else|:
name|nextNonLeaf
argument_list|()
return|;
block|}
comment|// Decodes next entry; returns true if it's a sub-block
DECL|method|nextLeaf
specifier|public
name|boolean
name|nextLeaf
parameter_list|()
block|{
comment|//if (DEBUG) System.out.println("  frame.next ord=" + ord + " nextEnt=" + nextEnt + " entCount=" + entCount);
assert|assert
name|nextEnt
operator|!=
operator|-
literal|1
operator|&&
name|nextEnt
operator|<
name|entCount
operator|:
literal|"nextEnt="
operator|+
name|nextEnt
operator|+
literal|" entCount="
operator|+
name|entCount
operator|+
literal|" fp="
operator|+
name|fp
assert|;
name|nextEnt
operator|++
expr_stmt|;
name|suffix
operator|=
name|suffixesReader
operator|.
name|readVInt
argument_list|()
expr_stmt|;
name|startBytePos
operator|=
name|suffixesReader
operator|.
name|getPosition
argument_list|()
expr_stmt|;
name|term
operator|.
name|length
operator|=
name|prefix
operator|+
name|suffix
expr_stmt|;
if|if
condition|(
name|term
operator|.
name|bytes
operator|.
name|length
operator|<
name|term
operator|.
name|length
condition|)
block|{
name|term
operator|.
name|grow
argument_list|(
name|term
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
name|suffixesReader
operator|.
name|readBytes
argument_list|(
name|term
operator|.
name|bytes
argument_list|,
name|prefix
argument_list|,
name|suffix
argument_list|)
expr_stmt|;
comment|// A normal term
name|termExists
operator|=
literal|true
expr_stmt|;
return|return
literal|false
return|;
block|}
DECL|method|nextNonLeaf
specifier|public
name|boolean
name|nextNonLeaf
parameter_list|()
block|{
comment|//if (DEBUG) System.out.println("  frame.next ord=" + ord + " nextEnt=" + nextEnt + " entCount=" + entCount);
assert|assert
name|nextEnt
operator|!=
operator|-
literal|1
operator|&&
name|nextEnt
operator|<
name|entCount
operator|:
literal|"nextEnt="
operator|+
name|nextEnt
operator|+
literal|" entCount="
operator|+
name|entCount
operator|+
literal|" fp="
operator|+
name|fp
assert|;
name|nextEnt
operator|++
expr_stmt|;
specifier|final
name|int
name|code
init|=
name|suffixesReader
operator|.
name|readVInt
argument_list|()
decl_stmt|;
name|suffix
operator|=
name|code
operator|>>>
literal|1
expr_stmt|;
name|startBytePos
operator|=
name|suffixesReader
operator|.
name|getPosition
argument_list|()
expr_stmt|;
name|term
operator|.
name|length
operator|=
name|prefix
operator|+
name|suffix
expr_stmt|;
if|if
condition|(
name|term
operator|.
name|bytes
operator|.
name|length
operator|<
name|term
operator|.
name|length
condition|)
block|{
name|term
operator|.
name|grow
argument_list|(
name|term
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
name|suffixesReader
operator|.
name|readBytes
argument_list|(
name|term
operator|.
name|bytes
argument_list|,
name|prefix
argument_list|,
name|suffix
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|code
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
block|{
comment|// A normal term
name|termExists
operator|=
literal|true
expr_stmt|;
name|subCode
operator|=
literal|0
expr_stmt|;
name|state
operator|.
name|termBlockOrd
operator|++
expr_stmt|;
return|return
literal|false
return|;
block|}
else|else
block|{
comment|// A sub-block; make sub-FP absolute:
name|termExists
operator|=
literal|false
expr_stmt|;
name|subCode
operator|=
name|suffixesReader
operator|.
name|readVLong
argument_list|()
expr_stmt|;
name|lastSubFP
operator|=
name|fp
operator|-
name|subCode
expr_stmt|;
comment|//if (DEBUG) {
comment|//System.out.println("    lastSubFP=" + lastSubFP);
comment|//}
return|return
literal|true
return|;
block|}
block|}
comment|// TODO: make this array'd so we can do bin search?
comment|// likely not worth it?  need to measure how many
comment|// floor blocks we "typically" get
DECL|method|scanToFloorFrame
specifier|public
name|void
name|scanToFloorFrame
parameter_list|(
name|BytesRef
name|target
parameter_list|)
block|{
if|if
condition|(
operator|!
name|isFloor
operator|||
name|target
operator|.
name|length
operator|<=
name|prefix
condition|)
block|{
comment|// if (DEBUG) {
comment|//   System.out.println("    scanToFloorFrame skip: isFloor=" + isFloor + " target.length=" + target.length + " vs prefix=" + prefix);
comment|// }
return|return;
block|}
specifier|final
name|int
name|targetLabel
init|=
name|target
operator|.
name|bytes
index|[
name|target
operator|.
name|offset
operator|+
name|prefix
index|]
operator|&
literal|0xFF
decl_stmt|;
comment|// if (DEBUG) {
comment|//   System.out.println("    scanToFloorFrame fpOrig=" + fpOrig + " targetLabel=" + toHex(targetLabel) + " vs nextFloorLabel=" + toHex(nextFloorLabel) + " numFollowFloorBlocks=" + numFollowFloorBlocks);
comment|// }
if|if
condition|(
name|targetLabel
operator|<
name|nextFloorLabel
condition|)
block|{
comment|// if (DEBUG) {
comment|//   System.out.println("      already on correct block");
comment|// }
return|return;
block|}
assert|assert
name|numFollowFloorBlocks
operator|!=
literal|0
assert|;
name|long
name|newFP
init|=
name|fpOrig
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
specifier|final
name|long
name|code
init|=
name|floorDataReader
operator|.
name|readVLong
argument_list|()
decl_stmt|;
name|newFP
operator|=
name|fpOrig
operator|+
operator|(
name|code
operator|>>>
literal|1
operator|)
expr_stmt|;
name|hasTerms
operator|=
operator|(
name|code
operator|&
literal|1
operator|)
operator|!=
literal|0
expr_stmt|;
comment|// if (DEBUG) {
comment|//   System.out.println("      label=" + toHex(nextFloorLabel) + " fp=" + newFP + " hasTerms?=" + hasTerms + " numFollowFloor=" + numFollowFloorBlocks);
comment|// }
name|isLastInFloor
operator|=
name|numFollowFloorBlocks
operator|==
literal|1
expr_stmt|;
name|numFollowFloorBlocks
operator|--
expr_stmt|;
if|if
condition|(
name|isLastInFloor
condition|)
block|{
name|nextFloorLabel
operator|=
literal|256
expr_stmt|;
comment|// if (DEBUG) {
comment|//   System.out.println("        stop!  last block nextFloorLabel=" + toHex(nextFloorLabel));
comment|// }
break|break;
block|}
else|else
block|{
name|nextFloorLabel
operator|=
name|floorDataReader
operator|.
name|readByte
argument_list|()
operator|&
literal|0xff
expr_stmt|;
if|if
condition|(
name|targetLabel
operator|<
name|nextFloorLabel
condition|)
block|{
comment|// if (DEBUG) {
comment|//   System.out.println("        stop!  nextFloorLabel=" + toHex(nextFloorLabel));
comment|// }
break|break;
block|}
block|}
block|}
if|if
condition|(
name|newFP
operator|!=
name|fp
condition|)
block|{
comment|// Force re-load of the block:
comment|// if (DEBUG) {
comment|//   System.out.println("      force switch to fp=" + newFP + " oldFP=" + fp);
comment|// }
name|nextEnt
operator|=
operator|-
literal|1
expr_stmt|;
name|fp
operator|=
name|newFP
expr_stmt|;
block|}
else|else
block|{
comment|// if (DEBUG) {
comment|//   System.out.println("      stay on same fp=" + newFP);
comment|// }
block|}
block|}
DECL|method|decodeMetaData
specifier|public
name|void
name|decodeMetaData
parameter_list|()
throws|throws
name|IOException
block|{
comment|//if (DEBUG) System.out.println("\nBTTR.decodeMetadata seg=" + segment + " mdUpto=" + metaDataUpto + " vs termBlockOrd=" + state.termBlockOrd);
comment|// lazily catch up on metadata decode:
specifier|final
name|int
name|limit
init|=
name|getTermBlockOrd
argument_list|()
decl_stmt|;
name|boolean
name|absolute
init|=
name|metaDataUpto
operator|==
literal|0
decl_stmt|;
assert|assert
name|limit
operator|>
literal|0
assert|;
comment|// TODO: better API would be "jump straight to term=N"???
while|while
condition|(
name|metaDataUpto
operator|<
name|limit
condition|)
block|{
comment|// TODO: we could make "tiers" of metadata, ie,
comment|// decode docFreq/totalTF but don't decode postings
comment|// metadata; this way caller could get
comment|// docFreq/totalTF w/o paying decode cost for
comment|// postings
comment|// TODO: if docFreq were bulk decoded we could
comment|// just skipN here:
comment|// stats
name|state
operator|.
name|docFreq
operator|=
name|statsReader
operator|.
name|readVInt
argument_list|()
expr_stmt|;
comment|//if (DEBUG) System.out.println("    dF=" + state.docFreq);
if|if
condition|(
name|fr
operator|.
name|fieldInfo
operator|.
name|getIndexOptions
argument_list|()
operator|!=
name|IndexOptions
operator|.
name|DOCS_ONLY
condition|)
block|{
name|state
operator|.
name|totalTermFreq
operator|=
name|state
operator|.
name|docFreq
operator|+
name|statsReader
operator|.
name|readVLong
argument_list|()
expr_stmt|;
comment|//if (DEBUG) System.out.println("    totTF=" + state.totalTermFreq);
block|}
comment|// metadata
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fr
operator|.
name|longsSize
condition|;
name|i
operator|++
control|)
block|{
name|longs
index|[
name|i
index|]
operator|=
name|bytesReader
operator|.
name|readVLong
argument_list|()
expr_stmt|;
block|}
name|fr
operator|.
name|parent
operator|.
name|postingsReader
operator|.
name|decodeTerm
argument_list|(
name|longs
argument_list|,
name|bytesReader
argument_list|,
name|fr
operator|.
name|fieldInfo
argument_list|,
name|state
argument_list|,
name|absolute
argument_list|)
expr_stmt|;
name|metaDataUpto
operator|++
expr_stmt|;
name|absolute
operator|=
literal|false
expr_stmt|;
block|}
name|state
operator|.
name|termBlockOrd
operator|=
name|metaDataUpto
expr_stmt|;
block|}
comment|// Used only by assert
DECL|method|prefixMatches
specifier|private
name|boolean
name|prefixMatches
parameter_list|(
name|BytesRef
name|target
parameter_list|)
block|{
for|for
control|(
name|int
name|bytePos
init|=
literal|0
init|;
name|bytePos
operator|<
name|prefix
condition|;
name|bytePos
operator|++
control|)
block|{
if|if
condition|(
name|target
operator|.
name|bytes
index|[
name|target
operator|.
name|offset
operator|+
name|bytePos
index|]
operator|!=
name|term
operator|.
name|bytes
index|[
name|bytePos
index|]
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
comment|// Scans to sub-block that has this target fp; only
comment|// called by next(); NOTE: does not set
comment|// startBytePos/suffix as a side effect
DECL|method|scanToSubBlock
specifier|public
name|void
name|scanToSubBlock
parameter_list|(
name|long
name|subFP
parameter_list|)
block|{
assert|assert
operator|!
name|isLeafBlock
assert|;
comment|//if (DEBUG) System.out.println("  scanToSubBlock fp=" + fp + " subFP=" + subFP + " entCount=" + entCount + " lastSubFP=" + lastSubFP);
comment|//assert nextEnt == 0;
if|if
condition|(
name|lastSubFP
operator|==
name|subFP
condition|)
block|{
comment|//if (DEBUG) System.out.println("    already positioned");
return|return;
block|}
assert|assert
name|subFP
operator|<
name|fp
operator|:
literal|"fp="
operator|+
name|fp
operator|+
literal|" subFP="
operator|+
name|subFP
assert|;
specifier|final
name|long
name|targetSubCode
init|=
name|fp
operator|-
name|subFP
decl_stmt|;
comment|//if (DEBUG) System.out.println("    targetSubCode=" + targetSubCode);
while|while
condition|(
literal|true
condition|)
block|{
assert|assert
name|nextEnt
operator|<
name|entCount
assert|;
name|nextEnt
operator|++
expr_stmt|;
specifier|final
name|int
name|code
init|=
name|suffixesReader
operator|.
name|readVInt
argument_list|()
decl_stmt|;
name|suffixesReader
operator|.
name|skipBytes
argument_list|(
name|isLeafBlock
condition|?
name|code
else|:
name|code
operator|>>>
literal|1
argument_list|)
expr_stmt|;
comment|//if (DEBUG) System.out.println("    " + nextEnt + " (of " + entCount + ") ent isSubBlock=" + ((code&1)==1));
if|if
condition|(
operator|(
name|code
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
block|{
specifier|final
name|long
name|subCode
init|=
name|suffixesReader
operator|.
name|readVLong
argument_list|()
decl_stmt|;
comment|//if (DEBUG) System.out.println("      subCode=" + subCode);
if|if
condition|(
name|targetSubCode
operator|==
name|subCode
condition|)
block|{
comment|//if (DEBUG) System.out.println("        match!");
name|lastSubFP
operator|=
name|subFP
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
name|state
operator|.
name|termBlockOrd
operator|++
expr_stmt|;
block|}
block|}
block|}
comment|// NOTE: sets startBytePos/suffix as a side effect
DECL|method|scanToTerm
specifier|public
name|SeekStatus
name|scanToTerm
parameter_list|(
name|BytesRef
name|target
parameter_list|,
name|boolean
name|exactOnly
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|isLeafBlock
condition|?
name|scanToTermLeaf
argument_list|(
name|target
argument_list|,
name|exactOnly
argument_list|)
else|:
name|scanToTermNonLeaf
argument_list|(
name|target
argument_list|,
name|exactOnly
argument_list|)
return|;
block|}
DECL|field|startBytePos
specifier|private
name|int
name|startBytePos
decl_stmt|;
DECL|field|suffix
specifier|private
name|int
name|suffix
decl_stmt|;
DECL|field|subCode
specifier|private
name|long
name|subCode
decl_stmt|;
comment|// Target's prefix matches this block's prefix; we
comment|// scan the entries check if the suffix matches.
DECL|method|scanToTermLeaf
specifier|public
name|SeekStatus
name|scanToTermLeaf
parameter_list|(
name|BytesRef
name|target
parameter_list|,
name|boolean
name|exactOnly
parameter_list|)
throws|throws
name|IOException
block|{
comment|// if (DEBUG) System.out.println("    scanToTermLeaf: block fp=" + fp + " prefix=" + prefix + " nextEnt=" + nextEnt + " (of " + entCount + ") target=" + brToString(target) + " term=" + brToString(term));
assert|assert
name|nextEnt
operator|!=
operator|-
literal|1
assert|;
name|termExists
operator|=
literal|true
expr_stmt|;
name|subCode
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|nextEnt
operator|==
name|entCount
condition|)
block|{
if|if
condition|(
name|exactOnly
condition|)
block|{
name|fillTerm
argument_list|()
expr_stmt|;
block|}
return|return
name|SeekStatus
operator|.
name|END
return|;
block|}
assert|assert
name|prefixMatches
argument_list|(
name|target
argument_list|)
assert|;
comment|// Loop over each entry (term or sub-block) in this block:
comment|//nextTerm: while(nextEnt< entCount) {
name|nextTerm
label|:
while|while
condition|(
literal|true
condition|)
block|{
name|nextEnt
operator|++
expr_stmt|;
name|suffix
operator|=
name|suffixesReader
operator|.
name|readVInt
argument_list|()
expr_stmt|;
comment|// if (DEBUG) {
comment|//   BytesRef suffixBytesRef = new BytesRef();
comment|//   suffixBytesRef.bytes = suffixBytes;
comment|//   suffixBytesRef.offset = suffixesReader.getPosition();
comment|//   suffixBytesRef.length = suffix;
comment|//   System.out.println("      cycle: term " + (nextEnt-1) + " (of " + entCount + ") suffix=" + brToString(suffixBytesRef));
comment|// }
specifier|final
name|int
name|termLen
init|=
name|prefix
operator|+
name|suffix
decl_stmt|;
name|startBytePos
operator|=
name|suffixesReader
operator|.
name|getPosition
argument_list|()
expr_stmt|;
name|suffixesReader
operator|.
name|skipBytes
argument_list|(
name|suffix
argument_list|)
expr_stmt|;
specifier|final
name|int
name|targetLimit
init|=
name|target
operator|.
name|offset
operator|+
operator|(
name|target
operator|.
name|length
operator|<
name|termLen
condition|?
name|target
operator|.
name|length
else|:
name|termLen
operator|)
decl_stmt|;
name|int
name|targetPos
init|=
name|target
operator|.
name|offset
operator|+
name|prefix
decl_stmt|;
comment|// Loop over bytes in the suffix, comparing to
comment|// the target
name|int
name|bytePos
init|=
name|startBytePos
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
specifier|final
name|int
name|cmp
decl_stmt|;
specifier|final
name|boolean
name|stop
decl_stmt|;
if|if
condition|(
name|targetPos
operator|<
name|targetLimit
condition|)
block|{
name|cmp
operator|=
operator|(
name|suffixBytes
index|[
name|bytePos
operator|++
index|]
operator|&
literal|0xFF
operator|)
operator|-
operator|(
name|target
operator|.
name|bytes
index|[
name|targetPos
operator|++
index|]
operator|&
literal|0xFF
operator|)
expr_stmt|;
name|stop
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
assert|assert
name|targetPos
operator|==
name|targetLimit
assert|;
name|cmp
operator|=
name|termLen
operator|-
name|target
operator|.
name|length
expr_stmt|;
name|stop
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|cmp
operator|<
literal|0
condition|)
block|{
comment|// Current entry is still before the target;
comment|// keep scanning
if|if
condition|(
name|nextEnt
operator|==
name|entCount
condition|)
block|{
if|if
condition|(
name|exactOnly
condition|)
block|{
name|fillTerm
argument_list|()
expr_stmt|;
block|}
comment|// We are done scanning this block
break|break
name|nextTerm
break|;
block|}
else|else
block|{
continue|continue
name|nextTerm
continue|;
block|}
block|}
elseif|else
if|if
condition|(
name|cmp
operator|>
literal|0
condition|)
block|{
comment|// Done!  Current entry is after target --
comment|// return NOT_FOUND:
name|fillTerm
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|exactOnly
operator|&&
operator|!
name|termExists
condition|)
block|{
comment|// We are on a sub-block, and caller wants
comment|// us to position to the next term after
comment|// the target, so we must recurse into the
comment|// sub-frame(s):
name|currentFrame
operator|=
name|pushFrame
argument_list|(
literal|null
argument_list|,
name|currentFrame
operator|.
name|lastSubFP
argument_list|,
name|termLen
argument_list|)
expr_stmt|;
name|currentFrame
operator|.
name|loadBlock
argument_list|()
expr_stmt|;
while|while
condition|(
name|currentFrame
operator|.
name|next
argument_list|()
condition|)
block|{
name|currentFrame
operator|=
name|pushFrame
argument_list|(
literal|null
argument_list|,
name|currentFrame
operator|.
name|lastSubFP
argument_list|,
name|term
operator|.
name|length
argument_list|)
expr_stmt|;
name|currentFrame
operator|.
name|loadBlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|//if (DEBUG) System.out.println("        not found");
return|return
name|SeekStatus
operator|.
name|NOT_FOUND
return|;
block|}
elseif|else
if|if
condition|(
name|stop
condition|)
block|{
comment|// Exact match!
comment|// This cannot be a sub-block because we
comment|// would have followed the index to this
comment|// sub-block from the start:
assert|assert
name|termExists
assert|;
name|fillTerm
argument_list|()
expr_stmt|;
comment|//if (DEBUG) System.out.println("        found!");
return|return
name|SeekStatus
operator|.
name|FOUND
return|;
block|}
block|}
block|}
comment|// It is possible (and OK) that terms index pointed us
comment|// at this block, but, we scanned the entire block and
comment|// did not find the term to position to.  This happens
comment|// when the target is after the last term in the block
comment|// (but, before the next term in the index).  EG
comment|// target could be foozzz, and terms index pointed us
comment|// to the foo* block, but the last term in this block
comment|// was fooz (and, eg, first term in the next block will
comment|// bee fop).
comment|//if (DEBUG) System.out.println("      block end");
if|if
condition|(
name|exactOnly
condition|)
block|{
name|fillTerm
argument_list|()
expr_stmt|;
block|}
comment|// TODO: not consistent that in the
comment|// not-exact case we don't next() into the next
comment|// frame here
return|return
name|SeekStatus
operator|.
name|END
return|;
block|}
comment|// Target's prefix matches this block's prefix; we
comment|// scan the entries check if the suffix matches.
DECL|method|scanToTermNonLeaf
specifier|public
name|SeekStatus
name|scanToTermNonLeaf
parameter_list|(
name|BytesRef
name|target
parameter_list|,
name|boolean
name|exactOnly
parameter_list|)
throws|throws
name|IOException
block|{
comment|//if (DEBUG) System.out.println("    scanToTermNonLeaf: block fp=" + fp + " prefix=" + prefix + " nextEnt=" + nextEnt + " (of " + entCount + ") target=" + brToString(target) + " term=" + brToString(term));
assert|assert
name|nextEnt
operator|!=
operator|-
literal|1
assert|;
if|if
condition|(
name|nextEnt
operator|==
name|entCount
condition|)
block|{
if|if
condition|(
name|exactOnly
condition|)
block|{
name|fillTerm
argument_list|()
expr_stmt|;
name|termExists
operator|=
name|subCode
operator|==
literal|0
expr_stmt|;
block|}
return|return
name|SeekStatus
operator|.
name|END
return|;
block|}
assert|assert
name|prefixMatches
argument_list|(
name|target
argument_list|)
assert|;
comment|// Loop over each entry (term or sub-block) in this block:
comment|//nextTerm: while(nextEnt< entCount) {
name|nextTerm
label|:
while|while
condition|(
literal|true
condition|)
block|{
name|nextEnt
operator|++
expr_stmt|;
specifier|final
name|int
name|code
init|=
name|suffixesReader
operator|.
name|readVInt
argument_list|()
decl_stmt|;
name|suffix
operator|=
name|code
operator|>>>
literal|1
expr_stmt|;
comment|// if (DEBUG) {
comment|//   BytesRef suffixBytesRef = new BytesRef();
comment|//   suffixBytesRef.bytes = suffixBytes;
comment|//   suffixBytesRef.offset = suffixesReader.getPosition();
comment|//   suffixBytesRef.length = suffix;
comment|//   System.out.println("      cycle: " + ((code&1)==1 ? "sub-block" : "term") + " " + (nextEnt-1) + " (of " + entCount + ") suffix=" + brToString(suffixBytesRef));
comment|// }
name|termExists
operator|=
operator|(
name|code
operator|&
literal|1
operator|)
operator|==
literal|0
expr_stmt|;
specifier|final
name|int
name|termLen
init|=
name|prefix
operator|+
name|suffix
decl_stmt|;
name|startBytePos
operator|=
name|suffixesReader
operator|.
name|getPosition
argument_list|()
expr_stmt|;
name|suffixesReader
operator|.
name|skipBytes
argument_list|(
name|suffix
argument_list|)
expr_stmt|;
if|if
condition|(
name|termExists
condition|)
block|{
name|state
operator|.
name|termBlockOrd
operator|++
expr_stmt|;
name|subCode
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|subCode
operator|=
name|suffixesReader
operator|.
name|readVLong
argument_list|()
expr_stmt|;
name|lastSubFP
operator|=
name|fp
operator|-
name|subCode
expr_stmt|;
block|}
specifier|final
name|int
name|targetLimit
init|=
name|target
operator|.
name|offset
operator|+
operator|(
name|target
operator|.
name|length
operator|<
name|termLen
condition|?
name|target
operator|.
name|length
else|:
name|termLen
operator|)
decl_stmt|;
name|int
name|targetPos
init|=
name|target
operator|.
name|offset
operator|+
name|prefix
decl_stmt|;
comment|// Loop over bytes in the suffix, comparing to
comment|// the target
name|int
name|bytePos
init|=
name|startBytePos
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
specifier|final
name|int
name|cmp
decl_stmt|;
specifier|final
name|boolean
name|stop
decl_stmt|;
if|if
condition|(
name|targetPos
operator|<
name|targetLimit
condition|)
block|{
name|cmp
operator|=
operator|(
name|suffixBytes
index|[
name|bytePos
operator|++
index|]
operator|&
literal|0xFF
operator|)
operator|-
operator|(
name|target
operator|.
name|bytes
index|[
name|targetPos
operator|++
index|]
operator|&
literal|0xFF
operator|)
expr_stmt|;
name|stop
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
assert|assert
name|targetPos
operator|==
name|targetLimit
assert|;
name|cmp
operator|=
name|termLen
operator|-
name|target
operator|.
name|length
expr_stmt|;
name|stop
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|cmp
operator|<
literal|0
condition|)
block|{
comment|// Current entry is still before the target;
comment|// keep scanning
if|if
condition|(
name|nextEnt
operator|==
name|entCount
condition|)
block|{
if|if
condition|(
name|exactOnly
condition|)
block|{
name|fillTerm
argument_list|()
expr_stmt|;
comment|//termExists = true;
block|}
comment|// We are done scanning this block
break|break
name|nextTerm
break|;
block|}
else|else
block|{
continue|continue
name|nextTerm
continue|;
block|}
block|}
elseif|else
if|if
condition|(
name|cmp
operator|>
literal|0
condition|)
block|{
comment|// Done!  Current entry is after target --
comment|// return NOT_FOUND:
name|fillTerm
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|exactOnly
operator|&&
operator|!
name|termExists
condition|)
block|{
comment|// We are on a sub-block, and caller wants
comment|// us to position to the next term after
comment|// the target, so we must recurse into the
comment|// sub-frame(s):
name|currentFrame
operator|=
name|pushFrame
argument_list|(
literal|null
argument_list|,
name|currentFrame
operator|.
name|lastSubFP
argument_list|,
name|termLen
argument_list|)
expr_stmt|;
name|currentFrame
operator|.
name|loadBlock
argument_list|()
expr_stmt|;
while|while
condition|(
name|currentFrame
operator|.
name|next
argument_list|()
condition|)
block|{
name|currentFrame
operator|=
name|pushFrame
argument_list|(
literal|null
argument_list|,
name|currentFrame
operator|.
name|lastSubFP
argument_list|,
name|term
operator|.
name|length
argument_list|)
expr_stmt|;
name|currentFrame
operator|.
name|loadBlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|//if (DEBUG) System.out.println("        not found");
return|return
name|SeekStatus
operator|.
name|NOT_FOUND
return|;
block|}
elseif|else
if|if
condition|(
name|stop
condition|)
block|{
comment|// Exact match!
comment|// This cannot be a sub-block because we
comment|// would have followed the index to this
comment|// sub-block from the start:
assert|assert
name|termExists
assert|;
name|fillTerm
argument_list|()
expr_stmt|;
comment|//if (DEBUG) System.out.println("        found!");
return|return
name|SeekStatus
operator|.
name|FOUND
return|;
block|}
block|}
block|}
comment|// It is possible (and OK) that terms index pointed us
comment|// at this block, but, we scanned the entire block and
comment|// did not find the term to position to.  This happens
comment|// when the target is after the last term in the block
comment|// (but, before the next term in the index).  EG
comment|// target could be foozzz, and terms index pointed us
comment|// to the foo* block, but the last term in this block
comment|// was fooz (and, eg, first term in the next block will
comment|// bee fop).
comment|//if (DEBUG) System.out.println("      block end");
if|if
condition|(
name|exactOnly
condition|)
block|{
name|fillTerm
argument_list|()
expr_stmt|;
block|}
comment|// TODO: not consistent that in the
comment|// not-exact case we don't next() into the next
comment|// frame here
return|return
name|SeekStatus
operator|.
name|END
return|;
block|}
DECL|method|fillTerm
specifier|private
name|void
name|fillTerm
parameter_list|()
block|{
specifier|final
name|int
name|termLength
init|=
name|prefix
operator|+
name|suffix
decl_stmt|;
name|term
operator|.
name|length
operator|=
name|prefix
operator|+
name|suffix
expr_stmt|;
if|if
condition|(
name|term
operator|.
name|bytes
operator|.
name|length
operator|<
name|termLength
condition|)
block|{
name|term
operator|.
name|grow
argument_list|(
name|termLength
argument_list|)
expr_stmt|;
block|}
name|System
operator|.
name|arraycopy
argument_list|(
name|suffixBytes
argument_list|,
name|startBytePos
argument_list|,
name|term
operator|.
name|bytes
argument_list|,
name|prefix
argument_list|,
name|suffix
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_class
end_unit
