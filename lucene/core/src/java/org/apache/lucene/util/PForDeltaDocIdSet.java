begin_unit
begin_package
DECL|package|org.apache.lucene.util
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
package|;
end_package
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|DocIdSet
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|DocIdSetIterator
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|packed
operator|.
name|MonotonicAppendingLongBuffer
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|packed
operator|.
name|PackedInts
import|;
end_import
begin_comment
comment|/**  * {@link DocIdSet} implementation based on pfor-delta encoding.  *<p>This implementation is inspired from LinkedIn's Kamikaze  * (http://data.linkedin.com/opensource/kamikaze) and Daniel Lemire's JavaFastPFOR  * (https://github.com/lemire/JavaFastPFOR).</p>  *<p>On the contrary to the original PFOR paper, exceptions are encoded with  * FOR instead of Simple16.</p>  */
end_comment
begin_class
DECL|class|PForDeltaDocIdSet
specifier|public
specifier|final
class|class
name|PForDeltaDocIdSet
extends|extends
name|DocIdSet
implements|implements
name|Accountable
block|{
DECL|field|BASE_RAM_BYTES_USED
specifier|private
specifier|static
specifier|final
name|long
name|BASE_RAM_BYTES_USED
init|=
name|RamUsageEstimator
operator|.
name|shallowSizeOfInstance
argument_list|(
name|PForDeltaDocIdSet
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|BLOCK_SIZE
specifier|static
specifier|final
name|int
name|BLOCK_SIZE
init|=
literal|128
decl_stmt|;
DECL|field|MAX_EXCEPTIONS
specifier|static
specifier|final
name|int
name|MAX_EXCEPTIONS
init|=
literal|24
decl_stmt|;
comment|// no more than 24 exceptions per block
DECL|field|DECODERS
specifier|static
specifier|final
name|PackedInts
operator|.
name|Decoder
index|[]
name|DECODERS
init|=
operator|new
name|PackedInts
operator|.
name|Decoder
index|[
literal|32
index|]
decl_stmt|;
DECL|field|ITERATIONS
specifier|static
specifier|final
name|int
index|[]
name|ITERATIONS
init|=
operator|new
name|int
index|[
literal|32
index|]
decl_stmt|;
DECL|field|BYTE_BLOCK_COUNTS
specifier|static
specifier|final
name|int
index|[]
name|BYTE_BLOCK_COUNTS
init|=
operator|new
name|int
index|[
literal|32
index|]
decl_stmt|;
DECL|field|MAX_BYTE_BLOCK_COUNT
specifier|static
specifier|final
name|int
name|MAX_BYTE_BLOCK_COUNT
decl_stmt|;
DECL|field|SINGLE_ZERO_BUFFER
specifier|static
specifier|final
name|MonotonicAppendingLongBuffer
name|SINGLE_ZERO_BUFFER
init|=
operator|new
name|MonotonicAppendingLongBuffer
argument_list|(
literal|0
argument_list|,
literal|64
argument_list|,
name|PackedInts
operator|.
name|COMPACT
argument_list|)
decl_stmt|;
DECL|field|EMPTY
specifier|static
specifier|final
name|PForDeltaDocIdSet
name|EMPTY
init|=
operator|new
name|PForDeltaDocIdSet
argument_list|(
literal|null
argument_list|,
literal|0
argument_list|,
name|Integer
operator|.
name|MAX_VALUE
argument_list|,
name|SINGLE_ZERO_BUFFER
argument_list|,
name|SINGLE_ZERO_BUFFER
argument_list|)
decl_stmt|;
DECL|field|LAST_BLOCK
specifier|static
specifier|final
name|int
name|LAST_BLOCK
init|=
literal|1
operator|<<
literal|5
decl_stmt|;
comment|// flag to indicate the last block
DECL|field|HAS_EXCEPTIONS
specifier|static
specifier|final
name|int
name|HAS_EXCEPTIONS
init|=
literal|1
operator|<<
literal|6
decl_stmt|;
DECL|field|UNARY
specifier|static
specifier|final
name|int
name|UNARY
init|=
literal|1
operator|<<
literal|7
decl_stmt|;
static|static
block|{
name|SINGLE_ZERO_BUFFER
operator|.
name|add
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|SINGLE_ZERO_BUFFER
operator|.
name|freeze
argument_list|()
expr_stmt|;
name|int
name|maxByteBLockCount
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|ITERATIONS
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
name|DECODERS
index|[
name|i
index|]
operator|=
name|PackedInts
operator|.
name|getDecoder
argument_list|(
name|PackedInts
operator|.
name|Format
operator|.
name|PACKED
argument_list|,
name|PackedInts
operator|.
name|VERSION_CURRENT
argument_list|,
name|i
argument_list|)
expr_stmt|;
assert|assert
name|BLOCK_SIZE
operator|%
name|DECODERS
index|[
name|i
index|]
operator|.
name|byteValueCount
argument_list|()
operator|==
literal|0
assert|;
name|ITERATIONS
index|[
name|i
index|]
operator|=
name|BLOCK_SIZE
operator|/
name|DECODERS
index|[
name|i
index|]
operator|.
name|byteValueCount
argument_list|()
expr_stmt|;
name|BYTE_BLOCK_COUNTS
index|[
name|i
index|]
operator|=
name|ITERATIONS
index|[
name|i
index|]
operator|*
name|DECODERS
index|[
name|i
index|]
operator|.
name|byteBlockCount
argument_list|()
expr_stmt|;
name|maxByteBLockCount
operator|=
name|Math
operator|.
name|max
argument_list|(
name|maxByteBLockCount
argument_list|,
name|DECODERS
index|[
name|i
index|]
operator|.
name|byteBlockCount
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|MAX_BYTE_BLOCK_COUNT
operator|=
name|maxByteBLockCount
expr_stmt|;
block|}
comment|/** A builder for {@link PForDeltaDocIdSet}. */
DECL|class|Builder
specifier|public
specifier|static
class|class
name|Builder
block|{
DECL|field|data
specifier|final
name|GrowableByteArrayDataOutput
name|data
decl_stmt|;
DECL|field|buffer
specifier|final
name|int
index|[]
name|buffer
init|=
operator|new
name|int
index|[
name|BLOCK_SIZE
index|]
decl_stmt|;
DECL|field|exceptionIndices
specifier|final
name|int
index|[]
name|exceptionIndices
init|=
operator|new
name|int
index|[
name|BLOCK_SIZE
index|]
decl_stmt|;
DECL|field|exceptions
specifier|final
name|int
index|[]
name|exceptions
init|=
operator|new
name|int
index|[
name|BLOCK_SIZE
index|]
decl_stmt|;
DECL|field|bufferSize
name|int
name|bufferSize
decl_stmt|;
DECL|field|previousDoc
name|int
name|previousDoc
decl_stmt|;
DECL|field|cardinality
name|int
name|cardinality
decl_stmt|;
DECL|field|indexInterval
name|int
name|indexInterval
decl_stmt|;
DECL|field|numBlocks
name|int
name|numBlocks
decl_stmt|;
comment|// temporary variables used when compressing blocks
DECL|field|freqs
specifier|final
name|int
index|[]
name|freqs
init|=
operator|new
name|int
index|[
literal|32
index|]
decl_stmt|;
DECL|field|bitsPerValue
name|int
name|bitsPerValue
decl_stmt|;
DECL|field|numExceptions
name|int
name|numExceptions
decl_stmt|;
DECL|field|bitsPerException
name|int
name|bitsPerException
decl_stmt|;
comment|/** Sole constructor. */
DECL|method|Builder
specifier|public
name|Builder
parameter_list|()
block|{
name|data
operator|=
operator|new
name|GrowableByteArrayDataOutput
argument_list|(
literal|128
argument_list|)
expr_stmt|;
name|bufferSize
operator|=
literal|0
expr_stmt|;
name|previousDoc
operator|=
operator|-
literal|1
expr_stmt|;
name|indexInterval
operator|=
literal|2
expr_stmt|;
name|cardinality
operator|=
literal|0
expr_stmt|;
name|numBlocks
operator|=
literal|0
expr_stmt|;
block|}
comment|/** Set the index interval. Every<code>indexInterval</code>-th block will      * be stored in the index. Set to {@link Integer#MAX_VALUE} to disable indexing. */
DECL|method|setIndexInterval
specifier|public
name|Builder
name|setIndexInterval
parameter_list|(
name|int
name|indexInterval
parameter_list|)
block|{
if|if
condition|(
name|indexInterval
operator|<
literal|1
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"indexInterval must be>= 1"
argument_list|)
throw|;
block|}
name|this
operator|.
name|indexInterval
operator|=
name|indexInterval
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/** Add a document to this builder. Documents must be added in order. */
DECL|method|add
specifier|public
name|Builder
name|add
parameter_list|(
name|int
name|doc
parameter_list|)
block|{
if|if
condition|(
name|doc
operator|<=
name|previousDoc
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Doc IDs must be provided in order, but previousDoc="
operator|+
name|previousDoc
operator|+
literal|" and doc="
operator|+
name|doc
argument_list|)
throw|;
block|}
name|buffer
index|[
name|bufferSize
operator|++
index|]
operator|=
name|doc
operator|-
name|previousDoc
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|bufferSize
operator|==
name|BLOCK_SIZE
condition|)
block|{
name|encodeBlock
argument_list|()
expr_stmt|;
name|bufferSize
operator|=
literal|0
expr_stmt|;
block|}
name|previousDoc
operator|=
name|doc
expr_stmt|;
operator|++
name|cardinality
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/** Convenience method to add the content of a {@link DocIdSetIterator} to this builder. */
DECL|method|add
specifier|public
name|Builder
name|add
parameter_list|(
name|DocIdSetIterator
name|it
parameter_list|)
throws|throws
name|IOException
block|{
for|for
control|(
name|int
name|doc
init|=
name|it
operator|.
name|nextDoc
argument_list|()
init|;
name|doc
operator|!=
name|DocIdSetIterator
operator|.
name|NO_MORE_DOCS
condition|;
name|doc
operator|=
name|it
operator|.
name|nextDoc
argument_list|()
control|)
block|{
name|add
argument_list|(
name|doc
argument_list|)
expr_stmt|;
block|}
return|return
name|this
return|;
block|}
DECL|method|computeFreqs
name|void
name|computeFreqs
parameter_list|()
block|{
name|Arrays
operator|.
name|fill
argument_list|(
name|freqs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|bufferSize
condition|;
operator|++
name|i
control|)
block|{
operator|++
name|freqs
index|[
literal|32
operator|-
name|Integer
operator|.
name|numberOfLeadingZeros
argument_list|(
name|buffer
index|[
name|i
index|]
argument_list|)
index|]
expr_stmt|;
block|}
block|}
DECL|method|pforBlockSize
name|int
name|pforBlockSize
parameter_list|(
name|int
name|bitsPerValue
parameter_list|,
name|int
name|numExceptions
parameter_list|,
name|int
name|bitsPerException
parameter_list|)
block|{
specifier|final
name|PackedInts
operator|.
name|Format
name|format
init|=
name|PackedInts
operator|.
name|Format
operator|.
name|PACKED
decl_stmt|;
name|long
name|blockSize
init|=
literal|1
comment|// header: number of bits per value
operator|+
name|format
operator|.
name|byteCount
argument_list|(
name|PackedInts
operator|.
name|VERSION_CURRENT
argument_list|,
name|BLOCK_SIZE
argument_list|,
name|bitsPerValue
argument_list|)
decl_stmt|;
if|if
condition|(
name|numExceptions
operator|>
literal|0
condition|)
block|{
name|blockSize
operator|+=
literal|2
comment|// 2 additional bytes in case of exceptions: numExceptions and bitsPerException
operator|+
name|numExceptions
comment|// indices of the exceptions
operator|+
name|format
operator|.
name|byteCount
argument_list|(
name|PackedInts
operator|.
name|VERSION_CURRENT
argument_list|,
name|numExceptions
argument_list|,
name|bitsPerException
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bufferSize
operator|<
name|BLOCK_SIZE
condition|)
block|{
name|blockSize
operator|+=
literal|1
expr_stmt|;
comment|// length of the block
block|}
return|return
operator|(
name|int
operator|)
name|blockSize
return|;
block|}
DECL|method|unaryBlockSize
name|int
name|unaryBlockSize
parameter_list|()
block|{
name|int
name|deltaSum
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|BLOCK_SIZE
condition|;
operator|++
name|i
control|)
block|{
name|deltaSum
operator|+=
literal|1
operator|+
name|buffer
index|[
name|i
index|]
expr_stmt|;
block|}
name|int
name|blockSize
init|=
operator|(
name|deltaSum
operator|+
literal|0x07
operator|)
operator|>>>
literal|3
decl_stmt|;
comment|// round to the next byte
operator|++
name|blockSize
expr_stmt|;
comment|// header
if|if
condition|(
name|bufferSize
operator|<
name|BLOCK_SIZE
condition|)
block|{
name|blockSize
operator|+=
literal|1
expr_stmt|;
comment|// length of the block
block|}
return|return
name|blockSize
return|;
block|}
DECL|method|computeOptimalNumberOfBits
name|int
name|computeOptimalNumberOfBits
parameter_list|()
block|{
name|computeFreqs
argument_list|()
expr_stmt|;
name|bitsPerValue
operator|=
literal|31
expr_stmt|;
name|numExceptions
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|bitsPerValue
operator|>
literal|0
operator|&&
name|freqs
index|[
name|bitsPerValue
index|]
operator|==
literal|0
condition|)
block|{
operator|--
name|bitsPerValue
expr_stmt|;
block|}
specifier|final
name|int
name|actualBitsPerValue
init|=
name|bitsPerValue
decl_stmt|;
name|int
name|blockSize
init|=
name|pforBlockSize
argument_list|(
name|bitsPerValue
argument_list|,
name|numExceptions
argument_list|,
name|bitsPerException
argument_list|)
decl_stmt|;
comment|// Now try different values for bitsPerValue and pick the best one
for|for
control|(
name|int
name|bitsPerValue
init|=
name|this
operator|.
name|bitsPerValue
operator|-
literal|1
init|,
name|numExceptions
init|=
name|freqs
index|[
name|this
operator|.
name|bitsPerValue
index|]
init|;
name|bitsPerValue
operator|>=
literal|0
operator|&&
name|numExceptions
operator|<=
name|MAX_EXCEPTIONS
condition|;
name|numExceptions
operator|+=
name|freqs
index|[
name|bitsPerValue
operator|--
index|]
control|)
block|{
specifier|final
name|int
name|newBlockSize
init|=
name|pforBlockSize
argument_list|(
name|bitsPerValue
argument_list|,
name|numExceptions
argument_list|,
name|actualBitsPerValue
operator|-
name|bitsPerValue
argument_list|)
decl_stmt|;
if|if
condition|(
name|newBlockSize
operator|<
name|blockSize
condition|)
block|{
name|this
operator|.
name|bitsPerValue
operator|=
name|bitsPerValue
expr_stmt|;
name|this
operator|.
name|numExceptions
operator|=
name|numExceptions
expr_stmt|;
name|blockSize
operator|=
name|newBlockSize
expr_stmt|;
block|}
block|}
name|this
operator|.
name|bitsPerException
operator|=
name|actualBitsPerValue
operator|-
name|bitsPerValue
expr_stmt|;
assert|assert
name|bufferSize
operator|<
name|BLOCK_SIZE
operator|||
name|numExceptions
operator|<
name|bufferSize
assert|;
return|return
name|blockSize
return|;
block|}
DECL|method|pforEncode
name|void
name|pforEncode
parameter_list|()
block|{
if|if
condition|(
name|numExceptions
operator|>
literal|0
condition|)
block|{
specifier|final
name|int
name|mask
init|=
operator|(
literal|1
operator|<<
name|bitsPerValue
operator|)
operator|-
literal|1
decl_stmt|;
name|int
name|ex
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|bufferSize
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|buffer
index|[
name|i
index|]
operator|>
name|mask
condition|)
block|{
name|exceptionIndices
index|[
name|ex
index|]
operator|=
name|i
expr_stmt|;
name|exceptions
index|[
name|ex
operator|++
index|]
operator|=
name|buffer
index|[
name|i
index|]
operator|>>>
name|bitsPerValue
expr_stmt|;
name|buffer
index|[
name|i
index|]
operator|&=
name|mask
expr_stmt|;
block|}
block|}
assert|assert
name|ex
operator|==
name|numExceptions
assert|;
name|Arrays
operator|.
name|fill
argument_list|(
name|exceptions
argument_list|,
name|numExceptions
argument_list|,
name|BLOCK_SIZE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bitsPerValue
operator|>
literal|0
condition|)
block|{
specifier|final
name|PackedInts
operator|.
name|Encoder
name|encoder
init|=
name|PackedInts
operator|.
name|getEncoder
argument_list|(
name|PackedInts
operator|.
name|Format
operator|.
name|PACKED
argument_list|,
name|PackedInts
operator|.
name|VERSION_CURRENT
argument_list|,
name|bitsPerValue
argument_list|)
decl_stmt|;
specifier|final
name|int
name|numIterations
init|=
name|ITERATIONS
index|[
name|bitsPerValue
index|]
decl_stmt|;
name|encoder
operator|.
name|encode
argument_list|(
name|buffer
argument_list|,
literal|0
argument_list|,
name|data
operator|.
name|bytes
argument_list|,
name|data
operator|.
name|length
argument_list|,
name|numIterations
argument_list|)
expr_stmt|;
name|data
operator|.
name|length
operator|+=
name|encoder
operator|.
name|byteBlockCount
argument_list|()
operator|*
name|numIterations
expr_stmt|;
block|}
if|if
condition|(
name|numExceptions
operator|>
literal|0
condition|)
block|{
assert|assert
name|bitsPerException
operator|>
literal|0
assert|;
name|data
operator|.
name|writeByte
argument_list|(
operator|(
name|byte
operator|)
name|numExceptions
argument_list|)
expr_stmt|;
name|data
operator|.
name|writeByte
argument_list|(
operator|(
name|byte
operator|)
name|bitsPerException
argument_list|)
expr_stmt|;
specifier|final
name|PackedInts
operator|.
name|Encoder
name|encoder
init|=
name|PackedInts
operator|.
name|getEncoder
argument_list|(
name|PackedInts
operator|.
name|Format
operator|.
name|PACKED
argument_list|,
name|PackedInts
operator|.
name|VERSION_CURRENT
argument_list|,
name|bitsPerException
argument_list|)
decl_stmt|;
specifier|final
name|int
name|numIterations
init|=
operator|(
name|numExceptions
operator|+
name|encoder
operator|.
name|byteValueCount
argument_list|()
operator|-
literal|1
operator|)
operator|/
name|encoder
operator|.
name|byteValueCount
argument_list|()
decl_stmt|;
name|encoder
operator|.
name|encode
argument_list|(
name|exceptions
argument_list|,
literal|0
argument_list|,
name|data
operator|.
name|bytes
argument_list|,
name|data
operator|.
name|length
argument_list|,
name|numIterations
argument_list|)
expr_stmt|;
name|data
operator|.
name|length
operator|+=
name|PackedInts
operator|.
name|Format
operator|.
name|PACKED
operator|.
name|byteCount
argument_list|(
name|PackedInts
operator|.
name|VERSION_CURRENT
argument_list|,
name|numExceptions
argument_list|,
name|bitsPerException
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numExceptions
condition|;
operator|++
name|i
control|)
block|{
name|data
operator|.
name|writeByte
argument_list|(
operator|(
name|byte
operator|)
name|exceptionIndices
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|unaryEncode
name|void
name|unaryEncode
parameter_list|()
block|{
name|int
name|current
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|,
name|doc
init|=
operator|-
literal|1
init|;
name|i
operator|<
name|BLOCK_SIZE
condition|;
operator|++
name|i
control|)
block|{
name|doc
operator|+=
literal|1
operator|+
name|buffer
index|[
name|i
index|]
expr_stmt|;
while|while
condition|(
name|doc
operator|>=
literal|8
condition|)
block|{
name|data
operator|.
name|writeByte
argument_list|(
operator|(
name|byte
operator|)
name|current
argument_list|)
expr_stmt|;
name|current
operator|=
literal|0
expr_stmt|;
name|doc
operator|-=
literal|8
expr_stmt|;
block|}
name|current
operator||=
literal|1
operator|<<
name|doc
expr_stmt|;
block|}
if|if
condition|(
name|current
operator|!=
literal|0
condition|)
block|{
name|data
operator|.
name|writeByte
argument_list|(
operator|(
name|byte
operator|)
name|current
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|encodeBlock
name|void
name|encodeBlock
parameter_list|()
block|{
specifier|final
name|int
name|originalLength
init|=
name|data
operator|.
name|length
decl_stmt|;
name|Arrays
operator|.
name|fill
argument_list|(
name|buffer
argument_list|,
name|bufferSize
argument_list|,
name|BLOCK_SIZE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
specifier|final
name|int
name|unaryBlockSize
init|=
name|unaryBlockSize
argument_list|()
decl_stmt|;
specifier|final
name|int
name|pforBlockSize
init|=
name|computeOptimalNumberOfBits
argument_list|()
decl_stmt|;
specifier|final
name|int
name|blockSize
decl_stmt|;
if|if
condition|(
name|pforBlockSize
operator|<=
name|unaryBlockSize
condition|)
block|{
comment|// use pfor
name|blockSize
operator|=
name|pforBlockSize
expr_stmt|;
name|data
operator|.
name|bytes
operator|=
name|ArrayUtil
operator|.
name|grow
argument_list|(
name|data
operator|.
name|bytes
argument_list|,
name|data
operator|.
name|length
operator|+
name|blockSize
operator|+
name|MAX_BYTE_BLOCK_COUNT
argument_list|)
expr_stmt|;
name|int
name|token
init|=
name|bufferSize
operator|<
name|BLOCK_SIZE
condition|?
name|LAST_BLOCK
else|:
literal|0
decl_stmt|;
name|token
operator||=
name|bitsPerValue
expr_stmt|;
if|if
condition|(
name|numExceptions
operator|>
literal|0
condition|)
block|{
name|token
operator||=
name|HAS_EXCEPTIONS
expr_stmt|;
block|}
name|data
operator|.
name|writeByte
argument_list|(
operator|(
name|byte
operator|)
name|token
argument_list|)
expr_stmt|;
name|pforEncode
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|// use unary
name|blockSize
operator|=
name|unaryBlockSize
expr_stmt|;
specifier|final
name|int
name|token
init|=
name|UNARY
operator||
operator|(
name|bufferSize
operator|<
name|BLOCK_SIZE
condition|?
name|LAST_BLOCK
else|:
literal|0
operator|)
decl_stmt|;
name|data
operator|.
name|writeByte
argument_list|(
operator|(
name|byte
operator|)
name|token
argument_list|)
expr_stmt|;
name|unaryEncode
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|bufferSize
operator|<
name|BLOCK_SIZE
condition|)
block|{
name|data
operator|.
name|writeByte
argument_list|(
operator|(
name|byte
operator|)
name|bufferSize
argument_list|)
expr_stmt|;
block|}
operator|++
name|numBlocks
expr_stmt|;
assert|assert
name|data
operator|.
name|length
operator|-
name|originalLength
operator|==
name|blockSize
operator|:
operator|(
name|data
operator|.
name|length
operator|-
name|originalLength
operator|)
operator|+
literal|"<> "
operator|+
name|blockSize
assert|;
block|}
comment|/** Build the {@link PForDeltaDocIdSet} instance. */
DECL|method|build
specifier|public
name|PForDeltaDocIdSet
name|build
parameter_list|()
block|{
assert|assert
name|bufferSize
operator|<
name|BLOCK_SIZE
assert|;
if|if
condition|(
name|cardinality
operator|==
literal|0
condition|)
block|{
assert|assert
name|previousDoc
operator|==
operator|-
literal|1
assert|;
return|return
name|EMPTY
return|;
block|}
name|encodeBlock
argument_list|()
expr_stmt|;
specifier|final
name|byte
index|[]
name|dataArr
init|=
name|Arrays
operator|.
name|copyOf
argument_list|(
name|data
operator|.
name|bytes
argument_list|,
name|data
operator|.
name|length
operator|+
name|MAX_BYTE_BLOCK_COUNT
argument_list|)
decl_stmt|;
specifier|final
name|int
name|indexSize
init|=
operator|(
name|numBlocks
operator|-
literal|1
operator|)
operator|/
name|indexInterval
operator|+
literal|1
decl_stmt|;
specifier|final
name|MonotonicAppendingLongBuffer
name|docIDs
decl_stmt|,
name|offsets
decl_stmt|;
if|if
condition|(
name|indexSize
operator|<=
literal|1
condition|)
block|{
name|docIDs
operator|=
name|offsets
operator|=
name|SINGLE_ZERO_BUFFER
expr_stmt|;
block|}
else|else
block|{
specifier|final
name|int
name|pageSize
init|=
literal|128
decl_stmt|;
specifier|final
name|int
name|initialPageCount
init|=
operator|(
name|indexSize
operator|+
name|pageSize
operator|-
literal|1
operator|)
operator|/
name|pageSize
decl_stmt|;
name|docIDs
operator|=
operator|new
name|MonotonicAppendingLongBuffer
argument_list|(
name|initialPageCount
argument_list|,
name|pageSize
argument_list|,
name|PackedInts
operator|.
name|COMPACT
argument_list|)
expr_stmt|;
name|offsets
operator|=
operator|new
name|MonotonicAppendingLongBuffer
argument_list|(
name|initialPageCount
argument_list|,
name|pageSize
argument_list|,
name|PackedInts
operator|.
name|COMPACT
argument_list|)
expr_stmt|;
comment|// Now build the index
specifier|final
name|Iterator
name|it
init|=
operator|new
name|Iterator
argument_list|(
name|dataArr
argument_list|,
name|cardinality
argument_list|,
name|Integer
operator|.
name|MAX_VALUE
argument_list|,
name|SINGLE_ZERO_BUFFER
argument_list|,
name|SINGLE_ZERO_BUFFER
argument_list|)
decl_stmt|;
name|index
label|:
for|for
control|(
name|int
name|k
init|=
literal|0
init|;
name|k
operator|<
name|indexSize
condition|;
operator|++
name|k
control|)
block|{
name|docIDs
operator|.
name|add
argument_list|(
name|it
operator|.
name|docID
argument_list|()
operator|+
literal|1
argument_list|)
expr_stmt|;
name|offsets
operator|.
name|add
argument_list|(
name|it
operator|.
name|offset
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|indexInterval
condition|;
operator|++
name|i
control|)
block|{
name|it
operator|.
name|skipBlock
argument_list|()
expr_stmt|;
if|if
condition|(
name|it
operator|.
name|docID
argument_list|()
operator|==
name|DocIdSetIterator
operator|.
name|NO_MORE_DOCS
condition|)
block|{
break|break
name|index
break|;
block|}
block|}
block|}
name|docIDs
operator|.
name|freeze
argument_list|()
expr_stmt|;
name|offsets
operator|.
name|freeze
argument_list|()
expr_stmt|;
block|}
return|return
operator|new
name|PForDeltaDocIdSet
argument_list|(
name|dataArr
argument_list|,
name|cardinality
argument_list|,
name|indexInterval
argument_list|,
name|docIDs
argument_list|,
name|offsets
argument_list|)
return|;
block|}
block|}
DECL|field|data
specifier|final
name|byte
index|[]
name|data
decl_stmt|;
DECL|field|docIDs
DECL|field|offsets
specifier|final
name|MonotonicAppendingLongBuffer
name|docIDs
decl_stmt|,
name|offsets
decl_stmt|;
comment|// for the index
DECL|field|cardinality
DECL|field|indexInterval
specifier|final
name|int
name|cardinality
decl_stmt|,
name|indexInterval
decl_stmt|;
DECL|method|PForDeltaDocIdSet
name|PForDeltaDocIdSet
parameter_list|(
name|byte
index|[]
name|data
parameter_list|,
name|int
name|cardinality
parameter_list|,
name|int
name|indexInterval
parameter_list|,
name|MonotonicAppendingLongBuffer
name|docIDs
parameter_list|,
name|MonotonicAppendingLongBuffer
name|offsets
parameter_list|)
block|{
name|this
operator|.
name|data
operator|=
name|data
expr_stmt|;
name|this
operator|.
name|cardinality
operator|=
name|cardinality
expr_stmt|;
name|this
operator|.
name|indexInterval
operator|=
name|indexInterval
expr_stmt|;
name|this
operator|.
name|docIDs
operator|=
name|docIDs
expr_stmt|;
name|this
operator|.
name|offsets
operator|=
name|offsets
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|isCacheable
specifier|public
name|boolean
name|isCacheable
parameter_list|()
block|{
return|return
literal|true
return|;
block|}
annotation|@
name|Override
DECL|method|iterator
specifier|public
name|DocIdSetIterator
name|iterator
parameter_list|()
block|{
if|if
condition|(
name|data
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
else|else
block|{
return|return
operator|new
name|Iterator
argument_list|(
name|data
argument_list|,
name|cardinality
argument_list|,
name|indexInterval
argument_list|,
name|docIDs
argument_list|,
name|offsets
argument_list|)
return|;
block|}
block|}
DECL|class|Iterator
specifier|static
class|class
name|Iterator
extends|extends
name|DocIdSetIterator
block|{
comment|// index
DECL|field|indexInterval
specifier|final
name|int
name|indexInterval
decl_stmt|;
DECL|field|docIDs
DECL|field|offsets
specifier|final
name|MonotonicAppendingLongBuffer
name|docIDs
decl_stmt|,
name|offsets
decl_stmt|;
DECL|field|cardinality
specifier|final
name|int
name|cardinality
decl_stmt|;
DECL|field|data
specifier|final
name|byte
index|[]
name|data
decl_stmt|;
DECL|field|offset
name|int
name|offset
decl_stmt|;
comment|// offset in data
DECL|field|nextDocs
specifier|final
name|int
index|[]
name|nextDocs
decl_stmt|;
DECL|field|i
name|int
name|i
decl_stmt|;
comment|// index in nextDeltas
DECL|field|nextExceptions
specifier|final
name|int
index|[]
name|nextExceptions
decl_stmt|;
DECL|field|blockIdx
name|int
name|blockIdx
decl_stmt|;
DECL|field|docID
name|int
name|docID
decl_stmt|;
DECL|method|Iterator
name|Iterator
parameter_list|(
name|byte
index|[]
name|data
parameter_list|,
name|int
name|cardinality
parameter_list|,
name|int
name|indexInterval
parameter_list|,
name|MonotonicAppendingLongBuffer
name|docIDs
parameter_list|,
name|MonotonicAppendingLongBuffer
name|offsets
parameter_list|)
block|{
name|this
operator|.
name|data
operator|=
name|data
expr_stmt|;
name|this
operator|.
name|cardinality
operator|=
name|cardinality
expr_stmt|;
name|this
operator|.
name|indexInterval
operator|=
name|indexInterval
expr_stmt|;
name|this
operator|.
name|docIDs
operator|=
name|docIDs
expr_stmt|;
name|this
operator|.
name|offsets
operator|=
name|offsets
expr_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
name|nextDocs
operator|=
operator|new
name|int
index|[
name|BLOCK_SIZE
index|]
expr_stmt|;
name|Arrays
operator|.
name|fill
argument_list|(
name|nextDocs
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|i
operator|=
name|BLOCK_SIZE
expr_stmt|;
name|nextExceptions
operator|=
operator|new
name|int
index|[
name|BLOCK_SIZE
index|]
expr_stmt|;
name|blockIdx
operator|=
operator|-
literal|1
expr_stmt|;
name|docID
operator|=
operator|-
literal|1
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|docID
specifier|public
name|int
name|docID
parameter_list|()
block|{
return|return
name|docID
return|;
block|}
DECL|method|pforDecompress
name|void
name|pforDecompress
parameter_list|(
name|byte
name|token
parameter_list|)
block|{
specifier|final
name|int
name|bitsPerValue
init|=
name|token
operator|&
literal|0x1F
decl_stmt|;
if|if
condition|(
name|bitsPerValue
operator|==
literal|0
condition|)
block|{
name|Arrays
operator|.
name|fill
argument_list|(
name|nextDocs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|DECODERS
index|[
name|bitsPerValue
index|]
operator|.
name|decode
argument_list|(
name|data
argument_list|,
name|offset
argument_list|,
name|nextDocs
argument_list|,
literal|0
argument_list|,
name|ITERATIONS
index|[
name|bitsPerValue
index|]
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|BYTE_BLOCK_COUNTS
index|[
name|bitsPerValue
index|]
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|token
operator|&
name|HAS_EXCEPTIONS
operator|)
operator|!=
literal|0
condition|)
block|{
comment|// there are exceptions
specifier|final
name|int
name|numExceptions
init|=
name|data
index|[
name|offset
operator|++
index|]
decl_stmt|;
specifier|final
name|int
name|bitsPerException
init|=
name|data
index|[
name|offset
operator|++
index|]
decl_stmt|;
specifier|final
name|int
name|numIterations
init|=
operator|(
name|numExceptions
operator|+
name|DECODERS
index|[
name|bitsPerException
index|]
operator|.
name|byteValueCount
argument_list|()
operator|-
literal|1
operator|)
operator|/
name|DECODERS
index|[
name|bitsPerException
index|]
operator|.
name|byteValueCount
argument_list|()
decl_stmt|;
name|DECODERS
index|[
name|bitsPerException
index|]
operator|.
name|decode
argument_list|(
name|data
argument_list|,
name|offset
argument_list|,
name|nextExceptions
argument_list|,
literal|0
argument_list|,
name|numIterations
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|PackedInts
operator|.
name|Format
operator|.
name|PACKED
operator|.
name|byteCount
argument_list|(
name|PackedInts
operator|.
name|VERSION_CURRENT
argument_list|,
name|numExceptions
argument_list|,
name|bitsPerException
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numExceptions
condition|;
operator|++
name|i
control|)
block|{
name|nextDocs
index|[
name|data
index|[
name|offset
operator|++
index|]
index|]
operator||=
name|nextExceptions
index|[
name|i
index|]
operator|<<
name|bitsPerValue
expr_stmt|;
block|}
block|}
for|for
control|(
name|int
name|previousDoc
init|=
name|docID
init|,
name|i
init|=
literal|0
init|;
name|i
operator|<
name|BLOCK_SIZE
condition|;
operator|++
name|i
control|)
block|{
specifier|final
name|int
name|doc
init|=
name|previousDoc
operator|+
literal|1
operator|+
name|nextDocs
index|[
name|i
index|]
decl_stmt|;
name|previousDoc
operator|=
name|nextDocs
index|[
name|i
index|]
operator|=
name|doc
expr_stmt|;
block|}
block|}
DECL|method|unaryDecompress
name|void
name|unaryDecompress
parameter_list|(
name|byte
name|token
parameter_list|)
block|{
assert|assert
operator|(
name|token
operator|&
name|HAS_EXCEPTIONS
operator|)
operator|==
literal|0
assert|;
name|int
name|docID
init|=
name|this
operator|.
name|docID
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|BLOCK_SIZE
condition|;
control|)
block|{
specifier|final
name|byte
name|b
init|=
name|data
index|[
name|offset
operator|++
index|]
decl_stmt|;
for|for
control|(
name|int
name|bitList
init|=
name|BitUtil
operator|.
name|bitList
argument_list|(
name|b
argument_list|)
init|;
name|bitList
operator|!=
literal|0
condition|;
operator|++
name|i
operator|,
name|bitList
operator|>>>=
literal|4
control|)
block|{
name|nextDocs
index|[
name|i
index|]
operator|=
name|docID
operator|+
operator|(
name|bitList
operator|&
literal|0x0F
operator|)
expr_stmt|;
block|}
name|docID
operator|+=
literal|8
expr_stmt|;
block|}
block|}
DECL|method|decompressBlock
name|void
name|decompressBlock
parameter_list|()
block|{
specifier|final
name|byte
name|token
init|=
name|data
index|[
name|offset
operator|++
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|token
operator|&
name|UNARY
operator|)
operator|!=
literal|0
condition|)
block|{
name|unaryDecompress
argument_list|(
name|token
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pforDecompress
argument_list|(
name|token
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|token
operator|&
name|LAST_BLOCK
operator|)
operator|!=
literal|0
condition|)
block|{
specifier|final
name|int
name|blockSize
init|=
name|data
index|[
name|offset
operator|++
index|]
decl_stmt|;
name|Arrays
operator|.
name|fill
argument_list|(
name|nextDocs
argument_list|,
name|blockSize
argument_list|,
name|BLOCK_SIZE
argument_list|,
name|NO_MORE_DOCS
argument_list|)
expr_stmt|;
block|}
operator|++
name|blockIdx
expr_stmt|;
block|}
DECL|method|skipBlock
name|void
name|skipBlock
parameter_list|()
block|{
assert|assert
name|i
operator|==
name|BLOCK_SIZE
assert|;
name|decompressBlock
argument_list|()
expr_stmt|;
name|docID
operator|=
name|nextDocs
index|[
name|BLOCK_SIZE
operator|-
literal|1
index|]
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|nextDoc
specifier|public
name|int
name|nextDoc
parameter_list|()
block|{
if|if
condition|(
name|i
operator|==
name|BLOCK_SIZE
condition|)
block|{
name|decompressBlock
argument_list|()
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|docID
operator|=
name|nextDocs
index|[
name|i
operator|++
index|]
return|;
block|}
DECL|method|forwardBinarySearch
name|int
name|forwardBinarySearch
parameter_list|(
name|int
name|target
parameter_list|)
block|{
comment|// advance forward and double the window at each step
specifier|final
name|int
name|indexSize
init|=
operator|(
name|int
operator|)
name|docIDs
operator|.
name|size
argument_list|()
decl_stmt|;
name|int
name|lo
init|=
name|Math
operator|.
name|max
argument_list|(
name|blockIdx
operator|/
name|indexInterval
argument_list|,
literal|0
argument_list|)
decl_stmt|,
name|hi
init|=
name|lo
operator|+
literal|1
decl_stmt|;
assert|assert
name|blockIdx
operator|==
operator|-
literal|1
operator|||
name|docIDs
operator|.
name|get
argument_list|(
name|lo
argument_list|)
operator|<=
name|docID
assert|;
assert|assert
name|lo
operator|+
literal|1
operator|==
name|docIDs
operator|.
name|size
argument_list|()
operator|||
name|docIDs
operator|.
name|get
argument_list|(
name|lo
operator|+
literal|1
argument_list|)
operator|>
name|docID
assert|;
while|while
condition|(
literal|true
condition|)
block|{
if|if
condition|(
name|hi
operator|>=
name|indexSize
condition|)
block|{
name|hi
operator|=
name|indexSize
operator|-
literal|1
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|docIDs
operator|.
name|get
argument_list|(
name|hi
argument_list|)
operator|>=
name|target
condition|)
block|{
break|break;
block|}
specifier|final
name|int
name|newLo
init|=
name|hi
decl_stmt|;
name|hi
operator|+=
operator|(
name|hi
operator|-
name|lo
operator|)
operator|<<
literal|1
expr_stmt|;
name|lo
operator|=
name|newLo
expr_stmt|;
block|}
comment|// we found a window containing our target, let's binary search now
while|while
condition|(
name|lo
operator|<=
name|hi
condition|)
block|{
specifier|final
name|int
name|mid
init|=
operator|(
name|lo
operator|+
name|hi
operator|)
operator|>>>
literal|1
decl_stmt|;
specifier|final
name|int
name|midDocID
init|=
operator|(
name|int
operator|)
name|docIDs
operator|.
name|get
argument_list|(
name|mid
argument_list|)
decl_stmt|;
if|if
condition|(
name|midDocID
operator|<=
name|target
condition|)
block|{
name|lo
operator|=
name|mid
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
name|hi
operator|=
name|mid
operator|-
literal|1
expr_stmt|;
block|}
block|}
assert|assert
name|docIDs
operator|.
name|get
argument_list|(
name|hi
argument_list|)
operator|<=
name|target
assert|;
assert|assert
name|hi
operator|+
literal|1
operator|==
name|docIDs
operator|.
name|size
argument_list|()
operator|||
name|docIDs
operator|.
name|get
argument_list|(
name|hi
operator|+
literal|1
argument_list|)
operator|>
name|target
assert|;
return|return
name|hi
return|;
block|}
annotation|@
name|Override
DECL|method|advance
specifier|public
name|int
name|advance
parameter_list|(
name|int
name|target
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|target
operator|>
name|docID
assert|;
if|if
condition|(
name|nextDocs
index|[
name|BLOCK_SIZE
operator|-
literal|1
index|]
operator|<
name|target
condition|)
block|{
comment|// not in the next block, now use the index
specifier|final
name|int
name|index
init|=
name|forwardBinarySearch
argument_list|(
name|target
argument_list|)
decl_stmt|;
specifier|final
name|int
name|offset
init|=
operator|(
name|int
operator|)
name|offsets
operator|.
name|get
argument_list|(
name|index
argument_list|)
decl_stmt|;
if|if
condition|(
name|offset
operator|>
name|this
operator|.
name|offset
condition|)
block|{
name|this
operator|.
name|offset
operator|=
name|offset
expr_stmt|;
name|docID
operator|=
operator|(
name|int
operator|)
name|docIDs
operator|.
name|get
argument_list|(
name|index
argument_list|)
operator|-
literal|1
expr_stmt|;
name|blockIdx
operator|=
name|index
operator|*
name|indexInterval
operator|-
literal|1
expr_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|decompressBlock
argument_list|()
expr_stmt|;
if|if
condition|(
name|nextDocs
index|[
name|BLOCK_SIZE
operator|-
literal|1
index|]
operator|>=
name|target
condition|)
block|{
break|break;
block|}
name|docID
operator|=
name|nextDocs
index|[
name|BLOCK_SIZE
operator|-
literal|1
index|]
expr_stmt|;
block|}
name|i
operator|=
literal|0
expr_stmt|;
block|}
block|}
return|return
name|slowAdvance
argument_list|(
name|target
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|cost
specifier|public
name|long
name|cost
parameter_list|()
block|{
return|return
name|cardinality
return|;
block|}
block|}
comment|/** Return the number of documents in this {@link DocIdSet} in constant time. */
DECL|method|cardinality
specifier|public
name|int
name|cardinality
parameter_list|()
block|{
return|return
name|cardinality
return|;
block|}
annotation|@
name|Override
DECL|method|ramBytesUsed
specifier|public
name|long
name|ramBytesUsed
parameter_list|()
block|{
if|if
condition|(
name|this
operator|==
name|EMPTY
condition|)
block|{
return|return
literal|0L
return|;
block|}
name|long
name|ramBytesUsed
init|=
name|BASE_RAM_BYTES_USED
operator|+
name|RamUsageEstimator
operator|.
name|sizeOf
argument_list|(
name|data
argument_list|)
decl_stmt|;
if|if
condition|(
name|docIDs
operator|!=
name|SINGLE_ZERO_BUFFER
condition|)
block|{
name|ramBytesUsed
operator|+=
name|docIDs
operator|.
name|ramBytesUsed
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|offsets
operator|!=
name|SINGLE_ZERO_BUFFER
condition|)
block|{
name|ramBytesUsed
operator|+=
name|offsets
operator|.
name|ramBytesUsed
argument_list|()
expr_stmt|;
block|}
return|return
name|ramBytesUsed
return|;
block|}
block|}
end_class
end_unit
