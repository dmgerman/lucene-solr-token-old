begin_unit
begin_comment
comment|/*  * dk.brics.automaton  *   * Copyright (c) 2001-2009 Anders Moeller  * All rights reserved.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *   * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment
begin_package
DECL|package|org.apache.lucene.util.automaton
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|automaton
package|;
end_package
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import
begin_comment
comment|/**  * Regular Expression extension to<code>Automaton</code>.  *<p>  * Regular expressions are built from the following abstract syntax:  *<p>  *<table border=0>  *<tr>  *<td><i>regexp</i></td>  *<td>::=</td>  *<td><i>unionexp</i></td>  *<td></td>  *<td></td>  *</tr>  *<tr>  *<td></td>  *<td>|</td>  *<td></td>  *<td></td>  *<td></td>  *</tr>  *   *<tr>  *<td><i>unionexp</i></td>  *<td>::=</td>  *<td><i>interexp</i>&nbsp;<tt><b>|</b></tt>&nbsp;<i>unionexp</i></td>  *<td>(union)</td>  *<td></td>  *</tr>  *<tr>  *<td></td>  *<td>|</td>  *<td><i>interexp</i></td>  *<td></td>  *<td></td>  *</tr>  *   *<tr>  *<td><i>interexp</i></td>  *<td>::=</td>  *<td><i>concatexp</i>&nbsp;<tt><b>&amp;</b></tt>&nbsp;<i>interexp</i></td>  *<td>(intersection)</td>  *<td><small>[OPTIONAL]</small></td>  *</tr>  *<tr>  *<td></td>  *<td>|</td>  *<td><i>concatexp</i></td>  *<td></td>  *<td></td>  *</tr>  *   *<tr>  *<td><i>concatexp</i></td>  *<td>::=</td>  *<td><i>repeatexp</i>&nbsp;<i>concatexp</i></td>  *<td>(concatenation)</td>  *<td></td>  *</tr>  *<tr>  *<td></td>  *<td>|</td>  *<td><i>repeatexp</i></td>  *<td></td>  *<td></td>  *</tr>  *   *<tr>  *<td><i>repeatexp</i></td>  *<td>::=</td>  *<td><i>repeatexp</i>&nbsp;<tt><b>?</b></tt></td>  *<td>(zero or one occurrence)</td>  *<td></td>  *</tr>  *<tr>  *<td></td>  *<td>|</td>  *<td><i>repeatexp</i>&nbsp;<tt><b>*</b></tt></td>  *<td>(zero or more occurrences)</td>  *<td></td>  *</tr>  *<tr>  *<td></td>  *<td>|</td>  *<td><i>repeatexp</i>&nbsp;<tt><b>+</b></tt></td>  *<td>(one or more occurrences)</td>  *<td></td>  *</tr>  *<tr>  *<td></td>  *<td>|</td>  *<td><i>repeatexp</i>&nbsp;<tt><b>{</b><i>n</i><b>}</b></tt></td>  *<td>(<tt><i>n</i></tt> occurrences)</td>  *<td></td>  *</tr>  *<tr>  *<td></td>  *<td>|</td>  *<td><i>repeatexp</i>&nbsp;<tt><b>{</b><i>n</i><b>,}</b></tt></td>  *<td>(<tt><i>n</i></tt> or more occurrences)</td>  *<td></td>  *</tr>  *<tr>  *<td></td>  *<td>|</td>  *<td><i>repeatexp</i>&nbsp;<tt><b>{</b><i>n</i><b>,</b><i>m</i><b>}</b></tt></td>  *<td>(<tt><i>n</i></tt> to<tt><i>m</i></tt> occurrences, including both)</td>  *<td></td>  *</tr>  *<tr>  *<td></td>  *<td>|</td>  *<td><i>complexp</i></td>  *<td></td>  *<td></td>  *</tr>  *   *<tr>  *<td><i>complexp</i></td>  *<td>::=</td>  *<td><tt><b>~</b></tt>&nbsp;<i>complexp</i></td>  *<td>(complement)</td>  *<td><small>[OPTIONAL]</small></td>  *</tr>  *<tr>  *<td></td>  *<td>|</td>  *<td><i>charclassexp</i></td>  *<td></td>  *<td></td>  *</tr>  *   *<tr>  *<td><i>charclassexp</i></td>  *<td>::=</td>  *<td><tt><b>[</b></tt>&nbsp;<i>charclasses</i>&nbsp;<tt><b>]</b></tt></td>  *<td>(character class)</td>  *<td></td>  *</tr>  *<tr>  *<td></td>  *<td>|</td>  *<td><tt><b>[^</b></tt>&nbsp;<i>charclasses</i>&nbsp;<tt><b>]</b></tt></td>  *<td>(negated character class)</td>  *<td></td>  *</tr>  *<tr>  *<td></td>  *<td>|</td>  *<td><i>simpleexp</i></td>  *<td></td>  *<td></td>  *</tr>  *   *<tr>  *<td><i>charclasses</i></td>  *<td>::=</td>  *<td><i>charclass</i>&nbsp;<i>charclasses</i></td>  *<td></td>  *<td></td>  *</tr>  *<tr>  *<td></td>  *<td>|</td>  *<td><i>charclass</i></td>  *<td></td>  *<td></td>  *</tr>  *   *<tr>  *<td><i>charclass</i></td>  *<td>::=</td>  *<td><i>charexp</i>&nbsp;<tt><b>-</b></tt>&nbsp;<i>charexp</i></td>  *<td>(character range, including end-points)</td>  *<td></td>  *</tr>  *<tr>  *<td></td>  *<td>|</td>  *<td><i>charexp</i></td>  *<td></td>  *<td></td>  *</tr>  *   *<tr>  *<td><i>simpleexp</i></td>  *<td>::=</td>  *<td><i>charexp</i></td>  *<td></td>  *<td></td>  *</tr>  *<tr>  *<td></td>  *<td>|</td>  *<td><tt><b>.</b></tt></td>  *<td>(any single character)</td>  *<td></td>  *</tr>  *<tr>  *<td></td>  *<td>|</td>  *<td><tt><b>#</b></tt></td>  *<td>(the empty language)</td>  *<td><small>[OPTIONAL]</small></td>  *</tr>  *<tr>  *<td></td>  *<td>|</td>  *<td><tt><b>@</b></tt></td>  *<td>(any string)</td>  *<td><small>[OPTIONAL]</small></td>  *</tr>  *<tr>  *<td></td>  *<td>|</td>  *<td><tt><b>"</b></tt>&nbsp;&lt;Unicode string without double-quotes&gt;&nbsp;<tt><b>"</b></tt></td>  *<td>(a string)</td>  *<td></td>  *</tr>  *<tr>  *<td></td>  *<td>|</td>  *<td><tt><b>(</b></tt>&nbsp;<tt><b>)</b></tt></td>  *<td>(the empty string)</td>  *<td></td>  *</tr>  *<tr>  *<td></td>  *<td>|</td>  *<td><tt><b>(</b></tt>&nbsp;<i>unionexp</i>&nbsp;<tt><b>)</b></tt></td>  *<td>(precedence override)</td>  *<td></td>  *</tr>  *<tr>  *<td></td>  *<td>|</td>  *<td><tt><b>&lt;</b></tt>&nbsp;&lt;identifier&gt;&nbsp;<tt><b>&gt;</b></tt></td>  *<td>(named automaton)</td>  *<td><small>[OPTIONAL]</small></td>  *</tr>  *<tr>  *<td></td>  *<td>|</td>  *<td><tt><b>&lt;</b><i>n</i>-<i>m</i><b>&gt;</b></tt></td>  *<td>(numerical interval)</td>  *<td><small>[OPTIONAL]</small></td>  *</tr>  *   *<tr>  *<td><i>charexp</i></td>  *<td>::=</td>  *<td>&lt;Unicode character&gt;</td>  *<td>(a single non-reserved character)</td>  *<td></td>  *</tr>  *<tr>  *<td></td>  *<td>|</td>  *<td><tt><b>\</b></tt>&nbsp;&lt;Unicode character&gt;&nbsp;</td>  *<td>(a single character)</td>  *<td></td>  *</tr>  *</table>  *<p>  * The productions marked<small>[OPTIONAL]</small> are only allowed if  * specified by the syntax flags passed to the<code>RegExp</code> constructor.  * The reserved characters used in the (enabled) syntax must be escaped with  * backslash (<tt><b>\</b></tt>) or double-quotes (<tt><b>"..."</b></tt>). (In  * contrast to other regexp syntaxes, this is required also in character  * classes.) Be aware that dash (<tt><b>-</b></tt>) has a special meaning in  *<i>charclass</i> expressions. An identifier is a string not containing right  * angle bracket (<tt><b>&gt;</b></tt>) or dash (<tt><b>-</b></tt>). Numerical  * intervals are specified by non-negative decimal integers and include both end  * points, and if<tt><i>n</i></tt> and<tt><i>m</i></tt> have the same number  * of digits, then the conforming strings must have that length (i.e. prefixed  * by 0's).  *   * @lucene.experimental  */
end_comment
begin_class
DECL|class|RegExp
specifier|public
class|class
name|RegExp
block|{
DECL|enum|Kind
enum|enum
name|Kind
block|{
DECL|enum constant|REGEXP_UNION
DECL|enum constant|REGEXP_CONCATENATION
DECL|enum constant|REGEXP_INTERSECTION
DECL|enum constant|REGEXP_OPTIONAL
DECL|enum constant|REGEXP_REPEAT
DECL|enum constant|REGEXP_REPEAT_MIN
DECL|enum constant|REGEXP_REPEAT_MINMAX
DECL|enum constant|REGEXP_COMPLEMENT
DECL|enum constant|REGEXP_CHAR
DECL|enum constant|REGEXP_CHAR_RANGE
DECL|enum constant|REGEXP_ANYCHAR
DECL|enum constant|REGEXP_EMPTY
DECL|enum constant|REGEXP_STRING
DECL|enum constant|REGEXP_ANYSTRING
DECL|enum constant|REGEXP_AUTOMATON
DECL|enum constant|REGEXP_INTERVAL
name|REGEXP_UNION
block|,
name|REGEXP_CONCATENATION
block|,
name|REGEXP_INTERSECTION
block|,
name|REGEXP_OPTIONAL
block|,
name|REGEXP_REPEAT
block|,
name|REGEXP_REPEAT_MIN
block|,
name|REGEXP_REPEAT_MINMAX
block|,
name|REGEXP_COMPLEMENT
block|,
name|REGEXP_CHAR
block|,
name|REGEXP_CHAR_RANGE
block|,
name|REGEXP_ANYCHAR
block|,
name|REGEXP_EMPTY
block|,
name|REGEXP_STRING
block|,
name|REGEXP_ANYSTRING
block|,
name|REGEXP_AUTOMATON
block|,
name|REGEXP_INTERVAL
block|}
comment|/**    * Syntax flag, enables intersection (<tt>&amp;</tt>).    */
DECL|field|INTERSECTION
specifier|public
specifier|static
specifier|final
name|int
name|INTERSECTION
init|=
literal|0x0001
decl_stmt|;
comment|/**    * Syntax flag, enables complement (<tt>~</tt>).    */
DECL|field|COMPLEMENT
specifier|public
specifier|static
specifier|final
name|int
name|COMPLEMENT
init|=
literal|0x0002
decl_stmt|;
comment|/**    * Syntax flag, enables empty language (<tt>#</tt>).    */
DECL|field|EMPTY
specifier|public
specifier|static
specifier|final
name|int
name|EMPTY
init|=
literal|0x0004
decl_stmt|;
comment|/**    * Syntax flag, enables anystring (<tt>@</tt>).    */
DECL|field|ANYSTRING
specifier|public
specifier|static
specifier|final
name|int
name|ANYSTRING
init|=
literal|0x0008
decl_stmt|;
comment|/**    * Syntax flag, enables named automata (<tt>&lt;</tt>identifier<tt>&gt;</tt>).    */
DECL|field|AUTOMATON
specifier|public
specifier|static
specifier|final
name|int
name|AUTOMATON
init|=
literal|0x0010
decl_stmt|;
comment|/**    * Syntax flag, enables numerical intervals (    *<tt>&lt;<i>n</i>-<i>m</i>&gt;</tt>).    */
DECL|field|INTERVAL
specifier|public
specifier|static
specifier|final
name|int
name|INTERVAL
init|=
literal|0x0020
decl_stmt|;
comment|/**    * Syntax flag, enables all optional regexp syntax.    */
DECL|field|ALL
specifier|public
specifier|static
specifier|final
name|int
name|ALL
init|=
literal|0xffff
decl_stmt|;
comment|/**    * Syntax flag, enables no optional regexp syntax.    */
DECL|field|NONE
specifier|public
specifier|static
specifier|final
name|int
name|NONE
init|=
literal|0x0000
decl_stmt|;
DECL|field|kind
name|Kind
name|kind
decl_stmt|;
DECL|field|exp1
DECL|field|exp2
name|RegExp
name|exp1
decl_stmt|,
name|exp2
decl_stmt|;
DECL|field|s
name|String
name|s
decl_stmt|;
DECL|field|c
name|int
name|c
decl_stmt|;
DECL|field|min
DECL|field|max
DECL|field|digits
name|int
name|min
decl_stmt|,
name|max
decl_stmt|,
name|digits
decl_stmt|;
DECL|field|from
DECL|field|to
name|int
name|from
decl_stmt|,
name|to
decl_stmt|;
DECL|field|b
name|String
name|b
decl_stmt|;
DECL|field|flags
name|int
name|flags
decl_stmt|;
DECL|field|pos
name|int
name|pos
decl_stmt|;
DECL|method|RegExp
name|RegExp
parameter_list|()
block|{}
comment|/**    * Constructs new<code>RegExp</code> from a string. Same as    *<code>RegExp(s, ALL)</code>.    *     * @param s regexp string    * @exception IllegalArgumentException if an error occured while parsing the    *              regular expression    */
DECL|method|RegExp
specifier|public
name|RegExp
parameter_list|(
name|String
name|s
parameter_list|)
throws|throws
name|IllegalArgumentException
block|{
name|this
argument_list|(
name|s
argument_list|,
name|ALL
argument_list|)
expr_stmt|;
block|}
comment|/**    * Constructs new<code>RegExp</code> from a string.    *     * @param s regexp string    * @param syntax_flags boolean 'or' of optional syntax constructs to be    *          enabled    * @exception IllegalArgumentException if an error occured while parsing the    *              regular expression    */
DECL|method|RegExp
specifier|public
name|RegExp
parameter_list|(
name|String
name|s
parameter_list|,
name|int
name|syntax_flags
parameter_list|)
throws|throws
name|IllegalArgumentException
block|{
name|b
operator|=
name|s
expr_stmt|;
name|flags
operator|=
name|syntax_flags
expr_stmt|;
name|RegExp
name|e
decl_stmt|;
if|if
condition|(
name|s
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
name|e
operator|=
name|makeString
argument_list|(
literal|""
argument_list|)
expr_stmt|;
else|else
block|{
name|e
operator|=
name|parseUnionExp
argument_list|()
expr_stmt|;
if|if
condition|(
name|pos
operator|<
name|b
operator|.
name|length
argument_list|()
condition|)
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"end-of-string expected at position "
operator|+
name|pos
argument_list|)
throw|;
block|}
name|kind
operator|=
name|e
operator|.
name|kind
expr_stmt|;
name|exp1
operator|=
name|e
operator|.
name|exp1
expr_stmt|;
name|exp2
operator|=
name|e
operator|.
name|exp2
expr_stmt|;
name|this
operator|.
name|s
operator|=
name|e
operator|.
name|s
expr_stmt|;
name|c
operator|=
name|e
operator|.
name|c
expr_stmt|;
name|min
operator|=
name|e
operator|.
name|min
expr_stmt|;
name|max
operator|=
name|e
operator|.
name|max
expr_stmt|;
name|digits
operator|=
name|e
operator|.
name|digits
expr_stmt|;
name|from
operator|=
name|e
operator|.
name|from
expr_stmt|;
name|to
operator|=
name|e
operator|.
name|to
expr_stmt|;
name|b
operator|=
literal|null
expr_stmt|;
block|}
comment|/**    * Constructs new<code>Automaton</code> from this<code>RegExp</code>. Same    * as<code>toAutomaton(null)</code> (empty automaton map).    */
DECL|method|toAutomaton
specifier|public
name|Automaton
name|toAutomaton
parameter_list|()
block|{
return|return
name|toAutomaton
argument_list|(
literal|null
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/**    * Constructs new<code>Automaton</code> from this<code>RegExp</code>. The    * constructed automaton is minimal and deterministic and has no transitions    * to dead states.    *     * @param automaton_provider provider of automata for named identifiers    * @exception IllegalArgumentException if this regular expression uses a named    *              identifier that is not available from the automaton provider    */
DECL|method|toAutomaton
specifier|public
name|Automaton
name|toAutomaton
parameter_list|(
name|AutomatonProvider
name|automaton_provider
parameter_list|)
throws|throws
name|IllegalArgumentException
block|{
return|return
name|toAutomaton
argument_list|(
literal|null
argument_list|,
name|automaton_provider
argument_list|)
return|;
block|}
comment|/**    * Constructs new<code>Automaton</code> from this<code>RegExp</code>. The    * constructed automaton is minimal and deterministic and has no transitions    * to dead states.    *     * @param automata a map from automaton identifiers to automata (of type    *<code>Automaton</code>).    * @exception IllegalArgumentException if this regular expression uses a named    *              identifier that does not occur in the automaton map    */
DECL|method|toAutomaton
specifier|public
name|Automaton
name|toAutomaton
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|Automaton
argument_list|>
name|automata
parameter_list|)
throws|throws
name|IllegalArgumentException
block|{
return|return
name|toAutomaton
argument_list|(
name|automata
argument_list|,
literal|null
argument_list|)
return|;
block|}
DECL|method|toAutomaton
specifier|private
name|Automaton
name|toAutomaton
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|Automaton
argument_list|>
name|automata
parameter_list|,
name|AutomatonProvider
name|automaton_provider
parameter_list|)
throws|throws
name|IllegalArgumentException
block|{
name|List
argument_list|<
name|Automaton
argument_list|>
name|list
decl_stmt|;
name|Automaton
name|a
init|=
literal|null
decl_stmt|;
switch|switch
condition|(
name|kind
condition|)
block|{
case|case
name|REGEXP_UNION
case|:
name|list
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
expr_stmt|;
name|findLeaves
argument_list|(
name|exp1
argument_list|,
name|Kind
operator|.
name|REGEXP_UNION
argument_list|,
name|list
argument_list|,
name|automata
argument_list|,
name|automaton_provider
argument_list|)
expr_stmt|;
name|findLeaves
argument_list|(
name|exp2
argument_list|,
name|Kind
operator|.
name|REGEXP_UNION
argument_list|,
name|list
argument_list|,
name|automata
argument_list|,
name|automaton_provider
argument_list|)
expr_stmt|;
name|a
operator|=
name|Operations
operator|.
name|union
argument_list|(
name|list
argument_list|)
expr_stmt|;
name|a
operator|=
name|MinimizationOperations
operator|.
name|minimize
argument_list|(
name|a
argument_list|)
expr_stmt|;
break|break;
case|case
name|REGEXP_CONCATENATION
case|:
name|list
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
expr_stmt|;
name|findLeaves
argument_list|(
name|exp1
argument_list|,
name|Kind
operator|.
name|REGEXP_CONCATENATION
argument_list|,
name|list
argument_list|,
name|automata
argument_list|,
name|automaton_provider
argument_list|)
expr_stmt|;
name|findLeaves
argument_list|(
name|exp2
argument_list|,
name|Kind
operator|.
name|REGEXP_CONCATENATION
argument_list|,
name|list
argument_list|,
name|automata
argument_list|,
name|automaton_provider
argument_list|)
expr_stmt|;
name|a
operator|=
name|Operations
operator|.
name|concatenate
argument_list|(
name|list
argument_list|)
expr_stmt|;
name|a
operator|=
name|MinimizationOperations
operator|.
name|minimize
argument_list|(
name|a
argument_list|)
expr_stmt|;
break|break;
case|case
name|REGEXP_INTERSECTION
case|:
name|a
operator|=
name|Operations
operator|.
name|intersection
argument_list|(
name|exp1
operator|.
name|toAutomaton
argument_list|(
name|automata
argument_list|,
name|automaton_provider
argument_list|)
argument_list|,
name|exp2
operator|.
name|toAutomaton
argument_list|(
name|automata
argument_list|,
name|automaton_provider
argument_list|)
argument_list|)
expr_stmt|;
name|a
operator|=
name|MinimizationOperations
operator|.
name|minimize
argument_list|(
name|a
argument_list|)
expr_stmt|;
break|break;
case|case
name|REGEXP_OPTIONAL
case|:
name|a
operator|=
name|Operations
operator|.
name|optional
argument_list|(
name|exp1
operator|.
name|toAutomaton
argument_list|(
name|automata
argument_list|,
name|automaton_provider
argument_list|)
argument_list|)
expr_stmt|;
name|a
operator|=
name|MinimizationOperations
operator|.
name|minimize
argument_list|(
name|a
argument_list|)
expr_stmt|;
break|break;
case|case
name|REGEXP_REPEAT
case|:
name|a
operator|=
name|Operations
operator|.
name|repeat
argument_list|(
name|exp1
operator|.
name|toAutomaton
argument_list|(
name|automata
argument_list|,
name|automaton_provider
argument_list|)
argument_list|)
expr_stmt|;
name|a
operator|=
name|MinimizationOperations
operator|.
name|minimize
argument_list|(
name|a
argument_list|)
expr_stmt|;
break|break;
case|case
name|REGEXP_REPEAT_MIN
case|:
name|a
operator|=
name|Operations
operator|.
name|repeat
argument_list|(
name|exp1
operator|.
name|toAutomaton
argument_list|(
name|automata
argument_list|,
name|automaton_provider
argument_list|)
argument_list|,
name|min
argument_list|)
expr_stmt|;
name|a
operator|=
name|MinimizationOperations
operator|.
name|minimize
argument_list|(
name|a
argument_list|)
expr_stmt|;
break|break;
case|case
name|REGEXP_REPEAT_MINMAX
case|:
name|a
operator|=
name|Operations
operator|.
name|repeat
argument_list|(
name|exp1
operator|.
name|toAutomaton
argument_list|(
name|automata
argument_list|,
name|automaton_provider
argument_list|)
argument_list|,
name|min
argument_list|,
name|max
argument_list|)
expr_stmt|;
name|a
operator|=
name|MinimizationOperations
operator|.
name|minimize
argument_list|(
name|a
argument_list|)
expr_stmt|;
break|break;
case|case
name|REGEXP_COMPLEMENT
case|:
name|a
operator|=
name|Operations
operator|.
name|complement
argument_list|(
name|exp1
operator|.
name|toAutomaton
argument_list|(
name|automata
argument_list|,
name|automaton_provider
argument_list|)
argument_list|)
expr_stmt|;
name|a
operator|=
name|MinimizationOperations
operator|.
name|minimize
argument_list|(
name|a
argument_list|)
expr_stmt|;
break|break;
case|case
name|REGEXP_CHAR
case|:
name|a
operator|=
name|Automata
operator|.
name|makeChar
argument_list|(
name|c
argument_list|)
expr_stmt|;
break|break;
case|case
name|REGEXP_CHAR_RANGE
case|:
name|a
operator|=
name|Automata
operator|.
name|makeCharRange
argument_list|(
name|from
argument_list|,
name|to
argument_list|)
expr_stmt|;
break|break;
case|case
name|REGEXP_ANYCHAR
case|:
name|a
operator|=
name|Automata
operator|.
name|makeAnyChar
argument_list|()
expr_stmt|;
break|break;
case|case
name|REGEXP_EMPTY
case|:
name|a
operator|=
name|Automata
operator|.
name|makeEmpty
argument_list|()
expr_stmt|;
break|break;
case|case
name|REGEXP_STRING
case|:
name|a
operator|=
name|Automata
operator|.
name|makeString
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
case|case
name|REGEXP_ANYSTRING
case|:
name|a
operator|=
name|Automata
operator|.
name|makeAnyString
argument_list|()
expr_stmt|;
break|break;
case|case
name|REGEXP_AUTOMATON
case|:
name|Automaton
name|aa
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|automata
operator|!=
literal|null
condition|)
block|{
name|aa
operator|=
name|automata
operator|.
name|get
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|aa
operator|==
literal|null
operator|&&
name|automaton_provider
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|aa
operator|=
name|automaton_provider
operator|.
name|getAutomaton
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
if|if
condition|(
name|aa
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"'"
operator|+
name|s
operator|+
literal|"' not found"
argument_list|)
throw|;
block|}
name|a
operator|=
name|aa
expr_stmt|;
break|break;
case|case
name|REGEXP_INTERVAL
case|:
name|a
operator|=
name|Automata
operator|.
name|makeInterval
argument_list|(
name|min
argument_list|,
name|max
argument_list|,
name|digits
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|a
return|;
block|}
DECL|method|findLeaves
specifier|private
name|void
name|findLeaves
parameter_list|(
name|RegExp
name|exp
parameter_list|,
name|Kind
name|kind
parameter_list|,
name|List
argument_list|<
name|Automaton
argument_list|>
name|list
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|Automaton
argument_list|>
name|automata
parameter_list|,
name|AutomatonProvider
name|automaton_provider
parameter_list|)
block|{
if|if
condition|(
name|exp
operator|.
name|kind
operator|==
name|kind
condition|)
block|{
name|findLeaves
argument_list|(
name|exp
operator|.
name|exp1
argument_list|,
name|kind
argument_list|,
name|list
argument_list|,
name|automata
argument_list|,
name|automaton_provider
argument_list|)
expr_stmt|;
name|findLeaves
argument_list|(
name|exp
operator|.
name|exp2
argument_list|,
name|kind
argument_list|,
name|list
argument_list|,
name|automata
argument_list|,
name|automaton_provider
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|list
operator|.
name|add
argument_list|(
name|exp
operator|.
name|toAutomaton
argument_list|(
name|automata
argument_list|,
name|automaton_provider
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Constructs string from parsed regular expression.    */
annotation|@
name|Override
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|toStringBuilder
argument_list|(
operator|new
name|StringBuilder
argument_list|()
argument_list|)
operator|.
name|toString
argument_list|()
return|;
block|}
DECL|method|toStringBuilder
name|StringBuilder
name|toStringBuilder
parameter_list|(
name|StringBuilder
name|b
parameter_list|)
block|{
switch|switch
condition|(
name|kind
condition|)
block|{
case|case
name|REGEXP_UNION
case|:
name|b
operator|.
name|append
argument_list|(
literal|"("
argument_list|)
expr_stmt|;
name|exp1
operator|.
name|toStringBuilder
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|b
operator|.
name|append
argument_list|(
literal|"|"
argument_list|)
expr_stmt|;
name|exp2
operator|.
name|toStringBuilder
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|b
operator|.
name|append
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|REGEXP_CONCATENATION
case|:
name|exp1
operator|.
name|toStringBuilder
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|exp2
operator|.
name|toStringBuilder
argument_list|(
name|b
argument_list|)
expr_stmt|;
break|break;
case|case
name|REGEXP_INTERSECTION
case|:
name|b
operator|.
name|append
argument_list|(
literal|"("
argument_list|)
expr_stmt|;
name|exp1
operator|.
name|toStringBuilder
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|b
operator|.
name|append
argument_list|(
literal|"&"
argument_list|)
expr_stmt|;
name|exp2
operator|.
name|toStringBuilder
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|b
operator|.
name|append
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|REGEXP_OPTIONAL
case|:
name|b
operator|.
name|append
argument_list|(
literal|"("
argument_list|)
expr_stmt|;
name|exp1
operator|.
name|toStringBuilder
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|b
operator|.
name|append
argument_list|(
literal|")?"
argument_list|)
expr_stmt|;
break|break;
case|case
name|REGEXP_REPEAT
case|:
name|b
operator|.
name|append
argument_list|(
literal|"("
argument_list|)
expr_stmt|;
name|exp1
operator|.
name|toStringBuilder
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|b
operator|.
name|append
argument_list|(
literal|")*"
argument_list|)
expr_stmt|;
break|break;
case|case
name|REGEXP_REPEAT_MIN
case|:
name|b
operator|.
name|append
argument_list|(
literal|"("
argument_list|)
expr_stmt|;
name|exp1
operator|.
name|toStringBuilder
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|b
operator|.
name|append
argument_list|(
literal|"){"
argument_list|)
operator|.
name|append
argument_list|(
name|min
argument_list|)
operator|.
name|append
argument_list|(
literal|",}"
argument_list|)
expr_stmt|;
break|break;
case|case
name|REGEXP_REPEAT_MINMAX
case|:
name|b
operator|.
name|append
argument_list|(
literal|"("
argument_list|)
expr_stmt|;
name|exp1
operator|.
name|toStringBuilder
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|b
operator|.
name|append
argument_list|(
literal|"){"
argument_list|)
operator|.
name|append
argument_list|(
name|min
argument_list|)
operator|.
name|append
argument_list|(
literal|","
argument_list|)
operator|.
name|append
argument_list|(
name|max
argument_list|)
operator|.
name|append
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
break|break;
case|case
name|REGEXP_COMPLEMENT
case|:
name|b
operator|.
name|append
argument_list|(
literal|"~("
argument_list|)
expr_stmt|;
name|exp1
operator|.
name|toStringBuilder
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|b
operator|.
name|append
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|REGEXP_CHAR
case|:
name|b
operator|.
name|append
argument_list|(
literal|"\\"
argument_list|)
operator|.
name|appendCodePoint
argument_list|(
name|c
argument_list|)
expr_stmt|;
break|break;
case|case
name|REGEXP_CHAR_RANGE
case|:
name|b
operator|.
name|append
argument_list|(
literal|"[\\"
argument_list|)
operator|.
name|appendCodePoint
argument_list|(
name|from
argument_list|)
operator|.
name|append
argument_list|(
literal|"-\\"
argument_list|)
operator|.
name|appendCodePoint
argument_list|(
name|to
argument_list|)
operator|.
name|append
argument_list|(
literal|"]"
argument_list|)
expr_stmt|;
break|break;
case|case
name|REGEXP_ANYCHAR
case|:
name|b
operator|.
name|append
argument_list|(
literal|"."
argument_list|)
expr_stmt|;
break|break;
case|case
name|REGEXP_EMPTY
case|:
name|b
operator|.
name|append
argument_list|(
literal|"#"
argument_list|)
expr_stmt|;
break|break;
case|case
name|REGEXP_STRING
case|:
name|b
operator|.
name|append
argument_list|(
literal|"\""
argument_list|)
operator|.
name|append
argument_list|(
name|s
argument_list|)
operator|.
name|append
argument_list|(
literal|"\""
argument_list|)
expr_stmt|;
break|break;
case|case
name|REGEXP_ANYSTRING
case|:
name|b
operator|.
name|append
argument_list|(
literal|"@"
argument_list|)
expr_stmt|;
break|break;
case|case
name|REGEXP_AUTOMATON
case|:
name|b
operator|.
name|append
argument_list|(
literal|"<"
argument_list|)
operator|.
name|append
argument_list|(
name|s
argument_list|)
operator|.
name|append
argument_list|(
literal|">"
argument_list|)
expr_stmt|;
break|break;
case|case
name|REGEXP_INTERVAL
case|:
name|String
name|s1
init|=
name|Integer
operator|.
name|toString
argument_list|(
name|min
argument_list|)
decl_stmt|;
name|String
name|s2
init|=
name|Integer
operator|.
name|toString
argument_list|(
name|max
argument_list|)
decl_stmt|;
name|b
operator|.
name|append
argument_list|(
literal|"<"
argument_list|)
expr_stmt|;
if|if
condition|(
name|digits
operator|>
literal|0
condition|)
for|for
control|(
name|int
name|i
init|=
name|s1
operator|.
name|length
argument_list|()
init|;
name|i
operator|<
name|digits
condition|;
name|i
operator|++
control|)
name|b
operator|.
name|append
argument_list|(
literal|'0'
argument_list|)
expr_stmt|;
name|b
operator|.
name|append
argument_list|(
name|s1
argument_list|)
operator|.
name|append
argument_list|(
literal|"-"
argument_list|)
expr_stmt|;
if|if
condition|(
name|digits
operator|>
literal|0
condition|)
for|for
control|(
name|int
name|i
init|=
name|s2
operator|.
name|length
argument_list|()
init|;
name|i
operator|<
name|digits
condition|;
name|i
operator|++
control|)
name|b
operator|.
name|append
argument_list|(
literal|'0'
argument_list|)
expr_stmt|;
name|b
operator|.
name|append
argument_list|(
name|s2
argument_list|)
operator|.
name|append
argument_list|(
literal|">"
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|b
return|;
block|}
comment|/**    * Returns set of automaton identifiers that occur in this regular expression.    */
DECL|method|getIdentifiers
specifier|public
name|Set
argument_list|<
name|String
argument_list|>
name|getIdentifiers
parameter_list|()
block|{
name|HashSet
argument_list|<
name|String
argument_list|>
name|set
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
name|getIdentifiers
argument_list|(
name|set
argument_list|)
expr_stmt|;
return|return
name|set
return|;
block|}
DECL|method|getIdentifiers
name|void
name|getIdentifiers
parameter_list|(
name|Set
argument_list|<
name|String
argument_list|>
name|set
parameter_list|)
block|{
switch|switch
condition|(
name|kind
condition|)
block|{
case|case
name|REGEXP_UNION
case|:
case|case
name|REGEXP_CONCATENATION
case|:
case|case
name|REGEXP_INTERSECTION
case|:
name|exp1
operator|.
name|getIdentifiers
argument_list|(
name|set
argument_list|)
expr_stmt|;
name|exp2
operator|.
name|getIdentifiers
argument_list|(
name|set
argument_list|)
expr_stmt|;
break|break;
case|case
name|REGEXP_OPTIONAL
case|:
case|case
name|REGEXP_REPEAT
case|:
case|case
name|REGEXP_REPEAT_MIN
case|:
case|case
name|REGEXP_REPEAT_MINMAX
case|:
case|case
name|REGEXP_COMPLEMENT
case|:
name|exp1
operator|.
name|getIdentifiers
argument_list|(
name|set
argument_list|)
expr_stmt|;
break|break;
case|case
name|REGEXP_AUTOMATON
case|:
name|set
operator|.
name|add
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
default|default:
block|}
block|}
DECL|method|makeUnion
specifier|static
name|RegExp
name|makeUnion
parameter_list|(
name|RegExp
name|exp1
parameter_list|,
name|RegExp
name|exp2
parameter_list|)
block|{
name|RegExp
name|r
init|=
operator|new
name|RegExp
argument_list|()
decl_stmt|;
name|r
operator|.
name|kind
operator|=
name|Kind
operator|.
name|REGEXP_UNION
expr_stmt|;
name|r
operator|.
name|exp1
operator|=
name|exp1
expr_stmt|;
name|r
operator|.
name|exp2
operator|=
name|exp2
expr_stmt|;
return|return
name|r
return|;
block|}
DECL|method|makeConcatenation
specifier|static
name|RegExp
name|makeConcatenation
parameter_list|(
name|RegExp
name|exp1
parameter_list|,
name|RegExp
name|exp2
parameter_list|)
block|{
if|if
condition|(
operator|(
name|exp1
operator|.
name|kind
operator|==
name|Kind
operator|.
name|REGEXP_CHAR
operator|||
name|exp1
operator|.
name|kind
operator|==
name|Kind
operator|.
name|REGEXP_STRING
operator|)
operator|&&
operator|(
name|exp2
operator|.
name|kind
operator|==
name|Kind
operator|.
name|REGEXP_CHAR
operator|||
name|exp2
operator|.
name|kind
operator|==
name|Kind
operator|.
name|REGEXP_STRING
operator|)
condition|)
return|return
name|makeString
argument_list|(
name|exp1
argument_list|,
name|exp2
argument_list|)
return|;
name|RegExp
name|r
init|=
operator|new
name|RegExp
argument_list|()
decl_stmt|;
name|r
operator|.
name|kind
operator|=
name|Kind
operator|.
name|REGEXP_CONCATENATION
expr_stmt|;
if|if
condition|(
name|exp1
operator|.
name|kind
operator|==
name|Kind
operator|.
name|REGEXP_CONCATENATION
operator|&&
operator|(
name|exp1
operator|.
name|exp2
operator|.
name|kind
operator|==
name|Kind
operator|.
name|REGEXP_CHAR
operator|||
name|exp1
operator|.
name|exp2
operator|.
name|kind
operator|==
name|Kind
operator|.
name|REGEXP_STRING
operator|)
operator|&&
operator|(
name|exp2
operator|.
name|kind
operator|==
name|Kind
operator|.
name|REGEXP_CHAR
operator|||
name|exp2
operator|.
name|kind
operator|==
name|Kind
operator|.
name|REGEXP_STRING
operator|)
condition|)
block|{
name|r
operator|.
name|exp1
operator|=
name|exp1
operator|.
name|exp1
expr_stmt|;
name|r
operator|.
name|exp2
operator|=
name|makeString
argument_list|(
name|exp1
operator|.
name|exp2
argument_list|,
name|exp2
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|exp1
operator|.
name|kind
operator|==
name|Kind
operator|.
name|REGEXP_CHAR
operator|||
name|exp1
operator|.
name|kind
operator|==
name|Kind
operator|.
name|REGEXP_STRING
operator|)
operator|&&
name|exp2
operator|.
name|kind
operator|==
name|Kind
operator|.
name|REGEXP_CONCATENATION
operator|&&
operator|(
name|exp2
operator|.
name|exp1
operator|.
name|kind
operator|==
name|Kind
operator|.
name|REGEXP_CHAR
operator|||
name|exp2
operator|.
name|exp1
operator|.
name|kind
operator|==
name|Kind
operator|.
name|REGEXP_STRING
operator|)
condition|)
block|{
name|r
operator|.
name|exp1
operator|=
name|makeString
argument_list|(
name|exp1
argument_list|,
name|exp2
operator|.
name|exp1
argument_list|)
expr_stmt|;
name|r
operator|.
name|exp2
operator|=
name|exp2
operator|.
name|exp2
expr_stmt|;
block|}
else|else
block|{
name|r
operator|.
name|exp1
operator|=
name|exp1
expr_stmt|;
name|r
operator|.
name|exp2
operator|=
name|exp2
expr_stmt|;
block|}
return|return
name|r
return|;
block|}
DECL|method|makeString
specifier|static
specifier|private
name|RegExp
name|makeString
parameter_list|(
name|RegExp
name|exp1
parameter_list|,
name|RegExp
name|exp2
parameter_list|)
block|{
name|StringBuilder
name|b
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
if|if
condition|(
name|exp1
operator|.
name|kind
operator|==
name|Kind
operator|.
name|REGEXP_STRING
condition|)
name|b
operator|.
name|append
argument_list|(
name|exp1
operator|.
name|s
argument_list|)
expr_stmt|;
else|else
name|b
operator|.
name|appendCodePoint
argument_list|(
name|exp1
operator|.
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|exp2
operator|.
name|kind
operator|==
name|Kind
operator|.
name|REGEXP_STRING
condition|)
name|b
operator|.
name|append
argument_list|(
name|exp2
operator|.
name|s
argument_list|)
expr_stmt|;
else|else
name|b
operator|.
name|appendCodePoint
argument_list|(
name|exp2
operator|.
name|c
argument_list|)
expr_stmt|;
return|return
name|makeString
argument_list|(
name|b
operator|.
name|toString
argument_list|()
argument_list|)
return|;
block|}
DECL|method|makeIntersection
specifier|static
name|RegExp
name|makeIntersection
parameter_list|(
name|RegExp
name|exp1
parameter_list|,
name|RegExp
name|exp2
parameter_list|)
block|{
name|RegExp
name|r
init|=
operator|new
name|RegExp
argument_list|()
decl_stmt|;
name|r
operator|.
name|kind
operator|=
name|Kind
operator|.
name|REGEXP_INTERSECTION
expr_stmt|;
name|r
operator|.
name|exp1
operator|=
name|exp1
expr_stmt|;
name|r
operator|.
name|exp2
operator|=
name|exp2
expr_stmt|;
return|return
name|r
return|;
block|}
DECL|method|makeOptional
specifier|static
name|RegExp
name|makeOptional
parameter_list|(
name|RegExp
name|exp
parameter_list|)
block|{
name|RegExp
name|r
init|=
operator|new
name|RegExp
argument_list|()
decl_stmt|;
name|r
operator|.
name|kind
operator|=
name|Kind
operator|.
name|REGEXP_OPTIONAL
expr_stmt|;
name|r
operator|.
name|exp1
operator|=
name|exp
expr_stmt|;
return|return
name|r
return|;
block|}
DECL|method|makeRepeat
specifier|static
name|RegExp
name|makeRepeat
parameter_list|(
name|RegExp
name|exp
parameter_list|)
block|{
name|RegExp
name|r
init|=
operator|new
name|RegExp
argument_list|()
decl_stmt|;
name|r
operator|.
name|kind
operator|=
name|Kind
operator|.
name|REGEXP_REPEAT
expr_stmt|;
name|r
operator|.
name|exp1
operator|=
name|exp
expr_stmt|;
return|return
name|r
return|;
block|}
DECL|method|makeRepeat
specifier|static
name|RegExp
name|makeRepeat
parameter_list|(
name|RegExp
name|exp
parameter_list|,
name|int
name|min
parameter_list|)
block|{
name|RegExp
name|r
init|=
operator|new
name|RegExp
argument_list|()
decl_stmt|;
name|r
operator|.
name|kind
operator|=
name|Kind
operator|.
name|REGEXP_REPEAT_MIN
expr_stmt|;
name|r
operator|.
name|exp1
operator|=
name|exp
expr_stmt|;
name|r
operator|.
name|min
operator|=
name|min
expr_stmt|;
return|return
name|r
return|;
block|}
DECL|method|makeRepeat
specifier|static
name|RegExp
name|makeRepeat
parameter_list|(
name|RegExp
name|exp
parameter_list|,
name|int
name|min
parameter_list|,
name|int
name|max
parameter_list|)
block|{
name|RegExp
name|r
init|=
operator|new
name|RegExp
argument_list|()
decl_stmt|;
name|r
operator|.
name|kind
operator|=
name|Kind
operator|.
name|REGEXP_REPEAT_MINMAX
expr_stmt|;
name|r
operator|.
name|exp1
operator|=
name|exp
expr_stmt|;
name|r
operator|.
name|min
operator|=
name|min
expr_stmt|;
name|r
operator|.
name|max
operator|=
name|max
expr_stmt|;
return|return
name|r
return|;
block|}
DECL|method|makeComplement
specifier|static
name|RegExp
name|makeComplement
parameter_list|(
name|RegExp
name|exp
parameter_list|)
block|{
name|RegExp
name|r
init|=
operator|new
name|RegExp
argument_list|()
decl_stmt|;
name|r
operator|.
name|kind
operator|=
name|Kind
operator|.
name|REGEXP_COMPLEMENT
expr_stmt|;
name|r
operator|.
name|exp1
operator|=
name|exp
expr_stmt|;
return|return
name|r
return|;
block|}
DECL|method|makeChar
specifier|static
name|RegExp
name|makeChar
parameter_list|(
name|int
name|c
parameter_list|)
block|{
name|RegExp
name|r
init|=
operator|new
name|RegExp
argument_list|()
decl_stmt|;
name|r
operator|.
name|kind
operator|=
name|Kind
operator|.
name|REGEXP_CHAR
expr_stmt|;
name|r
operator|.
name|c
operator|=
name|c
expr_stmt|;
return|return
name|r
return|;
block|}
DECL|method|makeCharRange
specifier|static
name|RegExp
name|makeCharRange
parameter_list|(
name|int
name|from
parameter_list|,
name|int
name|to
parameter_list|)
block|{
if|if
condition|(
name|from
operator|>
name|to
condition|)
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"invalid range: from ("
operator|+
name|from
operator|+
literal|") cannot be> to ("
operator|+
name|to
operator|+
literal|")"
argument_list|)
throw|;
name|RegExp
name|r
init|=
operator|new
name|RegExp
argument_list|()
decl_stmt|;
name|r
operator|.
name|kind
operator|=
name|Kind
operator|.
name|REGEXP_CHAR_RANGE
expr_stmt|;
name|r
operator|.
name|from
operator|=
name|from
expr_stmt|;
name|r
operator|.
name|to
operator|=
name|to
expr_stmt|;
return|return
name|r
return|;
block|}
DECL|method|makeAnyChar
specifier|static
name|RegExp
name|makeAnyChar
parameter_list|()
block|{
name|RegExp
name|r
init|=
operator|new
name|RegExp
argument_list|()
decl_stmt|;
name|r
operator|.
name|kind
operator|=
name|Kind
operator|.
name|REGEXP_ANYCHAR
expr_stmt|;
return|return
name|r
return|;
block|}
DECL|method|makeEmpty
specifier|static
name|RegExp
name|makeEmpty
parameter_list|()
block|{
name|RegExp
name|r
init|=
operator|new
name|RegExp
argument_list|()
decl_stmt|;
name|r
operator|.
name|kind
operator|=
name|Kind
operator|.
name|REGEXP_EMPTY
expr_stmt|;
return|return
name|r
return|;
block|}
DECL|method|makeString
specifier|static
name|RegExp
name|makeString
parameter_list|(
name|String
name|s
parameter_list|)
block|{
name|RegExp
name|r
init|=
operator|new
name|RegExp
argument_list|()
decl_stmt|;
name|r
operator|.
name|kind
operator|=
name|Kind
operator|.
name|REGEXP_STRING
expr_stmt|;
name|r
operator|.
name|s
operator|=
name|s
expr_stmt|;
return|return
name|r
return|;
block|}
DECL|method|makeAnyString
specifier|static
name|RegExp
name|makeAnyString
parameter_list|()
block|{
name|RegExp
name|r
init|=
operator|new
name|RegExp
argument_list|()
decl_stmt|;
name|r
operator|.
name|kind
operator|=
name|Kind
operator|.
name|REGEXP_ANYSTRING
expr_stmt|;
return|return
name|r
return|;
block|}
DECL|method|makeAutomaton
specifier|static
name|RegExp
name|makeAutomaton
parameter_list|(
name|String
name|s
parameter_list|)
block|{
name|RegExp
name|r
init|=
operator|new
name|RegExp
argument_list|()
decl_stmt|;
name|r
operator|.
name|kind
operator|=
name|Kind
operator|.
name|REGEXP_AUTOMATON
expr_stmt|;
name|r
operator|.
name|s
operator|=
name|s
expr_stmt|;
return|return
name|r
return|;
block|}
DECL|method|makeInterval
specifier|static
name|RegExp
name|makeInterval
parameter_list|(
name|int
name|min
parameter_list|,
name|int
name|max
parameter_list|,
name|int
name|digits
parameter_list|)
block|{
name|RegExp
name|r
init|=
operator|new
name|RegExp
argument_list|()
decl_stmt|;
name|r
operator|.
name|kind
operator|=
name|Kind
operator|.
name|REGEXP_INTERVAL
expr_stmt|;
name|r
operator|.
name|min
operator|=
name|min
expr_stmt|;
name|r
operator|.
name|max
operator|=
name|max
expr_stmt|;
name|r
operator|.
name|digits
operator|=
name|digits
expr_stmt|;
return|return
name|r
return|;
block|}
DECL|method|peek
specifier|private
name|boolean
name|peek
parameter_list|(
name|String
name|s
parameter_list|)
block|{
return|return
name|more
argument_list|()
operator|&&
name|s
operator|.
name|indexOf
argument_list|(
name|b
operator|.
name|codePointAt
argument_list|(
name|pos
argument_list|)
argument_list|)
operator|!=
operator|-
literal|1
return|;
block|}
DECL|method|match
specifier|private
name|boolean
name|match
parameter_list|(
name|int
name|c
parameter_list|)
block|{
if|if
condition|(
name|pos
operator|>=
name|b
operator|.
name|length
argument_list|()
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|b
operator|.
name|codePointAt
argument_list|(
name|pos
argument_list|)
operator|==
name|c
condition|)
block|{
name|pos
operator|+=
name|Character
operator|.
name|charCount
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
DECL|method|more
specifier|private
name|boolean
name|more
parameter_list|()
block|{
return|return
name|pos
operator|<
name|b
operator|.
name|length
argument_list|()
return|;
block|}
DECL|method|next
specifier|private
name|int
name|next
parameter_list|()
throws|throws
name|IllegalArgumentException
block|{
if|if
condition|(
operator|!
name|more
argument_list|()
condition|)
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"unexpected end-of-string"
argument_list|)
throw|;
name|int
name|ch
init|=
name|b
operator|.
name|codePointAt
argument_list|(
name|pos
argument_list|)
decl_stmt|;
name|pos
operator|+=
name|Character
operator|.
name|charCount
argument_list|(
name|ch
argument_list|)
expr_stmt|;
return|return
name|ch
return|;
block|}
DECL|method|check
specifier|private
name|boolean
name|check
parameter_list|(
name|int
name|flag
parameter_list|)
block|{
return|return
operator|(
name|flags
operator|&
name|flag
operator|)
operator|!=
literal|0
return|;
block|}
DECL|method|parseUnionExp
specifier|final
name|RegExp
name|parseUnionExp
parameter_list|()
throws|throws
name|IllegalArgumentException
block|{
name|RegExp
name|e
init|=
name|parseInterExp
argument_list|()
decl_stmt|;
if|if
condition|(
name|match
argument_list|(
literal|'|'
argument_list|)
condition|)
name|e
operator|=
name|makeUnion
argument_list|(
name|e
argument_list|,
name|parseUnionExp
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|e
return|;
block|}
DECL|method|parseInterExp
specifier|final
name|RegExp
name|parseInterExp
parameter_list|()
throws|throws
name|IllegalArgumentException
block|{
name|RegExp
name|e
init|=
name|parseConcatExp
argument_list|()
decl_stmt|;
if|if
condition|(
name|check
argument_list|(
name|INTERSECTION
argument_list|)
operator|&&
name|match
argument_list|(
literal|'&'
argument_list|)
condition|)
name|e
operator|=
name|makeIntersection
argument_list|(
name|e
argument_list|,
name|parseInterExp
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|e
return|;
block|}
DECL|method|parseConcatExp
specifier|final
name|RegExp
name|parseConcatExp
parameter_list|()
throws|throws
name|IllegalArgumentException
block|{
name|RegExp
name|e
init|=
name|parseRepeatExp
argument_list|()
decl_stmt|;
if|if
condition|(
name|more
argument_list|()
operator|&&
operator|!
name|peek
argument_list|(
literal|")|"
argument_list|)
operator|&&
operator|(
operator|!
name|check
argument_list|(
name|INTERSECTION
argument_list|)
operator|||
operator|!
name|peek
argument_list|(
literal|"&"
argument_list|)
operator|)
condition|)
name|e
operator|=
name|makeConcatenation
argument_list|(
name|e
argument_list|,
name|parseConcatExp
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|e
return|;
block|}
DECL|method|parseRepeatExp
specifier|final
name|RegExp
name|parseRepeatExp
parameter_list|()
throws|throws
name|IllegalArgumentException
block|{
name|RegExp
name|e
init|=
name|parseComplExp
argument_list|()
decl_stmt|;
while|while
condition|(
name|peek
argument_list|(
literal|"?*+{"
argument_list|)
condition|)
block|{
if|if
condition|(
name|match
argument_list|(
literal|'?'
argument_list|)
condition|)
name|e
operator|=
name|makeOptional
argument_list|(
name|e
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|match
argument_list|(
literal|'*'
argument_list|)
condition|)
name|e
operator|=
name|makeRepeat
argument_list|(
name|e
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|match
argument_list|(
literal|'+'
argument_list|)
condition|)
name|e
operator|=
name|makeRepeat
argument_list|(
name|e
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|match
argument_list|(
literal|'{'
argument_list|)
condition|)
block|{
name|int
name|start
init|=
name|pos
decl_stmt|;
while|while
condition|(
name|peek
argument_list|(
literal|"0123456789"
argument_list|)
condition|)
name|next
argument_list|()
expr_stmt|;
if|if
condition|(
name|start
operator|==
name|pos
condition|)
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"integer expected at position "
operator|+
name|pos
argument_list|)
throw|;
name|int
name|n
init|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|b
operator|.
name|substring
argument_list|(
name|start
argument_list|,
name|pos
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|m
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|match
argument_list|(
literal|','
argument_list|)
condition|)
block|{
name|start
operator|=
name|pos
expr_stmt|;
while|while
condition|(
name|peek
argument_list|(
literal|"0123456789"
argument_list|)
condition|)
name|next
argument_list|()
expr_stmt|;
if|if
condition|(
name|start
operator|!=
name|pos
condition|)
name|m
operator|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|b
operator|.
name|substring
argument_list|(
name|start
argument_list|,
name|pos
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|m
operator|=
name|n
expr_stmt|;
if|if
condition|(
operator|!
name|match
argument_list|(
literal|'}'
argument_list|)
condition|)
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"expected '}' at position "
operator|+
name|pos
argument_list|)
throw|;
if|if
condition|(
name|m
operator|==
operator|-
literal|1
condition|)
name|e
operator|=
name|makeRepeat
argument_list|(
name|e
argument_list|,
name|n
argument_list|)
expr_stmt|;
else|else
name|e
operator|=
name|makeRepeat
argument_list|(
name|e
argument_list|,
name|n
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|e
return|;
block|}
DECL|method|parseComplExp
specifier|final
name|RegExp
name|parseComplExp
parameter_list|()
throws|throws
name|IllegalArgumentException
block|{
if|if
condition|(
name|check
argument_list|(
name|COMPLEMENT
argument_list|)
operator|&&
name|match
argument_list|(
literal|'~'
argument_list|)
condition|)
return|return
name|makeComplement
argument_list|(
name|parseComplExp
argument_list|()
argument_list|)
return|;
else|else
return|return
name|parseCharClassExp
argument_list|()
return|;
block|}
DECL|method|parseCharClassExp
specifier|final
name|RegExp
name|parseCharClassExp
parameter_list|()
throws|throws
name|IllegalArgumentException
block|{
if|if
condition|(
name|match
argument_list|(
literal|'['
argument_list|)
condition|)
block|{
name|boolean
name|negate
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|match
argument_list|(
literal|'^'
argument_list|)
condition|)
name|negate
operator|=
literal|true
expr_stmt|;
name|RegExp
name|e
init|=
name|parseCharClasses
argument_list|()
decl_stmt|;
if|if
condition|(
name|negate
condition|)
name|e
operator|=
name|makeIntersection
argument_list|(
name|makeAnyChar
argument_list|()
argument_list|,
name|makeComplement
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|match
argument_list|(
literal|']'
argument_list|)
condition|)
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"expected ']' at position "
operator|+
name|pos
argument_list|)
throw|;
return|return
name|e
return|;
block|}
else|else
return|return
name|parseSimpleExp
argument_list|()
return|;
block|}
DECL|method|parseCharClasses
specifier|final
name|RegExp
name|parseCharClasses
parameter_list|()
throws|throws
name|IllegalArgumentException
block|{
name|RegExp
name|e
init|=
name|parseCharClass
argument_list|()
decl_stmt|;
while|while
condition|(
name|more
argument_list|()
operator|&&
operator|!
name|peek
argument_list|(
literal|"]"
argument_list|)
condition|)
name|e
operator|=
name|makeUnion
argument_list|(
name|e
argument_list|,
name|parseCharClass
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|e
return|;
block|}
DECL|method|parseCharClass
specifier|final
name|RegExp
name|parseCharClass
parameter_list|()
throws|throws
name|IllegalArgumentException
block|{
name|int
name|c
init|=
name|parseCharExp
argument_list|()
decl_stmt|;
if|if
condition|(
name|match
argument_list|(
literal|'-'
argument_list|)
condition|)
return|return
name|makeCharRange
argument_list|(
name|c
argument_list|,
name|parseCharExp
argument_list|()
argument_list|)
return|;
else|else
return|return
name|makeChar
argument_list|(
name|c
argument_list|)
return|;
block|}
DECL|method|parseSimpleExp
specifier|final
name|RegExp
name|parseSimpleExp
parameter_list|()
throws|throws
name|IllegalArgumentException
block|{
if|if
condition|(
name|match
argument_list|(
literal|'.'
argument_list|)
condition|)
return|return
name|makeAnyChar
argument_list|()
return|;
elseif|else
if|if
condition|(
name|check
argument_list|(
name|EMPTY
argument_list|)
operator|&&
name|match
argument_list|(
literal|'#'
argument_list|)
condition|)
return|return
name|makeEmpty
argument_list|()
return|;
elseif|else
if|if
condition|(
name|check
argument_list|(
name|ANYSTRING
argument_list|)
operator|&&
name|match
argument_list|(
literal|'@'
argument_list|)
condition|)
return|return
name|makeAnyString
argument_list|()
return|;
elseif|else
if|if
condition|(
name|match
argument_list|(
literal|'"'
argument_list|)
condition|)
block|{
name|int
name|start
init|=
name|pos
decl_stmt|;
while|while
condition|(
name|more
argument_list|()
operator|&&
operator|!
name|peek
argument_list|(
literal|"\""
argument_list|)
condition|)
name|next
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|match
argument_list|(
literal|'"'
argument_list|)
condition|)
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"expected '\"' at position "
operator|+
name|pos
argument_list|)
throw|;
return|return
name|makeString
argument_list|(
name|b
operator|.
name|substring
argument_list|(
name|start
argument_list|,
name|pos
operator|-
literal|1
argument_list|)
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|match
argument_list|(
literal|'('
argument_list|)
condition|)
block|{
if|if
condition|(
name|match
argument_list|(
literal|')'
argument_list|)
condition|)
return|return
name|makeString
argument_list|(
literal|""
argument_list|)
return|;
name|RegExp
name|e
init|=
name|parseUnionExp
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|match
argument_list|(
literal|')'
argument_list|)
condition|)
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"expected ')' at position "
operator|+
name|pos
argument_list|)
throw|;
return|return
name|e
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|check
argument_list|(
name|AUTOMATON
argument_list|)
operator|||
name|check
argument_list|(
name|INTERVAL
argument_list|)
operator|)
operator|&&
name|match
argument_list|(
literal|'<'
argument_list|)
condition|)
block|{
name|int
name|start
init|=
name|pos
decl_stmt|;
while|while
condition|(
name|more
argument_list|()
operator|&&
operator|!
name|peek
argument_list|(
literal|">"
argument_list|)
condition|)
name|next
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|match
argument_list|(
literal|'>'
argument_list|)
condition|)
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"expected '>' at position "
operator|+
name|pos
argument_list|)
throw|;
name|String
name|s
init|=
name|b
operator|.
name|substring
argument_list|(
name|start
argument_list|,
name|pos
operator|-
literal|1
argument_list|)
decl_stmt|;
name|int
name|i
init|=
name|s
operator|.
name|indexOf
argument_list|(
literal|'-'
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|check
argument_list|(
name|AUTOMATON
argument_list|)
condition|)
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"interval syntax error at position "
operator|+
operator|(
name|pos
operator|-
literal|1
operator|)
argument_list|)
throw|;
return|return
name|makeAutomaton
argument_list|(
name|s
argument_list|)
return|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|check
argument_list|(
name|INTERVAL
argument_list|)
condition|)
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"illegal identifier at position "
operator|+
operator|(
name|pos
operator|-
literal|1
operator|)
argument_list|)
throw|;
try|try
block|{
if|if
condition|(
name|i
operator|==
literal|0
operator|||
name|i
operator|==
name|s
operator|.
name|length
argument_list|()
operator|-
literal|1
operator|||
name|i
operator|!=
name|s
operator|.
name|lastIndexOf
argument_list|(
literal|'-'
argument_list|)
condition|)
throw|throw
operator|new
name|NumberFormatException
argument_list|()
throw|;
name|String
name|smin
init|=
name|s
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|String
name|smax
init|=
name|s
operator|.
name|substring
argument_list|(
name|i
operator|+
literal|1
argument_list|,
name|s
operator|.
name|length
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|imin
init|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|smin
argument_list|)
decl_stmt|;
name|int
name|imax
init|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|smax
argument_list|)
decl_stmt|;
name|int
name|digits
decl_stmt|;
if|if
condition|(
name|smin
operator|.
name|length
argument_list|()
operator|==
name|smax
operator|.
name|length
argument_list|()
condition|)
name|digits
operator|=
name|smin
operator|.
name|length
argument_list|()
expr_stmt|;
else|else
name|digits
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|imin
operator|>
name|imax
condition|)
block|{
name|int
name|t
init|=
name|imin
decl_stmt|;
name|imin
operator|=
name|imax
expr_stmt|;
name|imax
operator|=
name|t
expr_stmt|;
block|}
return|return
name|makeInterval
argument_list|(
name|imin
argument_list|,
name|imax
argument_list|,
name|digits
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"interval syntax error at position "
operator|+
operator|(
name|pos
operator|-
literal|1
operator|)
argument_list|)
throw|;
block|}
block|}
block|}
else|else
return|return
name|makeChar
argument_list|(
name|parseCharExp
argument_list|()
argument_list|)
return|;
block|}
DECL|method|parseCharExp
specifier|final
name|int
name|parseCharExp
parameter_list|()
throws|throws
name|IllegalArgumentException
block|{
name|match
argument_list|(
literal|'\\'
argument_list|)
expr_stmt|;
return|return
name|next
argument_list|()
return|;
block|}
block|}
end_class
end_unit
