begin_unit
begin_package
DECL|package|org.apache.lucene.util.automaton
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|automaton
package|;
end_package
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|PrintWriter
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|BitSet
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedList
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|ArrayUtil
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|InPlaceMergeSorter
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|Sorter
import|;
end_import
begin_comment
comment|// nocommit make tests that do the same ops w/ old and new and assertSameLang
end_comment
begin_comment
comment|// TODO
end_comment
begin_comment
comment|//   - could use packed int arrays instead
end_comment
begin_comment
comment|//   - could encode dest w/ delta from to?
end_comment
begin_comment
comment|// nocommit should we keep determinized bit?
end_comment
begin_comment
comment|/** Uses only int[]s to represent the automaton, but requires that all  *  transitions for each state are added at once.  If this is too restrictive,  *  use {@link #Builder} instead.  State 0 is always the  *  initial state.  *  * @lucene.experimental */
end_comment
begin_comment
comment|// nocommit rename to Automaton once everything is cutover
end_comment
begin_class
DECL|class|LightAutomaton
specifier|public
class|class
name|LightAutomaton
block|{
DECL|field|nextState
specifier|private
name|int
name|nextState
decl_stmt|;
comment|/** Where we next write to in int[] transitions; this    *  increments by 3 for each added transition because we    *  pack min, max, dest in sequence. */
DECL|field|nextTransition
specifier|private
name|int
name|nextTransition
decl_stmt|;
comment|/** Current state we are adding transitions to; the caller    *  must add all transitions for this state before moving    *  onto another state. */
DECL|field|curState
specifier|private
name|int
name|curState
init|=
operator|-
literal|1
decl_stmt|;
comment|/** Index in the transitions array, where this states    *  leaving transitions are stored, or -1 if this state    *  has not added any transitions yet, followed by number    *  of transitions. */
DECL|field|states
specifier|private
name|int
index|[]
name|states
init|=
operator|new
name|int
index|[
literal|4
index|]
decl_stmt|;
comment|/** Holds toState, min, max for each transition: */
comment|// nocommit inefficient when labels are really bytes (max 256)
DECL|field|transitions
specifier|private
name|int
index|[]
name|transitions
init|=
operator|new
name|int
index|[
literal|6
index|]
decl_stmt|;
DECL|field|finalStates
specifier|private
specifier|final
name|Set
argument_list|<
name|Integer
argument_list|>
name|finalStates
init|=
operator|new
name|HashSet
argument_list|<
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
DECL|method|createState
specifier|public
name|int
name|createState
parameter_list|()
block|{
name|growStates
argument_list|()
expr_stmt|;
name|int
name|state
init|=
name|nextState
operator|/
literal|2
decl_stmt|;
name|states
index|[
name|nextState
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|nextState
operator|+=
literal|2
expr_stmt|;
return|return
name|state
return|;
block|}
comment|/** Mark this state as an accept state. */
DECL|method|setAccept
specifier|public
name|void
name|setAccept
parameter_list|(
name|int
name|state
parameter_list|,
name|boolean
name|isAccept
parameter_list|)
block|{
if|if
condition|(
name|isAccept
condition|)
block|{
name|finalStates
operator|.
name|add
argument_list|(
name|state
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|finalStates
operator|.
name|remove
argument_list|(
name|state
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|isEmpty
specifier|public
name|boolean
name|isEmpty
parameter_list|()
block|{
return|return
name|finalStates
operator|.
name|isEmpty
argument_list|()
return|;
block|}
comment|/** Sugar, but object-heavy; it's better to iterate instead. */
DECL|method|getSortedTransitions
specifier|public
name|Transition
index|[]
index|[]
name|getSortedTransitions
parameter_list|()
block|{
name|int
name|numStates
init|=
name|getNumStates
argument_list|()
decl_stmt|;
name|Transition
index|[]
index|[]
name|transitions
init|=
operator|new
name|Transition
index|[
name|numStates
index|]
index|[]
decl_stmt|;
for|for
control|(
name|int
name|s
init|=
literal|0
init|;
name|s
operator|<
name|numStates
condition|;
name|s
operator|++
control|)
block|{
name|int
name|numTransitions
init|=
name|getNumTransitions
argument_list|(
name|s
argument_list|)
decl_stmt|;
name|transitions
index|[
name|s
index|]
operator|=
operator|new
name|Transition
index|[
name|numTransitions
index|]
expr_stmt|;
for|for
control|(
name|int
name|t
init|=
literal|0
init|;
name|t
operator|<
name|numTransitions
condition|;
name|t
operator|++
control|)
block|{
name|Transition
name|transition
init|=
operator|new
name|Transition
argument_list|()
decl_stmt|;
name|getTransition
argument_list|(
name|s
argument_list|,
name|t
argument_list|,
name|transition
argument_list|)
expr_stmt|;
name|transitions
index|[
name|s
index|]
index|[
name|t
index|]
operator|=
name|transition
expr_stmt|;
block|}
block|}
return|return
name|transitions
return|;
block|}
DECL|method|getAcceptStates
specifier|public
name|Set
argument_list|<
name|Integer
argument_list|>
name|getAcceptStates
parameter_list|()
block|{
return|return
name|finalStates
return|;
block|}
comment|/** Returns true if this state is an accept state. */
DECL|method|isAccept
specifier|public
name|boolean
name|isAccept
parameter_list|(
name|int
name|state
parameter_list|)
block|{
return|return
name|finalStates
operator|.
name|contains
argument_list|(
name|state
argument_list|)
return|;
block|}
DECL|method|addTransition
specifier|public
name|void
name|addTransition
parameter_list|(
name|int
name|source
parameter_list|,
name|int
name|dest
parameter_list|,
name|int
name|label
parameter_list|)
block|{
name|addTransition
argument_list|(
name|source
argument_list|,
name|dest
argument_list|,
name|label
argument_list|,
name|label
argument_list|)
expr_stmt|;
block|}
DECL|method|addTransition
specifier|public
name|void
name|addTransition
parameter_list|(
name|int
name|source
parameter_list|,
name|int
name|dest
parameter_list|,
name|int
name|min
parameter_list|,
name|int
name|max
parameter_list|)
block|{
assert|assert
name|nextTransition
operator|%
literal|3
operator|==
literal|0
assert|;
if|if
condition|(
name|source
operator|>=
name|nextState
operator|/
literal|2
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"source is out of bounds"
argument_list|)
throw|;
block|}
if|if
condition|(
name|dest
operator|>=
name|nextState
operator|/
literal|2
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"dest is out of bounds"
argument_list|)
throw|;
block|}
comment|//System.out.println("  addTransition nextTransition=" + nextTransition + " source=" + source + " dest=" + dest + " min=" + min + " max=" + max);
name|growTransitions
argument_list|()
expr_stmt|;
if|if
condition|(
name|curState
operator|!=
name|source
condition|)
block|{
comment|//System.out.println("    newstate");
if|if
condition|(
name|curState
operator|!=
operator|-
literal|1
condition|)
block|{
name|finishCurrentState
argument_list|()
expr_stmt|;
block|}
comment|// Move to next source:
name|curState
operator|=
name|source
expr_stmt|;
if|if
condition|(
name|states
index|[
literal|2
operator|*
name|curState
index|]
operator|!=
operator|-
literal|1
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"from state ("
operator|+
name|source
operator|+
literal|") already had transitions added"
argument_list|)
throw|;
block|}
assert|assert
name|states
index|[
literal|2
operator|*
name|curState
operator|+
literal|1
index|]
operator|==
literal|0
assert|;
name|states
index|[
literal|2
operator|*
name|curState
index|]
operator|=
name|nextTransition
expr_stmt|;
block|}
name|transitions
index|[
name|nextTransition
operator|++
index|]
operator|=
name|dest
expr_stmt|;
name|transitions
index|[
name|nextTransition
operator|++
index|]
operator|=
name|min
expr_stmt|;
name|transitions
index|[
name|nextTransition
operator|++
index|]
operator|=
name|max
expr_stmt|;
comment|// Increment transition count for this state
name|states
index|[
literal|2
operator|*
name|curState
operator|+
literal|1
index|]
operator|++
expr_stmt|;
block|}
DECL|method|addEpsilon
specifier|public
name|void
name|addEpsilon
parameter_list|(
name|int
name|source
parameter_list|,
name|int
name|dest
parameter_list|)
block|{
name|Transition
name|t
init|=
operator|new
name|Transition
argument_list|()
decl_stmt|;
name|int
name|count
init|=
name|initTransition
argument_list|(
name|dest
argument_list|,
name|t
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|getNextTransition
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|addTransition
argument_list|(
name|source
argument_list|,
name|t
operator|.
name|dest
argument_list|,
name|t
operator|.
name|min
argument_list|,
name|t
operator|.
name|max
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|isAccept
argument_list|(
name|dest
argument_list|)
condition|)
block|{
name|setAccept
argument_list|(
name|source
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Copies over all states/transitions from other. */
DECL|method|copy
specifier|public
name|void
name|copy
parameter_list|(
name|LightAutomaton
name|other
parameter_list|)
block|{
name|int
name|offset
init|=
name|getNumStates
argument_list|()
decl_stmt|;
name|int
name|otherNumStates
init|=
name|other
operator|.
name|getNumStates
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|s
init|=
literal|0
init|;
name|s
operator|<
name|otherNumStates
condition|;
name|s
operator|++
control|)
block|{
name|createState
argument_list|()
expr_stmt|;
name|setAccept
argument_list|(
name|offset
operator|+
name|s
argument_list|,
name|other
operator|.
name|isAccept
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|Transition
name|t
init|=
operator|new
name|Transition
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|s
init|=
literal|0
init|;
name|s
operator|<
name|otherNumStates
condition|;
name|s
operator|++
control|)
block|{
name|int
name|count
init|=
name|other
operator|.
name|initTransition
argument_list|(
name|s
argument_list|,
name|t
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|other
operator|.
name|getNextTransition
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|addTransition
argument_list|(
name|offset
operator|+
name|s
argument_list|,
name|offset
operator|+
name|t
operator|.
name|dest
argument_list|,
name|t
operator|.
name|min
argument_list|,
name|t
operator|.
name|max
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/** Freezes the last state, reducing and sorting its transitions. */
DECL|method|finishCurrentState
specifier|private
name|void
name|finishCurrentState
parameter_list|()
block|{
name|int
name|numTransitions
init|=
name|states
index|[
literal|2
operator|*
name|curState
operator|+
literal|1
index|]
decl_stmt|;
assert|assert
name|numTransitions
operator|>
literal|0
assert|;
comment|// System.out.println("finish curState=" + curState + " numTransitions=" + numTransitions);
name|int
name|offset
init|=
name|states
index|[
literal|2
operator|*
name|curState
index|]
decl_stmt|;
name|int
name|start
init|=
name|offset
operator|/
literal|3
decl_stmt|;
name|destMinMaxSorter
operator|.
name|sort
argument_list|(
name|start
argument_list|,
name|start
operator|+
name|numTransitions
argument_list|)
expr_stmt|;
comment|/*     for(int i=0;i<numTransitions;i++) {       System.out.println("  " + i + ": dest=" + transitions[offset+3*i] + " (accept?=" + isAccept(transitions[offset+3*i]) + ") min=" + transitions[offset+3*i+1] + " max=" + transitions[offset+3*i+2]);     }     */
comment|// Reduce any "adjacent" transitions:
name|int
name|upto
init|=
literal|0
decl_stmt|;
name|int
name|min
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|max
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|dest
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numTransitions
condition|;
name|i
operator|++
control|)
block|{
name|int
name|tDest
init|=
name|transitions
index|[
name|offset
operator|+
literal|3
operator|*
name|i
index|]
decl_stmt|;
name|int
name|tMin
init|=
name|transitions
index|[
name|offset
operator|+
literal|3
operator|*
name|i
operator|+
literal|1
index|]
decl_stmt|;
name|int
name|tMax
init|=
name|transitions
index|[
name|offset
operator|+
literal|3
operator|*
name|i
operator|+
literal|2
index|]
decl_stmt|;
if|if
condition|(
name|dest
operator|==
name|tDest
condition|)
block|{
if|if
condition|(
name|tMin
operator|<=
name|max
operator|+
literal|1
condition|)
block|{
if|if
condition|(
name|tMax
operator|>
name|max
condition|)
block|{
name|max
operator|=
name|tMax
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|dest
operator|!=
operator|-
literal|1
condition|)
block|{
name|transitions
index|[
name|offset
operator|+
literal|3
operator|*
name|upto
index|]
operator|=
name|dest
expr_stmt|;
name|transitions
index|[
name|offset
operator|+
literal|3
operator|*
name|upto
operator|+
literal|1
index|]
operator|=
name|min
expr_stmt|;
name|transitions
index|[
name|offset
operator|+
literal|3
operator|*
name|upto
operator|+
literal|2
index|]
operator|=
name|max
expr_stmt|;
name|upto
operator|++
expr_stmt|;
block|}
name|min
operator|=
name|tMin
expr_stmt|;
name|max
operator|=
name|tMax
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|dest
operator|!=
operator|-
literal|1
condition|)
block|{
name|transitions
index|[
name|offset
operator|+
literal|3
operator|*
name|upto
index|]
operator|=
name|dest
expr_stmt|;
name|transitions
index|[
name|offset
operator|+
literal|3
operator|*
name|upto
operator|+
literal|1
index|]
operator|=
name|min
expr_stmt|;
name|transitions
index|[
name|offset
operator|+
literal|3
operator|*
name|upto
operator|+
literal|2
index|]
operator|=
name|max
expr_stmt|;
name|upto
operator|++
expr_stmt|;
block|}
name|dest
operator|=
name|tDest
expr_stmt|;
name|min
operator|=
name|tMin
expr_stmt|;
name|max
operator|=
name|tMax
expr_stmt|;
block|}
block|}
if|if
condition|(
name|dest
operator|!=
operator|-
literal|1
condition|)
block|{
comment|// Last transition
name|transitions
index|[
name|offset
operator|+
literal|3
operator|*
name|upto
index|]
operator|=
name|dest
expr_stmt|;
name|transitions
index|[
name|offset
operator|+
literal|3
operator|*
name|upto
operator|+
literal|1
index|]
operator|=
name|min
expr_stmt|;
name|transitions
index|[
name|offset
operator|+
literal|3
operator|*
name|upto
operator|+
literal|2
index|]
operator|=
name|max
expr_stmt|;
name|upto
operator|++
expr_stmt|;
block|}
name|nextTransition
operator|-=
operator|(
name|numTransitions
operator|-
name|upto
operator|)
operator|*
literal|3
expr_stmt|;
name|states
index|[
literal|2
operator|*
name|curState
operator|+
literal|1
index|]
operator|=
name|upto
expr_stmt|;
comment|// Sort transitions by min/max/dest:
name|minMaxDestSorter
operator|.
name|sort
argument_list|(
name|start
argument_list|,
name|start
operator|+
name|upto
argument_list|)
expr_stmt|;
comment|/*     System.out.println("after finish: reduce collapsed " + (numTransitions-upto) + " transitions");     for(int i=0;i<upto;i++) {       System.out.println("  " + i + ": dest=" + transitions[offset+3*i] + " (accept?=" + isAccept(transitions[offset+3*i]) + ") min=" + transitions[offset+3*i+1] + " max=" + transitions[offset+3*i+2]);     }     */
block|}
DECL|method|finish
specifier|public
name|void
name|finish
parameter_list|()
block|{
if|if
condition|(
name|curState
operator|!=
operator|-
literal|1
condition|)
block|{
comment|//System.out.println("finish: finish current state " + curState);
name|finishCurrentState
argument_list|()
expr_stmt|;
name|curState
operator|=
operator|-
literal|1
expr_stmt|;
block|}
comment|// nocommit downsize the arrays?
comment|//assert getNumStates()> 0;
block|}
DECL|method|getNumStates
specifier|public
name|int
name|getNumStates
parameter_list|()
block|{
return|return
name|nextState
operator|/
literal|2
return|;
block|}
DECL|method|getNumTransitions
specifier|public
name|int
name|getNumTransitions
parameter_list|(
name|int
name|state
parameter_list|)
block|{
comment|//assert curState == -1: "not finished";
name|int
name|count
init|=
name|states
index|[
literal|2
operator|*
name|state
operator|+
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|count
operator|==
operator|-
literal|1
condition|)
block|{
return|return
literal|0
return|;
block|}
else|else
block|{
return|return
name|count
return|;
block|}
block|}
DECL|method|getDest
specifier|public
name|int
name|getDest
parameter_list|(
name|int
name|state
parameter_list|,
name|int
name|transitionIndex
parameter_list|)
block|{
return|return
name|transitions
index|[
name|states
index|[
literal|2
operator|*
name|state
index|]
index|]
return|;
block|}
DECL|method|getMin
specifier|public
name|int
name|getMin
parameter_list|(
name|int
name|state
parameter_list|,
name|int
name|transitionIndex
parameter_list|)
block|{
return|return
name|transitions
index|[
name|states
index|[
literal|2
operator|*
name|state
index|]
operator|+
literal|1
index|]
return|;
block|}
DECL|method|getMax
specifier|public
name|int
name|getMax
parameter_list|(
name|int
name|state
parameter_list|,
name|int
name|transitionIndex
parameter_list|)
block|{
return|return
name|transitions
index|[
name|states
index|[
literal|2
operator|*
name|state
index|]
operator|+
literal|2
index|]
return|;
block|}
DECL|method|growStates
specifier|private
name|void
name|growStates
parameter_list|()
block|{
if|if
condition|(
name|nextState
operator|+
literal|2
operator|>=
name|states
operator|.
name|length
condition|)
block|{
name|states
operator|=
name|ArrayUtil
operator|.
name|grow
argument_list|(
name|states
argument_list|,
name|nextState
operator|+
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|growTransitions
specifier|private
name|void
name|growTransitions
parameter_list|()
block|{
if|if
condition|(
name|nextTransition
operator|+
literal|3
operator|>=
name|transitions
operator|.
name|length
condition|)
block|{
name|transitions
operator|=
name|ArrayUtil
operator|.
name|grow
argument_list|(
name|transitions
argument_list|,
name|nextTransition
operator|+
literal|3
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Sorts transitions by dest, ascending, then min label ascending, then max label ascending */
DECL|field|destMinMaxSorter
specifier|private
specifier|final
name|Sorter
name|destMinMaxSorter
init|=
operator|new
name|InPlaceMergeSorter
argument_list|()
block|{
specifier|private
name|void
name|swapOne
parameter_list|(
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|)
block|{
name|int
name|x
init|=
name|transitions
index|[
name|i
index|]
decl_stmt|;
name|transitions
index|[
name|i
index|]
operator|=
name|transitions
index|[
name|j
index|]
expr_stmt|;
name|transitions
index|[
name|j
index|]
operator|=
name|x
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
name|void
name|swap
parameter_list|(
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|)
block|{
name|int
name|iStart
init|=
literal|3
operator|*
name|i
decl_stmt|;
name|int
name|jStart
init|=
literal|3
operator|*
name|j
decl_stmt|;
name|swapOne
argument_list|(
name|iStart
argument_list|,
name|jStart
argument_list|)
expr_stmt|;
name|swapOne
argument_list|(
name|iStart
operator|+
literal|1
argument_list|,
name|jStart
operator|+
literal|1
argument_list|)
expr_stmt|;
name|swapOne
argument_list|(
name|iStart
operator|+
literal|2
argument_list|,
name|jStart
operator|+
literal|2
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
annotation|@
name|Override
specifier|protected
name|int
name|compare
parameter_list|(
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|)
block|{
name|int
name|iStart
init|=
literal|3
operator|*
name|i
decl_stmt|;
name|int
name|jStart
init|=
literal|3
operator|*
name|j
decl_stmt|;
comment|// First dest:
name|int
name|iDest
init|=
name|transitions
index|[
name|iStart
index|]
decl_stmt|;
name|int
name|jDest
init|=
name|transitions
index|[
name|jStart
index|]
decl_stmt|;
if|if
condition|(
name|iDest
operator|<
name|jDest
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|iDest
operator|>
name|jDest
condition|)
block|{
return|return
literal|1
return|;
block|}
comment|// Then min:
name|int
name|iMin
init|=
name|transitions
index|[
name|iStart
operator|+
literal|1
index|]
decl_stmt|;
name|int
name|jMin
init|=
name|transitions
index|[
name|jStart
operator|+
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|iMin
operator|<
name|jMin
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|iMin
operator|>
name|jMin
condition|)
block|{
return|return
literal|1
return|;
block|}
comment|// Then max:
name|int
name|iMax
init|=
name|transitions
index|[
name|iStart
operator|+
literal|2
index|]
decl_stmt|;
name|int
name|jMax
init|=
name|transitions
index|[
name|jStart
operator|+
literal|2
index|]
decl_stmt|;
if|if
condition|(
name|iMax
operator|<
name|jMax
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|iMax
operator|>
name|jMax
condition|)
block|{
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
block|}
decl_stmt|;
comment|/** Sorts transitions by min label, ascending, then max label ascending, then dest ascending */
DECL|field|minMaxDestSorter
specifier|private
specifier|final
name|Sorter
name|minMaxDestSorter
init|=
operator|new
name|InPlaceMergeSorter
argument_list|()
block|{
specifier|private
name|void
name|swapOne
parameter_list|(
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|)
block|{
name|int
name|x
init|=
name|transitions
index|[
name|i
index|]
decl_stmt|;
name|transitions
index|[
name|i
index|]
operator|=
name|transitions
index|[
name|j
index|]
expr_stmt|;
name|transitions
index|[
name|j
index|]
operator|=
name|x
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
name|void
name|swap
parameter_list|(
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|)
block|{
name|int
name|iStart
init|=
literal|3
operator|*
name|i
decl_stmt|;
name|int
name|jStart
init|=
literal|3
operator|*
name|j
decl_stmt|;
name|swapOne
argument_list|(
name|iStart
argument_list|,
name|jStart
argument_list|)
expr_stmt|;
name|swapOne
argument_list|(
name|iStart
operator|+
literal|1
argument_list|,
name|jStart
operator|+
literal|1
argument_list|)
expr_stmt|;
name|swapOne
argument_list|(
name|iStart
operator|+
literal|2
argument_list|,
name|jStart
operator|+
literal|2
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
annotation|@
name|Override
specifier|protected
name|int
name|compare
parameter_list|(
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|)
block|{
name|int
name|iStart
init|=
literal|3
operator|*
name|i
decl_stmt|;
name|int
name|jStart
init|=
literal|3
operator|*
name|j
decl_stmt|;
comment|// First min:
name|int
name|iMin
init|=
name|transitions
index|[
name|iStart
operator|+
literal|1
index|]
decl_stmt|;
name|int
name|jMin
init|=
name|transitions
index|[
name|jStart
operator|+
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|iMin
operator|<
name|jMin
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|iMin
operator|>
name|jMin
condition|)
block|{
return|return
literal|1
return|;
block|}
comment|// Then max:
name|int
name|iMax
init|=
name|transitions
index|[
name|iStart
operator|+
literal|2
index|]
decl_stmt|;
name|int
name|jMax
init|=
name|transitions
index|[
name|jStart
operator|+
literal|2
index|]
decl_stmt|;
if|if
condition|(
name|iMax
operator|<
name|jMax
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|iMax
operator|>
name|jMax
condition|)
block|{
return|return
literal|1
return|;
block|}
comment|// Then dest:
name|int
name|iDest
init|=
name|transitions
index|[
name|iStart
index|]
decl_stmt|;
name|int
name|jDest
init|=
name|transitions
index|[
name|jStart
index|]
decl_stmt|;
if|if
condition|(
name|iDest
operator|<
name|jDest
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|iDest
operator|>
name|jDest
condition|)
block|{
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
block|}
decl_stmt|;
comment|/** Just used temporarily to return the transition from    *  {@link getTransition} and {@link #getNextTransition}. */
DECL|class|Transition
specifier|public
specifier|static
class|class
name|Transition
block|{
comment|// used only for assert:
DECL|field|source
specifier|public
name|int
name|source
decl_stmt|;
DECL|field|dest
specifier|public
name|int
name|dest
decl_stmt|;
DECL|field|min
specifier|public
name|int
name|min
decl_stmt|;
DECL|field|max
specifier|public
name|int
name|max
decl_stmt|;
comment|/** Remembers where we are in the iteration; init to -1 to provoke      *  exception if nextTransition is called without first initTransition. */
DECL|field|transitionUpto
specifier|private
name|int
name|transitionUpto
init|=
operator|-
literal|1
decl_stmt|;
annotation|@
name|Override
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|source
operator|+
literal|" --> "
operator|+
name|dest
operator|+
literal|" "
operator|+
operator|(
name|char
operator|)
name|min
operator|+
literal|"-"
operator|+
operator|(
name|char
operator|)
name|max
return|;
block|}
comment|// nocommit equals?  hashCode?  don't want to encourage putting these into a Map...?
block|}
comment|// nocommit createStates(int count)?
comment|// nocommit kinda awkward iterator api...
comment|/** Initialize the provided Transition for iteration; you    *  must call {@link #getNextTransition} to get the first    *  transition for the state.  Returns the number of transitions    *  leaving this state. */
DECL|method|initTransition
specifier|public
name|int
name|initTransition
parameter_list|(
name|int
name|state
parameter_list|,
name|Transition
name|t
parameter_list|)
block|{
comment|// assert curState == -1: "not finished";
name|t
operator|.
name|source
operator|=
name|state
expr_stmt|;
comment|//System.out.println("initTrans source=" + state  + " numTrans=" + getNumTransitions(state));
name|t
operator|.
name|transitionUpto
operator|=
name|states
index|[
literal|2
operator|*
name|state
index|]
expr_stmt|;
return|return
name|getNumTransitions
argument_list|(
name|state
argument_list|)
return|;
block|}
comment|/** Iterate to the next transition after the provided one */
DECL|method|getNextTransition
specifier|public
name|void
name|getNextTransition
parameter_list|(
name|Transition
name|t
parameter_list|)
block|{
comment|//assert curState == -1: "not finished";
comment|// Make sure there is still a transition left:
comment|//System.out.println("getNextTrans transUpto=" + t.transitionUpto);
comment|//System.out.println("  states[2*t.source]=" + states[2*t.source] + " numTrans=" + states[2*t.source+1] + " transitionUpto+3=" + (t.transitionUpto+3) + " t=" + t);
assert|assert
operator|(
name|t
operator|.
name|transitionUpto
operator|+
literal|3
operator|-
name|states
index|[
literal|2
operator|*
name|t
operator|.
name|source
index|]
operator|)
operator|<=
literal|3
operator|*
name|states
index|[
literal|2
operator|*
name|t
operator|.
name|source
operator|+
literal|1
index|]
assert|;
name|t
operator|.
name|dest
operator|=
name|transitions
index|[
name|t
operator|.
name|transitionUpto
operator|++
index|]
expr_stmt|;
name|t
operator|.
name|min
operator|=
name|transitions
index|[
name|t
operator|.
name|transitionUpto
operator|++
index|]
expr_stmt|;
name|t
operator|.
name|max
operator|=
name|transitions
index|[
name|t
operator|.
name|transitionUpto
operator|++
index|]
expr_stmt|;
block|}
comment|/** Fill the provided {@link Transition} with the index'th    *  transition leaving the specified state. */
DECL|method|getTransition
specifier|public
name|void
name|getTransition
parameter_list|(
name|int
name|state
parameter_list|,
name|int
name|index
parameter_list|,
name|Transition
name|t
parameter_list|)
block|{
assert|assert
name|curState
operator|==
operator|-
literal|1
operator|:
literal|"not finished"
assert|;
name|int
name|i
init|=
name|states
index|[
literal|2
operator|*
name|state
index|]
operator|+
literal|3
operator|*
name|index
decl_stmt|;
name|t
operator|.
name|source
operator|=
name|state
expr_stmt|;
name|t
operator|.
name|dest
operator|=
name|transitions
index|[
name|i
operator|++
index|]
expr_stmt|;
name|t
operator|.
name|min
operator|=
name|transitions
index|[
name|i
operator|++
index|]
expr_stmt|;
name|t
operator|.
name|max
operator|=
name|transitions
index|[
name|i
operator|++
index|]
expr_stmt|;
block|}
DECL|method|appendCharString
specifier|private
specifier|static
name|void
name|appendCharString
parameter_list|(
name|int
name|c
parameter_list|,
name|StringBuilder
name|b
parameter_list|)
block|{
if|if
condition|(
name|c
operator|>=
literal|0x21
operator|&&
name|c
operator|<=
literal|0x7e
operator|&&
name|c
operator|!=
literal|'\\'
operator|&&
name|c
operator|!=
literal|'"'
condition|)
name|b
operator|.
name|appendCodePoint
argument_list|(
name|c
argument_list|)
expr_stmt|;
else|else
block|{
name|b
operator|.
name|append
argument_list|(
literal|"\\\\U"
argument_list|)
expr_stmt|;
name|String
name|s
init|=
name|Integer
operator|.
name|toHexString
argument_list|(
name|c
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|<
literal|0x10
condition|)
name|b
operator|.
name|append
argument_list|(
literal|"0000000"
argument_list|)
operator|.
name|append
argument_list|(
name|s
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|<
literal|0x100
condition|)
name|b
operator|.
name|append
argument_list|(
literal|"000000"
argument_list|)
operator|.
name|append
argument_list|(
name|s
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|<
literal|0x1000
condition|)
name|b
operator|.
name|append
argument_list|(
literal|"00000"
argument_list|)
operator|.
name|append
argument_list|(
name|s
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|<
literal|0x10000
condition|)
name|b
operator|.
name|append
argument_list|(
literal|"0000"
argument_list|)
operator|.
name|append
argument_list|(
name|s
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|<
literal|0x100000
condition|)
name|b
operator|.
name|append
argument_list|(
literal|"000"
argument_list|)
operator|.
name|append
argument_list|(
name|s
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|<
literal|0x1000000
condition|)
name|b
operator|.
name|append
argument_list|(
literal|"00"
argument_list|)
operator|.
name|append
argument_list|(
name|s
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|<
literal|0x10000000
condition|)
name|b
operator|.
name|append
argument_list|(
literal|"0"
argument_list|)
operator|.
name|append
argument_list|(
name|s
argument_list|)
expr_stmt|;
else|else
name|b
operator|.
name|append
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|totalize
specifier|public
name|LightAutomaton
name|totalize
parameter_list|()
block|{
name|LightAutomaton
name|result
init|=
operator|new
name|LightAutomaton
argument_list|()
decl_stmt|;
name|int
name|numStates
init|=
name|getNumStates
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numStates
condition|;
name|i
operator|++
control|)
block|{
name|result
operator|.
name|createState
argument_list|()
expr_stmt|;
name|result
operator|.
name|setAccept
argument_list|(
name|i
argument_list|,
name|isAccept
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|int
name|deadState
init|=
name|result
operator|.
name|createState
argument_list|()
decl_stmt|;
name|result
operator|.
name|addTransition
argument_list|(
name|deadState
argument_list|,
name|deadState
argument_list|,
name|Character
operator|.
name|MIN_CODE_POINT
argument_list|,
name|Character
operator|.
name|MAX_CODE_POINT
argument_list|)
expr_stmt|;
name|Transition
name|t
init|=
operator|new
name|Transition
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numStates
condition|;
name|i
operator|++
control|)
block|{
name|int
name|maxi
init|=
name|Character
operator|.
name|MIN_CODE_POINT
decl_stmt|;
name|int
name|count
init|=
name|initTransition
argument_list|(
name|i
argument_list|,
name|t
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|count
condition|;
name|j
operator|++
control|)
block|{
name|getNextTransition
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|result
operator|.
name|addTransition
argument_list|(
name|i
argument_list|,
name|t
operator|.
name|dest
argument_list|,
name|t
operator|.
name|min
argument_list|,
name|t
operator|.
name|max
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|.
name|min
operator|>
name|maxi
condition|)
block|{
name|result
operator|.
name|addTransition
argument_list|(
name|i
argument_list|,
name|deadState
argument_list|,
name|maxi
argument_list|,
name|t
operator|.
name|min
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|t
operator|.
name|max
operator|+
literal|1
operator|>
name|maxi
condition|)
block|{
name|maxi
operator|=
name|t
operator|.
name|max
operator|+
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|maxi
operator|<=
name|Character
operator|.
name|MAX_CODE_POINT
condition|)
block|{
name|result
operator|.
name|addTransition
argument_list|(
name|i
argument_list|,
name|deadState
argument_list|,
name|maxi
argument_list|,
name|Character
operator|.
name|MAX_CODE_POINT
argument_list|)
expr_stmt|;
block|}
block|}
name|result
operator|.
name|finish
argument_list|()
expr_stmt|;
return|return
name|result
return|;
block|}
DECL|method|writeDot
specifier|public
name|void
name|writeDot
parameter_list|(
name|String
name|fileName
parameter_list|)
block|{
if|if
condition|(
name|fileName
operator|.
name|indexOf
argument_list|(
literal|'/'
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|fileName
operator|=
literal|"/l/la/lucene/core/"
operator|+
name|fileName
operator|+
literal|".dot"
expr_stmt|;
block|}
try|try
block|{
name|PrintWriter
name|pw
init|=
operator|new
name|PrintWriter
argument_list|(
name|fileName
argument_list|)
decl_stmt|;
name|pw
operator|.
name|println
argument_list|(
name|toDot
argument_list|()
argument_list|)
expr_stmt|;
name|pw
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|ioe
argument_list|)
throw|;
block|}
block|}
DECL|method|toDot
specifier|public
name|String
name|toDot
parameter_list|()
block|{
comment|// TODO: breadth first search so we can see get layered output...
name|StringBuilder
name|b
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|b
operator|.
name|append
argument_list|(
literal|"digraph Automaton {\n"
argument_list|)
expr_stmt|;
name|b
operator|.
name|append
argument_list|(
literal|"  rankdir = LR\n"
argument_list|)
expr_stmt|;
specifier|final
name|int
name|numStates
init|=
name|getNumStates
argument_list|()
decl_stmt|;
if|if
condition|(
name|numStates
operator|>
literal|0
condition|)
block|{
name|b
operator|.
name|append
argument_list|(
literal|"  initial [shape=plaintext,label=\"0\"]\n"
argument_list|)
expr_stmt|;
name|b
operator|.
name|append
argument_list|(
literal|"  initial -> 0\n"
argument_list|)
expr_stmt|;
block|}
name|Transition
name|t
init|=
operator|new
name|Transition
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|state
init|=
literal|0
init|;
name|state
operator|<
name|numStates
condition|;
name|state
operator|++
control|)
block|{
name|b
operator|.
name|append
argument_list|(
literal|"  "
argument_list|)
expr_stmt|;
name|b
operator|.
name|append
argument_list|(
name|state
argument_list|)
expr_stmt|;
if|if
condition|(
name|isAccept
argument_list|(
name|state
argument_list|)
condition|)
block|{
name|b
operator|.
name|append
argument_list|(
literal|" [shape=doublecircle,label=\""
operator|+
name|state
operator|+
literal|"\"]\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|b
operator|.
name|append
argument_list|(
literal|" [shape=circle,label=\""
operator|+
name|state
operator|+
literal|"\"]\n"
argument_list|)
expr_stmt|;
block|}
name|int
name|numTransitions
init|=
name|getNumTransitions
argument_list|(
name|state
argument_list|)
decl_stmt|;
name|initTransition
argument_list|(
name|state
argument_list|,
name|t
argument_list|)
expr_stmt|;
comment|//System.out.println("toDot: state " + state + " has " + numTransitions + " transitions; t.nextTrans=" + t.transitionUpto);
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numTransitions
condition|;
name|i
operator|++
control|)
block|{
name|getNextTransition
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|//System.out.println("  t.nextTrans=" + t.transitionUpto);
assert|assert
name|t
operator|.
name|max
operator|>=
name|t
operator|.
name|min
assert|;
name|b
operator|.
name|append
argument_list|(
literal|"  "
argument_list|)
expr_stmt|;
name|b
operator|.
name|append
argument_list|(
name|state
argument_list|)
expr_stmt|;
name|b
operator|.
name|append
argument_list|(
literal|" -> "
argument_list|)
expr_stmt|;
name|b
operator|.
name|append
argument_list|(
name|t
operator|.
name|dest
argument_list|)
expr_stmt|;
name|b
operator|.
name|append
argument_list|(
literal|" [label=\""
argument_list|)
expr_stmt|;
name|appendCharString
argument_list|(
name|t
operator|.
name|min
argument_list|,
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|.
name|max
operator|!=
name|t
operator|.
name|min
condition|)
block|{
name|b
operator|.
name|append
argument_list|(
literal|'-'
argument_list|)
expr_stmt|;
name|appendCharString
argument_list|(
name|t
operator|.
name|max
argument_list|,
name|b
argument_list|)
expr_stmt|;
block|}
name|b
operator|.
name|append
argument_list|(
literal|"\"]\n"
argument_list|)
expr_stmt|;
comment|//System.out.println("  t=" + t);
block|}
block|}
name|b
operator|.
name|append
argument_list|(
literal|'}'
argument_list|)
expr_stmt|;
return|return
name|b
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**    * Returns sorted array of all interval start points.    */
DECL|method|getStartPoints
name|int
index|[]
name|getStartPoints
parameter_list|()
block|{
name|Set
argument_list|<
name|Integer
argument_list|>
name|pointset
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
name|pointset
operator|.
name|add
argument_list|(
name|Character
operator|.
name|MIN_CODE_POINT
argument_list|)
expr_stmt|;
comment|//System.out.println("getStartPoints");
for|for
control|(
name|int
name|s
init|=
literal|0
init|;
name|s
operator|<
name|nextState
condition|;
name|s
operator|+=
literal|2
control|)
block|{
name|int
name|trans
init|=
name|states
index|[
name|s
index|]
decl_stmt|;
name|int
name|limit
init|=
name|trans
operator|+
literal|3
operator|*
name|states
index|[
name|s
operator|+
literal|1
index|]
decl_stmt|;
comment|//System.out.println("  state=" + (s/2) + " trans=" + trans + " limit=" + limit);
while|while
condition|(
name|trans
operator|<
name|limit
condition|)
block|{
name|int
name|min
init|=
name|transitions
index|[
name|trans
operator|+
literal|1
index|]
decl_stmt|;
name|int
name|max
init|=
name|transitions
index|[
name|trans
operator|+
literal|2
index|]
decl_stmt|;
comment|//System.out.println("    min=" + min);
name|pointset
operator|.
name|add
argument_list|(
name|min
argument_list|)
expr_stmt|;
if|if
condition|(
name|max
operator|<
name|Character
operator|.
name|MAX_CODE_POINT
condition|)
block|{
name|pointset
operator|.
name|add
argument_list|(
name|max
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
name|trans
operator|+=
literal|3
expr_stmt|;
block|}
block|}
name|int
index|[]
name|points
init|=
operator|new
name|int
index|[
name|pointset
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
name|int
name|n
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Integer
name|m
range|:
name|pointset
control|)
block|{
name|points
index|[
name|n
operator|++
index|]
operator|=
name|m
expr_stmt|;
block|}
name|Arrays
operator|.
name|sort
argument_list|(
name|points
argument_list|)
expr_stmt|;
return|return
name|points
return|;
block|}
comment|/**    * Performs lookup in transitions, assuming determinism.    *     * @param c codepoint to look up    * @return destination state, -1 if no matching outgoing transition    * @see #step(int, Collection)    */
DECL|method|step
specifier|public
name|int
name|step
parameter_list|(
name|int
name|state
parameter_list|,
name|int
name|label
parameter_list|)
block|{
assert|assert
name|state
operator|>=
literal|0
assert|;
assert|assert
name|label
operator|>=
literal|0
assert|;
name|int
name|trans
init|=
name|states
index|[
literal|2
operator|*
name|state
index|]
decl_stmt|;
name|int
name|limit
init|=
name|trans
operator|+
literal|3
operator|*
name|states
index|[
literal|2
operator|*
name|state
operator|+
literal|1
index|]
decl_stmt|;
comment|// nocommit we could do bin search; transitions are sorted
comment|// System.out.println("la.step state=" + state + " label=" + label + "  trans=" + trans + " limit=" + limit);
while|while
condition|(
name|trans
operator|<
name|limit
condition|)
block|{
name|int
name|dest
init|=
name|transitions
index|[
name|trans
index|]
decl_stmt|;
name|int
name|min
init|=
name|transitions
index|[
name|trans
operator|+
literal|1
index|]
decl_stmt|;
name|int
name|max
init|=
name|transitions
index|[
name|trans
operator|+
literal|2
index|]
decl_stmt|;
if|if
condition|(
name|min
operator|<=
name|label
operator|&&
name|label
operator|<=
name|max
condition|)
block|{
comment|//System.out.println("  ret dest=" + dest);
return|return
name|dest
return|;
block|}
name|trans
operator|+=
literal|3
expr_stmt|;
block|}
return|return
operator|-
literal|1
return|;
block|}
comment|/** Records new states and transitions and then {@link    *  #finish} creates the {@link LightAutomaton}.  Use this    *  when it's too restrictive to have to add all transitions    *  leaving each state at once. */
DECL|class|Builder
specifier|public
specifier|static
class|class
name|Builder
block|{
DECL|field|transitions
specifier|private
name|int
index|[]
name|transitions
init|=
operator|new
name|int
index|[
literal|4
index|]
decl_stmt|;
DECL|field|nextTransition
specifier|private
name|int
name|nextTransition
decl_stmt|;
DECL|field|a
specifier|private
specifier|final
name|LightAutomaton
name|a
init|=
operator|new
name|LightAutomaton
argument_list|()
decl_stmt|;
DECL|method|addTransition
specifier|public
name|void
name|addTransition
parameter_list|(
name|int
name|from
parameter_list|,
name|int
name|to
parameter_list|,
name|int
name|label
parameter_list|)
block|{
name|addTransition
argument_list|(
name|from
argument_list|,
name|to
argument_list|,
name|label
argument_list|,
name|label
argument_list|)
expr_stmt|;
block|}
DECL|method|addTransition
specifier|public
name|void
name|addTransition
parameter_list|(
name|int
name|from
parameter_list|,
name|int
name|to
parameter_list|,
name|int
name|min
parameter_list|,
name|int
name|max
parameter_list|)
block|{
if|if
condition|(
name|transitions
operator|.
name|length
operator|<
name|nextTransition
operator|+
literal|4
condition|)
block|{
name|transitions
operator|=
name|ArrayUtil
operator|.
name|grow
argument_list|(
name|transitions
argument_list|,
name|nextTransition
operator|+
literal|4
argument_list|)
expr_stmt|;
block|}
name|transitions
index|[
name|nextTransition
operator|++
index|]
operator|=
name|from
expr_stmt|;
name|transitions
index|[
name|nextTransition
operator|++
index|]
operator|=
name|to
expr_stmt|;
name|transitions
index|[
name|nextTransition
operator|++
index|]
operator|=
name|min
expr_stmt|;
name|transitions
index|[
name|nextTransition
operator|++
index|]
operator|=
name|max
expr_stmt|;
block|}
comment|/** Sorts transitions first then min label ascending, then      *  max label ascending, then dest ascending */
DECL|field|sorter
specifier|private
specifier|final
name|Sorter
name|sorter
init|=
operator|new
name|InPlaceMergeSorter
argument_list|()
block|{
specifier|private
name|void
name|swapOne
parameter_list|(
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|)
block|{
name|int
name|x
init|=
name|transitions
index|[
name|i
index|]
decl_stmt|;
name|transitions
index|[
name|i
index|]
operator|=
name|transitions
index|[
name|j
index|]
expr_stmt|;
name|transitions
index|[
name|j
index|]
operator|=
name|x
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
name|void
name|swap
parameter_list|(
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|)
block|{
name|int
name|iStart
init|=
literal|4
operator|*
name|i
decl_stmt|;
name|int
name|jStart
init|=
literal|4
operator|*
name|j
decl_stmt|;
name|swapOne
argument_list|(
name|iStart
argument_list|,
name|jStart
argument_list|)
expr_stmt|;
name|swapOne
argument_list|(
name|iStart
operator|+
literal|1
argument_list|,
name|jStart
operator|+
literal|1
argument_list|)
expr_stmt|;
name|swapOne
argument_list|(
name|iStart
operator|+
literal|2
argument_list|,
name|jStart
operator|+
literal|2
argument_list|)
expr_stmt|;
name|swapOne
argument_list|(
name|iStart
operator|+
literal|3
argument_list|,
name|jStart
operator|+
literal|3
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
annotation|@
name|Override
specifier|protected
name|int
name|compare
parameter_list|(
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|)
block|{
name|int
name|iStart
init|=
literal|4
operator|*
name|i
decl_stmt|;
name|int
name|jStart
init|=
literal|4
operator|*
name|j
decl_stmt|;
comment|// First src:
name|int
name|iSrc
init|=
name|transitions
index|[
name|iStart
index|]
decl_stmt|;
name|int
name|jSrc
init|=
name|transitions
index|[
name|jStart
index|]
decl_stmt|;
if|if
condition|(
name|iSrc
operator|<
name|jSrc
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|iSrc
operator|>
name|jSrc
condition|)
block|{
return|return
literal|1
return|;
block|}
comment|// Then min:
name|int
name|iMin
init|=
name|transitions
index|[
name|iStart
operator|+
literal|2
index|]
decl_stmt|;
name|int
name|jMin
init|=
name|transitions
index|[
name|jStart
operator|+
literal|2
index|]
decl_stmt|;
if|if
condition|(
name|iMin
operator|<
name|jMin
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|iMin
operator|>
name|jMin
condition|)
block|{
return|return
literal|1
return|;
block|}
comment|// Then max:
name|int
name|iMax
init|=
name|transitions
index|[
name|iStart
operator|+
literal|3
index|]
decl_stmt|;
name|int
name|jMax
init|=
name|transitions
index|[
name|jStart
operator|+
literal|3
index|]
decl_stmt|;
if|if
condition|(
name|iMax
operator|<
name|jMax
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|iMax
operator|>
name|jMax
condition|)
block|{
return|return
literal|1
return|;
block|}
comment|// First dest:
name|int
name|iDest
init|=
name|transitions
index|[
name|iStart
operator|+
literal|1
index|]
decl_stmt|;
name|int
name|jDest
init|=
name|transitions
index|[
name|jStart
operator|+
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|iDest
operator|<
name|jDest
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|iDest
operator|>
name|jDest
condition|)
block|{
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
block|}
decl_stmt|;
DECL|method|finish
specifier|public
name|LightAutomaton
name|finish
parameter_list|()
block|{
comment|//System.out.println("LA.Builder.finish: count=" + (nextTransition/4));
comment|// nocommit: we could make this more efficient,
comment|// e.g. somehow xfer the int[] to the automaton, or
comment|// alloc exactly the right size from the automaton
comment|//System.out.println("finish pending");
name|sorter
operator|.
name|sort
argument_list|(
literal|0
argument_list|,
name|nextTransition
operator|/
literal|4
argument_list|)
expr_stmt|;
name|int
name|upto
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|upto
operator|<
name|nextTransition
condition|)
block|{
name|a
operator|.
name|addTransition
argument_list|(
name|transitions
index|[
name|upto
index|]
argument_list|,
name|transitions
index|[
name|upto
operator|+
literal|1
index|]
argument_list|,
name|transitions
index|[
name|upto
operator|+
literal|2
index|]
argument_list|,
name|transitions
index|[
name|upto
operator|+
literal|3
index|]
argument_list|)
expr_stmt|;
name|upto
operator|+=
literal|4
expr_stmt|;
block|}
name|a
operator|.
name|finish
argument_list|()
expr_stmt|;
return|return
name|a
return|;
block|}
DECL|method|createState
specifier|public
name|int
name|createState
parameter_list|()
block|{
return|return
name|a
operator|.
name|createState
argument_list|()
return|;
block|}
DECL|method|setAccept
specifier|public
name|void
name|setAccept
parameter_list|(
name|int
name|state
parameter_list|,
name|boolean
name|accept
parameter_list|)
block|{
name|a
operator|.
name|setAccept
argument_list|(
name|state
argument_list|,
name|accept
argument_list|)
expr_stmt|;
block|}
DECL|method|isAccept
specifier|public
name|boolean
name|isAccept
parameter_list|(
name|int
name|state
parameter_list|)
block|{
return|return
name|a
operator|.
name|isAccept
argument_list|(
name|state
argument_list|)
return|;
block|}
DECL|method|getNumStates
specifier|public
name|int
name|getNumStates
parameter_list|()
block|{
return|return
name|a
operator|.
name|getNumStates
argument_list|()
return|;
block|}
comment|/** Copies over all states/transitions from other. */
DECL|method|copy
specifier|public
name|void
name|copy
parameter_list|(
name|LightAutomaton
name|other
parameter_list|)
block|{
name|int
name|offset
init|=
name|getNumStates
argument_list|()
decl_stmt|;
name|int
name|otherNumStates
init|=
name|other
operator|.
name|getNumStates
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|s
init|=
literal|0
init|;
name|s
operator|<
name|otherNumStates
condition|;
name|s
operator|++
control|)
block|{
name|int
name|newState
init|=
name|createState
argument_list|()
decl_stmt|;
name|setAccept
argument_list|(
name|newState
argument_list|,
name|other
operator|.
name|isAccept
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|Transition
name|t
init|=
operator|new
name|Transition
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|s
init|=
literal|0
init|;
name|s
operator|<
name|otherNumStates
condition|;
name|s
operator|++
control|)
block|{
name|int
name|count
init|=
name|other
operator|.
name|initTransition
argument_list|(
name|s
argument_list|,
name|t
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|other
operator|.
name|getNextTransition
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|addTransition
argument_list|(
name|offset
operator|+
name|s
argument_list|,
name|offset
operator|+
name|t
operator|.
name|dest
argument_list|,
name|t
operator|.
name|min
argument_list|,
name|t
operator|.
name|max
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
end_class
end_unit
