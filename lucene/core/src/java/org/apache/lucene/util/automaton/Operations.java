begin_unit
begin_comment
comment|/*  * dk.brics.automaton  *   * Copyright (c) 2001-2009 Anders Moeller  * All rights reserved.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *   * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment
begin_package
DECL|package|org.apache.lucene.util.automaton
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|automaton
package|;
end_package
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|ArrayUtil
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|BytesRef
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|BytesRefBuilder
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|IntsRef
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|IntsRefBuilder
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|RamUsageEstimator
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|BitSet
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedList
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import
begin_comment
comment|/**  * Automata operations.  *   * @lucene.experimental  */
end_comment
begin_class
DECL|class|Operations
specifier|final
specifier|public
class|class
name|Operations
block|{
comment|/**    * Default maximum number of states that {@link Operations#determinize} should create.    */
DECL|field|DEFAULT_MAX_DETERMINIZED_STATES
specifier|public
specifier|static
specifier|final
name|int
name|DEFAULT_MAX_DETERMINIZED_STATES
init|=
literal|10000
decl_stmt|;
DECL|method|Operations
specifier|private
name|Operations
parameter_list|()
block|{}
comment|/**    * Returns an automaton that accepts the concatenation of the languages of the    * given automata.    *<p>    * Complexity: linear in total number of states.    */
DECL|method|concatenate
specifier|static
specifier|public
name|Automaton
name|concatenate
parameter_list|(
name|Automaton
name|a1
parameter_list|,
name|Automaton
name|a2
parameter_list|)
block|{
return|return
name|concatenate
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|a1
argument_list|,
name|a2
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Returns an automaton that accepts the concatenation of the languages of the    * given automata.    *<p>    * Complexity: linear in total number of states.    */
DECL|method|concatenate
specifier|static
specifier|public
name|Automaton
name|concatenate
parameter_list|(
name|List
argument_list|<
name|Automaton
argument_list|>
name|l
parameter_list|)
block|{
name|Automaton
name|result
init|=
operator|new
name|Automaton
argument_list|()
decl_stmt|;
comment|// First pass: create all states
for|for
control|(
name|Automaton
name|a
range|:
name|l
control|)
block|{
if|if
condition|(
name|a
operator|.
name|getNumStates
argument_list|()
operator|==
literal|0
condition|)
block|{
name|result
operator|.
name|finishState
argument_list|()
expr_stmt|;
return|return
name|result
return|;
block|}
name|int
name|numStates
init|=
name|a
operator|.
name|getNumStates
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|s
init|=
literal|0
init|;
name|s
operator|<
name|numStates
condition|;
name|s
operator|++
control|)
block|{
name|result
operator|.
name|createState
argument_list|()
expr_stmt|;
block|}
block|}
comment|// Second pass: add transitions, carefully linking accept
comment|// states of A to init state of next A:
name|int
name|stateOffset
init|=
literal|0
decl_stmt|;
name|Transition
name|t
init|=
operator|new
name|Transition
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|l
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|Automaton
name|a
init|=
name|l
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|int
name|numStates
init|=
name|a
operator|.
name|getNumStates
argument_list|()
decl_stmt|;
name|Automaton
name|nextA
init|=
operator|(
name|i
operator|==
name|l
operator|.
name|size
argument_list|()
operator|-
literal|1
operator|)
condition|?
literal|null
else|:
name|l
operator|.
name|get
argument_list|(
name|i
operator|+
literal|1
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|s
init|=
literal|0
init|;
name|s
operator|<
name|numStates
condition|;
name|s
operator|++
control|)
block|{
name|int
name|numTransitions
init|=
name|a
operator|.
name|initTransition
argument_list|(
name|s
argument_list|,
name|t
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|numTransitions
condition|;
name|j
operator|++
control|)
block|{
name|a
operator|.
name|getNextTransition
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|result
operator|.
name|addTransition
argument_list|(
name|stateOffset
operator|+
name|s
argument_list|,
name|stateOffset
operator|+
name|t
operator|.
name|dest
argument_list|,
name|t
operator|.
name|min
argument_list|,
name|t
operator|.
name|max
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|a
operator|.
name|isAccept
argument_list|(
name|s
argument_list|)
condition|)
block|{
name|Automaton
name|followA
init|=
name|nextA
decl_stmt|;
name|int
name|followOffset
init|=
name|stateOffset
decl_stmt|;
name|int
name|upto
init|=
name|i
operator|+
literal|1
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
if|if
condition|(
name|followA
operator|!=
literal|null
condition|)
block|{
comment|// Adds a "virtual" epsilon transition:
name|numTransitions
operator|=
name|followA
operator|.
name|initTransition
argument_list|(
literal|0
argument_list|,
name|t
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|numTransitions
condition|;
name|j
operator|++
control|)
block|{
name|followA
operator|.
name|getNextTransition
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|result
operator|.
name|addTransition
argument_list|(
name|stateOffset
operator|+
name|s
argument_list|,
name|followOffset
operator|+
name|numStates
operator|+
name|t
operator|.
name|dest
argument_list|,
name|t
operator|.
name|min
argument_list|,
name|t
operator|.
name|max
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|followA
operator|.
name|isAccept
argument_list|(
literal|0
argument_list|)
condition|)
block|{
comment|// Keep chaining if followA accepts empty string
name|followOffset
operator|+=
name|followA
operator|.
name|getNumStates
argument_list|()
expr_stmt|;
name|followA
operator|=
operator|(
name|upto
operator|==
name|l
operator|.
name|size
argument_list|()
operator|-
literal|1
operator|)
condition|?
literal|null
else|:
name|l
operator|.
name|get
argument_list|(
name|upto
operator|+
literal|1
argument_list|)
expr_stmt|;
name|upto
operator|++
expr_stmt|;
block|}
else|else
block|{
break|break;
block|}
block|}
else|else
block|{
name|result
operator|.
name|setAccept
argument_list|(
name|stateOffset
operator|+
name|s
argument_list|,
literal|true
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
name|stateOffset
operator|+=
name|numStates
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|.
name|getNumStates
argument_list|()
operator|==
literal|0
condition|)
block|{
name|result
operator|.
name|createState
argument_list|()
expr_stmt|;
block|}
name|result
operator|.
name|finishState
argument_list|()
expr_stmt|;
return|return
name|result
return|;
block|}
comment|/**    * Returns an automaton that accepts the union of the empty string and the    * language of the given automaton.  This may create a dead state.    *<p>    * Complexity: linear in number of states.    */
DECL|method|optional
specifier|static
specifier|public
name|Automaton
name|optional
parameter_list|(
name|Automaton
name|a
parameter_list|)
block|{
name|Automaton
name|result
init|=
operator|new
name|Automaton
argument_list|()
decl_stmt|;
name|result
operator|.
name|createState
argument_list|()
expr_stmt|;
name|result
operator|.
name|setAccept
argument_list|(
literal|0
argument_list|,
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
operator|.
name|getNumStates
argument_list|()
operator|>
literal|0
condition|)
block|{
name|result
operator|.
name|copy
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|result
operator|.
name|addEpsilon
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|result
operator|.
name|finishState
argument_list|()
expr_stmt|;
return|return
name|result
return|;
block|}
comment|/**    * Returns an automaton that accepts the Kleene star (zero or more    * concatenated repetitions) of the language of the given automaton. Never    * modifies the input automaton language.    *<p>    * Complexity: linear in number of states.    */
DECL|method|repeat
specifier|static
specifier|public
name|Automaton
name|repeat
parameter_list|(
name|Automaton
name|a
parameter_list|)
block|{
if|if
condition|(
name|a
operator|.
name|getNumStates
argument_list|()
operator|==
literal|0
condition|)
block|{
comment|// Repeating the empty automata will still only accept the empty automata.
return|return
name|a
return|;
block|}
name|Automaton
operator|.
name|Builder
name|builder
init|=
operator|new
name|Automaton
operator|.
name|Builder
argument_list|()
decl_stmt|;
name|builder
operator|.
name|createState
argument_list|()
expr_stmt|;
name|builder
operator|.
name|setAccept
argument_list|(
literal|0
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|builder
operator|.
name|copy
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|Transition
name|t
init|=
operator|new
name|Transition
argument_list|()
decl_stmt|;
name|int
name|count
init|=
name|a
operator|.
name|initTransition
argument_list|(
literal|0
argument_list|,
name|t
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|a
operator|.
name|getNextTransition
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|builder
operator|.
name|addTransition
argument_list|(
literal|0
argument_list|,
name|t
operator|.
name|dest
operator|+
literal|1
argument_list|,
name|t
operator|.
name|min
argument_list|,
name|t
operator|.
name|max
argument_list|)
expr_stmt|;
block|}
name|int
name|numStates
init|=
name|a
operator|.
name|getNumStates
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|s
init|=
literal|0
init|;
name|s
operator|<
name|numStates
condition|;
name|s
operator|++
control|)
block|{
if|if
condition|(
name|a
operator|.
name|isAccept
argument_list|(
name|s
argument_list|)
condition|)
block|{
name|count
operator|=
name|a
operator|.
name|initTransition
argument_list|(
literal|0
argument_list|,
name|t
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|a
operator|.
name|getNextTransition
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|builder
operator|.
name|addTransition
argument_list|(
name|s
operator|+
literal|1
argument_list|,
name|t
operator|.
name|dest
operator|+
literal|1
argument_list|,
name|t
operator|.
name|min
argument_list|,
name|t
operator|.
name|max
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|builder
operator|.
name|finish
argument_list|()
return|;
block|}
comment|/**    * Returns an automaton that accepts<code>min</code> or more concatenated    * repetitions of the language of the given automaton.    *<p>    * Complexity: linear in number of states and in<code>min</code>.    */
DECL|method|repeat
specifier|static
specifier|public
name|Automaton
name|repeat
parameter_list|(
name|Automaton
name|a
parameter_list|,
name|int
name|count
parameter_list|)
block|{
if|if
condition|(
name|count
operator|==
literal|0
condition|)
block|{
return|return
name|repeat
argument_list|(
name|a
argument_list|)
return|;
block|}
name|List
argument_list|<
name|Automaton
argument_list|>
name|as
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
while|while
condition|(
name|count
operator|--
operator|>
literal|0
condition|)
block|{
name|as
operator|.
name|add
argument_list|(
name|a
argument_list|)
expr_stmt|;
block|}
name|as
operator|.
name|add
argument_list|(
name|repeat
argument_list|(
name|a
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|concatenate
argument_list|(
name|as
argument_list|)
return|;
block|}
comment|/**    * Returns an automaton that accepts between<code>min</code> and    *<code>max</code> (including both) concatenated repetitions of the language    * of the given automaton.    *<p>    * Complexity: linear in number of states and in<code>min</code> and    *<code>max</code>.    */
DECL|method|repeat
specifier|static
specifier|public
name|Automaton
name|repeat
parameter_list|(
name|Automaton
name|a
parameter_list|,
name|int
name|min
parameter_list|,
name|int
name|max
parameter_list|)
block|{
if|if
condition|(
name|min
operator|>
name|max
condition|)
block|{
return|return
name|Automata
operator|.
name|makeEmpty
argument_list|()
return|;
block|}
name|Automaton
name|b
decl_stmt|;
if|if
condition|(
name|min
operator|==
literal|0
condition|)
block|{
name|b
operator|=
name|Automata
operator|.
name|makeEmptyString
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|min
operator|==
literal|1
condition|)
block|{
name|b
operator|=
operator|new
name|Automaton
argument_list|()
expr_stmt|;
name|b
operator|.
name|copy
argument_list|(
name|a
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|List
argument_list|<
name|Automaton
argument_list|>
name|as
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|min
condition|;
name|i
operator|++
control|)
block|{
name|as
operator|.
name|add
argument_list|(
name|a
argument_list|)
expr_stmt|;
block|}
name|b
operator|=
name|concatenate
argument_list|(
name|as
argument_list|)
expr_stmt|;
block|}
name|Set
argument_list|<
name|Integer
argument_list|>
name|prevAcceptStates
init|=
name|toSet
argument_list|(
name|b
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|Automaton
operator|.
name|Builder
name|builder
init|=
operator|new
name|Automaton
operator|.
name|Builder
argument_list|()
decl_stmt|;
name|builder
operator|.
name|copy
argument_list|(
name|b
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
name|min
init|;
name|i
operator|<
name|max
condition|;
name|i
operator|++
control|)
block|{
name|int
name|numStates
init|=
name|builder
operator|.
name|getNumStates
argument_list|()
decl_stmt|;
name|builder
operator|.
name|copy
argument_list|(
name|a
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|s
range|:
name|prevAcceptStates
control|)
block|{
name|builder
operator|.
name|addEpsilon
argument_list|(
name|s
argument_list|,
name|numStates
argument_list|)
expr_stmt|;
block|}
name|prevAcceptStates
operator|=
name|toSet
argument_list|(
name|a
argument_list|,
name|numStates
argument_list|)
expr_stmt|;
block|}
return|return
name|builder
operator|.
name|finish
argument_list|()
return|;
block|}
DECL|method|toSet
specifier|private
specifier|static
name|Set
argument_list|<
name|Integer
argument_list|>
name|toSet
parameter_list|(
name|Automaton
name|a
parameter_list|,
name|int
name|offset
parameter_list|)
block|{
name|int
name|numStates
init|=
name|a
operator|.
name|getNumStates
argument_list|()
decl_stmt|;
name|BitSet
name|isAccept
init|=
name|a
operator|.
name|getAcceptStates
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|Integer
argument_list|>
name|result
init|=
operator|new
name|HashSet
argument_list|<
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
name|int
name|upto
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|upto
operator|<
name|numStates
operator|&&
operator|(
name|upto
operator|=
name|isAccept
operator|.
name|nextSetBit
argument_list|(
name|upto
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|result
operator|.
name|add
argument_list|(
name|offset
operator|+
name|upto
argument_list|)
expr_stmt|;
name|upto
operator|++
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
comment|/**    * Returns a (deterministic) automaton that accepts the complement of the    * language of the given automaton.    *<p>    * Complexity: linear in number of states if already deterministic and    *  exponential otherwise.    * @param maxDeterminizedStates maximum number of states determinizing the    *  automaton can result in.  Set higher to allow more complex queries and    *  lower to prevent memory exhaustion.    */
DECL|method|complement
specifier|static
specifier|public
name|Automaton
name|complement
parameter_list|(
name|Automaton
name|a
parameter_list|,
name|int
name|maxDeterminizedStates
parameter_list|)
block|{
name|a
operator|=
name|totalize
argument_list|(
name|determinize
argument_list|(
name|a
argument_list|,
name|maxDeterminizedStates
argument_list|)
argument_list|)
expr_stmt|;
name|int
name|numStates
init|=
name|a
operator|.
name|getNumStates
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|p
init|=
literal|0
init|;
name|p
operator|<
name|numStates
condition|;
name|p
operator|++
control|)
block|{
name|a
operator|.
name|setAccept
argument_list|(
name|p
argument_list|,
operator|!
name|a
operator|.
name|isAccept
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|removeDeadStates
argument_list|(
name|a
argument_list|)
return|;
block|}
comment|/**    * Returns a (deterministic) automaton that accepts the intersection of the    * language of<code>a1</code> and the complement of the language of    *<code>a2</code>. As a side-effect, the automata may be determinized, if not    * already deterministic.    *<p>    * Complexity: quadratic in number of states if a2 already deterministic and    *  exponential in number of a2's states otherwise.    */
DECL|method|minus
specifier|static
specifier|public
name|Automaton
name|minus
parameter_list|(
name|Automaton
name|a1
parameter_list|,
name|Automaton
name|a2
parameter_list|,
name|int
name|maxDeterminizedStates
parameter_list|)
block|{
if|if
condition|(
name|Operations
operator|.
name|isEmpty
argument_list|(
name|a1
argument_list|)
operator|||
name|a1
operator|==
name|a2
condition|)
block|{
return|return
name|Automata
operator|.
name|makeEmpty
argument_list|()
return|;
block|}
if|if
condition|(
name|Operations
operator|.
name|isEmpty
argument_list|(
name|a2
argument_list|)
condition|)
block|{
return|return
name|a1
return|;
block|}
return|return
name|intersection
argument_list|(
name|a1
argument_list|,
name|complement
argument_list|(
name|a2
argument_list|,
name|maxDeterminizedStates
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Returns an automaton that accepts the intersection of the languages of the    * given automata. Never modifies the input automata languages.    *<p>    * Complexity: quadratic in number of states.    */
DECL|method|intersection
specifier|static
specifier|public
name|Automaton
name|intersection
parameter_list|(
name|Automaton
name|a1
parameter_list|,
name|Automaton
name|a2
parameter_list|)
block|{
if|if
condition|(
name|a1
operator|==
name|a2
condition|)
block|{
return|return
name|a1
return|;
block|}
if|if
condition|(
name|a1
operator|.
name|getNumStates
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
name|a1
return|;
block|}
if|if
condition|(
name|a2
operator|.
name|getNumStates
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
name|a2
return|;
block|}
name|Transition
index|[]
index|[]
name|transitions1
init|=
name|a1
operator|.
name|getSortedTransitions
argument_list|()
decl_stmt|;
name|Transition
index|[]
index|[]
name|transitions2
init|=
name|a2
operator|.
name|getSortedTransitions
argument_list|()
decl_stmt|;
name|Automaton
name|c
init|=
operator|new
name|Automaton
argument_list|()
decl_stmt|;
name|c
operator|.
name|createState
argument_list|()
expr_stmt|;
name|LinkedList
argument_list|<
name|StatePair
argument_list|>
name|worklist
init|=
operator|new
name|LinkedList
argument_list|<>
argument_list|()
decl_stmt|;
name|HashMap
argument_list|<
name|StatePair
argument_list|,
name|StatePair
argument_list|>
name|newstates
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|StatePair
name|p
init|=
operator|new
name|StatePair
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|worklist
operator|.
name|add
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|newstates
operator|.
name|put
argument_list|(
name|p
argument_list|,
name|p
argument_list|)
expr_stmt|;
while|while
condition|(
name|worklist
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|p
operator|=
name|worklist
operator|.
name|removeFirst
argument_list|()
expr_stmt|;
name|c
operator|.
name|setAccept
argument_list|(
name|p
operator|.
name|s
argument_list|,
name|a1
operator|.
name|isAccept
argument_list|(
name|p
operator|.
name|s1
argument_list|)
operator|&&
name|a2
operator|.
name|isAccept
argument_list|(
name|p
operator|.
name|s2
argument_list|)
argument_list|)
expr_stmt|;
name|Transition
index|[]
name|t1
init|=
name|transitions1
index|[
name|p
operator|.
name|s1
index|]
decl_stmt|;
name|Transition
index|[]
name|t2
init|=
name|transitions2
index|[
name|p
operator|.
name|s2
index|]
decl_stmt|;
for|for
control|(
name|int
name|n1
init|=
literal|0
init|,
name|b2
init|=
literal|0
init|;
name|n1
operator|<
name|t1
operator|.
name|length
condition|;
name|n1
operator|++
control|)
block|{
while|while
condition|(
name|b2
operator|<
name|t2
operator|.
name|length
operator|&&
name|t2
index|[
name|b2
index|]
operator|.
name|max
operator|<
name|t1
index|[
name|n1
index|]
operator|.
name|min
condition|)
name|b2
operator|++
expr_stmt|;
for|for
control|(
name|int
name|n2
init|=
name|b2
init|;
name|n2
operator|<
name|t2
operator|.
name|length
operator|&&
name|t1
index|[
name|n1
index|]
operator|.
name|max
operator|>=
name|t2
index|[
name|n2
index|]
operator|.
name|min
condition|;
name|n2
operator|++
control|)
if|if
condition|(
name|t2
index|[
name|n2
index|]
operator|.
name|max
operator|>=
name|t1
index|[
name|n1
index|]
operator|.
name|min
condition|)
block|{
name|StatePair
name|q
init|=
operator|new
name|StatePair
argument_list|(
name|t1
index|[
name|n1
index|]
operator|.
name|dest
argument_list|,
name|t2
index|[
name|n2
index|]
operator|.
name|dest
argument_list|)
decl_stmt|;
name|StatePair
name|r
init|=
name|newstates
operator|.
name|get
argument_list|(
name|q
argument_list|)
decl_stmt|;
if|if
condition|(
name|r
operator|==
literal|null
condition|)
block|{
name|q
operator|.
name|s
operator|=
name|c
operator|.
name|createState
argument_list|()
expr_stmt|;
name|worklist
operator|.
name|add
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|newstates
operator|.
name|put
argument_list|(
name|q
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|r
operator|=
name|q
expr_stmt|;
block|}
name|int
name|min
init|=
name|t1
index|[
name|n1
index|]
operator|.
name|min
operator|>
name|t2
index|[
name|n2
index|]
operator|.
name|min
condition|?
name|t1
index|[
name|n1
index|]
operator|.
name|min
else|:
name|t2
index|[
name|n2
index|]
operator|.
name|min
decl_stmt|;
name|int
name|max
init|=
name|t1
index|[
name|n1
index|]
operator|.
name|max
operator|<
name|t2
index|[
name|n2
index|]
operator|.
name|max
condition|?
name|t1
index|[
name|n1
index|]
operator|.
name|max
else|:
name|t2
index|[
name|n2
index|]
operator|.
name|max
decl_stmt|;
name|c
operator|.
name|addTransition
argument_list|(
name|p
operator|.
name|s
argument_list|,
name|r
operator|.
name|s
argument_list|,
name|min
argument_list|,
name|max
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|c
operator|.
name|finishState
argument_list|()
expr_stmt|;
return|return
name|removeDeadStates
argument_list|(
name|c
argument_list|)
return|;
block|}
comment|/** Returns true if these two automata accept exactly the    *  same language.  This is a costly computation!  Note    *  also that a1 and a2 will be determinized as a side    *  effect.  Both automata must be determinized and have    *  no dead states! */
DECL|method|sameLanguage
specifier|public
specifier|static
name|boolean
name|sameLanguage
parameter_list|(
name|Automaton
name|a1
parameter_list|,
name|Automaton
name|a2
parameter_list|)
block|{
if|if
condition|(
name|a1
operator|==
name|a2
condition|)
block|{
return|return
literal|true
return|;
block|}
return|return
name|subsetOf
argument_list|(
name|a2
argument_list|,
name|a1
argument_list|)
operator|&&
name|subsetOf
argument_list|(
name|a1
argument_list|,
name|a2
argument_list|)
return|;
block|}
comment|// TODO: move to test-framework?
comment|/** Returns true if this automaton has any states that cannot    *  be reached from the initial state or cannot reach an accept state.    *  Cost is O(numTransitions+numStates). */
DECL|method|hasDeadStates
specifier|public
specifier|static
name|boolean
name|hasDeadStates
parameter_list|(
name|Automaton
name|a
parameter_list|)
block|{
name|BitSet
name|liveStates
init|=
name|getLiveStates
argument_list|(
name|a
argument_list|)
decl_stmt|;
name|int
name|numLive
init|=
name|liveStates
operator|.
name|cardinality
argument_list|()
decl_stmt|;
name|int
name|numStates
init|=
name|a
operator|.
name|getNumStates
argument_list|()
decl_stmt|;
assert|assert
name|numLive
operator|<=
name|numStates
operator|:
literal|"numLive="
operator|+
name|numLive
operator|+
literal|" numStates="
operator|+
name|numStates
operator|+
literal|" "
operator|+
name|liveStates
assert|;
return|return
name|numLive
operator|<
name|numStates
return|;
block|}
comment|// TODO: move to test-framework?
comment|/** Returns true if there are dead states reachable from an initial state. */
DECL|method|hasDeadStatesFromInitial
specifier|public
specifier|static
name|boolean
name|hasDeadStatesFromInitial
parameter_list|(
name|Automaton
name|a
parameter_list|)
block|{
name|BitSet
name|reachableFromInitial
init|=
name|getLiveStatesFromInitial
argument_list|(
name|a
argument_list|)
decl_stmt|;
name|BitSet
name|reachableFromAccept
init|=
name|getLiveStatesToAccept
argument_list|(
name|a
argument_list|)
decl_stmt|;
name|reachableFromInitial
operator|.
name|andNot
argument_list|(
name|reachableFromAccept
argument_list|)
expr_stmt|;
return|return
name|reachableFromInitial
operator|.
name|isEmpty
argument_list|()
operator|==
literal|false
return|;
block|}
comment|// TODO: move to test-framework?
comment|/** Returns true if there are dead states that reach an accept state. */
DECL|method|hasDeadStatesToAccept
specifier|public
specifier|static
name|boolean
name|hasDeadStatesToAccept
parameter_list|(
name|Automaton
name|a
parameter_list|)
block|{
name|BitSet
name|reachableFromInitial
init|=
name|getLiveStatesFromInitial
argument_list|(
name|a
argument_list|)
decl_stmt|;
name|BitSet
name|reachableFromAccept
init|=
name|getLiveStatesToAccept
argument_list|(
name|a
argument_list|)
decl_stmt|;
name|reachableFromAccept
operator|.
name|andNot
argument_list|(
name|reachableFromInitial
argument_list|)
expr_stmt|;
return|return
name|reachableFromAccept
operator|.
name|isEmpty
argument_list|()
operator|==
literal|false
return|;
block|}
comment|/**    * Returns true if the language of<code>a1</code> is a subset of the language    * of<code>a2</code>. Both automata must be determinized and must have no dead    * states.    *<p>    * Complexity: quadratic in number of states.    */
DECL|method|subsetOf
specifier|public
specifier|static
name|boolean
name|subsetOf
parameter_list|(
name|Automaton
name|a1
parameter_list|,
name|Automaton
name|a2
parameter_list|)
block|{
if|if
condition|(
name|a1
operator|.
name|isDeterministic
argument_list|()
operator|==
literal|false
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"a1 must be deterministic"
argument_list|)
throw|;
block|}
if|if
condition|(
name|a2
operator|.
name|isDeterministic
argument_list|()
operator|==
literal|false
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"a2 must be deterministic"
argument_list|)
throw|;
block|}
assert|assert
name|hasDeadStatesFromInitial
argument_list|(
name|a1
argument_list|)
operator|==
literal|false
assert|;
assert|assert
name|hasDeadStatesFromInitial
argument_list|(
name|a2
argument_list|)
operator|==
literal|false
assert|;
if|if
condition|(
name|a1
operator|.
name|getNumStates
argument_list|()
operator|==
literal|0
condition|)
block|{
comment|// Empty language is alwyas a subset of any other language
return|return
literal|true
return|;
block|}
elseif|else
if|if
condition|(
name|a2
operator|.
name|getNumStates
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
name|isEmpty
argument_list|(
name|a1
argument_list|)
return|;
block|}
comment|// TODO: cutover to iterators instead
name|Transition
index|[]
index|[]
name|transitions1
init|=
name|a1
operator|.
name|getSortedTransitions
argument_list|()
decl_stmt|;
name|Transition
index|[]
index|[]
name|transitions2
init|=
name|a2
operator|.
name|getSortedTransitions
argument_list|()
decl_stmt|;
name|LinkedList
argument_list|<
name|StatePair
argument_list|>
name|worklist
init|=
operator|new
name|LinkedList
argument_list|<>
argument_list|()
decl_stmt|;
name|HashSet
argument_list|<
name|StatePair
argument_list|>
name|visited
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
name|StatePair
name|p
init|=
operator|new
name|StatePair
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|worklist
operator|.
name|add
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|visited
operator|.
name|add
argument_list|(
name|p
argument_list|)
expr_stmt|;
while|while
condition|(
name|worklist
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|p
operator|=
name|worklist
operator|.
name|removeFirst
argument_list|()
expr_stmt|;
if|if
condition|(
name|a1
operator|.
name|isAccept
argument_list|(
name|p
operator|.
name|s1
argument_list|)
operator|&&
name|a2
operator|.
name|isAccept
argument_list|(
name|p
operator|.
name|s2
argument_list|)
operator|==
literal|false
condition|)
block|{
return|return
literal|false
return|;
block|}
name|Transition
index|[]
name|t1
init|=
name|transitions1
index|[
name|p
operator|.
name|s1
index|]
decl_stmt|;
name|Transition
index|[]
name|t2
init|=
name|transitions2
index|[
name|p
operator|.
name|s2
index|]
decl_stmt|;
for|for
control|(
name|int
name|n1
init|=
literal|0
init|,
name|b2
init|=
literal|0
init|;
name|n1
operator|<
name|t1
operator|.
name|length
condition|;
name|n1
operator|++
control|)
block|{
while|while
condition|(
name|b2
operator|<
name|t2
operator|.
name|length
operator|&&
name|t2
index|[
name|b2
index|]
operator|.
name|max
operator|<
name|t1
index|[
name|n1
index|]
operator|.
name|min
condition|)
block|{
name|b2
operator|++
expr_stmt|;
block|}
name|int
name|min1
init|=
name|t1
index|[
name|n1
index|]
operator|.
name|min
decl_stmt|,
name|max1
init|=
name|t1
index|[
name|n1
index|]
operator|.
name|max
decl_stmt|;
for|for
control|(
name|int
name|n2
init|=
name|b2
init|;
name|n2
operator|<
name|t2
operator|.
name|length
operator|&&
name|t1
index|[
name|n1
index|]
operator|.
name|max
operator|>=
name|t2
index|[
name|n2
index|]
operator|.
name|min
condition|;
name|n2
operator|++
control|)
block|{
if|if
condition|(
name|t2
index|[
name|n2
index|]
operator|.
name|min
operator|>
name|min1
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|t2
index|[
name|n2
index|]
operator|.
name|max
operator|<
name|Character
operator|.
name|MAX_CODE_POINT
condition|)
block|{
name|min1
operator|=
name|t2
index|[
name|n2
index|]
operator|.
name|max
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
name|min1
operator|=
name|Character
operator|.
name|MAX_CODE_POINT
expr_stmt|;
name|max1
operator|=
name|Character
operator|.
name|MIN_CODE_POINT
expr_stmt|;
block|}
name|StatePair
name|q
init|=
operator|new
name|StatePair
argument_list|(
name|t1
index|[
name|n1
index|]
operator|.
name|dest
argument_list|,
name|t2
index|[
name|n2
index|]
operator|.
name|dest
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|visited
operator|.
name|contains
argument_list|(
name|q
argument_list|)
condition|)
block|{
name|worklist
operator|.
name|add
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|visited
operator|.
name|add
argument_list|(
name|q
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|min1
operator|<=
name|max1
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
block|}
return|return
literal|true
return|;
block|}
comment|/**    * Returns an automaton that accepts the union of the languages of the given    * automata.    *<p>    * Complexity: linear in number of states.    */
DECL|method|union
specifier|public
specifier|static
name|Automaton
name|union
parameter_list|(
name|Automaton
name|a1
parameter_list|,
name|Automaton
name|a2
parameter_list|)
block|{
return|return
name|union
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|a1
argument_list|,
name|a2
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Returns an automaton that accepts the union of the languages of the given    * automata.    *<p>    * Complexity: linear in number of states.    */
DECL|method|union
specifier|public
specifier|static
name|Automaton
name|union
parameter_list|(
name|Collection
argument_list|<
name|Automaton
argument_list|>
name|l
parameter_list|)
block|{
name|Automaton
name|result
init|=
operator|new
name|Automaton
argument_list|()
decl_stmt|;
comment|// Create initial state:
name|result
operator|.
name|createState
argument_list|()
expr_stmt|;
comment|// Copy over all automata
for|for
control|(
name|Automaton
name|a
range|:
name|l
control|)
block|{
name|result
operator|.
name|copy
argument_list|(
name|a
argument_list|)
expr_stmt|;
block|}
comment|// Add epsilon transition from new initial state
name|int
name|stateOffset
init|=
literal|1
decl_stmt|;
for|for
control|(
name|Automaton
name|a
range|:
name|l
control|)
block|{
if|if
condition|(
name|a
operator|.
name|getNumStates
argument_list|()
operator|==
literal|0
condition|)
block|{
continue|continue;
block|}
name|result
operator|.
name|addEpsilon
argument_list|(
literal|0
argument_list|,
name|stateOffset
argument_list|)
expr_stmt|;
name|stateOffset
operator|+=
name|a
operator|.
name|getNumStates
argument_list|()
expr_stmt|;
block|}
name|result
operator|.
name|finishState
argument_list|()
expr_stmt|;
return|return
name|removeDeadStates
argument_list|(
name|result
argument_list|)
return|;
block|}
comment|// Simple custom ArrayList<Transition>
DECL|class|TransitionList
specifier|private
specifier|final
specifier|static
class|class
name|TransitionList
block|{
comment|// dest, min, max
DECL|field|transitions
name|int
index|[]
name|transitions
init|=
operator|new
name|int
index|[
literal|3
index|]
decl_stmt|;
DECL|field|next
name|int
name|next
decl_stmt|;
DECL|method|add
specifier|public
name|void
name|add
parameter_list|(
name|Transition
name|t
parameter_list|)
block|{
if|if
condition|(
name|transitions
operator|.
name|length
operator|<
name|next
operator|+
literal|3
condition|)
block|{
name|transitions
operator|=
name|ArrayUtil
operator|.
name|grow
argument_list|(
name|transitions
argument_list|,
name|next
operator|+
literal|3
argument_list|)
expr_stmt|;
block|}
name|transitions
index|[
name|next
index|]
operator|=
name|t
operator|.
name|dest
expr_stmt|;
name|transitions
index|[
name|next
operator|+
literal|1
index|]
operator|=
name|t
operator|.
name|min
expr_stmt|;
name|transitions
index|[
name|next
operator|+
literal|2
index|]
operator|=
name|t
operator|.
name|max
expr_stmt|;
name|next
operator|+=
literal|3
expr_stmt|;
block|}
block|}
comment|// Holds all transitions that start on this int point, or
comment|// end at this point-1
DECL|class|PointTransitions
specifier|private
specifier|final
specifier|static
class|class
name|PointTransitions
implements|implements
name|Comparable
argument_list|<
name|PointTransitions
argument_list|>
block|{
DECL|field|point
name|int
name|point
decl_stmt|;
DECL|field|ends
specifier|final
name|TransitionList
name|ends
init|=
operator|new
name|TransitionList
argument_list|()
decl_stmt|;
DECL|field|starts
specifier|final
name|TransitionList
name|starts
init|=
operator|new
name|TransitionList
argument_list|()
decl_stmt|;
annotation|@
name|Override
DECL|method|compareTo
specifier|public
name|int
name|compareTo
parameter_list|(
name|PointTransitions
name|other
parameter_list|)
block|{
return|return
name|point
operator|-
name|other
operator|.
name|point
return|;
block|}
DECL|method|reset
specifier|public
name|void
name|reset
parameter_list|(
name|int
name|point
parameter_list|)
block|{
name|this
operator|.
name|point
operator|=
name|point
expr_stmt|;
name|ends
operator|.
name|next
operator|=
literal|0
expr_stmt|;
name|starts
operator|.
name|next
operator|=
literal|0
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|equals
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|other
parameter_list|)
block|{
return|return
operator|(
operator|(
name|PointTransitions
operator|)
name|other
operator|)
operator|.
name|point
operator|==
name|point
return|;
block|}
annotation|@
name|Override
DECL|method|hashCode
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
name|point
return|;
block|}
block|}
DECL|class|PointTransitionSet
specifier|private
specifier|final
specifier|static
class|class
name|PointTransitionSet
block|{
DECL|field|count
name|int
name|count
decl_stmt|;
DECL|field|points
name|PointTransitions
index|[]
name|points
init|=
operator|new
name|PointTransitions
index|[
literal|5
index|]
decl_stmt|;
DECL|field|HASHMAP_CUTOVER
specifier|private
specifier|final
specifier|static
name|int
name|HASHMAP_CUTOVER
init|=
literal|30
decl_stmt|;
DECL|field|map
specifier|private
specifier|final
name|HashMap
argument_list|<
name|Integer
argument_list|,
name|PointTransitions
argument_list|>
name|map
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
DECL|field|useHash
specifier|private
name|boolean
name|useHash
init|=
literal|false
decl_stmt|;
DECL|method|next
specifier|private
name|PointTransitions
name|next
parameter_list|(
name|int
name|point
parameter_list|)
block|{
comment|// 1st time we are seeing this point
if|if
condition|(
name|count
operator|==
name|points
operator|.
name|length
condition|)
block|{
specifier|final
name|PointTransitions
index|[]
name|newArray
init|=
operator|new
name|PointTransitions
index|[
name|ArrayUtil
operator|.
name|oversize
argument_list|(
literal|1
operator|+
name|count
argument_list|,
name|RamUsageEstimator
operator|.
name|NUM_BYTES_OBJECT_REF
argument_list|)
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|points
argument_list|,
literal|0
argument_list|,
name|newArray
argument_list|,
literal|0
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|points
operator|=
name|newArray
expr_stmt|;
block|}
name|PointTransitions
name|points0
init|=
name|points
index|[
name|count
index|]
decl_stmt|;
if|if
condition|(
name|points0
operator|==
literal|null
condition|)
block|{
name|points0
operator|=
name|points
index|[
name|count
index|]
operator|=
operator|new
name|PointTransitions
argument_list|()
expr_stmt|;
block|}
name|points0
operator|.
name|reset
argument_list|(
name|point
argument_list|)
expr_stmt|;
name|count
operator|++
expr_stmt|;
return|return
name|points0
return|;
block|}
DECL|method|find
specifier|private
name|PointTransitions
name|find
parameter_list|(
name|int
name|point
parameter_list|)
block|{
if|if
condition|(
name|useHash
condition|)
block|{
specifier|final
name|Integer
name|pi
init|=
name|point
decl_stmt|;
name|PointTransitions
name|p
init|=
name|map
operator|.
name|get
argument_list|(
name|pi
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
operator|==
literal|null
condition|)
block|{
name|p
operator|=
name|next
argument_list|(
name|point
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
name|pi
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
return|return
name|p
return|;
block|}
else|else
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|points
index|[
name|i
index|]
operator|.
name|point
operator|==
name|point
condition|)
block|{
return|return
name|points
index|[
name|i
index|]
return|;
block|}
block|}
specifier|final
name|PointTransitions
name|p
init|=
name|next
argument_list|(
name|point
argument_list|)
decl_stmt|;
if|if
condition|(
name|count
operator|==
name|HASHMAP_CUTOVER
condition|)
block|{
comment|// switch to HashMap on the fly
assert|assert
name|map
operator|.
name|size
argument_list|()
operator|==
literal|0
assert|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|map
operator|.
name|put
argument_list|(
name|points
index|[
name|i
index|]
operator|.
name|point
argument_list|,
name|points
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|useHash
operator|=
literal|true
expr_stmt|;
block|}
return|return
name|p
return|;
block|}
block|}
DECL|method|reset
specifier|public
name|void
name|reset
parameter_list|()
block|{
if|if
condition|(
name|useHash
condition|)
block|{
name|map
operator|.
name|clear
argument_list|()
expr_stmt|;
name|useHash
operator|=
literal|false
expr_stmt|;
block|}
name|count
operator|=
literal|0
expr_stmt|;
block|}
DECL|method|sort
specifier|public
name|void
name|sort
parameter_list|()
block|{
comment|// Tim sort performs well on already sorted arrays:
if|if
condition|(
name|count
operator|>
literal|1
condition|)
name|ArrayUtil
operator|.
name|timSort
argument_list|(
name|points
argument_list|,
literal|0
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
DECL|method|add
specifier|public
name|void
name|add
parameter_list|(
name|Transition
name|t
parameter_list|)
block|{
name|find
argument_list|(
name|t
operator|.
name|min
argument_list|)
operator|.
name|starts
operator|.
name|add
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|find
argument_list|(
literal|1
operator|+
name|t
operator|.
name|max
argument_list|)
operator|.
name|ends
operator|.
name|add
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
name|StringBuilder
name|s
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|s
operator|.
name|append
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
name|s
operator|.
name|append
argument_list|(
name|points
index|[
name|i
index|]
operator|.
name|point
argument_list|)
operator|.
name|append
argument_list|(
literal|':'
argument_list|)
operator|.
name|append
argument_list|(
name|points
index|[
name|i
index|]
operator|.
name|starts
operator|.
name|next
operator|/
literal|3
argument_list|)
operator|.
name|append
argument_list|(
literal|','
argument_list|)
operator|.
name|append
argument_list|(
name|points
index|[
name|i
index|]
operator|.
name|ends
operator|.
name|next
operator|/
literal|3
argument_list|)
expr_stmt|;
block|}
return|return
name|s
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
comment|/**    * Determinizes the given automaton.    *<p>    * Worst case complexity: exponential in number of states.    * @param maxDeterminizedStates Maximum number of states created when    *   determinizing.  Higher numbers allow this operation to consume more    *   memory but allow more complex automatons.  Use    *   DEFAULT_MAX_DETERMINIZED_STATES as a decent default if you don't know    *   how many to allow.    * @throws TooComplexToDeterminizeException if determinizing a creates an    *   automaton with more than maxDeterminizedStates    */
DECL|method|determinize
specifier|public
specifier|static
name|Automaton
name|determinize
parameter_list|(
name|Automaton
name|a
parameter_list|,
name|int
name|maxDeterminizedStates
parameter_list|)
block|{
if|if
condition|(
name|a
operator|.
name|isDeterministic
argument_list|()
condition|)
block|{
comment|// Already determinized
return|return
name|a
return|;
block|}
if|if
condition|(
name|a
operator|.
name|getNumStates
argument_list|()
operator|<=
literal|1
condition|)
block|{
comment|// Already determinized
return|return
name|a
return|;
block|}
comment|// subset construction
name|Automaton
operator|.
name|Builder
name|b
init|=
operator|new
name|Automaton
operator|.
name|Builder
argument_list|()
decl_stmt|;
comment|//System.out.println("DET:");
comment|//a.writeDot("/l/la/lucene/core/detin.dot");
name|SortedIntSet
operator|.
name|FrozenIntSet
name|initialset
init|=
operator|new
name|SortedIntSet
operator|.
name|FrozenIntSet
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|// Create state 0:
name|b
operator|.
name|createState
argument_list|()
expr_stmt|;
name|LinkedList
argument_list|<
name|SortedIntSet
operator|.
name|FrozenIntSet
argument_list|>
name|worklist
init|=
operator|new
name|LinkedList
argument_list|<>
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|SortedIntSet
operator|.
name|FrozenIntSet
argument_list|,
name|Integer
argument_list|>
name|newstate
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|worklist
operator|.
name|add
argument_list|(
name|initialset
argument_list|)
expr_stmt|;
name|b
operator|.
name|setAccept
argument_list|(
literal|0
argument_list|,
name|a
operator|.
name|isAccept
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|newstate
operator|.
name|put
argument_list|(
name|initialset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|// like Set<Integer,PointTransitions>
specifier|final
name|PointTransitionSet
name|points
init|=
operator|new
name|PointTransitionSet
argument_list|()
decl_stmt|;
comment|// like SortedMap<Integer,Integer>
specifier|final
name|SortedIntSet
name|statesSet
init|=
operator|new
name|SortedIntSet
argument_list|(
literal|5
argument_list|)
decl_stmt|;
name|Transition
name|t
init|=
operator|new
name|Transition
argument_list|()
decl_stmt|;
while|while
condition|(
name|worklist
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|SortedIntSet
operator|.
name|FrozenIntSet
name|s
init|=
name|worklist
operator|.
name|removeFirst
argument_list|()
decl_stmt|;
comment|//System.out.println("det: pop set=" + s);
comment|// Collate all outgoing transitions by min/1+max:
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|s
operator|.
name|values
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|int
name|s0
init|=
name|s
operator|.
name|values
index|[
name|i
index|]
decl_stmt|;
name|int
name|numTransitions
init|=
name|a
operator|.
name|getNumTransitions
argument_list|(
name|s0
argument_list|)
decl_stmt|;
name|a
operator|.
name|initTransition
argument_list|(
name|s0
argument_list|,
name|t
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|numTransitions
condition|;
name|j
operator|++
control|)
block|{
name|a
operator|.
name|getNextTransition
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|points
operator|.
name|add
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|points
operator|.
name|count
operator|==
literal|0
condition|)
block|{
comment|// No outgoing transitions -- skip it
continue|continue;
block|}
name|points
operator|.
name|sort
argument_list|()
expr_stmt|;
name|int
name|lastPoint
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|accCount
init|=
literal|0
decl_stmt|;
specifier|final
name|int
name|r
init|=
name|s
operator|.
name|state
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|points
operator|.
name|count
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|int
name|point
init|=
name|points
operator|.
name|points
index|[
name|i
index|]
operator|.
name|point
decl_stmt|;
if|if
condition|(
name|statesSet
operator|.
name|upto
operator|>
literal|0
condition|)
block|{
assert|assert
name|lastPoint
operator|!=
operator|-
literal|1
assert|;
name|statesSet
operator|.
name|computeHash
argument_list|()
expr_stmt|;
name|Integer
name|q
init|=
name|newstate
operator|.
name|get
argument_list|(
name|statesSet
argument_list|)
decl_stmt|;
if|if
condition|(
name|q
operator|==
literal|null
condition|)
block|{
name|q
operator|=
name|b
operator|.
name|createState
argument_list|()
expr_stmt|;
if|if
condition|(
name|q
operator|>=
name|maxDeterminizedStates
condition|)
block|{
throw|throw
operator|new
name|TooComplexToDeterminizeException
argument_list|(
name|a
argument_list|,
name|maxDeterminizedStates
argument_list|)
throw|;
block|}
specifier|final
name|SortedIntSet
operator|.
name|FrozenIntSet
name|p
init|=
name|statesSet
operator|.
name|freeze
argument_list|(
name|q
argument_list|)
decl_stmt|;
comment|//System.out.println("  make new state=" + q + " -> " + p + " accCount=" + accCount);
name|worklist
operator|.
name|add
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|b
operator|.
name|setAccept
argument_list|(
name|q
argument_list|,
name|accCount
operator|>
literal|0
argument_list|)
expr_stmt|;
name|newstate
operator|.
name|put
argument_list|(
name|p
argument_list|,
name|q
argument_list|)
expr_stmt|;
block|}
else|else
block|{
assert|assert
operator|(
name|accCount
operator|>
literal|0
condition|?
literal|true
else|:
literal|false
operator|)
operator|==
name|b
operator|.
name|isAccept
argument_list|(
name|q
argument_list|)
operator|:
literal|"accCount="
operator|+
name|accCount
operator|+
literal|" vs existing accept="
operator|+
name|b
operator|.
name|isAccept
argument_list|(
name|q
argument_list|)
operator|+
literal|" states="
operator|+
name|statesSet
assert|;
block|}
comment|// System.out.println("  add trans src=" + r + " dest=" + q + " min=" + lastPoint + " max=" + (point-1));
name|b
operator|.
name|addTransition
argument_list|(
name|r
argument_list|,
name|q
argument_list|,
name|lastPoint
argument_list|,
name|point
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|// process transitions that end on this point
comment|// (closes an overlapping interval)
name|int
index|[]
name|transitions
init|=
name|points
operator|.
name|points
index|[
name|i
index|]
operator|.
name|ends
operator|.
name|transitions
decl_stmt|;
name|int
name|limit
init|=
name|points
operator|.
name|points
index|[
name|i
index|]
operator|.
name|ends
operator|.
name|next
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|limit
condition|;
name|j
operator|+=
literal|3
control|)
block|{
name|int
name|dest
init|=
name|transitions
index|[
name|j
index|]
decl_stmt|;
name|statesSet
operator|.
name|decr
argument_list|(
name|dest
argument_list|)
expr_stmt|;
name|accCount
operator|-=
name|a
operator|.
name|isAccept
argument_list|(
name|dest
argument_list|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
block|}
name|points
operator|.
name|points
index|[
name|i
index|]
operator|.
name|ends
operator|.
name|next
operator|=
literal|0
expr_stmt|;
comment|// process transitions that start on this point
comment|// (opens a new interval)
name|transitions
operator|=
name|points
operator|.
name|points
index|[
name|i
index|]
operator|.
name|starts
operator|.
name|transitions
expr_stmt|;
name|limit
operator|=
name|points
operator|.
name|points
index|[
name|i
index|]
operator|.
name|starts
operator|.
name|next
expr_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|limit
condition|;
name|j
operator|+=
literal|3
control|)
block|{
name|int
name|dest
init|=
name|transitions
index|[
name|j
index|]
decl_stmt|;
name|statesSet
operator|.
name|incr
argument_list|(
name|dest
argument_list|)
expr_stmt|;
name|accCount
operator|+=
name|a
operator|.
name|isAccept
argument_list|(
name|dest
argument_list|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
block|}
name|lastPoint
operator|=
name|point
expr_stmt|;
name|points
operator|.
name|points
index|[
name|i
index|]
operator|.
name|starts
operator|.
name|next
operator|=
literal|0
expr_stmt|;
block|}
name|points
operator|.
name|reset
argument_list|()
expr_stmt|;
assert|assert
name|statesSet
operator|.
name|upto
operator|==
literal|0
operator|:
literal|"upto="
operator|+
name|statesSet
operator|.
name|upto
assert|;
block|}
name|Automaton
name|result
init|=
name|b
operator|.
name|finish
argument_list|()
decl_stmt|;
assert|assert
name|result
operator|.
name|isDeterministic
argument_list|()
assert|;
return|return
name|result
return|;
block|}
comment|/**    * Returns true if the given automaton accepts no strings.    */
DECL|method|isEmpty
specifier|public
specifier|static
name|boolean
name|isEmpty
parameter_list|(
name|Automaton
name|a
parameter_list|)
block|{
if|if
condition|(
name|a
operator|.
name|getNumStates
argument_list|()
operator|==
literal|0
condition|)
block|{
comment|// Common case: no states
return|return
literal|true
return|;
block|}
if|if
condition|(
name|a
operator|.
name|isAccept
argument_list|(
literal|0
argument_list|)
operator|==
literal|false
operator|&&
name|a
operator|.
name|getNumTransitions
argument_list|(
literal|0
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|// Common case: just one initial state
return|return
literal|true
return|;
block|}
if|if
condition|(
name|a
operator|.
name|isAccept
argument_list|(
literal|0
argument_list|)
operator|==
literal|true
condition|)
block|{
comment|// Apparently common case: it accepts the damned empty string
return|return
literal|false
return|;
block|}
name|LinkedList
argument_list|<
name|Integer
argument_list|>
name|workList
init|=
operator|new
name|LinkedList
argument_list|<>
argument_list|()
decl_stmt|;
name|BitSet
name|seen
init|=
operator|new
name|BitSet
argument_list|(
name|a
operator|.
name|getNumStates
argument_list|()
argument_list|)
decl_stmt|;
name|workList
operator|.
name|add
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|seen
operator|.
name|set
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|Transition
name|t
init|=
operator|new
name|Transition
argument_list|()
decl_stmt|;
while|while
condition|(
name|workList
operator|.
name|isEmpty
argument_list|()
operator|==
literal|false
condition|)
block|{
name|int
name|state
init|=
name|workList
operator|.
name|removeFirst
argument_list|()
decl_stmt|;
if|if
condition|(
name|a
operator|.
name|isAccept
argument_list|(
name|state
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|int
name|count
init|=
name|a
operator|.
name|initTransition
argument_list|(
name|state
argument_list|,
name|t
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|a
operator|.
name|getNextTransition
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|seen
operator|.
name|get
argument_list|(
name|t
operator|.
name|dest
argument_list|)
operator|==
literal|false
condition|)
block|{
name|workList
operator|.
name|add
argument_list|(
name|t
operator|.
name|dest
argument_list|)
expr_stmt|;
name|seen
operator|.
name|set
argument_list|(
name|t
operator|.
name|dest
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
literal|true
return|;
block|}
comment|/**    * Returns true if the given automaton accepts all strings.  The automaton must be minimized.    */
DECL|method|isTotal
specifier|public
specifier|static
name|boolean
name|isTotal
parameter_list|(
name|Automaton
name|a
parameter_list|)
block|{
return|return
name|isTotal
argument_list|(
name|a
argument_list|,
name|Character
operator|.
name|MIN_CODE_POINT
argument_list|,
name|Character
operator|.
name|MAX_CODE_POINT
argument_list|)
return|;
block|}
comment|/**    * Returns true if the given automaton accepts all strings for the specified min/max    * range of the alphabet.  The automaton must be minimized.    */
DECL|method|isTotal
specifier|public
specifier|static
name|boolean
name|isTotal
parameter_list|(
name|Automaton
name|a
parameter_list|,
name|int
name|minAlphabet
parameter_list|,
name|int
name|maxAlphabet
parameter_list|)
block|{
if|if
condition|(
name|a
operator|.
name|isAccept
argument_list|(
literal|0
argument_list|)
operator|&&
name|a
operator|.
name|getNumTransitions
argument_list|(
literal|0
argument_list|)
operator|==
literal|1
condition|)
block|{
name|Transition
name|t
init|=
operator|new
name|Transition
argument_list|()
decl_stmt|;
name|a
operator|.
name|getTransition
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
name|t
operator|.
name|dest
operator|==
literal|0
operator|&&
name|t
operator|.
name|min
operator|==
name|minAlphabet
operator|&&
name|t
operator|.
name|max
operator|==
name|maxAlphabet
return|;
block|}
return|return
literal|false
return|;
block|}
comment|/**    * Returns true if the given string is accepted by the automaton.  The input must be deterministic.    *<p>    * Complexity: linear in the length of the string.    *<p>    *<b>Note:</b> for full performance, use the {@link RunAutomaton} class.    */
DECL|method|run
specifier|public
specifier|static
name|boolean
name|run
parameter_list|(
name|Automaton
name|a
parameter_list|,
name|String
name|s
parameter_list|)
block|{
assert|assert
name|a
operator|.
name|isDeterministic
argument_list|()
assert|;
name|int
name|state
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|,
name|cp
init|=
literal|0
init|;
name|i
operator|<
name|s
operator|.
name|length
argument_list|()
condition|;
name|i
operator|+=
name|Character
operator|.
name|charCount
argument_list|(
name|cp
argument_list|)
control|)
block|{
name|int
name|nextState
init|=
name|a
operator|.
name|step
argument_list|(
name|state
argument_list|,
name|cp
operator|=
name|s
operator|.
name|codePointAt
argument_list|(
name|i
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|nextState
operator|==
operator|-
literal|1
condition|)
block|{
return|return
literal|false
return|;
block|}
name|state
operator|=
name|nextState
expr_stmt|;
block|}
return|return
name|a
operator|.
name|isAccept
argument_list|(
name|state
argument_list|)
return|;
block|}
comment|/**    * Returns true if the given string (expressed as unicode codepoints) is accepted by the automaton.  The input must be deterministic.    *<p>    * Complexity: linear in the length of the string.    *<p>    *<b>Note:</b> for full performance, use the {@link RunAutomaton} class.    */
DECL|method|run
specifier|public
specifier|static
name|boolean
name|run
parameter_list|(
name|Automaton
name|a
parameter_list|,
name|IntsRef
name|s
parameter_list|)
block|{
assert|assert
name|a
operator|.
name|isDeterministic
argument_list|()
assert|;
name|int
name|state
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|s
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|int
name|nextState
init|=
name|a
operator|.
name|step
argument_list|(
name|state
argument_list|,
name|s
operator|.
name|ints
index|[
name|s
operator|.
name|offset
operator|+
name|i
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|nextState
operator|==
operator|-
literal|1
condition|)
block|{
return|return
literal|false
return|;
block|}
name|state
operator|=
name|nextState
expr_stmt|;
block|}
return|return
name|a
operator|.
name|isAccept
argument_list|(
name|state
argument_list|)
return|;
block|}
comment|/**    * Returns the set of live states. A state is "live" if an accept state is    * reachable from it and if it is reachable from the initial state.    */
DECL|method|getLiveStates
specifier|private
specifier|static
name|BitSet
name|getLiveStates
parameter_list|(
name|Automaton
name|a
parameter_list|)
block|{
name|BitSet
name|live
init|=
name|getLiveStatesFromInitial
argument_list|(
name|a
argument_list|)
decl_stmt|;
name|live
operator|.
name|and
argument_list|(
name|getLiveStatesToAccept
argument_list|(
name|a
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|live
return|;
block|}
comment|/** Returns bitset marking states reachable from the initial state. */
DECL|method|getLiveStatesFromInitial
specifier|private
specifier|static
name|BitSet
name|getLiveStatesFromInitial
parameter_list|(
name|Automaton
name|a
parameter_list|)
block|{
name|int
name|numStates
init|=
name|a
operator|.
name|getNumStates
argument_list|()
decl_stmt|;
name|BitSet
name|live
init|=
operator|new
name|BitSet
argument_list|(
name|numStates
argument_list|)
decl_stmt|;
if|if
condition|(
name|numStates
operator|==
literal|0
condition|)
block|{
return|return
name|live
return|;
block|}
name|LinkedList
argument_list|<
name|Integer
argument_list|>
name|workList
init|=
operator|new
name|LinkedList
argument_list|<>
argument_list|()
decl_stmt|;
name|live
operator|.
name|set
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|workList
operator|.
name|add
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|Transition
name|t
init|=
operator|new
name|Transition
argument_list|()
decl_stmt|;
while|while
condition|(
name|workList
operator|.
name|isEmpty
argument_list|()
operator|==
literal|false
condition|)
block|{
name|int
name|s
init|=
name|workList
operator|.
name|removeFirst
argument_list|()
decl_stmt|;
name|int
name|count
init|=
name|a
operator|.
name|initTransition
argument_list|(
name|s
argument_list|,
name|t
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|a
operator|.
name|getNextTransition
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|live
operator|.
name|get
argument_list|(
name|t
operator|.
name|dest
argument_list|)
operator|==
literal|false
condition|)
block|{
name|live
operator|.
name|set
argument_list|(
name|t
operator|.
name|dest
argument_list|)
expr_stmt|;
name|workList
operator|.
name|add
argument_list|(
name|t
operator|.
name|dest
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|live
return|;
block|}
comment|/** Returns bitset marking states that can reach an accept state. */
DECL|method|getLiveStatesToAccept
specifier|private
specifier|static
name|BitSet
name|getLiveStatesToAccept
parameter_list|(
name|Automaton
name|a
parameter_list|)
block|{
name|Automaton
operator|.
name|Builder
name|builder
init|=
operator|new
name|Automaton
operator|.
name|Builder
argument_list|()
decl_stmt|;
comment|// NOTE: not quite the same thing as what SpecialOperations.reverse does:
name|Transition
name|t
init|=
operator|new
name|Transition
argument_list|()
decl_stmt|;
name|int
name|numStates
init|=
name|a
operator|.
name|getNumStates
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|s
init|=
literal|0
init|;
name|s
operator|<
name|numStates
condition|;
name|s
operator|++
control|)
block|{
name|builder
operator|.
name|createState
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|int
name|s
init|=
literal|0
init|;
name|s
operator|<
name|numStates
condition|;
name|s
operator|++
control|)
block|{
name|int
name|count
init|=
name|a
operator|.
name|initTransition
argument_list|(
name|s
argument_list|,
name|t
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|a
operator|.
name|getNextTransition
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|builder
operator|.
name|addTransition
argument_list|(
name|t
operator|.
name|dest
argument_list|,
name|s
argument_list|,
name|t
operator|.
name|min
argument_list|,
name|t
operator|.
name|max
argument_list|)
expr_stmt|;
block|}
block|}
name|Automaton
name|a2
init|=
name|builder
operator|.
name|finish
argument_list|()
decl_stmt|;
name|LinkedList
argument_list|<
name|Integer
argument_list|>
name|workList
init|=
operator|new
name|LinkedList
argument_list|<>
argument_list|()
decl_stmt|;
name|BitSet
name|live
init|=
operator|new
name|BitSet
argument_list|(
name|numStates
argument_list|)
decl_stmt|;
name|BitSet
name|acceptBits
init|=
name|a
operator|.
name|getAcceptStates
argument_list|()
decl_stmt|;
name|int
name|s
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|s
operator|<
name|numStates
operator|&&
operator|(
name|s
operator|=
name|acceptBits
operator|.
name|nextSetBit
argument_list|(
name|s
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|live
operator|.
name|set
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|workList
operator|.
name|add
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|s
operator|++
expr_stmt|;
block|}
while|while
condition|(
name|workList
operator|.
name|isEmpty
argument_list|()
operator|==
literal|false
condition|)
block|{
name|s
operator|=
name|workList
operator|.
name|removeFirst
argument_list|()
expr_stmt|;
name|int
name|count
init|=
name|a2
operator|.
name|initTransition
argument_list|(
name|s
argument_list|,
name|t
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|a2
operator|.
name|getNextTransition
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|live
operator|.
name|get
argument_list|(
name|t
operator|.
name|dest
argument_list|)
operator|==
literal|false
condition|)
block|{
name|live
operator|.
name|set
argument_list|(
name|t
operator|.
name|dest
argument_list|)
expr_stmt|;
name|workList
operator|.
name|add
argument_list|(
name|t
operator|.
name|dest
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|live
return|;
block|}
comment|/**    * Removes transitions to dead states (a state is "dead" if it is not    * reachable from the initial state or no accept state is reachable from it.)    */
DECL|method|removeDeadStates
specifier|public
specifier|static
name|Automaton
name|removeDeadStates
parameter_list|(
name|Automaton
name|a
parameter_list|)
block|{
name|int
name|numStates
init|=
name|a
operator|.
name|getNumStates
argument_list|()
decl_stmt|;
name|BitSet
name|liveSet
init|=
name|getLiveStates
argument_list|(
name|a
argument_list|)
decl_stmt|;
name|int
index|[]
name|map
init|=
operator|new
name|int
index|[
name|numStates
index|]
decl_stmt|;
name|Automaton
name|result
init|=
operator|new
name|Automaton
argument_list|()
decl_stmt|;
comment|//System.out.println("liveSet: " + liveSet + " numStates=" + numStates);
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numStates
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|liveSet
operator|.
name|get
argument_list|(
name|i
argument_list|)
condition|)
block|{
name|map
index|[
name|i
index|]
operator|=
name|result
operator|.
name|createState
argument_list|()
expr_stmt|;
name|result
operator|.
name|setAccept
argument_list|(
name|map
index|[
name|i
index|]
argument_list|,
name|a
operator|.
name|isAccept
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|Transition
name|t
init|=
operator|new
name|Transition
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numStates
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|liveSet
operator|.
name|get
argument_list|(
name|i
argument_list|)
condition|)
block|{
name|int
name|numTransitions
init|=
name|a
operator|.
name|initTransition
argument_list|(
name|i
argument_list|,
name|t
argument_list|)
decl_stmt|;
comment|// filter out transitions to dead states:
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|numTransitions
condition|;
name|j
operator|++
control|)
block|{
name|a
operator|.
name|getNextTransition
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|liveSet
operator|.
name|get
argument_list|(
name|t
operator|.
name|dest
argument_list|)
condition|)
block|{
name|result
operator|.
name|addTransition
argument_list|(
name|map
index|[
name|i
index|]
argument_list|,
name|map
index|[
name|t
operator|.
name|dest
index|]
argument_list|,
name|t
operator|.
name|min
argument_list|,
name|t
operator|.
name|max
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
name|result
operator|.
name|finishState
argument_list|()
expr_stmt|;
assert|assert
name|hasDeadStates
argument_list|(
name|result
argument_list|)
operator|==
literal|false
assert|;
return|return
name|result
return|;
block|}
comment|/**    * Finds the largest entry whose value is less than or equal to c, or 0 if    * there is no such entry.    */
DECL|method|findIndex
specifier|static
name|int
name|findIndex
parameter_list|(
name|int
name|c
parameter_list|,
name|int
index|[]
name|points
parameter_list|)
block|{
name|int
name|a
init|=
literal|0
decl_stmt|;
name|int
name|b
init|=
name|points
operator|.
name|length
decl_stmt|;
while|while
condition|(
name|b
operator|-
name|a
operator|>
literal|1
condition|)
block|{
name|int
name|d
init|=
operator|(
name|a
operator|+
name|b
operator|)
operator|>>>
literal|1
decl_stmt|;
if|if
condition|(
name|points
index|[
name|d
index|]
operator|>
name|c
condition|)
name|b
operator|=
name|d
expr_stmt|;
elseif|else
if|if
condition|(
name|points
index|[
name|d
index|]
operator|<
name|c
condition|)
name|a
operator|=
name|d
expr_stmt|;
else|else
return|return
name|d
return|;
block|}
return|return
name|a
return|;
block|}
comment|/**    * Returns true if the language of this automaton is finite.  The    * automaton must not have any dead states.    */
DECL|method|isFinite
specifier|public
specifier|static
name|boolean
name|isFinite
parameter_list|(
name|Automaton
name|a
parameter_list|)
block|{
if|if
condition|(
name|a
operator|.
name|getNumStates
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
literal|true
return|;
block|}
return|return
name|isFinite
argument_list|(
operator|new
name|Transition
argument_list|()
argument_list|,
name|a
argument_list|,
literal|0
argument_list|,
operator|new
name|BitSet
argument_list|(
name|a
operator|.
name|getNumStates
argument_list|()
argument_list|)
argument_list|,
operator|new
name|BitSet
argument_list|(
name|a
operator|.
name|getNumStates
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Checks whether there is a loop containing state. (This is sufficient since    * there are never transitions to dead states.)    */
comment|// TODO: not great that this is recursive... in theory a
comment|// large automata could exceed java's stack
DECL|method|isFinite
specifier|private
specifier|static
name|boolean
name|isFinite
parameter_list|(
name|Transition
name|scratch
parameter_list|,
name|Automaton
name|a
parameter_list|,
name|int
name|state
parameter_list|,
name|BitSet
name|path
parameter_list|,
name|BitSet
name|visited
parameter_list|)
block|{
name|path
operator|.
name|set
argument_list|(
name|state
argument_list|)
expr_stmt|;
name|int
name|numTransitions
init|=
name|a
operator|.
name|initTransition
argument_list|(
name|state
argument_list|,
name|scratch
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|t
init|=
literal|0
init|;
name|t
operator|<
name|numTransitions
condition|;
name|t
operator|++
control|)
block|{
name|a
operator|.
name|getTransition
argument_list|(
name|state
argument_list|,
name|t
argument_list|,
name|scratch
argument_list|)
expr_stmt|;
if|if
condition|(
name|path
operator|.
name|get
argument_list|(
name|scratch
operator|.
name|dest
argument_list|)
operator|||
operator|(
operator|!
name|visited
operator|.
name|get
argument_list|(
name|scratch
operator|.
name|dest
argument_list|)
operator|&&
operator|!
name|isFinite
argument_list|(
name|scratch
argument_list|,
name|a
argument_list|,
name|scratch
operator|.
name|dest
argument_list|,
name|path
argument_list|,
name|visited
argument_list|)
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
name|path
operator|.
name|clear
argument_list|(
name|state
argument_list|)
expr_stmt|;
name|visited
operator|.
name|set
argument_list|(
name|state
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
comment|/**    * Returns the longest string that is a prefix of all accepted strings and    * visits each state at most once.  The automaton must be deterministic.    *     * @return common prefix, which can be an empty (length 0) String (never null)    */
DECL|method|getCommonPrefix
specifier|public
specifier|static
name|String
name|getCommonPrefix
parameter_list|(
name|Automaton
name|a
parameter_list|)
block|{
if|if
condition|(
name|a
operator|.
name|isDeterministic
argument_list|()
operator|==
literal|false
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"input automaton must be deterministic"
argument_list|)
throw|;
block|}
name|StringBuilder
name|b
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|HashSet
argument_list|<
name|Integer
argument_list|>
name|visited
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
name|int
name|s
init|=
literal|0
decl_stmt|;
name|boolean
name|done
decl_stmt|;
name|Transition
name|t
init|=
operator|new
name|Transition
argument_list|()
decl_stmt|;
do|do
block|{
name|done
operator|=
literal|true
expr_stmt|;
name|visited
operator|.
name|add
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
operator|.
name|isAccept
argument_list|(
name|s
argument_list|)
operator|==
literal|false
operator|&&
name|a
operator|.
name|getNumTransitions
argument_list|(
name|s
argument_list|)
operator|==
literal|1
condition|)
block|{
name|a
operator|.
name|getTransition
argument_list|(
name|s
argument_list|,
literal|0
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|.
name|min
operator|==
name|t
operator|.
name|max
operator|&&
operator|!
name|visited
operator|.
name|contains
argument_list|(
name|t
operator|.
name|dest
argument_list|)
condition|)
block|{
name|b
operator|.
name|appendCodePoint
argument_list|(
name|t
operator|.
name|min
argument_list|)
expr_stmt|;
name|s
operator|=
name|t
operator|.
name|dest
expr_stmt|;
name|done
operator|=
literal|false
expr_stmt|;
block|}
block|}
block|}
do|while
condition|(
operator|!
name|done
condition|)
do|;
return|return
name|b
operator|.
name|toString
argument_list|()
return|;
block|}
comment|// TODO: this currently requites a determinized machine,
comment|// but it need not -- we can speed it up by walking the
comment|// NFA instead.  it'd still be fail fast.
comment|/**    * Returns the longest BytesRef that is a prefix of all accepted strings and    * visits each state at most once.  The automaton must be deterministic.    *     * @return common prefix, which can be an empty (length 0) BytesRef (never null)    */
DECL|method|getCommonPrefixBytesRef
specifier|public
specifier|static
name|BytesRef
name|getCommonPrefixBytesRef
parameter_list|(
name|Automaton
name|a
parameter_list|)
block|{
name|BytesRefBuilder
name|builder
init|=
operator|new
name|BytesRefBuilder
argument_list|()
decl_stmt|;
name|HashSet
argument_list|<
name|Integer
argument_list|>
name|visited
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
name|int
name|s
init|=
literal|0
decl_stmt|;
name|boolean
name|done
decl_stmt|;
name|Transition
name|t
init|=
operator|new
name|Transition
argument_list|()
decl_stmt|;
do|do
block|{
name|done
operator|=
literal|true
expr_stmt|;
name|visited
operator|.
name|add
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
operator|.
name|isAccept
argument_list|(
name|s
argument_list|)
operator|==
literal|false
operator|&&
name|a
operator|.
name|getNumTransitions
argument_list|(
name|s
argument_list|)
operator|==
literal|1
condition|)
block|{
name|a
operator|.
name|getTransition
argument_list|(
name|s
argument_list|,
literal|0
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|.
name|min
operator|==
name|t
operator|.
name|max
operator|&&
operator|!
name|visited
operator|.
name|contains
argument_list|(
name|t
operator|.
name|dest
argument_list|)
condition|)
block|{
name|builder
operator|.
name|append
argument_list|(
operator|(
name|byte
operator|)
name|t
operator|.
name|min
argument_list|)
expr_stmt|;
name|s
operator|=
name|t
operator|.
name|dest
expr_stmt|;
name|done
operator|=
literal|false
expr_stmt|;
block|}
block|}
block|}
do|while
condition|(
operator|!
name|done
condition|)
do|;
return|return
name|builder
operator|.
name|get
argument_list|()
return|;
block|}
comment|/** If this automaton accepts a single input, return it.  Else, return null.    *  The automaton must be deterministic. */
DECL|method|getSingleton
specifier|public
specifier|static
name|IntsRef
name|getSingleton
parameter_list|(
name|Automaton
name|a
parameter_list|)
block|{
if|if
condition|(
name|a
operator|.
name|isDeterministic
argument_list|()
operator|==
literal|false
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"input automaton must be deterministic"
argument_list|)
throw|;
block|}
name|IntsRefBuilder
name|builder
init|=
operator|new
name|IntsRefBuilder
argument_list|()
decl_stmt|;
name|HashSet
argument_list|<
name|Integer
argument_list|>
name|visited
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
name|int
name|s
init|=
literal|0
decl_stmt|;
name|Transition
name|t
init|=
operator|new
name|Transition
argument_list|()
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|visited
operator|.
name|add
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
operator|.
name|isAccept
argument_list|(
name|s
argument_list|)
operator|==
literal|false
condition|)
block|{
if|if
condition|(
name|a
operator|.
name|getNumTransitions
argument_list|(
name|s
argument_list|)
operator|==
literal|1
condition|)
block|{
name|a
operator|.
name|getTransition
argument_list|(
name|s
argument_list|,
literal|0
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|.
name|min
operator|==
name|t
operator|.
name|max
operator|&&
operator|!
name|visited
operator|.
name|contains
argument_list|(
name|t
operator|.
name|dest
argument_list|)
condition|)
block|{
name|builder
operator|.
name|append
argument_list|(
name|t
operator|.
name|min
argument_list|)
expr_stmt|;
name|s
operator|=
name|t
operator|.
name|dest
expr_stmt|;
continue|continue;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|a
operator|.
name|getNumTransitions
argument_list|(
name|s
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
name|builder
operator|.
name|get
argument_list|()
return|;
block|}
comment|// Automaton accepts more than one string:
return|return
literal|null
return|;
block|}
block|}
comment|/**    * Returns the longest BytesRef that is a suffix of all accepted strings.    * Worst case complexity: exponential in number of states (this calls    * determinize).    * @param maxDeterminizedStates maximum number of states determinizing the    *  automaton can result in.  Set higher to allow more complex queries and    *  lower to prevent memory exhaustion.    * @return common suffix, which can be an empty (length 0) BytesRef (never null)    */
DECL|method|getCommonSuffixBytesRef
specifier|public
specifier|static
name|BytesRef
name|getCommonSuffixBytesRef
parameter_list|(
name|Automaton
name|a
parameter_list|,
name|int
name|maxDeterminizedStates
parameter_list|)
block|{
comment|// reverse the language of the automaton, then reverse its common prefix.
name|Automaton
name|r
init|=
name|Operations
operator|.
name|determinize
argument_list|(
name|reverse
argument_list|(
name|a
argument_list|)
argument_list|,
name|maxDeterminizedStates
argument_list|)
decl_stmt|;
name|BytesRef
name|ref
init|=
name|getCommonPrefixBytesRef
argument_list|(
name|r
argument_list|)
decl_stmt|;
name|reverseBytes
argument_list|(
name|ref
argument_list|)
expr_stmt|;
return|return
name|ref
return|;
block|}
DECL|method|reverseBytes
specifier|private
specifier|static
name|void
name|reverseBytes
parameter_list|(
name|BytesRef
name|ref
parameter_list|)
block|{
if|if
condition|(
name|ref
operator|.
name|length
operator|<=
literal|1
condition|)
return|return;
name|int
name|num
init|=
name|ref
operator|.
name|length
operator|>>
literal|1
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|ref
operator|.
name|offset
init|;
name|i
operator|<
operator|(
name|ref
operator|.
name|offset
operator|+
name|num
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|byte
name|b
init|=
name|ref
operator|.
name|bytes
index|[
name|i
index|]
decl_stmt|;
name|ref
operator|.
name|bytes
index|[
name|i
index|]
operator|=
name|ref
operator|.
name|bytes
index|[
name|ref
operator|.
name|offset
operator|*
literal|2
operator|+
name|ref
operator|.
name|length
operator|-
name|i
operator|-
literal|1
index|]
expr_stmt|;
name|ref
operator|.
name|bytes
index|[
name|ref
operator|.
name|offset
operator|*
literal|2
operator|+
name|ref
operator|.
name|length
operator|-
name|i
operator|-
literal|1
index|]
operator|=
name|b
expr_stmt|;
block|}
block|}
comment|/** Returns an automaton accepting the reverse language. */
DECL|method|reverse
specifier|public
specifier|static
name|Automaton
name|reverse
parameter_list|(
name|Automaton
name|a
parameter_list|)
block|{
return|return
name|reverse
argument_list|(
name|a
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/** Reverses the automaton, returning the new initial states. */
DECL|method|reverse
specifier|static
name|Automaton
name|reverse
parameter_list|(
name|Automaton
name|a
parameter_list|,
name|Set
argument_list|<
name|Integer
argument_list|>
name|initialStates
parameter_list|)
block|{
if|if
condition|(
name|Operations
operator|.
name|isEmpty
argument_list|(
name|a
argument_list|)
condition|)
block|{
return|return
operator|new
name|Automaton
argument_list|()
return|;
block|}
name|int
name|numStates
init|=
name|a
operator|.
name|getNumStates
argument_list|()
decl_stmt|;
comment|// Build a new automaton with all edges reversed
name|Automaton
operator|.
name|Builder
name|builder
init|=
operator|new
name|Automaton
operator|.
name|Builder
argument_list|()
decl_stmt|;
comment|// Initial node; we'll add epsilon transitions in the end:
name|builder
operator|.
name|createState
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|s
init|=
literal|0
init|;
name|s
operator|<
name|numStates
condition|;
name|s
operator|++
control|)
block|{
name|builder
operator|.
name|createState
argument_list|()
expr_stmt|;
block|}
comment|// Old initial state becomes new accept state:
name|builder
operator|.
name|setAccept
argument_list|(
literal|1
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|Transition
name|t
init|=
operator|new
name|Transition
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|s
init|=
literal|0
init|;
name|s
operator|<
name|numStates
condition|;
name|s
operator|++
control|)
block|{
name|int
name|numTransitions
init|=
name|a
operator|.
name|getNumTransitions
argument_list|(
name|s
argument_list|)
decl_stmt|;
name|a
operator|.
name|initTransition
argument_list|(
name|s
argument_list|,
name|t
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numTransitions
condition|;
name|i
operator|++
control|)
block|{
name|a
operator|.
name|getNextTransition
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|builder
operator|.
name|addTransition
argument_list|(
name|t
operator|.
name|dest
operator|+
literal|1
argument_list|,
name|s
operator|+
literal|1
argument_list|,
name|t
operator|.
name|min
argument_list|,
name|t
operator|.
name|max
argument_list|)
expr_stmt|;
block|}
block|}
name|Automaton
name|result
init|=
name|builder
operator|.
name|finish
argument_list|()
decl_stmt|;
name|int
name|s
init|=
literal|0
decl_stmt|;
name|BitSet
name|acceptStates
init|=
name|a
operator|.
name|getAcceptStates
argument_list|()
decl_stmt|;
while|while
condition|(
name|s
operator|<
name|numStates
operator|&&
operator|(
name|s
operator|=
name|acceptStates
operator|.
name|nextSetBit
argument_list|(
name|s
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|result
operator|.
name|addEpsilon
argument_list|(
literal|0
argument_list|,
name|s
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|initialStates
operator|!=
literal|null
condition|)
block|{
name|initialStates
operator|.
name|add
argument_list|(
name|s
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
name|s
operator|++
expr_stmt|;
block|}
name|result
operator|.
name|finishState
argument_list|()
expr_stmt|;
return|return
name|result
return|;
block|}
comment|/** Returns a new automaton accepting the same language with added    *  transitions to a dead state so that from every state and every label    *  there is a transition. */
DECL|method|totalize
specifier|static
name|Automaton
name|totalize
parameter_list|(
name|Automaton
name|a
parameter_list|)
block|{
name|Automaton
name|result
init|=
operator|new
name|Automaton
argument_list|()
decl_stmt|;
name|int
name|numStates
init|=
name|a
operator|.
name|getNumStates
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numStates
condition|;
name|i
operator|++
control|)
block|{
name|result
operator|.
name|createState
argument_list|()
expr_stmt|;
name|result
operator|.
name|setAccept
argument_list|(
name|i
argument_list|,
name|a
operator|.
name|isAccept
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|int
name|deadState
init|=
name|result
operator|.
name|createState
argument_list|()
decl_stmt|;
name|result
operator|.
name|addTransition
argument_list|(
name|deadState
argument_list|,
name|deadState
argument_list|,
name|Character
operator|.
name|MIN_CODE_POINT
argument_list|,
name|Character
operator|.
name|MAX_CODE_POINT
argument_list|)
expr_stmt|;
name|Transition
name|t
init|=
operator|new
name|Transition
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numStates
condition|;
name|i
operator|++
control|)
block|{
name|int
name|maxi
init|=
name|Character
operator|.
name|MIN_CODE_POINT
decl_stmt|;
name|int
name|count
init|=
name|a
operator|.
name|initTransition
argument_list|(
name|i
argument_list|,
name|t
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|count
condition|;
name|j
operator|++
control|)
block|{
name|a
operator|.
name|getNextTransition
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|result
operator|.
name|addTransition
argument_list|(
name|i
argument_list|,
name|t
operator|.
name|dest
argument_list|,
name|t
operator|.
name|min
argument_list|,
name|t
operator|.
name|max
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|.
name|min
operator|>
name|maxi
condition|)
block|{
name|result
operator|.
name|addTransition
argument_list|(
name|i
argument_list|,
name|deadState
argument_list|,
name|maxi
argument_list|,
name|t
operator|.
name|min
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|t
operator|.
name|max
operator|+
literal|1
operator|>
name|maxi
condition|)
block|{
name|maxi
operator|=
name|t
operator|.
name|max
operator|+
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|maxi
operator|<=
name|Character
operator|.
name|MAX_CODE_POINT
condition|)
block|{
name|result
operator|.
name|addTransition
argument_list|(
name|i
argument_list|,
name|deadState
argument_list|,
name|maxi
argument_list|,
name|Character
operator|.
name|MAX_CODE_POINT
argument_list|)
expr_stmt|;
block|}
block|}
name|result
operator|.
name|finishState
argument_list|()
expr_stmt|;
return|return
name|result
return|;
block|}
comment|/** Returns the topological sort of all states reachable from    *  the initial state.  Behavior is undefined if this    *  automaton has cycles.  CPU cost is O(numTransitions),    *  and the implementation is recursive so an automaton    *  matching long strings may exhaust the java stack. */
DECL|method|topoSortStates
specifier|public
specifier|static
name|int
index|[]
name|topoSortStates
parameter_list|(
name|Automaton
name|a
parameter_list|)
block|{
if|if
condition|(
name|a
operator|.
name|getNumStates
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
operator|new
name|int
index|[
literal|0
index|]
return|;
block|}
name|int
name|numStates
init|=
name|a
operator|.
name|getNumStates
argument_list|()
decl_stmt|;
name|int
index|[]
name|states
init|=
operator|new
name|int
index|[
name|numStates
index|]
decl_stmt|;
specifier|final
name|BitSet
name|visited
init|=
operator|new
name|BitSet
argument_list|(
name|numStates
argument_list|)
decl_stmt|;
name|int
name|upto
init|=
name|topoSortStatesRecurse
argument_list|(
name|a
argument_list|,
name|visited
argument_list|,
name|states
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|upto
operator|<
name|states
operator|.
name|length
condition|)
block|{
comment|// There were dead states
name|int
index|[]
name|newStates
init|=
operator|new
name|int
index|[
name|upto
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|states
argument_list|,
literal|0
argument_list|,
name|newStates
argument_list|,
literal|0
argument_list|,
name|upto
argument_list|)
expr_stmt|;
name|states
operator|=
name|newStates
expr_stmt|;
block|}
comment|// Reverse the order:
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|states
operator|.
name|length
operator|/
literal|2
condition|;
name|i
operator|++
control|)
block|{
name|int
name|s
init|=
name|states
index|[
name|i
index|]
decl_stmt|;
name|states
index|[
name|i
index|]
operator|=
name|states
index|[
name|states
operator|.
name|length
operator|-
literal|1
operator|-
name|i
index|]
expr_stmt|;
name|states
index|[
name|states
operator|.
name|length
operator|-
literal|1
operator|-
name|i
index|]
operator|=
name|s
expr_stmt|;
block|}
return|return
name|states
return|;
block|}
DECL|method|topoSortStatesRecurse
specifier|private
specifier|static
name|int
name|topoSortStatesRecurse
parameter_list|(
name|Automaton
name|a
parameter_list|,
name|BitSet
name|visited
parameter_list|,
name|int
index|[]
name|states
parameter_list|,
name|int
name|upto
parameter_list|,
name|int
name|state
parameter_list|)
block|{
name|Transition
name|t
init|=
operator|new
name|Transition
argument_list|()
decl_stmt|;
name|int
name|count
init|=
name|a
operator|.
name|initTransition
argument_list|(
name|state
argument_list|,
name|t
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|a
operator|.
name|getNextTransition
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|visited
operator|.
name|get
argument_list|(
name|t
operator|.
name|dest
argument_list|)
condition|)
block|{
name|visited
operator|.
name|set
argument_list|(
name|t
operator|.
name|dest
argument_list|)
expr_stmt|;
name|upto
operator|=
name|topoSortStatesRecurse
argument_list|(
name|a
argument_list|,
name|visited
argument_list|,
name|states
argument_list|,
name|upto
argument_list|,
name|t
operator|.
name|dest
argument_list|)
expr_stmt|;
block|}
block|}
name|states
index|[
name|upto
index|]
operator|=
name|state
expr_stmt|;
name|upto
operator|++
expr_stmt|;
return|return
name|upto
return|;
block|}
block|}
end_class
end_unit
