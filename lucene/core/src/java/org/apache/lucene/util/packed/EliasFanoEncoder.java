begin_unit
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_package
DECL|package|org.apache.lucene.util.packed
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|packed
package|;
end_package
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|Accountable
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|FixedBitSet
import|;
end_import
begin_comment
comment|// for javadocs
end_comment
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|RamUsageEstimator
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|ToStringUtils
import|;
end_import
begin_comment
comment|/** Encode a non decreasing sequence of non negative whole numbers in the Elias-Fano encoding  * that was introduced in the 1970's by Peter Elias and Robert Fano.  *<p>  * The Elias-Fano encoding is a high bits / low bits representation of  * a monotonically increasing sequence of<code>numValues> 0</code> natural numbers<code>x[i]</code>  *<p>  *<code>0<= x[0]<= x[1]<= ...<= x[numValues-2]<= x[numValues-1]<= upperBound</code>  *<p>  * where<code>upperBound> 0</code> is an upper bound on the last value.  *<br>  * The Elias-Fano encoding uses less than half a bit per encoded number more  * than the smallest representation  * that can encode any monotone sequence with the same bounds.  *<p>  * The lower<code>L</code> bits of each<code>x[i]</code> are stored explicitly and contiguously  * in the lower-bits array, with<code>L</code> chosen as (<code>log()</code> base 2):  *<p>  *<code>L = max(0, floor(log(upperBound/numValues)))</code>  *<p>  * The upper bits are stored in the upper-bits array as a sequence of unary-coded gaps (<code>x[-1] = 0</code>):  *<p>  *<code>(x[i]/2**L) - (x[i-1]/2**L)</code>  *<p>  * The unary code encodes a natural number<code>n</code> by<code>n</code> 0 bits followed by a 1 bit:  *<code>0...01</code>.<br>  * In the upper bits the total the number of 1 bits is<code>numValues</code>  * and the total number of 0 bits is:<p>  *<code>floor(x[numValues-1]/2**L)<= upperBound/(2**max(0, floor(log(upperBound/numValues))))<= 2*numValues</code>  *<p>  * The Elias-Fano encoding uses at most  *<p>  *<code>2 + ceil(log(upperBound/numValues))</code>  *<p>  * bits per encoded number. With<code>upperBound</code> in these bounds (<code>p</code> is an integer):  *<p>  *<code>2**p< x[numValues-1]<= upperBound<= 2**(p+1)</code>  *<p>  * the number of bits per encoded number is minimized.  *<p>  * In this implementation the values in the sequence can be given as<code>long</code>,  *<code>numValues = 0</code> and<code>upperBound = 0</code> are allowed,  * and each of the upper and lower bit arrays should fit in a<code>long[]</code>.  *<br>  * An index of positions of zero's in the upper bits is also built.  *<p>  * This implementation is based on this article:  *<br>  * Sebastiano Vigna, "Quasi Succinct Indices", June 19, 2012, sections 3, 4 and 9.  * Retrieved from http://arxiv.org/pdf/1206.4300 .  *  *<p>The articles originally describing the Elias-Fano representation are:  *<br>Peter Elias, "Efficient storage and retrieval by content and address of static files",  * J. Assoc. Comput. Mach., 21(2):246â260, 1974.  *<br>Robert M. Fano, "On the number of bits required to implement an associative memory",  *  Memorandum 61, Computer Structures Group, Project MAC, MIT, Cambridge, Mass., 1971.  *  * @lucene.internal  */
end_comment
begin_class
DECL|class|EliasFanoEncoder
specifier|public
class|class
name|EliasFanoEncoder
implements|implements
name|Accountable
block|{
DECL|field|BASE_RAM_BYTES_USED
specifier|private
specifier|static
specifier|final
name|long
name|BASE_RAM_BYTES_USED
init|=
name|RamUsageEstimator
operator|.
name|shallowSizeOfInstance
argument_list|(
name|EliasFanoEncoder
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|numValues
specifier|final
name|long
name|numValues
decl_stmt|;
DECL|field|upperBound
specifier|private
specifier|final
name|long
name|upperBound
decl_stmt|;
DECL|field|numLowBits
specifier|final
name|int
name|numLowBits
decl_stmt|;
DECL|field|lowerBitsMask
specifier|final
name|long
name|lowerBitsMask
decl_stmt|;
DECL|field|upperLongs
specifier|final
name|long
index|[]
name|upperLongs
decl_stmt|;
DECL|field|lowerLongs
specifier|final
name|long
index|[]
name|lowerLongs
decl_stmt|;
DECL|field|LOG2_LONG_SIZE
specifier|private
specifier|static
specifier|final
name|int
name|LOG2_LONG_SIZE
init|=
name|Long
operator|.
name|numberOfTrailingZeros
argument_list|(
name|Long
operator|.
name|SIZE
argument_list|)
decl_stmt|;
DECL|field|numEncoded
name|long
name|numEncoded
init|=
literal|0L
decl_stmt|;
DECL|field|lastEncoded
name|long
name|lastEncoded
init|=
literal|0L
decl_stmt|;
comment|/** The default index interval for zero upper bits. */
DECL|field|DEFAULT_INDEX_INTERVAL
specifier|public
specifier|static
specifier|final
name|long
name|DEFAULT_INDEX_INTERVAL
init|=
literal|256
decl_stmt|;
DECL|field|numIndexEntries
specifier|final
name|long
name|numIndexEntries
decl_stmt|;
DECL|field|indexInterval
specifier|final
name|long
name|indexInterval
decl_stmt|;
DECL|field|nIndexEntryBits
specifier|final
name|int
name|nIndexEntryBits
decl_stmt|;
comment|/** upperZeroBitPositionIndex[i] (filled using packValue) will contain the bit position    *  just after the zero bit ((i+1) * indexInterval) in the upper bits.    */
DECL|field|upperZeroBitPositionIndex
specifier|final
name|long
index|[]
name|upperZeroBitPositionIndex
decl_stmt|;
DECL|field|currentEntryIndex
name|long
name|currentEntryIndex
decl_stmt|;
comment|// also indicates how many entries in the index are valid.
comment|/**    * Construct an Elias-Fano encoder.    * After construction, call {@link #encodeNext}<code>numValues</code> times to encode    * a non decreasing sequence of non negative numbers.    * @param numValues The number of values that is to be encoded.    * @param upperBound  At least the highest value that will be encoded.    *                For space efficiency this should not exceed the power of two that equals    *                or is the first higher than the actual maximum.    *<br>When<code>numValues>= (upperBound/3)</code>    *                a {@link FixedBitSet} will take less space.    * @param indexInterval The number of high zero bits for which a single index entry is built.    *                The index will have at most<code>2 * numValues / indexInterval</code> entries    *                and each index entry will use at most<code>ceil(log2(3 * numValues))</code> bits,    *                see {@link EliasFanoEncoder}.    * @throws IllegalArgumentException when:    *<ul>    *<li><code>numValues</code> is negative, or    *<li><code>numValues</code> is non negative and<code>upperBound</code> is negative, or    *<li>the low bits do not fit in a<code>long[]</code>:    *<code>(L * numValues / 64)> Integer.MAX_VALUE</code>, or    *<li>the high bits do not fit in a<code>long[]</code>:    *<code>(2 * numValues / 64)> Integer.MAX_VALUE</code>, or    *<li><code>indexInterval< 2</code>,    *<li>the index bits do not fit in a<code>long[]</code>:    *<code>(numValues / indexInterval * ceil(2log(3 * numValues)) / 64)> Integer.MAX_VALUE</code>.    *</ul>    */
DECL|method|EliasFanoEncoder
specifier|public
name|EliasFanoEncoder
parameter_list|(
name|long
name|numValues
parameter_list|,
name|long
name|upperBound
parameter_list|,
name|long
name|indexInterval
parameter_list|)
block|{
if|if
condition|(
name|numValues
operator|<
literal|0L
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"numValues should not be negative: "
operator|+
name|numValues
argument_list|)
throw|;
block|}
name|this
operator|.
name|numValues
operator|=
name|numValues
expr_stmt|;
if|if
condition|(
operator|(
name|numValues
operator|>
literal|0L
operator|)
operator|&&
operator|(
name|upperBound
operator|<
literal|0L
operator|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"upperBound should not be negative: "
operator|+
name|upperBound
operator|+
literal|" when numValues> 0"
argument_list|)
throw|;
block|}
name|this
operator|.
name|upperBound
operator|=
name|numValues
operator|>
literal|0
condition|?
name|upperBound
else|:
operator|-
literal|1L
expr_stmt|;
comment|// if there is no value, -1 is the best upper bound
name|int
name|nLowBits
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|this
operator|.
name|numValues
operator|>
literal|0
condition|)
block|{
comment|// nLowBits = max(0; floor(2log(upperBound/numValues)))
name|long
name|lowBitsFac
init|=
name|this
operator|.
name|upperBound
operator|/
name|this
operator|.
name|numValues
decl_stmt|;
if|if
condition|(
name|lowBitsFac
operator|>
literal|0
condition|)
block|{
name|nLowBits
operator|=
literal|63
operator|-
name|Long
operator|.
name|numberOfLeadingZeros
argument_list|(
name|lowBitsFac
argument_list|)
expr_stmt|;
comment|// see Long.numberOfLeadingZeros javadocs
block|}
block|}
name|this
operator|.
name|numLowBits
operator|=
name|nLowBits
expr_stmt|;
name|this
operator|.
name|lowerBitsMask
operator|=
name|Long
operator|.
name|MAX_VALUE
operator|>>>
operator|(
name|Long
operator|.
name|SIZE
operator|-
literal|1
operator|-
name|this
operator|.
name|numLowBits
operator|)
expr_stmt|;
name|long
name|numLongsForLowBits
init|=
name|numLongsForBits
argument_list|(
name|numValues
operator|*
name|numLowBits
argument_list|)
decl_stmt|;
if|if
condition|(
name|numLongsForLowBits
operator|>
name|Integer
operator|.
name|MAX_VALUE
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"numLongsForLowBits too large to index a long array: "
operator|+
name|numLongsForLowBits
argument_list|)
throw|;
block|}
name|this
operator|.
name|lowerLongs
operator|=
operator|new
name|long
index|[
operator|(
name|int
operator|)
name|numLongsForLowBits
index|]
expr_stmt|;
name|long
name|numHighBitsClear
init|=
operator|(
operator|(
name|this
operator|.
name|upperBound
operator|>
literal|0
operator|)
condition|?
name|this
operator|.
name|upperBound
else|:
literal|0
operator|)
operator|>>>
name|this
operator|.
name|numLowBits
decl_stmt|;
assert|assert
name|numHighBitsClear
operator|<=
operator|(
literal|2
operator|*
name|this
operator|.
name|numValues
operator|)
assert|;
name|long
name|numHighBitsSet
init|=
name|this
operator|.
name|numValues
decl_stmt|;
name|long
name|numLongsForHighBits
init|=
name|numLongsForBits
argument_list|(
name|numHighBitsClear
operator|+
name|numHighBitsSet
argument_list|)
decl_stmt|;
if|if
condition|(
name|numLongsForHighBits
operator|>
name|Integer
operator|.
name|MAX_VALUE
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"numLongsForHighBits too large to index a long array: "
operator|+
name|numLongsForHighBits
argument_list|)
throw|;
block|}
name|this
operator|.
name|upperLongs
operator|=
operator|new
name|long
index|[
operator|(
name|int
operator|)
name|numLongsForHighBits
index|]
expr_stmt|;
if|if
condition|(
name|indexInterval
operator|<
literal|2
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"indexInterval should at least 2: "
operator|+
name|indexInterval
argument_list|)
throw|;
block|}
comment|// For the index:
name|long
name|maxHighValue
init|=
name|upperBound
operator|>>>
name|this
operator|.
name|numLowBits
decl_stmt|;
name|long
name|nIndexEntries
init|=
name|maxHighValue
operator|/
name|indexInterval
decl_stmt|;
comment|// no zero value index entry
name|this
operator|.
name|numIndexEntries
operator|=
operator|(
name|nIndexEntries
operator|>=
literal|0
operator|)
condition|?
name|nIndexEntries
else|:
literal|0
expr_stmt|;
name|long
name|maxIndexEntry
init|=
name|maxHighValue
operator|+
name|numValues
operator|-
literal|1
decl_stmt|;
comment|// clear upper bits, set upper bits, start at zero
name|this
operator|.
name|nIndexEntryBits
operator|=
operator|(
name|maxIndexEntry
operator|<=
literal|0
operator|)
condition|?
literal|0
else|:
operator|(
literal|64
operator|-
name|Long
operator|.
name|numberOfLeadingZeros
argument_list|(
name|maxIndexEntry
argument_list|)
operator|)
expr_stmt|;
name|long
name|numLongsForIndexBits
init|=
name|numLongsForBits
argument_list|(
name|numIndexEntries
operator|*
name|nIndexEntryBits
argument_list|)
decl_stmt|;
if|if
condition|(
name|numLongsForIndexBits
operator|>
name|Integer
operator|.
name|MAX_VALUE
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"numLongsForIndexBits too large to index a long array: "
operator|+
name|numLongsForIndexBits
argument_list|)
throw|;
block|}
name|this
operator|.
name|upperZeroBitPositionIndex
operator|=
operator|new
name|long
index|[
operator|(
name|int
operator|)
name|numLongsForIndexBits
index|]
expr_stmt|;
name|this
operator|.
name|currentEntryIndex
operator|=
literal|0
expr_stmt|;
name|this
operator|.
name|indexInterval
operator|=
name|indexInterval
expr_stmt|;
block|}
comment|/**   * Construct an Elias-Fano encoder using {@link #DEFAULT_INDEX_INTERVAL}.   */
DECL|method|EliasFanoEncoder
specifier|public
name|EliasFanoEncoder
parameter_list|(
name|long
name|numValues
parameter_list|,
name|long
name|upperBound
parameter_list|)
block|{
name|this
argument_list|(
name|numValues
argument_list|,
name|upperBound
argument_list|,
name|DEFAULT_INDEX_INTERVAL
argument_list|)
expr_stmt|;
block|}
DECL|method|numLongsForBits
specifier|private
specifier|static
name|long
name|numLongsForBits
parameter_list|(
name|long
name|numBits
parameter_list|)
block|{
comment|// Note: int version in FixedBitSet.bits2words()
assert|assert
name|numBits
operator|>=
literal|0
operator|:
name|numBits
assert|;
return|return
operator|(
name|numBits
operator|+
operator|(
name|Long
operator|.
name|SIZE
operator|-
literal|1
operator|)
operator|)
operator|>>>
name|LOG2_LONG_SIZE
return|;
block|}
comment|/** Call at most<code>numValues</code> times to encode a non decreasing sequence of non negative numbers.    * @param x The next number to be encoded.    * @throws IllegalStateException when called more than<code>numValues</code> times.    * @throws IllegalArgumentException when:    *<ul>    *<li><code>x</code> is smaller than an earlier encoded value, or    *<li><code>x</code> is larger than<code>upperBound</code>.    *</ul>    */
DECL|method|encodeNext
specifier|public
name|void
name|encodeNext
parameter_list|(
name|long
name|x
parameter_list|)
block|{
if|if
condition|(
name|numEncoded
operator|>=
name|numValues
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"encodeNext called more than "
operator|+
name|numValues
operator|+
literal|" times."
argument_list|)
throw|;
block|}
if|if
condition|(
name|lastEncoded
operator|>
name|x
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
name|x
operator|+
literal|" smaller than previous "
operator|+
name|lastEncoded
argument_list|)
throw|;
block|}
if|if
condition|(
name|x
operator|>
name|upperBound
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
name|x
operator|+
literal|" larger than upperBound "
operator|+
name|upperBound
argument_list|)
throw|;
block|}
name|long
name|highValue
init|=
name|x
operator|>>>
name|numLowBits
decl_stmt|;
name|encodeUpperBits
argument_list|(
name|highValue
argument_list|)
expr_stmt|;
name|encodeLowerBits
argument_list|(
name|x
operator|&
name|lowerBitsMask
argument_list|)
expr_stmt|;
name|lastEncoded
operator|=
name|x
expr_stmt|;
comment|// Add index entries:
name|long
name|indexValue
init|=
operator|(
name|currentEntryIndex
operator|+
literal|1
operator|)
operator|*
name|indexInterval
decl_stmt|;
while|while
condition|(
name|indexValue
operator|<=
name|highValue
condition|)
block|{
name|long
name|afterZeroBitPosition
init|=
name|indexValue
operator|+
name|numEncoded
decl_stmt|;
name|packValue
argument_list|(
name|afterZeroBitPosition
argument_list|,
name|upperZeroBitPositionIndex
argument_list|,
name|nIndexEntryBits
argument_list|,
name|currentEntryIndex
argument_list|)
expr_stmt|;
name|currentEntryIndex
operator|+=
literal|1
expr_stmt|;
name|indexValue
operator|+=
name|indexInterval
expr_stmt|;
block|}
name|numEncoded
operator|++
expr_stmt|;
block|}
DECL|method|encodeUpperBits
specifier|private
name|void
name|encodeUpperBits
parameter_list|(
name|long
name|highValue
parameter_list|)
block|{
name|long
name|nextHighBitNum
init|=
name|numEncoded
operator|+
name|highValue
decl_stmt|;
comment|// sequence of unary gaps
name|upperLongs
index|[
call|(
name|int
call|)
argument_list|(
name|nextHighBitNum
operator|>>>
name|LOG2_LONG_SIZE
argument_list|)
index|]
operator||=
operator|(
literal|1L
operator|<<
operator|(
name|nextHighBitNum
operator|&
operator|(
name|Long
operator|.
name|SIZE
operator|-
literal|1
operator|)
operator|)
operator|)
expr_stmt|;
block|}
DECL|method|encodeLowerBits
specifier|private
name|void
name|encodeLowerBits
parameter_list|(
name|long
name|lowValue
parameter_list|)
block|{
name|packValue
argument_list|(
name|lowValue
argument_list|,
name|lowerLongs
argument_list|,
name|numLowBits
argument_list|,
name|numEncoded
argument_list|)
expr_stmt|;
block|}
DECL|method|packValue
specifier|private
specifier|static
name|void
name|packValue
parameter_list|(
name|long
name|value
parameter_list|,
name|long
index|[]
name|longArray
parameter_list|,
name|int
name|numBits
parameter_list|,
name|long
name|packIndex
parameter_list|)
block|{
if|if
condition|(
name|numBits
operator|!=
literal|0
condition|)
block|{
name|long
name|bitPos
init|=
name|numBits
operator|*
name|packIndex
decl_stmt|;
name|int
name|index
init|=
call|(
name|int
call|)
argument_list|(
name|bitPos
operator|>>>
name|LOG2_LONG_SIZE
argument_list|)
decl_stmt|;
name|int
name|bitPosAtIndex
init|=
call|(
name|int
call|)
argument_list|(
name|bitPos
operator|&
operator|(
name|Long
operator|.
name|SIZE
operator|-
literal|1
operator|)
argument_list|)
decl_stmt|;
name|longArray
index|[
name|index
index|]
operator||=
operator|(
name|value
operator|<<
name|bitPosAtIndex
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|bitPosAtIndex
operator|+
name|numBits
operator|)
operator|>
name|Long
operator|.
name|SIZE
condition|)
block|{
name|longArray
index|[
name|index
operator|+
literal|1
index|]
operator|=
operator|(
name|value
operator|>>>
operator|(
name|Long
operator|.
name|SIZE
operator|-
name|bitPosAtIndex
operator|)
operator|)
expr_stmt|;
block|}
block|}
block|}
comment|/** Provide an indication that it is better to use an {@link EliasFanoEncoder} than a {@link FixedBitSet}    *  to encode document identifiers.    *  This indication is not precise and may change in the future.    *<br>An EliasFanoEncoder is favoured when the size of the encoding by the EliasFanoEncoder    *  (including some space for its index) is at most about 5/6 of the size of the FixedBitSet,    *  this is the same as comparing estimates of the number of bits accessed by a pair of FixedBitSets and    *  by a pair of non indexed EliasFanoDocIdSets when determining the intersections of the pairs.    *<br>A bit set is preferred when<code>upperbound<= 256</code>.    *<br>It is assumed that {@link #DEFAULT_INDEX_INTERVAL} is used.    *  @param numValues The number of document identifiers that is to be encoded. Should be non negative.    *  @param upperBound The maximum possible value for a document identifier. Should be at least<code>numValues</code>.    */
DECL|method|sufficientlySmallerThanBitSet
specifier|public
specifier|static
name|boolean
name|sufficientlySmallerThanBitSet
parameter_list|(
name|long
name|numValues
parameter_list|,
name|long
name|upperBound
parameter_list|)
block|{
comment|/* When (upperBound / 6) == numValues,      * the number of bits per entry for the EliasFanoEncoder is 2 + ceil(2log(upperBound/numValues)) == 5.      *      * For intersecting two bit sets upperBound bits are accessed, roughly half of one, half of the other.      * For intersecting two EliasFano sequences without index on the upper bits,      * all (2 * 3 * numValues) upper bits are accessed.      */
return|return
operator|(
name|upperBound
operator|>
operator|(
literal|4
operator|*
name|Long
operator|.
name|SIZE
operator|)
operator|)
comment|// prefer a bit set when it takes no more than 4 longs.
operator|&&
operator|(
name|upperBound
operator|/
literal|7
operator|)
operator|>
name|numValues
return|;
comment|// 6 + 1 to allow some room for the index.
block|}
comment|/**    * Returns an {@link EliasFanoDecoder} to access the encoded values.    * Perform all calls to {@link #encodeNext} before calling {@link #getDecoder}.    */
DECL|method|getDecoder
specifier|public
name|EliasFanoDecoder
name|getDecoder
parameter_list|()
block|{
comment|// decode as far as currently encoded as determined by numEncoded.
return|return
operator|new
name|EliasFanoDecoder
argument_list|(
name|this
argument_list|)
return|;
block|}
comment|/** Expert. The low bits. */
DECL|method|getLowerBits
specifier|public
name|long
index|[]
name|getLowerBits
parameter_list|()
block|{
return|return
name|lowerLongs
return|;
block|}
comment|/** Expert. The high bits. */
DECL|method|getUpperBits
specifier|public
name|long
index|[]
name|getUpperBits
parameter_list|()
block|{
return|return
name|upperLongs
return|;
block|}
comment|/** Expert. The index bits. */
DECL|method|getIndexBits
specifier|public
name|long
index|[]
name|getIndexBits
parameter_list|()
block|{
return|return
name|upperZeroBitPositionIndex
return|;
block|}
annotation|@
name|Override
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
name|StringBuilder
name|s
init|=
operator|new
name|StringBuilder
argument_list|(
literal|"EliasFanoSequence"
argument_list|)
decl_stmt|;
name|s
operator|.
name|append
argument_list|(
literal|" numValues "
operator|+
name|numValues
argument_list|)
expr_stmt|;
name|s
operator|.
name|append
argument_list|(
literal|" numEncoded "
operator|+
name|numEncoded
argument_list|)
expr_stmt|;
name|s
operator|.
name|append
argument_list|(
literal|" upperBound "
operator|+
name|upperBound
argument_list|)
expr_stmt|;
name|s
operator|.
name|append
argument_list|(
literal|" lastEncoded "
operator|+
name|lastEncoded
argument_list|)
expr_stmt|;
name|s
operator|.
name|append
argument_list|(
literal|" numLowBits "
operator|+
name|numLowBits
argument_list|)
expr_stmt|;
name|s
operator|.
name|append
argument_list|(
literal|"\nupperLongs["
operator|+
name|upperLongs
operator|.
name|length
operator|+
literal|"]"
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|upperLongs
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|s
operator|.
name|append
argument_list|(
literal|" "
operator|+
name|ToStringUtils
operator|.
name|longHex
argument_list|(
name|upperLongs
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|s
operator|.
name|append
argument_list|(
literal|"\nlowerLongs["
operator|+
name|lowerLongs
operator|.
name|length
operator|+
literal|"]"
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|lowerLongs
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|s
operator|.
name|append
argument_list|(
literal|" "
operator|+
name|ToStringUtils
operator|.
name|longHex
argument_list|(
name|lowerLongs
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|s
operator|.
name|append
argument_list|(
literal|"\nindexInterval: "
operator|+
name|indexInterval
operator|+
literal|", nIndexEntryBits: "
operator|+
name|nIndexEntryBits
argument_list|)
expr_stmt|;
name|s
operator|.
name|append
argument_list|(
literal|"\nupperZeroBitPositionIndex["
operator|+
name|upperZeroBitPositionIndex
operator|.
name|length
operator|+
literal|"]"
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|upperZeroBitPositionIndex
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|s
operator|.
name|append
argument_list|(
literal|" "
operator|+
name|ToStringUtils
operator|.
name|longHex
argument_list|(
name|upperZeroBitPositionIndex
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|s
operator|.
name|toString
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|equals
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|other
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|other
operator|instanceof
name|EliasFanoEncoder
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|EliasFanoEncoder
name|oefs
init|=
operator|(
name|EliasFanoEncoder
operator|)
name|other
decl_stmt|;
comment|// no equality needed for upperBound
return|return
operator|(
name|this
operator|.
name|numValues
operator|==
name|oefs
operator|.
name|numValues
operator|)
operator|&&
operator|(
name|this
operator|.
name|numEncoded
operator|==
name|oefs
operator|.
name|numEncoded
operator|)
operator|&&
operator|(
name|this
operator|.
name|numLowBits
operator|==
name|oefs
operator|.
name|numLowBits
operator|)
operator|&&
operator|(
name|this
operator|.
name|numIndexEntries
operator|==
name|oefs
operator|.
name|numIndexEntries
operator|)
operator|&&
operator|(
name|this
operator|.
name|indexInterval
operator|==
name|oefs
operator|.
name|indexInterval
operator|)
comment|// no need to check index content
operator|&&
name|Arrays
operator|.
name|equals
argument_list|(
name|this
operator|.
name|upperLongs
argument_list|,
name|oefs
operator|.
name|upperLongs
argument_list|)
operator|&&
name|Arrays
operator|.
name|equals
argument_list|(
name|this
operator|.
name|lowerLongs
argument_list|,
name|oefs
operator|.
name|lowerLongs
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|hashCode
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
name|int
name|h
init|=
operator|(
call|(
name|int
call|)
argument_list|(
literal|31
operator|*
operator|(
name|numValues
operator|+
literal|7
operator|*
operator|(
name|numEncoded
operator|+
literal|5
operator|*
operator|(
name|numLowBits
operator|+
literal|3
operator|*
operator|(
name|numIndexEntries
operator|+
literal|11
operator|*
name|indexInterval
operator|)
operator|)
operator|)
operator|)
argument_list|)
operator|)
operator|^
name|Arrays
operator|.
name|hashCode
argument_list|(
name|upperLongs
argument_list|)
operator|^
name|Arrays
operator|.
name|hashCode
argument_list|(
name|lowerLongs
argument_list|)
decl_stmt|;
return|return
name|h
return|;
block|}
annotation|@
name|Override
DECL|method|ramBytesUsed
specifier|public
name|long
name|ramBytesUsed
parameter_list|()
block|{
return|return
name|BASE_RAM_BYTES_USED
operator|+
name|RamUsageEstimator
operator|.
name|sizeOf
argument_list|(
name|lowerLongs
argument_list|)
operator|+
name|RamUsageEstimator
operator|.
name|sizeOf
argument_list|(
name|upperLongs
argument_list|)
operator|+
name|RamUsageEstimator
operator|.
name|sizeOf
argument_list|(
name|upperZeroBitPositionIndex
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|getChildResources
specifier|public
name|Iterable
argument_list|<
name|?
extends|extends
name|Accountable
argument_list|>
name|getChildResources
parameter_list|()
block|{
return|return
name|Collections
operator|.
name|emptyList
argument_list|()
return|;
block|}
block|}
end_class
end_unit
