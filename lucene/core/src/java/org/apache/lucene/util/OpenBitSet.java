begin_unit
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_package
DECL|package|org.apache.lucene.util
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
package|;
end_package
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|DocIdSet
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|DocIdSetIterator
import|;
end_import
begin_comment
comment|/** An "open" BitSet implementation that allows direct access to the array of words  * storing the bits.  *<p/>  * Unlike java.util.bitset, the fact that bits are packed into an array of longs  * is part of the interface.  This allows efficient implementation of other algorithms  * by someone other than the author.  It also allows one to efficiently implement  * alternate serialization or interchange formats.  *<p/>  *<code>OpenBitSet</code> is faster than<code>java.util.BitSet</code> in most operations  * and *much* faster at calculating cardinality of sets and results of set operations.  * It can also handle sets of larger cardinality (up to 64 * 2**32-1)  *<p/>  * The goals of<code>OpenBitSet</code> are the fastest implementation possible, and  * maximum code reuse.  Extra safety and encapsulation  * may always be built on top, but if that's built in, the cost can never be removed (and  * hence people re-implement their own version in order to get better performance).  * If you want a "safe", totally encapsulated (and slower and limited) BitSet  * class, use<code>java.util.BitSet</code>.  *<p/>  *<h3>Performance Results</h3>  *  Test system: Pentium 4, Sun Java 1.5_06 -server -Xbatch -Xmx64M<br/>BitSet size = 1,000,000<br/>Results are java.util.BitSet time divided by OpenBitSet time.<table border="1"><tr><th></th><th>cardinality</th><th>intersect_count</th><th>union</th><th>nextSetBit</th><th>get</th><th>iterator</th></tr><tr><th>50% full</th><td>3.36</td><td>3.96</td><td>1.44</td><td>1.46</td><td>1.99</td><td>1.58</td></tr><tr><th>1% full</th><td>3.31</td><td>3.90</td><td>&nbsp;</td><td>1.04</td><td>&nbsp;</td><td>0.99</td></tr></table><br/> Test system: AMD Opteron, 64 bit linux, Sun Java 1.5_06 -server -Xbatch -Xmx64M<br/>BitSet size = 1,000,000<br/>Results are java.util.BitSet time divided by OpenBitSet time.<table border="1"><tr><th></th><th>cardinality</th><th>intersect_count</th><th>union</th><th>nextSetBit</th><th>get</th><th>iterator</th></tr><tr><th>50% full</th><td>2.50</td><td>3.50</td><td>1.00</td><td>1.03</td><td>1.12</td><td>1.25</td></tr><tr><th>1% full</th><td>2.51</td><td>3.49</td><td>&nbsp;</td><td>1.00</td><td>&nbsp;</td><td>1.02</td></tr></table>  */
end_comment
begin_class
DECL|class|OpenBitSet
specifier|public
class|class
name|OpenBitSet
extends|extends
name|DocIdSet
implements|implements
name|Bits
implements|,
name|Cloneable
block|{
DECL|field|bits
specifier|protected
name|long
index|[]
name|bits
decl_stmt|;
DECL|field|wlen
specifier|protected
name|int
name|wlen
decl_stmt|;
comment|// number of words (elements) used in the array
comment|// Used only for assert:
DECL|field|numBits
specifier|private
name|long
name|numBits
decl_stmt|;
comment|/** Constructs an OpenBitSet large enough to hold {@code numBits}. */
DECL|method|OpenBitSet
specifier|public
name|OpenBitSet
parameter_list|(
name|long
name|numBits
parameter_list|)
block|{
name|this
operator|.
name|numBits
operator|=
name|numBits
expr_stmt|;
name|bits
operator|=
operator|new
name|long
index|[
name|bits2words
argument_list|(
name|numBits
argument_list|)
index|]
expr_stmt|;
name|wlen
operator|=
name|bits
operator|.
name|length
expr_stmt|;
block|}
comment|/** Constructor: allocates enough space for 64 bits. */
DECL|method|OpenBitSet
specifier|public
name|OpenBitSet
parameter_list|()
block|{
name|this
argument_list|(
literal|64
argument_list|)
expr_stmt|;
block|}
comment|/**    * Constructs an OpenBitSet from an existing long[].    *<p>    * The first 64 bits are in long[0], with bit index 0 at the least significant    * bit, and bit index 63 at the most significant. Given a bit index, the word    * containing it is long[index/64], and it is at bit number index%64 within    * that word.    *<p>    * numWords are the number of elements in the array that contain set bits    * (non-zero longs). numWords should be&lt= bits.length, and any existing    * words in the array at position&gt= numWords should be zero.    *     */
DECL|method|OpenBitSet
specifier|public
name|OpenBitSet
parameter_list|(
name|long
index|[]
name|bits
parameter_list|,
name|int
name|numWords
parameter_list|)
block|{
if|if
condition|(
name|numWords
operator|>
name|bits
operator|.
name|length
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"numWords cannot exceed bits.length"
argument_list|)
throw|;
block|}
name|this
operator|.
name|bits
operator|=
name|bits
expr_stmt|;
name|this
operator|.
name|wlen
operator|=
name|numWords
expr_stmt|;
name|this
operator|.
name|numBits
operator|=
name|wlen
operator|*
literal|64
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|iterator
specifier|public
name|DocIdSetIterator
name|iterator
parameter_list|()
block|{
return|return
operator|new
name|OpenBitSetIterator
argument_list|(
name|bits
argument_list|,
name|wlen
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|bits
specifier|public
name|Bits
name|bits
parameter_list|()
block|{
return|return
name|this
return|;
block|}
comment|/** This DocIdSet implementation is cacheable. */
annotation|@
name|Override
DECL|method|isCacheable
specifier|public
name|boolean
name|isCacheable
parameter_list|()
block|{
return|return
literal|true
return|;
block|}
annotation|@
name|Override
DECL|method|ramBytesUsed
specifier|public
name|long
name|ramBytesUsed
parameter_list|()
block|{
return|return
name|RamUsageEstimator
operator|.
name|alignObjectSize
argument_list|(
name|RamUsageEstimator
operator|.
name|NUM_BYTES_OBJECT_REF
operator|+
name|RamUsageEstimator
operator|.
name|NUM_BYTES_LONG
operator|+
name|RamUsageEstimator
operator|.
name|NUM_BYTES_INT
argument_list|)
operator|+
name|RamUsageEstimator
operator|.
name|sizeOf
argument_list|(
name|bits
argument_list|)
return|;
block|}
comment|/** Returns the current capacity in bits (1 greater than the index of the last bit) */
DECL|method|capacity
specifier|public
name|long
name|capacity
parameter_list|()
block|{
return|return
name|bits
operator|.
name|length
operator|<<
literal|6
return|;
block|}
comment|/**   * Returns the current capacity of this set.  Included for   * compatibility.  This is *not* equal to {@link #cardinality}   */
DECL|method|size
specifier|public
name|long
name|size
parameter_list|()
block|{
return|return
name|capacity
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|length
specifier|public
name|int
name|length
parameter_list|()
block|{
return|return
name|bits
operator|.
name|length
operator|<<
literal|6
return|;
block|}
comment|/** Returns true if there are no set bits */
DECL|method|isEmpty
specifier|public
name|boolean
name|isEmpty
parameter_list|()
block|{
return|return
name|cardinality
argument_list|()
operator|==
literal|0
return|;
block|}
comment|/** Expert: returns the long[] storing the bits */
DECL|method|getBits
specifier|public
name|long
index|[]
name|getBits
parameter_list|()
block|{
return|return
name|bits
return|;
block|}
comment|/** Expert: gets the number of longs in the array that are in use */
DECL|method|getNumWords
specifier|public
name|int
name|getNumWords
parameter_list|()
block|{
return|return
name|wlen
return|;
block|}
comment|/** Returns true or false for the specified bit index. */
annotation|@
name|Override
DECL|method|get
specifier|public
name|boolean
name|get
parameter_list|(
name|int
name|index
parameter_list|)
block|{
name|int
name|i
init|=
name|index
operator|>>
literal|6
decl_stmt|;
comment|// div 64
comment|// signed shift will keep a negative index and force an
comment|// array-index-out-of-bounds-exception, removing the need for an explicit check.
if|if
condition|(
name|i
operator|>=
name|bits
operator|.
name|length
condition|)
return|return
literal|false
return|;
name|int
name|bit
init|=
name|index
operator|&
literal|0x3f
decl_stmt|;
comment|// mod 64
name|long
name|bitmask
init|=
literal|1L
operator|<<
name|bit
decl_stmt|;
return|return
operator|(
name|bits
index|[
name|i
index|]
operator|&
name|bitmask
operator|)
operator|!=
literal|0
return|;
block|}
comment|/** Returns true or false for the specified bit index.    * The index should be less than the OpenBitSet size    */
DECL|method|fastGet
specifier|public
name|boolean
name|fastGet
parameter_list|(
name|int
name|index
parameter_list|)
block|{
assert|assert
name|index
operator|>=
literal|0
operator|&&
name|index
operator|<
name|numBits
assert|;
name|int
name|i
init|=
name|index
operator|>>
literal|6
decl_stmt|;
comment|// div 64
comment|// signed shift will keep a negative index and force an
comment|// array-index-out-of-bounds-exception, removing the need for an explicit check.
name|int
name|bit
init|=
name|index
operator|&
literal|0x3f
decl_stmt|;
comment|// mod 64
name|long
name|bitmask
init|=
literal|1L
operator|<<
name|bit
decl_stmt|;
return|return
operator|(
name|bits
index|[
name|i
index|]
operator|&
name|bitmask
operator|)
operator|!=
literal|0
return|;
block|}
comment|/** Returns true or false for the specified bit index   */
DECL|method|get
specifier|public
name|boolean
name|get
parameter_list|(
name|long
name|index
parameter_list|)
block|{
name|int
name|i
init|=
call|(
name|int
call|)
argument_list|(
name|index
operator|>>
literal|6
argument_list|)
decl_stmt|;
comment|// div 64
if|if
condition|(
name|i
operator|>=
name|bits
operator|.
name|length
condition|)
return|return
literal|false
return|;
name|int
name|bit
init|=
operator|(
name|int
operator|)
name|index
operator|&
literal|0x3f
decl_stmt|;
comment|// mod 64
name|long
name|bitmask
init|=
literal|1L
operator|<<
name|bit
decl_stmt|;
return|return
operator|(
name|bits
index|[
name|i
index|]
operator|&
name|bitmask
operator|)
operator|!=
literal|0
return|;
block|}
comment|/** Returns true or false for the specified bit index.    * The index should be less than the OpenBitSet size.    */
DECL|method|fastGet
specifier|public
name|boolean
name|fastGet
parameter_list|(
name|long
name|index
parameter_list|)
block|{
assert|assert
name|index
operator|>=
literal|0
operator|&&
name|index
operator|<
name|numBits
assert|;
name|int
name|i
init|=
call|(
name|int
call|)
argument_list|(
name|index
operator|>>
literal|6
argument_list|)
decl_stmt|;
comment|// div 64
name|int
name|bit
init|=
operator|(
name|int
operator|)
name|index
operator|&
literal|0x3f
decl_stmt|;
comment|// mod 64
name|long
name|bitmask
init|=
literal|1L
operator|<<
name|bit
decl_stmt|;
return|return
operator|(
name|bits
index|[
name|i
index|]
operator|&
name|bitmask
operator|)
operator|!=
literal|0
return|;
block|}
comment|/*   // alternate implementation of get()   public boolean get1(int index) {     int i = index>> 6;                // div 64     int bit = index& 0x3f;            // mod 64     return ((bits[i]>>>bit)& 0x01) != 0;     // this does a long shift and a bittest (on x86) vs     // a long shift, and a long AND, (the test for zero is prob a no-op)     // testing on a P4 indicates this is slower than (bits[i]& bitmask) != 0;   }   */
comment|/** returns 1 if the bit is set, 0 if not.    * The index should be less than the OpenBitSet size    */
DECL|method|getBit
specifier|public
name|int
name|getBit
parameter_list|(
name|int
name|index
parameter_list|)
block|{
assert|assert
name|index
operator|>=
literal|0
operator|&&
name|index
operator|<
name|numBits
assert|;
name|int
name|i
init|=
name|index
operator|>>
literal|6
decl_stmt|;
comment|// div 64
name|int
name|bit
init|=
name|index
operator|&
literal|0x3f
decl_stmt|;
comment|// mod 64
return|return
operator|(
call|(
name|int
call|)
argument_list|(
name|bits
index|[
name|i
index|]
operator|>>>
name|bit
argument_list|)
operator|)
operator|&
literal|0x01
return|;
block|}
comment|/*   public boolean get2(int index) {     int word = index>> 6;            // div 64     int bit = index& 0x0000003f;     // mod 64     return (bits[word]<< bit)< 0;   // hmmm, this would work if bit order were reversed     // we could right shift and check for parity bit, if it was available to us.   }   */
comment|/** sets a bit, expanding the set size if necessary */
DECL|method|set
specifier|public
name|void
name|set
parameter_list|(
name|long
name|index
parameter_list|)
block|{
name|int
name|wordNum
init|=
name|expandingWordNum
argument_list|(
name|index
argument_list|)
decl_stmt|;
name|int
name|bit
init|=
operator|(
name|int
operator|)
name|index
operator|&
literal|0x3f
decl_stmt|;
name|long
name|bitmask
init|=
literal|1L
operator|<<
name|bit
decl_stmt|;
name|bits
index|[
name|wordNum
index|]
operator||=
name|bitmask
expr_stmt|;
block|}
comment|/** Sets the bit at the specified index.   * The index should be less than the OpenBitSet size.   */
DECL|method|fastSet
specifier|public
name|void
name|fastSet
parameter_list|(
name|int
name|index
parameter_list|)
block|{
assert|assert
name|index
operator|>=
literal|0
operator|&&
name|index
operator|<
name|numBits
assert|;
name|int
name|wordNum
init|=
name|index
operator|>>
literal|6
decl_stmt|;
comment|// div 64
name|int
name|bit
init|=
name|index
operator|&
literal|0x3f
decl_stmt|;
comment|// mod 64
name|long
name|bitmask
init|=
literal|1L
operator|<<
name|bit
decl_stmt|;
name|bits
index|[
name|wordNum
index|]
operator||=
name|bitmask
expr_stmt|;
block|}
comment|/** Sets the bit at the specified index.   * The index should be less than the OpenBitSet size.   */
DECL|method|fastSet
specifier|public
name|void
name|fastSet
parameter_list|(
name|long
name|index
parameter_list|)
block|{
assert|assert
name|index
operator|>=
literal|0
operator|&&
name|index
operator|<
name|numBits
assert|;
name|int
name|wordNum
init|=
call|(
name|int
call|)
argument_list|(
name|index
operator|>>
literal|6
argument_list|)
decl_stmt|;
name|int
name|bit
init|=
operator|(
name|int
operator|)
name|index
operator|&
literal|0x3f
decl_stmt|;
name|long
name|bitmask
init|=
literal|1L
operator|<<
name|bit
decl_stmt|;
name|bits
index|[
name|wordNum
index|]
operator||=
name|bitmask
expr_stmt|;
block|}
comment|/** Sets a range of bits, expanding the set size if necessary    *    * @param startIndex lower index    * @param endIndex one-past the last bit to set    */
DECL|method|set
specifier|public
name|void
name|set
parameter_list|(
name|long
name|startIndex
parameter_list|,
name|long
name|endIndex
parameter_list|)
block|{
if|if
condition|(
name|endIndex
operator|<=
name|startIndex
condition|)
return|return;
name|int
name|startWord
init|=
call|(
name|int
call|)
argument_list|(
name|startIndex
operator|>>
literal|6
argument_list|)
decl_stmt|;
comment|// since endIndex is one past the end, this is index of the last
comment|// word to be changed.
name|int
name|endWord
init|=
name|expandingWordNum
argument_list|(
name|endIndex
operator|-
literal|1
argument_list|)
decl_stmt|;
name|long
name|startmask
init|=
operator|-
literal|1L
operator|<<
name|startIndex
decl_stmt|;
name|long
name|endmask
init|=
operator|-
literal|1L
operator|>>>
operator|-
name|endIndex
decl_stmt|;
comment|// 64-(endIndex&0x3f) is the same as -endIndex due to wrap
if|if
condition|(
name|startWord
operator|==
name|endWord
condition|)
block|{
name|bits
index|[
name|startWord
index|]
operator||=
operator|(
name|startmask
operator|&
name|endmask
operator|)
expr_stmt|;
return|return;
block|}
name|bits
index|[
name|startWord
index|]
operator||=
name|startmask
expr_stmt|;
name|Arrays
operator|.
name|fill
argument_list|(
name|bits
argument_list|,
name|startWord
operator|+
literal|1
argument_list|,
name|endWord
argument_list|,
operator|-
literal|1L
argument_list|)
expr_stmt|;
name|bits
index|[
name|endWord
index|]
operator||=
name|endmask
expr_stmt|;
block|}
DECL|method|expandingWordNum
specifier|protected
name|int
name|expandingWordNum
parameter_list|(
name|long
name|index
parameter_list|)
block|{
name|int
name|wordNum
init|=
call|(
name|int
call|)
argument_list|(
name|index
operator|>>
literal|6
argument_list|)
decl_stmt|;
if|if
condition|(
name|wordNum
operator|>=
name|wlen
condition|)
block|{
name|ensureCapacity
argument_list|(
name|index
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|wordNum
return|;
block|}
comment|/** clears a bit.    * The index should be less than the OpenBitSet size.    */
DECL|method|fastClear
specifier|public
name|void
name|fastClear
parameter_list|(
name|int
name|index
parameter_list|)
block|{
assert|assert
name|index
operator|>=
literal|0
operator|&&
name|index
operator|<
name|numBits
assert|;
name|int
name|wordNum
init|=
name|index
operator|>>
literal|6
decl_stmt|;
name|int
name|bit
init|=
name|index
operator|&
literal|0x03f
decl_stmt|;
name|long
name|bitmask
init|=
literal|1L
operator|<<
name|bit
decl_stmt|;
name|bits
index|[
name|wordNum
index|]
operator|&=
operator|~
name|bitmask
expr_stmt|;
comment|// hmmm, it takes one more instruction to clear than it does to set... any
comment|// way to work around this?  If there were only 63 bits per word, we could
comment|// use a right shift of 10111111...111 in binary to position the 0 in the
comment|// correct place (using sign extension).
comment|// Could also use Long.rotateRight() or rotateLeft() *if* they were converted
comment|// by the JVM into a native instruction.
comment|// bits[word]&= Long.rotateLeft(0xfffffffe,bit);
block|}
comment|/** clears a bit.    * The index should be less than the OpenBitSet size.    */
DECL|method|fastClear
specifier|public
name|void
name|fastClear
parameter_list|(
name|long
name|index
parameter_list|)
block|{
assert|assert
name|index
operator|>=
literal|0
operator|&&
name|index
operator|<
name|numBits
assert|;
name|int
name|wordNum
init|=
call|(
name|int
call|)
argument_list|(
name|index
operator|>>
literal|6
argument_list|)
decl_stmt|;
comment|// div 64
name|int
name|bit
init|=
operator|(
name|int
operator|)
name|index
operator|&
literal|0x3f
decl_stmt|;
comment|// mod 64
name|long
name|bitmask
init|=
literal|1L
operator|<<
name|bit
decl_stmt|;
name|bits
index|[
name|wordNum
index|]
operator|&=
operator|~
name|bitmask
expr_stmt|;
block|}
comment|/** clears a bit, allowing access beyond the current set size without changing the size.*/
DECL|method|clear
specifier|public
name|void
name|clear
parameter_list|(
name|long
name|index
parameter_list|)
block|{
name|int
name|wordNum
init|=
call|(
name|int
call|)
argument_list|(
name|index
operator|>>
literal|6
argument_list|)
decl_stmt|;
comment|// div 64
if|if
condition|(
name|wordNum
operator|>=
name|wlen
condition|)
return|return;
name|int
name|bit
init|=
operator|(
name|int
operator|)
name|index
operator|&
literal|0x3f
decl_stmt|;
comment|// mod 64
name|long
name|bitmask
init|=
literal|1L
operator|<<
name|bit
decl_stmt|;
name|bits
index|[
name|wordNum
index|]
operator|&=
operator|~
name|bitmask
expr_stmt|;
block|}
comment|/** Clears a range of bits.  Clearing past the end does not change the size of the set.    *    * @param startIndex lower index    * @param endIndex one-past the last bit to clear    */
DECL|method|clear
specifier|public
name|void
name|clear
parameter_list|(
name|int
name|startIndex
parameter_list|,
name|int
name|endIndex
parameter_list|)
block|{
if|if
condition|(
name|endIndex
operator|<=
name|startIndex
condition|)
return|return;
name|int
name|startWord
init|=
operator|(
name|startIndex
operator|>>
literal|6
operator|)
decl_stmt|;
if|if
condition|(
name|startWord
operator|>=
name|wlen
condition|)
return|return;
comment|// since endIndex is one past the end, this is index of the last
comment|// word to be changed.
name|int
name|endWord
init|=
operator|(
operator|(
name|endIndex
operator|-
literal|1
operator|)
operator|>>
literal|6
operator|)
decl_stmt|;
name|long
name|startmask
init|=
operator|-
literal|1L
operator|<<
name|startIndex
decl_stmt|;
name|long
name|endmask
init|=
operator|-
literal|1L
operator|>>>
operator|-
name|endIndex
decl_stmt|;
comment|// 64-(endIndex&0x3f) is the same as -endIndex due to wrap
comment|// invert masks since we are clearing
name|startmask
operator|=
operator|~
name|startmask
expr_stmt|;
name|endmask
operator|=
operator|~
name|endmask
expr_stmt|;
if|if
condition|(
name|startWord
operator|==
name|endWord
condition|)
block|{
name|bits
index|[
name|startWord
index|]
operator|&=
operator|(
name|startmask
operator||
name|endmask
operator|)
expr_stmt|;
return|return;
block|}
name|bits
index|[
name|startWord
index|]
operator|&=
name|startmask
expr_stmt|;
name|int
name|middle
init|=
name|Math
operator|.
name|min
argument_list|(
name|wlen
argument_list|,
name|endWord
argument_list|)
decl_stmt|;
name|Arrays
operator|.
name|fill
argument_list|(
name|bits
argument_list|,
name|startWord
operator|+
literal|1
argument_list|,
name|middle
argument_list|,
literal|0L
argument_list|)
expr_stmt|;
if|if
condition|(
name|endWord
operator|<
name|wlen
condition|)
block|{
name|bits
index|[
name|endWord
index|]
operator|&=
name|endmask
expr_stmt|;
block|}
block|}
comment|/** Clears a range of bits.  Clearing past the end does not change the size of the set.    *    * @param startIndex lower index    * @param endIndex one-past the last bit to clear    */
DECL|method|clear
specifier|public
name|void
name|clear
parameter_list|(
name|long
name|startIndex
parameter_list|,
name|long
name|endIndex
parameter_list|)
block|{
if|if
condition|(
name|endIndex
operator|<=
name|startIndex
condition|)
return|return;
name|int
name|startWord
init|=
call|(
name|int
call|)
argument_list|(
name|startIndex
operator|>>
literal|6
argument_list|)
decl_stmt|;
if|if
condition|(
name|startWord
operator|>=
name|wlen
condition|)
return|return;
comment|// since endIndex is one past the end, this is index of the last
comment|// word to be changed.
name|int
name|endWord
init|=
call|(
name|int
call|)
argument_list|(
operator|(
name|endIndex
operator|-
literal|1
operator|)
operator|>>
literal|6
argument_list|)
decl_stmt|;
name|long
name|startmask
init|=
operator|-
literal|1L
operator|<<
name|startIndex
decl_stmt|;
name|long
name|endmask
init|=
operator|-
literal|1L
operator|>>>
operator|-
name|endIndex
decl_stmt|;
comment|// 64-(endIndex&0x3f) is the same as -endIndex due to wrap
comment|// invert masks since we are clearing
name|startmask
operator|=
operator|~
name|startmask
expr_stmt|;
name|endmask
operator|=
operator|~
name|endmask
expr_stmt|;
if|if
condition|(
name|startWord
operator|==
name|endWord
condition|)
block|{
name|bits
index|[
name|startWord
index|]
operator|&=
operator|(
name|startmask
operator||
name|endmask
operator|)
expr_stmt|;
return|return;
block|}
name|bits
index|[
name|startWord
index|]
operator|&=
name|startmask
expr_stmt|;
name|int
name|middle
init|=
name|Math
operator|.
name|min
argument_list|(
name|wlen
argument_list|,
name|endWord
argument_list|)
decl_stmt|;
name|Arrays
operator|.
name|fill
argument_list|(
name|bits
argument_list|,
name|startWord
operator|+
literal|1
argument_list|,
name|middle
argument_list|,
literal|0L
argument_list|)
expr_stmt|;
if|if
condition|(
name|endWord
operator|<
name|wlen
condition|)
block|{
name|bits
index|[
name|endWord
index|]
operator|&=
name|endmask
expr_stmt|;
block|}
block|}
comment|/** Sets a bit and returns the previous value.    * The index should be less than the OpenBitSet size.    */
DECL|method|getAndSet
specifier|public
name|boolean
name|getAndSet
parameter_list|(
name|int
name|index
parameter_list|)
block|{
assert|assert
name|index
operator|>=
literal|0
operator|&&
name|index
operator|<
name|numBits
assert|;
name|int
name|wordNum
init|=
name|index
operator|>>
literal|6
decl_stmt|;
comment|// div 64
name|int
name|bit
init|=
name|index
operator|&
literal|0x3f
decl_stmt|;
comment|// mod 64
name|long
name|bitmask
init|=
literal|1L
operator|<<
name|bit
decl_stmt|;
name|boolean
name|val
init|=
operator|(
name|bits
index|[
name|wordNum
index|]
operator|&
name|bitmask
operator|)
operator|!=
literal|0
decl_stmt|;
name|bits
index|[
name|wordNum
index|]
operator||=
name|bitmask
expr_stmt|;
return|return
name|val
return|;
block|}
comment|/** Sets a bit and returns the previous value.    * The index should be less than the OpenBitSet size.    */
DECL|method|getAndSet
specifier|public
name|boolean
name|getAndSet
parameter_list|(
name|long
name|index
parameter_list|)
block|{
assert|assert
name|index
operator|>=
literal|0
operator|&&
name|index
operator|<
name|numBits
assert|;
name|int
name|wordNum
init|=
call|(
name|int
call|)
argument_list|(
name|index
operator|>>
literal|6
argument_list|)
decl_stmt|;
comment|// div 64
name|int
name|bit
init|=
operator|(
name|int
operator|)
name|index
operator|&
literal|0x3f
decl_stmt|;
comment|// mod 64
name|long
name|bitmask
init|=
literal|1L
operator|<<
name|bit
decl_stmt|;
name|boolean
name|val
init|=
operator|(
name|bits
index|[
name|wordNum
index|]
operator|&
name|bitmask
operator|)
operator|!=
literal|0
decl_stmt|;
name|bits
index|[
name|wordNum
index|]
operator||=
name|bitmask
expr_stmt|;
return|return
name|val
return|;
block|}
comment|/** flips a bit.    * The index should be less than the OpenBitSet size.    */
DECL|method|fastFlip
specifier|public
name|void
name|fastFlip
parameter_list|(
name|int
name|index
parameter_list|)
block|{
assert|assert
name|index
operator|>=
literal|0
operator|&&
name|index
operator|<
name|numBits
assert|;
name|int
name|wordNum
init|=
name|index
operator|>>
literal|6
decl_stmt|;
comment|// div 64
name|int
name|bit
init|=
name|index
operator|&
literal|0x3f
decl_stmt|;
comment|// mod 64
name|long
name|bitmask
init|=
literal|1L
operator|<<
name|bit
decl_stmt|;
name|bits
index|[
name|wordNum
index|]
operator|^=
name|bitmask
expr_stmt|;
block|}
comment|/** flips a bit.    * The index should be less than the OpenBitSet size.    */
DECL|method|fastFlip
specifier|public
name|void
name|fastFlip
parameter_list|(
name|long
name|index
parameter_list|)
block|{
assert|assert
name|index
operator|>=
literal|0
operator|&&
name|index
operator|<
name|numBits
assert|;
name|int
name|wordNum
init|=
call|(
name|int
call|)
argument_list|(
name|index
operator|>>
literal|6
argument_list|)
decl_stmt|;
comment|// div 64
name|int
name|bit
init|=
operator|(
name|int
operator|)
name|index
operator|&
literal|0x3f
decl_stmt|;
comment|// mod 64
name|long
name|bitmask
init|=
literal|1L
operator|<<
name|bit
decl_stmt|;
name|bits
index|[
name|wordNum
index|]
operator|^=
name|bitmask
expr_stmt|;
block|}
comment|/** flips a bit, expanding the set size if necessary */
DECL|method|flip
specifier|public
name|void
name|flip
parameter_list|(
name|long
name|index
parameter_list|)
block|{
name|int
name|wordNum
init|=
name|expandingWordNum
argument_list|(
name|index
argument_list|)
decl_stmt|;
name|int
name|bit
init|=
operator|(
name|int
operator|)
name|index
operator|&
literal|0x3f
decl_stmt|;
comment|// mod 64
name|long
name|bitmask
init|=
literal|1L
operator|<<
name|bit
decl_stmt|;
name|bits
index|[
name|wordNum
index|]
operator|^=
name|bitmask
expr_stmt|;
block|}
comment|/** flips a bit and returns the resulting bit value.    * The index should be less than the OpenBitSet size.    */
DECL|method|flipAndGet
specifier|public
name|boolean
name|flipAndGet
parameter_list|(
name|int
name|index
parameter_list|)
block|{
assert|assert
name|index
operator|>=
literal|0
operator|&&
name|index
operator|<
name|numBits
assert|;
name|int
name|wordNum
init|=
name|index
operator|>>
literal|6
decl_stmt|;
comment|// div 64
name|int
name|bit
init|=
name|index
operator|&
literal|0x3f
decl_stmt|;
comment|// mod 64
name|long
name|bitmask
init|=
literal|1L
operator|<<
name|bit
decl_stmt|;
name|bits
index|[
name|wordNum
index|]
operator|^=
name|bitmask
expr_stmt|;
return|return
operator|(
name|bits
index|[
name|wordNum
index|]
operator|&
name|bitmask
operator|)
operator|!=
literal|0
return|;
block|}
comment|/** flips a bit and returns the resulting bit value.    * The index should be less than the OpenBitSet size.    */
DECL|method|flipAndGet
specifier|public
name|boolean
name|flipAndGet
parameter_list|(
name|long
name|index
parameter_list|)
block|{
assert|assert
name|index
operator|>=
literal|0
operator|&&
name|index
operator|<
name|numBits
assert|;
name|int
name|wordNum
init|=
call|(
name|int
call|)
argument_list|(
name|index
operator|>>
literal|6
argument_list|)
decl_stmt|;
comment|// div 64
name|int
name|bit
init|=
operator|(
name|int
operator|)
name|index
operator|&
literal|0x3f
decl_stmt|;
comment|// mod 64
name|long
name|bitmask
init|=
literal|1L
operator|<<
name|bit
decl_stmt|;
name|bits
index|[
name|wordNum
index|]
operator|^=
name|bitmask
expr_stmt|;
return|return
operator|(
name|bits
index|[
name|wordNum
index|]
operator|&
name|bitmask
operator|)
operator|!=
literal|0
return|;
block|}
comment|/** Flips a range of bits, expanding the set size if necessary    *    * @param startIndex lower index    * @param endIndex one-past the last bit to flip    */
DECL|method|flip
specifier|public
name|void
name|flip
parameter_list|(
name|long
name|startIndex
parameter_list|,
name|long
name|endIndex
parameter_list|)
block|{
if|if
condition|(
name|endIndex
operator|<=
name|startIndex
condition|)
return|return;
name|int
name|startWord
init|=
call|(
name|int
call|)
argument_list|(
name|startIndex
operator|>>
literal|6
argument_list|)
decl_stmt|;
comment|// since endIndex is one past the end, this is index of the last
comment|// word to be changed.
name|int
name|endWord
init|=
name|expandingWordNum
argument_list|(
name|endIndex
operator|-
literal|1
argument_list|)
decl_stmt|;
comment|/*** Grrr, java shifting wraps around so -1L>>>64 == -1      * for that reason, make sure not to use endmask if the bits to flip will      * be zero in the last word (redefine endWord to be the last changed...)     long startmask = -1L<< (startIndex& 0x3f);     // example: 11111...111000     long endmask = -1L>>> (64-(endIndex& 0x3f));   // example: 00111...111111     ***/
name|long
name|startmask
init|=
operator|-
literal|1L
operator|<<
name|startIndex
decl_stmt|;
name|long
name|endmask
init|=
operator|-
literal|1L
operator|>>>
operator|-
name|endIndex
decl_stmt|;
comment|// 64-(endIndex&0x3f) is the same as -endIndex due to wrap
if|if
condition|(
name|startWord
operator|==
name|endWord
condition|)
block|{
name|bits
index|[
name|startWord
index|]
operator|^=
operator|(
name|startmask
operator|&
name|endmask
operator|)
expr_stmt|;
return|return;
block|}
name|bits
index|[
name|startWord
index|]
operator|^=
name|startmask
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
name|startWord
operator|+
literal|1
init|;
name|i
operator|<
name|endWord
condition|;
name|i
operator|++
control|)
block|{
name|bits
index|[
name|i
index|]
operator|=
operator|~
name|bits
index|[
name|i
index|]
expr_stmt|;
block|}
name|bits
index|[
name|endWord
index|]
operator|^=
name|endmask
expr_stmt|;
block|}
comment|/*   public static int pop(long v0, long v1, long v2, long v3) {     // derived from pop_array by setting last four elems to 0.     // exchanges one pop() call for 10 elementary operations     // saving about 7 instructions... is there a better way?       long twosA=v0& v1;       long ones=v0^v1;        long u2=ones^v2;       long twosB =(ones&v2)|(u2&v3);       ones=u2^v3;        long fours=(twosA&twosB);       long twos=twosA^twosB;        return (pop(fours)<<2)              + (pop(twos)<<1)              + pop(ones);    }   */
comment|/** @return the number of set bits */
DECL|method|cardinality
specifier|public
name|long
name|cardinality
parameter_list|()
block|{
return|return
name|BitUtil
operator|.
name|pop_array
argument_list|(
name|bits
argument_list|,
literal|0
argument_list|,
name|wlen
argument_list|)
return|;
block|}
comment|/** Returns the popcount or cardinality of the intersection of the two sets.    * Neither set is modified.    */
DECL|method|intersectionCount
specifier|public
specifier|static
name|long
name|intersectionCount
parameter_list|(
name|OpenBitSet
name|a
parameter_list|,
name|OpenBitSet
name|b
parameter_list|)
block|{
return|return
name|BitUtil
operator|.
name|pop_intersect
argument_list|(
name|a
operator|.
name|bits
argument_list|,
name|b
operator|.
name|bits
argument_list|,
literal|0
argument_list|,
name|Math
operator|.
name|min
argument_list|(
name|a
operator|.
name|wlen
argument_list|,
name|b
operator|.
name|wlen
argument_list|)
argument_list|)
return|;
block|}
comment|/** Returns the popcount or cardinality of the union of the two sets.     * Neither set is modified.     */
DECL|method|unionCount
specifier|public
specifier|static
name|long
name|unionCount
parameter_list|(
name|OpenBitSet
name|a
parameter_list|,
name|OpenBitSet
name|b
parameter_list|)
block|{
name|long
name|tot
init|=
name|BitUtil
operator|.
name|pop_union
argument_list|(
name|a
operator|.
name|bits
argument_list|,
name|b
operator|.
name|bits
argument_list|,
literal|0
argument_list|,
name|Math
operator|.
name|min
argument_list|(
name|a
operator|.
name|wlen
argument_list|,
name|b
operator|.
name|wlen
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|a
operator|.
name|wlen
operator|<
name|b
operator|.
name|wlen
condition|)
block|{
name|tot
operator|+=
name|BitUtil
operator|.
name|pop_array
argument_list|(
name|b
operator|.
name|bits
argument_list|,
name|a
operator|.
name|wlen
argument_list|,
name|b
operator|.
name|wlen
operator|-
name|a
operator|.
name|wlen
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|a
operator|.
name|wlen
operator|>
name|b
operator|.
name|wlen
condition|)
block|{
name|tot
operator|+=
name|BitUtil
operator|.
name|pop_array
argument_list|(
name|a
operator|.
name|bits
argument_list|,
name|b
operator|.
name|wlen
argument_list|,
name|a
operator|.
name|wlen
operator|-
name|b
operator|.
name|wlen
argument_list|)
expr_stmt|;
block|}
return|return
name|tot
return|;
block|}
comment|/** Returns the popcount or cardinality of "a and not b"    * or "intersection(a, not(b))".    * Neither set is modified.    */
DECL|method|andNotCount
specifier|public
specifier|static
name|long
name|andNotCount
parameter_list|(
name|OpenBitSet
name|a
parameter_list|,
name|OpenBitSet
name|b
parameter_list|)
block|{
name|long
name|tot
init|=
name|BitUtil
operator|.
name|pop_andnot
argument_list|(
name|a
operator|.
name|bits
argument_list|,
name|b
operator|.
name|bits
argument_list|,
literal|0
argument_list|,
name|Math
operator|.
name|min
argument_list|(
name|a
operator|.
name|wlen
argument_list|,
name|b
operator|.
name|wlen
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|a
operator|.
name|wlen
operator|>
name|b
operator|.
name|wlen
condition|)
block|{
name|tot
operator|+=
name|BitUtil
operator|.
name|pop_array
argument_list|(
name|a
operator|.
name|bits
argument_list|,
name|b
operator|.
name|wlen
argument_list|,
name|a
operator|.
name|wlen
operator|-
name|b
operator|.
name|wlen
argument_list|)
expr_stmt|;
block|}
return|return
name|tot
return|;
block|}
comment|/** Returns the popcount or cardinality of the exclusive-or of the two sets.   * Neither set is modified.   */
DECL|method|xorCount
specifier|public
specifier|static
name|long
name|xorCount
parameter_list|(
name|OpenBitSet
name|a
parameter_list|,
name|OpenBitSet
name|b
parameter_list|)
block|{
name|long
name|tot
init|=
name|BitUtil
operator|.
name|pop_xor
argument_list|(
name|a
operator|.
name|bits
argument_list|,
name|b
operator|.
name|bits
argument_list|,
literal|0
argument_list|,
name|Math
operator|.
name|min
argument_list|(
name|a
operator|.
name|wlen
argument_list|,
name|b
operator|.
name|wlen
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|a
operator|.
name|wlen
operator|<
name|b
operator|.
name|wlen
condition|)
block|{
name|tot
operator|+=
name|BitUtil
operator|.
name|pop_array
argument_list|(
name|b
operator|.
name|bits
argument_list|,
name|a
operator|.
name|wlen
argument_list|,
name|b
operator|.
name|wlen
operator|-
name|a
operator|.
name|wlen
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|a
operator|.
name|wlen
operator|>
name|b
operator|.
name|wlen
condition|)
block|{
name|tot
operator|+=
name|BitUtil
operator|.
name|pop_array
argument_list|(
name|a
operator|.
name|bits
argument_list|,
name|b
operator|.
name|wlen
argument_list|,
name|a
operator|.
name|wlen
operator|-
name|b
operator|.
name|wlen
argument_list|)
expr_stmt|;
block|}
return|return
name|tot
return|;
block|}
comment|/** Returns the index of the first set bit starting at the index specified.    *  -1 is returned if there are no more set bits.    */
DECL|method|nextSetBit
specifier|public
name|int
name|nextSetBit
parameter_list|(
name|int
name|index
parameter_list|)
block|{
name|int
name|i
init|=
name|index
operator|>>
literal|6
decl_stmt|;
if|if
condition|(
name|i
operator|>=
name|wlen
condition|)
return|return
operator|-
literal|1
return|;
name|int
name|subIndex
init|=
name|index
operator|&
literal|0x3f
decl_stmt|;
comment|// index within the word
name|long
name|word
init|=
name|bits
index|[
name|i
index|]
operator|>>
name|subIndex
decl_stmt|;
comment|// skip all the bits to the right of index
if|if
condition|(
name|word
operator|!=
literal|0
condition|)
block|{
return|return
operator|(
name|i
operator|<<
literal|6
operator|)
operator|+
name|subIndex
operator|+
name|Long
operator|.
name|numberOfTrailingZeros
argument_list|(
name|word
argument_list|)
return|;
block|}
while|while
condition|(
operator|++
name|i
operator|<
name|wlen
condition|)
block|{
name|word
operator|=
name|bits
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|word
operator|!=
literal|0
condition|)
return|return
operator|(
name|i
operator|<<
literal|6
operator|)
operator|+
name|Long
operator|.
name|numberOfTrailingZeros
argument_list|(
name|word
argument_list|)
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
comment|/** Returns the index of the first set bit starting at the index specified.    *  -1 is returned if there are no more set bits.    */
DECL|method|nextSetBit
specifier|public
name|long
name|nextSetBit
parameter_list|(
name|long
name|index
parameter_list|)
block|{
name|int
name|i
init|=
call|(
name|int
call|)
argument_list|(
name|index
operator|>>>
literal|6
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|>=
name|wlen
condition|)
return|return
operator|-
literal|1
return|;
name|int
name|subIndex
init|=
operator|(
name|int
operator|)
name|index
operator|&
literal|0x3f
decl_stmt|;
comment|// index within the word
name|long
name|word
init|=
name|bits
index|[
name|i
index|]
operator|>>>
name|subIndex
decl_stmt|;
comment|// skip all the bits to the right of index
if|if
condition|(
name|word
operator|!=
literal|0
condition|)
block|{
return|return
operator|(
operator|(
operator|(
name|long
operator|)
name|i
operator|)
operator|<<
literal|6
operator|)
operator|+
operator|(
name|subIndex
operator|+
name|Long
operator|.
name|numberOfTrailingZeros
argument_list|(
name|word
argument_list|)
operator|)
return|;
block|}
while|while
condition|(
operator|++
name|i
operator|<
name|wlen
condition|)
block|{
name|word
operator|=
name|bits
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|word
operator|!=
literal|0
condition|)
return|return
operator|(
operator|(
operator|(
name|long
operator|)
name|i
operator|)
operator|<<
literal|6
operator|)
operator|+
name|Long
operator|.
name|numberOfTrailingZeros
argument_list|(
name|word
argument_list|)
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
comment|/** Returns the index of the first set bit starting downwards at    *  the index specified.    *  -1 is returned if there are no more set bits.    */
DECL|method|prevSetBit
specifier|public
name|int
name|prevSetBit
parameter_list|(
name|int
name|index
parameter_list|)
block|{
name|int
name|i
init|=
name|index
operator|>>
literal|6
decl_stmt|;
specifier|final
name|int
name|subIndex
decl_stmt|;
name|long
name|word
decl_stmt|;
if|if
condition|(
name|i
operator|>=
name|wlen
condition|)
block|{
name|i
operator|=
name|wlen
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
name|subIndex
operator|=
literal|63
expr_stmt|;
comment|// last possible bit
name|word
operator|=
name|bits
index|[
name|i
index|]
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|i
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
name|subIndex
operator|=
name|index
operator|&
literal|0x3f
expr_stmt|;
comment|// index within the word
name|word
operator|=
operator|(
name|bits
index|[
name|i
index|]
operator|<<
operator|(
literal|63
operator|-
name|subIndex
operator|)
operator|)
expr_stmt|;
comment|// skip all the bits to the left of index
block|}
if|if
condition|(
name|word
operator|!=
literal|0
condition|)
block|{
return|return
operator|(
name|i
operator|<<
literal|6
operator|)
operator|+
name|subIndex
operator|-
name|Long
operator|.
name|numberOfLeadingZeros
argument_list|(
name|word
argument_list|)
return|;
comment|// See LUCENE-3197
block|}
while|while
condition|(
operator|--
name|i
operator|>=
literal|0
condition|)
block|{
name|word
operator|=
name|bits
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|word
operator|!=
literal|0
condition|)
block|{
return|return
operator|(
name|i
operator|<<
literal|6
operator|)
operator|+
literal|63
operator|-
name|Long
operator|.
name|numberOfLeadingZeros
argument_list|(
name|word
argument_list|)
return|;
block|}
block|}
return|return
operator|-
literal|1
return|;
block|}
comment|/** Returns the index of the first set bit starting downwards at    *  the index specified.    *  -1 is returned if there are no more set bits.    */
DECL|method|prevSetBit
specifier|public
name|long
name|prevSetBit
parameter_list|(
name|long
name|index
parameter_list|)
block|{
name|int
name|i
init|=
call|(
name|int
call|)
argument_list|(
name|index
operator|>>
literal|6
argument_list|)
decl_stmt|;
specifier|final
name|int
name|subIndex
decl_stmt|;
name|long
name|word
decl_stmt|;
if|if
condition|(
name|i
operator|>=
name|wlen
condition|)
block|{
name|i
operator|=
name|wlen
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
name|subIndex
operator|=
literal|63
expr_stmt|;
comment|// last possible bit
name|word
operator|=
name|bits
index|[
name|i
index|]
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|i
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
name|subIndex
operator|=
operator|(
name|int
operator|)
name|index
operator|&
literal|0x3f
expr_stmt|;
comment|// index within the word
name|word
operator|=
operator|(
name|bits
index|[
name|i
index|]
operator|<<
operator|(
literal|63
operator|-
name|subIndex
operator|)
operator|)
expr_stmt|;
comment|// skip all the bits to the left of index
block|}
if|if
condition|(
name|word
operator|!=
literal|0
condition|)
block|{
return|return
operator|(
operator|(
operator|(
name|long
operator|)
name|i
operator|)
operator|<<
literal|6
operator|)
operator|+
name|subIndex
operator|-
name|Long
operator|.
name|numberOfLeadingZeros
argument_list|(
name|word
argument_list|)
return|;
comment|// See LUCENE-3197
block|}
while|while
condition|(
operator|--
name|i
operator|>=
literal|0
condition|)
block|{
name|word
operator|=
name|bits
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|word
operator|!=
literal|0
condition|)
block|{
return|return
operator|(
operator|(
operator|(
name|long
operator|)
name|i
operator|)
operator|<<
literal|6
operator|)
operator|+
literal|63
operator|-
name|Long
operator|.
name|numberOfLeadingZeros
argument_list|(
name|word
argument_list|)
return|;
block|}
block|}
return|return
operator|-
literal|1
return|;
block|}
annotation|@
name|Override
DECL|method|clone
specifier|public
name|OpenBitSet
name|clone
parameter_list|()
block|{
try|try
block|{
name|OpenBitSet
name|obs
init|=
operator|(
name|OpenBitSet
operator|)
name|super
operator|.
name|clone
argument_list|()
decl_stmt|;
name|obs
operator|.
name|bits
operator|=
name|obs
operator|.
name|bits
operator|.
name|clone
argument_list|()
expr_stmt|;
comment|// hopefully an array clone is as fast(er) than arraycopy
return|return
name|obs
return|;
block|}
catch|catch
parameter_list|(
name|CloneNotSupportedException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
comment|/** this = this AND other */
DECL|method|intersect
specifier|public
name|void
name|intersect
parameter_list|(
name|OpenBitSet
name|other
parameter_list|)
block|{
name|int
name|newLen
init|=
name|Math
operator|.
name|min
argument_list|(
name|this
operator|.
name|wlen
argument_list|,
name|other
operator|.
name|wlen
argument_list|)
decl_stmt|;
name|long
index|[]
name|thisArr
init|=
name|this
operator|.
name|bits
decl_stmt|;
name|long
index|[]
name|otherArr
init|=
name|other
operator|.
name|bits
decl_stmt|;
comment|// testing against zero can be more efficient
name|int
name|pos
init|=
name|newLen
decl_stmt|;
while|while
condition|(
operator|--
name|pos
operator|>=
literal|0
condition|)
block|{
name|thisArr
index|[
name|pos
index|]
operator|&=
name|otherArr
index|[
name|pos
index|]
expr_stmt|;
block|}
if|if
condition|(
name|this
operator|.
name|wlen
operator|>
name|newLen
condition|)
block|{
comment|// fill zeros from the new shorter length to the old length
name|Arrays
operator|.
name|fill
argument_list|(
name|bits
argument_list|,
name|newLen
argument_list|,
name|this
operator|.
name|wlen
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|wlen
operator|=
name|newLen
expr_stmt|;
block|}
comment|/** this = this OR other */
DECL|method|union
specifier|public
name|void
name|union
parameter_list|(
name|OpenBitSet
name|other
parameter_list|)
block|{
name|int
name|newLen
init|=
name|Math
operator|.
name|max
argument_list|(
name|wlen
argument_list|,
name|other
operator|.
name|wlen
argument_list|)
decl_stmt|;
name|ensureCapacityWords
argument_list|(
name|newLen
argument_list|)
expr_stmt|;
assert|assert
operator|(
name|numBits
operator|=
name|Math
operator|.
name|max
argument_list|(
name|other
operator|.
name|numBits
argument_list|,
name|numBits
argument_list|)
operator|)
operator|>=
literal|0
assert|;
name|long
index|[]
name|thisArr
init|=
name|this
operator|.
name|bits
decl_stmt|;
name|long
index|[]
name|otherArr
init|=
name|other
operator|.
name|bits
decl_stmt|;
name|int
name|pos
init|=
name|Math
operator|.
name|min
argument_list|(
name|wlen
argument_list|,
name|other
operator|.
name|wlen
argument_list|)
decl_stmt|;
while|while
condition|(
operator|--
name|pos
operator|>=
literal|0
condition|)
block|{
name|thisArr
index|[
name|pos
index|]
operator||=
name|otherArr
index|[
name|pos
index|]
expr_stmt|;
block|}
if|if
condition|(
name|this
operator|.
name|wlen
operator|<
name|newLen
condition|)
block|{
name|System
operator|.
name|arraycopy
argument_list|(
name|otherArr
argument_list|,
name|this
operator|.
name|wlen
argument_list|,
name|thisArr
argument_list|,
name|this
operator|.
name|wlen
argument_list|,
name|newLen
operator|-
name|this
operator|.
name|wlen
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|wlen
operator|=
name|newLen
expr_stmt|;
block|}
comment|/** Remove all elements set in other. this = this AND_NOT other */
DECL|method|remove
specifier|public
name|void
name|remove
parameter_list|(
name|OpenBitSet
name|other
parameter_list|)
block|{
name|int
name|idx
init|=
name|Math
operator|.
name|min
argument_list|(
name|wlen
argument_list|,
name|other
operator|.
name|wlen
argument_list|)
decl_stmt|;
name|long
index|[]
name|thisArr
init|=
name|this
operator|.
name|bits
decl_stmt|;
name|long
index|[]
name|otherArr
init|=
name|other
operator|.
name|bits
decl_stmt|;
while|while
condition|(
operator|--
name|idx
operator|>=
literal|0
condition|)
block|{
name|thisArr
index|[
name|idx
index|]
operator|&=
operator|~
name|otherArr
index|[
name|idx
index|]
expr_stmt|;
block|}
block|}
comment|/** this = this XOR other */
DECL|method|xor
specifier|public
name|void
name|xor
parameter_list|(
name|OpenBitSet
name|other
parameter_list|)
block|{
name|int
name|newLen
init|=
name|Math
operator|.
name|max
argument_list|(
name|wlen
argument_list|,
name|other
operator|.
name|wlen
argument_list|)
decl_stmt|;
name|ensureCapacityWords
argument_list|(
name|newLen
argument_list|)
expr_stmt|;
assert|assert
operator|(
name|numBits
operator|=
name|Math
operator|.
name|max
argument_list|(
name|other
operator|.
name|numBits
argument_list|,
name|numBits
argument_list|)
operator|)
operator|>=
literal|0
assert|;
name|long
index|[]
name|thisArr
init|=
name|this
operator|.
name|bits
decl_stmt|;
name|long
index|[]
name|otherArr
init|=
name|other
operator|.
name|bits
decl_stmt|;
name|int
name|pos
init|=
name|Math
operator|.
name|min
argument_list|(
name|wlen
argument_list|,
name|other
operator|.
name|wlen
argument_list|)
decl_stmt|;
while|while
condition|(
operator|--
name|pos
operator|>=
literal|0
condition|)
block|{
name|thisArr
index|[
name|pos
index|]
operator|^=
name|otherArr
index|[
name|pos
index|]
expr_stmt|;
block|}
if|if
condition|(
name|this
operator|.
name|wlen
operator|<
name|newLen
condition|)
block|{
name|System
operator|.
name|arraycopy
argument_list|(
name|otherArr
argument_list|,
name|this
operator|.
name|wlen
argument_list|,
name|thisArr
argument_list|,
name|this
operator|.
name|wlen
argument_list|,
name|newLen
operator|-
name|this
operator|.
name|wlen
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|wlen
operator|=
name|newLen
expr_stmt|;
block|}
comment|// some BitSet compatability methods
comment|//** see {@link intersect} */
DECL|method|and
specifier|public
name|void
name|and
parameter_list|(
name|OpenBitSet
name|other
parameter_list|)
block|{
name|intersect
argument_list|(
name|other
argument_list|)
expr_stmt|;
block|}
comment|//** see {@link union} */
DECL|method|or
specifier|public
name|void
name|or
parameter_list|(
name|OpenBitSet
name|other
parameter_list|)
block|{
name|union
argument_list|(
name|other
argument_list|)
expr_stmt|;
block|}
comment|//** see {@link andNot} */
DECL|method|andNot
specifier|public
name|void
name|andNot
parameter_list|(
name|OpenBitSet
name|other
parameter_list|)
block|{
name|remove
argument_list|(
name|other
argument_list|)
expr_stmt|;
block|}
comment|/** returns true if the sets have any elements in common */
DECL|method|intersects
specifier|public
name|boolean
name|intersects
parameter_list|(
name|OpenBitSet
name|other
parameter_list|)
block|{
name|int
name|pos
init|=
name|Math
operator|.
name|min
argument_list|(
name|this
operator|.
name|wlen
argument_list|,
name|other
operator|.
name|wlen
argument_list|)
decl_stmt|;
name|long
index|[]
name|thisArr
init|=
name|this
operator|.
name|bits
decl_stmt|;
name|long
index|[]
name|otherArr
init|=
name|other
operator|.
name|bits
decl_stmt|;
while|while
condition|(
operator|--
name|pos
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|thisArr
index|[
name|pos
index|]
operator|&
name|otherArr
index|[
name|pos
index|]
operator|)
operator|!=
literal|0
condition|)
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
comment|/** Expand the long[] with the size given as a number of words (64 bit longs). */
DECL|method|ensureCapacityWords
specifier|public
name|void
name|ensureCapacityWords
parameter_list|(
name|int
name|numWords
parameter_list|)
block|{
name|bits
operator|=
name|ArrayUtil
operator|.
name|grow
argument_list|(
name|bits
argument_list|,
name|numWords
argument_list|)
expr_stmt|;
name|wlen
operator|=
name|numWords
expr_stmt|;
assert|assert
operator|(
name|this
operator|.
name|numBits
operator|=
name|Math
operator|.
name|max
argument_list|(
name|this
operator|.
name|numBits
argument_list|,
name|numWords
operator|<<
literal|6
argument_list|)
operator|)
operator|>=
literal|0
assert|;
block|}
comment|/**    * Ensure that the long[] is big enough to hold numBits, expanding it if    * necessary.    */
DECL|method|ensureCapacity
specifier|public
name|void
name|ensureCapacity
parameter_list|(
name|long
name|numBits
parameter_list|)
block|{
name|ensureCapacityWords
argument_list|(
name|bits2words
argument_list|(
name|numBits
argument_list|)
argument_list|)
expr_stmt|;
comment|// ensureCapacityWords sets numBits to a multiple of 64, but we want to set
comment|// it to exactly what the app asked.
assert|assert
operator|(
name|this
operator|.
name|numBits
operator|=
name|Math
operator|.
name|max
argument_list|(
name|this
operator|.
name|numBits
argument_list|,
name|numBits
argument_list|)
operator|)
operator|>=
literal|0
assert|;
block|}
comment|/** Lowers numWords, the number of words in use,    * by checking for trailing zero words.    */
DECL|method|trimTrailingZeros
specifier|public
name|void
name|trimTrailingZeros
parameter_list|()
block|{
name|int
name|idx
init|=
name|wlen
operator|-
literal|1
decl_stmt|;
while|while
condition|(
name|idx
operator|>=
literal|0
operator|&&
name|bits
index|[
name|idx
index|]
operator|==
literal|0
condition|)
name|idx
operator|--
expr_stmt|;
name|wlen
operator|=
name|idx
operator|+
literal|1
expr_stmt|;
block|}
comment|/** returns the number of 64 bit words it would take to hold numBits */
DECL|method|bits2words
specifier|public
specifier|static
name|int
name|bits2words
parameter_list|(
name|long
name|numBits
parameter_list|)
block|{
return|return
call|(
name|int
call|)
argument_list|(
operator|(
operator|(
name|numBits
operator|-
literal|1
operator|)
operator|>>>
literal|6
operator|)
operator|+
literal|1
argument_list|)
return|;
block|}
comment|/** returns true if both sets have the same bits set */
annotation|@
name|Override
DECL|method|equals
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
if|if
condition|(
name|this
operator|==
name|o
condition|)
return|return
literal|true
return|;
if|if
condition|(
operator|!
operator|(
name|o
operator|instanceof
name|OpenBitSet
operator|)
condition|)
return|return
literal|false
return|;
name|OpenBitSet
name|a
decl_stmt|;
name|OpenBitSet
name|b
init|=
operator|(
name|OpenBitSet
operator|)
name|o
decl_stmt|;
comment|// make a the larger set.
if|if
condition|(
name|b
operator|.
name|wlen
operator|>
name|this
operator|.
name|wlen
condition|)
block|{
name|a
operator|=
name|b
expr_stmt|;
name|b
operator|=
name|this
expr_stmt|;
block|}
else|else
block|{
name|a
operator|=
name|this
expr_stmt|;
block|}
comment|// check for any set bits out of the range of b
for|for
control|(
name|int
name|i
init|=
name|a
operator|.
name|wlen
operator|-
literal|1
init|;
name|i
operator|>=
name|b
operator|.
name|wlen
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|a
operator|.
name|bits
index|[
name|i
index|]
operator|!=
literal|0
condition|)
return|return
literal|false
return|;
block|}
for|for
control|(
name|int
name|i
init|=
name|b
operator|.
name|wlen
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|a
operator|.
name|bits
index|[
name|i
index|]
operator|!=
name|b
operator|.
name|bits
index|[
name|i
index|]
condition|)
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
annotation|@
name|Override
DECL|method|hashCode
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
comment|// Start with a zero hash and use a mix that results in zero if the input is zero.
comment|// This effectively truncates trailing zeros without an explicit check.
name|long
name|h
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|bits
operator|.
name|length
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
control|)
block|{
name|h
operator|^=
name|bits
index|[
name|i
index|]
expr_stmt|;
name|h
operator|=
operator|(
name|h
operator|<<
literal|1
operator|)
operator||
operator|(
name|h
operator|>>>
literal|63
operator|)
expr_stmt|;
comment|// rotate left
block|}
comment|// fold leftmost bits into right and add a constant to prevent
comment|// empty sets from returning 0, which is too common.
return|return
call|(
name|int
call|)
argument_list|(
operator|(
name|h
operator|>>
literal|32
operator|)
operator|^
name|h
argument_list|)
operator|+
literal|0x98761234
return|;
block|}
block|}
end_class
end_unit
