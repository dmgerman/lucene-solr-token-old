begin_unit
begin_package
DECL|package|org.apache.lucene.util.fst
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|fst
package|;
end_package
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|ArrayUtil
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|IntsRef
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|IntsRefBuilder
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|RamUsageEstimator
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|fst
operator|.
name|FST
operator|.
name|INPUT_TYPE
import|;
end_import
begin_comment
comment|// javadoc
end_comment
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|packed
operator|.
name|PackedInts
import|;
end_import
begin_comment
comment|// TODO: could we somehow stream an FST to disk while we
end_comment
begin_comment
comment|// build it?
end_comment
begin_comment
comment|/**  * Builds a minimal FST (maps an IntsRef term to an arbitrary  * output) from pre-sorted terms with outputs.  The FST  * becomes an FSA if you use NoOutputs.  The FST is written  * on-the-fly into a compact serialized format byte array, which can  * be saved to / loaded from a Directory or used directly  * for traversal.  The FST is always finite (no cycles).  *  *<p>NOTE: The algorithm is described at  * http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.24.3698</p>  *  *<p>The parameterized type T is the output type.  See the  * subclasses of {@link Outputs}.  *  *<p>FSTs larger than 2.1GB are now possible (as of Lucene  * 4.2).  FSTs containing more than 2.1B nodes are also now  * possible, however they cannot be packed.  *  * @lucene.experimental  */
end_comment
begin_class
DECL|class|Builder
specifier|public
class|class
name|Builder
parameter_list|<
name|T
parameter_list|>
block|{
DECL|field|dedupHash
specifier|private
specifier|final
name|NodeHash
argument_list|<
name|T
argument_list|>
name|dedupHash
decl_stmt|;
DECL|field|fst
specifier|final
name|FST
argument_list|<
name|T
argument_list|>
name|fst
decl_stmt|;
DECL|field|NO_OUTPUT
specifier|private
specifier|final
name|T
name|NO_OUTPUT
decl_stmt|;
comment|// private static final boolean DEBUG = true;
comment|// simplistic pruning: we prune node (and all following
comment|// nodes) if less than this number of terms go through it:
DECL|field|minSuffixCount1
specifier|private
specifier|final
name|int
name|minSuffixCount1
decl_stmt|;
comment|// better pruning: we prune node (and all following
comment|// nodes) if the prior node has less than this number of
comment|// terms go through it:
DECL|field|minSuffixCount2
specifier|private
specifier|final
name|int
name|minSuffixCount2
decl_stmt|;
DECL|field|doShareNonSingletonNodes
specifier|private
specifier|final
name|boolean
name|doShareNonSingletonNodes
decl_stmt|;
DECL|field|shareMaxTailLength
specifier|private
specifier|final
name|int
name|shareMaxTailLength
decl_stmt|;
DECL|field|lastInput
specifier|private
specifier|final
name|IntsRefBuilder
name|lastInput
init|=
operator|new
name|IntsRefBuilder
argument_list|()
decl_stmt|;
comment|// for packing
DECL|field|doPackFST
specifier|private
specifier|final
name|boolean
name|doPackFST
decl_stmt|;
DECL|field|acceptableOverheadRatio
specifier|private
specifier|final
name|float
name|acceptableOverheadRatio
decl_stmt|;
comment|// NOTE: cutting this over to ArrayList instead loses ~6%
comment|// in build performance on 9.8M Wikipedia terms; so we
comment|// left this as an array:
comment|// current "frontier"
DECL|field|frontier
specifier|private
name|UnCompiledNode
argument_list|<
name|T
argument_list|>
index|[]
name|frontier
decl_stmt|;
comment|// Used for the BIT_TARGET_NEXT optimization (whereby
comment|// instead of storing the address of the target node for
comment|// a given arc, we mark a single bit noting that the next
comment|// node in the byte[] is the target node):
DECL|field|lastFrozenNode
name|long
name|lastFrozenNode
decl_stmt|;
comment|// Reused temporarily while building the FST:
DECL|field|reusedBytesPerArc
name|int
index|[]
name|reusedBytesPerArc
init|=
operator|new
name|int
index|[
literal|4
index|]
decl_stmt|;
DECL|field|arcCount
name|long
name|arcCount
decl_stmt|;
DECL|field|nodeCount
name|long
name|nodeCount
decl_stmt|;
DECL|field|allowArrayArcs
name|boolean
name|allowArrayArcs
decl_stmt|;
DECL|field|bytes
name|BytesStore
name|bytes
decl_stmt|;
comment|/**    * Instantiates an FST/FSA builder without any pruning. A shortcut    * to {@link #Builder(FST.INPUT_TYPE, int, int, boolean,    * boolean, int, Outputs, boolean, float,    * boolean, int)} with pruning options turned off.    */
DECL|method|Builder
specifier|public
name|Builder
parameter_list|(
name|FST
operator|.
name|INPUT_TYPE
name|inputType
parameter_list|,
name|Outputs
argument_list|<
name|T
argument_list|>
name|outputs
parameter_list|)
block|{
name|this
argument_list|(
name|inputType
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|true
argument_list|,
literal|true
argument_list|,
name|Integer
operator|.
name|MAX_VALUE
argument_list|,
name|outputs
argument_list|,
literal|false
argument_list|,
name|PackedInts
operator|.
name|COMPACT
argument_list|,
literal|true
argument_list|,
literal|15
argument_list|)
expr_stmt|;
block|}
comment|/**    * Instantiates an FST/FSA builder with all the possible tuning and construction    * tweaks. Read parameter documentation carefully.    *     * @param inputType     *    The input type (transition labels). Can be anything from {@link INPUT_TYPE}    *    enumeration. Shorter types will consume less memory. Strings (character sequences) are     *    represented as {@link INPUT_TYPE#BYTE4} (full unicode codepoints).     *         * @param minSuffixCount1    *    If pruning the input graph during construction, this threshold is used for telling    *    if a node is kept or pruned. If transition_count(node)&gt;= minSuffixCount1, the node    *    is kept.     *        * @param minSuffixCount2    *    (Note: only Mike McCandless knows what this one is really doing...)     *     * @param doShareSuffix     *    If<code>true</code>, the shared suffixes will be compacted into unique paths.    *    This requires an additional RAM-intensive hash map for lookups in memory. Setting this parameter to    *<code>false</code> creates a single suffix path for all input sequences. This will result in a larger    *    FST, but requires substantially less memory and CPU during building.      *    * @param doShareNonSingletonNodes    *    Only used if doShareSuffix is true.  Set this to    *    true to ensure FST is fully minimal, at cost of more    *    CPU and more RAM during building.    *    * @param shareMaxTailLength    *    Only used if doShareSuffix is true.  Set this to    *    Integer.MAX_VALUE to ensure FST is fully minimal, at cost of more    *    CPU and more RAM during building.    *    * @param outputs The output type for each input sequence. Applies only if building an FST. For    *    FSA, use {@link NoOutputs#getSingleton()} and {@link NoOutputs#getNoOutput()} as the    *    singleton output object.    *    * @param doPackFST Pass true to create a packed FST.    *     * @param acceptableOverheadRatio How to trade speed for space when building the FST. This option    *    is only relevant when doPackFST is true. @see PackedInts#getMutable(int, int, float)    *    * @param allowArrayArcs Pass false to disable the array arc optimization    *    while building the FST; this will make the resulting    *    FST smaller but slower to traverse.    *    * @param bytesPageBits How many bits wide to make each    *    byte[] block in the BytesStore; if you know the FST    *    will be large then make this larger.  For example 15    *    bits = 32768 byte pages.    */
DECL|method|Builder
specifier|public
name|Builder
parameter_list|(
name|FST
operator|.
name|INPUT_TYPE
name|inputType
parameter_list|,
name|int
name|minSuffixCount1
parameter_list|,
name|int
name|minSuffixCount2
parameter_list|,
name|boolean
name|doShareSuffix
parameter_list|,
name|boolean
name|doShareNonSingletonNodes
parameter_list|,
name|int
name|shareMaxTailLength
parameter_list|,
name|Outputs
argument_list|<
name|T
argument_list|>
name|outputs
parameter_list|,
name|boolean
name|doPackFST
parameter_list|,
name|float
name|acceptableOverheadRatio
parameter_list|,
name|boolean
name|allowArrayArcs
parameter_list|,
name|int
name|bytesPageBits
parameter_list|)
block|{
name|this
operator|.
name|minSuffixCount1
operator|=
name|minSuffixCount1
expr_stmt|;
name|this
operator|.
name|minSuffixCount2
operator|=
name|minSuffixCount2
expr_stmt|;
name|this
operator|.
name|doShareNonSingletonNodes
operator|=
name|doShareNonSingletonNodes
expr_stmt|;
name|this
operator|.
name|shareMaxTailLength
operator|=
name|shareMaxTailLength
expr_stmt|;
name|this
operator|.
name|doPackFST
operator|=
name|doPackFST
expr_stmt|;
name|this
operator|.
name|acceptableOverheadRatio
operator|=
name|acceptableOverheadRatio
expr_stmt|;
name|this
operator|.
name|allowArrayArcs
operator|=
name|allowArrayArcs
expr_stmt|;
name|fst
operator|=
operator|new
name|FST
argument_list|<>
argument_list|(
name|inputType
argument_list|,
name|outputs
argument_list|,
name|doPackFST
argument_list|,
name|acceptableOverheadRatio
argument_list|,
name|bytesPageBits
argument_list|)
expr_stmt|;
name|bytes
operator|=
name|fst
operator|.
name|bytes
expr_stmt|;
assert|assert
name|bytes
operator|!=
literal|null
assert|;
if|if
condition|(
name|doShareSuffix
condition|)
block|{
name|dedupHash
operator|=
operator|new
name|NodeHash
argument_list|<>
argument_list|(
name|fst
argument_list|,
name|bytes
operator|.
name|getReverseReader
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dedupHash
operator|=
literal|null
expr_stmt|;
block|}
name|NO_OUTPUT
operator|=
name|outputs
operator|.
name|getNoOutput
argument_list|()
expr_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
block|{
literal|"rawtypes"
block|,
literal|"unchecked"
block|}
argument_list|)
specifier|final
name|UnCompiledNode
argument_list|<
name|T
argument_list|>
index|[]
name|f
init|=
operator|(
name|UnCompiledNode
argument_list|<
name|T
argument_list|>
index|[]
operator|)
operator|new
name|UnCompiledNode
index|[
literal|10
index|]
decl_stmt|;
name|frontier
operator|=
name|f
expr_stmt|;
for|for
control|(
name|int
name|idx
init|=
literal|0
init|;
name|idx
operator|<
name|frontier
operator|.
name|length
condition|;
name|idx
operator|++
control|)
block|{
name|frontier
index|[
name|idx
index|]
operator|=
operator|new
name|UnCompiledNode
argument_list|<>
argument_list|(
name|this
argument_list|,
name|idx
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|getTermCount
specifier|public
name|long
name|getTermCount
parameter_list|()
block|{
return|return
name|frontier
index|[
literal|0
index|]
operator|.
name|inputCount
return|;
block|}
DECL|method|getNodeCount
specifier|public
name|long
name|getNodeCount
parameter_list|()
block|{
comment|// 1+ in order to count the -1 implicit final node
return|return
literal|1
operator|+
name|nodeCount
return|;
block|}
DECL|method|getArcCount
specifier|public
name|long
name|getArcCount
parameter_list|()
block|{
return|return
name|arcCount
return|;
block|}
DECL|method|getMappedStateCount
specifier|public
name|long
name|getMappedStateCount
parameter_list|()
block|{
return|return
name|dedupHash
operator|==
literal|null
condition|?
literal|0
else|:
name|nodeCount
return|;
block|}
DECL|method|compileNode
specifier|private
name|CompiledNode
name|compileNode
parameter_list|(
name|UnCompiledNode
argument_list|<
name|T
argument_list|>
name|nodeIn
parameter_list|,
name|int
name|tailLength
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|long
name|node
decl_stmt|;
name|long
name|bytesPosStart
init|=
name|bytes
operator|.
name|getPosition
argument_list|()
decl_stmt|;
if|if
condition|(
name|dedupHash
operator|!=
literal|null
operator|&&
operator|(
name|doShareNonSingletonNodes
operator|||
name|nodeIn
operator|.
name|numArcs
operator|<=
literal|1
operator|)
operator|&&
name|tailLength
operator|<=
name|shareMaxTailLength
condition|)
block|{
if|if
condition|(
name|nodeIn
operator|.
name|numArcs
operator|==
literal|0
condition|)
block|{
name|node
operator|=
name|fst
operator|.
name|addNode
argument_list|(
name|this
argument_list|,
name|nodeIn
argument_list|)
expr_stmt|;
name|lastFrozenNode
operator|=
name|node
expr_stmt|;
block|}
else|else
block|{
name|node
operator|=
name|dedupHash
operator|.
name|add
argument_list|(
name|this
argument_list|,
name|nodeIn
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|node
operator|=
name|fst
operator|.
name|addNode
argument_list|(
name|this
argument_list|,
name|nodeIn
argument_list|)
expr_stmt|;
block|}
assert|assert
name|node
operator|!=
operator|-
literal|2
assert|;
name|long
name|bytesPosEnd
init|=
name|bytes
operator|.
name|getPosition
argument_list|()
decl_stmt|;
if|if
condition|(
name|bytesPosEnd
operator|!=
name|bytesPosStart
condition|)
block|{
comment|// The FST added a new node:
assert|assert
name|bytesPosEnd
operator|>
name|bytesPosStart
assert|;
name|lastFrozenNode
operator|=
name|node
expr_stmt|;
block|}
name|nodeIn
operator|.
name|clear
argument_list|()
expr_stmt|;
specifier|final
name|CompiledNode
name|fn
init|=
operator|new
name|CompiledNode
argument_list|()
decl_stmt|;
name|fn
operator|.
name|node
operator|=
name|node
expr_stmt|;
return|return
name|fn
return|;
block|}
DECL|method|freezeTail
specifier|private
name|void
name|freezeTail
parameter_list|(
name|int
name|prefixLenPlus1
parameter_list|)
throws|throws
name|IOException
block|{
comment|//System.out.println("  compileTail " + prefixLenPlus1);
specifier|final
name|int
name|downTo
init|=
name|Math
operator|.
name|max
argument_list|(
literal|1
argument_list|,
name|prefixLenPlus1
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|idx
init|=
name|lastInput
operator|.
name|length
argument_list|()
init|;
name|idx
operator|>=
name|downTo
condition|;
name|idx
operator|--
control|)
block|{
name|boolean
name|doPrune
init|=
literal|false
decl_stmt|;
name|boolean
name|doCompile
init|=
literal|false
decl_stmt|;
specifier|final
name|UnCompiledNode
argument_list|<
name|T
argument_list|>
name|node
init|=
name|frontier
index|[
name|idx
index|]
decl_stmt|;
specifier|final
name|UnCompiledNode
argument_list|<
name|T
argument_list|>
name|parent
init|=
name|frontier
index|[
name|idx
operator|-
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|node
operator|.
name|inputCount
operator|<
name|minSuffixCount1
condition|)
block|{
name|doPrune
operator|=
literal|true
expr_stmt|;
name|doCompile
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|idx
operator|>
name|prefixLenPlus1
condition|)
block|{
comment|// prune if parent's inputCount is less than suffixMinCount2
if|if
condition|(
name|parent
operator|.
name|inputCount
operator|<
name|minSuffixCount2
operator|||
operator|(
name|minSuffixCount2
operator|==
literal|1
operator|&&
name|parent
operator|.
name|inputCount
operator|==
literal|1
operator|&&
name|idx
operator|>
literal|1
operator|)
condition|)
block|{
comment|// my parent, about to be compiled, doesn't make the cut, so
comment|// I'm definitely pruned
comment|// if minSuffixCount2 is 1, we keep only up
comment|// until the 'distinguished edge', ie we keep only the
comment|// 'divergent' part of the FST. if my parent, about to be
comment|// compiled, has inputCount 1 then we are already past the
comment|// distinguished edge.  NOTE: this only works if
comment|// the FST outputs are not "compressible" (simple
comment|// ords ARE compressible).
name|doPrune
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
comment|// my parent, about to be compiled, does make the cut, so
comment|// I'm definitely not pruned
name|doPrune
operator|=
literal|false
expr_stmt|;
block|}
name|doCompile
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
comment|// if pruning is disabled (count is 0) we can always
comment|// compile current node
name|doCompile
operator|=
name|minSuffixCount2
operator|==
literal|0
expr_stmt|;
block|}
comment|//System.out.println("    label=" + ((char) lastInput.ints[lastInput.offset+idx-1]) + " idx=" + idx + " inputCount=" + frontier[idx].inputCount + " doCompile=" + doCompile + " doPrune=" + doPrune);
if|if
condition|(
name|node
operator|.
name|inputCount
operator|<
name|minSuffixCount2
operator|||
operator|(
name|minSuffixCount2
operator|==
literal|1
operator|&&
name|node
operator|.
name|inputCount
operator|==
literal|1
operator|&&
name|idx
operator|>
literal|1
operator|)
condition|)
block|{
comment|// drop all arcs
for|for
control|(
name|int
name|arcIdx
init|=
literal|0
init|;
name|arcIdx
operator|<
name|node
operator|.
name|numArcs
condition|;
name|arcIdx
operator|++
control|)
block|{
annotation|@
name|SuppressWarnings
argument_list|(
block|{
literal|"rawtypes"
block|,
literal|"unchecked"
block|}
argument_list|)
specifier|final
name|UnCompiledNode
argument_list|<
name|T
argument_list|>
name|target
init|=
operator|(
name|UnCompiledNode
argument_list|<
name|T
argument_list|>
operator|)
name|node
operator|.
name|arcs
index|[
name|arcIdx
index|]
operator|.
name|target
decl_stmt|;
name|target
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
name|node
operator|.
name|numArcs
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|doPrune
condition|)
block|{
comment|// this node doesn't make it -- deref it
name|node
operator|.
name|clear
argument_list|()
expr_stmt|;
name|parent
operator|.
name|deleteLast
argument_list|(
name|lastInput
operator|.
name|intAt
argument_list|(
name|idx
operator|-
literal|1
argument_list|)
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|minSuffixCount2
operator|!=
literal|0
condition|)
block|{
name|compileAllTargets
argument_list|(
name|node
argument_list|,
name|lastInput
operator|.
name|length
argument_list|()
operator|-
name|idx
argument_list|)
expr_stmt|;
block|}
specifier|final
name|T
name|nextFinalOutput
init|=
name|node
operator|.
name|output
decl_stmt|;
comment|// We "fake" the node as being final if it has no
comment|// outgoing arcs; in theory we could leave it
comment|// as non-final (the FST can represent this), but
comment|// FSTEnum, Util, etc., have trouble w/ non-final
comment|// dead-end states:
specifier|final
name|boolean
name|isFinal
init|=
name|node
operator|.
name|isFinal
operator|||
name|node
operator|.
name|numArcs
operator|==
literal|0
decl_stmt|;
if|if
condition|(
name|doCompile
condition|)
block|{
comment|// this node makes it and we now compile it.  first,
comment|// compile any targets that were previously
comment|// undecided:
name|parent
operator|.
name|replaceLast
argument_list|(
name|lastInput
operator|.
name|intAt
argument_list|(
name|idx
operator|-
literal|1
argument_list|)
argument_list|,
name|compileNode
argument_list|(
name|node
argument_list|,
literal|1
operator|+
name|lastInput
operator|.
name|length
argument_list|()
operator|-
name|idx
argument_list|)
argument_list|,
name|nextFinalOutput
argument_list|,
name|isFinal
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// replaceLast just to install
comment|// nextFinalOutput/isFinal onto the arc
name|parent
operator|.
name|replaceLast
argument_list|(
name|lastInput
operator|.
name|intAt
argument_list|(
name|idx
operator|-
literal|1
argument_list|)
argument_list|,
name|node
argument_list|,
name|nextFinalOutput
argument_list|,
name|isFinal
argument_list|)
expr_stmt|;
comment|// this node will stay in play for now, since we are
comment|// undecided on whether to prune it.  later, it
comment|// will be either compiled or pruned, so we must
comment|// allocate a new node:
name|frontier
index|[
name|idx
index|]
operator|=
operator|new
name|UnCompiledNode
argument_list|<>
argument_list|(
name|this
argument_list|,
name|idx
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|// for debugging
comment|/*   private String toString(BytesRef b) {     try {       return b.utf8ToString() + " " + b;     } catch (Throwable t) {       return b.toString();     }   }   */
comment|/** Add the next input/output pair.  The provided input    *  must be sorted after the previous one according to    *  {@link IntsRef#compareTo}.  It's also OK to add the same    *  input twice in a row with different outputs, as long    *  as {@link Outputs} implements the {@link Outputs#merge}    *  method. Note that input is fully consumed after this    *  method is returned (so caller is free to reuse), but    *  output is not.  So if your outputs are changeable (eg    *  {@link ByteSequenceOutputs} or {@link    *  IntSequenceOutputs}) then you cannot reuse across    *  calls. */
DECL|method|add
specifier|public
name|void
name|add
parameter_list|(
name|IntsRef
name|input
parameter_list|,
name|T
name|output
parameter_list|)
throws|throws
name|IOException
block|{
comment|/*     if (DEBUG) {       BytesRef b = new BytesRef(input.length);       for(int x=0;x<input.length;x++) {         b.bytes[x] = (byte) input.ints[x];       }       b.length = input.length;       if (output == NO_OUTPUT) {         System.out.println("\nFST ADD: input=" + toString(b) + " " + b);       } else {         System.out.println("\nFST ADD: input=" + toString(b) + " " + b + " output=" + fst.outputs.outputToString(output));       }     }     */
comment|// De-dup NO_OUTPUT since it must be a singleton:
if|if
condition|(
name|output
operator|.
name|equals
argument_list|(
name|NO_OUTPUT
argument_list|)
condition|)
block|{
name|output
operator|=
name|NO_OUTPUT
expr_stmt|;
block|}
assert|assert
name|lastInput
operator|.
name|length
argument_list|()
operator|==
literal|0
operator|||
name|input
operator|.
name|compareTo
argument_list|(
name|lastInput
operator|.
name|get
argument_list|()
argument_list|)
operator|>=
literal|0
operator|:
literal|"inputs are added out of order lastInput="
operator|+
name|lastInput
operator|.
name|get
argument_list|()
operator|+
literal|" vs input="
operator|+
name|input
assert|;
assert|assert
name|validOutput
argument_list|(
name|output
argument_list|)
assert|;
comment|//System.out.println("\nadd: " + input);
if|if
condition|(
name|input
operator|.
name|length
operator|==
literal|0
condition|)
block|{
comment|// empty input: only allowed as first input.  we have
comment|// to special case this because the packed FST
comment|// format cannot represent the empty input since
comment|// 'finalness' is stored on the incoming arc, not on
comment|// the node
name|frontier
index|[
literal|0
index|]
operator|.
name|inputCount
operator|++
expr_stmt|;
name|frontier
index|[
literal|0
index|]
operator|.
name|isFinal
operator|=
literal|true
expr_stmt|;
name|fst
operator|.
name|setEmptyOutput
argument_list|(
name|output
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// compare shared prefix length
name|int
name|pos1
init|=
literal|0
decl_stmt|;
name|int
name|pos2
init|=
name|input
operator|.
name|offset
decl_stmt|;
specifier|final
name|int
name|pos1Stop
init|=
name|Math
operator|.
name|min
argument_list|(
name|lastInput
operator|.
name|length
argument_list|()
argument_list|,
name|input
operator|.
name|length
argument_list|)
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|frontier
index|[
name|pos1
index|]
operator|.
name|inputCount
operator|++
expr_stmt|;
comment|//System.out.println("  incr " + pos1 + " ct=" + frontier[pos1].inputCount + " n=" + frontier[pos1]);
if|if
condition|(
name|pos1
operator|>=
name|pos1Stop
operator|||
name|lastInput
operator|.
name|intAt
argument_list|(
name|pos1
argument_list|)
operator|!=
name|input
operator|.
name|ints
index|[
name|pos2
index|]
condition|)
block|{
break|break;
block|}
name|pos1
operator|++
expr_stmt|;
name|pos2
operator|++
expr_stmt|;
block|}
specifier|final
name|int
name|prefixLenPlus1
init|=
name|pos1
operator|+
literal|1
decl_stmt|;
if|if
condition|(
name|frontier
operator|.
name|length
operator|<
name|input
operator|.
name|length
operator|+
literal|1
condition|)
block|{
annotation|@
name|SuppressWarnings
argument_list|(
block|{
literal|"rawtypes"
block|,
literal|"unchecked"
block|}
argument_list|)
specifier|final
name|UnCompiledNode
argument_list|<
name|T
argument_list|>
index|[]
name|next
init|=
operator|new
name|UnCompiledNode
index|[
name|ArrayUtil
operator|.
name|oversize
argument_list|(
name|input
operator|.
name|length
operator|+
literal|1
argument_list|,
name|RamUsageEstimator
operator|.
name|NUM_BYTES_OBJECT_REF
argument_list|)
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|frontier
argument_list|,
literal|0
argument_list|,
name|next
argument_list|,
literal|0
argument_list|,
name|frontier
operator|.
name|length
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|idx
init|=
name|frontier
operator|.
name|length
init|;
name|idx
operator|<
name|next
operator|.
name|length
condition|;
name|idx
operator|++
control|)
block|{
name|next
index|[
name|idx
index|]
operator|=
operator|new
name|UnCompiledNode
argument_list|<>
argument_list|(
name|this
argument_list|,
name|idx
argument_list|)
expr_stmt|;
block|}
name|frontier
operator|=
name|next
expr_stmt|;
block|}
comment|// minimize/compile states from previous input's
comment|// orphan'd suffix
name|freezeTail
argument_list|(
name|prefixLenPlus1
argument_list|)
expr_stmt|;
comment|// init tail states for current input
for|for
control|(
name|int
name|idx
init|=
name|prefixLenPlus1
init|;
name|idx
operator|<=
name|input
operator|.
name|length
condition|;
name|idx
operator|++
control|)
block|{
name|frontier
index|[
name|idx
operator|-
literal|1
index|]
operator|.
name|addArc
argument_list|(
name|input
operator|.
name|ints
index|[
name|input
operator|.
name|offset
operator|+
name|idx
operator|-
literal|1
index|]
argument_list|,
name|frontier
index|[
name|idx
index|]
argument_list|)
expr_stmt|;
name|frontier
index|[
name|idx
index|]
operator|.
name|inputCount
operator|++
expr_stmt|;
block|}
specifier|final
name|UnCompiledNode
argument_list|<
name|T
argument_list|>
name|lastNode
init|=
name|frontier
index|[
name|input
operator|.
name|length
index|]
decl_stmt|;
if|if
condition|(
name|lastInput
operator|.
name|length
argument_list|()
operator|!=
name|input
operator|.
name|length
operator|||
name|prefixLenPlus1
operator|!=
name|input
operator|.
name|length
operator|+
literal|1
condition|)
block|{
name|lastNode
operator|.
name|isFinal
operator|=
literal|true
expr_stmt|;
name|lastNode
operator|.
name|output
operator|=
name|NO_OUTPUT
expr_stmt|;
block|}
comment|// push conflicting outputs forward, only as far as
comment|// needed
for|for
control|(
name|int
name|idx
init|=
literal|1
init|;
name|idx
operator|<
name|prefixLenPlus1
condition|;
name|idx
operator|++
control|)
block|{
specifier|final
name|UnCompiledNode
argument_list|<
name|T
argument_list|>
name|node
init|=
name|frontier
index|[
name|idx
index|]
decl_stmt|;
specifier|final
name|UnCompiledNode
argument_list|<
name|T
argument_list|>
name|parentNode
init|=
name|frontier
index|[
name|idx
operator|-
literal|1
index|]
decl_stmt|;
specifier|final
name|T
name|lastOutput
init|=
name|parentNode
operator|.
name|getLastOutput
argument_list|(
name|input
operator|.
name|ints
index|[
name|input
operator|.
name|offset
operator|+
name|idx
operator|-
literal|1
index|]
argument_list|)
decl_stmt|;
assert|assert
name|validOutput
argument_list|(
name|lastOutput
argument_list|)
assert|;
specifier|final
name|T
name|commonOutputPrefix
decl_stmt|;
specifier|final
name|T
name|wordSuffix
decl_stmt|;
if|if
condition|(
name|lastOutput
operator|!=
name|NO_OUTPUT
condition|)
block|{
name|commonOutputPrefix
operator|=
name|fst
operator|.
name|outputs
operator|.
name|common
argument_list|(
name|output
argument_list|,
name|lastOutput
argument_list|)
expr_stmt|;
assert|assert
name|validOutput
argument_list|(
name|commonOutputPrefix
argument_list|)
assert|;
name|wordSuffix
operator|=
name|fst
operator|.
name|outputs
operator|.
name|subtract
argument_list|(
name|lastOutput
argument_list|,
name|commonOutputPrefix
argument_list|)
expr_stmt|;
assert|assert
name|validOutput
argument_list|(
name|wordSuffix
argument_list|)
assert|;
name|parentNode
operator|.
name|setLastOutput
argument_list|(
name|input
operator|.
name|ints
index|[
name|input
operator|.
name|offset
operator|+
name|idx
operator|-
literal|1
index|]
argument_list|,
name|commonOutputPrefix
argument_list|)
expr_stmt|;
name|node
operator|.
name|prependOutput
argument_list|(
name|wordSuffix
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|commonOutputPrefix
operator|=
name|wordSuffix
operator|=
name|NO_OUTPUT
expr_stmt|;
block|}
name|output
operator|=
name|fst
operator|.
name|outputs
operator|.
name|subtract
argument_list|(
name|output
argument_list|,
name|commonOutputPrefix
argument_list|)
expr_stmt|;
assert|assert
name|validOutput
argument_list|(
name|output
argument_list|)
assert|;
block|}
if|if
condition|(
name|lastInput
operator|.
name|length
argument_list|()
operator|==
name|input
operator|.
name|length
operator|&&
name|prefixLenPlus1
operator|==
literal|1
operator|+
name|input
operator|.
name|length
condition|)
block|{
comment|// same input more than 1 time in a row, mapping to
comment|// multiple outputs
name|lastNode
operator|.
name|output
operator|=
name|fst
operator|.
name|outputs
operator|.
name|merge
argument_list|(
name|lastNode
operator|.
name|output
argument_list|,
name|output
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// this new arc is private to this new input; set its
comment|// arc output to the leftover output:
name|frontier
index|[
name|prefixLenPlus1
operator|-
literal|1
index|]
operator|.
name|setLastOutput
argument_list|(
name|input
operator|.
name|ints
index|[
name|input
operator|.
name|offset
operator|+
name|prefixLenPlus1
operator|-
literal|1
index|]
argument_list|,
name|output
argument_list|)
expr_stmt|;
block|}
comment|// save last input
name|lastInput
operator|.
name|copyInts
argument_list|(
name|input
argument_list|)
expr_stmt|;
comment|//System.out.println("  count[0]=" + frontier[0].inputCount);
block|}
DECL|method|validOutput
specifier|private
name|boolean
name|validOutput
parameter_list|(
name|T
name|output
parameter_list|)
block|{
return|return
name|output
operator|==
name|NO_OUTPUT
operator|||
operator|!
name|output
operator|.
name|equals
argument_list|(
name|NO_OUTPUT
argument_list|)
return|;
block|}
comment|/** Returns final FST.  NOTE: this will return null if    *  nothing is accepted by the FST. */
DECL|method|finish
specifier|public
name|FST
argument_list|<
name|T
argument_list|>
name|finish
parameter_list|()
throws|throws
name|IOException
block|{
specifier|final
name|UnCompiledNode
argument_list|<
name|T
argument_list|>
name|root
init|=
name|frontier
index|[
literal|0
index|]
decl_stmt|;
comment|// minimize nodes in the last word's suffix
name|freezeTail
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|root
operator|.
name|inputCount
operator|<
name|minSuffixCount1
operator|||
name|root
operator|.
name|inputCount
operator|<
name|minSuffixCount2
operator|||
name|root
operator|.
name|numArcs
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|fst
operator|.
name|emptyOutput
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
elseif|else
if|if
condition|(
name|minSuffixCount1
operator|>
literal|0
operator|||
name|minSuffixCount2
operator|>
literal|0
condition|)
block|{
comment|// empty string got pruned
return|return
literal|null
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|minSuffixCount2
operator|!=
literal|0
condition|)
block|{
name|compileAllTargets
argument_list|(
name|root
argument_list|,
name|lastInput
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|//if (DEBUG) System.out.println("  builder.finish root.isFinal=" + root.isFinal + " root.output=" + root.output);
name|fst
operator|.
name|finish
argument_list|(
name|compileNode
argument_list|(
name|root
argument_list|,
name|lastInput
operator|.
name|length
argument_list|()
argument_list|)
operator|.
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|doPackFST
condition|)
block|{
return|return
name|fst
operator|.
name|pack
argument_list|(
name|this
argument_list|,
literal|3
argument_list|,
name|Math
operator|.
name|max
argument_list|(
literal|10
argument_list|,
call|(
name|int
call|)
argument_list|(
name|getNodeCount
argument_list|()
operator|/
literal|4
argument_list|)
argument_list|)
argument_list|,
name|acceptableOverheadRatio
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|fst
return|;
block|}
block|}
DECL|method|compileAllTargets
specifier|private
name|void
name|compileAllTargets
parameter_list|(
name|UnCompiledNode
argument_list|<
name|T
argument_list|>
name|node
parameter_list|,
name|int
name|tailLength
parameter_list|)
throws|throws
name|IOException
block|{
for|for
control|(
name|int
name|arcIdx
init|=
literal|0
init|;
name|arcIdx
operator|<
name|node
operator|.
name|numArcs
condition|;
name|arcIdx
operator|++
control|)
block|{
specifier|final
name|Arc
argument_list|<
name|T
argument_list|>
name|arc
init|=
name|node
operator|.
name|arcs
index|[
name|arcIdx
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|arc
operator|.
name|target
operator|.
name|isCompiled
argument_list|()
condition|)
block|{
comment|// not yet compiled
annotation|@
name|SuppressWarnings
argument_list|(
block|{
literal|"rawtypes"
block|,
literal|"unchecked"
block|}
argument_list|)
specifier|final
name|UnCompiledNode
argument_list|<
name|T
argument_list|>
name|n
init|=
operator|(
name|UnCompiledNode
argument_list|<
name|T
argument_list|>
operator|)
name|arc
operator|.
name|target
decl_stmt|;
if|if
condition|(
name|n
operator|.
name|numArcs
operator|==
literal|0
condition|)
block|{
comment|//System.out.println("seg=" + segment + "        FORCE final arc=" + (char) arc.label);
name|arc
operator|.
name|isFinal
operator|=
name|n
operator|.
name|isFinal
operator|=
literal|true
expr_stmt|;
block|}
name|arc
operator|.
name|target
operator|=
name|compileNode
argument_list|(
name|n
argument_list|,
name|tailLength
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/** Expert: holds a pending (seen but not yet serialized) arc. */
DECL|class|Arc
specifier|public
specifier|static
class|class
name|Arc
parameter_list|<
name|T
parameter_list|>
block|{
DECL|field|label
specifier|public
name|int
name|label
decl_stmt|;
comment|// really an "unsigned" byte
DECL|field|target
specifier|public
name|Node
name|target
decl_stmt|;
DECL|field|isFinal
specifier|public
name|boolean
name|isFinal
decl_stmt|;
DECL|field|output
specifier|public
name|T
name|output
decl_stmt|;
DECL|field|nextFinalOutput
specifier|public
name|T
name|nextFinalOutput
decl_stmt|;
block|}
comment|// NOTE: not many instances of Node or CompiledNode are in
comment|// memory while the FST is being built; it's only the
comment|// current "frontier":
DECL|interface|Node
specifier|static
interface|interface
name|Node
block|{
DECL|method|isCompiled
name|boolean
name|isCompiled
parameter_list|()
function_decl|;
block|}
DECL|method|fstRamBytesUsed
specifier|public
name|long
name|fstRamBytesUsed
parameter_list|()
block|{
return|return
name|fst
operator|.
name|ramBytesUsed
argument_list|()
return|;
block|}
DECL|class|CompiledNode
specifier|static
specifier|final
class|class
name|CompiledNode
implements|implements
name|Node
block|{
DECL|field|node
name|long
name|node
decl_stmt|;
annotation|@
name|Override
DECL|method|isCompiled
specifier|public
name|boolean
name|isCompiled
parameter_list|()
block|{
return|return
literal|true
return|;
block|}
block|}
comment|/** Expert: holds a pending (seen but not yet serialized) Node. */
DECL|class|UnCompiledNode
specifier|public
specifier|static
specifier|final
class|class
name|UnCompiledNode
parameter_list|<
name|T
parameter_list|>
implements|implements
name|Node
block|{
DECL|field|owner
specifier|final
name|Builder
argument_list|<
name|T
argument_list|>
name|owner
decl_stmt|;
DECL|field|numArcs
specifier|public
name|int
name|numArcs
decl_stmt|;
DECL|field|arcs
specifier|public
name|Arc
argument_list|<
name|T
argument_list|>
index|[]
name|arcs
decl_stmt|;
comment|// TODO: instead of recording isFinal/output on the
comment|// node, maybe we should use -1 arc to mean "end" (like
comment|// we do when reading the FST).  Would simplify much
comment|// code here...
DECL|field|output
specifier|public
name|T
name|output
decl_stmt|;
DECL|field|isFinal
specifier|public
name|boolean
name|isFinal
decl_stmt|;
DECL|field|inputCount
specifier|public
name|long
name|inputCount
decl_stmt|;
comment|/** This node's depth, starting from the automaton root. */
DECL|field|depth
specifier|public
specifier|final
name|int
name|depth
decl_stmt|;
comment|/**      * @param depth      *          The node's depth starting from the automaton root. Needed for      *          LUCENE-2934 (node expansion based on conditions other than the      *          fanout size).      */
annotation|@
name|SuppressWarnings
argument_list|(
block|{
literal|"rawtypes"
block|,
literal|"unchecked"
block|}
argument_list|)
DECL|method|UnCompiledNode
specifier|public
name|UnCompiledNode
parameter_list|(
name|Builder
argument_list|<
name|T
argument_list|>
name|owner
parameter_list|,
name|int
name|depth
parameter_list|)
block|{
name|this
operator|.
name|owner
operator|=
name|owner
expr_stmt|;
name|arcs
operator|=
operator|(
name|Arc
argument_list|<
name|T
argument_list|>
index|[]
operator|)
operator|new
name|Arc
index|[
literal|1
index|]
expr_stmt|;
name|arcs
index|[
literal|0
index|]
operator|=
operator|new
name|Arc
argument_list|<>
argument_list|()
expr_stmt|;
name|output
operator|=
name|owner
operator|.
name|NO_OUTPUT
expr_stmt|;
name|this
operator|.
name|depth
operator|=
name|depth
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|isCompiled
specifier|public
name|boolean
name|isCompiled
parameter_list|()
block|{
return|return
literal|false
return|;
block|}
DECL|method|clear
specifier|public
name|void
name|clear
parameter_list|()
block|{
name|numArcs
operator|=
literal|0
expr_stmt|;
name|isFinal
operator|=
literal|false
expr_stmt|;
name|output
operator|=
name|owner
operator|.
name|NO_OUTPUT
expr_stmt|;
name|inputCount
operator|=
literal|0
expr_stmt|;
comment|// We don't clear the depth here because it never changes
comment|// for nodes on the frontier (even when reused).
block|}
DECL|method|getLastOutput
specifier|public
name|T
name|getLastOutput
parameter_list|(
name|int
name|labelToMatch
parameter_list|)
block|{
assert|assert
name|numArcs
operator|>
literal|0
assert|;
assert|assert
name|arcs
index|[
name|numArcs
operator|-
literal|1
index|]
operator|.
name|label
operator|==
name|labelToMatch
assert|;
return|return
name|arcs
index|[
name|numArcs
operator|-
literal|1
index|]
operator|.
name|output
return|;
block|}
DECL|method|addArc
specifier|public
name|void
name|addArc
parameter_list|(
name|int
name|label
parameter_list|,
name|Node
name|target
parameter_list|)
block|{
assert|assert
name|label
operator|>=
literal|0
assert|;
assert|assert
name|numArcs
operator|==
literal|0
operator|||
name|label
operator|>
name|arcs
index|[
name|numArcs
operator|-
literal|1
index|]
operator|.
name|label
operator|:
literal|"arc[-1].label="
operator|+
name|arcs
index|[
name|numArcs
operator|-
literal|1
index|]
operator|.
name|label
operator|+
literal|" new label="
operator|+
name|label
operator|+
literal|" numArcs="
operator|+
name|numArcs
assert|;
if|if
condition|(
name|numArcs
operator|==
name|arcs
operator|.
name|length
condition|)
block|{
annotation|@
name|SuppressWarnings
argument_list|(
block|{
literal|"rawtypes"
block|,
literal|"unchecked"
block|}
argument_list|)
specifier|final
name|Arc
argument_list|<
name|T
argument_list|>
index|[]
name|newArcs
init|=
operator|new
name|Arc
index|[
name|ArrayUtil
operator|.
name|oversize
argument_list|(
name|numArcs
operator|+
literal|1
argument_list|,
name|RamUsageEstimator
operator|.
name|NUM_BYTES_OBJECT_REF
argument_list|)
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|arcs
argument_list|,
literal|0
argument_list|,
name|newArcs
argument_list|,
literal|0
argument_list|,
name|arcs
operator|.
name|length
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|arcIdx
init|=
name|numArcs
init|;
name|arcIdx
operator|<
name|newArcs
operator|.
name|length
condition|;
name|arcIdx
operator|++
control|)
block|{
name|newArcs
index|[
name|arcIdx
index|]
operator|=
operator|new
name|Arc
argument_list|<>
argument_list|()
expr_stmt|;
block|}
name|arcs
operator|=
name|newArcs
expr_stmt|;
block|}
specifier|final
name|Arc
argument_list|<
name|T
argument_list|>
name|arc
init|=
name|arcs
index|[
name|numArcs
operator|++
index|]
decl_stmt|;
name|arc
operator|.
name|label
operator|=
name|label
expr_stmt|;
name|arc
operator|.
name|target
operator|=
name|target
expr_stmt|;
name|arc
operator|.
name|output
operator|=
name|arc
operator|.
name|nextFinalOutput
operator|=
name|owner
operator|.
name|NO_OUTPUT
expr_stmt|;
name|arc
operator|.
name|isFinal
operator|=
literal|false
expr_stmt|;
block|}
DECL|method|replaceLast
specifier|public
name|void
name|replaceLast
parameter_list|(
name|int
name|labelToMatch
parameter_list|,
name|Node
name|target
parameter_list|,
name|T
name|nextFinalOutput
parameter_list|,
name|boolean
name|isFinal
parameter_list|)
block|{
assert|assert
name|numArcs
operator|>
literal|0
assert|;
specifier|final
name|Arc
argument_list|<
name|T
argument_list|>
name|arc
init|=
name|arcs
index|[
name|numArcs
operator|-
literal|1
index|]
decl_stmt|;
assert|assert
name|arc
operator|.
name|label
operator|==
name|labelToMatch
operator|:
literal|"arc.label="
operator|+
name|arc
operator|.
name|label
operator|+
literal|" vs "
operator|+
name|labelToMatch
assert|;
name|arc
operator|.
name|target
operator|=
name|target
expr_stmt|;
comment|//assert target.node != -2;
name|arc
operator|.
name|nextFinalOutput
operator|=
name|nextFinalOutput
expr_stmt|;
name|arc
operator|.
name|isFinal
operator|=
name|isFinal
expr_stmt|;
block|}
DECL|method|deleteLast
specifier|public
name|void
name|deleteLast
parameter_list|(
name|int
name|label
parameter_list|,
name|Node
name|target
parameter_list|)
block|{
assert|assert
name|numArcs
operator|>
literal|0
assert|;
assert|assert
name|label
operator|==
name|arcs
index|[
name|numArcs
operator|-
literal|1
index|]
operator|.
name|label
assert|;
assert|assert
name|target
operator|==
name|arcs
index|[
name|numArcs
operator|-
literal|1
index|]
operator|.
name|target
assert|;
name|numArcs
operator|--
expr_stmt|;
block|}
DECL|method|setLastOutput
specifier|public
name|void
name|setLastOutput
parameter_list|(
name|int
name|labelToMatch
parameter_list|,
name|T
name|newOutput
parameter_list|)
block|{
assert|assert
name|owner
operator|.
name|validOutput
argument_list|(
name|newOutput
argument_list|)
assert|;
assert|assert
name|numArcs
operator|>
literal|0
assert|;
specifier|final
name|Arc
argument_list|<
name|T
argument_list|>
name|arc
init|=
name|arcs
index|[
name|numArcs
operator|-
literal|1
index|]
decl_stmt|;
assert|assert
name|arc
operator|.
name|label
operator|==
name|labelToMatch
assert|;
name|arc
operator|.
name|output
operator|=
name|newOutput
expr_stmt|;
block|}
comment|// pushes an output prefix forward onto all arcs
DECL|method|prependOutput
specifier|public
name|void
name|prependOutput
parameter_list|(
name|T
name|outputPrefix
parameter_list|)
block|{
assert|assert
name|owner
operator|.
name|validOutput
argument_list|(
name|outputPrefix
argument_list|)
assert|;
for|for
control|(
name|int
name|arcIdx
init|=
literal|0
init|;
name|arcIdx
operator|<
name|numArcs
condition|;
name|arcIdx
operator|++
control|)
block|{
name|arcs
index|[
name|arcIdx
index|]
operator|.
name|output
operator|=
name|owner
operator|.
name|fst
operator|.
name|outputs
operator|.
name|add
argument_list|(
name|outputPrefix
argument_list|,
name|arcs
index|[
name|arcIdx
index|]
operator|.
name|output
argument_list|)
expr_stmt|;
assert|assert
name|owner
operator|.
name|validOutput
argument_list|(
name|arcs
index|[
name|arcIdx
index|]
operator|.
name|output
argument_list|)
assert|;
block|}
if|if
condition|(
name|isFinal
condition|)
block|{
name|output
operator|=
name|owner
operator|.
name|fst
operator|.
name|outputs
operator|.
name|add
argument_list|(
name|outputPrefix
argument_list|,
name|output
argument_list|)
expr_stmt|;
assert|assert
name|owner
operator|.
name|validOutput
argument_list|(
name|output
argument_list|)
assert|;
block|}
block|}
block|}
block|}
end_class
end_unit
