begin_unit
begin_package
DECL|package|org.apache.lucene.util.fst
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|fst
package|;
end_package
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|BufferedInputStream
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|BufferedOutputStream
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStream
import|;
end_import
begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|Files
import|;
end_import
begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|Path
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|codecs
operator|.
name|CodecUtil
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|ByteArrayDataOutput
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|DataInput
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|DataOutput
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|InputStreamDataInput
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|OutputStreamDataOutput
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|RAMOutputStream
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|Accountable
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|Accountables
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|ArrayUtil
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|Constants
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|PriorityQueue
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|RamUsageEstimator
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|fst
operator|.
name|Builder
operator|.
name|UnCompiledNode
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|packed
operator|.
name|GrowableWriter
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|packed
operator|.
name|PackedInts
import|;
end_import
begin_comment
comment|// TODO: break this into WritableFST and ReadOnlyFST.. then
end_comment
begin_comment
comment|// we can have subclasses of ReadOnlyFST to handle the
end_comment
begin_comment
comment|// different byte[] level encodings (packed or
end_comment
begin_comment
comment|// not)... and things like nodeCount, arcCount are read only
end_comment
begin_comment
comment|// TODO: if FST is pure prefix trie we can do a more compact
end_comment
begin_comment
comment|// job, ie, once we are at a 'suffix only', just store the
end_comment
begin_comment
comment|// completion labels as a string not as a series of arcs.
end_comment
begin_comment
comment|// NOTE: while the FST is able to represent a non-final
end_comment
begin_comment
comment|// dead-end state (NON_FINAL_END_NODE=0), the layers above
end_comment
begin_comment
comment|// (FSTEnum, Util) have problems with this!!
end_comment
begin_comment
comment|/** Represents an finite state machine (FST), using a  *  compact byte[] format.  *<p> The format is similar to what's used by Morfologik  *  (http://sourceforge.net/projects/morfologik).  *    *<p> See the {@link org.apache.lucene.util.fst package  *      documentation} for some simple examples.  *  * @lucene.experimental  */
end_comment
begin_class
DECL|class|FST
specifier|public
specifier|final
class|class
name|FST
parameter_list|<
name|T
parameter_list|>
implements|implements
name|Accountable
block|{
DECL|field|BASE_RAM_BYTES_USED
specifier|private
specifier|static
specifier|final
name|long
name|BASE_RAM_BYTES_USED
init|=
name|RamUsageEstimator
operator|.
name|shallowSizeOfInstance
argument_list|(
name|FST
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|ARC_SHALLOW_RAM_BYTES_USED
specifier|private
specifier|static
specifier|final
name|long
name|ARC_SHALLOW_RAM_BYTES_USED
init|=
name|RamUsageEstimator
operator|.
name|shallowSizeOfInstance
argument_list|(
name|Arc
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/** Specifies allowed range of each int input label for    *  this FST. */
DECL|enum|INPUT_TYPE
DECL|enum constant|BYTE1
DECL|enum constant|BYTE2
DECL|enum constant|BYTE4
specifier|public
specifier|static
enum|enum
name|INPUT_TYPE
block|{
name|BYTE1
block|,
name|BYTE2
block|,
name|BYTE4
block|}
empty_stmt|;
DECL|field|BIT_FINAL_ARC
specifier|static
specifier|final
name|int
name|BIT_FINAL_ARC
init|=
literal|1
operator|<<
literal|0
decl_stmt|;
DECL|field|BIT_LAST_ARC
specifier|static
specifier|final
name|int
name|BIT_LAST_ARC
init|=
literal|1
operator|<<
literal|1
decl_stmt|;
DECL|field|BIT_TARGET_NEXT
specifier|static
specifier|final
name|int
name|BIT_TARGET_NEXT
init|=
literal|1
operator|<<
literal|2
decl_stmt|;
comment|// TODO: we can free up a bit if we can nuke this:
DECL|field|BIT_STOP_NODE
specifier|static
specifier|final
name|int
name|BIT_STOP_NODE
init|=
literal|1
operator|<<
literal|3
decl_stmt|;
comment|/** This flag is set if the arc has an output. */
DECL|field|BIT_ARC_HAS_OUTPUT
specifier|public
specifier|static
specifier|final
name|int
name|BIT_ARC_HAS_OUTPUT
init|=
literal|1
operator|<<
literal|4
decl_stmt|;
DECL|field|BIT_ARC_HAS_FINAL_OUTPUT
specifier|static
specifier|final
name|int
name|BIT_ARC_HAS_FINAL_OUTPUT
init|=
literal|1
operator|<<
literal|5
decl_stmt|;
comment|// Arcs are stored as fixed-size (per entry) array, so
comment|// that we can find an arc using binary search.  We do
comment|// this when number of arcs is> NUM_ARCS_ARRAY:
comment|// If set, the target node is delta coded vs current
comment|// position:
DECL|field|BIT_TARGET_DELTA
specifier|private
specifier|static
specifier|final
name|int
name|BIT_TARGET_DELTA
init|=
literal|1
operator|<<
literal|6
decl_stmt|;
comment|// We use this as a marker (because this one flag is
comment|// illegal by itself ...):
DECL|field|ARCS_AS_FIXED_ARRAY
specifier|private
specifier|static
specifier|final
name|byte
name|ARCS_AS_FIXED_ARRAY
init|=
name|BIT_ARC_HAS_FINAL_OUTPUT
decl_stmt|;
comment|/**    * @see #shouldExpand(UnCompiledNode)    */
DECL|field|FIXED_ARRAY_SHALLOW_DISTANCE
specifier|static
specifier|final
name|int
name|FIXED_ARRAY_SHALLOW_DISTANCE
init|=
literal|3
decl_stmt|;
comment|// 0 => only root node.
comment|/**    * @see #shouldExpand(UnCompiledNode)    */
DECL|field|FIXED_ARRAY_NUM_ARCS_SHALLOW
specifier|static
specifier|final
name|int
name|FIXED_ARRAY_NUM_ARCS_SHALLOW
init|=
literal|5
decl_stmt|;
comment|/**    * @see #shouldExpand(UnCompiledNode)    */
DECL|field|FIXED_ARRAY_NUM_ARCS_DEEP
specifier|static
specifier|final
name|int
name|FIXED_ARRAY_NUM_ARCS_DEEP
init|=
literal|10
decl_stmt|;
comment|// Reused temporarily while building the FST:
DECL|field|reusedBytesPerArc
specifier|private
name|int
index|[]
name|reusedBytesPerArc
init|=
operator|new
name|int
index|[
literal|0
index|]
decl_stmt|;
comment|// Increment version to change it
DECL|field|FILE_FORMAT_NAME
specifier|private
specifier|static
specifier|final
name|String
name|FILE_FORMAT_NAME
init|=
literal|"FST"
decl_stmt|;
DECL|field|VERSION_START
specifier|private
specifier|static
specifier|final
name|int
name|VERSION_START
init|=
literal|0
decl_stmt|;
comment|/** Changed numBytesPerArc for array'd case from byte to int. */
DECL|field|VERSION_INT_NUM_BYTES_PER_ARC
specifier|private
specifier|static
specifier|final
name|int
name|VERSION_INT_NUM_BYTES_PER_ARC
init|=
literal|1
decl_stmt|;
comment|/** Write BYTE2 labels as 2-byte short, not vInt. */
DECL|field|VERSION_SHORT_BYTE2_LABELS
specifier|private
specifier|static
specifier|final
name|int
name|VERSION_SHORT_BYTE2_LABELS
init|=
literal|2
decl_stmt|;
comment|/** Added optional packed format. */
DECL|field|VERSION_PACKED
specifier|private
specifier|static
specifier|final
name|int
name|VERSION_PACKED
init|=
literal|3
decl_stmt|;
comment|/** Changed from int to vInt for encoding arc targets.     *  Also changed maxBytesPerArc from int to vInt in the array case. */
DECL|field|VERSION_VINT_TARGET
specifier|private
specifier|static
specifier|final
name|int
name|VERSION_VINT_TARGET
init|=
literal|4
decl_stmt|;
DECL|field|VERSION_CURRENT
specifier|private
specifier|static
specifier|final
name|int
name|VERSION_CURRENT
init|=
name|VERSION_VINT_TARGET
decl_stmt|;
comment|// Never serialized; just used to represent the virtual
comment|// final node w/ no arcs:
DECL|field|FINAL_END_NODE
specifier|private
specifier|static
specifier|final
name|long
name|FINAL_END_NODE
init|=
operator|-
literal|1
decl_stmt|;
comment|// Never serialized; just used to represent the virtual
comment|// non-final node w/ no arcs:
DECL|field|NON_FINAL_END_NODE
specifier|private
specifier|static
specifier|final
name|long
name|NON_FINAL_END_NODE
init|=
literal|0
decl_stmt|;
comment|/** If arc has this label then that arc is final/accepted */
DECL|field|END_LABEL
specifier|public
specifier|static
specifier|final
name|int
name|END_LABEL
init|=
operator|-
literal|1
decl_stmt|;
DECL|field|inputType
specifier|public
specifier|final
name|INPUT_TYPE
name|inputType
decl_stmt|;
comment|// if non-null, this FST accepts the empty string and
comment|// produces this output
DECL|field|emptyOutput
name|T
name|emptyOutput
decl_stmt|;
DECL|field|bytes
specifier|final
name|BytesStore
name|bytes
decl_stmt|;
DECL|field|startNode
specifier|private
name|long
name|startNode
init|=
operator|-
literal|1
decl_stmt|;
DECL|field|outputs
specifier|public
specifier|final
name|Outputs
argument_list|<
name|T
argument_list|>
name|outputs
decl_stmt|;
comment|// Used for the BIT_TARGET_NEXT optimization (whereby
comment|// instead of storing the address of the target node for
comment|// a given arc, we mark a single bit noting that the next
comment|// node in the byte[] is the target node):
DECL|field|lastFrozenNode
specifier|private
name|long
name|lastFrozenNode
decl_stmt|;
DECL|field|NO_OUTPUT
specifier|private
specifier|final
name|T
name|NO_OUTPUT
decl_stmt|;
DECL|field|nodeCount
specifier|public
name|long
name|nodeCount
decl_stmt|;
DECL|field|arcCount
specifier|public
name|long
name|arcCount
decl_stmt|;
DECL|field|arcWithOutputCount
specifier|public
name|long
name|arcWithOutputCount
decl_stmt|;
DECL|field|packed
specifier|private
specifier|final
name|boolean
name|packed
decl_stmt|;
DECL|field|nodeRefToAddress
specifier|private
name|PackedInts
operator|.
name|Reader
name|nodeRefToAddress
decl_stmt|;
DECL|field|allowArrayArcs
specifier|private
specifier|final
name|boolean
name|allowArrayArcs
decl_stmt|;
DECL|field|cachedRootArcs
specifier|private
name|Arc
argument_list|<
name|T
argument_list|>
name|cachedRootArcs
index|[]
decl_stmt|;
comment|/** Represents a single arc. */
DECL|class|Arc
specifier|public
specifier|static
specifier|final
class|class
name|Arc
parameter_list|<
name|T
parameter_list|>
block|{
DECL|field|label
specifier|public
name|int
name|label
decl_stmt|;
DECL|field|output
specifier|public
name|T
name|output
decl_stmt|;
comment|// From node (ord or address); currently only used when
comment|// building an FST w/ willPackFST=true:
DECL|field|node
name|long
name|node
decl_stmt|;
comment|/** To node (ord or address) */
DECL|field|target
specifier|public
name|long
name|target
decl_stmt|;
DECL|field|flags
name|byte
name|flags
decl_stmt|;
DECL|field|nextFinalOutput
specifier|public
name|T
name|nextFinalOutput
decl_stmt|;
comment|// address (into the byte[]), or ord/address if label == END_LABEL
DECL|field|nextArc
name|long
name|nextArc
decl_stmt|;
comment|/** Where the first arc in the array starts; only valid if      *  bytesPerArc != 0 */
DECL|field|posArcsStart
specifier|public
name|long
name|posArcsStart
decl_stmt|;
comment|/** Non-zero if this arc is part of an array, which means all      *  arcs for the node are encoded with a fixed number of bytes so      *  that we can random access by index.  We do when there are enough      *  arcs leaving one node.  It wastes some bytes but gives faster      *  lookups. */
DECL|field|bytesPerArc
specifier|public
name|int
name|bytesPerArc
decl_stmt|;
comment|/** Where we are in the array; only valid if bytesPerArc != 0. */
DECL|field|arcIdx
specifier|public
name|int
name|arcIdx
decl_stmt|;
comment|/** How many arcs in the array; only valid if bytesPerArc != 0. */
DECL|field|numArcs
specifier|public
name|int
name|numArcs
decl_stmt|;
comment|/** Returns this */
DECL|method|copyFrom
specifier|public
name|Arc
argument_list|<
name|T
argument_list|>
name|copyFrom
parameter_list|(
name|Arc
argument_list|<
name|T
argument_list|>
name|other
parameter_list|)
block|{
name|node
operator|=
name|other
operator|.
name|node
expr_stmt|;
name|label
operator|=
name|other
operator|.
name|label
expr_stmt|;
name|target
operator|=
name|other
operator|.
name|target
expr_stmt|;
name|flags
operator|=
name|other
operator|.
name|flags
expr_stmt|;
name|output
operator|=
name|other
operator|.
name|output
expr_stmt|;
name|nextFinalOutput
operator|=
name|other
operator|.
name|nextFinalOutput
expr_stmt|;
name|nextArc
operator|=
name|other
operator|.
name|nextArc
expr_stmt|;
name|bytesPerArc
operator|=
name|other
operator|.
name|bytesPerArc
expr_stmt|;
if|if
condition|(
name|bytesPerArc
operator|!=
literal|0
condition|)
block|{
name|posArcsStart
operator|=
name|other
operator|.
name|posArcsStart
expr_stmt|;
name|arcIdx
operator|=
name|other
operator|.
name|arcIdx
expr_stmt|;
name|numArcs
operator|=
name|other
operator|.
name|numArcs
expr_stmt|;
block|}
return|return
name|this
return|;
block|}
DECL|method|flag
name|boolean
name|flag
parameter_list|(
name|int
name|flag
parameter_list|)
block|{
return|return
name|FST
operator|.
name|flag
argument_list|(
name|flags
argument_list|,
name|flag
argument_list|)
return|;
block|}
DECL|method|isLast
specifier|public
name|boolean
name|isLast
parameter_list|()
block|{
return|return
name|flag
argument_list|(
name|BIT_LAST_ARC
argument_list|)
return|;
block|}
DECL|method|isFinal
specifier|public
name|boolean
name|isFinal
parameter_list|()
block|{
return|return
name|flag
argument_list|(
name|BIT_FINAL_ARC
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
name|StringBuilder
name|b
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|b
operator|.
name|append
argument_list|(
literal|"node="
operator|+
name|node
argument_list|)
expr_stmt|;
name|b
operator|.
name|append
argument_list|(
literal|" target="
operator|+
name|target
argument_list|)
expr_stmt|;
name|b
operator|.
name|append
argument_list|(
literal|" label=0x"
operator|+
name|Integer
operator|.
name|toHexString
argument_list|(
name|label
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag
argument_list|(
name|BIT_FINAL_ARC
argument_list|)
condition|)
block|{
name|b
operator|.
name|append
argument_list|(
literal|" final"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flag
argument_list|(
name|BIT_LAST_ARC
argument_list|)
condition|)
block|{
name|b
operator|.
name|append
argument_list|(
literal|" last"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flag
argument_list|(
name|BIT_TARGET_NEXT
argument_list|)
condition|)
block|{
name|b
operator|.
name|append
argument_list|(
literal|" targetNext"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flag
argument_list|(
name|BIT_STOP_NODE
argument_list|)
condition|)
block|{
name|b
operator|.
name|append
argument_list|(
literal|" stop"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flag
argument_list|(
name|BIT_ARC_HAS_OUTPUT
argument_list|)
condition|)
block|{
name|b
operator|.
name|append
argument_list|(
literal|" output="
operator|+
name|output
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flag
argument_list|(
name|BIT_ARC_HAS_FINAL_OUTPUT
argument_list|)
condition|)
block|{
name|b
operator|.
name|append
argument_list|(
literal|" nextFinalOutput="
operator|+
name|nextFinalOutput
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bytesPerArc
operator|!=
literal|0
condition|)
block|{
name|b
operator|.
name|append
argument_list|(
literal|" arcArray(idx="
operator|+
name|arcIdx
operator|+
literal|" of "
operator|+
name|numArcs
operator|+
literal|")"
argument_list|)
expr_stmt|;
block|}
return|return
name|b
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
empty_stmt|;
DECL|method|flag
specifier|private
specifier|static
name|boolean
name|flag
parameter_list|(
name|int
name|flags
parameter_list|,
name|int
name|bit
parameter_list|)
block|{
return|return
operator|(
name|flags
operator|&
name|bit
operator|)
operator|!=
literal|0
return|;
block|}
DECL|field|nodeAddress
specifier|private
name|GrowableWriter
name|nodeAddress
decl_stmt|;
comment|// TODO: we could be smarter here, and prune periodically
comment|// as we go; high in-count nodes will "usually" become
comment|// clear early on:
DECL|field|inCounts
specifier|private
name|GrowableWriter
name|inCounts
decl_stmt|;
DECL|field|version
specifier|private
specifier|final
name|int
name|version
decl_stmt|;
comment|// make a new empty FST, for building; Builder invokes
comment|// this ctor
DECL|method|FST
name|FST
parameter_list|(
name|INPUT_TYPE
name|inputType
parameter_list|,
name|Outputs
argument_list|<
name|T
argument_list|>
name|outputs
parameter_list|,
name|boolean
name|willPackFST
parameter_list|,
name|float
name|acceptableOverheadRatio
parameter_list|,
name|boolean
name|allowArrayArcs
parameter_list|,
name|int
name|bytesPageBits
parameter_list|)
block|{
name|this
operator|.
name|inputType
operator|=
name|inputType
expr_stmt|;
name|this
operator|.
name|outputs
operator|=
name|outputs
expr_stmt|;
name|this
operator|.
name|allowArrayArcs
operator|=
name|allowArrayArcs
expr_stmt|;
name|version
operator|=
name|VERSION_CURRENT
expr_stmt|;
name|bytes
operator|=
operator|new
name|BytesStore
argument_list|(
name|bytesPageBits
argument_list|)
expr_stmt|;
comment|// pad: ensure no node gets address 0 which is reserved to mean
comment|// the stop state w/ no arcs
name|bytes
operator|.
name|writeByte
argument_list|(
operator|(
name|byte
operator|)
literal|0
argument_list|)
expr_stmt|;
name|NO_OUTPUT
operator|=
name|outputs
operator|.
name|getNoOutput
argument_list|()
expr_stmt|;
if|if
condition|(
name|willPackFST
condition|)
block|{
name|nodeAddress
operator|=
operator|new
name|GrowableWriter
argument_list|(
literal|15
argument_list|,
literal|8
argument_list|,
name|acceptableOverheadRatio
argument_list|)
expr_stmt|;
name|inCounts
operator|=
operator|new
name|GrowableWriter
argument_list|(
literal|1
argument_list|,
literal|8
argument_list|,
name|acceptableOverheadRatio
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|nodeAddress
operator|=
literal|null
expr_stmt|;
name|inCounts
operator|=
literal|null
expr_stmt|;
block|}
name|emptyOutput
operator|=
literal|null
expr_stmt|;
name|packed
operator|=
literal|false
expr_stmt|;
name|nodeRefToAddress
operator|=
literal|null
expr_stmt|;
block|}
DECL|field|DEFAULT_MAX_BLOCK_BITS
specifier|public
specifier|static
specifier|final
name|int
name|DEFAULT_MAX_BLOCK_BITS
init|=
name|Constants
operator|.
name|JRE_IS_64BIT
condition|?
literal|30
else|:
literal|28
decl_stmt|;
comment|/** Load a previously saved FST. */
DECL|method|FST
specifier|public
name|FST
parameter_list|(
name|DataInput
name|in
parameter_list|,
name|Outputs
argument_list|<
name|T
argument_list|>
name|outputs
parameter_list|)
throws|throws
name|IOException
block|{
name|this
argument_list|(
name|in
argument_list|,
name|outputs
argument_list|,
name|DEFAULT_MAX_BLOCK_BITS
argument_list|)
expr_stmt|;
block|}
comment|/** Load a previously saved FST; maxBlockBits allows you to    *  control the size of the byte[] pages used to hold the FST bytes. */
DECL|method|FST
specifier|public
name|FST
parameter_list|(
name|DataInput
name|in
parameter_list|,
name|Outputs
argument_list|<
name|T
argument_list|>
name|outputs
parameter_list|,
name|int
name|maxBlockBits
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|outputs
operator|=
name|outputs
expr_stmt|;
if|if
condition|(
name|maxBlockBits
argument_list|<
literal|1
operator|||
name|maxBlockBits
argument_list|>
literal|30
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"maxBlockBits should be 1 .. 30; got "
operator|+
name|maxBlockBits
argument_list|)
throw|;
block|}
comment|// NOTE: only reads most recent format; we don't have
comment|// back-compat promise for FSTs (they are experimental):
name|version
operator|=
name|CodecUtil
operator|.
name|checkHeader
argument_list|(
name|in
argument_list|,
name|FILE_FORMAT_NAME
argument_list|,
name|VERSION_PACKED
argument_list|,
name|VERSION_VINT_TARGET
argument_list|)
expr_stmt|;
name|packed
operator|=
name|in
operator|.
name|readByte
argument_list|()
operator|==
literal|1
expr_stmt|;
if|if
condition|(
name|in
operator|.
name|readByte
argument_list|()
operator|==
literal|1
condition|)
block|{
comment|// accepts empty string
comment|// 1 KB blocks:
name|BytesStore
name|emptyBytes
init|=
operator|new
name|BytesStore
argument_list|(
literal|10
argument_list|)
decl_stmt|;
name|int
name|numBytes
init|=
name|in
operator|.
name|readVInt
argument_list|()
decl_stmt|;
name|emptyBytes
operator|.
name|copyBytes
argument_list|(
name|in
argument_list|,
name|numBytes
argument_list|)
expr_stmt|;
comment|// De-serialize empty-string output:
name|BytesReader
name|reader
decl_stmt|;
if|if
condition|(
name|packed
condition|)
block|{
name|reader
operator|=
name|emptyBytes
operator|.
name|getForwardReader
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|reader
operator|=
name|emptyBytes
operator|.
name|getReverseReader
argument_list|()
expr_stmt|;
comment|// NoOutputs uses 0 bytes when writing its output,
comment|// so we have to check here else BytesStore gets
comment|// angry:
if|if
condition|(
name|numBytes
operator|>
literal|0
condition|)
block|{
name|reader
operator|.
name|setPosition
argument_list|(
name|numBytes
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|emptyOutput
operator|=
name|outputs
operator|.
name|readFinalOutput
argument_list|(
name|reader
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|emptyOutput
operator|=
literal|null
expr_stmt|;
block|}
specifier|final
name|byte
name|t
init|=
name|in
operator|.
name|readByte
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|t
condition|)
block|{
case|case
literal|0
case|:
name|inputType
operator|=
name|INPUT_TYPE
operator|.
name|BYTE1
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|inputType
operator|=
name|INPUT_TYPE
operator|.
name|BYTE2
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|inputType
operator|=
name|INPUT_TYPE
operator|.
name|BYTE4
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"invalid input type "
operator|+
name|t
argument_list|)
throw|;
block|}
if|if
condition|(
name|packed
condition|)
block|{
name|nodeRefToAddress
operator|=
name|PackedInts
operator|.
name|getReader
argument_list|(
name|in
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|nodeRefToAddress
operator|=
literal|null
expr_stmt|;
block|}
name|startNode
operator|=
name|in
operator|.
name|readVLong
argument_list|()
expr_stmt|;
name|nodeCount
operator|=
name|in
operator|.
name|readVLong
argument_list|()
expr_stmt|;
name|arcCount
operator|=
name|in
operator|.
name|readVLong
argument_list|()
expr_stmt|;
name|arcWithOutputCount
operator|=
name|in
operator|.
name|readVLong
argument_list|()
expr_stmt|;
name|long
name|numBytes
init|=
name|in
operator|.
name|readVLong
argument_list|()
decl_stmt|;
name|bytes
operator|=
operator|new
name|BytesStore
argument_list|(
name|in
argument_list|,
name|numBytes
argument_list|,
literal|1
operator|<<
name|maxBlockBits
argument_list|)
expr_stmt|;
name|NO_OUTPUT
operator|=
name|outputs
operator|.
name|getNoOutput
argument_list|()
expr_stmt|;
name|cacheRootArcs
argument_list|()
expr_stmt|;
comment|// NOTE: bogus because this is only used during
comment|// building; we need to break out mutable FST from
comment|// immutable
name|allowArrayArcs
operator|=
literal|false
expr_stmt|;
comment|/*     if (bytes.length == 665) {       Writer w = new OutputStreamWriter(new FileOutputStream("out.dot"), StandardCharsets.UTF_8);       Util.toDot(this, w, false, false);       w.close();       System.out.println("Wrote FST to out.dot");     }     */
block|}
DECL|method|getInputType
specifier|public
name|INPUT_TYPE
name|getInputType
parameter_list|()
block|{
return|return
name|inputType
return|;
block|}
DECL|method|ramBytesUsed
specifier|private
name|long
name|ramBytesUsed
parameter_list|(
name|Arc
argument_list|<
name|T
argument_list|>
index|[]
name|arcs
parameter_list|)
block|{
name|long
name|size
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|arcs
operator|!=
literal|null
condition|)
block|{
name|size
operator|+=
name|RamUsageEstimator
operator|.
name|shallowSizeOf
argument_list|(
name|arcs
argument_list|)
expr_stmt|;
for|for
control|(
name|Arc
argument_list|<
name|T
argument_list|>
name|arc
range|:
name|arcs
control|)
block|{
if|if
condition|(
name|arc
operator|!=
literal|null
condition|)
block|{
name|size
operator|+=
name|ARC_SHALLOW_RAM_BYTES_USED
expr_stmt|;
if|if
condition|(
name|arc
operator|.
name|output
operator|!=
literal|null
operator|&&
name|arc
operator|.
name|output
operator|!=
name|outputs
operator|.
name|getNoOutput
argument_list|()
condition|)
block|{
name|size
operator|+=
name|outputs
operator|.
name|ramBytesUsed
argument_list|(
name|arc
operator|.
name|output
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|arc
operator|.
name|nextFinalOutput
operator|!=
literal|null
operator|&&
name|arc
operator|.
name|nextFinalOutput
operator|!=
name|outputs
operator|.
name|getNoOutput
argument_list|()
condition|)
block|{
name|size
operator|+=
name|outputs
operator|.
name|ramBytesUsed
argument_list|(
name|arc
operator|.
name|nextFinalOutput
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
name|size
return|;
block|}
DECL|field|cachedArcsBytesUsed
specifier|private
name|int
name|cachedArcsBytesUsed
decl_stmt|;
annotation|@
name|Override
DECL|method|ramBytesUsed
specifier|public
name|long
name|ramBytesUsed
parameter_list|()
block|{
name|long
name|size
init|=
name|BASE_RAM_BYTES_USED
decl_stmt|;
name|size
operator|+=
name|bytes
operator|.
name|ramBytesUsed
argument_list|()
expr_stmt|;
if|if
condition|(
name|packed
condition|)
block|{
name|size
operator|+=
name|nodeRefToAddress
operator|.
name|ramBytesUsed
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nodeAddress
operator|!=
literal|null
condition|)
block|{
name|size
operator|+=
name|nodeAddress
operator|.
name|ramBytesUsed
argument_list|()
expr_stmt|;
name|size
operator|+=
name|inCounts
operator|.
name|ramBytesUsed
argument_list|()
expr_stmt|;
block|}
name|size
operator|+=
name|cachedArcsBytesUsed
expr_stmt|;
name|size
operator|+=
name|RamUsageEstimator
operator|.
name|sizeOf
argument_list|(
name|reusedBytesPerArc
argument_list|)
expr_stmt|;
return|return
name|size
return|;
block|}
annotation|@
name|Override
DECL|method|getChildResources
specifier|public
name|Collection
argument_list|<
name|Accountable
argument_list|>
name|getChildResources
parameter_list|()
block|{
name|List
argument_list|<
name|Accountable
argument_list|>
name|resources
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
if|if
condition|(
name|packed
condition|)
block|{
name|resources
operator|.
name|add
argument_list|(
name|Accountables
operator|.
name|namedAccountable
argument_list|(
literal|"node ref to address"
argument_list|,
name|nodeRefToAddress
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nodeAddress
operator|!=
literal|null
condition|)
block|{
name|resources
operator|.
name|add
argument_list|(
name|Accountables
operator|.
name|namedAccountable
argument_list|(
literal|"node addresses"
argument_list|,
name|nodeAddress
argument_list|)
argument_list|)
expr_stmt|;
name|resources
operator|.
name|add
argument_list|(
name|Accountables
operator|.
name|namedAccountable
argument_list|(
literal|"in counts"
argument_list|,
name|inCounts
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|resources
return|;
block|}
annotation|@
name|Override
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|"(input="
operator|+
name|inputType
operator|+
literal|",output="
operator|+
name|outputs
operator|+
literal|",packed="
operator|+
name|packed
operator|+
literal|",nodes="
operator|+
name|nodeCount
operator|+
literal|",arcs="
operator|+
name|arcCount
operator|+
literal|")"
return|;
block|}
DECL|method|finish
name|void
name|finish
parameter_list|(
name|long
name|newStartNode
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|startNode
operator|!=
operator|-
literal|1
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"already finished"
argument_list|)
throw|;
block|}
if|if
condition|(
name|newStartNode
operator|==
name|FINAL_END_NODE
operator|&&
name|emptyOutput
operator|!=
literal|null
condition|)
block|{
name|newStartNode
operator|=
literal|0
expr_stmt|;
block|}
name|startNode
operator|=
name|newStartNode
expr_stmt|;
name|bytes
operator|.
name|finish
argument_list|()
expr_stmt|;
name|cacheRootArcs
argument_list|()
expr_stmt|;
block|}
DECL|method|getNodeAddress
specifier|private
name|long
name|getNodeAddress
parameter_list|(
name|long
name|node
parameter_list|)
block|{
if|if
condition|(
name|nodeAddress
operator|!=
literal|null
condition|)
block|{
comment|// Deref
return|return
name|nodeAddress
operator|.
name|get
argument_list|(
operator|(
name|int
operator|)
name|node
argument_list|)
return|;
block|}
else|else
block|{
comment|// Straight
return|return
name|node
return|;
block|}
block|}
comment|// Optionally caches first 128 labels
annotation|@
name|SuppressWarnings
argument_list|(
block|{
literal|"rawtypes"
block|,
literal|"unchecked"
block|}
argument_list|)
DECL|method|cacheRootArcs
specifier|private
name|void
name|cacheRootArcs
parameter_list|()
throws|throws
name|IOException
block|{
comment|// We should only be called once per FST:
assert|assert
name|cachedArcsBytesUsed
operator|==
literal|0
assert|;
specifier|final
name|Arc
argument_list|<
name|T
argument_list|>
name|arc
init|=
operator|new
name|Arc
argument_list|<>
argument_list|()
decl_stmt|;
name|getFirstArc
argument_list|(
name|arc
argument_list|)
expr_stmt|;
if|if
condition|(
name|targetHasArcs
argument_list|(
name|arc
argument_list|)
condition|)
block|{
specifier|final
name|BytesReader
name|in
init|=
name|getBytesReader
argument_list|()
decl_stmt|;
name|Arc
argument_list|<
name|T
argument_list|>
index|[]
name|arcs
init|=
operator|(
name|Arc
argument_list|<
name|T
argument_list|>
index|[]
operator|)
operator|new
name|Arc
index|[
literal|0x80
index|]
decl_stmt|;
name|readFirstRealTargetArc
argument_list|(
name|arc
operator|.
name|target
argument_list|,
name|arc
argument_list|,
name|in
argument_list|)
expr_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
assert|assert
name|arc
operator|.
name|label
operator|!=
name|END_LABEL
assert|;
if|if
condition|(
name|arc
operator|.
name|label
operator|<
name|arcs
operator|.
name|length
condition|)
block|{
name|arcs
index|[
name|arc
operator|.
name|label
index|]
operator|=
operator|new
name|Arc
argument_list|<
name|T
argument_list|>
argument_list|()
operator|.
name|copyFrom
argument_list|(
name|arc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
break|break;
block|}
if|if
condition|(
name|arc
operator|.
name|isLast
argument_list|()
condition|)
block|{
break|break;
block|}
name|readNextRealArc
argument_list|(
name|arc
argument_list|,
name|in
argument_list|)
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
name|int
name|cacheRAM
init|=
operator|(
name|int
operator|)
name|ramBytesUsed
argument_list|(
name|arcs
argument_list|)
decl_stmt|;
comment|// Don't cache if there are only a few arcs or if the cache would use> 20% RAM of the FST itself:
if|if
condition|(
name|count
operator|>=
name|FIXED_ARRAY_NUM_ARCS_SHALLOW
operator|&&
name|cacheRAM
operator|<
name|ramBytesUsed
argument_list|()
operator|/
literal|5
condition|)
block|{
name|cachedRootArcs
operator|=
name|arcs
expr_stmt|;
name|cachedArcsBytesUsed
operator|=
name|cacheRAM
expr_stmt|;
block|}
block|}
block|}
DECL|method|getEmptyOutput
specifier|public
name|T
name|getEmptyOutput
parameter_list|()
block|{
return|return
name|emptyOutput
return|;
block|}
DECL|method|setEmptyOutput
name|void
name|setEmptyOutput
parameter_list|(
name|T
name|v
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|emptyOutput
operator|!=
literal|null
condition|)
block|{
name|emptyOutput
operator|=
name|outputs
operator|.
name|merge
argument_list|(
name|emptyOutput
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|emptyOutput
operator|=
name|v
expr_stmt|;
block|}
block|}
DECL|method|save
specifier|public
name|void
name|save
parameter_list|(
name|DataOutput
name|out
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|startNode
operator|==
operator|-
literal|1
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"call finish first"
argument_list|)
throw|;
block|}
if|if
condition|(
name|nodeAddress
operator|!=
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"cannot save an FST pre-packed FST; it must first be packed"
argument_list|)
throw|;
block|}
if|if
condition|(
name|packed
operator|&&
operator|!
operator|(
name|nodeRefToAddress
operator|instanceof
name|PackedInts
operator|.
name|Mutable
operator|)
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"cannot save a FST which has been loaded from disk "
argument_list|)
throw|;
block|}
name|CodecUtil
operator|.
name|writeHeader
argument_list|(
name|out
argument_list|,
name|FILE_FORMAT_NAME
argument_list|,
name|VERSION_CURRENT
argument_list|)
expr_stmt|;
if|if
condition|(
name|packed
condition|)
block|{
name|out
operator|.
name|writeByte
argument_list|(
operator|(
name|byte
operator|)
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|out
operator|.
name|writeByte
argument_list|(
operator|(
name|byte
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
comment|// TODO: really we should encode this as an arc, arriving
comment|// to the root node, instead of special casing here:
if|if
condition|(
name|emptyOutput
operator|!=
literal|null
condition|)
block|{
comment|// Accepts empty string
name|out
operator|.
name|writeByte
argument_list|(
operator|(
name|byte
operator|)
literal|1
argument_list|)
expr_stmt|;
comment|// Serialize empty-string output:
name|RAMOutputStream
name|ros
init|=
operator|new
name|RAMOutputStream
argument_list|()
decl_stmt|;
name|outputs
operator|.
name|writeFinalOutput
argument_list|(
name|emptyOutput
argument_list|,
name|ros
argument_list|)
expr_stmt|;
name|byte
index|[]
name|emptyOutputBytes
init|=
operator|new
name|byte
index|[
operator|(
name|int
operator|)
name|ros
operator|.
name|getFilePointer
argument_list|()
index|]
decl_stmt|;
name|ros
operator|.
name|writeTo
argument_list|(
name|emptyOutputBytes
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|packed
condition|)
block|{
comment|// reverse
specifier|final
name|int
name|stopAt
init|=
name|emptyOutputBytes
operator|.
name|length
operator|/
literal|2
decl_stmt|;
name|int
name|upto
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|upto
operator|<
name|stopAt
condition|)
block|{
specifier|final
name|byte
name|b
init|=
name|emptyOutputBytes
index|[
name|upto
index|]
decl_stmt|;
name|emptyOutputBytes
index|[
name|upto
index|]
operator|=
name|emptyOutputBytes
index|[
name|emptyOutputBytes
operator|.
name|length
operator|-
name|upto
operator|-
literal|1
index|]
expr_stmt|;
name|emptyOutputBytes
index|[
name|emptyOutputBytes
operator|.
name|length
operator|-
name|upto
operator|-
literal|1
index|]
operator|=
name|b
expr_stmt|;
name|upto
operator|++
expr_stmt|;
block|}
block|}
name|out
operator|.
name|writeVInt
argument_list|(
name|emptyOutputBytes
operator|.
name|length
argument_list|)
expr_stmt|;
name|out
operator|.
name|writeBytes
argument_list|(
name|emptyOutputBytes
argument_list|,
literal|0
argument_list|,
name|emptyOutputBytes
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|out
operator|.
name|writeByte
argument_list|(
operator|(
name|byte
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
specifier|final
name|byte
name|t
decl_stmt|;
if|if
condition|(
name|inputType
operator|==
name|INPUT_TYPE
operator|.
name|BYTE1
condition|)
block|{
name|t
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|inputType
operator|==
name|INPUT_TYPE
operator|.
name|BYTE2
condition|)
block|{
name|t
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|t
operator|=
literal|2
expr_stmt|;
block|}
name|out
operator|.
name|writeByte
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|packed
condition|)
block|{
operator|(
operator|(
name|PackedInts
operator|.
name|Mutable
operator|)
name|nodeRefToAddress
operator|)
operator|.
name|save
argument_list|(
name|out
argument_list|)
expr_stmt|;
block|}
name|out
operator|.
name|writeVLong
argument_list|(
name|startNode
argument_list|)
expr_stmt|;
name|out
operator|.
name|writeVLong
argument_list|(
name|nodeCount
argument_list|)
expr_stmt|;
name|out
operator|.
name|writeVLong
argument_list|(
name|arcCount
argument_list|)
expr_stmt|;
name|out
operator|.
name|writeVLong
argument_list|(
name|arcWithOutputCount
argument_list|)
expr_stmt|;
name|long
name|numBytes
init|=
name|bytes
operator|.
name|getPosition
argument_list|()
decl_stmt|;
name|out
operator|.
name|writeVLong
argument_list|(
name|numBytes
argument_list|)
expr_stmt|;
name|bytes
operator|.
name|writeTo
argument_list|(
name|out
argument_list|)
expr_stmt|;
block|}
comment|/**    * Writes an automaton to a file.     */
DECL|method|save
specifier|public
name|void
name|save
parameter_list|(
specifier|final
name|Path
name|path
parameter_list|)
throws|throws
name|IOException
block|{
try|try
init|(
name|OutputStream
name|os
init|=
operator|new
name|BufferedOutputStream
argument_list|(
name|Files
operator|.
name|newOutputStream
argument_list|(
name|path
argument_list|)
argument_list|)
init|)
block|{
name|save
argument_list|(
operator|new
name|OutputStreamDataOutput
argument_list|(
name|os
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Reads an automaton from a file.     */
DECL|method|read
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|FST
argument_list|<
name|T
argument_list|>
name|read
parameter_list|(
name|Path
name|path
parameter_list|,
name|Outputs
argument_list|<
name|T
argument_list|>
name|outputs
parameter_list|)
throws|throws
name|IOException
block|{
try|try
init|(
name|InputStream
name|is
init|=
name|Files
operator|.
name|newInputStream
argument_list|(
name|path
argument_list|)
init|)
block|{
return|return
operator|new
name|FST
argument_list|<>
argument_list|(
operator|new
name|InputStreamDataInput
argument_list|(
operator|new
name|BufferedInputStream
argument_list|(
name|is
argument_list|)
argument_list|)
argument_list|,
name|outputs
argument_list|)
return|;
block|}
block|}
DECL|method|writeLabel
specifier|private
name|void
name|writeLabel
parameter_list|(
name|DataOutput
name|out
parameter_list|,
name|int
name|v
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|v
operator|>=
literal|0
operator|:
literal|"v="
operator|+
name|v
assert|;
if|if
condition|(
name|inputType
operator|==
name|INPUT_TYPE
operator|.
name|BYTE1
condition|)
block|{
assert|assert
name|v
operator|<=
literal|255
operator|:
literal|"v="
operator|+
name|v
assert|;
name|out
operator|.
name|writeByte
argument_list|(
operator|(
name|byte
operator|)
name|v
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|inputType
operator|==
name|INPUT_TYPE
operator|.
name|BYTE2
condition|)
block|{
assert|assert
name|v
operator|<=
literal|65535
operator|:
literal|"v="
operator|+
name|v
assert|;
name|out
operator|.
name|writeShort
argument_list|(
operator|(
name|short
operator|)
name|v
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|out
operator|.
name|writeVInt
argument_list|(
name|v
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Reads one BYTE1/2/4 label from the provided {@link DataInput}. */
DECL|method|readLabel
specifier|public
name|int
name|readLabel
parameter_list|(
name|DataInput
name|in
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|int
name|v
decl_stmt|;
if|if
condition|(
name|inputType
operator|==
name|INPUT_TYPE
operator|.
name|BYTE1
condition|)
block|{
comment|// Unsigned byte:
name|v
operator|=
name|in
operator|.
name|readByte
argument_list|()
operator|&
literal|0xFF
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|inputType
operator|==
name|INPUT_TYPE
operator|.
name|BYTE2
condition|)
block|{
comment|// Unsigned short:
name|v
operator|=
name|in
operator|.
name|readShort
argument_list|()
operator|&
literal|0xFFFF
expr_stmt|;
block|}
else|else
block|{
name|v
operator|=
name|in
operator|.
name|readVInt
argument_list|()
expr_stmt|;
block|}
return|return
name|v
return|;
block|}
comment|/** returns true if the node at this address has any    *  outgoing arcs */
DECL|method|targetHasArcs
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|boolean
name|targetHasArcs
parameter_list|(
name|Arc
argument_list|<
name|T
argument_list|>
name|arc
parameter_list|)
block|{
return|return
name|arc
operator|.
name|target
operator|>
literal|0
return|;
block|}
comment|// serializes new node by appending its bytes to the end
comment|// of the current byte[]
DECL|method|addNode
name|long
name|addNode
parameter_list|(
name|Builder
operator|.
name|UnCompiledNode
argument_list|<
name|T
argument_list|>
name|nodeIn
parameter_list|)
throws|throws
name|IOException
block|{
comment|//System.out.println("FST.addNode pos=" + bytes.getPosition() + " numArcs=" + nodeIn.numArcs);
if|if
condition|(
name|nodeIn
operator|.
name|numArcs
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|nodeIn
operator|.
name|isFinal
condition|)
block|{
return|return
name|FINAL_END_NODE
return|;
block|}
else|else
block|{
return|return
name|NON_FINAL_END_NODE
return|;
block|}
block|}
specifier|final
name|long
name|startAddress
init|=
name|bytes
operator|.
name|getPosition
argument_list|()
decl_stmt|;
comment|//System.out.println("  startAddr=" + startAddress);
specifier|final
name|boolean
name|doFixedArray
init|=
name|shouldExpand
argument_list|(
name|nodeIn
argument_list|)
decl_stmt|;
if|if
condition|(
name|doFixedArray
condition|)
block|{
comment|//System.out.println("  fixedArray");
if|if
condition|(
name|reusedBytesPerArc
operator|.
name|length
operator|<
name|nodeIn
operator|.
name|numArcs
condition|)
block|{
name|reusedBytesPerArc
operator|=
operator|new
name|int
index|[
name|ArrayUtil
operator|.
name|oversize
argument_list|(
name|nodeIn
operator|.
name|numArcs
argument_list|,
literal|1
argument_list|)
index|]
expr_stmt|;
block|}
block|}
name|arcCount
operator|+=
name|nodeIn
operator|.
name|numArcs
expr_stmt|;
specifier|final
name|int
name|lastArc
init|=
name|nodeIn
operator|.
name|numArcs
operator|-
literal|1
decl_stmt|;
name|long
name|lastArcStart
init|=
name|bytes
operator|.
name|getPosition
argument_list|()
decl_stmt|;
name|int
name|maxBytesPerArc
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|arcIdx
init|=
literal|0
init|;
name|arcIdx
operator|<
name|nodeIn
operator|.
name|numArcs
condition|;
name|arcIdx
operator|++
control|)
block|{
specifier|final
name|Builder
operator|.
name|Arc
argument_list|<
name|T
argument_list|>
name|arc
init|=
name|nodeIn
operator|.
name|arcs
index|[
name|arcIdx
index|]
decl_stmt|;
specifier|final
name|Builder
operator|.
name|CompiledNode
name|target
init|=
operator|(
name|Builder
operator|.
name|CompiledNode
operator|)
name|arc
operator|.
name|target
decl_stmt|;
name|int
name|flags
init|=
literal|0
decl_stmt|;
comment|//System.out.println("  arc " + arcIdx + " label=" + arc.label + " -> target=" + target.node);
if|if
condition|(
name|arcIdx
operator|==
name|lastArc
condition|)
block|{
name|flags
operator|+=
name|BIT_LAST_ARC
expr_stmt|;
block|}
if|if
condition|(
name|lastFrozenNode
operator|==
name|target
operator|.
name|node
operator|&&
operator|!
name|doFixedArray
condition|)
block|{
comment|// TODO: for better perf (but more RAM used) we
comment|// could avoid this except when arc is "near" the
comment|// last arc:
name|flags
operator|+=
name|BIT_TARGET_NEXT
expr_stmt|;
block|}
if|if
condition|(
name|arc
operator|.
name|isFinal
condition|)
block|{
name|flags
operator|+=
name|BIT_FINAL_ARC
expr_stmt|;
if|if
condition|(
name|arc
operator|.
name|nextFinalOutput
operator|!=
name|NO_OUTPUT
condition|)
block|{
name|flags
operator|+=
name|BIT_ARC_HAS_FINAL_OUTPUT
expr_stmt|;
block|}
block|}
else|else
block|{
assert|assert
name|arc
operator|.
name|nextFinalOutput
operator|==
name|NO_OUTPUT
assert|;
block|}
name|boolean
name|targetHasArcs
init|=
name|target
operator|.
name|node
operator|>
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|targetHasArcs
condition|)
block|{
name|flags
operator|+=
name|BIT_STOP_NODE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|inCounts
operator|!=
literal|null
condition|)
block|{
name|inCounts
operator|.
name|set
argument_list|(
operator|(
name|int
operator|)
name|target
operator|.
name|node
argument_list|,
name|inCounts
operator|.
name|get
argument_list|(
operator|(
name|int
operator|)
name|target
operator|.
name|node
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|arc
operator|.
name|output
operator|!=
name|NO_OUTPUT
condition|)
block|{
name|flags
operator|+=
name|BIT_ARC_HAS_OUTPUT
expr_stmt|;
block|}
name|bytes
operator|.
name|writeByte
argument_list|(
operator|(
name|byte
operator|)
name|flags
argument_list|)
expr_stmt|;
name|writeLabel
argument_list|(
name|bytes
argument_list|,
name|arc
operator|.
name|label
argument_list|)
expr_stmt|;
comment|// System.out.println("  write arc: label=" + (char) arc.label + " flags=" + flags + " target=" + target.node + " pos=" + bytes.getPosition() + " output=" + outputs.outputToString(arc.output));
if|if
condition|(
name|arc
operator|.
name|output
operator|!=
name|NO_OUTPUT
condition|)
block|{
name|outputs
operator|.
name|write
argument_list|(
name|arc
operator|.
name|output
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
comment|//System.out.println("    write output");
name|arcWithOutputCount
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|arc
operator|.
name|nextFinalOutput
operator|!=
name|NO_OUTPUT
condition|)
block|{
comment|//System.out.println("    write final output");
name|outputs
operator|.
name|writeFinalOutput
argument_list|(
name|arc
operator|.
name|nextFinalOutput
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|targetHasArcs
operator|&&
operator|(
name|flags
operator|&
name|BIT_TARGET_NEXT
operator|)
operator|==
literal|0
condition|)
block|{
assert|assert
name|target
operator|.
name|node
operator|>
literal|0
assert|;
comment|//System.out.println("    write target");
name|bytes
operator|.
name|writeVLong
argument_list|(
name|target
operator|.
name|node
argument_list|)
expr_stmt|;
block|}
comment|// just write the arcs "like normal" on first pass,
comment|// but record how many bytes each one took, and max
comment|// byte size:
if|if
condition|(
name|doFixedArray
condition|)
block|{
name|reusedBytesPerArc
index|[
name|arcIdx
index|]
operator|=
call|(
name|int
call|)
argument_list|(
name|bytes
operator|.
name|getPosition
argument_list|()
operator|-
name|lastArcStart
argument_list|)
expr_stmt|;
name|lastArcStart
operator|=
name|bytes
operator|.
name|getPosition
argument_list|()
expr_stmt|;
name|maxBytesPerArc
operator|=
name|Math
operator|.
name|max
argument_list|(
name|maxBytesPerArc
argument_list|,
name|reusedBytesPerArc
index|[
name|arcIdx
index|]
argument_list|)
expr_stmt|;
comment|//System.out.println("    bytes=" + reusedBytesPerArc[arcIdx]);
block|}
block|}
comment|// TODO: try to avoid wasteful cases: disable doFixedArray in that case
comment|/*       *       * LUCENE-4682: what is a fair heuristic here?      * It could involve some of these:      * 1. how "busy" the node is: nodeIn.inputCount relative to frontier[0].inputCount?      * 2. how much binSearch saves over scan: nodeIn.numArcs      * 3. waste: numBytes vs numBytesExpanded      *       * the one below just looks at #3     if (doFixedArray) {       // rough heuristic: make this 1.25 "waste factor" a parameter to the phd ctor????       int numBytes = lastArcStart - startAddress;       int numBytesExpanded = maxBytesPerArc * nodeIn.numArcs;       if (numBytesExpanded> numBytes*1.25) {         doFixedArray = false;       }     }     */
if|if
condition|(
name|doFixedArray
condition|)
block|{
specifier|final
name|int
name|MAX_HEADER_SIZE
init|=
literal|11
decl_stmt|;
comment|// header(byte) + numArcs(vint) + numBytes(vint)
assert|assert
name|maxBytesPerArc
operator|>
literal|0
assert|;
comment|// 2nd pass just "expands" all arcs to take up a fixed
comment|// byte size
comment|//System.out.println("write int @pos=" + (fixedArrayStart-4) + " numArcs=" + nodeIn.numArcs);
comment|// create the header
comment|// TODO: clean this up: or just rewind+reuse and deal with it
name|byte
name|header
index|[]
init|=
operator|new
name|byte
index|[
name|MAX_HEADER_SIZE
index|]
decl_stmt|;
name|ByteArrayDataOutput
name|bad
init|=
operator|new
name|ByteArrayDataOutput
argument_list|(
name|header
argument_list|)
decl_stmt|;
comment|// write a "false" first arc:
name|bad
operator|.
name|writeByte
argument_list|(
name|ARCS_AS_FIXED_ARRAY
argument_list|)
expr_stmt|;
name|bad
operator|.
name|writeVInt
argument_list|(
name|nodeIn
operator|.
name|numArcs
argument_list|)
expr_stmt|;
name|bad
operator|.
name|writeVInt
argument_list|(
name|maxBytesPerArc
argument_list|)
expr_stmt|;
name|int
name|headerLen
init|=
name|bad
operator|.
name|getPosition
argument_list|()
decl_stmt|;
specifier|final
name|long
name|fixedArrayStart
init|=
name|startAddress
operator|+
name|headerLen
decl_stmt|;
comment|// expand the arcs in place, backwards
name|long
name|srcPos
init|=
name|bytes
operator|.
name|getPosition
argument_list|()
decl_stmt|;
name|long
name|destPos
init|=
name|fixedArrayStart
operator|+
name|nodeIn
operator|.
name|numArcs
operator|*
name|maxBytesPerArc
decl_stmt|;
assert|assert
name|destPos
operator|>=
name|srcPos
assert|;
if|if
condition|(
name|destPos
operator|>
name|srcPos
condition|)
block|{
name|bytes
operator|.
name|skipBytes
argument_list|(
call|(
name|int
call|)
argument_list|(
name|destPos
operator|-
name|srcPos
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|arcIdx
init|=
name|nodeIn
operator|.
name|numArcs
operator|-
literal|1
init|;
name|arcIdx
operator|>=
literal|0
condition|;
name|arcIdx
operator|--
control|)
block|{
name|destPos
operator|-=
name|maxBytesPerArc
expr_stmt|;
name|srcPos
operator|-=
name|reusedBytesPerArc
index|[
name|arcIdx
index|]
expr_stmt|;
comment|//System.out.println("  repack arcIdx=" + arcIdx + " srcPos=" + srcPos + " destPos=" + destPos);
if|if
condition|(
name|srcPos
operator|!=
name|destPos
condition|)
block|{
comment|//System.out.println("  copy len=" + reusedBytesPerArc[arcIdx]);
assert|assert
name|destPos
operator|>
name|srcPos
operator|:
literal|"destPos="
operator|+
name|destPos
operator|+
literal|" srcPos="
operator|+
name|srcPos
operator|+
literal|" arcIdx="
operator|+
name|arcIdx
operator|+
literal|" maxBytesPerArc="
operator|+
name|maxBytesPerArc
operator|+
literal|" reusedBytesPerArc[arcIdx]="
operator|+
name|reusedBytesPerArc
index|[
name|arcIdx
index|]
operator|+
literal|" nodeIn.numArcs="
operator|+
name|nodeIn
operator|.
name|numArcs
assert|;
name|bytes
operator|.
name|copyBytes
argument_list|(
name|srcPos
argument_list|,
name|destPos
argument_list|,
name|reusedBytesPerArc
index|[
name|arcIdx
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// now write the header
name|bytes
operator|.
name|writeBytes
argument_list|(
name|startAddress
argument_list|,
name|header
argument_list|,
literal|0
argument_list|,
name|headerLen
argument_list|)
expr_stmt|;
block|}
specifier|final
name|long
name|thisNodeAddress
init|=
name|bytes
operator|.
name|getPosition
argument_list|()
operator|-
literal|1
decl_stmt|;
name|bytes
operator|.
name|reverse
argument_list|(
name|startAddress
argument_list|,
name|thisNodeAddress
argument_list|)
expr_stmt|;
comment|// PackedInts uses int as the index, so we cannot handle
comment|//> 2.1B nodes when packing:
if|if
condition|(
name|nodeAddress
operator|!=
literal|null
operator|&&
name|nodeCount
operator|==
name|Integer
operator|.
name|MAX_VALUE
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"cannot create a packed FST with more than 2.1 billion nodes"
argument_list|)
throw|;
block|}
name|nodeCount
operator|++
expr_stmt|;
specifier|final
name|long
name|node
decl_stmt|;
if|if
condition|(
name|nodeAddress
operator|!=
literal|null
condition|)
block|{
comment|// Nodes are addressed by 1+ord:
if|if
condition|(
operator|(
name|int
operator|)
name|nodeCount
operator|==
name|nodeAddress
operator|.
name|size
argument_list|()
condition|)
block|{
name|nodeAddress
operator|=
name|nodeAddress
operator|.
name|resize
argument_list|(
name|ArrayUtil
operator|.
name|oversize
argument_list|(
name|nodeAddress
operator|.
name|size
argument_list|()
operator|+
literal|1
argument_list|,
name|nodeAddress
operator|.
name|getBitsPerValue
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|inCounts
operator|=
name|inCounts
operator|.
name|resize
argument_list|(
name|ArrayUtil
operator|.
name|oversize
argument_list|(
name|inCounts
operator|.
name|size
argument_list|()
operator|+
literal|1
argument_list|,
name|inCounts
operator|.
name|getBitsPerValue
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|nodeAddress
operator|.
name|set
argument_list|(
operator|(
name|int
operator|)
name|nodeCount
argument_list|,
name|thisNodeAddress
argument_list|)
expr_stmt|;
comment|// System.out.println("  write nodeAddress[" + nodeCount + "] = " + endAddress);
name|node
operator|=
name|nodeCount
expr_stmt|;
block|}
else|else
block|{
name|node
operator|=
name|thisNodeAddress
expr_stmt|;
block|}
name|lastFrozenNode
operator|=
name|node
expr_stmt|;
comment|//System.out.println("  ret node=" + node + " address=" + thisNodeAddress + " nodeAddress=" + nodeAddress);
return|return
name|node
return|;
block|}
comment|/** Fills virtual 'start' arc, ie, an empty incoming arc to    *  the FST's start node */
DECL|method|getFirstArc
specifier|public
name|Arc
argument_list|<
name|T
argument_list|>
name|getFirstArc
parameter_list|(
name|Arc
argument_list|<
name|T
argument_list|>
name|arc
parameter_list|)
block|{
if|if
condition|(
name|emptyOutput
operator|!=
literal|null
condition|)
block|{
name|arc
operator|.
name|flags
operator|=
name|BIT_FINAL_ARC
operator||
name|BIT_LAST_ARC
expr_stmt|;
name|arc
operator|.
name|nextFinalOutput
operator|=
name|emptyOutput
expr_stmt|;
if|if
condition|(
name|emptyOutput
operator|!=
name|NO_OUTPUT
condition|)
block|{
name|arc
operator|.
name|flags
operator||=
name|BIT_ARC_HAS_FINAL_OUTPUT
expr_stmt|;
block|}
block|}
else|else
block|{
name|arc
operator|.
name|flags
operator|=
name|BIT_LAST_ARC
expr_stmt|;
name|arc
operator|.
name|nextFinalOutput
operator|=
name|NO_OUTPUT
expr_stmt|;
block|}
name|arc
operator|.
name|output
operator|=
name|NO_OUTPUT
expr_stmt|;
comment|// If there are no nodes, ie, the FST only accepts the
comment|// empty string, then startNode is 0
name|arc
operator|.
name|target
operator|=
name|startNode
expr_stmt|;
return|return
name|arc
return|;
block|}
comment|/** Follows the<code>follow</code> arc and reads the last    *  arc of its target; this changes the provided    *<code>arc</code> (2nd arg) in-place and returns it.    *     * @return Returns the second argument    * (<code>arc</code>). */
DECL|method|readLastTargetArc
specifier|public
name|Arc
argument_list|<
name|T
argument_list|>
name|readLastTargetArc
parameter_list|(
name|Arc
argument_list|<
name|T
argument_list|>
name|follow
parameter_list|,
name|Arc
argument_list|<
name|T
argument_list|>
name|arc
parameter_list|,
name|BytesReader
name|in
parameter_list|)
throws|throws
name|IOException
block|{
comment|//System.out.println("readLast");
if|if
condition|(
operator|!
name|targetHasArcs
argument_list|(
name|follow
argument_list|)
condition|)
block|{
comment|//System.out.println("  end node");
assert|assert
name|follow
operator|.
name|isFinal
argument_list|()
assert|;
name|arc
operator|.
name|label
operator|=
name|END_LABEL
expr_stmt|;
name|arc
operator|.
name|target
operator|=
name|FINAL_END_NODE
expr_stmt|;
name|arc
operator|.
name|output
operator|=
name|follow
operator|.
name|nextFinalOutput
expr_stmt|;
name|arc
operator|.
name|flags
operator|=
name|BIT_LAST_ARC
expr_stmt|;
return|return
name|arc
return|;
block|}
else|else
block|{
name|in
operator|.
name|setPosition
argument_list|(
name|getNodeAddress
argument_list|(
name|follow
operator|.
name|target
argument_list|)
argument_list|)
expr_stmt|;
name|arc
operator|.
name|node
operator|=
name|follow
operator|.
name|target
expr_stmt|;
specifier|final
name|byte
name|b
init|=
name|in
operator|.
name|readByte
argument_list|()
decl_stmt|;
if|if
condition|(
name|b
operator|==
name|ARCS_AS_FIXED_ARRAY
condition|)
block|{
comment|// array: jump straight to end
name|arc
operator|.
name|numArcs
operator|=
name|in
operator|.
name|readVInt
argument_list|()
expr_stmt|;
if|if
condition|(
name|packed
operator|||
name|version
operator|>=
name|VERSION_VINT_TARGET
condition|)
block|{
name|arc
operator|.
name|bytesPerArc
operator|=
name|in
operator|.
name|readVInt
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|arc
operator|.
name|bytesPerArc
operator|=
name|in
operator|.
name|readInt
argument_list|()
expr_stmt|;
block|}
comment|//System.out.println("  array numArcs=" + arc.numArcs + " bpa=" + arc.bytesPerArc);
name|arc
operator|.
name|posArcsStart
operator|=
name|in
operator|.
name|getPosition
argument_list|()
expr_stmt|;
name|arc
operator|.
name|arcIdx
operator|=
name|arc
operator|.
name|numArcs
operator|-
literal|2
expr_stmt|;
block|}
else|else
block|{
name|arc
operator|.
name|flags
operator|=
name|b
expr_stmt|;
comment|// non-array: linear scan
name|arc
operator|.
name|bytesPerArc
operator|=
literal|0
expr_stmt|;
comment|//System.out.println("  scan");
while|while
condition|(
operator|!
name|arc
operator|.
name|isLast
argument_list|()
condition|)
block|{
comment|// skip this arc:
name|readLabel
argument_list|(
name|in
argument_list|)
expr_stmt|;
if|if
condition|(
name|arc
operator|.
name|flag
argument_list|(
name|BIT_ARC_HAS_OUTPUT
argument_list|)
condition|)
block|{
name|outputs
operator|.
name|skipOutput
argument_list|(
name|in
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|arc
operator|.
name|flag
argument_list|(
name|BIT_ARC_HAS_FINAL_OUTPUT
argument_list|)
condition|)
block|{
name|outputs
operator|.
name|skipFinalOutput
argument_list|(
name|in
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|arc
operator|.
name|flag
argument_list|(
name|BIT_STOP_NODE
argument_list|)
condition|)
block|{           }
elseif|else
if|if
condition|(
name|arc
operator|.
name|flag
argument_list|(
name|BIT_TARGET_NEXT
argument_list|)
condition|)
block|{           }
elseif|else
if|if
condition|(
name|packed
condition|)
block|{
name|in
operator|.
name|readVLong
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|readUnpackedNodeTarget
argument_list|(
name|in
argument_list|)
expr_stmt|;
block|}
name|arc
operator|.
name|flags
operator|=
name|in
operator|.
name|readByte
argument_list|()
expr_stmt|;
block|}
comment|// Undo the byte flags we read:
name|in
operator|.
name|skipBytes
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
name|arc
operator|.
name|nextArc
operator|=
name|in
operator|.
name|getPosition
argument_list|()
expr_stmt|;
block|}
name|readNextRealArc
argument_list|(
name|arc
argument_list|,
name|in
argument_list|)
expr_stmt|;
assert|assert
name|arc
operator|.
name|isLast
argument_list|()
assert|;
return|return
name|arc
return|;
block|}
block|}
DECL|method|readUnpackedNodeTarget
specifier|private
name|long
name|readUnpackedNodeTarget
parameter_list|(
name|BytesReader
name|in
parameter_list|)
throws|throws
name|IOException
block|{
name|long
name|target
decl_stmt|;
if|if
condition|(
name|version
operator|<
name|VERSION_VINT_TARGET
condition|)
block|{
name|target
operator|=
name|in
operator|.
name|readInt
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|target
operator|=
name|in
operator|.
name|readVLong
argument_list|()
expr_stmt|;
block|}
return|return
name|target
return|;
block|}
comment|/**    * Follow the<code>follow</code> arc and read the first arc of its target;    * this changes the provided<code>arc</code> (2nd arg) in-place and returns    * it.    *     * @return Returns the second argument (<code>arc</code>).    */
DECL|method|readFirstTargetArc
specifier|public
name|Arc
argument_list|<
name|T
argument_list|>
name|readFirstTargetArc
parameter_list|(
name|Arc
argument_list|<
name|T
argument_list|>
name|follow
parameter_list|,
name|Arc
argument_list|<
name|T
argument_list|>
name|arc
parameter_list|,
name|BytesReader
name|in
parameter_list|)
throws|throws
name|IOException
block|{
comment|//int pos = address;
comment|//System.out.println("    readFirstTarget follow.target=" + follow.target + " isFinal=" + follow.isFinal());
if|if
condition|(
name|follow
operator|.
name|isFinal
argument_list|()
condition|)
block|{
comment|// Insert "fake" final first arc:
name|arc
operator|.
name|label
operator|=
name|END_LABEL
expr_stmt|;
name|arc
operator|.
name|output
operator|=
name|follow
operator|.
name|nextFinalOutput
expr_stmt|;
name|arc
operator|.
name|flags
operator|=
name|BIT_FINAL_ARC
expr_stmt|;
if|if
condition|(
name|follow
operator|.
name|target
operator|<=
literal|0
condition|)
block|{
name|arc
operator|.
name|flags
operator||=
name|BIT_LAST_ARC
expr_stmt|;
block|}
else|else
block|{
name|arc
operator|.
name|node
operator|=
name|follow
operator|.
name|target
expr_stmt|;
comment|// NOTE: nextArc is a node (not an address!) in this case:
name|arc
operator|.
name|nextArc
operator|=
name|follow
operator|.
name|target
expr_stmt|;
block|}
name|arc
operator|.
name|target
operator|=
name|FINAL_END_NODE
expr_stmt|;
comment|//System.out.println("    insert isFinal; nextArc=" + follow.target + " isLast=" + arc.isLast() + " output=" + outputs.outputToString(arc.output));
return|return
name|arc
return|;
block|}
else|else
block|{
return|return
name|readFirstRealTargetArc
argument_list|(
name|follow
operator|.
name|target
argument_list|,
name|arc
argument_list|,
name|in
argument_list|)
return|;
block|}
block|}
DECL|method|readFirstRealTargetArc
specifier|public
name|Arc
argument_list|<
name|T
argument_list|>
name|readFirstRealTargetArc
parameter_list|(
name|long
name|node
parameter_list|,
name|Arc
argument_list|<
name|T
argument_list|>
name|arc
parameter_list|,
specifier|final
name|BytesReader
name|in
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|long
name|address
init|=
name|getNodeAddress
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|in
operator|.
name|setPosition
argument_list|(
name|address
argument_list|)
expr_stmt|;
comment|//System.out.println("  readFirstRealTargtArc address="
comment|//+ address);
comment|//System.out.println("   flags=" + arc.flags);
name|arc
operator|.
name|node
operator|=
name|node
expr_stmt|;
if|if
condition|(
name|in
operator|.
name|readByte
argument_list|()
operator|==
name|ARCS_AS_FIXED_ARRAY
condition|)
block|{
comment|//System.out.println("  fixedArray");
comment|// this is first arc in a fixed-array
name|arc
operator|.
name|numArcs
operator|=
name|in
operator|.
name|readVInt
argument_list|()
expr_stmt|;
if|if
condition|(
name|packed
operator|||
name|version
operator|>=
name|VERSION_VINT_TARGET
condition|)
block|{
name|arc
operator|.
name|bytesPerArc
operator|=
name|in
operator|.
name|readVInt
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|arc
operator|.
name|bytesPerArc
operator|=
name|in
operator|.
name|readInt
argument_list|()
expr_stmt|;
block|}
name|arc
operator|.
name|arcIdx
operator|=
operator|-
literal|1
expr_stmt|;
name|arc
operator|.
name|nextArc
operator|=
name|arc
operator|.
name|posArcsStart
operator|=
name|in
operator|.
name|getPosition
argument_list|()
expr_stmt|;
comment|//System.out.println("  bytesPer=" + arc.bytesPerArc + " numArcs=" + arc.numArcs + " arcsStart=" + pos);
block|}
else|else
block|{
comment|//arc.flags = b;
name|arc
operator|.
name|nextArc
operator|=
name|address
expr_stmt|;
name|arc
operator|.
name|bytesPerArc
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|readNextRealArc
argument_list|(
name|arc
argument_list|,
name|in
argument_list|)
return|;
block|}
comment|/**    * Checks if<code>arc</code>'s target state is in expanded (or vector) format.     *     * @return Returns<code>true</code> if<code>arc</code> points to a state in an    * expanded array format.    */
DECL|method|isExpandedTarget
name|boolean
name|isExpandedTarget
parameter_list|(
name|Arc
argument_list|<
name|T
argument_list|>
name|follow
parameter_list|,
name|BytesReader
name|in
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|targetHasArcs
argument_list|(
name|follow
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
else|else
block|{
name|in
operator|.
name|setPosition
argument_list|(
name|getNodeAddress
argument_list|(
name|follow
operator|.
name|target
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|in
operator|.
name|readByte
argument_list|()
operator|==
name|ARCS_AS_FIXED_ARRAY
return|;
block|}
block|}
comment|/** In-place read; returns the arc. */
DECL|method|readNextArc
specifier|public
name|Arc
argument_list|<
name|T
argument_list|>
name|readNextArc
parameter_list|(
name|Arc
argument_list|<
name|T
argument_list|>
name|arc
parameter_list|,
name|BytesReader
name|in
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|arc
operator|.
name|label
operator|==
name|END_LABEL
condition|)
block|{
comment|// This was a fake inserted "final" arc
if|if
condition|(
name|arc
operator|.
name|nextArc
operator|<=
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"cannot readNextArc when arc.isLast()=true"
argument_list|)
throw|;
block|}
return|return
name|readFirstRealTargetArc
argument_list|(
name|arc
operator|.
name|nextArc
argument_list|,
name|arc
argument_list|,
name|in
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|readNextRealArc
argument_list|(
name|arc
argument_list|,
name|in
argument_list|)
return|;
block|}
block|}
comment|/** Peeks at next arc's label; does not alter arc.  Do    *  not call this if arc.isLast()! */
DECL|method|readNextArcLabel
specifier|public
name|int
name|readNextArcLabel
parameter_list|(
name|Arc
argument_list|<
name|T
argument_list|>
name|arc
parameter_list|,
name|BytesReader
name|in
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
operator|!
name|arc
operator|.
name|isLast
argument_list|()
assert|;
if|if
condition|(
name|arc
operator|.
name|label
operator|==
name|END_LABEL
condition|)
block|{
comment|//System.out.println("    nextArc fake " +
comment|//arc.nextArc);
name|long
name|pos
init|=
name|getNodeAddress
argument_list|(
name|arc
operator|.
name|nextArc
argument_list|)
decl_stmt|;
name|in
operator|.
name|setPosition
argument_list|(
name|pos
argument_list|)
expr_stmt|;
specifier|final
name|byte
name|b
init|=
name|in
operator|.
name|readByte
argument_list|()
decl_stmt|;
if|if
condition|(
name|b
operator|==
name|ARCS_AS_FIXED_ARRAY
condition|)
block|{
comment|//System.out.println("    nextArc fixed array");
name|in
operator|.
name|readVInt
argument_list|()
expr_stmt|;
comment|// Skip bytesPerArc:
if|if
condition|(
name|packed
operator|||
name|version
operator|>=
name|VERSION_VINT_TARGET
condition|)
block|{
name|in
operator|.
name|readVInt
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|in
operator|.
name|readInt
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
name|in
operator|.
name|setPosition
argument_list|(
name|pos
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|arc
operator|.
name|bytesPerArc
operator|!=
literal|0
condition|)
block|{
comment|//System.out.println("    nextArc real array");
comment|// arcs are at fixed entries
name|in
operator|.
name|setPosition
argument_list|(
name|arc
operator|.
name|posArcsStart
argument_list|)
expr_stmt|;
name|in
operator|.
name|skipBytes
argument_list|(
operator|(
literal|1
operator|+
name|arc
operator|.
name|arcIdx
operator|)
operator|*
name|arc
operator|.
name|bytesPerArc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// arcs are packed
comment|//System.out.println("    nextArc real packed");
name|in
operator|.
name|setPosition
argument_list|(
name|arc
operator|.
name|nextArc
argument_list|)
expr_stmt|;
block|}
block|}
comment|// skip flags
name|in
operator|.
name|readByte
argument_list|()
expr_stmt|;
return|return
name|readLabel
argument_list|(
name|in
argument_list|)
return|;
block|}
comment|/** Never returns null, but you should never call this if    *  arc.isLast() is true. */
DECL|method|readNextRealArc
specifier|public
name|Arc
argument_list|<
name|T
argument_list|>
name|readNextRealArc
parameter_list|(
name|Arc
argument_list|<
name|T
argument_list|>
name|arc
parameter_list|,
specifier|final
name|BytesReader
name|in
parameter_list|)
throws|throws
name|IOException
block|{
comment|// TODO: can't assert this because we call from readFirstArc
comment|// assert !flag(arc.flags, BIT_LAST_ARC);
comment|// this is a continuing arc in a fixed array
if|if
condition|(
name|arc
operator|.
name|bytesPerArc
operator|!=
literal|0
condition|)
block|{
comment|// arcs are at fixed entries
name|arc
operator|.
name|arcIdx
operator|++
expr_stmt|;
assert|assert
name|arc
operator|.
name|arcIdx
operator|<
name|arc
operator|.
name|numArcs
assert|;
name|in
operator|.
name|setPosition
argument_list|(
name|arc
operator|.
name|posArcsStart
argument_list|)
expr_stmt|;
name|in
operator|.
name|skipBytes
argument_list|(
name|arc
operator|.
name|arcIdx
operator|*
name|arc
operator|.
name|bytesPerArc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// arcs are packed
name|in
operator|.
name|setPosition
argument_list|(
name|arc
operator|.
name|nextArc
argument_list|)
expr_stmt|;
block|}
name|arc
operator|.
name|flags
operator|=
name|in
operator|.
name|readByte
argument_list|()
expr_stmt|;
name|arc
operator|.
name|label
operator|=
name|readLabel
argument_list|(
name|in
argument_list|)
expr_stmt|;
if|if
condition|(
name|arc
operator|.
name|flag
argument_list|(
name|BIT_ARC_HAS_OUTPUT
argument_list|)
condition|)
block|{
name|arc
operator|.
name|output
operator|=
name|outputs
operator|.
name|read
argument_list|(
name|in
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|arc
operator|.
name|output
operator|=
name|outputs
operator|.
name|getNoOutput
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|arc
operator|.
name|flag
argument_list|(
name|BIT_ARC_HAS_FINAL_OUTPUT
argument_list|)
condition|)
block|{
name|arc
operator|.
name|nextFinalOutput
operator|=
name|outputs
operator|.
name|readFinalOutput
argument_list|(
name|in
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|arc
operator|.
name|nextFinalOutput
operator|=
name|outputs
operator|.
name|getNoOutput
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|arc
operator|.
name|flag
argument_list|(
name|BIT_STOP_NODE
argument_list|)
condition|)
block|{
if|if
condition|(
name|arc
operator|.
name|flag
argument_list|(
name|BIT_FINAL_ARC
argument_list|)
condition|)
block|{
name|arc
operator|.
name|target
operator|=
name|FINAL_END_NODE
expr_stmt|;
block|}
else|else
block|{
name|arc
operator|.
name|target
operator|=
name|NON_FINAL_END_NODE
expr_stmt|;
block|}
name|arc
operator|.
name|nextArc
operator|=
name|in
operator|.
name|getPosition
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|arc
operator|.
name|flag
argument_list|(
name|BIT_TARGET_NEXT
argument_list|)
condition|)
block|{
name|arc
operator|.
name|nextArc
operator|=
name|in
operator|.
name|getPosition
argument_list|()
expr_stmt|;
comment|// TODO: would be nice to make this lazy -- maybe
comment|// caller doesn't need the target and is scanning arcs...
if|if
condition|(
name|nodeAddress
operator|==
literal|null
condition|)
block|{
if|if
condition|(
operator|!
name|arc
operator|.
name|flag
argument_list|(
name|BIT_LAST_ARC
argument_list|)
condition|)
block|{
if|if
condition|(
name|arc
operator|.
name|bytesPerArc
operator|==
literal|0
condition|)
block|{
comment|// must scan
name|seekToNextNode
argument_list|(
name|in
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|in
operator|.
name|setPosition
argument_list|(
name|arc
operator|.
name|posArcsStart
argument_list|)
expr_stmt|;
name|in
operator|.
name|skipBytes
argument_list|(
name|arc
operator|.
name|bytesPerArc
operator|*
name|arc
operator|.
name|numArcs
argument_list|)
expr_stmt|;
block|}
block|}
name|arc
operator|.
name|target
operator|=
name|in
operator|.
name|getPosition
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|arc
operator|.
name|target
operator|=
name|arc
operator|.
name|node
operator|-
literal|1
expr_stmt|;
assert|assert
name|arc
operator|.
name|target
operator|>
literal|0
assert|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|packed
condition|)
block|{
specifier|final
name|long
name|pos
init|=
name|in
operator|.
name|getPosition
argument_list|()
decl_stmt|;
specifier|final
name|long
name|code
init|=
name|in
operator|.
name|readVLong
argument_list|()
decl_stmt|;
if|if
condition|(
name|arc
operator|.
name|flag
argument_list|(
name|BIT_TARGET_DELTA
argument_list|)
condition|)
block|{
comment|// Address is delta-coded from current address:
name|arc
operator|.
name|target
operator|=
name|pos
operator|+
name|code
expr_stmt|;
comment|//System.out.println("    delta pos=" + pos + " delta=" + code + " target=" + arc.target);
block|}
elseif|else
if|if
condition|(
name|code
operator|<
name|nodeRefToAddress
operator|.
name|size
argument_list|()
condition|)
block|{
comment|// Deref
name|arc
operator|.
name|target
operator|=
name|nodeRefToAddress
operator|.
name|get
argument_list|(
operator|(
name|int
operator|)
name|code
argument_list|)
expr_stmt|;
comment|//System.out.println("    deref code=" + code + " target=" + arc.target);
block|}
else|else
block|{
comment|// Absolute
name|arc
operator|.
name|target
operator|=
name|code
expr_stmt|;
comment|//System.out.println("    abs code=" + code);
block|}
block|}
else|else
block|{
name|arc
operator|.
name|target
operator|=
name|readUnpackedNodeTarget
argument_list|(
name|in
argument_list|)
expr_stmt|;
block|}
name|arc
operator|.
name|nextArc
operator|=
name|in
operator|.
name|getPosition
argument_list|()
expr_stmt|;
block|}
return|return
name|arc
return|;
block|}
comment|// LUCENE-5152: called only from asserts, to validate that the
comment|// non-cached arc lookup would produce the same result, to
comment|// catch callers that illegally modify shared structures with
comment|// the result (we shallow-clone the Arc itself, but e.g. a BytesRef
comment|// output is still shared):
DECL|method|assertRootCachedArc
specifier|private
name|boolean
name|assertRootCachedArc
parameter_list|(
name|int
name|label
parameter_list|,
name|Arc
argument_list|<
name|T
argument_list|>
name|cachedArc
parameter_list|)
throws|throws
name|IOException
block|{
name|Arc
argument_list|<
name|T
argument_list|>
name|arc
init|=
operator|new
name|Arc
argument_list|<>
argument_list|()
decl_stmt|;
name|getFirstArc
argument_list|(
name|arc
argument_list|)
expr_stmt|;
name|BytesReader
name|in
init|=
name|getBytesReader
argument_list|()
decl_stmt|;
name|Arc
argument_list|<
name|T
argument_list|>
name|result
init|=
name|findTargetArc
argument_list|(
name|label
argument_list|,
name|arc
argument_list|,
name|arc
argument_list|,
name|in
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|==
literal|null
condition|)
block|{
assert|assert
name|cachedArc
operator|==
literal|null
assert|;
block|}
else|else
block|{
assert|assert
name|cachedArc
operator|!=
literal|null
assert|;
assert|assert
name|cachedArc
operator|.
name|arcIdx
operator|==
name|result
operator|.
name|arcIdx
assert|;
assert|assert
name|cachedArc
operator|.
name|bytesPerArc
operator|==
name|result
operator|.
name|bytesPerArc
assert|;
assert|assert
name|cachedArc
operator|.
name|flags
operator|==
name|result
operator|.
name|flags
assert|;
assert|assert
name|cachedArc
operator|.
name|label
operator|==
name|result
operator|.
name|label
assert|;
assert|assert
name|cachedArc
operator|.
name|nextArc
operator|==
name|result
operator|.
name|nextArc
assert|;
assert|assert
name|cachedArc
operator|.
name|nextFinalOutput
operator|.
name|equals
argument_list|(
name|result
operator|.
name|nextFinalOutput
argument_list|)
assert|;
assert|assert
name|cachedArc
operator|.
name|node
operator|==
name|result
operator|.
name|node
assert|;
assert|assert
name|cachedArc
operator|.
name|numArcs
operator|==
name|result
operator|.
name|numArcs
assert|;
assert|assert
name|cachedArc
operator|.
name|output
operator|.
name|equals
argument_list|(
name|result
operator|.
name|output
argument_list|)
assert|;
assert|assert
name|cachedArc
operator|.
name|posArcsStart
operator|==
name|result
operator|.
name|posArcsStart
assert|;
assert|assert
name|cachedArc
operator|.
name|target
operator|==
name|result
operator|.
name|target
assert|;
block|}
return|return
literal|true
return|;
block|}
comment|// TODO: could we somehow [partially] tableize arc lookups
comment|// like automaton?
comment|/** Finds an arc leaving the incoming arc, replacing the arc in place.    *  This returns null if the arc was not found, else the incoming arc. */
DECL|method|findTargetArc
specifier|public
name|Arc
argument_list|<
name|T
argument_list|>
name|findTargetArc
parameter_list|(
name|int
name|labelToMatch
parameter_list|,
name|Arc
argument_list|<
name|T
argument_list|>
name|follow
parameter_list|,
name|Arc
argument_list|<
name|T
argument_list|>
name|arc
parameter_list|,
name|BytesReader
name|in
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|findTargetArc
argument_list|(
name|labelToMatch
argument_list|,
name|follow
argument_list|,
name|arc
argument_list|,
name|in
argument_list|,
literal|true
argument_list|)
return|;
block|}
comment|/** Finds an arc leaving the incoming arc, replacing the arc in place.    *  This returns null if the arc was not found, else the incoming arc. */
DECL|method|findTargetArc
specifier|private
name|Arc
argument_list|<
name|T
argument_list|>
name|findTargetArc
parameter_list|(
name|int
name|labelToMatch
parameter_list|,
name|Arc
argument_list|<
name|T
argument_list|>
name|follow
parameter_list|,
name|Arc
argument_list|<
name|T
argument_list|>
name|arc
parameter_list|,
name|BytesReader
name|in
parameter_list|,
name|boolean
name|useRootArcCache
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|labelToMatch
operator|==
name|END_LABEL
condition|)
block|{
if|if
condition|(
name|follow
operator|.
name|isFinal
argument_list|()
condition|)
block|{
if|if
condition|(
name|follow
operator|.
name|target
operator|<=
literal|0
condition|)
block|{
name|arc
operator|.
name|flags
operator|=
name|BIT_LAST_ARC
expr_stmt|;
block|}
else|else
block|{
name|arc
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
comment|// NOTE: nextArc is a node (not an address!) in this case:
name|arc
operator|.
name|nextArc
operator|=
name|follow
operator|.
name|target
expr_stmt|;
name|arc
operator|.
name|node
operator|=
name|follow
operator|.
name|target
expr_stmt|;
block|}
name|arc
operator|.
name|output
operator|=
name|follow
operator|.
name|nextFinalOutput
expr_stmt|;
name|arc
operator|.
name|label
operator|=
name|END_LABEL
expr_stmt|;
return|return
name|arc
return|;
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
comment|// Short-circuit if this arc is in the root arc cache:
if|if
condition|(
name|useRootArcCache
operator|&&
name|cachedRootArcs
operator|!=
literal|null
operator|&&
name|follow
operator|.
name|target
operator|==
name|startNode
operator|&&
name|labelToMatch
operator|<
name|cachedRootArcs
operator|.
name|length
condition|)
block|{
specifier|final
name|Arc
argument_list|<
name|T
argument_list|>
name|result
init|=
name|cachedRootArcs
index|[
name|labelToMatch
index|]
decl_stmt|;
comment|// LUCENE-5152: detect tricky cases where caller
comment|// modified previously returned cached root-arcs:
assert|assert
name|assertRootCachedArc
argument_list|(
name|labelToMatch
argument_list|,
name|result
argument_list|)
assert|;
if|if
condition|(
name|result
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
else|else
block|{
name|arc
operator|.
name|copyFrom
argument_list|(
name|result
argument_list|)
expr_stmt|;
return|return
name|arc
return|;
block|}
block|}
if|if
condition|(
operator|!
name|targetHasArcs
argument_list|(
name|follow
argument_list|)
condition|)
block|{
return|return
literal|null
return|;
block|}
name|in
operator|.
name|setPosition
argument_list|(
name|getNodeAddress
argument_list|(
name|follow
operator|.
name|target
argument_list|)
argument_list|)
expr_stmt|;
name|arc
operator|.
name|node
operator|=
name|follow
operator|.
name|target
expr_stmt|;
comment|// System.out.println("fta label=" + (char) labelToMatch);
if|if
condition|(
name|in
operator|.
name|readByte
argument_list|()
operator|==
name|ARCS_AS_FIXED_ARRAY
condition|)
block|{
comment|// Arcs are full array; do binary search:
name|arc
operator|.
name|numArcs
operator|=
name|in
operator|.
name|readVInt
argument_list|()
expr_stmt|;
if|if
condition|(
name|packed
operator|||
name|version
operator|>=
name|VERSION_VINT_TARGET
condition|)
block|{
name|arc
operator|.
name|bytesPerArc
operator|=
name|in
operator|.
name|readVInt
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|arc
operator|.
name|bytesPerArc
operator|=
name|in
operator|.
name|readInt
argument_list|()
expr_stmt|;
block|}
name|arc
operator|.
name|posArcsStart
operator|=
name|in
operator|.
name|getPosition
argument_list|()
expr_stmt|;
name|int
name|low
init|=
literal|0
decl_stmt|;
name|int
name|high
init|=
name|arc
operator|.
name|numArcs
operator|-
literal|1
decl_stmt|;
while|while
condition|(
name|low
operator|<=
name|high
condition|)
block|{
comment|//System.out.println("    cycle");
name|int
name|mid
init|=
operator|(
name|low
operator|+
name|high
operator|)
operator|>>>
literal|1
decl_stmt|;
name|in
operator|.
name|setPosition
argument_list|(
name|arc
operator|.
name|posArcsStart
argument_list|)
expr_stmt|;
name|in
operator|.
name|skipBytes
argument_list|(
name|arc
operator|.
name|bytesPerArc
operator|*
name|mid
operator|+
literal|1
argument_list|)
expr_stmt|;
name|int
name|midLabel
init|=
name|readLabel
argument_list|(
name|in
argument_list|)
decl_stmt|;
specifier|final
name|int
name|cmp
init|=
name|midLabel
operator|-
name|labelToMatch
decl_stmt|;
if|if
condition|(
name|cmp
operator|<
literal|0
condition|)
block|{
name|low
operator|=
name|mid
operator|+
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cmp
operator|>
literal|0
condition|)
block|{
name|high
operator|=
name|mid
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|arc
operator|.
name|arcIdx
operator|=
name|mid
operator|-
literal|1
expr_stmt|;
comment|//System.out.println("    found!");
return|return
name|readNextRealArc
argument_list|(
name|arc
argument_list|,
name|in
argument_list|)
return|;
block|}
block|}
return|return
literal|null
return|;
block|}
comment|// Linear scan
name|readFirstRealTargetArc
argument_list|(
name|follow
operator|.
name|target
argument_list|,
name|arc
argument_list|,
name|in
argument_list|)
expr_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
comment|//System.out.println("  non-bs cycle");
comment|// TODO: we should fix this code to not have to create
comment|// object for the output of every arc we scan... only
comment|// for the matching arc, if found
if|if
condition|(
name|arc
operator|.
name|label
operator|==
name|labelToMatch
condition|)
block|{
comment|//System.out.println("    found!");
return|return
name|arc
return|;
block|}
elseif|else
if|if
condition|(
name|arc
operator|.
name|label
operator|>
name|labelToMatch
condition|)
block|{
return|return
literal|null
return|;
block|}
elseif|else
if|if
condition|(
name|arc
operator|.
name|isLast
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
else|else
block|{
name|readNextRealArc
argument_list|(
name|arc
argument_list|,
name|in
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|seekToNextNode
specifier|private
name|void
name|seekToNextNode
parameter_list|(
name|BytesReader
name|in
parameter_list|)
throws|throws
name|IOException
block|{
while|while
condition|(
literal|true
condition|)
block|{
specifier|final
name|int
name|flags
init|=
name|in
operator|.
name|readByte
argument_list|()
decl_stmt|;
name|readLabel
argument_list|(
name|in
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag
argument_list|(
name|flags
argument_list|,
name|BIT_ARC_HAS_OUTPUT
argument_list|)
condition|)
block|{
name|outputs
operator|.
name|skipOutput
argument_list|(
name|in
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flag
argument_list|(
name|flags
argument_list|,
name|BIT_ARC_HAS_FINAL_OUTPUT
argument_list|)
condition|)
block|{
name|outputs
operator|.
name|skipFinalOutput
argument_list|(
name|in
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|flag
argument_list|(
name|flags
argument_list|,
name|BIT_STOP_NODE
argument_list|)
operator|&&
operator|!
name|flag
argument_list|(
name|flags
argument_list|,
name|BIT_TARGET_NEXT
argument_list|)
condition|)
block|{
if|if
condition|(
name|packed
condition|)
block|{
name|in
operator|.
name|readVLong
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|readUnpackedNodeTarget
argument_list|(
name|in
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|flag
argument_list|(
name|flags
argument_list|,
name|BIT_LAST_ARC
argument_list|)
condition|)
block|{
return|return;
block|}
block|}
block|}
DECL|method|getNodeCount
specifier|public
name|long
name|getNodeCount
parameter_list|()
block|{
comment|// 1+ in order to count the -1 implicit final node
return|return
literal|1
operator|+
name|nodeCount
return|;
block|}
DECL|method|getArcCount
specifier|public
name|long
name|getArcCount
parameter_list|()
block|{
return|return
name|arcCount
return|;
block|}
DECL|method|getArcWithOutputCount
specifier|public
name|long
name|getArcWithOutputCount
parameter_list|()
block|{
return|return
name|arcWithOutputCount
return|;
block|}
comment|/**    * Nodes will be expanded if their depth (distance from the root node) is    *&lt;= this value and their number of arcs is&gt;=    * {@link #FIXED_ARRAY_NUM_ARCS_SHALLOW}.    *     *<p>    * Fixed array consumes more RAM but enables binary search on the arcs    * (instead of a linear scan) on lookup by arc label.    *     * @return<code>true</code> if<code>node</code> should be stored in an    *         expanded (array) form.    *     * @see #FIXED_ARRAY_NUM_ARCS_DEEP    * @see Builder.UnCompiledNode#depth    */
DECL|method|shouldExpand
specifier|private
name|boolean
name|shouldExpand
parameter_list|(
name|UnCompiledNode
argument_list|<
name|T
argument_list|>
name|node
parameter_list|)
block|{
return|return
name|allowArrayArcs
operator|&&
operator|(
operator|(
name|node
operator|.
name|depth
operator|<=
name|FIXED_ARRAY_SHALLOW_DISTANCE
operator|&&
name|node
operator|.
name|numArcs
operator|>=
name|FIXED_ARRAY_NUM_ARCS_SHALLOW
operator|)
operator|||
name|node
operator|.
name|numArcs
operator|>=
name|FIXED_ARRAY_NUM_ARCS_DEEP
operator|)
return|;
block|}
comment|/** Returns a {@link BytesReader} for this FST, positioned at    *  position 0. */
DECL|method|getBytesReader
specifier|public
name|BytesReader
name|getBytesReader
parameter_list|()
block|{
name|BytesReader
name|in
decl_stmt|;
if|if
condition|(
name|packed
condition|)
block|{
name|in
operator|=
name|bytes
operator|.
name|getForwardReader
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|in
operator|=
name|bytes
operator|.
name|getReverseReader
argument_list|()
expr_stmt|;
block|}
return|return
name|in
return|;
block|}
comment|/** Reads bytes stored in an FST. */
DECL|class|BytesReader
specifier|public
specifier|static
specifier|abstract
class|class
name|BytesReader
extends|extends
name|DataInput
block|{
comment|/** Get current read position. */
DECL|method|getPosition
specifier|public
specifier|abstract
name|long
name|getPosition
parameter_list|()
function_decl|;
comment|/** Set current read position. */
DECL|method|setPosition
specifier|public
specifier|abstract
name|void
name|setPosition
parameter_list|(
name|long
name|pos
parameter_list|)
function_decl|;
comment|/** Returns true if this reader uses reversed bytes      *  under-the-hood. */
DECL|method|reversed
specifier|public
specifier|abstract
name|boolean
name|reversed
parameter_list|()
function_decl|;
block|}
comment|/*   public void countSingleChains() throws IOException {     // TODO: must assert this FST was built with     // "willRewrite"      final List<ArcAndState<T>> queue = new ArrayList<>();      // TODO: use bitset to not revisit nodes already     // visited      FixedBitSet seen = new FixedBitSet(1+nodeCount);     int saved = 0;      queue.add(new ArcAndState<T>(getFirstArc(new Arc<T>()), new IntsRef()));     Arc<T> scratchArc = new Arc<>();     while(queue.size()> 0) {       //System.out.println("cycle size=" + queue.size());       //for(ArcAndState<T> ent : queue) {       //  System.out.println("  " + Util.toBytesRef(ent.chain, new BytesRef()));       //  }       final ArcAndState<T> arcAndState = queue.get(queue.size()-1);       seen.set(arcAndState.arc.node);       final BytesRef br = Util.toBytesRef(arcAndState.chain, new BytesRef());       if (br.length> 0&& br.bytes[br.length-1] == -1) {         br.length--;       }       //System.out.println("  top node=" + arcAndState.arc.target + " chain=" + br.utf8ToString());       if (targetHasArcs(arcAndState.arc)&& !seen.get(arcAndState.arc.target)) {         // push         readFirstTargetArc(arcAndState.arc, scratchArc);         //System.out.println("  push label=" + (char) scratchArc.label);         //System.out.println("    tonode=" + scratchArc.target + " last?=" + scratchArc.isLast());                  final IntsRef chain = IntsRef.deepCopyOf(arcAndState.chain);         chain.grow(1+chain.length);         // TODO         //assert scratchArc.label != END_LABEL;         chain.ints[chain.length] = scratchArc.label;         chain.length++;          if (scratchArc.isLast()) {           if (scratchArc.target != -1&& inCounts[scratchArc.target] == 1) {             //System.out.println("    append");           } else {             if (arcAndState.chain.length> 1) {               saved += chain.length-2;               try {                 System.out.println("chain: " + Util.toBytesRef(chain, new BytesRef()).utf8ToString());               } catch (AssertionError ae) {                 System.out.println("chain: " + Util.toBytesRef(chain, new BytesRef()));               }             }             chain.length = 0;           }         } else {           //System.out.println("    reset");           if (arcAndState.chain.length> 1) {             saved += arcAndState.chain.length-2;             try {               System.out.println("chain: " + Util.toBytesRef(arcAndState.chain, new BytesRef()).utf8ToString());             } catch (AssertionError ae) {               System.out.println("chain: " + Util.toBytesRef(arcAndState.chain, new BytesRef()));             }           }           if (scratchArc.target != -1&& inCounts[scratchArc.target] != 1) {             chain.length = 0;           } else {             chain.ints[0] = scratchArc.label;             chain.length = 1;           }         }         // TODO: instead of new Arc() we can re-use from         // a by-depth array         queue.add(new ArcAndState<T>(new Arc<T>().copyFrom(scratchArc), chain));       } else if (!arcAndState.arc.isLast()) {         // next         readNextArc(arcAndState.arc);         //System.out.println("  next label=" + (char) arcAndState.arc.label + " len=" + arcAndState.chain.length);         if (arcAndState.chain.length != 0) {           arcAndState.chain.ints[arcAndState.chain.length-1] = arcAndState.arc.label;         }       } else {         if (arcAndState.chain.length> 1) {           saved += arcAndState.chain.length-2;           System.out.println("chain: " + Util.toBytesRef(arcAndState.chain, new BytesRef()).utf8ToString());         }         // pop         //System.out.println("  pop");         queue.remove(queue.size()-1);         while(queue.size()> 0&& queue.get(queue.size()-1).arc.isLast()) {           queue.remove(queue.size()-1);         }         if (queue.size()> 0) {           final ArcAndState<T> arcAndState2 = queue.get(queue.size()-1);           readNextArc(arcAndState2.arc);           //System.out.println("  read next=" + (char) arcAndState2.arc.label + " queue=" + queue.size());           assert arcAndState2.arc.label != END_LABEL;           if (arcAndState2.chain.length != 0) {             arcAndState2.chain.ints[arcAndState2.chain.length-1] = arcAndState2.arc.label;           }         }       }     }      System.out.println("TOT saved " + saved);   }  */
comment|// Creates a packed FST
DECL|method|FST
specifier|private
name|FST
parameter_list|(
name|INPUT_TYPE
name|inputType
parameter_list|,
name|Outputs
argument_list|<
name|T
argument_list|>
name|outputs
parameter_list|,
name|int
name|bytesPageBits
parameter_list|)
block|{
name|version
operator|=
name|VERSION_CURRENT
expr_stmt|;
name|packed
operator|=
literal|true
expr_stmt|;
name|this
operator|.
name|inputType
operator|=
name|inputType
expr_stmt|;
name|bytes
operator|=
operator|new
name|BytesStore
argument_list|(
name|bytesPageBits
argument_list|)
expr_stmt|;
name|this
operator|.
name|outputs
operator|=
name|outputs
expr_stmt|;
name|NO_OUTPUT
operator|=
name|outputs
operator|.
name|getNoOutput
argument_list|()
expr_stmt|;
comment|// NOTE: bogus because this is only used during
comment|// building; we need to break out mutable FST from
comment|// immutable
name|allowArrayArcs
operator|=
literal|false
expr_stmt|;
block|}
comment|/** Expert: creates an FST by packing this one.  This    *  process requires substantial additional RAM (currently    *  up to ~8 bytes per node depending on    *<code>acceptableOverheadRatio</code>), but then should    *  produce a smaller FST.    *    *<p>The implementation of this method uses ideas from    *<a target="_blank" href="http://www.cs.put.poznan.pl/dweiss/site/publications/download/fsacomp.pdf">Smaller Representation of Finite State Automata</a>,    *  which describes techniques to reduce the size of a FST.    *  However, this is not a strict implementation of the    *  algorithms described in this paper.    */
DECL|method|pack
name|FST
argument_list|<
name|T
argument_list|>
name|pack
parameter_list|(
name|int
name|minInCountDeref
parameter_list|,
name|int
name|maxDerefNodes
parameter_list|,
name|float
name|acceptableOverheadRatio
parameter_list|)
throws|throws
name|IOException
block|{
comment|// NOTE: maxDerefNodes is intentionally int: we cannot
comment|// support> 2.1B deref nodes
comment|// TODO: other things to try
comment|//   - renumber the nodes to get more next / better locality?
comment|//   - allow multiple input labels on an arc, so
comment|//     singular chain of inputs can take one arc (on
comment|//     wikipedia terms this could save another ~6%)
comment|//   - in the ord case, the output '1' is presumably
comment|//     very common (after NO_OUTPUT)... maybe use a bit
comment|//     for it..?
comment|//   - use spare bits in flags.... for top few labels /
comment|//     outputs / targets
if|if
condition|(
name|nodeAddress
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"this FST was not built with willPackFST=true"
argument_list|)
throw|;
block|}
name|Arc
argument_list|<
name|T
argument_list|>
name|arc
init|=
operator|new
name|Arc
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|BytesReader
name|r
init|=
name|getBytesReader
argument_list|()
decl_stmt|;
specifier|final
name|int
name|topN
init|=
name|Math
operator|.
name|min
argument_list|(
name|maxDerefNodes
argument_list|,
name|inCounts
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
comment|// Find top nodes with highest number of incoming arcs:
name|NodeQueue
name|q
init|=
operator|new
name|NodeQueue
argument_list|(
name|topN
argument_list|)
decl_stmt|;
comment|// TODO: we could use more RAM efficient selection algo here...
name|NodeAndInCount
name|bottom
init|=
literal|null
decl_stmt|;
for|for
control|(
name|int
name|node
init|=
literal|0
init|;
name|node
operator|<
name|inCounts
operator|.
name|size
argument_list|()
condition|;
name|node
operator|++
control|)
block|{
if|if
condition|(
name|inCounts
operator|.
name|get
argument_list|(
name|node
argument_list|)
operator|>=
name|minInCountDeref
condition|)
block|{
if|if
condition|(
name|bottom
operator|==
literal|null
condition|)
block|{
name|q
operator|.
name|add
argument_list|(
operator|new
name|NodeAndInCount
argument_list|(
name|node
argument_list|,
operator|(
name|int
operator|)
name|inCounts
operator|.
name|get
argument_list|(
name|node
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|.
name|size
argument_list|()
operator|==
name|topN
condition|)
block|{
name|bottom
operator|=
name|q
operator|.
name|top
argument_list|()
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|inCounts
operator|.
name|get
argument_list|(
name|node
argument_list|)
operator|>
name|bottom
operator|.
name|count
condition|)
block|{
name|q
operator|.
name|insertWithOverflow
argument_list|(
operator|new
name|NodeAndInCount
argument_list|(
name|node
argument_list|,
operator|(
name|int
operator|)
name|inCounts
operator|.
name|get
argument_list|(
name|node
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// Free up RAM:
name|inCounts
operator|=
literal|null
expr_stmt|;
specifier|final
name|Map
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|topNodeMap
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|downTo
init|=
name|q
operator|.
name|size
argument_list|()
operator|-
literal|1
init|;
name|downTo
operator|>=
literal|0
condition|;
name|downTo
operator|--
control|)
block|{
name|NodeAndInCount
name|n
init|=
name|q
operator|.
name|pop
argument_list|()
decl_stmt|;
name|topNodeMap
operator|.
name|put
argument_list|(
name|n
operator|.
name|node
argument_list|,
name|downTo
argument_list|)
expr_stmt|;
comment|//System.out.println("map node=" + n.node + " inCount=" + n.count + " to newID=" + downTo);
block|}
comment|// +1 because node ords start at 1 (0 is reserved as stop node):
specifier|final
name|GrowableWriter
name|newNodeAddress
init|=
operator|new
name|GrowableWriter
argument_list|(
name|PackedInts
operator|.
name|bitsRequired
argument_list|(
name|this
operator|.
name|bytes
operator|.
name|getPosition
argument_list|()
argument_list|)
argument_list|,
call|(
name|int
call|)
argument_list|(
literal|1
operator|+
name|nodeCount
argument_list|)
argument_list|,
name|acceptableOverheadRatio
argument_list|)
decl_stmt|;
comment|// Fill initial coarse guess:
for|for
control|(
name|int
name|node
init|=
literal|1
init|;
name|node
operator|<=
name|nodeCount
condition|;
name|node
operator|++
control|)
block|{
name|newNodeAddress
operator|.
name|set
argument_list|(
name|node
argument_list|,
literal|1
operator|+
name|this
operator|.
name|bytes
operator|.
name|getPosition
argument_list|()
operator|-
name|nodeAddress
operator|.
name|get
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|int
name|absCount
decl_stmt|;
name|int
name|deltaCount
decl_stmt|;
name|int
name|topCount
decl_stmt|;
name|int
name|nextCount
decl_stmt|;
name|FST
argument_list|<
name|T
argument_list|>
name|fst
decl_stmt|;
comment|// Iterate until we converge:
while|while
condition|(
literal|true
condition|)
block|{
comment|//System.out.println("\nITER");
name|boolean
name|changed
init|=
literal|false
decl_stmt|;
comment|// for assert:
name|boolean
name|negDelta
init|=
literal|false
decl_stmt|;
name|fst
operator|=
operator|new
name|FST
argument_list|<>
argument_list|(
name|inputType
argument_list|,
name|outputs
argument_list|,
name|bytes
operator|.
name|getBlockBits
argument_list|()
argument_list|)
expr_stmt|;
specifier|final
name|BytesStore
name|writer
init|=
name|fst
operator|.
name|bytes
decl_stmt|;
comment|// Skip 0 byte since 0 is reserved target:
name|writer
operator|.
name|writeByte
argument_list|(
operator|(
name|byte
operator|)
literal|0
argument_list|)
expr_stmt|;
name|fst
operator|.
name|arcWithOutputCount
operator|=
literal|0
expr_stmt|;
name|fst
operator|.
name|nodeCount
operator|=
literal|0
expr_stmt|;
name|fst
operator|.
name|arcCount
operator|=
literal|0
expr_stmt|;
name|absCount
operator|=
name|deltaCount
operator|=
name|topCount
operator|=
name|nextCount
operator|=
literal|0
expr_stmt|;
name|int
name|changedCount
init|=
literal|0
decl_stmt|;
name|long
name|addressError
init|=
literal|0
decl_stmt|;
comment|//int totWasted = 0;
comment|// Since we re-reverse the bytes, we now write the
comment|// nodes backwards, so that BIT_TARGET_NEXT is
comment|// unchanged:
for|for
control|(
name|int
name|node
init|=
operator|(
name|int
operator|)
name|nodeCount
init|;
name|node
operator|>=
literal|1
condition|;
name|node
operator|--
control|)
block|{
name|fst
operator|.
name|nodeCount
operator|++
expr_stmt|;
specifier|final
name|long
name|address
init|=
name|writer
operator|.
name|getPosition
argument_list|()
decl_stmt|;
comment|//System.out.println("  node: " + node + " address=" + address);
if|if
condition|(
name|address
operator|!=
name|newNodeAddress
operator|.
name|get
argument_list|(
name|node
argument_list|)
condition|)
block|{
name|addressError
operator|=
name|address
operator|-
name|newNodeAddress
operator|.
name|get
argument_list|(
name|node
argument_list|)
expr_stmt|;
comment|//System.out.println("    change: " + (address - newNodeAddress[node]));
name|changed
operator|=
literal|true
expr_stmt|;
name|newNodeAddress
operator|.
name|set
argument_list|(
name|node
argument_list|,
name|address
argument_list|)
expr_stmt|;
name|changedCount
operator|++
expr_stmt|;
block|}
name|int
name|nodeArcCount
init|=
literal|0
decl_stmt|;
name|int
name|bytesPerArc
init|=
literal|0
decl_stmt|;
name|boolean
name|retry
init|=
literal|false
decl_stmt|;
comment|// for assert:
name|boolean
name|anyNegDelta
init|=
literal|false
decl_stmt|;
comment|// Retry loop: possibly iterate more than once, if
comment|// this is an array'd node and bytesPerArc changes:
name|writeNode
label|:
while|while
condition|(
literal|true
condition|)
block|{
comment|// retry writing this node
comment|//System.out.println("  cycle: retry");
name|readFirstRealTargetArc
argument_list|(
name|node
argument_list|,
name|arc
argument_list|,
name|r
argument_list|)
expr_stmt|;
specifier|final
name|boolean
name|useArcArray
init|=
name|arc
operator|.
name|bytesPerArc
operator|!=
literal|0
decl_stmt|;
if|if
condition|(
name|useArcArray
condition|)
block|{
comment|// Write false first arc:
if|if
condition|(
name|bytesPerArc
operator|==
literal|0
condition|)
block|{
name|bytesPerArc
operator|=
name|arc
operator|.
name|bytesPerArc
expr_stmt|;
block|}
name|writer
operator|.
name|writeByte
argument_list|(
name|ARCS_AS_FIXED_ARRAY
argument_list|)
expr_stmt|;
name|writer
operator|.
name|writeVInt
argument_list|(
name|arc
operator|.
name|numArcs
argument_list|)
expr_stmt|;
name|writer
operator|.
name|writeVInt
argument_list|(
name|bytesPerArc
argument_list|)
expr_stmt|;
comment|//System.out.println("node " + node + ": " + arc.numArcs + " arcs");
block|}
name|int
name|maxBytesPerArc
init|=
literal|0
decl_stmt|;
comment|//int wasted = 0;
while|while
condition|(
literal|true
condition|)
block|{
comment|// iterate over all arcs for this node
comment|//System.out.println("    cycle next arc");
specifier|final
name|long
name|arcStartPos
init|=
name|writer
operator|.
name|getPosition
argument_list|()
decl_stmt|;
name|nodeArcCount
operator|++
expr_stmt|;
name|byte
name|flags
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|arc
operator|.
name|isLast
argument_list|()
condition|)
block|{
name|flags
operator|+=
name|BIT_LAST_ARC
expr_stmt|;
block|}
comment|/*             if (!useArcArray&& nodeUpto< nodes.length-1&& arc.target == nodes[nodeUpto+1]) {               flags += BIT_TARGET_NEXT;             }             */
if|if
condition|(
operator|!
name|useArcArray
operator|&&
name|node
operator|!=
literal|1
operator|&&
name|arc
operator|.
name|target
operator|==
name|node
operator|-
literal|1
condition|)
block|{
name|flags
operator|+=
name|BIT_TARGET_NEXT
expr_stmt|;
if|if
condition|(
operator|!
name|retry
condition|)
block|{
name|nextCount
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|arc
operator|.
name|isFinal
argument_list|()
condition|)
block|{
name|flags
operator|+=
name|BIT_FINAL_ARC
expr_stmt|;
if|if
condition|(
name|arc
operator|.
name|nextFinalOutput
operator|!=
name|NO_OUTPUT
condition|)
block|{
name|flags
operator|+=
name|BIT_ARC_HAS_FINAL_OUTPUT
expr_stmt|;
block|}
block|}
else|else
block|{
assert|assert
name|arc
operator|.
name|nextFinalOutput
operator|==
name|NO_OUTPUT
assert|;
block|}
if|if
condition|(
operator|!
name|targetHasArcs
argument_list|(
name|arc
argument_list|)
condition|)
block|{
name|flags
operator|+=
name|BIT_STOP_NODE
expr_stmt|;
block|}
if|if
condition|(
name|arc
operator|.
name|output
operator|!=
name|NO_OUTPUT
condition|)
block|{
name|flags
operator|+=
name|BIT_ARC_HAS_OUTPUT
expr_stmt|;
block|}
specifier|final
name|long
name|absPtr
decl_stmt|;
specifier|final
name|boolean
name|doWriteTarget
init|=
name|targetHasArcs
argument_list|(
name|arc
argument_list|)
operator|&&
operator|(
name|flags
operator|&
name|BIT_TARGET_NEXT
operator|)
operator|==
literal|0
decl_stmt|;
if|if
condition|(
name|doWriteTarget
condition|)
block|{
specifier|final
name|Integer
name|ptr
init|=
name|topNodeMap
operator|.
name|get
argument_list|(
name|arc
operator|.
name|target
argument_list|)
decl_stmt|;
if|if
condition|(
name|ptr
operator|!=
literal|null
condition|)
block|{
name|absPtr
operator|=
name|ptr
expr_stmt|;
block|}
else|else
block|{
name|absPtr
operator|=
name|topNodeMap
operator|.
name|size
argument_list|()
operator|+
name|newNodeAddress
operator|.
name|get
argument_list|(
operator|(
name|int
operator|)
name|arc
operator|.
name|target
argument_list|)
operator|+
name|addressError
expr_stmt|;
block|}
name|long
name|delta
init|=
name|newNodeAddress
operator|.
name|get
argument_list|(
operator|(
name|int
operator|)
name|arc
operator|.
name|target
argument_list|)
operator|+
name|addressError
operator|-
name|writer
operator|.
name|getPosition
argument_list|()
operator|-
literal|2
decl_stmt|;
if|if
condition|(
name|delta
operator|<
literal|0
condition|)
block|{
comment|//System.out.println("neg: " + delta);
name|anyNegDelta
operator|=
literal|true
expr_stmt|;
name|delta
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|delta
operator|<
name|absPtr
condition|)
block|{
name|flags
operator||=
name|BIT_TARGET_DELTA
expr_stmt|;
block|}
block|}
else|else
block|{
name|absPtr
operator|=
literal|0
expr_stmt|;
block|}
assert|assert
name|flags
operator|!=
name|ARCS_AS_FIXED_ARRAY
assert|;
name|writer
operator|.
name|writeByte
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|fst
operator|.
name|writeLabel
argument_list|(
name|writer
argument_list|,
name|arc
operator|.
name|label
argument_list|)
expr_stmt|;
if|if
condition|(
name|arc
operator|.
name|output
operator|!=
name|NO_OUTPUT
condition|)
block|{
name|outputs
operator|.
name|write
argument_list|(
name|arc
operator|.
name|output
argument_list|,
name|writer
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|retry
condition|)
block|{
name|fst
operator|.
name|arcWithOutputCount
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|arc
operator|.
name|nextFinalOutput
operator|!=
name|NO_OUTPUT
condition|)
block|{
name|outputs
operator|.
name|writeFinalOutput
argument_list|(
name|arc
operator|.
name|nextFinalOutput
argument_list|,
name|writer
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|doWriteTarget
condition|)
block|{
name|long
name|delta
init|=
name|newNodeAddress
operator|.
name|get
argument_list|(
operator|(
name|int
operator|)
name|arc
operator|.
name|target
argument_list|)
operator|+
name|addressError
operator|-
name|writer
operator|.
name|getPosition
argument_list|()
decl_stmt|;
if|if
condition|(
name|delta
operator|<
literal|0
condition|)
block|{
name|anyNegDelta
operator|=
literal|true
expr_stmt|;
comment|//System.out.println("neg: " + delta);
name|delta
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|flag
argument_list|(
name|flags
argument_list|,
name|BIT_TARGET_DELTA
argument_list|)
condition|)
block|{
comment|//System.out.println("        delta");
name|writer
operator|.
name|writeVLong
argument_list|(
name|delta
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|retry
condition|)
block|{
name|deltaCount
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/*                 if (ptr != null) {                   System.out.println("        deref");                 } else {                   System.out.println("        abs");                 }                 */
name|writer
operator|.
name|writeVLong
argument_list|(
name|absPtr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|retry
condition|)
block|{
if|if
condition|(
name|absPtr
operator|>=
name|topNodeMap
operator|.
name|size
argument_list|()
condition|)
block|{
name|absCount
operator|++
expr_stmt|;
block|}
else|else
block|{
name|topCount
operator|++
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|useArcArray
condition|)
block|{
specifier|final
name|int
name|arcBytes
init|=
call|(
name|int
call|)
argument_list|(
name|writer
operator|.
name|getPosition
argument_list|()
operator|-
name|arcStartPos
argument_list|)
decl_stmt|;
comment|//System.out.println("  " + arcBytes + " bytes");
name|maxBytesPerArc
operator|=
name|Math
operator|.
name|max
argument_list|(
name|maxBytesPerArc
argument_list|,
name|arcBytes
argument_list|)
expr_stmt|;
comment|// NOTE: this may in fact go "backwards", if
comment|// somehow (rarely, possibly never) we use
comment|// more bytesPerArc in this rewrite than the
comment|// incoming FST did... but in this case we
comment|// will retry (below) so it's OK to ovewrite
comment|// bytes:
comment|//wasted += bytesPerArc - arcBytes;
name|writer
operator|.
name|skipBytes
argument_list|(
call|(
name|int
call|)
argument_list|(
name|arcStartPos
operator|+
name|bytesPerArc
operator|-
name|writer
operator|.
name|getPosition
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|arc
operator|.
name|isLast
argument_list|()
condition|)
block|{
break|break;
block|}
name|readNextRealArc
argument_list|(
name|arc
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|useArcArray
condition|)
block|{
if|if
condition|(
name|maxBytesPerArc
operator|==
name|bytesPerArc
operator|||
operator|(
name|retry
operator|&&
name|maxBytesPerArc
operator|<=
name|bytesPerArc
operator|)
condition|)
block|{
comment|// converged
comment|//System.out.println("  bba=" + bytesPerArc + " wasted=" + wasted);
comment|//totWasted += wasted;
break|break;
block|}
block|}
else|else
block|{
break|break;
block|}
comment|//System.out.println("  retry this node maxBytesPerArc=" + maxBytesPerArc + " vs " + bytesPerArc);
comment|// Retry:
name|bytesPerArc
operator|=
name|maxBytesPerArc
expr_stmt|;
name|writer
operator|.
name|truncate
argument_list|(
name|address
argument_list|)
expr_stmt|;
name|nodeArcCount
operator|=
literal|0
expr_stmt|;
name|retry
operator|=
literal|true
expr_stmt|;
name|anyNegDelta
operator|=
literal|false
expr_stmt|;
block|}
name|negDelta
operator||=
name|anyNegDelta
expr_stmt|;
name|fst
operator|.
name|arcCount
operator|+=
name|nodeArcCount
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|changed
condition|)
block|{
comment|// We don't renumber the nodes (just reverse their
comment|// order) so nodes should only point forward to
comment|// other nodes because we only produce acyclic FSTs
comment|// w/ nodes only pointing "forwards":
assert|assert
operator|!
name|negDelta
assert|;
comment|//System.out.println("TOT wasted=" + totWasted);
comment|// Converged!
break|break;
block|}
comment|//System.out.println("  " + changedCount + " of " + fst.nodeCount + " changed; retry");
block|}
name|long
name|maxAddress
init|=
literal|0
decl_stmt|;
for|for
control|(
name|long
name|key
range|:
name|topNodeMap
operator|.
name|keySet
argument_list|()
control|)
block|{
name|maxAddress
operator|=
name|Math
operator|.
name|max
argument_list|(
name|maxAddress
argument_list|,
name|newNodeAddress
operator|.
name|get
argument_list|(
operator|(
name|int
operator|)
name|key
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|PackedInts
operator|.
name|Mutable
name|nodeRefToAddressIn
init|=
name|PackedInts
operator|.
name|getMutable
argument_list|(
name|topNodeMap
operator|.
name|size
argument_list|()
argument_list|,
name|PackedInts
operator|.
name|bitsRequired
argument_list|(
name|maxAddress
argument_list|)
argument_list|,
name|acceptableOverheadRatio
argument_list|)
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|ent
range|:
name|topNodeMap
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|nodeRefToAddressIn
operator|.
name|set
argument_list|(
name|ent
operator|.
name|getValue
argument_list|()
argument_list|,
name|newNodeAddress
operator|.
name|get
argument_list|(
name|ent
operator|.
name|getKey
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|fst
operator|.
name|nodeRefToAddress
operator|=
name|nodeRefToAddressIn
expr_stmt|;
name|fst
operator|.
name|startNode
operator|=
name|newNodeAddress
operator|.
name|get
argument_list|(
operator|(
name|int
operator|)
name|startNode
argument_list|)
expr_stmt|;
comment|//System.out.println("new startNode=" + fst.startNode + " old startNode=" + startNode);
if|if
condition|(
name|emptyOutput
operator|!=
literal|null
condition|)
block|{
name|fst
operator|.
name|setEmptyOutput
argument_list|(
name|emptyOutput
argument_list|)
expr_stmt|;
block|}
assert|assert
name|fst
operator|.
name|nodeCount
operator|==
name|nodeCount
operator|:
literal|"fst.nodeCount="
operator|+
name|fst
operator|.
name|nodeCount
operator|+
literal|" nodeCount="
operator|+
name|nodeCount
assert|;
assert|assert
name|fst
operator|.
name|arcCount
operator|==
name|arcCount
assert|;
assert|assert
name|fst
operator|.
name|arcWithOutputCount
operator|==
name|arcWithOutputCount
operator|:
literal|"fst.arcWithOutputCount="
operator|+
name|fst
operator|.
name|arcWithOutputCount
operator|+
literal|" arcWithOutputCount="
operator|+
name|arcWithOutputCount
assert|;
name|fst
operator|.
name|bytes
operator|.
name|finish
argument_list|()
expr_stmt|;
name|fst
operator|.
name|cacheRootArcs
argument_list|()
expr_stmt|;
comment|//final int size = fst.sizeInBytes();
comment|//System.out.println("nextCount=" + nextCount + " topCount=" + topCount + " deltaCount=" + deltaCount + " absCount=" + absCount);
return|return
name|fst
return|;
block|}
DECL|class|NodeAndInCount
specifier|private
specifier|static
class|class
name|NodeAndInCount
implements|implements
name|Comparable
argument_list|<
name|NodeAndInCount
argument_list|>
block|{
DECL|field|node
specifier|final
name|int
name|node
decl_stmt|;
DECL|field|count
specifier|final
name|int
name|count
decl_stmt|;
DECL|method|NodeAndInCount
specifier|public
name|NodeAndInCount
parameter_list|(
name|int
name|node
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|this
operator|.
name|node
operator|=
name|node
expr_stmt|;
name|this
operator|.
name|count
operator|=
name|count
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|compareTo
specifier|public
name|int
name|compareTo
parameter_list|(
name|NodeAndInCount
name|other
parameter_list|)
block|{
if|if
condition|(
name|count
operator|>
name|other
operator|.
name|count
condition|)
block|{
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|count
operator|<
name|other
operator|.
name|count
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
else|else
block|{
comment|// Tie-break: smaller node compares as greater than
return|return
name|other
operator|.
name|node
operator|-
name|node
return|;
block|}
block|}
block|}
DECL|class|NodeQueue
specifier|private
specifier|static
class|class
name|NodeQueue
extends|extends
name|PriorityQueue
argument_list|<
name|NodeAndInCount
argument_list|>
block|{
DECL|method|NodeQueue
specifier|public
name|NodeQueue
parameter_list|(
name|int
name|topN
parameter_list|)
block|{
name|super
argument_list|(
name|topN
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|lessThan
specifier|public
name|boolean
name|lessThan
parameter_list|(
name|NodeAndInCount
name|a
parameter_list|,
name|NodeAndInCount
name|b
parameter_list|)
block|{
specifier|final
name|int
name|cmp
init|=
name|a
operator|.
name|compareTo
argument_list|(
name|b
argument_list|)
decl_stmt|;
assert|assert
name|cmp
operator|!=
literal|0
assert|;
return|return
name|cmp
operator|<
literal|0
return|;
block|}
block|}
block|}
end_class
end_unit
