begin_unit
begin_package
DECL|package|org.apache.lucene.util.fst
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|fst
package|;
end_package
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|BufferedInputStream
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|BufferedOutputStream
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileInputStream
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileOutputStream
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStream
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|codecs
operator|.
name|CodecUtil
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|DataInput
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|DataOutput
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|InputStreamDataInput
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|OutputStreamDataOutput
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|ArrayUtil
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|IOUtils
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|IntsRef
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|PriorityQueue
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|fst
operator|.
name|Builder
operator|.
name|UnCompiledNode
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|packed
operator|.
name|GrowableWriter
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|packed
operator|.
name|PackedInts
import|;
end_import
begin_comment
comment|// TODO: break this into WritableFST and ReadOnlyFST.. then
end_comment
begin_comment
comment|// we can have subclasses of ReadOnlyFST to handle the
end_comment
begin_comment
comment|// different byte[] level encodings (packed or
end_comment
begin_comment
comment|// not)... and things like nodeCount, arcCount are read only
end_comment
begin_comment
comment|// TODO: if FST is pure prefix trie we can do a more compact
end_comment
begin_comment
comment|// job, ie, once we are at a 'suffix only', just store the
end_comment
begin_comment
comment|// completion labels as a string not as a series of arcs.
end_comment
begin_comment
comment|// TODO: maybe make an explicit thread state that holds
end_comment
begin_comment
comment|// reusable stuff eg BytesReader, a scratch arc
end_comment
begin_comment
comment|// NOTE: while the FST is able to represent a non-final
end_comment
begin_comment
comment|// dead-end state (NON_FINAL_END_NODE=0), the layers above
end_comment
begin_comment
comment|// (FSTEnum, Util) have problems with this!!
end_comment
begin_comment
comment|/** Represents an finite state machine (FST), using a  *  compact byte[] format.  *<p> The format is similar to what's used by Morfologik  *  (http://sourceforge.net/projects/morfologik).  *    *<p> See the {@link org.apache.lucene.util.fst package  *      documentation} for some simple examples.  *<p><b>NOTE</b>: the FST cannot be larger than ~2.1 GB  *  because it uses int to address the byte[].  *  * @lucene.experimental  */
end_comment
begin_class
DECL|class|FST
specifier|public
specifier|final
class|class
name|FST
parameter_list|<
name|T
parameter_list|>
block|{
comment|/** Specifies allowed range of each int input label for    *  this FST. */
DECL|enum|INPUT_TYPE
DECL|enum constant|BYTE1
DECL|enum constant|BYTE2
DECL|enum constant|BYTE4
specifier|public
specifier|static
enum|enum
name|INPUT_TYPE
block|{
name|BYTE1
block|,
name|BYTE2
block|,
name|BYTE4
block|}
empty_stmt|;
DECL|field|inputType
specifier|public
specifier|final
name|INPUT_TYPE
name|inputType
decl_stmt|;
DECL|field|BIT_FINAL_ARC
specifier|final
specifier|static
name|int
name|BIT_FINAL_ARC
init|=
literal|1
operator|<<
literal|0
decl_stmt|;
DECL|field|BIT_LAST_ARC
specifier|final
specifier|static
name|int
name|BIT_LAST_ARC
init|=
literal|1
operator|<<
literal|1
decl_stmt|;
DECL|field|BIT_TARGET_NEXT
specifier|final
specifier|static
name|int
name|BIT_TARGET_NEXT
init|=
literal|1
operator|<<
literal|2
decl_stmt|;
comment|// TODO: we can free up a bit if we can nuke this:
DECL|field|BIT_STOP_NODE
specifier|final
specifier|static
name|int
name|BIT_STOP_NODE
init|=
literal|1
operator|<<
literal|3
decl_stmt|;
DECL|field|BIT_ARC_HAS_OUTPUT
specifier|final
specifier|static
name|int
name|BIT_ARC_HAS_OUTPUT
init|=
literal|1
operator|<<
literal|4
decl_stmt|;
DECL|field|BIT_ARC_HAS_FINAL_OUTPUT
specifier|final
specifier|static
name|int
name|BIT_ARC_HAS_FINAL_OUTPUT
init|=
literal|1
operator|<<
literal|5
decl_stmt|;
comment|// Arcs are stored as fixed-size (per entry) array, so
comment|// that we can find an arc using binary search.  We do
comment|// this when number of arcs is> NUM_ARCS_ARRAY:
comment|// If set, the target node is delta coded vs current
comment|// position:
DECL|field|BIT_TARGET_DELTA
specifier|private
specifier|final
specifier|static
name|int
name|BIT_TARGET_DELTA
init|=
literal|1
operator|<<
literal|6
decl_stmt|;
DECL|field|ARCS_AS_FIXED_ARRAY
specifier|private
specifier|final
specifier|static
name|byte
name|ARCS_AS_FIXED_ARRAY
init|=
name|BIT_ARC_HAS_FINAL_OUTPUT
decl_stmt|;
comment|/**    * @see #shouldExpand(UnCompiledNode)    */
DECL|field|FIXED_ARRAY_SHALLOW_DISTANCE
specifier|final
specifier|static
name|int
name|FIXED_ARRAY_SHALLOW_DISTANCE
init|=
literal|3
decl_stmt|;
comment|// 0 => only root node.
comment|/**    * @see #shouldExpand(UnCompiledNode)    */
DECL|field|FIXED_ARRAY_NUM_ARCS_SHALLOW
specifier|final
specifier|static
name|int
name|FIXED_ARRAY_NUM_ARCS_SHALLOW
init|=
literal|5
decl_stmt|;
comment|/**    * @see #shouldExpand(UnCompiledNode)    */
DECL|field|FIXED_ARRAY_NUM_ARCS_DEEP
specifier|final
specifier|static
name|int
name|FIXED_ARRAY_NUM_ARCS_DEEP
init|=
literal|10
decl_stmt|;
DECL|field|bytesPerArc
specifier|private
name|int
index|[]
name|bytesPerArc
init|=
operator|new
name|int
index|[
literal|0
index|]
decl_stmt|;
comment|// Increment version to change it
DECL|field|FILE_FORMAT_NAME
specifier|private
specifier|final
specifier|static
name|String
name|FILE_FORMAT_NAME
init|=
literal|"FST"
decl_stmt|;
DECL|field|VERSION_START
specifier|private
specifier|final
specifier|static
name|int
name|VERSION_START
init|=
literal|0
decl_stmt|;
comment|/** Changed numBytesPerArc for array'd case from byte to int. */
DECL|field|VERSION_INT_NUM_BYTES_PER_ARC
specifier|private
specifier|final
specifier|static
name|int
name|VERSION_INT_NUM_BYTES_PER_ARC
init|=
literal|1
decl_stmt|;
comment|/** Write BYTE2 labels as 2-byte short, not vInt. */
DECL|field|VERSION_SHORT_BYTE2_LABELS
specifier|private
specifier|final
specifier|static
name|int
name|VERSION_SHORT_BYTE2_LABELS
init|=
literal|2
decl_stmt|;
comment|/** Added optional packed format. */
DECL|field|VERSION_PACKED
specifier|private
specifier|final
specifier|static
name|int
name|VERSION_PACKED
init|=
literal|3
decl_stmt|;
DECL|field|VERSION_CURRENT
specifier|private
specifier|final
specifier|static
name|int
name|VERSION_CURRENT
init|=
name|VERSION_PACKED
decl_stmt|;
comment|// Never serialized; just used to represent the virtual
comment|// final node w/ no arcs:
DECL|field|FINAL_END_NODE
specifier|private
specifier|final
specifier|static
name|int
name|FINAL_END_NODE
init|=
operator|-
literal|1
decl_stmt|;
comment|// Never serialized; just used to represent the virtual
comment|// non-final node w/ no arcs:
DECL|field|NON_FINAL_END_NODE
specifier|private
specifier|final
specifier|static
name|int
name|NON_FINAL_END_NODE
init|=
literal|0
decl_stmt|;
comment|// if non-null, this FST accepts the empty string and
comment|// produces this output
DECL|field|emptyOutput
name|T
name|emptyOutput
decl_stmt|;
DECL|field|emptyOutputBytes
specifier|private
name|byte
index|[]
name|emptyOutputBytes
decl_stmt|;
comment|// Not private to avoid synthetic access$NNN methods:
DECL|field|bytes
name|byte
index|[]
name|bytes
decl_stmt|;
DECL|field|byteUpto
name|int
name|byteUpto
init|=
literal|0
decl_stmt|;
DECL|field|startNode
specifier|private
name|int
name|startNode
init|=
operator|-
literal|1
decl_stmt|;
DECL|field|outputs
specifier|public
specifier|final
name|Outputs
argument_list|<
name|T
argument_list|>
name|outputs
decl_stmt|;
DECL|field|lastFrozenNode
specifier|private
name|int
name|lastFrozenNode
decl_stmt|;
DECL|field|NO_OUTPUT
specifier|private
specifier|final
name|T
name|NO_OUTPUT
decl_stmt|;
DECL|field|nodeCount
specifier|public
name|int
name|nodeCount
decl_stmt|;
DECL|field|arcCount
specifier|public
name|int
name|arcCount
decl_stmt|;
DECL|field|arcWithOutputCount
specifier|public
name|int
name|arcWithOutputCount
decl_stmt|;
DECL|field|packed
specifier|private
specifier|final
name|boolean
name|packed
decl_stmt|;
DECL|field|nodeRefToAddress
specifier|private
name|PackedInts
operator|.
name|Reader
name|nodeRefToAddress
decl_stmt|;
comment|/** If arc has this label then that arc is final/accepted */
DECL|field|END_LABEL
specifier|public
specifier|static
specifier|final
name|int
name|END_LABEL
init|=
operator|-
literal|1
decl_stmt|;
DECL|field|allowArrayArcs
specifier|private
name|boolean
name|allowArrayArcs
init|=
literal|true
decl_stmt|;
DECL|field|cachedRootArcs
specifier|private
name|Arc
argument_list|<
name|T
argument_list|>
name|cachedRootArcs
index|[]
decl_stmt|;
comment|/** Represents a single arc. */
DECL|class|Arc
specifier|public
specifier|final
specifier|static
class|class
name|Arc
parameter_list|<
name|T
parameter_list|>
block|{
DECL|field|label
specifier|public
name|int
name|label
decl_stmt|;
DECL|field|output
specifier|public
name|T
name|output
decl_stmt|;
comment|// From node (ord or address); currently only used when
comment|// building an FST w/ willPackFST=true:
DECL|field|node
name|int
name|node
decl_stmt|;
comment|/** To node (ord or address) */
DECL|field|target
specifier|public
name|int
name|target
decl_stmt|;
DECL|field|flags
name|byte
name|flags
decl_stmt|;
DECL|field|nextFinalOutput
specifier|public
name|T
name|nextFinalOutput
decl_stmt|;
comment|// address (into the byte[]), or ord/address if label == END_LABEL
DECL|field|nextArc
name|int
name|nextArc
decl_stmt|;
comment|// This is non-zero if current arcs are fixed array:
DECL|field|posArcsStart
name|int
name|posArcsStart
decl_stmt|;
DECL|field|bytesPerArc
name|int
name|bytesPerArc
decl_stmt|;
DECL|field|arcIdx
name|int
name|arcIdx
decl_stmt|;
DECL|field|numArcs
name|int
name|numArcs
decl_stmt|;
comment|/** Returns this */
DECL|method|copyFrom
specifier|public
name|Arc
argument_list|<
name|T
argument_list|>
name|copyFrom
parameter_list|(
name|Arc
argument_list|<
name|T
argument_list|>
name|other
parameter_list|)
block|{
name|node
operator|=
name|other
operator|.
name|node
expr_stmt|;
name|label
operator|=
name|other
operator|.
name|label
expr_stmt|;
name|target
operator|=
name|other
operator|.
name|target
expr_stmt|;
name|flags
operator|=
name|other
operator|.
name|flags
expr_stmt|;
name|output
operator|=
name|other
operator|.
name|output
expr_stmt|;
name|nextFinalOutput
operator|=
name|other
operator|.
name|nextFinalOutput
expr_stmt|;
name|nextArc
operator|=
name|other
operator|.
name|nextArc
expr_stmt|;
name|bytesPerArc
operator|=
name|other
operator|.
name|bytesPerArc
expr_stmt|;
if|if
condition|(
name|bytesPerArc
operator|!=
literal|0
condition|)
block|{
name|posArcsStart
operator|=
name|other
operator|.
name|posArcsStart
expr_stmt|;
name|arcIdx
operator|=
name|other
operator|.
name|arcIdx
expr_stmt|;
name|numArcs
operator|=
name|other
operator|.
name|numArcs
expr_stmt|;
block|}
return|return
name|this
return|;
block|}
DECL|method|flag
name|boolean
name|flag
parameter_list|(
name|int
name|flag
parameter_list|)
block|{
return|return
name|FST
operator|.
name|flag
argument_list|(
name|flags
argument_list|,
name|flag
argument_list|)
return|;
block|}
DECL|method|isLast
specifier|public
name|boolean
name|isLast
parameter_list|()
block|{
return|return
name|flag
argument_list|(
name|BIT_LAST_ARC
argument_list|)
return|;
block|}
DECL|method|isFinal
specifier|public
name|boolean
name|isFinal
parameter_list|()
block|{
return|return
name|flag
argument_list|(
name|BIT_FINAL_ARC
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
name|StringBuilder
name|b
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|b
operator|.
name|append
argument_list|(
literal|"node="
operator|+
name|node
argument_list|)
expr_stmt|;
name|b
operator|.
name|append
argument_list|(
literal|" target="
operator|+
name|target
argument_list|)
expr_stmt|;
name|b
operator|.
name|append
argument_list|(
literal|" label="
operator|+
name|label
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag
argument_list|(
name|BIT_LAST_ARC
argument_list|)
condition|)
block|{
name|b
operator|.
name|append
argument_list|(
literal|" last"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flag
argument_list|(
name|BIT_FINAL_ARC
argument_list|)
condition|)
block|{
name|b
operator|.
name|append
argument_list|(
literal|" final"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flag
argument_list|(
name|BIT_TARGET_NEXT
argument_list|)
condition|)
block|{
name|b
operator|.
name|append
argument_list|(
literal|" targetNext"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flag
argument_list|(
name|BIT_ARC_HAS_OUTPUT
argument_list|)
condition|)
block|{
name|b
operator|.
name|append
argument_list|(
literal|" output="
operator|+
name|output
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flag
argument_list|(
name|BIT_ARC_HAS_FINAL_OUTPUT
argument_list|)
condition|)
block|{
name|b
operator|.
name|append
argument_list|(
literal|" nextFinalOutput="
operator|+
name|nextFinalOutput
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bytesPerArc
operator|!=
literal|0
condition|)
block|{
name|b
operator|.
name|append
argument_list|(
literal|" arcArray(idx="
operator|+
name|arcIdx
operator|+
literal|" of "
operator|+
name|numArcs
operator|+
literal|")"
argument_list|)
expr_stmt|;
block|}
return|return
name|b
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
empty_stmt|;
DECL|method|flag
specifier|private
specifier|static
name|boolean
name|flag
parameter_list|(
name|int
name|flags
parameter_list|,
name|int
name|bit
parameter_list|)
block|{
return|return
operator|(
name|flags
operator|&
name|bit
operator|)
operator|!=
literal|0
return|;
block|}
DECL|field|writer
specifier|private
specifier|final
name|BytesWriter
name|writer
decl_stmt|;
DECL|field|nodeAddress
specifier|private
name|GrowableWriter
name|nodeAddress
decl_stmt|;
comment|// TODO: we could be smarter here, and prune periodically
comment|// as we go; high in-count nodes will "usually" become
comment|// clear early on:
DECL|field|inCounts
specifier|private
name|GrowableWriter
name|inCounts
decl_stmt|;
comment|// make a new empty FST, for building; Builder invokes
comment|// this ctor
DECL|method|FST
name|FST
parameter_list|(
name|INPUT_TYPE
name|inputType
parameter_list|,
name|Outputs
argument_list|<
name|T
argument_list|>
name|outputs
parameter_list|,
name|boolean
name|willPackFST
parameter_list|,
name|float
name|acceptableOverheadRatio
parameter_list|)
block|{
name|this
operator|.
name|inputType
operator|=
name|inputType
expr_stmt|;
name|this
operator|.
name|outputs
operator|=
name|outputs
expr_stmt|;
name|bytes
operator|=
operator|new
name|byte
index|[
literal|128
index|]
expr_stmt|;
name|NO_OUTPUT
operator|=
name|outputs
operator|.
name|getNoOutput
argument_list|()
expr_stmt|;
if|if
condition|(
name|willPackFST
condition|)
block|{
name|nodeAddress
operator|=
operator|new
name|GrowableWriter
argument_list|(
name|PackedInts
operator|.
name|bitsRequired
argument_list|(
name|bytes
operator|.
name|length
operator|-
literal|1
argument_list|)
argument_list|,
literal|8
argument_list|,
name|acceptableOverheadRatio
argument_list|)
expr_stmt|;
name|inCounts
operator|=
operator|new
name|GrowableWriter
argument_list|(
literal|1
argument_list|,
literal|8
argument_list|,
name|acceptableOverheadRatio
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|nodeAddress
operator|=
literal|null
expr_stmt|;
name|inCounts
operator|=
literal|null
expr_stmt|;
block|}
name|writer
operator|=
operator|new
name|DefaultBytesWriter
argument_list|()
expr_stmt|;
name|emptyOutput
operator|=
literal|null
expr_stmt|;
name|packed
operator|=
literal|false
expr_stmt|;
name|nodeRefToAddress
operator|=
literal|null
expr_stmt|;
block|}
comment|/** Load a previously saved FST. */
DECL|method|FST
specifier|public
name|FST
parameter_list|(
name|DataInput
name|in
parameter_list|,
name|Outputs
argument_list|<
name|T
argument_list|>
name|outputs
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|outputs
operator|=
name|outputs
expr_stmt|;
name|writer
operator|=
literal|null
expr_stmt|;
comment|// NOTE: only reads most recent format; we don't have
comment|// back-compat promise for FSTs (they are experimental):
name|CodecUtil
operator|.
name|checkHeader
argument_list|(
name|in
argument_list|,
name|FILE_FORMAT_NAME
argument_list|,
name|VERSION_PACKED
argument_list|,
name|VERSION_PACKED
argument_list|)
expr_stmt|;
name|packed
operator|=
name|in
operator|.
name|readByte
argument_list|()
operator|==
literal|1
expr_stmt|;
if|if
condition|(
name|in
operator|.
name|readByte
argument_list|()
operator|==
literal|1
condition|)
block|{
comment|// accepts empty string
name|int
name|numBytes
init|=
name|in
operator|.
name|readVInt
argument_list|()
decl_stmt|;
comment|// messy
name|bytes
operator|=
operator|new
name|byte
index|[
name|numBytes
index|]
expr_stmt|;
name|in
operator|.
name|readBytes
argument_list|(
name|bytes
argument_list|,
literal|0
argument_list|,
name|numBytes
argument_list|)
expr_stmt|;
name|BytesReader
name|reader
decl_stmt|;
if|if
condition|(
name|packed
condition|)
block|{
name|reader
operator|=
name|getBytesReader
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|reader
operator|=
name|getBytesReader
argument_list|(
name|numBytes
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|emptyOutput
operator|=
name|outputs
operator|.
name|readFinalOutput
argument_list|(
name|reader
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|emptyOutput
operator|=
literal|null
expr_stmt|;
block|}
specifier|final
name|byte
name|t
init|=
name|in
operator|.
name|readByte
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|t
condition|)
block|{
case|case
literal|0
case|:
name|inputType
operator|=
name|INPUT_TYPE
operator|.
name|BYTE1
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|inputType
operator|=
name|INPUT_TYPE
operator|.
name|BYTE2
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|inputType
operator|=
name|INPUT_TYPE
operator|.
name|BYTE4
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"invalid input type "
operator|+
name|t
argument_list|)
throw|;
block|}
if|if
condition|(
name|packed
condition|)
block|{
name|nodeRefToAddress
operator|=
name|PackedInts
operator|.
name|getReader
argument_list|(
name|in
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|nodeRefToAddress
operator|=
literal|null
expr_stmt|;
block|}
name|startNode
operator|=
name|in
operator|.
name|readVInt
argument_list|()
expr_stmt|;
name|nodeCount
operator|=
name|in
operator|.
name|readVInt
argument_list|()
expr_stmt|;
name|arcCount
operator|=
name|in
operator|.
name|readVInt
argument_list|()
expr_stmt|;
name|arcWithOutputCount
operator|=
name|in
operator|.
name|readVInt
argument_list|()
expr_stmt|;
name|bytes
operator|=
operator|new
name|byte
index|[
name|in
operator|.
name|readVInt
argument_list|()
index|]
expr_stmt|;
name|in
operator|.
name|readBytes
argument_list|(
name|bytes
argument_list|,
literal|0
argument_list|,
name|bytes
operator|.
name|length
argument_list|)
expr_stmt|;
name|NO_OUTPUT
operator|=
name|outputs
operator|.
name|getNoOutput
argument_list|()
expr_stmt|;
name|cacheRootArcs
argument_list|()
expr_stmt|;
block|}
DECL|method|getInputType
specifier|public
name|INPUT_TYPE
name|getInputType
parameter_list|()
block|{
return|return
name|inputType
return|;
block|}
comment|/** Returns bytes used to represent the FST */
DECL|method|sizeInBytes
specifier|public
name|int
name|sizeInBytes
parameter_list|()
block|{
name|int
name|size
init|=
name|bytes
operator|.
name|length
decl_stmt|;
if|if
condition|(
name|packed
condition|)
block|{
name|size
operator|+=
name|nodeRefToAddress
operator|.
name|ramBytesUsed
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nodeAddress
operator|!=
literal|null
condition|)
block|{
name|size
operator|+=
name|nodeAddress
operator|.
name|ramBytesUsed
argument_list|()
expr_stmt|;
name|size
operator|+=
name|inCounts
operator|.
name|ramBytesUsed
argument_list|()
expr_stmt|;
block|}
return|return
name|size
return|;
block|}
DECL|method|finish
name|void
name|finish
parameter_list|(
name|int
name|startNode
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|startNode
operator|==
name|FINAL_END_NODE
operator|&&
name|emptyOutput
operator|!=
literal|null
condition|)
block|{
name|startNode
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|this
operator|.
name|startNode
operator|!=
operator|-
literal|1
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"already finished"
argument_list|)
throw|;
block|}
name|byte
index|[]
name|finalBytes
init|=
operator|new
name|byte
index|[
name|writer
operator|.
name|getPosition
argument_list|()
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|bytes
argument_list|,
literal|0
argument_list|,
name|finalBytes
argument_list|,
literal|0
argument_list|,
name|writer
operator|.
name|getPosition
argument_list|()
argument_list|)
expr_stmt|;
name|bytes
operator|=
name|finalBytes
expr_stmt|;
name|this
operator|.
name|startNode
operator|=
name|startNode
expr_stmt|;
name|cacheRootArcs
argument_list|()
expr_stmt|;
block|}
DECL|method|getNodeAddress
specifier|private
name|int
name|getNodeAddress
parameter_list|(
name|int
name|node
parameter_list|)
block|{
if|if
condition|(
name|nodeAddress
operator|!=
literal|null
condition|)
block|{
comment|// Deref
return|return
operator|(
name|int
operator|)
name|nodeAddress
operator|.
name|get
argument_list|(
name|node
argument_list|)
return|;
block|}
else|else
block|{
comment|// Straight
return|return
name|node
return|;
block|}
block|}
comment|// Caches first 128 labels
annotation|@
name|SuppressWarnings
argument_list|(
block|{
literal|"rawtypes"
block|,
literal|"unchecked"
block|}
argument_list|)
DECL|method|cacheRootArcs
specifier|private
name|void
name|cacheRootArcs
parameter_list|()
throws|throws
name|IOException
block|{
name|cachedRootArcs
operator|=
operator|(
name|Arc
argument_list|<
name|T
argument_list|>
index|[]
operator|)
operator|new
name|Arc
index|[
literal|0x80
index|]
expr_stmt|;
specifier|final
name|Arc
argument_list|<
name|T
argument_list|>
name|arc
init|=
operator|new
name|Arc
argument_list|<
name|T
argument_list|>
argument_list|()
decl_stmt|;
name|getFirstArc
argument_list|(
name|arc
argument_list|)
expr_stmt|;
specifier|final
name|BytesReader
name|in
init|=
name|getBytesReader
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|targetHasArcs
argument_list|(
name|arc
argument_list|)
condition|)
block|{
name|readFirstRealTargetArc
argument_list|(
name|arc
operator|.
name|target
argument_list|,
name|arc
argument_list|,
name|in
argument_list|)
expr_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
assert|assert
name|arc
operator|.
name|label
operator|!=
name|END_LABEL
assert|;
if|if
condition|(
name|arc
operator|.
name|label
operator|<
name|cachedRootArcs
operator|.
name|length
condition|)
block|{
name|cachedRootArcs
index|[
name|arc
operator|.
name|label
index|]
operator|=
operator|new
name|Arc
argument_list|<
name|T
argument_list|>
argument_list|()
operator|.
name|copyFrom
argument_list|(
name|arc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
break|break;
block|}
if|if
condition|(
name|arc
operator|.
name|isLast
argument_list|()
condition|)
block|{
break|break;
block|}
name|readNextRealArc
argument_list|(
name|arc
argument_list|,
name|in
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|getEmptyOutput
specifier|public
name|T
name|getEmptyOutput
parameter_list|()
block|{
return|return
name|emptyOutput
return|;
block|}
DECL|method|setEmptyOutput
name|void
name|setEmptyOutput
parameter_list|(
name|T
name|v
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|emptyOutput
operator|!=
literal|null
condition|)
block|{
name|emptyOutput
operator|=
name|outputs
operator|.
name|merge
argument_list|(
name|emptyOutput
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|emptyOutput
operator|=
name|v
expr_stmt|;
block|}
comment|// TODO: this is messy -- replace with sillyBytesWriter; maybe make
comment|// bytes private
specifier|final
name|int
name|posSave
init|=
name|writer
operator|.
name|getPosition
argument_list|()
decl_stmt|;
name|outputs
operator|.
name|writeFinalOutput
argument_list|(
name|emptyOutput
argument_list|,
name|writer
argument_list|)
expr_stmt|;
name|emptyOutputBytes
operator|=
operator|new
name|byte
index|[
name|writer
operator|.
name|getPosition
argument_list|()
operator|-
name|posSave
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|packed
condition|)
block|{
comment|// reverse
specifier|final
name|int
name|stopAt
init|=
operator|(
name|writer
operator|.
name|getPosition
argument_list|()
operator|-
name|posSave
operator|)
operator|/
literal|2
decl_stmt|;
name|int
name|upto
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|upto
operator|<
name|stopAt
condition|)
block|{
specifier|final
name|byte
name|b
init|=
name|bytes
index|[
name|posSave
operator|+
name|upto
index|]
decl_stmt|;
name|bytes
index|[
name|posSave
operator|+
name|upto
index|]
operator|=
name|bytes
index|[
name|writer
operator|.
name|getPosition
argument_list|()
operator|-
name|upto
operator|-
literal|1
index|]
expr_stmt|;
name|bytes
index|[
name|writer
operator|.
name|getPosition
argument_list|()
operator|-
name|upto
operator|-
literal|1
index|]
operator|=
name|b
expr_stmt|;
name|upto
operator|++
expr_stmt|;
block|}
block|}
name|System
operator|.
name|arraycopy
argument_list|(
name|bytes
argument_list|,
name|posSave
argument_list|,
name|emptyOutputBytes
argument_list|,
literal|0
argument_list|,
name|writer
operator|.
name|getPosition
argument_list|()
operator|-
name|posSave
argument_list|)
expr_stmt|;
name|writer
operator|.
name|setPosition
argument_list|(
name|posSave
argument_list|)
expr_stmt|;
block|}
DECL|method|save
specifier|public
name|void
name|save
parameter_list|(
name|DataOutput
name|out
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|startNode
operator|==
operator|-
literal|1
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"call finish first"
argument_list|)
throw|;
block|}
if|if
condition|(
name|nodeAddress
operator|!=
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"cannot save an FST pre-packed FST; it must first be packed"
argument_list|)
throw|;
block|}
if|if
condition|(
name|packed
operator|&&
operator|!
operator|(
name|nodeRefToAddress
operator|instanceof
name|PackedInts
operator|.
name|Mutable
operator|)
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"cannot save a FST which has been loaded from disk "
argument_list|)
throw|;
block|}
name|CodecUtil
operator|.
name|writeHeader
argument_list|(
name|out
argument_list|,
name|FILE_FORMAT_NAME
argument_list|,
name|VERSION_CURRENT
argument_list|)
expr_stmt|;
if|if
condition|(
name|packed
condition|)
block|{
name|out
operator|.
name|writeByte
argument_list|(
operator|(
name|byte
operator|)
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|out
operator|.
name|writeByte
argument_list|(
operator|(
name|byte
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
comment|// TODO: really we should encode this as an arc, arriving
comment|// to the root node, instead of special casing here:
if|if
condition|(
name|emptyOutput
operator|!=
literal|null
condition|)
block|{
name|out
operator|.
name|writeByte
argument_list|(
operator|(
name|byte
operator|)
literal|1
argument_list|)
expr_stmt|;
name|out
operator|.
name|writeVInt
argument_list|(
name|emptyOutputBytes
operator|.
name|length
argument_list|)
expr_stmt|;
name|out
operator|.
name|writeBytes
argument_list|(
name|emptyOutputBytes
argument_list|,
literal|0
argument_list|,
name|emptyOutputBytes
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|out
operator|.
name|writeByte
argument_list|(
operator|(
name|byte
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
specifier|final
name|byte
name|t
decl_stmt|;
if|if
condition|(
name|inputType
operator|==
name|INPUT_TYPE
operator|.
name|BYTE1
condition|)
block|{
name|t
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|inputType
operator|==
name|INPUT_TYPE
operator|.
name|BYTE2
condition|)
block|{
name|t
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|t
operator|=
literal|2
expr_stmt|;
block|}
name|out
operator|.
name|writeByte
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|packed
condition|)
block|{
operator|(
operator|(
name|PackedInts
operator|.
name|Mutable
operator|)
name|nodeRefToAddress
operator|)
operator|.
name|save
argument_list|(
name|out
argument_list|)
expr_stmt|;
block|}
name|out
operator|.
name|writeVInt
argument_list|(
name|startNode
argument_list|)
expr_stmt|;
name|out
operator|.
name|writeVInt
argument_list|(
name|nodeCount
argument_list|)
expr_stmt|;
name|out
operator|.
name|writeVInt
argument_list|(
name|arcCount
argument_list|)
expr_stmt|;
name|out
operator|.
name|writeVInt
argument_list|(
name|arcWithOutputCount
argument_list|)
expr_stmt|;
name|out
operator|.
name|writeVInt
argument_list|(
name|bytes
operator|.
name|length
argument_list|)
expr_stmt|;
name|out
operator|.
name|writeBytes
argument_list|(
name|bytes
argument_list|,
literal|0
argument_list|,
name|bytes
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
comment|/**    * Writes an automaton to a file.     */
DECL|method|save
specifier|public
name|void
name|save
parameter_list|(
specifier|final
name|File
name|file
parameter_list|)
throws|throws
name|IOException
block|{
name|boolean
name|success
init|=
literal|false
decl_stmt|;
name|OutputStream
name|os
init|=
operator|new
name|BufferedOutputStream
argument_list|(
operator|new
name|FileOutputStream
argument_list|(
name|file
argument_list|)
argument_list|)
decl_stmt|;
try|try
block|{
name|save
argument_list|(
operator|new
name|OutputStreamDataOutput
argument_list|(
name|os
argument_list|)
argument_list|)
expr_stmt|;
name|success
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
name|success
condition|)
block|{
name|IOUtils
operator|.
name|close
argument_list|(
name|os
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|IOUtils
operator|.
name|closeWhileHandlingException
argument_list|(
name|os
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Reads an automaton from a file.     */
DECL|method|read
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|FST
argument_list|<
name|T
argument_list|>
name|read
parameter_list|(
name|File
name|file
parameter_list|,
name|Outputs
argument_list|<
name|T
argument_list|>
name|outputs
parameter_list|)
throws|throws
name|IOException
block|{
name|InputStream
name|is
init|=
operator|new
name|BufferedInputStream
argument_list|(
operator|new
name|FileInputStream
argument_list|(
name|file
argument_list|)
argument_list|)
decl_stmt|;
name|boolean
name|success
init|=
literal|false
decl_stmt|;
try|try
block|{
name|FST
argument_list|<
name|T
argument_list|>
name|fst
init|=
operator|new
name|FST
argument_list|<
name|T
argument_list|>
argument_list|(
operator|new
name|InputStreamDataInput
argument_list|(
name|is
argument_list|)
argument_list|,
name|outputs
argument_list|)
decl_stmt|;
name|success
operator|=
literal|true
expr_stmt|;
return|return
name|fst
return|;
block|}
finally|finally
block|{
if|if
condition|(
name|success
condition|)
block|{
name|IOUtils
operator|.
name|close
argument_list|(
name|is
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|IOUtils
operator|.
name|closeWhileHandlingException
argument_list|(
name|is
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|writeLabel
specifier|private
name|void
name|writeLabel
parameter_list|(
name|int
name|v
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|v
operator|>=
literal|0
operator|:
literal|"v="
operator|+
name|v
assert|;
if|if
condition|(
name|inputType
operator|==
name|INPUT_TYPE
operator|.
name|BYTE1
condition|)
block|{
assert|assert
name|v
operator|<=
literal|255
operator|:
literal|"v="
operator|+
name|v
assert|;
name|writer
operator|.
name|writeByte
argument_list|(
operator|(
name|byte
operator|)
name|v
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|inputType
operator|==
name|INPUT_TYPE
operator|.
name|BYTE2
condition|)
block|{
assert|assert
name|v
operator|<=
literal|65535
operator|:
literal|"v="
operator|+
name|v
assert|;
name|writer
operator|.
name|writeShort
argument_list|(
operator|(
name|short
operator|)
name|v
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|//writeInt(v);
name|writer
operator|.
name|writeVInt
argument_list|(
name|v
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|readLabel
name|int
name|readLabel
parameter_list|(
name|DataInput
name|in
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|int
name|v
decl_stmt|;
if|if
condition|(
name|inputType
operator|==
name|INPUT_TYPE
operator|.
name|BYTE1
condition|)
block|{
comment|// Unsigned byte:
name|v
operator|=
name|in
operator|.
name|readByte
argument_list|()
operator|&
literal|0xFF
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|inputType
operator|==
name|INPUT_TYPE
operator|.
name|BYTE2
condition|)
block|{
comment|// Unsigned short:
name|v
operator|=
name|in
operator|.
name|readShort
argument_list|()
operator|&
literal|0xFFFF
expr_stmt|;
block|}
else|else
block|{
name|v
operator|=
name|in
operator|.
name|readVInt
argument_list|()
expr_stmt|;
block|}
return|return
name|v
return|;
block|}
comment|/** returns true if the node at this address has any    *  outgoing arcs */
DECL|method|targetHasArcs
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|boolean
name|targetHasArcs
parameter_list|(
name|Arc
argument_list|<
name|T
argument_list|>
name|arc
parameter_list|)
block|{
return|return
name|arc
operator|.
name|target
operator|>
literal|0
return|;
block|}
comment|// serializes new node by appending its bytes to the end
comment|// of the current byte[]
DECL|method|addNode
name|int
name|addNode
parameter_list|(
name|Builder
operator|.
name|UnCompiledNode
argument_list|<
name|T
argument_list|>
name|nodeIn
parameter_list|)
throws|throws
name|IOException
block|{
comment|//System.out.println("FST.addNode pos=" + writer.posWrite + " numArcs=" + nodeIn.numArcs);
if|if
condition|(
name|nodeIn
operator|.
name|numArcs
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|nodeIn
operator|.
name|isFinal
condition|)
block|{
return|return
name|FINAL_END_NODE
return|;
block|}
else|else
block|{
return|return
name|NON_FINAL_END_NODE
return|;
block|}
block|}
name|int
name|startAddress
init|=
name|writer
operator|.
name|getPosition
argument_list|()
decl_stmt|;
comment|//System.out.println("  startAddr=" + startAddress);
specifier|final
name|boolean
name|doFixedArray
init|=
name|shouldExpand
argument_list|(
name|nodeIn
argument_list|)
decl_stmt|;
specifier|final
name|int
name|fixedArrayStart
decl_stmt|;
if|if
condition|(
name|doFixedArray
condition|)
block|{
if|if
condition|(
name|bytesPerArc
operator|.
name|length
operator|<
name|nodeIn
operator|.
name|numArcs
condition|)
block|{
name|bytesPerArc
operator|=
operator|new
name|int
index|[
name|ArrayUtil
operator|.
name|oversize
argument_list|(
name|nodeIn
operator|.
name|numArcs
argument_list|,
literal|1
argument_list|)
index|]
expr_stmt|;
block|}
comment|// write a "false" first arc:
name|writer
operator|.
name|writeByte
argument_list|(
name|ARCS_AS_FIXED_ARRAY
argument_list|)
expr_stmt|;
name|writer
operator|.
name|writeVInt
argument_list|(
name|nodeIn
operator|.
name|numArcs
argument_list|)
expr_stmt|;
comment|// placeholder -- we'll come back and write the number
comment|// of bytes per arc (int) here:
comment|// TODO: we could make this a vInt instead
name|writer
operator|.
name|writeInt
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|fixedArrayStart
operator|=
name|writer
operator|.
name|getPosition
argument_list|()
expr_stmt|;
comment|//System.out.println("  do fixed arcs array arcsStart=" + fixedArrayStart);
block|}
else|else
block|{
name|fixedArrayStart
operator|=
literal|0
expr_stmt|;
block|}
name|arcCount
operator|+=
name|nodeIn
operator|.
name|numArcs
expr_stmt|;
specifier|final
name|int
name|lastArc
init|=
name|nodeIn
operator|.
name|numArcs
operator|-
literal|1
decl_stmt|;
name|int
name|lastArcStart
init|=
name|writer
operator|.
name|getPosition
argument_list|()
decl_stmt|;
name|int
name|maxBytesPerArc
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|arcIdx
init|=
literal|0
init|;
name|arcIdx
operator|<
name|nodeIn
operator|.
name|numArcs
condition|;
name|arcIdx
operator|++
control|)
block|{
specifier|final
name|Builder
operator|.
name|Arc
argument_list|<
name|T
argument_list|>
name|arc
init|=
name|nodeIn
operator|.
name|arcs
index|[
name|arcIdx
index|]
decl_stmt|;
specifier|final
name|Builder
operator|.
name|CompiledNode
name|target
init|=
operator|(
name|Builder
operator|.
name|CompiledNode
operator|)
name|arc
operator|.
name|target
decl_stmt|;
name|int
name|flags
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|arcIdx
operator|==
name|lastArc
condition|)
block|{
name|flags
operator|+=
name|BIT_LAST_ARC
expr_stmt|;
block|}
if|if
condition|(
name|lastFrozenNode
operator|==
name|target
operator|.
name|node
operator|&&
operator|!
name|doFixedArray
condition|)
block|{
comment|// TODO: for better perf (but more RAM used) we
comment|// could avoid this except when arc is "near" the
comment|// last arc:
name|flags
operator|+=
name|BIT_TARGET_NEXT
expr_stmt|;
block|}
if|if
condition|(
name|arc
operator|.
name|isFinal
condition|)
block|{
name|flags
operator|+=
name|BIT_FINAL_ARC
expr_stmt|;
if|if
condition|(
name|arc
operator|.
name|nextFinalOutput
operator|!=
name|NO_OUTPUT
condition|)
block|{
name|flags
operator|+=
name|BIT_ARC_HAS_FINAL_OUTPUT
expr_stmt|;
block|}
block|}
else|else
block|{
assert|assert
name|arc
operator|.
name|nextFinalOutput
operator|==
name|NO_OUTPUT
assert|;
block|}
name|boolean
name|targetHasArcs
init|=
name|target
operator|.
name|node
operator|>
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|targetHasArcs
condition|)
block|{
name|flags
operator|+=
name|BIT_STOP_NODE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|inCounts
operator|!=
literal|null
condition|)
block|{
name|inCounts
operator|.
name|set
argument_list|(
name|target
operator|.
name|node
argument_list|,
name|inCounts
operator|.
name|get
argument_list|(
name|target
operator|.
name|node
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|arc
operator|.
name|output
operator|!=
name|NO_OUTPUT
condition|)
block|{
name|flags
operator|+=
name|BIT_ARC_HAS_OUTPUT
expr_stmt|;
block|}
name|writer
operator|.
name|writeByte
argument_list|(
operator|(
name|byte
operator|)
name|flags
argument_list|)
expr_stmt|;
name|writeLabel
argument_list|(
name|arc
operator|.
name|label
argument_list|)
expr_stmt|;
comment|// System.out.println("  write arc: label=" + (char) arc.label + " flags=" + flags + " target=" + target.node + " pos=" + writer.posWrite + " output=" + outputs.outputToString(arc.output));
if|if
condition|(
name|arc
operator|.
name|output
operator|!=
name|NO_OUTPUT
condition|)
block|{
name|outputs
operator|.
name|write
argument_list|(
name|arc
operator|.
name|output
argument_list|,
name|writer
argument_list|)
expr_stmt|;
comment|//System.out.println("    write output");
name|arcWithOutputCount
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|arc
operator|.
name|nextFinalOutput
operator|!=
name|NO_OUTPUT
condition|)
block|{
comment|//System.out.println("    write final output");
name|outputs
operator|.
name|writeFinalOutput
argument_list|(
name|arc
operator|.
name|nextFinalOutput
argument_list|,
name|writer
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|targetHasArcs
operator|&&
operator|(
name|flags
operator|&
name|BIT_TARGET_NEXT
operator|)
operator|==
literal|0
condition|)
block|{
assert|assert
name|target
operator|.
name|node
operator|>
literal|0
assert|;
comment|//System.out.println("    write target");
name|writer
operator|.
name|writeInt
argument_list|(
name|target
operator|.
name|node
argument_list|)
expr_stmt|;
block|}
comment|// just write the arcs "like normal" on first pass,
comment|// but record how many bytes each one took, and max
comment|// byte size:
if|if
condition|(
name|doFixedArray
condition|)
block|{
name|bytesPerArc
index|[
name|arcIdx
index|]
operator|=
name|writer
operator|.
name|getPosition
argument_list|()
operator|-
name|lastArcStart
expr_stmt|;
name|lastArcStart
operator|=
name|writer
operator|.
name|getPosition
argument_list|()
expr_stmt|;
name|maxBytesPerArc
operator|=
name|Math
operator|.
name|max
argument_list|(
name|maxBytesPerArc
argument_list|,
name|bytesPerArc
index|[
name|arcIdx
index|]
argument_list|)
expr_stmt|;
comment|//System.out.println("    bytes=" + bytesPerArc[arcIdx]);
block|}
block|}
comment|// TODO: if arc'd arrays will be "too wasteful" by some
comment|// measure, eg if arcs have vastly different sized
comment|// outputs, then we should selectively disable array for
comment|// such cases
if|if
condition|(
name|doFixedArray
condition|)
block|{
comment|//System.out.println("  doFixedArray");
assert|assert
name|maxBytesPerArc
operator|>
literal|0
assert|;
comment|// 2nd pass just "expands" all arcs to take up a fixed
comment|// byte size
specifier|final
name|int
name|sizeNeeded
init|=
name|fixedArrayStart
operator|+
name|nodeIn
operator|.
name|numArcs
operator|*
name|maxBytesPerArc
decl_stmt|;
assert|assert
operator|(
operator|(
name|long
operator|)
name|fixedArrayStart
operator|)
operator|+
operator|(
operator|(
name|long
operator|)
name|nodeIn
operator|.
name|numArcs
operator|)
operator|*
name|maxBytesPerArc
operator|<
name|Integer
operator|.
name|MAX_VALUE
operator|:
literal|"FST too large (> 2.1 GB)"
assert|;
name|bytes
operator|=
name|ArrayUtil
operator|.
name|grow
argument_list|(
name|bytes
argument_list|,
name|sizeNeeded
argument_list|)
expr_stmt|;
comment|// TODO: we could make this a vInt instead
name|bytes
index|[
name|fixedArrayStart
operator|-
literal|4
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
name|maxBytesPerArc
operator|>>
literal|24
argument_list|)
expr_stmt|;
name|bytes
index|[
name|fixedArrayStart
operator|-
literal|3
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
name|maxBytesPerArc
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|bytes
index|[
name|fixedArrayStart
operator|-
literal|2
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
name|maxBytesPerArc
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|bytes
index|[
name|fixedArrayStart
operator|-
literal|1
index|]
operator|=
operator|(
name|byte
operator|)
name|maxBytesPerArc
expr_stmt|;
comment|// expand the arcs in place, backwards
name|int
name|srcPos
init|=
name|writer
operator|.
name|getPosition
argument_list|()
decl_stmt|;
name|int
name|destPos
init|=
name|fixedArrayStart
operator|+
name|nodeIn
operator|.
name|numArcs
operator|*
name|maxBytesPerArc
decl_stmt|;
name|writer
operator|.
name|setPosition
argument_list|(
name|destPos
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|arcIdx
init|=
name|nodeIn
operator|.
name|numArcs
operator|-
literal|1
init|;
name|arcIdx
operator|>=
literal|0
condition|;
name|arcIdx
operator|--
control|)
block|{
comment|//System.out.println("  repack arcIdx=" + arcIdx + " srcPos=" + srcPos + " destPos=" + destPos);
name|destPos
operator|-=
name|maxBytesPerArc
expr_stmt|;
name|srcPos
operator|-=
name|bytesPerArc
index|[
name|arcIdx
index|]
expr_stmt|;
if|if
condition|(
name|srcPos
operator|!=
name|destPos
condition|)
block|{
assert|assert
name|destPos
operator|>
name|srcPos
operator|:
literal|"destPos="
operator|+
name|destPos
operator|+
literal|" srcPos="
operator|+
name|srcPos
operator|+
literal|" arcIdx="
operator|+
name|arcIdx
operator|+
literal|" maxBytesPerArc="
operator|+
name|maxBytesPerArc
operator|+
literal|" bytesPerArc[arcIdx]="
operator|+
name|bytesPerArc
index|[
name|arcIdx
index|]
operator|+
literal|" nodeIn.numArcs="
operator|+
name|nodeIn
operator|.
name|numArcs
assert|;
name|System
operator|.
name|arraycopy
argument_list|(
name|bytes
argument_list|,
name|srcPos
argument_list|,
name|bytes
argument_list|,
name|destPos
argument_list|,
name|bytesPerArc
index|[
name|arcIdx
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// reverse bytes in-place; we do this so that the
comment|// "BIT_TARGET_NEXT" opto can work, ie, it reads the
comment|// node just before the current one
specifier|final
name|int
name|endAddress
init|=
name|writer
operator|.
name|getPosition
argument_list|()
operator|-
literal|1
decl_stmt|;
name|int
name|left
init|=
name|startAddress
decl_stmt|;
name|int
name|right
init|=
name|endAddress
decl_stmt|;
while|while
condition|(
name|left
operator|<
name|right
condition|)
block|{
specifier|final
name|byte
name|b
init|=
name|bytes
index|[
name|left
index|]
decl_stmt|;
name|bytes
index|[
name|left
operator|++
index|]
operator|=
name|bytes
index|[
name|right
index|]
expr_stmt|;
name|bytes
index|[
name|right
operator|--
index|]
operator|=
name|b
expr_stmt|;
block|}
comment|//System.out.println("  endAddress=" + endAddress);
name|nodeCount
operator|++
expr_stmt|;
specifier|final
name|int
name|node
decl_stmt|;
if|if
condition|(
name|nodeAddress
operator|!=
literal|null
condition|)
block|{
comment|// Nodes are addressed by 1+ord:
if|if
condition|(
name|nodeCount
operator|==
name|nodeAddress
operator|.
name|size
argument_list|()
condition|)
block|{
name|nodeAddress
operator|=
name|nodeAddress
operator|.
name|resize
argument_list|(
name|ArrayUtil
operator|.
name|oversize
argument_list|(
name|nodeAddress
operator|.
name|size
argument_list|()
operator|+
literal|1
argument_list|,
name|nodeAddress
operator|.
name|getBitsPerValue
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|inCounts
operator|=
name|inCounts
operator|.
name|resize
argument_list|(
name|ArrayUtil
operator|.
name|oversize
argument_list|(
name|inCounts
operator|.
name|size
argument_list|()
operator|+
literal|1
argument_list|,
name|inCounts
operator|.
name|getBitsPerValue
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|nodeAddress
operator|.
name|set
argument_list|(
name|nodeCount
argument_list|,
name|endAddress
argument_list|)
expr_stmt|;
comment|// System.out.println("  write nodeAddress[" + nodeCount + "] = " + endAddress);
name|node
operator|=
name|nodeCount
expr_stmt|;
block|}
else|else
block|{
name|node
operator|=
name|endAddress
expr_stmt|;
block|}
name|lastFrozenNode
operator|=
name|node
expr_stmt|;
return|return
name|node
return|;
block|}
comment|/** Fills virtual 'start' arc, ie, an empty incoming arc to    *  the FST's start node */
DECL|method|getFirstArc
specifier|public
name|Arc
argument_list|<
name|T
argument_list|>
name|getFirstArc
parameter_list|(
name|Arc
argument_list|<
name|T
argument_list|>
name|arc
parameter_list|)
block|{
if|if
condition|(
name|emptyOutput
operator|!=
literal|null
condition|)
block|{
name|arc
operator|.
name|flags
operator|=
name|BIT_FINAL_ARC
operator||
name|BIT_LAST_ARC
expr_stmt|;
name|arc
operator|.
name|nextFinalOutput
operator|=
name|emptyOutput
expr_stmt|;
block|}
else|else
block|{
name|arc
operator|.
name|flags
operator|=
name|BIT_LAST_ARC
expr_stmt|;
name|arc
operator|.
name|nextFinalOutput
operator|=
name|NO_OUTPUT
expr_stmt|;
block|}
name|arc
operator|.
name|output
operator|=
name|NO_OUTPUT
expr_stmt|;
comment|// If there are no nodes, ie, the FST only accepts the
comment|// empty string, then startNode is 0
name|arc
operator|.
name|target
operator|=
name|startNode
expr_stmt|;
return|return
name|arc
return|;
block|}
comment|/** Follows the<code>follow</code> arc and reads the last    *  arc of its target; this changes the provided    *<code>arc</code> (2nd arg) in-place and returns it.    *     * @return Returns the second argument    * (<code>arc</code>). */
DECL|method|readLastTargetArc
specifier|public
name|Arc
argument_list|<
name|T
argument_list|>
name|readLastTargetArc
parameter_list|(
name|Arc
argument_list|<
name|T
argument_list|>
name|follow
parameter_list|,
name|Arc
argument_list|<
name|T
argument_list|>
name|arc
parameter_list|,
name|FST
operator|.
name|BytesReader
name|in
parameter_list|)
throws|throws
name|IOException
block|{
comment|//System.out.println("readLast");
if|if
condition|(
operator|!
name|targetHasArcs
argument_list|(
name|follow
argument_list|)
condition|)
block|{
comment|//System.out.println("  end node");
assert|assert
name|follow
operator|.
name|isFinal
argument_list|()
assert|;
name|arc
operator|.
name|label
operator|=
name|END_LABEL
expr_stmt|;
name|arc
operator|.
name|target
operator|=
name|FINAL_END_NODE
expr_stmt|;
name|arc
operator|.
name|output
operator|=
name|follow
operator|.
name|nextFinalOutput
expr_stmt|;
name|arc
operator|.
name|flags
operator|=
name|BIT_LAST_ARC
expr_stmt|;
return|return
name|arc
return|;
block|}
else|else
block|{
name|in
operator|.
name|pos
operator|=
name|getNodeAddress
argument_list|(
name|follow
operator|.
name|target
argument_list|)
expr_stmt|;
name|arc
operator|.
name|node
operator|=
name|follow
operator|.
name|target
expr_stmt|;
specifier|final
name|byte
name|b
init|=
name|in
operator|.
name|readByte
argument_list|()
decl_stmt|;
if|if
condition|(
name|b
operator|==
name|ARCS_AS_FIXED_ARRAY
condition|)
block|{
comment|// array: jump straight to end
name|arc
operator|.
name|numArcs
operator|=
name|in
operator|.
name|readVInt
argument_list|()
expr_stmt|;
if|if
condition|(
name|packed
condition|)
block|{
name|arc
operator|.
name|bytesPerArc
operator|=
name|in
operator|.
name|readVInt
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|arc
operator|.
name|bytesPerArc
operator|=
name|in
operator|.
name|readInt
argument_list|()
expr_stmt|;
block|}
comment|//System.out.println("  array numArcs=" + arc.numArcs + " bpa=" + arc.bytesPerArc);
name|arc
operator|.
name|posArcsStart
operator|=
name|in
operator|.
name|pos
expr_stmt|;
name|arc
operator|.
name|arcIdx
operator|=
name|arc
operator|.
name|numArcs
operator|-
literal|2
expr_stmt|;
block|}
else|else
block|{
name|arc
operator|.
name|flags
operator|=
name|b
expr_stmt|;
comment|// non-array: linear scan
name|arc
operator|.
name|bytesPerArc
operator|=
literal|0
expr_stmt|;
comment|//System.out.println("  scan");
while|while
condition|(
operator|!
name|arc
operator|.
name|isLast
argument_list|()
condition|)
block|{
comment|// skip this arc:
name|readLabel
argument_list|(
name|in
argument_list|)
expr_stmt|;
if|if
condition|(
name|arc
operator|.
name|flag
argument_list|(
name|BIT_ARC_HAS_OUTPUT
argument_list|)
condition|)
block|{
name|outputs
operator|.
name|read
argument_list|(
name|in
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|arc
operator|.
name|flag
argument_list|(
name|BIT_ARC_HAS_FINAL_OUTPUT
argument_list|)
condition|)
block|{
name|outputs
operator|.
name|readFinalOutput
argument_list|(
name|in
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|arc
operator|.
name|flag
argument_list|(
name|BIT_STOP_NODE
argument_list|)
condition|)
block|{           }
elseif|else
if|if
condition|(
name|arc
operator|.
name|flag
argument_list|(
name|BIT_TARGET_NEXT
argument_list|)
condition|)
block|{           }
else|else
block|{
if|if
condition|(
name|packed
condition|)
block|{
name|in
operator|.
name|readVInt
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|in
operator|.
name|skip
argument_list|(
literal|4
argument_list|)
expr_stmt|;
block|}
block|}
name|arc
operator|.
name|flags
operator|=
name|in
operator|.
name|readByte
argument_list|()
expr_stmt|;
block|}
comment|// Undo the byte flags we read:
name|in
operator|.
name|skip
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
name|arc
operator|.
name|nextArc
operator|=
name|in
operator|.
name|pos
expr_stmt|;
block|}
name|readNextRealArc
argument_list|(
name|arc
argument_list|,
name|in
argument_list|)
expr_stmt|;
assert|assert
name|arc
operator|.
name|isLast
argument_list|()
assert|;
return|return
name|arc
return|;
block|}
block|}
comment|/**    * Follow the<code>follow</code> arc and read the first arc of its target;    * this changes the provided<code>arc</code> (2nd arg) in-place and returns    * it.    *     * @return Returns the second argument (<code>arc</code>).    */
DECL|method|readFirstTargetArc
specifier|public
name|Arc
argument_list|<
name|T
argument_list|>
name|readFirstTargetArc
parameter_list|(
name|Arc
argument_list|<
name|T
argument_list|>
name|follow
parameter_list|,
name|Arc
argument_list|<
name|T
argument_list|>
name|arc
parameter_list|,
name|BytesReader
name|in
parameter_list|)
throws|throws
name|IOException
block|{
comment|//int pos = address;
comment|//System.out.println("    readFirstTarget follow.target=" + follow.target + " isFinal=" + follow.isFinal());
if|if
condition|(
name|follow
operator|.
name|isFinal
argument_list|()
condition|)
block|{
comment|// Insert "fake" final first arc:
name|arc
operator|.
name|label
operator|=
name|END_LABEL
expr_stmt|;
name|arc
operator|.
name|output
operator|=
name|follow
operator|.
name|nextFinalOutput
expr_stmt|;
name|arc
operator|.
name|flags
operator|=
name|BIT_FINAL_ARC
expr_stmt|;
if|if
condition|(
name|follow
operator|.
name|target
operator|<=
literal|0
condition|)
block|{
name|arc
operator|.
name|flags
operator||=
name|BIT_LAST_ARC
expr_stmt|;
block|}
else|else
block|{
name|arc
operator|.
name|node
operator|=
name|follow
operator|.
name|target
expr_stmt|;
comment|// NOTE: nextArc is a node (not an address!) in this case:
name|arc
operator|.
name|nextArc
operator|=
name|follow
operator|.
name|target
expr_stmt|;
block|}
name|arc
operator|.
name|target
operator|=
name|FINAL_END_NODE
expr_stmt|;
comment|//System.out.println("    insert isFinal; nextArc=" + follow.target + " isLast=" + arc.isLast() + " output=" + outputs.outputToString(arc.output));
return|return
name|arc
return|;
block|}
else|else
block|{
return|return
name|readFirstRealTargetArc
argument_list|(
name|follow
operator|.
name|target
argument_list|,
name|arc
argument_list|,
name|in
argument_list|)
return|;
block|}
block|}
DECL|method|readFirstRealTargetArc
specifier|public
name|Arc
argument_list|<
name|T
argument_list|>
name|readFirstRealTargetArc
parameter_list|(
name|int
name|node
parameter_list|,
name|Arc
argument_list|<
name|T
argument_list|>
name|arc
parameter_list|,
specifier|final
name|BytesReader
name|in
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|in
operator|.
name|bytes
operator|==
name|bytes
assert|;
specifier|final
name|int
name|address
init|=
name|getNodeAddress
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|in
operator|.
name|pos
operator|=
name|address
expr_stmt|;
comment|//System.out.println("  readFirstRealTargtArc address="
comment|//+ address);
comment|//System.out.println("   flags=" + arc.flags);
name|arc
operator|.
name|node
operator|=
name|node
expr_stmt|;
if|if
condition|(
name|in
operator|.
name|readByte
argument_list|()
operator|==
name|ARCS_AS_FIXED_ARRAY
condition|)
block|{
comment|//System.out.println("  fixedArray");
comment|// this is first arc in a fixed-array
name|arc
operator|.
name|numArcs
operator|=
name|in
operator|.
name|readVInt
argument_list|()
expr_stmt|;
if|if
condition|(
name|packed
condition|)
block|{
name|arc
operator|.
name|bytesPerArc
operator|=
name|in
operator|.
name|readVInt
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|arc
operator|.
name|bytesPerArc
operator|=
name|in
operator|.
name|readInt
argument_list|()
expr_stmt|;
block|}
name|arc
operator|.
name|arcIdx
operator|=
operator|-
literal|1
expr_stmt|;
name|arc
operator|.
name|nextArc
operator|=
name|arc
operator|.
name|posArcsStart
operator|=
name|in
operator|.
name|pos
expr_stmt|;
comment|//System.out.println("  bytesPer=" + arc.bytesPerArc + " numArcs=" + arc.numArcs + " arcsStart=" + pos);
block|}
else|else
block|{
comment|//arc.flags = b;
name|arc
operator|.
name|nextArc
operator|=
name|address
expr_stmt|;
name|arc
operator|.
name|bytesPerArc
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|readNextRealArc
argument_list|(
name|arc
argument_list|,
name|in
argument_list|)
return|;
block|}
comment|/**    * Checks if<code>arc</code>'s target state is in expanded (or vector) format.     *     * @return Returns<code>true</code> if<code>arc</code> points to a state in an    * expanded array format.    */
DECL|method|isExpandedTarget
name|boolean
name|isExpandedTarget
parameter_list|(
name|Arc
argument_list|<
name|T
argument_list|>
name|follow
parameter_list|,
name|FST
operator|.
name|BytesReader
name|in
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|targetHasArcs
argument_list|(
name|follow
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
else|else
block|{
name|in
operator|.
name|pos
operator|=
name|getNodeAddress
argument_list|(
name|follow
operator|.
name|target
argument_list|)
expr_stmt|;
return|return
name|in
operator|.
name|readByte
argument_list|()
operator|==
name|ARCS_AS_FIXED_ARRAY
return|;
block|}
block|}
comment|/** In-place read; returns the arc. */
DECL|method|readNextArc
specifier|public
name|Arc
argument_list|<
name|T
argument_list|>
name|readNextArc
parameter_list|(
name|Arc
argument_list|<
name|T
argument_list|>
name|arc
parameter_list|,
name|BytesReader
name|in
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|arc
operator|.
name|label
operator|==
name|END_LABEL
condition|)
block|{
comment|// This was a fake inserted "final" arc
if|if
condition|(
name|arc
operator|.
name|nextArc
operator|<=
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"cannot readNextArc when arc.isLast()=true"
argument_list|)
throw|;
block|}
return|return
name|readFirstRealTargetArc
argument_list|(
name|arc
operator|.
name|nextArc
argument_list|,
name|arc
argument_list|,
name|in
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|readNextRealArc
argument_list|(
name|arc
argument_list|,
name|in
argument_list|)
return|;
block|}
block|}
comment|/** Peeks at next arc's label; does not alter arc.  Do    *  not call this if arc.isLast()! */
DECL|method|readNextArcLabel
specifier|public
name|int
name|readNextArcLabel
parameter_list|(
name|Arc
argument_list|<
name|T
argument_list|>
name|arc
parameter_list|,
name|BytesReader
name|in
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
operator|!
name|arc
operator|.
name|isLast
argument_list|()
assert|;
if|if
condition|(
name|arc
operator|.
name|label
operator|==
name|END_LABEL
condition|)
block|{
comment|//System.out.println("    nextArc fake " + arc.nextArc);
name|int
name|pos
init|=
name|in
operator|.
name|pos
operator|=
name|getNodeAddress
argument_list|(
name|arc
operator|.
name|nextArc
argument_list|)
decl_stmt|;
specifier|final
name|byte
name|b
init|=
name|in
operator|.
name|readByte
argument_list|()
decl_stmt|;
if|if
condition|(
name|b
operator|==
name|ARCS_AS_FIXED_ARRAY
condition|)
block|{
comment|//System.out.println("    nextArc fake array");
name|in
operator|.
name|readVInt
argument_list|()
expr_stmt|;
if|if
condition|(
name|packed
condition|)
block|{
name|in
operator|.
name|readVInt
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|in
operator|.
name|readInt
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
name|in
operator|.
name|pos
operator|=
name|pos
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|arc
operator|.
name|bytesPerArc
operator|!=
literal|0
condition|)
block|{
comment|//System.out.println("    nextArc real array");
comment|// arcs are at fixed entries
name|in
operator|.
name|pos
operator|=
name|arc
operator|.
name|posArcsStart
expr_stmt|;
name|in
operator|.
name|skip
argument_list|(
operator|(
literal|1
operator|+
name|arc
operator|.
name|arcIdx
operator|)
operator|*
name|arc
operator|.
name|bytesPerArc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// arcs are packed
comment|//System.out.println("    nextArc real packed");
name|in
operator|.
name|pos
operator|=
name|arc
operator|.
name|nextArc
expr_stmt|;
block|}
block|}
comment|// skip flags
name|in
operator|.
name|readByte
argument_list|()
expr_stmt|;
return|return
name|readLabel
argument_list|(
name|in
argument_list|)
return|;
block|}
comment|/** Never returns null, but you should never call this if    *  arc.isLast() is true. */
DECL|method|readNextRealArc
specifier|public
name|Arc
argument_list|<
name|T
argument_list|>
name|readNextRealArc
parameter_list|(
name|Arc
argument_list|<
name|T
argument_list|>
name|arc
parameter_list|,
specifier|final
name|BytesReader
name|in
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|in
operator|.
name|bytes
operator|==
name|bytes
assert|;
comment|// TODO: can't assert this because we call from readFirstArc
comment|// assert !flag(arc.flags, BIT_LAST_ARC);
comment|// this is a continuing arc in a fixed array
if|if
condition|(
name|arc
operator|.
name|bytesPerArc
operator|!=
literal|0
condition|)
block|{
comment|// arcs are at fixed entries
name|arc
operator|.
name|arcIdx
operator|++
expr_stmt|;
assert|assert
name|arc
operator|.
name|arcIdx
operator|<
name|arc
operator|.
name|numArcs
assert|;
name|in
operator|.
name|skip
argument_list|(
name|arc
operator|.
name|posArcsStart
argument_list|,
name|arc
operator|.
name|arcIdx
operator|*
name|arc
operator|.
name|bytesPerArc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// arcs are packed
name|in
operator|.
name|pos
operator|=
name|arc
operator|.
name|nextArc
expr_stmt|;
block|}
name|arc
operator|.
name|flags
operator|=
name|in
operator|.
name|readByte
argument_list|()
expr_stmt|;
name|arc
operator|.
name|label
operator|=
name|readLabel
argument_list|(
name|in
argument_list|)
expr_stmt|;
if|if
condition|(
name|arc
operator|.
name|flag
argument_list|(
name|BIT_ARC_HAS_OUTPUT
argument_list|)
condition|)
block|{
name|arc
operator|.
name|output
operator|=
name|outputs
operator|.
name|read
argument_list|(
name|in
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|arc
operator|.
name|output
operator|=
name|outputs
operator|.
name|getNoOutput
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|arc
operator|.
name|flag
argument_list|(
name|BIT_ARC_HAS_FINAL_OUTPUT
argument_list|)
condition|)
block|{
name|arc
operator|.
name|nextFinalOutput
operator|=
name|outputs
operator|.
name|readFinalOutput
argument_list|(
name|in
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|arc
operator|.
name|nextFinalOutput
operator|=
name|outputs
operator|.
name|getNoOutput
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|arc
operator|.
name|flag
argument_list|(
name|BIT_STOP_NODE
argument_list|)
condition|)
block|{
if|if
condition|(
name|arc
operator|.
name|flag
argument_list|(
name|BIT_FINAL_ARC
argument_list|)
condition|)
block|{
name|arc
operator|.
name|target
operator|=
name|FINAL_END_NODE
expr_stmt|;
block|}
else|else
block|{
name|arc
operator|.
name|target
operator|=
name|NON_FINAL_END_NODE
expr_stmt|;
block|}
name|arc
operator|.
name|nextArc
operator|=
name|in
operator|.
name|pos
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|arc
operator|.
name|flag
argument_list|(
name|BIT_TARGET_NEXT
argument_list|)
condition|)
block|{
name|arc
operator|.
name|nextArc
operator|=
name|in
operator|.
name|pos
expr_stmt|;
comment|// TODO: would be nice to make this lazy -- maybe
comment|// caller doesn't need the target and is scanning arcs...
if|if
condition|(
name|nodeAddress
operator|==
literal|null
condition|)
block|{
if|if
condition|(
operator|!
name|arc
operator|.
name|flag
argument_list|(
name|BIT_LAST_ARC
argument_list|)
condition|)
block|{
if|if
condition|(
name|arc
operator|.
name|bytesPerArc
operator|==
literal|0
condition|)
block|{
comment|// must scan
name|seekToNextNode
argument_list|(
name|in
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|in
operator|.
name|skip
argument_list|(
name|arc
operator|.
name|posArcsStart
argument_list|,
name|arc
operator|.
name|bytesPerArc
operator|*
name|arc
operator|.
name|numArcs
argument_list|)
expr_stmt|;
block|}
block|}
name|arc
operator|.
name|target
operator|=
name|in
operator|.
name|pos
expr_stmt|;
block|}
else|else
block|{
name|arc
operator|.
name|target
operator|=
name|arc
operator|.
name|node
operator|-
literal|1
expr_stmt|;
assert|assert
name|arc
operator|.
name|target
operator|>
literal|0
assert|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|packed
condition|)
block|{
specifier|final
name|int
name|pos
init|=
name|in
operator|.
name|pos
decl_stmt|;
specifier|final
name|int
name|code
init|=
name|in
operator|.
name|readVInt
argument_list|()
decl_stmt|;
if|if
condition|(
name|arc
operator|.
name|flag
argument_list|(
name|BIT_TARGET_DELTA
argument_list|)
condition|)
block|{
comment|// Address is delta-coded from current address:
name|arc
operator|.
name|target
operator|=
name|pos
operator|+
name|code
expr_stmt|;
comment|//System.out.println("    delta pos=" + pos + " delta=" + code + " target=" + arc.target);
block|}
elseif|else
if|if
condition|(
name|code
operator|<
name|nodeRefToAddress
operator|.
name|size
argument_list|()
condition|)
block|{
comment|// Deref
name|arc
operator|.
name|target
operator|=
operator|(
name|int
operator|)
name|nodeRefToAddress
operator|.
name|get
argument_list|(
name|code
argument_list|)
expr_stmt|;
comment|//System.out.println("    deref code=" + code + " target=" + arc.target);
block|}
else|else
block|{
comment|// Absolute
name|arc
operator|.
name|target
operator|=
name|code
expr_stmt|;
comment|//System.out.println("    abs code=" + code + " derefLen=" + nodeRefToAddress.length);
block|}
block|}
else|else
block|{
name|arc
operator|.
name|target
operator|=
name|in
operator|.
name|readInt
argument_list|()
expr_stmt|;
block|}
name|arc
operator|.
name|nextArc
operator|=
name|in
operator|.
name|pos
expr_stmt|;
block|}
return|return
name|arc
return|;
block|}
comment|/** Finds an arc leaving the incoming arc, replacing the arc in place.    *  This returns null if the arc was not found, else the incoming arc. */
DECL|method|findTargetArc
specifier|public
name|Arc
argument_list|<
name|T
argument_list|>
name|findTargetArc
parameter_list|(
name|int
name|labelToMatch
parameter_list|,
name|Arc
argument_list|<
name|T
argument_list|>
name|follow
parameter_list|,
name|Arc
argument_list|<
name|T
argument_list|>
name|arc
parameter_list|,
name|BytesReader
name|in
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|cachedRootArcs
operator|!=
literal|null
assert|;
assert|assert
name|in
operator|.
name|bytes
operator|==
name|bytes
assert|;
if|if
condition|(
name|labelToMatch
operator|==
name|END_LABEL
condition|)
block|{
if|if
condition|(
name|follow
operator|.
name|isFinal
argument_list|()
condition|)
block|{
if|if
condition|(
name|follow
operator|.
name|target
operator|<=
literal|0
condition|)
block|{
name|arc
operator|.
name|flags
operator|=
name|BIT_LAST_ARC
expr_stmt|;
block|}
else|else
block|{
name|arc
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
comment|// NOTE: nextArc is a node (not an address!) in this case:
name|arc
operator|.
name|nextArc
operator|=
name|follow
operator|.
name|target
expr_stmt|;
name|arc
operator|.
name|node
operator|=
name|follow
operator|.
name|target
expr_stmt|;
block|}
name|arc
operator|.
name|output
operator|=
name|follow
operator|.
name|nextFinalOutput
expr_stmt|;
name|arc
operator|.
name|label
operator|=
name|END_LABEL
expr_stmt|;
return|return
name|arc
return|;
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
comment|// Short-circuit if this arc is in the root arc cache:
if|if
condition|(
name|follow
operator|.
name|target
operator|==
name|startNode
operator|&&
name|labelToMatch
operator|<
name|cachedRootArcs
operator|.
name|length
condition|)
block|{
specifier|final
name|Arc
argument_list|<
name|T
argument_list|>
name|result
init|=
name|cachedRootArcs
index|[
name|labelToMatch
index|]
decl_stmt|;
if|if
condition|(
name|result
operator|==
literal|null
condition|)
block|{
return|return
name|result
return|;
block|}
else|else
block|{
name|arc
operator|.
name|copyFrom
argument_list|(
name|result
argument_list|)
expr_stmt|;
return|return
name|arc
return|;
block|}
block|}
if|if
condition|(
operator|!
name|targetHasArcs
argument_list|(
name|follow
argument_list|)
condition|)
block|{
return|return
literal|null
return|;
block|}
name|in
operator|.
name|pos
operator|=
name|getNodeAddress
argument_list|(
name|follow
operator|.
name|target
argument_list|)
expr_stmt|;
name|arc
operator|.
name|node
operator|=
name|follow
operator|.
name|target
expr_stmt|;
comment|// System.out.println("fta label=" + (char) labelToMatch);
if|if
condition|(
name|in
operator|.
name|readByte
argument_list|()
operator|==
name|ARCS_AS_FIXED_ARRAY
condition|)
block|{
comment|// Arcs are full array; do binary search:
name|arc
operator|.
name|numArcs
operator|=
name|in
operator|.
name|readVInt
argument_list|()
expr_stmt|;
if|if
condition|(
name|packed
condition|)
block|{
name|arc
operator|.
name|bytesPerArc
operator|=
name|in
operator|.
name|readVInt
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|arc
operator|.
name|bytesPerArc
operator|=
name|in
operator|.
name|readInt
argument_list|()
expr_stmt|;
block|}
name|arc
operator|.
name|posArcsStart
operator|=
name|in
operator|.
name|pos
expr_stmt|;
name|int
name|low
init|=
literal|0
decl_stmt|;
name|int
name|high
init|=
name|arc
operator|.
name|numArcs
operator|-
literal|1
decl_stmt|;
while|while
condition|(
name|low
operator|<=
name|high
condition|)
block|{
comment|//System.out.println("    cycle");
name|int
name|mid
init|=
operator|(
name|low
operator|+
name|high
operator|)
operator|>>>
literal|1
decl_stmt|;
name|in
operator|.
name|skip
argument_list|(
name|arc
operator|.
name|posArcsStart
argument_list|,
name|arc
operator|.
name|bytesPerArc
operator|*
name|mid
operator|+
literal|1
argument_list|)
expr_stmt|;
name|int
name|midLabel
init|=
name|readLabel
argument_list|(
name|in
argument_list|)
decl_stmt|;
specifier|final
name|int
name|cmp
init|=
name|midLabel
operator|-
name|labelToMatch
decl_stmt|;
if|if
condition|(
name|cmp
operator|<
literal|0
condition|)
block|{
name|low
operator|=
name|mid
operator|+
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cmp
operator|>
literal|0
condition|)
block|{
name|high
operator|=
name|mid
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|arc
operator|.
name|arcIdx
operator|=
name|mid
operator|-
literal|1
expr_stmt|;
comment|//System.out.println("    found!");
return|return
name|readNextRealArc
argument_list|(
name|arc
argument_list|,
name|in
argument_list|)
return|;
block|}
block|}
return|return
literal|null
return|;
block|}
comment|// Linear scan
name|readFirstRealTargetArc
argument_list|(
name|follow
operator|.
name|target
argument_list|,
name|arc
argument_list|,
name|in
argument_list|)
expr_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
comment|//System.out.println("  non-bs cycle");
comment|// TODO: we should fix this code to not have to create
comment|// object for the output of every arc we scan... only
comment|// for the matching arc, if found
if|if
condition|(
name|arc
operator|.
name|label
operator|==
name|labelToMatch
condition|)
block|{
comment|//System.out.println("    found!");
return|return
name|arc
return|;
block|}
elseif|else
if|if
condition|(
name|arc
operator|.
name|label
operator|>
name|labelToMatch
condition|)
block|{
return|return
literal|null
return|;
block|}
elseif|else
if|if
condition|(
name|arc
operator|.
name|isLast
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
else|else
block|{
name|readNextRealArc
argument_list|(
name|arc
argument_list|,
name|in
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|seekToNextNode
specifier|private
name|void
name|seekToNextNode
parameter_list|(
name|BytesReader
name|in
parameter_list|)
throws|throws
name|IOException
block|{
while|while
condition|(
literal|true
condition|)
block|{
specifier|final
name|int
name|flags
init|=
name|in
operator|.
name|readByte
argument_list|()
decl_stmt|;
name|readLabel
argument_list|(
name|in
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag
argument_list|(
name|flags
argument_list|,
name|BIT_ARC_HAS_OUTPUT
argument_list|)
condition|)
block|{
name|outputs
operator|.
name|read
argument_list|(
name|in
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flag
argument_list|(
name|flags
argument_list|,
name|BIT_ARC_HAS_FINAL_OUTPUT
argument_list|)
condition|)
block|{
name|outputs
operator|.
name|readFinalOutput
argument_list|(
name|in
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|flag
argument_list|(
name|flags
argument_list|,
name|BIT_STOP_NODE
argument_list|)
operator|&&
operator|!
name|flag
argument_list|(
name|flags
argument_list|,
name|BIT_TARGET_NEXT
argument_list|)
condition|)
block|{
if|if
condition|(
name|packed
condition|)
block|{
name|in
operator|.
name|readVInt
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|in
operator|.
name|readInt
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|flag
argument_list|(
name|flags
argument_list|,
name|BIT_LAST_ARC
argument_list|)
condition|)
block|{
return|return;
block|}
block|}
block|}
DECL|method|getNodeCount
specifier|public
name|int
name|getNodeCount
parameter_list|()
block|{
comment|// 1+ in order to count the -1 implicit final node
return|return
literal|1
operator|+
name|nodeCount
return|;
block|}
DECL|method|getArcCount
specifier|public
name|int
name|getArcCount
parameter_list|()
block|{
return|return
name|arcCount
return|;
block|}
DECL|method|getArcWithOutputCount
specifier|public
name|int
name|getArcWithOutputCount
parameter_list|()
block|{
return|return
name|arcWithOutputCount
return|;
block|}
DECL|method|setAllowArrayArcs
specifier|public
name|void
name|setAllowArrayArcs
parameter_list|(
name|boolean
name|v
parameter_list|)
block|{
name|allowArrayArcs
operator|=
name|v
expr_stmt|;
block|}
comment|/**    * Nodes will be expanded if their depth (distance from the root node) is    *&lt;= this value and their number of arcs is&gt;=    * {@link #FIXED_ARRAY_NUM_ARCS_SHALLOW}.    *     *<p>    * Fixed array consumes more RAM but enables binary search on the arcs    * (instead of a linear scan) on lookup by arc label.    *     * @return<code>true</code> if<code>node</code> should be stored in an    *         expanded (array) form.    *     * @see #FIXED_ARRAY_NUM_ARCS_DEEP    * @see Builder.UnCompiledNode#depth    */
DECL|method|shouldExpand
specifier|private
name|boolean
name|shouldExpand
parameter_list|(
name|UnCompiledNode
argument_list|<
name|T
argument_list|>
name|node
parameter_list|)
block|{
return|return
name|allowArrayArcs
operator|&&
operator|(
operator|(
name|node
operator|.
name|depth
operator|<=
name|FIXED_ARRAY_SHALLOW_DISTANCE
operator|&&
name|node
operator|.
name|numArcs
operator|>=
name|FIXED_ARRAY_NUM_ARCS_SHALLOW
operator|)
operator|||
name|node
operator|.
name|numArcs
operator|>=
name|FIXED_ARRAY_NUM_ARCS_DEEP
operator|)
return|;
block|}
DECL|class|BytesWriter
specifier|static
specifier|abstract
class|class
name|BytesWriter
extends|extends
name|DataOutput
block|{
DECL|method|setPosition
specifier|public
specifier|abstract
name|void
name|setPosition
parameter_list|(
name|int
name|posWrite
parameter_list|)
function_decl|;
DECL|method|getPosition
specifier|public
specifier|abstract
name|int
name|getPosition
parameter_list|()
function_decl|;
block|}
comment|// Non-static: writes to FST's byte[]
DECL|class|DefaultBytesWriter
class|class
name|DefaultBytesWriter
extends|extends
name|BytesWriter
block|{
DECL|field|posWrite
name|int
name|posWrite
decl_stmt|;
DECL|method|DefaultBytesWriter
specifier|public
name|DefaultBytesWriter
parameter_list|()
block|{
comment|// pad: ensure no node gets address 0 which is reserved to mean
comment|// the stop state w/ no arcs
name|posWrite
operator|=
literal|1
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|writeByte
specifier|public
name|void
name|writeByte
parameter_list|(
name|byte
name|b
parameter_list|)
block|{
assert|assert
name|posWrite
operator|<=
name|bytes
operator|.
name|length
assert|;
if|if
condition|(
name|bytes
operator|.
name|length
operator|==
name|posWrite
condition|)
block|{
assert|assert
name|bytes
operator|.
name|length
operator|<
name|Integer
operator|.
name|MAX_VALUE
operator|:
literal|"FST too large (> 2.1 GB)"
assert|;
name|bytes
operator|=
name|ArrayUtil
operator|.
name|grow
argument_list|(
name|bytes
argument_list|)
expr_stmt|;
block|}
assert|assert
name|posWrite
operator|<
name|bytes
operator|.
name|length
operator|:
literal|"posWrite="
operator|+
name|posWrite
operator|+
literal|" bytes.length="
operator|+
name|bytes
operator|.
name|length
assert|;
name|bytes
index|[
name|posWrite
operator|++
index|]
operator|=
name|b
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|getPosition
specifier|public
name|int
name|getPosition
parameter_list|()
block|{
return|return
name|posWrite
return|;
block|}
annotation|@
name|Override
DECL|method|setPosition
specifier|public
name|void
name|setPosition
parameter_list|(
name|int
name|posWrite
parameter_list|)
block|{
name|this
operator|.
name|posWrite
operator|=
name|posWrite
expr_stmt|;
if|if
condition|(
name|bytes
operator|.
name|length
operator|<
name|posWrite
condition|)
block|{
assert|assert
name|bytes
operator|.
name|length
operator|<
name|Integer
operator|.
name|MAX_VALUE
operator|:
literal|"FST too large (> 2.1 GB)"
assert|;
name|bytes
operator|=
name|ArrayUtil
operator|.
name|grow
argument_list|(
name|bytes
argument_list|,
name|posWrite
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|writeBytes
specifier|public
name|void
name|writeBytes
parameter_list|(
name|byte
index|[]
name|b
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|)
block|{
specifier|final
name|int
name|size
init|=
name|posWrite
operator|+
name|length
decl_stmt|;
assert|assert
name|bytes
operator|.
name|length
operator|<
name|Integer
operator|.
name|MAX_VALUE
operator|:
literal|"FST too large (> 2.1 GB)"
assert|;
name|bytes
operator|=
name|ArrayUtil
operator|.
name|grow
argument_list|(
name|bytes
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|b
argument_list|,
name|offset
argument_list|,
name|bytes
argument_list|,
name|posWrite
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|posWrite
operator|+=
name|length
expr_stmt|;
block|}
block|}
comment|/** Returns a {@link BytesReader} for this FST, positioned at    *  position 0. */
DECL|method|getBytesReader
specifier|public
name|BytesReader
name|getBytesReader
parameter_list|()
block|{
return|return
name|getBytesReader
argument_list|(
literal|0
argument_list|)
return|;
block|}
comment|/** Returns a {@link BytesReader} for this FST, positioned at    *  the provided position. */
DECL|method|getBytesReader
specifier|public
name|BytesReader
name|getBytesReader
parameter_list|(
name|int
name|pos
parameter_list|)
block|{
comment|// TODO: maybe re-use via ThreadLocal?
if|if
condition|(
name|packed
condition|)
block|{
return|return
operator|new
name|ForwardBytesReader
argument_list|(
name|bytes
argument_list|,
name|pos
argument_list|)
return|;
block|}
else|else
block|{
return|return
operator|new
name|ReverseBytesReader
argument_list|(
name|bytes
argument_list|,
name|pos
argument_list|)
return|;
block|}
block|}
comment|/** Reads the bytes from this FST.  Use {@link    *  #getBytesReader(int)} to obtain an instance for this    *  FST; re-use across calls (but only within a single    *  thread) for better performance. */
DECL|class|BytesReader
specifier|public
specifier|static
specifier|abstract
class|class
name|BytesReader
extends|extends
name|DataInput
block|{
DECL|field|pos
specifier|protected
name|int
name|pos
decl_stmt|;
DECL|field|bytes
specifier|protected
specifier|final
name|byte
index|[]
name|bytes
decl_stmt|;
DECL|method|BytesReader
specifier|protected
name|BytesReader
parameter_list|(
name|byte
index|[]
name|bytes
parameter_list|,
name|int
name|pos
parameter_list|)
block|{
name|this
operator|.
name|bytes
operator|=
name|bytes
expr_stmt|;
name|this
operator|.
name|pos
operator|=
name|pos
expr_stmt|;
block|}
DECL|method|skip
specifier|abstract
name|void
name|skip
parameter_list|(
name|int
name|byteCount
parameter_list|)
function_decl|;
DECL|method|skip
specifier|abstract
name|void
name|skip
parameter_list|(
name|int
name|base
parameter_list|,
name|int
name|byteCount
parameter_list|)
function_decl|;
block|}
DECL|class|ReverseBytesReader
specifier|final
specifier|static
class|class
name|ReverseBytesReader
extends|extends
name|BytesReader
block|{
DECL|method|ReverseBytesReader
specifier|public
name|ReverseBytesReader
parameter_list|(
name|byte
index|[]
name|bytes
parameter_list|,
name|int
name|pos
parameter_list|)
block|{
name|super
argument_list|(
name|bytes
argument_list|,
name|pos
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|readByte
specifier|public
name|byte
name|readByte
parameter_list|()
block|{
return|return
name|bytes
index|[
name|pos
operator|--
index|]
return|;
block|}
annotation|@
name|Override
DECL|method|readBytes
specifier|public
name|void
name|readBytes
parameter_list|(
name|byte
index|[]
name|b
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|len
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|b
index|[
name|offset
operator|+
name|i
index|]
operator|=
name|bytes
index|[
name|pos
operator|--
index|]
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|skip
specifier|public
name|void
name|skip
parameter_list|(
name|int
name|count
parameter_list|)
block|{
name|pos
operator|-=
name|count
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|skip
specifier|public
name|void
name|skip
parameter_list|(
name|int
name|base
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|pos
operator|=
name|base
operator|-
name|count
expr_stmt|;
block|}
block|}
comment|// TODO: can we use just ByteArrayDataInput...?  need to
comment|// add a .skipBytes to DataInput.. hmm and .setPosition
DECL|class|ForwardBytesReader
specifier|final
specifier|static
class|class
name|ForwardBytesReader
extends|extends
name|BytesReader
block|{
DECL|method|ForwardBytesReader
specifier|public
name|ForwardBytesReader
parameter_list|(
name|byte
index|[]
name|bytes
parameter_list|,
name|int
name|pos
parameter_list|)
block|{
name|super
argument_list|(
name|bytes
argument_list|,
name|pos
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|readByte
specifier|public
name|byte
name|readByte
parameter_list|()
block|{
return|return
name|bytes
index|[
name|pos
operator|++
index|]
return|;
block|}
annotation|@
name|Override
DECL|method|readBytes
specifier|public
name|void
name|readBytes
parameter_list|(
name|byte
index|[]
name|b
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|System
operator|.
name|arraycopy
argument_list|(
name|bytes
argument_list|,
name|pos
argument_list|,
name|b
argument_list|,
name|offset
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|pos
operator|+=
name|len
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|skip
specifier|public
name|void
name|skip
parameter_list|(
name|int
name|count
parameter_list|)
block|{
name|pos
operator|+=
name|count
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|skip
specifier|public
name|void
name|skip
parameter_list|(
name|int
name|base
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|pos
operator|=
name|base
operator|+
name|count
expr_stmt|;
block|}
block|}
DECL|class|ArcAndState
specifier|private
specifier|static
class|class
name|ArcAndState
parameter_list|<
name|T
parameter_list|>
block|{
DECL|field|arc
specifier|final
name|Arc
argument_list|<
name|T
argument_list|>
name|arc
decl_stmt|;
DECL|field|chain
specifier|final
name|IntsRef
name|chain
decl_stmt|;
DECL|method|ArcAndState
specifier|public
name|ArcAndState
parameter_list|(
name|Arc
argument_list|<
name|T
argument_list|>
name|arc
parameter_list|,
name|IntsRef
name|chain
parameter_list|)
block|{
name|this
operator|.
name|arc
operator|=
name|arc
expr_stmt|;
name|this
operator|.
name|chain
operator|=
name|chain
expr_stmt|;
block|}
block|}
comment|/*   public void countSingleChains() throws IOException {     // TODO: must assert this FST was built with     // "willRewrite"      final List<ArcAndState<T>> queue = new ArrayList<ArcAndState<T>>();      // TODO: use bitset to not revisit nodes already     // visited      FixedBitSet seen = new FixedBitSet(1+nodeCount);     int saved = 0;      queue.add(new ArcAndState<T>(getFirstArc(new Arc<T>()), new IntsRef()));     Arc<T> scratchArc = new Arc<T>();     while(queue.size()> 0) {       //System.out.println("cycle size=" + queue.size());       //for(ArcAndState<T> ent : queue) {       //  System.out.println("  " + Util.toBytesRef(ent.chain, new BytesRef()));       //  }       final ArcAndState<T> arcAndState = queue.get(queue.size()-1);       seen.set(arcAndState.arc.node);       final BytesRef br = Util.toBytesRef(arcAndState.chain, new BytesRef());       if (br.length> 0&& br.bytes[br.length-1] == -1) {         br.length--;       }       //System.out.println("  top node=" + arcAndState.arc.target + " chain=" + br.utf8ToString());       if (targetHasArcs(arcAndState.arc)&& !seen.get(arcAndState.arc.target)) {         // push         readFirstTargetArc(arcAndState.arc, scratchArc);         //System.out.println("  push label=" + (char) scratchArc.label);         //System.out.println("    tonode=" + scratchArc.target + " last?=" + scratchArc.isLast());                  final IntsRef chain = IntsRef.deepCopyOf(arcAndState.chain);         chain.grow(1+chain.length);         // TODO         //assert scratchArc.label != END_LABEL;         chain.ints[chain.length] = scratchArc.label;         chain.length++;          if (scratchArc.isLast()) {           if (scratchArc.target != -1&& inCounts[scratchArc.target] == 1) {             //System.out.println("    append");           } else {             if (arcAndState.chain.length> 1) {               saved += chain.length-2;               try {                 System.out.println("chain: " + Util.toBytesRef(chain, new BytesRef()).utf8ToString());               } catch (AssertionError ae) {                 System.out.println("chain: " + Util.toBytesRef(chain, new BytesRef()));               }             }             chain.length = 0;           }         } else {           //System.out.println("    reset");           if (arcAndState.chain.length> 1) {             saved += arcAndState.chain.length-2;             try {               System.out.println("chain: " + Util.toBytesRef(arcAndState.chain, new BytesRef()).utf8ToString());             } catch (AssertionError ae) {               System.out.println("chain: " + Util.toBytesRef(arcAndState.chain, new BytesRef()));             }           }           if (scratchArc.target != -1&& inCounts[scratchArc.target] != 1) {             chain.length = 0;           } else {             chain.ints[0] = scratchArc.label;             chain.length = 1;           }         }         // TODO: instead of new Arc() we can re-use from         // a by-depth array         queue.add(new ArcAndState<T>(new Arc<T>().copyFrom(scratchArc), chain));       } else if (!arcAndState.arc.isLast()) {         // next         readNextArc(arcAndState.arc);         //System.out.println("  next label=" + (char) arcAndState.arc.label + " len=" + arcAndState.chain.length);         if (arcAndState.chain.length != 0) {           arcAndState.chain.ints[arcAndState.chain.length-1] = arcAndState.arc.label;         }       } else {         if (arcAndState.chain.length> 1) {           saved += arcAndState.chain.length-2;           System.out.println("chain: " + Util.toBytesRef(arcAndState.chain, new BytesRef()).utf8ToString());         }         // pop         //System.out.println("  pop");         queue.remove(queue.size()-1);         while(queue.size()> 0&& queue.get(queue.size()-1).arc.isLast()) {           queue.remove(queue.size()-1);         }         if (queue.size()> 0) {           final ArcAndState<T> arcAndState2 = queue.get(queue.size()-1);           readNextArc(arcAndState2.arc);           //System.out.println("  read next=" + (char) arcAndState2.arc.label + " queue=" + queue.size());           assert arcAndState2.arc.label != END_LABEL;           if (arcAndState2.chain.length != 0) {             arcAndState2.chain.ints[arcAndState2.chain.length-1] = arcAndState2.arc.label;           }         }       }     }      System.out.println("TOT saved " + saved);   }  */
comment|// Creates a packed FST
DECL|method|FST
specifier|private
name|FST
parameter_list|(
name|INPUT_TYPE
name|inputType
parameter_list|,
name|PackedInts
operator|.
name|Reader
name|nodeRefToAddress
parameter_list|,
name|Outputs
argument_list|<
name|T
argument_list|>
name|outputs
parameter_list|)
block|{
name|packed
operator|=
literal|true
expr_stmt|;
name|this
operator|.
name|inputType
operator|=
name|inputType
expr_stmt|;
name|bytes
operator|=
operator|new
name|byte
index|[
literal|128
index|]
expr_stmt|;
name|this
operator|.
name|nodeRefToAddress
operator|=
name|nodeRefToAddress
expr_stmt|;
name|this
operator|.
name|outputs
operator|=
name|outputs
expr_stmt|;
name|NO_OUTPUT
operator|=
name|outputs
operator|.
name|getNoOutput
argument_list|()
expr_stmt|;
name|writer
operator|=
operator|new
name|DefaultBytesWriter
argument_list|()
expr_stmt|;
block|}
comment|/** Expert: creates an FST by packing this one.  This    *  process requires substantial additional RAM (currently    *  up to ~8 bytes per node depending on    *<code>acceptableOverheadRatio</code>), but then should    *  produce a smaller FST.    *    *<p>The implementation of this method uses ideas from    *<a target="_blank" href="http://www.cs.put.poznan.pl/dweiss/site/publications/download/fsacomp.pdf">Smaller Representation of Finite State Automata</a>,    *  which describes techniques to reduce the size of a FST.    *  However, this is not a strict implementation of the    *  algorithms described in this paper.    */
DECL|method|pack
specifier|public
name|FST
argument_list|<
name|T
argument_list|>
name|pack
parameter_list|(
name|int
name|minInCountDeref
parameter_list|,
name|int
name|maxDerefNodes
parameter_list|,
name|float
name|acceptableOverheadRatio
parameter_list|)
throws|throws
name|IOException
block|{
comment|// TODO: other things to try
comment|//   - renumber the nodes to get more next / better locality?
comment|//   - allow multiple input labels on an arc, so
comment|//     singular chain of inputs can take one arc (on
comment|//     wikipedia terms this could save another ~6%)
comment|//   - in the ord case, the output '1' is presumably
comment|//     very common (after NO_OUTPUT)... maybe use a bit
comment|//     for it..?
comment|//   - use spare bits in flags.... for top few labels /
comment|//     outputs / targets
if|if
condition|(
name|nodeAddress
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"this FST was not built with willPackFST=true"
argument_list|)
throw|;
block|}
name|Arc
argument_list|<
name|T
argument_list|>
name|arc
init|=
operator|new
name|Arc
argument_list|<
name|T
argument_list|>
argument_list|()
decl_stmt|;
specifier|final
name|BytesReader
name|r
init|=
name|getBytesReader
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|int
name|topN
init|=
name|Math
operator|.
name|min
argument_list|(
name|maxDerefNodes
argument_list|,
name|inCounts
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
comment|// Find top nodes with highest number of incoming arcs:
name|NodeQueue
name|q
init|=
operator|new
name|NodeQueue
argument_list|(
name|topN
argument_list|)
decl_stmt|;
comment|// TODO: we could use more RAM efficient selection algo here...
name|NodeAndInCount
name|bottom
init|=
literal|null
decl_stmt|;
for|for
control|(
name|int
name|node
init|=
literal|0
init|;
name|node
operator|<
name|inCounts
operator|.
name|size
argument_list|()
condition|;
name|node
operator|++
control|)
block|{
if|if
condition|(
name|inCounts
operator|.
name|get
argument_list|(
name|node
argument_list|)
operator|>=
name|minInCountDeref
condition|)
block|{
if|if
condition|(
name|bottom
operator|==
literal|null
condition|)
block|{
name|q
operator|.
name|add
argument_list|(
operator|new
name|NodeAndInCount
argument_list|(
name|node
argument_list|,
operator|(
name|int
operator|)
name|inCounts
operator|.
name|get
argument_list|(
name|node
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|.
name|size
argument_list|()
operator|==
name|topN
condition|)
block|{
name|bottom
operator|=
name|q
operator|.
name|top
argument_list|()
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|inCounts
operator|.
name|get
argument_list|(
name|node
argument_list|)
operator|>
name|bottom
operator|.
name|count
condition|)
block|{
name|q
operator|.
name|insertWithOverflow
argument_list|(
operator|new
name|NodeAndInCount
argument_list|(
name|node
argument_list|,
operator|(
name|int
operator|)
name|inCounts
operator|.
name|get
argument_list|(
name|node
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// Free up RAM:
name|inCounts
operator|=
literal|null
expr_stmt|;
specifier|final
name|Map
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|topNodeMap
init|=
operator|new
name|HashMap
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|downTo
init|=
name|q
operator|.
name|size
argument_list|()
operator|-
literal|1
init|;
name|downTo
operator|>=
literal|0
condition|;
name|downTo
operator|--
control|)
block|{
name|NodeAndInCount
name|n
init|=
name|q
operator|.
name|pop
argument_list|()
decl_stmt|;
name|topNodeMap
operator|.
name|put
argument_list|(
name|n
operator|.
name|node
argument_list|,
name|downTo
argument_list|)
expr_stmt|;
comment|//System.out.println("map node=" + n.node + " inCount=" + n.count + " to newID=" + downTo);
block|}
specifier|final
name|FST
argument_list|<
name|T
argument_list|>
name|fst
init|=
operator|new
name|FST
argument_list|<
name|T
argument_list|>
argument_list|(
name|inputType
argument_list|,
literal|null
argument_list|,
name|outputs
argument_list|)
decl_stmt|;
specifier|final
name|BytesWriter
name|writer
init|=
name|fst
operator|.
name|writer
decl_stmt|;
comment|// +1 because node ords start at 1 (0 is reserved as stop node):
specifier|final
name|GrowableWriter
name|newNodeAddress
init|=
operator|new
name|GrowableWriter
argument_list|(
name|PackedInts
operator|.
name|bitsRequired
argument_list|(
name|bytes
operator|.
name|length
argument_list|)
argument_list|,
literal|1
operator|+
name|nodeCount
argument_list|,
name|acceptableOverheadRatio
argument_list|)
decl_stmt|;
comment|// Fill initial coarse guess:
for|for
control|(
name|int
name|node
init|=
literal|1
init|;
name|node
operator|<=
name|nodeCount
condition|;
name|node
operator|++
control|)
block|{
name|newNodeAddress
operator|.
name|set
argument_list|(
name|node
argument_list|,
literal|1
operator|+
name|bytes
operator|.
name|length
operator|-
name|nodeAddress
operator|.
name|get
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|int
name|absCount
decl_stmt|;
name|int
name|deltaCount
decl_stmt|;
name|int
name|topCount
decl_stmt|;
name|int
name|nextCount
decl_stmt|;
comment|// Iterate until we converge:
while|while
condition|(
literal|true
condition|)
block|{
comment|//System.out.println("\nITER");
name|boolean
name|changed
init|=
literal|false
decl_stmt|;
comment|// for assert:
name|boolean
name|negDelta
init|=
literal|false
decl_stmt|;
name|writer
operator|.
name|setPosition
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|// Skip 0 byte since 0 is reserved target:
name|writer
operator|.
name|writeByte
argument_list|(
operator|(
name|byte
operator|)
literal|0
argument_list|)
expr_stmt|;
name|fst
operator|.
name|arcWithOutputCount
operator|=
literal|0
expr_stmt|;
name|fst
operator|.
name|nodeCount
operator|=
literal|0
expr_stmt|;
name|fst
operator|.
name|arcCount
operator|=
literal|0
expr_stmt|;
name|absCount
operator|=
name|deltaCount
operator|=
name|topCount
operator|=
name|nextCount
operator|=
literal|0
expr_stmt|;
name|int
name|changedCount
init|=
literal|0
decl_stmt|;
name|int
name|addressError
init|=
literal|0
decl_stmt|;
comment|//int totWasted = 0;
comment|// Since we re-reverse the bytes, we now write the
comment|// nodes backwards, so that BIT_TARGET_NEXT is
comment|// unchanged:
for|for
control|(
name|int
name|node
init|=
name|nodeCount
init|;
name|node
operator|>=
literal|1
condition|;
name|node
operator|--
control|)
block|{
name|fst
operator|.
name|nodeCount
operator|++
expr_stmt|;
specifier|final
name|int
name|address
init|=
name|writer
operator|.
name|getPosition
argument_list|()
decl_stmt|;
comment|//System.out.println("  node: " + node + " address=" + address);
if|if
condition|(
name|address
operator|!=
name|newNodeAddress
operator|.
name|get
argument_list|(
name|node
argument_list|)
condition|)
block|{
name|addressError
operator|=
name|address
operator|-
operator|(
name|int
operator|)
name|newNodeAddress
operator|.
name|get
argument_list|(
name|node
argument_list|)
expr_stmt|;
comment|//System.out.println("    change: " + (address - newNodeAddress[node]));
name|changed
operator|=
literal|true
expr_stmt|;
name|newNodeAddress
operator|.
name|set
argument_list|(
name|node
argument_list|,
name|address
argument_list|)
expr_stmt|;
name|changedCount
operator|++
expr_stmt|;
block|}
name|int
name|nodeArcCount
init|=
literal|0
decl_stmt|;
name|int
name|bytesPerArc
init|=
literal|0
decl_stmt|;
name|boolean
name|retry
init|=
literal|false
decl_stmt|;
comment|// for assert:
name|boolean
name|anyNegDelta
init|=
literal|false
decl_stmt|;
comment|// Retry loop: possibly iterate more than once, if
comment|// this is an array'd node and bytesPerArc changes:
name|writeNode
label|:
while|while
condition|(
literal|true
condition|)
block|{
comment|// retry writing this node
name|readFirstRealTargetArc
argument_list|(
name|node
argument_list|,
name|arc
argument_list|,
name|r
argument_list|)
expr_stmt|;
specifier|final
name|boolean
name|useArcArray
init|=
name|arc
operator|.
name|bytesPerArc
operator|!=
literal|0
decl_stmt|;
if|if
condition|(
name|useArcArray
condition|)
block|{
comment|// Write false first arc:
if|if
condition|(
name|bytesPerArc
operator|==
literal|0
condition|)
block|{
name|bytesPerArc
operator|=
name|arc
operator|.
name|bytesPerArc
expr_stmt|;
block|}
name|writer
operator|.
name|writeByte
argument_list|(
name|ARCS_AS_FIXED_ARRAY
argument_list|)
expr_stmt|;
name|writer
operator|.
name|writeVInt
argument_list|(
name|arc
operator|.
name|numArcs
argument_list|)
expr_stmt|;
name|writer
operator|.
name|writeVInt
argument_list|(
name|bytesPerArc
argument_list|)
expr_stmt|;
comment|//System.out.println("node " + node + ": " + arc.numArcs + " arcs");
block|}
name|int
name|maxBytesPerArc
init|=
literal|0
decl_stmt|;
comment|//int wasted = 0;
while|while
condition|(
literal|true
condition|)
block|{
comment|// iterate over all arcs for this node
comment|//System.out.println("    arc label=" + arc.label + " target=" + arc.target + " pos=" + writer.posWrite);
specifier|final
name|int
name|arcStartPos
init|=
name|writer
operator|.
name|getPosition
argument_list|()
decl_stmt|;
name|nodeArcCount
operator|++
expr_stmt|;
name|byte
name|flags
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|arc
operator|.
name|isLast
argument_list|()
condition|)
block|{
name|flags
operator|+=
name|BIT_LAST_ARC
expr_stmt|;
block|}
comment|/*             if (!useArcArray&& nodeUpto< nodes.length-1&& arc.target == nodes[nodeUpto+1]) {               flags += BIT_TARGET_NEXT;             }             */
if|if
condition|(
operator|!
name|useArcArray
operator|&&
name|node
operator|!=
literal|1
operator|&&
name|arc
operator|.
name|target
operator|==
name|node
operator|-
literal|1
condition|)
block|{
name|flags
operator|+=
name|BIT_TARGET_NEXT
expr_stmt|;
if|if
condition|(
operator|!
name|retry
condition|)
block|{
name|nextCount
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|arc
operator|.
name|isFinal
argument_list|()
condition|)
block|{
name|flags
operator|+=
name|BIT_FINAL_ARC
expr_stmt|;
if|if
condition|(
name|arc
operator|.
name|nextFinalOutput
operator|!=
name|NO_OUTPUT
condition|)
block|{
name|flags
operator|+=
name|BIT_ARC_HAS_FINAL_OUTPUT
expr_stmt|;
block|}
block|}
else|else
block|{
assert|assert
name|arc
operator|.
name|nextFinalOutput
operator|==
name|NO_OUTPUT
assert|;
block|}
if|if
condition|(
operator|!
name|targetHasArcs
argument_list|(
name|arc
argument_list|)
condition|)
block|{
name|flags
operator|+=
name|BIT_STOP_NODE
expr_stmt|;
block|}
if|if
condition|(
name|arc
operator|.
name|output
operator|!=
name|NO_OUTPUT
condition|)
block|{
name|flags
operator|+=
name|BIT_ARC_HAS_OUTPUT
expr_stmt|;
block|}
specifier|final
name|Integer
name|ptr
decl_stmt|;
specifier|final
name|int
name|absPtr
decl_stmt|;
specifier|final
name|boolean
name|doWriteTarget
init|=
name|targetHasArcs
argument_list|(
name|arc
argument_list|)
operator|&&
operator|(
name|flags
operator|&
name|BIT_TARGET_NEXT
operator|)
operator|==
literal|0
decl_stmt|;
if|if
condition|(
name|doWriteTarget
condition|)
block|{
name|ptr
operator|=
name|topNodeMap
operator|.
name|get
argument_list|(
name|arc
operator|.
name|target
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|!=
literal|null
condition|)
block|{
name|absPtr
operator|=
name|ptr
expr_stmt|;
block|}
else|else
block|{
name|absPtr
operator|=
name|topNodeMap
operator|.
name|size
argument_list|()
operator|+
operator|(
name|int
operator|)
name|newNodeAddress
operator|.
name|get
argument_list|(
name|arc
operator|.
name|target
argument_list|)
operator|+
name|addressError
expr_stmt|;
block|}
name|int
name|delta
init|=
operator|(
name|int
operator|)
name|newNodeAddress
operator|.
name|get
argument_list|(
name|arc
operator|.
name|target
argument_list|)
operator|+
name|addressError
operator|-
name|writer
operator|.
name|getPosition
argument_list|()
operator|-
literal|2
decl_stmt|;
if|if
condition|(
name|delta
operator|<
literal|0
condition|)
block|{
comment|//System.out.println("neg: " + delta);
name|anyNegDelta
operator|=
literal|true
expr_stmt|;
name|delta
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|delta
operator|<
name|absPtr
condition|)
block|{
name|flags
operator||=
name|BIT_TARGET_DELTA
expr_stmt|;
block|}
block|}
else|else
block|{
name|ptr
operator|=
literal|null
expr_stmt|;
name|absPtr
operator|=
literal|0
expr_stmt|;
block|}
name|writer
operator|.
name|writeByte
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|fst
operator|.
name|writeLabel
argument_list|(
name|arc
operator|.
name|label
argument_list|)
expr_stmt|;
if|if
condition|(
name|arc
operator|.
name|output
operator|!=
name|NO_OUTPUT
condition|)
block|{
name|outputs
operator|.
name|write
argument_list|(
name|arc
operator|.
name|output
argument_list|,
name|writer
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|retry
condition|)
block|{
name|fst
operator|.
name|arcWithOutputCount
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|arc
operator|.
name|nextFinalOutput
operator|!=
name|NO_OUTPUT
condition|)
block|{
name|outputs
operator|.
name|writeFinalOutput
argument_list|(
name|arc
operator|.
name|nextFinalOutput
argument_list|,
name|writer
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|doWriteTarget
condition|)
block|{
name|int
name|delta
init|=
operator|(
name|int
operator|)
name|newNodeAddress
operator|.
name|get
argument_list|(
name|arc
operator|.
name|target
argument_list|)
operator|+
name|addressError
operator|-
name|writer
operator|.
name|getPosition
argument_list|()
decl_stmt|;
if|if
condition|(
name|delta
operator|<
literal|0
condition|)
block|{
name|anyNegDelta
operator|=
literal|true
expr_stmt|;
comment|//System.out.println("neg: " + delta);
name|delta
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|flag
argument_list|(
name|flags
argument_list|,
name|BIT_TARGET_DELTA
argument_list|)
condition|)
block|{
comment|//System.out.println("        delta");
name|writer
operator|.
name|writeVInt
argument_list|(
name|delta
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|retry
condition|)
block|{
name|deltaCount
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/*                 if (ptr != null) {                   System.out.println("        deref");                 } else {                   System.out.println("        abs");                 }                 */
name|writer
operator|.
name|writeVInt
argument_list|(
name|absPtr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|retry
condition|)
block|{
if|if
condition|(
name|absPtr
operator|>=
name|topNodeMap
operator|.
name|size
argument_list|()
condition|)
block|{
name|absCount
operator|++
expr_stmt|;
block|}
else|else
block|{
name|topCount
operator|++
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|useArcArray
condition|)
block|{
specifier|final
name|int
name|arcBytes
init|=
name|writer
operator|.
name|getPosition
argument_list|()
operator|-
name|arcStartPos
decl_stmt|;
comment|//System.out.println("  " + arcBytes + " bytes");
name|maxBytesPerArc
operator|=
name|Math
operator|.
name|max
argument_list|(
name|maxBytesPerArc
argument_list|,
name|arcBytes
argument_list|)
expr_stmt|;
comment|// NOTE: this may in fact go "backwards", if
comment|// somehow (rarely, possibly never) we use
comment|// more bytesPerArc in this rewrite than the
comment|// incoming FST did... but in this case we
comment|// will retry (below) so it's OK to ovewrite
comment|// bytes:
comment|//wasted += bytesPerArc - arcBytes;
name|writer
operator|.
name|setPosition
argument_list|(
name|arcStartPos
operator|+
name|bytesPerArc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|arc
operator|.
name|isLast
argument_list|()
condition|)
block|{
break|break;
block|}
name|readNextRealArc
argument_list|(
name|arc
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|useArcArray
condition|)
block|{
if|if
condition|(
name|maxBytesPerArc
operator|==
name|bytesPerArc
operator|||
operator|(
name|retry
operator|&&
name|maxBytesPerArc
operator|<=
name|bytesPerArc
operator|)
condition|)
block|{
comment|// converged
comment|//System.out.println("  bba=" + bytesPerArc + " wasted=" + wasted);
comment|//totWasted += wasted;
break|break;
block|}
block|}
else|else
block|{
break|break;
block|}
comment|//System.out.println("  retry this node maxBytesPerArc=" + maxBytesPerArc + " vs " + bytesPerArc);
comment|// Retry:
name|bytesPerArc
operator|=
name|maxBytesPerArc
expr_stmt|;
name|writer
operator|.
name|setPosition
argument_list|(
name|address
argument_list|)
expr_stmt|;
name|nodeArcCount
operator|=
literal|0
expr_stmt|;
name|retry
operator|=
literal|true
expr_stmt|;
name|anyNegDelta
operator|=
literal|false
expr_stmt|;
block|}
name|negDelta
operator||=
name|anyNegDelta
expr_stmt|;
name|fst
operator|.
name|arcCount
operator|+=
name|nodeArcCount
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|changed
condition|)
block|{
comment|// We don't renumber the nodes (just reverse their
comment|// order) so nodes should only point forward to
comment|// other nodes because we only produce acyclic FSTs
comment|// w/ nodes only pointing "forwards":
assert|assert
operator|!
name|negDelta
assert|;
comment|//System.out.println("TOT wasted=" + totWasted);
comment|// Converged!
break|break;
block|}
comment|//System.out.println("  " + changedCount + " of " + fst.nodeCount + " changed; retry");
block|}
name|long
name|maxAddress
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|key
range|:
name|topNodeMap
operator|.
name|keySet
argument_list|()
control|)
block|{
name|maxAddress
operator|=
name|Math
operator|.
name|max
argument_list|(
name|maxAddress
argument_list|,
name|newNodeAddress
operator|.
name|get
argument_list|(
name|key
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|PackedInts
operator|.
name|Mutable
name|nodeRefToAddressIn
init|=
name|PackedInts
operator|.
name|getMutable
argument_list|(
name|topNodeMap
operator|.
name|size
argument_list|()
argument_list|,
name|PackedInts
operator|.
name|bitsRequired
argument_list|(
name|maxAddress
argument_list|)
argument_list|,
name|acceptableOverheadRatio
argument_list|)
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|ent
range|:
name|topNodeMap
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|nodeRefToAddressIn
operator|.
name|set
argument_list|(
name|ent
operator|.
name|getValue
argument_list|()
argument_list|,
name|newNodeAddress
operator|.
name|get
argument_list|(
name|ent
operator|.
name|getKey
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|fst
operator|.
name|nodeRefToAddress
operator|=
name|nodeRefToAddressIn
expr_stmt|;
name|fst
operator|.
name|startNode
operator|=
operator|(
name|int
operator|)
name|newNodeAddress
operator|.
name|get
argument_list|(
name|startNode
argument_list|)
expr_stmt|;
comment|//System.out.println("new startNode=" + fst.startNode + " old startNode=" + startNode);
if|if
condition|(
name|emptyOutput
operator|!=
literal|null
condition|)
block|{
name|fst
operator|.
name|setEmptyOutput
argument_list|(
name|emptyOutput
argument_list|)
expr_stmt|;
block|}
assert|assert
name|fst
operator|.
name|nodeCount
operator|==
name|nodeCount
operator|:
literal|"fst.nodeCount="
operator|+
name|fst
operator|.
name|nodeCount
operator|+
literal|" nodeCount="
operator|+
name|nodeCount
assert|;
assert|assert
name|fst
operator|.
name|arcCount
operator|==
name|arcCount
assert|;
assert|assert
name|fst
operator|.
name|arcWithOutputCount
operator|==
name|arcWithOutputCount
operator|:
literal|"fst.arcWithOutputCount="
operator|+
name|fst
operator|.
name|arcWithOutputCount
operator|+
literal|" arcWithOutputCount="
operator|+
name|arcWithOutputCount
assert|;
specifier|final
name|byte
index|[]
name|finalBytes
init|=
operator|new
name|byte
index|[
name|writer
operator|.
name|getPosition
argument_list|()
index|]
decl_stmt|;
comment|//System.out.println("resize " + fst.bytes.length + " down to " + writer.posWrite);
name|System
operator|.
name|arraycopy
argument_list|(
name|fst
operator|.
name|bytes
argument_list|,
literal|0
argument_list|,
name|finalBytes
argument_list|,
literal|0
argument_list|,
name|writer
operator|.
name|getPosition
argument_list|()
argument_list|)
expr_stmt|;
name|fst
operator|.
name|bytes
operator|=
name|finalBytes
expr_stmt|;
name|fst
operator|.
name|cacheRootArcs
argument_list|()
expr_stmt|;
comment|//final int size = fst.sizeInBytes();
comment|//System.out.println("nextCount=" + nextCount + " topCount=" + topCount + " deltaCount=" + deltaCount + " absCount=" + absCount);
return|return
name|fst
return|;
block|}
DECL|class|NodeAndInCount
specifier|private
specifier|static
class|class
name|NodeAndInCount
implements|implements
name|Comparable
argument_list|<
name|NodeAndInCount
argument_list|>
block|{
DECL|field|node
specifier|final
name|int
name|node
decl_stmt|;
DECL|field|count
specifier|final
name|int
name|count
decl_stmt|;
DECL|method|NodeAndInCount
specifier|public
name|NodeAndInCount
parameter_list|(
name|int
name|node
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|this
operator|.
name|node
operator|=
name|node
expr_stmt|;
name|this
operator|.
name|count
operator|=
name|count
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|compareTo
specifier|public
name|int
name|compareTo
parameter_list|(
name|NodeAndInCount
name|other
parameter_list|)
block|{
if|if
condition|(
name|count
operator|>
name|other
operator|.
name|count
condition|)
block|{
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|count
operator|<
name|other
operator|.
name|count
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
else|else
block|{
comment|// Tie-break: smaller node compares as greater than
return|return
name|other
operator|.
name|node
operator|-
name|node
return|;
block|}
block|}
block|}
DECL|class|NodeQueue
specifier|private
specifier|static
class|class
name|NodeQueue
extends|extends
name|PriorityQueue
argument_list|<
name|NodeAndInCount
argument_list|>
block|{
DECL|method|NodeQueue
specifier|public
name|NodeQueue
parameter_list|(
name|int
name|topN
parameter_list|)
block|{
name|super
argument_list|(
name|topN
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|lessThan
specifier|public
name|boolean
name|lessThan
parameter_list|(
name|NodeAndInCount
name|a
parameter_list|,
name|NodeAndInCount
name|b
parameter_list|)
block|{
specifier|final
name|int
name|cmp
init|=
name|a
operator|.
name|compareTo
argument_list|(
name|b
argument_list|)
decl_stmt|;
assert|assert
name|cmp
operator|!=
literal|0
assert|;
return|return
name|cmp
operator|<
literal|0
return|;
block|}
block|}
block|}
end_class
end_unit
