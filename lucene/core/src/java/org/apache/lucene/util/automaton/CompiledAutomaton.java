begin_unit
begin_package
DECL|package|org.apache.lucene.util.automaton
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|automaton
package|;
end_package
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|SingleTermsEnum
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|Terms
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|TermsEnum
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|BytesRef
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|BytesRefBuilder
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|IntsRef
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|StringHelper
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|UnicodeUtil
import|;
end_import
begin_comment
comment|/**  * Immutable class holding compiled details for a given  * Automaton.  The Automaton is deterministic, must not have  * dead states but is not necessarily minimal.  *  * @lucene.experimental  */
end_comment
begin_class
DECL|class|CompiledAutomaton
specifier|public
class|class
name|CompiledAutomaton
block|{
comment|/**    * Automata are compiled into different internal forms for the    * most efficient execution depending upon the language they accept.    */
DECL|enum|AUTOMATON_TYPE
specifier|public
enum|enum
name|AUTOMATON_TYPE
block|{
comment|/** Automaton that accepts no strings. */
DECL|enum constant|NONE
name|NONE
block|,
comment|/** Automaton that accepts all possible strings. */
DECL|enum constant|ALL
name|ALL
block|,
comment|/** Automaton that accepts only a single fixed string. */
DECL|enum constant|SINGLE
name|SINGLE
block|,
comment|/** Catch-all for any other automata. */
DECL|enum constant|NORMAL
name|NORMAL
block|}
empty_stmt|;
comment|/** If simplify is true this will be the "simplified" type; else, this is NORMAL */
DECL|field|type
specifier|public
specifier|final
name|AUTOMATON_TYPE
name|type
decl_stmt|;
comment|/**     * For {@link AUTOMATON_TYPE#SINGLE} this is the singleton term.    */
DECL|field|term
specifier|public
specifier|final
name|BytesRef
name|term
decl_stmt|;
comment|/**     * Matcher for quickly determining if a byte[] is accepted.    * only valid for {@link AUTOMATON_TYPE#NORMAL}.    */
DECL|field|runAutomaton
specifier|public
specifier|final
name|ByteRunAutomaton
name|runAutomaton
decl_stmt|;
comment|/**    * Two dimensional array of transitions, indexed by state    * number for traversal. The state numbering is consistent with    * {@link #runAutomaton}.     * Only valid for {@link AUTOMATON_TYPE#NORMAL}.    */
DECL|field|automaton
specifier|public
specifier|final
name|Automaton
name|automaton
decl_stmt|;
comment|/**    * Shared common suffix accepted by the automaton. Only valid    * for {@link AUTOMATON_TYPE#NORMAL}, and only when the    * automaton accepts an infinite language.    */
DECL|field|commonSuffixRef
specifier|public
specifier|final
name|BytesRef
name|commonSuffixRef
decl_stmt|;
comment|/**    * Indicates if the automaton accepts a finite set of strings.    * Null if this was not computed.    * Only valid for {@link AUTOMATON_TYPE#NORMAL}.    */
DECL|field|finite
specifier|public
specifier|final
name|Boolean
name|finite
decl_stmt|;
comment|/** Create this, passing simplify=true and finite=null, so that we try    *  to simplify the automaton and determine if it is finite. */
DECL|method|CompiledAutomaton
specifier|public
name|CompiledAutomaton
parameter_list|(
name|Automaton
name|automaton
parameter_list|)
block|{
name|this
argument_list|(
name|automaton
argument_list|,
literal|null
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
comment|/** Create this.  If finite is null, we use {@link Operations#isFinite}    *  to determine whether it is finite.  If simplify is true, we run    *  possibly expensive operations to determine if the automaton is one    *  the cases in {@link CompiledAutomaton.AUTOMATON_TYPE}. */
DECL|method|CompiledAutomaton
specifier|public
name|CompiledAutomaton
parameter_list|(
name|Automaton
name|automaton
parameter_list|,
name|Boolean
name|finite
parameter_list|,
name|boolean
name|simplify
parameter_list|)
block|{
name|this
argument_list|(
name|automaton
argument_list|,
name|finite
argument_list|,
name|simplify
argument_list|,
name|Operations
operator|.
name|DEFAULT_MAX_DETERMINIZED_STATES
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
comment|/** Create this.  If finite is null, we use {@link Operations#isFinite}    *  to determine whether it is finite.  If simplify is true, we run    *  possibly expensive operations to determine if the automaton is one    *  the cases in {@link CompiledAutomaton.AUTOMATON_TYPE}. If simplify    *  requires determinizing the autaomaton then only maxDeterminizedStates    *  will be created.  Any more than that will cause a    *  TooComplexToDeterminizeException.    */
DECL|method|CompiledAutomaton
specifier|public
name|CompiledAutomaton
parameter_list|(
name|Automaton
name|automaton
parameter_list|,
name|Boolean
name|finite
parameter_list|,
name|boolean
name|simplify
parameter_list|,
name|int
name|maxDeterminizedStates
parameter_list|,
name|boolean
name|isBinary
parameter_list|)
block|{
if|if
condition|(
name|automaton
operator|.
name|getNumStates
argument_list|()
operator|==
literal|0
condition|)
block|{
name|automaton
operator|=
operator|new
name|Automaton
argument_list|()
expr_stmt|;
name|automaton
operator|.
name|createState
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|simplify
condition|)
block|{
comment|// Test whether the automaton is a "simple" form and
comment|// if so, don't create a runAutomaton.  Note that on a
comment|// large automaton these tests could be costly:
if|if
condition|(
name|Operations
operator|.
name|isEmpty
argument_list|(
name|automaton
argument_list|)
condition|)
block|{
comment|// matches nothing
name|type
operator|=
name|AUTOMATON_TYPE
operator|.
name|NONE
expr_stmt|;
name|term
operator|=
literal|null
expr_stmt|;
name|commonSuffixRef
operator|=
literal|null
expr_stmt|;
name|runAutomaton
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|automaton
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|finite
operator|=
literal|null
expr_stmt|;
return|return;
block|}
name|boolean
name|isTotal
decl_stmt|;
comment|// NOTE: only approximate, because automaton may not be minimal:
if|if
condition|(
name|isBinary
condition|)
block|{
name|isTotal
operator|=
name|Operations
operator|.
name|isTotal
argument_list|(
name|automaton
argument_list|,
literal|0
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|isTotal
operator|=
name|Operations
operator|.
name|isTotal
argument_list|(
name|automaton
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|isTotal
condition|)
block|{
comment|// matches all possible strings
name|type
operator|=
name|AUTOMATON_TYPE
operator|.
name|ALL
expr_stmt|;
name|term
operator|=
literal|null
expr_stmt|;
name|commonSuffixRef
operator|=
literal|null
expr_stmt|;
name|runAutomaton
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|automaton
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|finite
operator|=
literal|null
expr_stmt|;
return|return;
block|}
name|automaton
operator|=
name|Operations
operator|.
name|determinize
argument_list|(
name|automaton
argument_list|,
name|maxDeterminizedStates
argument_list|)
expr_stmt|;
name|IntsRef
name|singleton
init|=
name|Operations
operator|.
name|getSingleton
argument_list|(
name|automaton
argument_list|)
decl_stmt|;
if|if
condition|(
name|singleton
operator|!=
literal|null
condition|)
block|{
comment|// matches a fixed string
name|type
operator|=
name|AUTOMATON_TYPE
operator|.
name|SINGLE
expr_stmt|;
name|commonSuffixRef
operator|=
literal|null
expr_stmt|;
name|runAutomaton
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|automaton
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|finite
operator|=
literal|null
expr_stmt|;
if|if
condition|(
name|isBinary
condition|)
block|{
name|term
operator|=
name|StringHelper
operator|.
name|intsRefToBytesRef
argument_list|(
name|singleton
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|term
operator|=
operator|new
name|BytesRef
argument_list|(
name|UnicodeUtil
operator|.
name|newString
argument_list|(
name|singleton
operator|.
name|ints
argument_list|,
name|singleton
operator|.
name|offset
argument_list|,
name|singleton
operator|.
name|length
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
block|}
name|type
operator|=
name|AUTOMATON_TYPE
operator|.
name|NORMAL
expr_stmt|;
name|term
operator|=
literal|null
expr_stmt|;
if|if
condition|(
name|finite
operator|==
literal|null
condition|)
block|{
name|this
operator|.
name|finite
operator|=
name|Operations
operator|.
name|isFinite
argument_list|(
name|automaton
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|this
operator|.
name|finite
operator|=
name|finite
expr_stmt|;
block|}
name|Automaton
name|binary
decl_stmt|;
if|if
condition|(
name|isBinary
condition|)
block|{
comment|// Caller already built binary automaton themselves, e.g. PrefixQuery
comment|// does this since it can be provided with a binary (not necessarily
comment|// UTF8!) term:
name|binary
operator|=
name|automaton
expr_stmt|;
block|}
else|else
block|{
comment|// Incoming automaton is unicode, and we must convert to UTF8 to match what's in the index:
name|binary
operator|=
operator|new
name|UTF32ToUTF8
argument_list|()
operator|.
name|convert
argument_list|(
name|automaton
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|this
operator|.
name|finite
condition|)
block|{
name|commonSuffixRef
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
comment|// NOTE: this is a very costly operation!  We should test if it's really warranted in practice...
name|commonSuffixRef
operator|=
name|Operations
operator|.
name|getCommonSuffixBytesRef
argument_list|(
name|binary
argument_list|,
name|maxDeterminizedStates
argument_list|)
expr_stmt|;
block|}
comment|// This will determinize the binary automaton for us:
name|runAutomaton
operator|=
operator|new
name|ByteRunAutomaton
argument_list|(
name|binary
argument_list|,
literal|true
argument_list|,
name|maxDeterminizedStates
argument_list|)
expr_stmt|;
name|this
operator|.
name|automaton
operator|=
name|runAutomaton
operator|.
name|automaton
expr_stmt|;
block|}
DECL|field|transition
specifier|private
name|Transition
name|transition
init|=
operator|new
name|Transition
argument_list|()
decl_stmt|;
comment|//private static final boolean DEBUG = BlockTreeTermsWriter.DEBUG;
DECL|method|addTail
specifier|private
name|BytesRef
name|addTail
parameter_list|(
name|int
name|state
parameter_list|,
name|BytesRefBuilder
name|term
parameter_list|,
name|int
name|idx
parameter_list|,
name|int
name|leadLabel
parameter_list|)
block|{
comment|//System.out.println("addTail state=" + state + " term=" + term.utf8ToString() + " idx=" + idx + " leadLabel=" + (char) leadLabel);
comment|//System.out.println(automaton.toDot());
comment|// Find biggest transition that's< label
comment|// TODO: use binary search here
name|int
name|maxIndex
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|numTransitions
init|=
name|automaton
operator|.
name|initTransition
argument_list|(
name|state
argument_list|,
name|transition
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numTransitions
condition|;
name|i
operator|++
control|)
block|{
name|automaton
operator|.
name|getNextTransition
argument_list|(
name|transition
argument_list|)
expr_stmt|;
if|if
condition|(
name|transition
operator|.
name|min
operator|<
name|leadLabel
condition|)
block|{
name|maxIndex
operator|=
name|i
expr_stmt|;
block|}
else|else
block|{
comment|// Transitions are alway sorted
break|break;
block|}
block|}
comment|//System.out.println("  maxIndex=" + maxIndex);
assert|assert
name|maxIndex
operator|!=
operator|-
literal|1
assert|;
name|automaton
operator|.
name|getTransition
argument_list|(
name|state
argument_list|,
name|maxIndex
argument_list|,
name|transition
argument_list|)
expr_stmt|;
comment|// Append floorLabel
specifier|final
name|int
name|floorLabel
decl_stmt|;
if|if
condition|(
name|transition
operator|.
name|max
operator|>
name|leadLabel
operator|-
literal|1
condition|)
block|{
name|floorLabel
operator|=
name|leadLabel
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|floorLabel
operator|=
name|transition
operator|.
name|max
expr_stmt|;
block|}
comment|//System.out.println("  floorLabel=" + (char) floorLabel);
name|term
operator|.
name|grow
argument_list|(
literal|1
operator|+
name|idx
argument_list|)
expr_stmt|;
comment|//if (DEBUG) System.out.println("  add floorLabel=" + (char) floorLabel + " idx=" + idx);
name|term
operator|.
name|setByteAt
argument_list|(
name|idx
argument_list|,
operator|(
name|byte
operator|)
name|floorLabel
argument_list|)
expr_stmt|;
name|state
operator|=
name|transition
operator|.
name|dest
expr_stmt|;
comment|//System.out.println("  dest: " + state);
name|idx
operator|++
expr_stmt|;
comment|// Push down to last accept state
while|while
condition|(
literal|true
condition|)
block|{
name|numTransitions
operator|=
name|automaton
operator|.
name|getNumTransitions
argument_list|(
name|state
argument_list|)
expr_stmt|;
if|if
condition|(
name|numTransitions
operator|==
literal|0
condition|)
block|{
comment|//System.out.println("state=" + state + " 0 trans");
assert|assert
name|runAutomaton
operator|.
name|isAccept
argument_list|(
name|state
argument_list|)
assert|;
name|term
operator|.
name|setLength
argument_list|(
name|idx
argument_list|)
expr_stmt|;
comment|//if (DEBUG) System.out.println("  return " + term.utf8ToString());
return|return
name|term
operator|.
name|get
argument_list|()
return|;
block|}
else|else
block|{
comment|// We are pushing "top" -- so get last label of
comment|// last transition:
comment|//System.out.println("get state=" + state + " numTrans=" + numTransitions);
name|automaton
operator|.
name|getTransition
argument_list|(
name|state
argument_list|,
name|numTransitions
operator|-
literal|1
argument_list|,
name|transition
argument_list|)
expr_stmt|;
name|term
operator|.
name|grow
argument_list|(
literal|1
operator|+
name|idx
argument_list|)
expr_stmt|;
comment|//if (DEBUG) System.out.println("  push maxLabel=" + (char) lastTransition.max + " idx=" + idx);
comment|//System.out.println("  add trans dest=" + scratch.dest + " label=" + (char) scratch.max);
name|term
operator|.
name|setByteAt
argument_list|(
name|idx
argument_list|,
operator|(
name|byte
operator|)
name|transition
operator|.
name|max
argument_list|)
expr_stmt|;
name|state
operator|=
name|transition
operator|.
name|dest
expr_stmt|;
name|idx
operator|++
expr_stmt|;
block|}
block|}
block|}
comment|// TODO: should this take startTerm too?  This way
comment|// Terms.intersect could forward to this method if type !=
comment|// NORMAL:
comment|/** Return a {@link TermsEnum} intersecting the provided {@link Terms}    *  with the terms accepted by this automaton. */
DECL|method|getTermsEnum
specifier|public
name|TermsEnum
name|getTermsEnum
parameter_list|(
name|Terms
name|terms
parameter_list|)
throws|throws
name|IOException
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|NONE
case|:
return|return
name|TermsEnum
operator|.
name|EMPTY
return|;
case|case
name|ALL
case|:
return|return
name|terms
operator|.
name|iterator
argument_list|(
literal|null
argument_list|)
return|;
case|case
name|SINGLE
case|:
return|return
operator|new
name|SingleTermsEnum
argument_list|(
name|terms
operator|.
name|iterator
argument_list|(
literal|null
argument_list|)
argument_list|,
name|term
argument_list|)
return|;
case|case
name|NORMAL
case|:
return|return
name|terms
operator|.
name|intersect
argument_list|(
name|this
argument_list|,
literal|null
argument_list|)
return|;
default|default:
comment|// unreachable
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"unhandled case"
argument_list|)
throw|;
block|}
block|}
comment|/** Finds largest term accepted by this Automaton, that's    *&lt;= the provided input term.  The result is placed in    *  output; it's fine for output and input to point to    *  the same bytes.  The returned result is either the    *  provided output, or null if there is no floor term    *  (ie, the provided input term is before the first term    *  accepted by this Automaton). */
DECL|method|floor
specifier|public
name|BytesRef
name|floor
parameter_list|(
name|BytesRef
name|input
parameter_list|,
name|BytesRefBuilder
name|output
parameter_list|)
block|{
comment|//if (DEBUG) System.out.println("CA.floor input=" + input.utf8ToString());
name|int
name|state
init|=
name|runAutomaton
operator|.
name|getInitialState
argument_list|()
decl_stmt|;
comment|// Special case empty string:
if|if
condition|(
name|input
operator|.
name|length
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|runAutomaton
operator|.
name|isAccept
argument_list|(
name|state
argument_list|)
condition|)
block|{
name|output
operator|.
name|clear
argument_list|()
expr_stmt|;
return|return
name|output
operator|.
name|get
argument_list|()
return|;
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
specifier|final
name|List
argument_list|<
name|Integer
argument_list|>
name|stack
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|int
name|idx
init|=
literal|0
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|int
name|label
init|=
name|input
operator|.
name|bytes
index|[
name|input
operator|.
name|offset
operator|+
name|idx
index|]
operator|&
literal|0xff
decl_stmt|;
name|int
name|nextState
init|=
name|runAutomaton
operator|.
name|step
argument_list|(
name|state
argument_list|,
name|label
argument_list|)
decl_stmt|;
comment|//if (DEBUG) System.out.println("  cycle label=" + (char) label + " nextState=" + nextState);
if|if
condition|(
name|idx
operator|==
name|input
operator|.
name|length
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|nextState
operator|!=
operator|-
literal|1
operator|&&
name|runAutomaton
operator|.
name|isAccept
argument_list|(
name|nextState
argument_list|)
condition|)
block|{
comment|// Input string is accepted
name|output
operator|.
name|grow
argument_list|(
literal|1
operator|+
name|idx
argument_list|)
expr_stmt|;
name|output
operator|.
name|setByteAt
argument_list|(
name|idx
argument_list|,
operator|(
name|byte
operator|)
name|label
argument_list|)
expr_stmt|;
name|output
operator|.
name|setLength
argument_list|(
name|input
operator|.
name|length
argument_list|)
expr_stmt|;
comment|//if (DEBUG) System.out.println("  input is accepted; return term=" + output.utf8ToString());
return|return
name|output
operator|.
name|get
argument_list|()
return|;
block|}
else|else
block|{
name|nextState
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|nextState
operator|==
operator|-
literal|1
condition|)
block|{
comment|// Pop back to a state that has a transition
comment|//<= our label:
while|while
condition|(
literal|true
condition|)
block|{
name|int
name|numTransitions
init|=
name|automaton
operator|.
name|getNumTransitions
argument_list|(
name|state
argument_list|)
decl_stmt|;
if|if
condition|(
name|numTransitions
operator|==
literal|0
condition|)
block|{
assert|assert
name|runAutomaton
operator|.
name|isAccept
argument_list|(
name|state
argument_list|)
assert|;
name|output
operator|.
name|setLength
argument_list|(
name|idx
argument_list|)
expr_stmt|;
comment|//if (DEBUG) System.out.println("  return " + output.utf8ToString());
return|return
name|output
operator|.
name|get
argument_list|()
return|;
block|}
else|else
block|{
name|automaton
operator|.
name|getTransition
argument_list|(
name|state
argument_list|,
literal|0
argument_list|,
name|transition
argument_list|)
expr_stmt|;
if|if
condition|(
name|label
operator|-
literal|1
operator|<
name|transition
operator|.
name|min
condition|)
block|{
if|if
condition|(
name|runAutomaton
operator|.
name|isAccept
argument_list|(
name|state
argument_list|)
condition|)
block|{
name|output
operator|.
name|setLength
argument_list|(
name|idx
argument_list|)
expr_stmt|;
comment|//if (DEBUG) System.out.println("  return " + output.utf8ToString());
return|return
name|output
operator|.
name|get
argument_list|()
return|;
block|}
comment|// pop
if|if
condition|(
name|stack
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
comment|//if (DEBUG) System.out.println("  pop ord=" + idx + " return null");
return|return
literal|null
return|;
block|}
else|else
block|{
name|state
operator|=
name|stack
operator|.
name|remove
argument_list|(
name|stack
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
name|idx
operator|--
expr_stmt|;
comment|//if (DEBUG) System.out.println("  pop ord=" + (idx+1) + " label=" + (char) label + " first trans.min=" + (char) transitions[0].min);
name|label
operator|=
name|input
operator|.
name|bytes
index|[
name|input
operator|.
name|offset
operator|+
name|idx
index|]
operator|&
literal|0xff
expr_stmt|;
block|}
block|}
else|else
block|{
comment|//if (DEBUG) System.out.println("  stop pop ord=" + idx + " first trans.min=" + (char) transitions[0].min);
break|break;
block|}
block|}
block|}
comment|//if (DEBUG) System.out.println("  label=" + (char) label + " idx=" + idx);
return|return
name|addTail
argument_list|(
name|state
argument_list|,
name|output
argument_list|,
name|idx
argument_list|,
name|label
argument_list|)
return|;
block|}
else|else
block|{
name|output
operator|.
name|grow
argument_list|(
literal|1
operator|+
name|idx
argument_list|)
expr_stmt|;
name|output
operator|.
name|setByteAt
argument_list|(
name|idx
argument_list|,
operator|(
name|byte
operator|)
name|label
argument_list|)
expr_stmt|;
name|stack
operator|.
name|add
argument_list|(
name|state
argument_list|)
expr_stmt|;
name|state
operator|=
name|nextState
expr_stmt|;
name|idx
operator|++
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|Override
DECL|method|hashCode
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
specifier|final
name|int
name|prime
init|=
literal|31
decl_stmt|;
name|int
name|result
init|=
literal|1
decl_stmt|;
name|result
operator|=
name|prime
operator|*
name|result
operator|+
operator|(
operator|(
name|runAutomaton
operator|==
literal|null
operator|)
condition|?
literal|0
else|:
name|runAutomaton
operator|.
name|hashCode
argument_list|()
operator|)
expr_stmt|;
name|result
operator|=
name|prime
operator|*
name|result
operator|+
operator|(
operator|(
name|term
operator|==
literal|null
operator|)
condition|?
literal|0
else|:
name|term
operator|.
name|hashCode
argument_list|()
operator|)
expr_stmt|;
name|result
operator|=
name|prime
operator|*
name|result
operator|+
operator|(
operator|(
name|type
operator|==
literal|null
operator|)
condition|?
literal|0
else|:
name|type
operator|.
name|hashCode
argument_list|()
operator|)
expr_stmt|;
return|return
name|result
return|;
block|}
annotation|@
name|Override
DECL|method|equals
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|obj
parameter_list|)
block|{
if|if
condition|(
name|this
operator|==
name|obj
condition|)
return|return
literal|true
return|;
if|if
condition|(
name|obj
operator|==
literal|null
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|getClass
argument_list|()
operator|!=
name|obj
operator|.
name|getClass
argument_list|()
condition|)
return|return
literal|false
return|;
name|CompiledAutomaton
name|other
init|=
operator|(
name|CompiledAutomaton
operator|)
name|obj
decl_stmt|;
if|if
condition|(
name|type
operator|!=
name|other
operator|.
name|type
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|type
operator|==
name|AUTOMATON_TYPE
operator|.
name|SINGLE
condition|)
block|{
if|if
condition|(
operator|!
name|term
operator|.
name|equals
argument_list|(
name|other
operator|.
name|term
argument_list|)
condition|)
return|return
literal|false
return|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|AUTOMATON_TYPE
operator|.
name|NORMAL
condition|)
block|{
if|if
condition|(
operator|!
name|runAutomaton
operator|.
name|equals
argument_list|(
name|other
operator|.
name|runAutomaton
argument_list|)
condition|)
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
block|}
end_class
end_unit
