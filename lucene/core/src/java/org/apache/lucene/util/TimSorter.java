begin_unit
begin_package
DECL|package|org.apache.lucene.util
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
package|;
end_package
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import
begin_comment
comment|/**  * {@link Sorter} implementation based on the  *<a href="http://svn.python.org/projects/python/trunk/Objects/listsort.txt">TimSort</a>  * algorithm.  *<p>This implementation is especially good at sorting partially-sorted  * arrays and sorts small arrays with binary sort.  *<p><b>NOTE</b>:There are a few differences with the original implementation:<ul>  *<li><a name="maxTempSlots"></a>The extra amount of memory to perform merges is  * configurable. This allows small merges to be very fast while large merges  * will be performed in-place (slightly slower). You can make sure that the  * fast merge routine will always be used by having<code>maxTempSlots</code>  * equal to half of the length of the slice of data to sort.  *<li>Only the fast merge routine can gallop (the one that doesn't run  * in-place) and it only gallops on the longest slice.  *</ul>  * @lucene.internal  */
end_comment
begin_class
DECL|class|TimSorter
specifier|public
specifier|abstract
class|class
name|TimSorter
extends|extends
name|Sorter
block|{
DECL|field|MINRUN
specifier|static
specifier|final
name|int
name|MINRUN
init|=
literal|32
decl_stmt|;
DECL|field|THRESHOLD
specifier|static
specifier|final
name|int
name|THRESHOLD
init|=
literal|64
decl_stmt|;
DECL|field|STACKSIZE
specifier|static
specifier|final
name|int
name|STACKSIZE
init|=
literal|49
decl_stmt|;
comment|// depends on MINRUN
DECL|field|MIN_GALLOP
specifier|static
specifier|final
name|int
name|MIN_GALLOP
init|=
literal|7
decl_stmt|;
DECL|field|maxTempSlots
specifier|final
name|int
name|maxTempSlots
decl_stmt|;
DECL|field|minRun
name|int
name|minRun
decl_stmt|;
DECL|field|to
name|int
name|to
decl_stmt|;
DECL|field|stackSize
name|int
name|stackSize
decl_stmt|;
DECL|field|runEnds
name|int
index|[]
name|runEnds
decl_stmt|;
comment|/**    * Create a new {@link TimSorter}.    * @param maxTempSlots the<a href="#maxTempSlots">maximum amount of extra memory to run merges</a>    */
DECL|method|TimSorter
specifier|protected
name|TimSorter
parameter_list|(
name|int
name|maxTempSlots
parameter_list|)
block|{
name|super
argument_list|()
expr_stmt|;
name|runEnds
operator|=
operator|new
name|int
index|[
literal|1
operator|+
name|STACKSIZE
index|]
expr_stmt|;
name|this
operator|.
name|maxTempSlots
operator|=
name|maxTempSlots
expr_stmt|;
block|}
comment|/** Minimum run length for an array of length<code>length</code>. */
DECL|method|minRun
specifier|static
name|int
name|minRun
parameter_list|(
name|int
name|length
parameter_list|)
block|{
assert|assert
name|length
operator|>=
name|MINRUN
assert|;
name|int
name|n
init|=
name|length
decl_stmt|;
name|int
name|r
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|n
operator|>=
literal|64
condition|)
block|{
name|r
operator||=
name|n
operator|&
literal|1
expr_stmt|;
name|n
operator|>>>=
literal|1
expr_stmt|;
block|}
specifier|final
name|int
name|minRun
init|=
name|n
operator|+
name|r
decl_stmt|;
assert|assert
name|minRun
operator|>=
name|MINRUN
operator|&&
name|minRun
operator|<=
name|THRESHOLD
assert|;
return|return
name|minRun
return|;
block|}
DECL|method|runLen
name|int
name|runLen
parameter_list|(
name|int
name|i
parameter_list|)
block|{
specifier|final
name|int
name|off
init|=
name|stackSize
operator|-
name|i
decl_stmt|;
return|return
name|runEnds
index|[
name|off
index|]
operator|-
name|runEnds
index|[
name|off
operator|-
literal|1
index|]
return|;
block|}
DECL|method|runBase
name|int
name|runBase
parameter_list|(
name|int
name|i
parameter_list|)
block|{
return|return
name|runEnds
index|[
name|stackSize
operator|-
name|i
operator|-
literal|1
index|]
return|;
block|}
DECL|method|runEnd
name|int
name|runEnd
parameter_list|(
name|int
name|i
parameter_list|)
block|{
return|return
name|runEnds
index|[
name|stackSize
operator|-
name|i
index|]
return|;
block|}
DECL|method|setRunEnd
name|void
name|setRunEnd
parameter_list|(
name|int
name|i
parameter_list|,
name|int
name|runEnd
parameter_list|)
block|{
name|runEnds
index|[
name|stackSize
operator|-
name|i
index|]
operator|=
name|runEnd
expr_stmt|;
block|}
DECL|method|pushRunLen
name|void
name|pushRunLen
parameter_list|(
name|int
name|len
parameter_list|)
block|{
name|runEnds
index|[
name|stackSize
operator|+
literal|1
index|]
operator|=
name|runEnds
index|[
name|stackSize
index|]
operator|+
name|len
expr_stmt|;
operator|++
name|stackSize
expr_stmt|;
block|}
comment|/** Compute the length of the next run, make the run sorted and return its    *  length. */
DECL|method|nextRun
name|int
name|nextRun
parameter_list|()
block|{
specifier|final
name|int
name|runBase
init|=
name|runEnd
argument_list|(
literal|0
argument_list|)
decl_stmt|;
assert|assert
name|runBase
operator|<
name|to
assert|;
if|if
condition|(
name|runBase
operator|==
name|to
operator|-
literal|1
condition|)
block|{
return|return
literal|1
return|;
block|}
name|int
name|o
init|=
name|runBase
operator|+
literal|2
decl_stmt|;
if|if
condition|(
name|compare
argument_list|(
name|runBase
argument_list|,
name|runBase
operator|+
literal|1
argument_list|)
operator|>
literal|0
condition|)
block|{
comment|// run must be strictly descending
while|while
condition|(
name|o
operator|<
name|to
operator|&&
name|compare
argument_list|(
name|o
operator|-
literal|1
argument_list|,
name|o
argument_list|)
operator|>
literal|0
condition|)
block|{
operator|++
name|o
expr_stmt|;
block|}
name|reverse
argument_list|(
name|runBase
argument_list|,
name|o
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// run must be non-descending
while|while
condition|(
name|o
operator|<
name|to
operator|&&
name|compare
argument_list|(
name|o
operator|-
literal|1
argument_list|,
name|o
argument_list|)
operator|<=
literal|0
condition|)
block|{
operator|++
name|o
expr_stmt|;
block|}
block|}
specifier|final
name|int
name|runHi
init|=
name|Math
operator|.
name|max
argument_list|(
name|o
argument_list|,
name|Math
operator|.
name|min
argument_list|(
name|to
argument_list|,
name|runBase
operator|+
name|minRun
argument_list|)
argument_list|)
decl_stmt|;
name|binarySort
argument_list|(
name|runBase
argument_list|,
name|runHi
argument_list|,
name|o
argument_list|)
expr_stmt|;
return|return
name|runHi
operator|-
name|runBase
return|;
block|}
DECL|method|ensureInvariants
name|void
name|ensureInvariants
parameter_list|()
block|{
while|while
condition|(
name|stackSize
operator|>
literal|1
condition|)
block|{
specifier|final
name|int
name|runLen0
init|=
name|runLen
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|int
name|runLen1
init|=
name|runLen
argument_list|(
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|stackSize
operator|>
literal|2
condition|)
block|{
specifier|final
name|int
name|runLen2
init|=
name|runLen
argument_list|(
literal|2
argument_list|)
decl_stmt|;
if|if
condition|(
name|runLen2
operator|<=
name|runLen1
operator|+
name|runLen0
condition|)
block|{
comment|// merge the smaller of 0 and 2 with 1
if|if
condition|(
name|runLen2
operator|<
name|runLen0
condition|)
block|{
name|mergeAt
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mergeAt
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
block|}
if|if
condition|(
name|runLen1
operator|<=
name|runLen0
condition|)
block|{
name|mergeAt
argument_list|(
literal|0
argument_list|)
expr_stmt|;
continue|continue;
block|}
break|break;
block|}
block|}
DECL|method|exhaustStack
name|void
name|exhaustStack
parameter_list|()
block|{
while|while
condition|(
name|stackSize
operator|>
literal|1
condition|)
block|{
name|mergeAt
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|reset
name|void
name|reset
parameter_list|(
name|int
name|from
parameter_list|,
name|int
name|to
parameter_list|)
block|{
name|stackSize
operator|=
literal|0
expr_stmt|;
name|Arrays
operator|.
name|fill
argument_list|(
name|runEnds
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|runEnds
index|[
literal|0
index|]
operator|=
name|from
expr_stmt|;
name|this
operator|.
name|to
operator|=
name|to
expr_stmt|;
specifier|final
name|int
name|length
init|=
name|to
operator|-
name|from
decl_stmt|;
name|this
operator|.
name|minRun
operator|=
name|length
operator|<=
name|THRESHOLD
condition|?
name|length
else|:
name|minRun
argument_list|(
name|length
argument_list|)
expr_stmt|;
block|}
DECL|method|mergeAt
name|void
name|mergeAt
parameter_list|(
name|int
name|n
parameter_list|)
block|{
assert|assert
name|stackSize
operator|>=
literal|2
assert|;
name|merge
argument_list|(
name|runBase
argument_list|(
name|n
operator|+
literal|1
argument_list|)
argument_list|,
name|runBase
argument_list|(
name|n
argument_list|)
argument_list|,
name|runEnd
argument_list|(
name|n
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|j
init|=
name|n
operator|+
literal|1
init|;
name|j
operator|>
literal|0
condition|;
operator|--
name|j
control|)
block|{
name|setRunEnd
argument_list|(
name|j
argument_list|,
name|runEnd
argument_list|(
name|j
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|--
name|stackSize
expr_stmt|;
block|}
DECL|method|merge
name|void
name|merge
parameter_list|(
name|int
name|lo
parameter_list|,
name|int
name|mid
parameter_list|,
name|int
name|hi
parameter_list|)
block|{
if|if
condition|(
name|compare
argument_list|(
name|mid
operator|-
literal|1
argument_list|,
name|mid
argument_list|)
operator|<=
literal|0
condition|)
block|{
return|return;
block|}
name|lo
operator|=
name|upper2
argument_list|(
name|lo
argument_list|,
name|mid
argument_list|,
name|mid
argument_list|)
expr_stmt|;
name|hi
operator|=
name|lower2
argument_list|(
name|mid
argument_list|,
name|hi
argument_list|,
name|mid
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|hi
operator|-
name|mid
operator|<=
name|mid
operator|-
name|lo
operator|&&
name|hi
operator|-
name|mid
operator|<=
name|maxTempSlots
condition|)
block|{
name|mergeHi
argument_list|(
name|lo
argument_list|,
name|mid
argument_list|,
name|hi
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mid
operator|-
name|lo
operator|<=
name|maxTempSlots
condition|)
block|{
name|mergeLo
argument_list|(
name|lo
argument_list|,
name|mid
argument_list|,
name|hi
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mergeInPlace
argument_list|(
name|lo
argument_list|,
name|mid
argument_list|,
name|hi
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|sort
specifier|public
name|void
name|sort
parameter_list|(
name|int
name|from
parameter_list|,
name|int
name|to
parameter_list|)
block|{
name|checkRange
argument_list|(
name|from
argument_list|,
name|to
argument_list|)
expr_stmt|;
if|if
condition|(
name|to
operator|-
name|from
operator|<=
literal|1
condition|)
block|{
return|return;
block|}
name|reset
argument_list|(
name|from
argument_list|,
name|to
argument_list|)
expr_stmt|;
do|do
block|{
name|ensureInvariants
argument_list|()
expr_stmt|;
name|pushRunLen
argument_list|(
name|nextRun
argument_list|()
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|runEnd
argument_list|(
literal|0
argument_list|)
operator|<
name|to
condition|)
do|;
name|exhaustStack
argument_list|()
expr_stmt|;
assert|assert
name|runEnd
argument_list|(
literal|0
argument_list|)
operator|==
name|to
assert|;
block|}
annotation|@
name|Override
DECL|method|doRotate
name|void
name|doRotate
parameter_list|(
name|int
name|lo
parameter_list|,
name|int
name|mid
parameter_list|,
name|int
name|hi
parameter_list|)
block|{
specifier|final
name|int
name|len1
init|=
name|mid
operator|-
name|lo
decl_stmt|;
specifier|final
name|int
name|len2
init|=
name|hi
operator|-
name|mid
decl_stmt|;
if|if
condition|(
name|len1
operator|==
name|len2
condition|)
block|{
while|while
condition|(
name|mid
operator|<
name|hi
condition|)
block|{
name|swap
argument_list|(
name|lo
operator|++
argument_list|,
name|mid
operator|++
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|len2
operator|<
name|len1
operator|&&
name|len2
operator|<=
name|maxTempSlots
condition|)
block|{
name|save
argument_list|(
name|mid
argument_list|,
name|len2
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
name|lo
operator|+
name|len1
operator|-
literal|1
init|,
name|j
init|=
name|hi
operator|-
literal|1
init|;
name|i
operator|>=
name|lo
condition|;
operator|--
name|i
operator|,
operator|--
name|j
control|)
block|{
name|copy
argument_list|(
name|i
argument_list|,
name|j
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|,
name|j
init|=
name|lo
init|;
name|i
operator|<
name|len2
condition|;
operator|++
name|i
operator|,
operator|++
name|j
control|)
block|{
name|restore
argument_list|(
name|i
argument_list|,
name|j
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|len1
operator|<=
name|maxTempSlots
condition|)
block|{
name|save
argument_list|(
name|lo
argument_list|,
name|len1
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
name|mid
init|,
name|j
init|=
name|lo
init|;
name|i
operator|<
name|hi
condition|;
operator|++
name|i
operator|,
operator|++
name|j
control|)
block|{
name|copy
argument_list|(
name|i
argument_list|,
name|j
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|,
name|j
init|=
name|lo
operator|+
name|len2
init|;
name|j
operator|<
name|hi
condition|;
operator|++
name|i
operator|,
operator|++
name|j
control|)
block|{
name|restore
argument_list|(
name|i
argument_list|,
name|j
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|reverse
argument_list|(
name|lo
argument_list|,
name|mid
argument_list|)
expr_stmt|;
name|reverse
argument_list|(
name|mid
argument_list|,
name|hi
argument_list|)
expr_stmt|;
name|reverse
argument_list|(
name|lo
argument_list|,
name|hi
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|mergeLo
name|void
name|mergeLo
parameter_list|(
name|int
name|lo
parameter_list|,
name|int
name|mid
parameter_list|,
name|int
name|hi
parameter_list|)
block|{
assert|assert
name|compare
argument_list|(
name|lo
argument_list|,
name|mid
argument_list|)
operator|>
literal|0
assert|;
name|int
name|len1
init|=
name|mid
operator|-
name|lo
decl_stmt|;
name|save
argument_list|(
name|lo
argument_list|,
name|len1
argument_list|)
expr_stmt|;
name|copy
argument_list|(
name|mid
argument_list|,
name|lo
argument_list|)
expr_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|,
name|j
init|=
name|mid
operator|+
literal|1
decl_stmt|,
name|dest
init|=
name|lo
operator|+
literal|1
decl_stmt|;
name|outer
label|:
for|for
control|(
init|;
condition|;
control|)
block|{
for|for
control|(
name|int
name|count
init|=
literal|0
init|;
name|count
operator|<
name|MIN_GALLOP
condition|;
control|)
block|{
if|if
condition|(
name|i
operator|>=
name|len1
operator|||
name|j
operator|>=
name|hi
condition|)
block|{
break|break
name|outer
break|;
block|}
elseif|else
if|if
condition|(
name|compareSaved
argument_list|(
name|i
argument_list|,
name|j
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|restore
argument_list|(
name|i
operator|++
argument_list|,
name|dest
operator|++
argument_list|)
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|copy
argument_list|(
name|j
operator|++
argument_list|,
name|dest
operator|++
argument_list|)
expr_stmt|;
operator|++
name|count
expr_stmt|;
block|}
block|}
comment|// galloping...
name|int
name|next
init|=
name|lowerSaved3
argument_list|(
name|j
argument_list|,
name|hi
argument_list|,
name|i
argument_list|)
decl_stmt|;
for|for
control|(
init|;
name|j
operator|<
name|next
condition|;
operator|++
name|dest
control|)
block|{
name|copy
argument_list|(
name|j
operator|++
argument_list|,
name|dest
argument_list|)
expr_stmt|;
block|}
name|restore
argument_list|(
name|i
operator|++
argument_list|,
name|dest
operator|++
argument_list|)
expr_stmt|;
block|}
for|for
control|(
init|;
name|i
operator|<
name|len1
condition|;
operator|++
name|dest
control|)
block|{
name|restore
argument_list|(
name|i
operator|++
argument_list|,
name|dest
argument_list|)
expr_stmt|;
block|}
assert|assert
name|j
operator|==
name|dest
assert|;
block|}
DECL|method|mergeHi
name|void
name|mergeHi
parameter_list|(
name|int
name|lo
parameter_list|,
name|int
name|mid
parameter_list|,
name|int
name|hi
parameter_list|)
block|{
assert|assert
name|compare
argument_list|(
name|mid
operator|-
literal|1
argument_list|,
name|hi
operator|-
literal|1
argument_list|)
operator|>
literal|0
assert|;
name|int
name|len2
init|=
name|hi
operator|-
name|mid
decl_stmt|;
name|save
argument_list|(
name|mid
argument_list|,
name|len2
argument_list|)
expr_stmt|;
name|copy
argument_list|(
name|mid
operator|-
literal|1
argument_list|,
name|hi
operator|-
literal|1
argument_list|)
expr_stmt|;
name|int
name|i
init|=
name|mid
operator|-
literal|2
decl_stmt|,
name|j
init|=
name|len2
operator|-
literal|1
decl_stmt|,
name|dest
init|=
name|hi
operator|-
literal|2
decl_stmt|;
name|outer
label|:
for|for
control|(
init|;
condition|;
control|)
block|{
for|for
control|(
name|int
name|count
init|=
literal|0
init|;
name|count
operator|<
name|MIN_GALLOP
condition|;
control|)
block|{
if|if
condition|(
name|i
operator|<
name|lo
operator|||
name|j
operator|<
literal|0
condition|)
block|{
break|break
name|outer
break|;
block|}
elseif|else
if|if
condition|(
name|compareSaved
argument_list|(
name|j
argument_list|,
name|i
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|restore
argument_list|(
name|j
operator|--
argument_list|,
name|dest
operator|--
argument_list|)
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|copy
argument_list|(
name|i
operator|--
argument_list|,
name|dest
operator|--
argument_list|)
expr_stmt|;
operator|++
name|count
expr_stmt|;
block|}
block|}
comment|// galloping
name|int
name|next
init|=
name|upperSaved3
argument_list|(
name|lo
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|j
argument_list|)
decl_stmt|;
while|while
condition|(
name|i
operator|>=
name|next
condition|)
block|{
name|copy
argument_list|(
name|i
operator|--
argument_list|,
name|dest
operator|--
argument_list|)
expr_stmt|;
block|}
name|restore
argument_list|(
name|j
operator|--
argument_list|,
name|dest
operator|--
argument_list|)
expr_stmt|;
block|}
for|for
control|(
init|;
name|j
operator|>=
literal|0
condition|;
operator|--
name|dest
control|)
block|{
name|restore
argument_list|(
name|j
operator|--
argument_list|,
name|dest
argument_list|)
expr_stmt|;
block|}
assert|assert
name|i
operator|==
name|dest
assert|;
block|}
DECL|method|lowerSaved
name|int
name|lowerSaved
parameter_list|(
name|int
name|from
parameter_list|,
name|int
name|to
parameter_list|,
name|int
name|val
parameter_list|)
block|{
name|int
name|len
init|=
name|to
operator|-
name|from
decl_stmt|;
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
specifier|final
name|int
name|half
init|=
name|len
operator|>>>
literal|1
decl_stmt|;
specifier|final
name|int
name|mid
init|=
name|from
operator|+
name|half
decl_stmt|;
if|if
condition|(
name|compareSaved
argument_list|(
name|val
argument_list|,
name|mid
argument_list|)
operator|>
literal|0
condition|)
block|{
name|from
operator|=
name|mid
operator|+
literal|1
expr_stmt|;
name|len
operator|=
name|len
operator|-
name|half
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|len
operator|=
name|half
expr_stmt|;
block|}
block|}
return|return
name|from
return|;
block|}
DECL|method|upperSaved
name|int
name|upperSaved
parameter_list|(
name|int
name|from
parameter_list|,
name|int
name|to
parameter_list|,
name|int
name|val
parameter_list|)
block|{
name|int
name|len
init|=
name|to
operator|-
name|from
decl_stmt|;
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
specifier|final
name|int
name|half
init|=
name|len
operator|>>>
literal|1
decl_stmt|;
specifier|final
name|int
name|mid
init|=
name|from
operator|+
name|half
decl_stmt|;
if|if
condition|(
name|compareSaved
argument_list|(
name|val
argument_list|,
name|mid
argument_list|)
operator|<
literal|0
condition|)
block|{
name|len
operator|=
name|half
expr_stmt|;
block|}
else|else
block|{
name|from
operator|=
name|mid
operator|+
literal|1
expr_stmt|;
name|len
operator|=
name|len
operator|-
name|half
operator|-
literal|1
expr_stmt|;
block|}
block|}
return|return
name|from
return|;
block|}
comment|// faster than lowerSaved when val is at the beginning of [from:to[
DECL|method|lowerSaved3
name|int
name|lowerSaved3
parameter_list|(
name|int
name|from
parameter_list|,
name|int
name|to
parameter_list|,
name|int
name|val
parameter_list|)
block|{
name|int
name|f
init|=
name|from
decl_stmt|,
name|t
init|=
name|f
operator|+
literal|1
decl_stmt|;
while|while
condition|(
name|t
operator|<
name|to
condition|)
block|{
if|if
condition|(
name|compareSaved
argument_list|(
name|val
argument_list|,
name|t
argument_list|)
operator|<=
literal|0
condition|)
block|{
return|return
name|lowerSaved
argument_list|(
name|f
argument_list|,
name|t
argument_list|,
name|val
argument_list|)
return|;
block|}
name|int
name|delta
init|=
name|t
operator|-
name|f
decl_stmt|;
name|f
operator|=
name|t
expr_stmt|;
name|t
operator|+=
name|delta
operator|<<
literal|1
expr_stmt|;
block|}
return|return
name|lowerSaved
argument_list|(
name|f
argument_list|,
name|to
argument_list|,
name|val
argument_list|)
return|;
block|}
comment|//faster than upperSaved when val is at the end of [from:to[
DECL|method|upperSaved3
name|int
name|upperSaved3
parameter_list|(
name|int
name|from
parameter_list|,
name|int
name|to
parameter_list|,
name|int
name|val
parameter_list|)
block|{
name|int
name|f
init|=
name|to
operator|-
literal|1
decl_stmt|,
name|t
init|=
name|to
decl_stmt|;
while|while
condition|(
name|f
operator|>
name|from
condition|)
block|{
if|if
condition|(
name|compareSaved
argument_list|(
name|val
argument_list|,
name|f
argument_list|)
operator|>=
literal|0
condition|)
block|{
return|return
name|upperSaved
argument_list|(
name|f
argument_list|,
name|t
argument_list|,
name|val
argument_list|)
return|;
block|}
specifier|final
name|int
name|delta
init|=
name|t
operator|-
name|f
decl_stmt|;
name|t
operator|=
name|f
expr_stmt|;
name|f
operator|-=
name|delta
operator|<<
literal|1
expr_stmt|;
block|}
return|return
name|upperSaved
argument_list|(
name|from
argument_list|,
name|t
argument_list|,
name|val
argument_list|)
return|;
block|}
comment|/** Copy data from slot<code>src</code> to slot<code>dest</code>. */
DECL|method|copy
specifier|protected
specifier|abstract
name|void
name|copy
parameter_list|(
name|int
name|src
parameter_list|,
name|int
name|dest
parameter_list|)
function_decl|;
comment|/** Save all elements between slots<code>i</code> and<code>i+len</code>    *  into the temporary storage. */
DECL|method|save
specifier|protected
specifier|abstract
name|void
name|save
parameter_list|(
name|int
name|i
parameter_list|,
name|int
name|len
parameter_list|)
function_decl|;
comment|/** Restore element<code>j</code> from the temporary storage into slot<code>i</code>. */
DECL|method|restore
specifier|protected
specifier|abstract
name|void
name|restore
parameter_list|(
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|)
function_decl|;
comment|/** Compare element<code>i</code> from the temporary storage with element    *<code>j</code> from the slice to sort, similarly to    *  {@link #compare(int, int)}. */
DECL|method|compareSaved
specifier|protected
specifier|abstract
name|int
name|compareSaved
parameter_list|(
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|)
function_decl|;
block|}
end_class
end_unit
