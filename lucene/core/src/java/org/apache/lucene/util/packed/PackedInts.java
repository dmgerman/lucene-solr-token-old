begin_unit
begin_package
DECL|package|org.apache.lucene.util.packed
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|packed
package|;
end_package
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|codecs
operator|.
name|CodecUtil
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|NumericDocValues
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|DataInput
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|DataOutput
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|IndexInput
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|Accountable
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|LongsRef
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|RamUsageEstimator
import|;
end_import
begin_comment
comment|/**  * Simplistic compression for array of unsigned long values.  * Each value is {@code>= 0} and {@code<=} a specified maximum value.  The  * values are stored as packed ints, with each value  * consuming a fixed number of bits.  *  * @lucene.internal  */
end_comment
begin_class
DECL|class|PackedInts
specifier|public
class|class
name|PackedInts
block|{
comment|/**    * At most 700% memory overhead, always select a direct implementation.    */
DECL|field|FASTEST
specifier|public
specifier|static
specifier|final
name|float
name|FASTEST
init|=
literal|7f
decl_stmt|;
comment|/**    * At most 50% memory overhead, always select a reasonably fast implementation.    */
DECL|field|FAST
specifier|public
specifier|static
specifier|final
name|float
name|FAST
init|=
literal|0.5f
decl_stmt|;
comment|/**    * At most 25% memory overhead.    */
DECL|field|DEFAULT
specifier|public
specifier|static
specifier|final
name|float
name|DEFAULT
init|=
literal|0.25f
decl_stmt|;
comment|/**    * No memory overhead at all, but the returned implementation may be slow.    */
DECL|field|COMPACT
specifier|public
specifier|static
specifier|final
name|float
name|COMPACT
init|=
literal|0f
decl_stmt|;
comment|/**    * Default amount of memory to use for bulk operations.    */
DECL|field|DEFAULT_BUFFER_SIZE
specifier|public
specifier|static
specifier|final
name|int
name|DEFAULT_BUFFER_SIZE
init|=
literal|1024
decl_stmt|;
comment|// 1K
DECL|field|CODEC_NAME
specifier|public
specifier|final
specifier|static
name|String
name|CODEC_NAME
init|=
literal|"PackedInts"
decl_stmt|;
DECL|field|VERSION_MONOTONIC_WITHOUT_ZIGZAG
specifier|public
specifier|static
specifier|final
name|int
name|VERSION_MONOTONIC_WITHOUT_ZIGZAG
init|=
literal|2
decl_stmt|;
DECL|field|VERSION_START
specifier|public
specifier|final
specifier|static
name|int
name|VERSION_START
init|=
name|VERSION_MONOTONIC_WITHOUT_ZIGZAG
decl_stmt|;
DECL|field|VERSION_CURRENT
specifier|public
specifier|final
specifier|static
name|int
name|VERSION_CURRENT
init|=
name|VERSION_MONOTONIC_WITHOUT_ZIGZAG
decl_stmt|;
comment|/**    * Check the validity of a version number.    */
DECL|method|checkVersion
specifier|public
specifier|static
name|void
name|checkVersion
parameter_list|(
name|int
name|version
parameter_list|)
block|{
if|if
condition|(
name|version
operator|<
name|VERSION_START
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Version is too old, should be at least "
operator|+
name|VERSION_START
operator|+
literal|" (got "
operator|+
name|version
operator|+
literal|")"
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
name|version
operator|>
name|VERSION_CURRENT
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Version is too new, should be at most "
operator|+
name|VERSION_CURRENT
operator|+
literal|" (got "
operator|+
name|version
operator|+
literal|")"
argument_list|)
throw|;
block|}
block|}
comment|/**    * A format to write packed ints.    *    * @lucene.internal    */
DECL|enum|Format
specifier|public
enum|enum
name|Format
block|{
comment|/**      * Compact format, all bits are written contiguously.      */
DECL|enum constant|PACKED
name|PACKED
argument_list|(
literal|0
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|long
name|byteCount
parameter_list|(
name|int
name|packedIntsVersion
parameter_list|,
name|int
name|valueCount
parameter_list|,
name|int
name|bitsPerValue
parameter_list|)
block|{
return|return
operator|(
name|long
operator|)
name|Math
operator|.
name|ceil
argument_list|(
operator|(
name|double
operator|)
name|valueCount
operator|*
name|bitsPerValue
operator|/
literal|8
argument_list|)
return|;
block|}
block|}
block|,
comment|/**      * A format that may insert padding bits to improve encoding and decoding      * speed. Since this format doesn't support all possible bits per value, you      * should never use it directly, but rather use      * {@link PackedInts#fastestFormatAndBits(int, int, float)} to find the      * format that best suits your needs.      */
DECL|enum constant|PACKED_SINGLE_BLOCK
name|PACKED_SINGLE_BLOCK
argument_list|(
literal|1
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|int
name|longCount
parameter_list|(
name|int
name|packedIntsVersion
parameter_list|,
name|int
name|valueCount
parameter_list|,
name|int
name|bitsPerValue
parameter_list|)
block|{
specifier|final
name|int
name|valuesPerBlock
init|=
literal|64
operator|/
name|bitsPerValue
decl_stmt|;
return|return
operator|(
name|int
operator|)
name|Math
operator|.
name|ceil
argument_list|(
operator|(
name|double
operator|)
name|valueCount
operator|/
name|valuesPerBlock
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|isSupported
parameter_list|(
name|int
name|bitsPerValue
parameter_list|)
block|{
return|return
name|Packed64SingleBlock
operator|.
name|isSupported
argument_list|(
name|bitsPerValue
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|float
name|overheadPerValue
parameter_list|(
name|int
name|bitsPerValue
parameter_list|)
block|{
assert|assert
name|isSupported
argument_list|(
name|bitsPerValue
argument_list|)
assert|;
specifier|final
name|int
name|valuesPerBlock
init|=
literal|64
operator|/
name|bitsPerValue
decl_stmt|;
specifier|final
name|int
name|overhead
init|=
literal|64
operator|%
name|bitsPerValue
decl_stmt|;
return|return
operator|(
name|float
operator|)
name|overhead
operator|/
name|valuesPerBlock
return|;
block|}
block|}
block|;
comment|/**      * Get a format according to its ID.      */
DECL|method|byId
specifier|public
specifier|static
name|Format
name|byId
parameter_list|(
name|int
name|id
parameter_list|)
block|{
for|for
control|(
name|Format
name|format
range|:
name|Format
operator|.
name|values
argument_list|()
control|)
block|{
if|if
condition|(
name|format
operator|.
name|getId
argument_list|()
operator|==
name|id
condition|)
block|{
return|return
name|format
return|;
block|}
block|}
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Unknown format id: "
operator|+
name|id
argument_list|)
throw|;
block|}
DECL|method|Format
specifier|private
name|Format
parameter_list|(
name|int
name|id
parameter_list|)
block|{
name|this
operator|.
name|id
operator|=
name|id
expr_stmt|;
block|}
DECL|field|id
specifier|public
name|int
name|id
decl_stmt|;
comment|/**      * Returns the ID of the format.      */
DECL|method|getId
specifier|public
name|int
name|getId
parameter_list|()
block|{
return|return
name|id
return|;
block|}
comment|/**      * Computes how many byte blocks are needed to store<code>values</code>      * values of size<code>bitsPerValue</code>.      */
DECL|method|byteCount
specifier|public
name|long
name|byteCount
parameter_list|(
name|int
name|packedIntsVersion
parameter_list|,
name|int
name|valueCount
parameter_list|,
name|int
name|bitsPerValue
parameter_list|)
block|{
assert|assert
name|bitsPerValue
operator|>=
literal|0
operator|&&
name|bitsPerValue
operator|<=
literal|64
operator|:
name|bitsPerValue
assert|;
comment|// assume long-aligned
return|return
literal|8L
operator|*
name|longCount
argument_list|(
name|packedIntsVersion
argument_list|,
name|valueCount
argument_list|,
name|bitsPerValue
argument_list|)
return|;
block|}
comment|/**      * Computes how many long blocks are needed to store<code>values</code>      * values of size<code>bitsPerValue</code>.      */
DECL|method|longCount
specifier|public
name|int
name|longCount
parameter_list|(
name|int
name|packedIntsVersion
parameter_list|,
name|int
name|valueCount
parameter_list|,
name|int
name|bitsPerValue
parameter_list|)
block|{
assert|assert
name|bitsPerValue
operator|>=
literal|0
operator|&&
name|bitsPerValue
operator|<=
literal|64
operator|:
name|bitsPerValue
assert|;
specifier|final
name|long
name|byteCount
init|=
name|byteCount
argument_list|(
name|packedIntsVersion
argument_list|,
name|valueCount
argument_list|,
name|bitsPerValue
argument_list|)
decl_stmt|;
assert|assert
name|byteCount
operator|<
literal|8L
operator|*
name|Integer
operator|.
name|MAX_VALUE
assert|;
if|if
condition|(
operator|(
name|byteCount
operator|%
literal|8
operator|)
operator|==
literal|0
condition|)
block|{
return|return
call|(
name|int
call|)
argument_list|(
name|byteCount
operator|/
literal|8
argument_list|)
return|;
block|}
else|else
block|{
return|return
call|(
name|int
call|)
argument_list|(
name|byteCount
operator|/
literal|8
operator|+
literal|1
argument_list|)
return|;
block|}
block|}
comment|/**      * Tests whether the provided number of bits per value is supported by the      * format.      */
DECL|method|isSupported
specifier|public
name|boolean
name|isSupported
parameter_list|(
name|int
name|bitsPerValue
parameter_list|)
block|{
return|return
name|bitsPerValue
operator|>=
literal|1
operator|&&
name|bitsPerValue
operator|<=
literal|64
return|;
block|}
comment|/**      * Returns the overhead per value, in bits.      */
DECL|method|overheadPerValue
specifier|public
name|float
name|overheadPerValue
parameter_list|(
name|int
name|bitsPerValue
parameter_list|)
block|{
assert|assert
name|isSupported
argument_list|(
name|bitsPerValue
argument_list|)
assert|;
return|return
literal|0f
return|;
block|}
comment|/**      * Returns the overhead ratio (<code>overhead per value / bits per value</code>).      */
DECL|method|overheadRatio
specifier|public
specifier|final
name|float
name|overheadRatio
parameter_list|(
name|int
name|bitsPerValue
parameter_list|)
block|{
assert|assert
name|isSupported
argument_list|(
name|bitsPerValue
argument_list|)
assert|;
return|return
name|overheadPerValue
argument_list|(
name|bitsPerValue
argument_list|)
operator|/
name|bitsPerValue
return|;
block|}
block|}
comment|/**    * Simple class that holds a format and a number of bits per value.    */
DECL|class|FormatAndBits
specifier|public
specifier|static
class|class
name|FormatAndBits
block|{
DECL|field|format
specifier|public
specifier|final
name|Format
name|format
decl_stmt|;
DECL|field|bitsPerValue
specifier|public
specifier|final
name|int
name|bitsPerValue
decl_stmt|;
DECL|method|FormatAndBits
specifier|public
name|FormatAndBits
parameter_list|(
name|Format
name|format
parameter_list|,
name|int
name|bitsPerValue
parameter_list|)
block|{
name|this
operator|.
name|format
operator|=
name|format
expr_stmt|;
name|this
operator|.
name|bitsPerValue
operator|=
name|bitsPerValue
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"FormatAndBits(format="
operator|+
name|format
operator|+
literal|" bitsPerValue="
operator|+
name|bitsPerValue
operator|+
literal|")"
return|;
block|}
block|}
comment|/**    * Try to find the {@link Format} and number of bits per value that would    * restore from disk the fastest reader whose overhead is less than    *<code>acceptableOverheadRatio</code>.    *<p>    * The<code>acceptableOverheadRatio</code> parameter makes sense for    * random-access {@link Reader}s. In case you only plan to perform    * sequential access on this stream later on, you should probably use    * {@link PackedInts#COMPACT}.    *<p>    * If you don't know how many values you are going to write, use    *<code>valueCount = -1</code>.    */
DECL|method|fastestFormatAndBits
specifier|public
specifier|static
name|FormatAndBits
name|fastestFormatAndBits
parameter_list|(
name|int
name|valueCount
parameter_list|,
name|int
name|bitsPerValue
parameter_list|,
name|float
name|acceptableOverheadRatio
parameter_list|)
block|{
if|if
condition|(
name|valueCount
operator|==
operator|-
literal|1
condition|)
block|{
name|valueCount
operator|=
name|Integer
operator|.
name|MAX_VALUE
expr_stmt|;
block|}
name|acceptableOverheadRatio
operator|=
name|Math
operator|.
name|max
argument_list|(
name|COMPACT
argument_list|,
name|acceptableOverheadRatio
argument_list|)
expr_stmt|;
name|acceptableOverheadRatio
operator|=
name|Math
operator|.
name|min
argument_list|(
name|FASTEST
argument_list|,
name|acceptableOverheadRatio
argument_list|)
expr_stmt|;
name|float
name|acceptableOverheadPerValue
init|=
name|acceptableOverheadRatio
operator|*
name|bitsPerValue
decl_stmt|;
comment|// in bits
name|int
name|maxBitsPerValue
init|=
name|bitsPerValue
operator|+
operator|(
name|int
operator|)
name|acceptableOverheadPerValue
decl_stmt|;
name|int
name|actualBitsPerValue
init|=
operator|-
literal|1
decl_stmt|;
name|Format
name|format
init|=
name|Format
operator|.
name|PACKED
decl_stmt|;
if|if
condition|(
name|bitsPerValue
operator|<=
literal|8
operator|&&
name|maxBitsPerValue
operator|>=
literal|8
condition|)
block|{
name|actualBitsPerValue
operator|=
literal|8
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bitsPerValue
operator|<=
literal|16
operator|&&
name|maxBitsPerValue
operator|>=
literal|16
condition|)
block|{
name|actualBitsPerValue
operator|=
literal|16
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bitsPerValue
operator|<=
literal|32
operator|&&
name|maxBitsPerValue
operator|>=
literal|32
condition|)
block|{
name|actualBitsPerValue
operator|=
literal|32
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bitsPerValue
operator|<=
literal|64
operator|&&
name|maxBitsPerValue
operator|>=
literal|64
condition|)
block|{
name|actualBitsPerValue
operator|=
literal|64
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|valueCount
operator|<=
name|Packed8ThreeBlocks
operator|.
name|MAX_SIZE
operator|&&
name|bitsPerValue
operator|<=
literal|24
operator|&&
name|maxBitsPerValue
operator|>=
literal|24
condition|)
block|{
name|actualBitsPerValue
operator|=
literal|24
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|valueCount
operator|<=
name|Packed16ThreeBlocks
operator|.
name|MAX_SIZE
operator|&&
name|bitsPerValue
operator|<=
literal|48
operator|&&
name|maxBitsPerValue
operator|>=
literal|48
condition|)
block|{
name|actualBitsPerValue
operator|=
literal|48
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|int
name|bpv
init|=
name|bitsPerValue
init|;
name|bpv
operator|<=
name|maxBitsPerValue
condition|;
operator|++
name|bpv
control|)
block|{
if|if
condition|(
name|Format
operator|.
name|PACKED_SINGLE_BLOCK
operator|.
name|isSupported
argument_list|(
name|bpv
argument_list|)
condition|)
block|{
name|float
name|overhead
init|=
name|Format
operator|.
name|PACKED_SINGLE_BLOCK
operator|.
name|overheadPerValue
argument_list|(
name|bpv
argument_list|)
decl_stmt|;
name|float
name|acceptableOverhead
init|=
name|acceptableOverheadPerValue
operator|+
name|bitsPerValue
operator|-
name|bpv
decl_stmt|;
if|if
condition|(
name|overhead
operator|<=
name|acceptableOverhead
condition|)
block|{
name|actualBitsPerValue
operator|=
name|bpv
expr_stmt|;
name|format
operator|=
name|Format
operator|.
name|PACKED_SINGLE_BLOCK
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|actualBitsPerValue
operator|<
literal|0
condition|)
block|{
name|actualBitsPerValue
operator|=
name|bitsPerValue
expr_stmt|;
block|}
block|}
return|return
operator|new
name|FormatAndBits
argument_list|(
name|format
argument_list|,
name|actualBitsPerValue
argument_list|)
return|;
block|}
comment|/**    * A decoder for packed integers.    */
DECL|interface|Decoder
specifier|public
specifier|static
interface|interface
name|Decoder
block|{
comment|/**      * The minimum number of long blocks to encode in a single iteration, when      * using long encoding.      */
DECL|method|longBlockCount
name|int
name|longBlockCount
parameter_list|()
function_decl|;
comment|/**      * The number of values that can be stored in {@link #longBlockCount()} long      * blocks.      */
DECL|method|longValueCount
name|int
name|longValueCount
parameter_list|()
function_decl|;
comment|/**      * The minimum number of byte blocks to encode in a single iteration, when      * using byte encoding.      */
DECL|method|byteBlockCount
name|int
name|byteBlockCount
parameter_list|()
function_decl|;
comment|/**      * The number of values that can be stored in {@link #byteBlockCount()} byte      * blocks.      */
DECL|method|byteValueCount
name|int
name|byteValueCount
parameter_list|()
function_decl|;
comment|/**      * Read<code>iterations * blockCount()</code> blocks from<code>blocks</code>,      * decode them and write<code>iterations * valueCount()</code> values into      *<code>values</code>.      *      * @param blocks       the long blocks that hold packed integer values      * @param blocksOffset the offset where to start reading blocks      * @param values       the values buffer      * @param valuesOffset the offset where to start writing values      * @param iterations   controls how much data to decode      */
DECL|method|decode
name|void
name|decode
parameter_list|(
name|long
index|[]
name|blocks
parameter_list|,
name|int
name|blocksOffset
parameter_list|,
name|long
index|[]
name|values
parameter_list|,
name|int
name|valuesOffset
parameter_list|,
name|int
name|iterations
parameter_list|)
function_decl|;
comment|/**      * Read<code>8 * iterations * blockCount()</code> blocks from<code>blocks</code>,      * decode them and write<code>iterations * valueCount()</code> values into      *<code>values</code>.      *      * @param blocks       the long blocks that hold packed integer values      * @param blocksOffset the offset where to start reading blocks      * @param values       the values buffer      * @param valuesOffset the offset where to start writing values      * @param iterations   controls how much data to decode      */
DECL|method|decode
name|void
name|decode
parameter_list|(
name|byte
index|[]
name|blocks
parameter_list|,
name|int
name|blocksOffset
parameter_list|,
name|long
index|[]
name|values
parameter_list|,
name|int
name|valuesOffset
parameter_list|,
name|int
name|iterations
parameter_list|)
function_decl|;
comment|/**      * Read<code>iterations * blockCount()</code> blocks from<code>blocks</code>,      * decode them and write<code>iterations * valueCount()</code> values into      *<code>values</code>.      *      * @param blocks       the long blocks that hold packed integer values      * @param blocksOffset the offset where to start reading blocks      * @param values       the values buffer      * @param valuesOffset the offset where to start writing values      * @param iterations   controls how much data to decode      */
DECL|method|decode
name|void
name|decode
parameter_list|(
name|long
index|[]
name|blocks
parameter_list|,
name|int
name|blocksOffset
parameter_list|,
name|int
index|[]
name|values
parameter_list|,
name|int
name|valuesOffset
parameter_list|,
name|int
name|iterations
parameter_list|)
function_decl|;
comment|/**      * Read<code>8 * iterations * blockCount()</code> blocks from<code>blocks</code>,      * decode them and write<code>iterations * valueCount()</code> values into      *<code>values</code>.      *      * @param blocks       the long blocks that hold packed integer values      * @param blocksOffset the offset where to start reading blocks      * @param values       the values buffer      * @param valuesOffset the offset where to start writing values      * @param iterations   controls how much data to decode      */
DECL|method|decode
name|void
name|decode
parameter_list|(
name|byte
index|[]
name|blocks
parameter_list|,
name|int
name|blocksOffset
parameter_list|,
name|int
index|[]
name|values
parameter_list|,
name|int
name|valuesOffset
parameter_list|,
name|int
name|iterations
parameter_list|)
function_decl|;
block|}
comment|/**    * An encoder for packed integers.    */
DECL|interface|Encoder
specifier|public
specifier|static
interface|interface
name|Encoder
block|{
comment|/**      * The minimum number of long blocks to encode in a single iteration, when      * using long encoding.      */
DECL|method|longBlockCount
name|int
name|longBlockCount
parameter_list|()
function_decl|;
comment|/**      * The number of values that can be stored in {@link #longBlockCount()} long      * blocks.      */
DECL|method|longValueCount
name|int
name|longValueCount
parameter_list|()
function_decl|;
comment|/**      * The minimum number of byte blocks to encode in a single iteration, when      * using byte encoding.      */
DECL|method|byteBlockCount
name|int
name|byteBlockCount
parameter_list|()
function_decl|;
comment|/**      * The number of values that can be stored in {@link #byteBlockCount()} byte      * blocks.      */
DECL|method|byteValueCount
name|int
name|byteValueCount
parameter_list|()
function_decl|;
comment|/**      * Read<code>iterations * valueCount()</code> values from<code>values</code>,      * encode them and write<code>iterations * blockCount()</code> blocks into      *<code>blocks</code>.      *      * @param blocks       the long blocks that hold packed integer values      * @param blocksOffset the offset where to start writing blocks      * @param values       the values buffer      * @param valuesOffset the offset where to start reading values      * @param iterations   controls how much data to encode      */
DECL|method|encode
name|void
name|encode
parameter_list|(
name|long
index|[]
name|values
parameter_list|,
name|int
name|valuesOffset
parameter_list|,
name|long
index|[]
name|blocks
parameter_list|,
name|int
name|blocksOffset
parameter_list|,
name|int
name|iterations
parameter_list|)
function_decl|;
comment|/**      * Read<code>iterations * valueCount()</code> values from<code>values</code>,      * encode them and write<code>8 * iterations * blockCount()</code> blocks into      *<code>blocks</code>.      *      * @param blocks       the long blocks that hold packed integer values      * @param blocksOffset the offset where to start writing blocks      * @param values       the values buffer      * @param valuesOffset the offset where to start reading values      * @param iterations   controls how much data to encode      */
DECL|method|encode
name|void
name|encode
parameter_list|(
name|long
index|[]
name|values
parameter_list|,
name|int
name|valuesOffset
parameter_list|,
name|byte
index|[]
name|blocks
parameter_list|,
name|int
name|blocksOffset
parameter_list|,
name|int
name|iterations
parameter_list|)
function_decl|;
comment|/**      * Read<code>iterations * valueCount()</code> values from<code>values</code>,      * encode them and write<code>iterations * blockCount()</code> blocks into      *<code>blocks</code>.      *      * @param blocks       the long blocks that hold packed integer values      * @param blocksOffset the offset where to start writing blocks      * @param values       the values buffer      * @param valuesOffset the offset where to start reading values      * @param iterations   controls how much data to encode      */
DECL|method|encode
name|void
name|encode
parameter_list|(
name|int
index|[]
name|values
parameter_list|,
name|int
name|valuesOffset
parameter_list|,
name|long
index|[]
name|blocks
parameter_list|,
name|int
name|blocksOffset
parameter_list|,
name|int
name|iterations
parameter_list|)
function_decl|;
comment|/**      * Read<code>iterations * valueCount()</code> values from<code>values</code>,      * encode them and write<code>8 * iterations * blockCount()</code> blocks into      *<code>blocks</code>.      *      * @param blocks       the long blocks that hold packed integer values      * @param blocksOffset the offset where to start writing blocks      * @param values       the values buffer      * @param valuesOffset the offset where to start reading values      * @param iterations   controls how much data to encode      */
DECL|method|encode
name|void
name|encode
parameter_list|(
name|int
index|[]
name|values
parameter_list|,
name|int
name|valuesOffset
parameter_list|,
name|byte
index|[]
name|blocks
parameter_list|,
name|int
name|blocksOffset
parameter_list|,
name|int
name|iterations
parameter_list|)
function_decl|;
block|}
comment|/**    * A read-only random access array of positive integers.    * @lucene.internal    */
DECL|class|Reader
specifier|public
specifier|static
specifier|abstract
class|class
name|Reader
extends|extends
name|NumericDocValues
implements|implements
name|Accountable
block|{
comment|/**      * Bulk get: read at least one and at most<code>len</code> longs starting      * from<code>index</code> into<code>arr[off:off+len]</code> and return      * the actual number of values that have been read.      */
DECL|method|get
specifier|public
name|int
name|get
parameter_list|(
name|int
name|index
parameter_list|,
name|long
index|[]
name|arr
parameter_list|,
name|int
name|off
parameter_list|,
name|int
name|len
parameter_list|)
block|{
assert|assert
name|len
operator|>
literal|0
operator|:
literal|"len must be> 0 (got "
operator|+
name|len
operator|+
literal|")"
assert|;
assert|assert
name|index
operator|>=
literal|0
operator|&&
name|index
operator|<
name|size
argument_list|()
assert|;
assert|assert
name|off
operator|+
name|len
operator|<=
name|arr
operator|.
name|length
assert|;
specifier|final
name|int
name|gets
init|=
name|Math
operator|.
name|min
argument_list|(
name|size
argument_list|()
operator|-
name|index
argument_list|,
name|len
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|index
init|,
name|o
init|=
name|off
init|,
name|end
init|=
name|index
operator|+
name|gets
init|;
name|i
operator|<
name|end
condition|;
operator|++
name|i
operator|,
operator|++
name|o
control|)
block|{
name|arr
index|[
name|o
index|]
operator|=
name|get
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
return|return
name|gets
return|;
block|}
comment|/**      * @return the number of values.      */
DECL|method|size
specifier|public
specifier|abstract
name|int
name|size
parameter_list|()
function_decl|;
block|}
comment|/**    * Run-once iterator interface, to decode previously saved PackedInts.    */
DECL|interface|ReaderIterator
specifier|public
specifier|static
interface|interface
name|ReaderIterator
block|{
comment|/** Returns next value */
DECL|method|next
name|long
name|next
parameter_list|()
throws|throws
name|IOException
function_decl|;
comment|/** Returns at least 1 and at most<code>count</code> next values,      * the returned ref MUST NOT be modified */
DECL|method|next
name|LongsRef
name|next
parameter_list|(
name|int
name|count
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|/** Returns number of bits per value */
DECL|method|getBitsPerValue
name|int
name|getBitsPerValue
parameter_list|()
function_decl|;
comment|/** Returns number of values */
DECL|method|size
name|int
name|size
parameter_list|()
function_decl|;
comment|/** Returns the current position */
DECL|method|ord
name|int
name|ord
parameter_list|()
function_decl|;
block|}
DECL|class|ReaderIteratorImpl
specifier|static
specifier|abstract
class|class
name|ReaderIteratorImpl
implements|implements
name|ReaderIterator
block|{
DECL|field|in
specifier|protected
specifier|final
name|DataInput
name|in
decl_stmt|;
DECL|field|bitsPerValue
specifier|protected
specifier|final
name|int
name|bitsPerValue
decl_stmt|;
DECL|field|valueCount
specifier|protected
specifier|final
name|int
name|valueCount
decl_stmt|;
DECL|method|ReaderIteratorImpl
specifier|protected
name|ReaderIteratorImpl
parameter_list|(
name|int
name|valueCount
parameter_list|,
name|int
name|bitsPerValue
parameter_list|,
name|DataInput
name|in
parameter_list|)
block|{
name|this
operator|.
name|in
operator|=
name|in
expr_stmt|;
name|this
operator|.
name|bitsPerValue
operator|=
name|bitsPerValue
expr_stmt|;
name|this
operator|.
name|valueCount
operator|=
name|valueCount
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|next
specifier|public
name|long
name|next
parameter_list|()
throws|throws
name|IOException
block|{
name|LongsRef
name|nextValues
init|=
name|next
argument_list|(
literal|1
argument_list|)
decl_stmt|;
assert|assert
name|nextValues
operator|.
name|length
operator|>
literal|0
assert|;
specifier|final
name|long
name|result
init|=
name|nextValues
operator|.
name|longs
index|[
name|nextValues
operator|.
name|offset
index|]
decl_stmt|;
operator|++
name|nextValues
operator|.
name|offset
expr_stmt|;
operator|--
name|nextValues
operator|.
name|length
expr_stmt|;
return|return
name|result
return|;
block|}
annotation|@
name|Override
DECL|method|getBitsPerValue
specifier|public
name|int
name|getBitsPerValue
parameter_list|()
block|{
return|return
name|bitsPerValue
return|;
block|}
annotation|@
name|Override
DECL|method|size
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|valueCount
return|;
block|}
block|}
comment|/**    * A packed integer array that can be modified.    * @lucene.internal    */
DECL|class|Mutable
specifier|public
specifier|static
specifier|abstract
class|class
name|Mutable
extends|extends
name|Reader
block|{
comment|/**      * @return the number of bits used to store any given value.      *         Note: This does not imply that memory usage is      *         {@code bitsPerValue * #values} as implementations are free to      *         use non-space-optimal packing of bits.      */
DECL|method|getBitsPerValue
specifier|public
specifier|abstract
name|int
name|getBitsPerValue
parameter_list|()
function_decl|;
comment|/**      * Set the value at the given index in the array.      * @param index where the value should be positioned.      * @param value a value conforming to the constraints set by the array.      */
DECL|method|set
specifier|public
specifier|abstract
name|void
name|set
parameter_list|(
name|int
name|index
parameter_list|,
name|long
name|value
parameter_list|)
function_decl|;
comment|/**      * Bulk set: set at least one and at most<code>len</code> longs starting      * at<code>off</code> in<code>arr</code> into this mutable, starting at      *<code>index</code>. Returns the actual number of values that have been      * set.      */
DECL|method|set
specifier|public
name|int
name|set
parameter_list|(
name|int
name|index
parameter_list|,
name|long
index|[]
name|arr
parameter_list|,
name|int
name|off
parameter_list|,
name|int
name|len
parameter_list|)
block|{
assert|assert
name|len
operator|>
literal|0
operator|:
literal|"len must be> 0 (got "
operator|+
name|len
operator|+
literal|")"
assert|;
assert|assert
name|index
operator|>=
literal|0
operator|&&
name|index
operator|<
name|size
argument_list|()
assert|;
name|len
operator|=
name|Math
operator|.
name|min
argument_list|(
name|len
argument_list|,
name|size
argument_list|()
operator|-
name|index
argument_list|)
expr_stmt|;
assert|assert
name|off
operator|+
name|len
operator|<=
name|arr
operator|.
name|length
assert|;
for|for
control|(
name|int
name|i
init|=
name|index
init|,
name|o
init|=
name|off
init|,
name|end
init|=
name|index
operator|+
name|len
init|;
name|i
operator|<
name|end
condition|;
operator|++
name|i
operator|,
operator|++
name|o
control|)
block|{
name|set
argument_list|(
name|i
argument_list|,
name|arr
index|[
name|o
index|]
argument_list|)
expr_stmt|;
block|}
return|return
name|len
return|;
block|}
comment|/**      * Fill the mutable from<code>fromIndex</code> (inclusive) to      *<code>toIndex</code> (exclusive) with<code>val</code>.      */
DECL|method|fill
specifier|public
name|void
name|fill
parameter_list|(
name|int
name|fromIndex
parameter_list|,
name|int
name|toIndex
parameter_list|,
name|long
name|val
parameter_list|)
block|{
assert|assert
name|val
operator|<=
name|maxValue
argument_list|(
name|getBitsPerValue
argument_list|()
argument_list|)
assert|;
assert|assert
name|fromIndex
operator|<=
name|toIndex
assert|;
for|for
control|(
name|int
name|i
init|=
name|fromIndex
init|;
name|i
operator|<
name|toIndex
condition|;
operator|++
name|i
control|)
block|{
name|set
argument_list|(
name|i
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Sets all values to 0.      */
DECL|method|clear
specifier|public
name|void
name|clear
parameter_list|()
block|{
name|fill
argument_list|(
literal|0
argument_list|,
name|size
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/**      * Save this mutable into<code>out</code>. Instantiating a reader from      * the generated data will return a reader with the same number of bits      * per value.      */
DECL|method|save
specifier|public
name|void
name|save
parameter_list|(
name|DataOutput
name|out
parameter_list|)
throws|throws
name|IOException
block|{
name|Writer
name|writer
init|=
name|getWriterNoHeader
argument_list|(
name|out
argument_list|,
name|getFormat
argument_list|()
argument_list|,
name|size
argument_list|()
argument_list|,
name|getBitsPerValue
argument_list|()
argument_list|,
name|DEFAULT_BUFFER_SIZE
argument_list|)
decl_stmt|;
name|writer
operator|.
name|writeHeader
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|writer
operator|.
name|add
argument_list|(
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|writer
operator|.
name|finish
argument_list|()
expr_stmt|;
block|}
comment|/** The underlying format. */
DECL|method|getFormat
name|Format
name|getFormat
parameter_list|()
block|{
return|return
name|Format
operator|.
name|PACKED
return|;
block|}
block|}
comment|/**    * A simple base for Readers that keeps track of valueCount and bitsPerValue.    * @lucene.internal    */
DECL|class|ReaderImpl
specifier|static
specifier|abstract
class|class
name|ReaderImpl
extends|extends
name|Reader
block|{
DECL|field|valueCount
specifier|protected
specifier|final
name|int
name|valueCount
decl_stmt|;
DECL|method|ReaderImpl
specifier|protected
name|ReaderImpl
parameter_list|(
name|int
name|valueCount
parameter_list|)
block|{
name|this
operator|.
name|valueCount
operator|=
name|valueCount
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|get
specifier|public
specifier|abstract
name|long
name|get
parameter_list|(
name|int
name|index
parameter_list|)
function_decl|;
annotation|@
name|Override
DECL|method|size
specifier|public
specifier|final
name|int
name|size
parameter_list|()
block|{
return|return
name|valueCount
return|;
block|}
block|}
DECL|class|MutableImpl
specifier|static
specifier|abstract
class|class
name|MutableImpl
extends|extends
name|Mutable
block|{
DECL|field|valueCount
specifier|protected
specifier|final
name|int
name|valueCount
decl_stmt|;
DECL|field|bitsPerValue
specifier|protected
specifier|final
name|int
name|bitsPerValue
decl_stmt|;
DECL|method|MutableImpl
specifier|protected
name|MutableImpl
parameter_list|(
name|int
name|valueCount
parameter_list|,
name|int
name|bitsPerValue
parameter_list|)
block|{
name|this
operator|.
name|valueCount
operator|=
name|valueCount
expr_stmt|;
assert|assert
name|bitsPerValue
operator|>
literal|0
operator|&&
name|bitsPerValue
operator|<=
literal|64
operator|:
literal|"bitsPerValue="
operator|+
name|bitsPerValue
assert|;
name|this
operator|.
name|bitsPerValue
operator|=
name|bitsPerValue
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|getBitsPerValue
specifier|public
specifier|final
name|int
name|getBitsPerValue
parameter_list|()
block|{
return|return
name|bitsPerValue
return|;
block|}
annotation|@
name|Override
DECL|method|size
specifier|public
specifier|final
name|int
name|size
parameter_list|()
block|{
return|return
name|valueCount
return|;
block|}
annotation|@
name|Override
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|"(valueCount="
operator|+
name|valueCount
operator|+
literal|",bitsPerValue="
operator|+
name|bitsPerValue
operator|+
literal|")"
return|;
block|}
block|}
comment|/** A {@link Reader} which has all its values equal to 0 (bitsPerValue = 0). */
DECL|class|NullReader
specifier|public
specifier|static
specifier|final
class|class
name|NullReader
extends|extends
name|Reader
block|{
DECL|field|valueCount
specifier|private
specifier|final
name|int
name|valueCount
decl_stmt|;
comment|/** Sole constructor. */
DECL|method|NullReader
specifier|public
name|NullReader
parameter_list|(
name|int
name|valueCount
parameter_list|)
block|{
name|this
operator|.
name|valueCount
operator|=
name|valueCount
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|get
specifier|public
name|long
name|get
parameter_list|(
name|int
name|index
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
annotation|@
name|Override
DECL|method|get
specifier|public
name|int
name|get
parameter_list|(
name|int
name|index
parameter_list|,
name|long
index|[]
name|arr
parameter_list|,
name|int
name|off
parameter_list|,
name|int
name|len
parameter_list|)
block|{
assert|assert
name|len
operator|>
literal|0
operator|:
literal|"len must be> 0 (got "
operator|+
name|len
operator|+
literal|")"
assert|;
assert|assert
name|index
operator|>=
literal|0
operator|&&
name|index
operator|<
name|valueCount
assert|;
name|len
operator|=
name|Math
operator|.
name|min
argument_list|(
name|len
argument_list|,
name|valueCount
operator|-
name|index
argument_list|)
expr_stmt|;
name|Arrays
operator|.
name|fill
argument_list|(
name|arr
argument_list|,
name|off
argument_list|,
name|off
operator|+
name|len
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|len
return|;
block|}
annotation|@
name|Override
DECL|method|size
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|valueCount
return|;
block|}
annotation|@
name|Override
DECL|method|ramBytesUsed
specifier|public
name|long
name|ramBytesUsed
parameter_list|()
block|{
return|return
name|RamUsageEstimator
operator|.
name|alignObjectSize
argument_list|(
name|RamUsageEstimator
operator|.
name|NUM_BYTES_OBJECT_HEADER
operator|+
name|RamUsageEstimator
operator|.
name|NUM_BYTES_INT
argument_list|)
return|;
block|}
block|}
comment|/** A write-once Writer.    * @lucene.internal    */
DECL|class|Writer
specifier|public
specifier|static
specifier|abstract
class|class
name|Writer
block|{
DECL|field|out
specifier|protected
specifier|final
name|DataOutput
name|out
decl_stmt|;
DECL|field|valueCount
specifier|protected
specifier|final
name|int
name|valueCount
decl_stmt|;
DECL|field|bitsPerValue
specifier|protected
specifier|final
name|int
name|bitsPerValue
decl_stmt|;
DECL|method|Writer
specifier|protected
name|Writer
parameter_list|(
name|DataOutput
name|out
parameter_list|,
name|int
name|valueCount
parameter_list|,
name|int
name|bitsPerValue
parameter_list|)
block|{
assert|assert
name|bitsPerValue
operator|<=
literal|64
assert|;
assert|assert
name|valueCount
operator|>=
literal|0
operator|||
name|valueCount
operator|==
operator|-
literal|1
assert|;
name|this
operator|.
name|out
operator|=
name|out
expr_stmt|;
name|this
operator|.
name|valueCount
operator|=
name|valueCount
expr_stmt|;
name|this
operator|.
name|bitsPerValue
operator|=
name|bitsPerValue
expr_stmt|;
block|}
DECL|method|writeHeader
name|void
name|writeHeader
parameter_list|()
throws|throws
name|IOException
block|{
assert|assert
name|valueCount
operator|!=
operator|-
literal|1
assert|;
name|CodecUtil
operator|.
name|writeHeader
argument_list|(
name|out
argument_list|,
name|CODEC_NAME
argument_list|,
name|VERSION_CURRENT
argument_list|)
expr_stmt|;
name|out
operator|.
name|writeVInt
argument_list|(
name|bitsPerValue
argument_list|)
expr_stmt|;
name|out
operator|.
name|writeVInt
argument_list|(
name|valueCount
argument_list|)
expr_stmt|;
name|out
operator|.
name|writeVInt
argument_list|(
name|getFormat
argument_list|()
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/** The format used to serialize values. */
DECL|method|getFormat
specifier|protected
specifier|abstract
name|PackedInts
operator|.
name|Format
name|getFormat
parameter_list|()
function_decl|;
comment|/** Add a value to the stream. */
DECL|method|add
specifier|public
specifier|abstract
name|void
name|add
parameter_list|(
name|long
name|v
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|/** The number of bits per value. */
DECL|method|bitsPerValue
specifier|public
specifier|final
name|int
name|bitsPerValue
parameter_list|()
block|{
return|return
name|bitsPerValue
return|;
block|}
comment|/** Perform end-of-stream operations. */
DECL|method|finish
specifier|public
specifier|abstract
name|void
name|finish
parameter_list|()
throws|throws
name|IOException
function_decl|;
comment|/**      * Returns the current ord in the stream (number of values that have been      * written so far minus one).      */
DECL|method|ord
specifier|public
specifier|abstract
name|int
name|ord
parameter_list|()
function_decl|;
block|}
comment|/**    * Get a {@link Decoder}.    *    * @param format         the format used to store packed ints    * @param version        the compatibility version    * @param bitsPerValue   the number of bits per value    * @return a decoder    */
DECL|method|getDecoder
specifier|public
specifier|static
name|Decoder
name|getDecoder
parameter_list|(
name|Format
name|format
parameter_list|,
name|int
name|version
parameter_list|,
name|int
name|bitsPerValue
parameter_list|)
block|{
name|checkVersion
argument_list|(
name|version
argument_list|)
expr_stmt|;
return|return
name|BulkOperation
operator|.
name|of
argument_list|(
name|format
argument_list|,
name|bitsPerValue
argument_list|)
return|;
block|}
comment|/**    * Get an {@link Encoder}.    *    * @param format         the format used to store packed ints    * @param version        the compatibility version    * @param bitsPerValue   the number of bits per value    * @return an encoder    */
DECL|method|getEncoder
specifier|public
specifier|static
name|Encoder
name|getEncoder
parameter_list|(
name|Format
name|format
parameter_list|,
name|int
name|version
parameter_list|,
name|int
name|bitsPerValue
parameter_list|)
block|{
name|checkVersion
argument_list|(
name|version
argument_list|)
expr_stmt|;
return|return
name|BulkOperation
operator|.
name|of
argument_list|(
name|format
argument_list|,
name|bitsPerValue
argument_list|)
return|;
block|}
comment|/**    * Expert: Restore a {@link Reader} from a stream without reading metadata at    * the beginning of the stream. This method is useful to restore data from    * streams which have been created using    * {@link PackedInts#getWriterNoHeader(DataOutput, Format, int, int, int)}.    *    * @param in           the stream to read data from, positioned at the beginning of the packed values    * @param format       the format used to serialize    * @param version      the version used to serialize the data    * @param valueCount   how many values the stream holds    * @param bitsPerValue the number of bits per value    * @return             a Reader    * @throws IOException If there is a low-level I/O error    * @see PackedInts#getWriterNoHeader(DataOutput, Format, int, int, int)    * @lucene.internal    */
DECL|method|getReaderNoHeader
specifier|public
specifier|static
name|Reader
name|getReaderNoHeader
parameter_list|(
name|DataInput
name|in
parameter_list|,
name|Format
name|format
parameter_list|,
name|int
name|version
parameter_list|,
name|int
name|valueCount
parameter_list|,
name|int
name|bitsPerValue
parameter_list|)
throws|throws
name|IOException
block|{
name|checkVersion
argument_list|(
name|version
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|format
condition|)
block|{
case|case
name|PACKED_SINGLE_BLOCK
case|:
return|return
name|Packed64SingleBlock
operator|.
name|create
argument_list|(
name|in
argument_list|,
name|valueCount
argument_list|,
name|bitsPerValue
argument_list|)
return|;
case|case
name|PACKED
case|:
switch|switch
condition|(
name|bitsPerValue
condition|)
block|{
case|case
literal|8
case|:
return|return
operator|new
name|Direct8
argument_list|(
name|version
argument_list|,
name|in
argument_list|,
name|valueCount
argument_list|)
return|;
case|case
literal|16
case|:
return|return
operator|new
name|Direct16
argument_list|(
name|version
argument_list|,
name|in
argument_list|,
name|valueCount
argument_list|)
return|;
case|case
literal|32
case|:
return|return
operator|new
name|Direct32
argument_list|(
name|version
argument_list|,
name|in
argument_list|,
name|valueCount
argument_list|)
return|;
case|case
literal|64
case|:
return|return
operator|new
name|Direct64
argument_list|(
name|version
argument_list|,
name|in
argument_list|,
name|valueCount
argument_list|)
return|;
case|case
literal|24
case|:
if|if
condition|(
name|valueCount
operator|<=
name|Packed8ThreeBlocks
operator|.
name|MAX_SIZE
condition|)
block|{
return|return
operator|new
name|Packed8ThreeBlocks
argument_list|(
name|version
argument_list|,
name|in
argument_list|,
name|valueCount
argument_list|)
return|;
block|}
break|break;
case|case
literal|48
case|:
if|if
condition|(
name|valueCount
operator|<=
name|Packed16ThreeBlocks
operator|.
name|MAX_SIZE
condition|)
block|{
return|return
operator|new
name|Packed16ThreeBlocks
argument_list|(
name|version
argument_list|,
name|in
argument_list|,
name|valueCount
argument_list|)
return|;
block|}
break|break;
block|}
return|return
operator|new
name|Packed64
argument_list|(
name|version
argument_list|,
name|in
argument_list|,
name|valueCount
argument_list|,
name|bitsPerValue
argument_list|)
return|;
default|default:
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"Unknown Writer format: "
operator|+
name|format
argument_list|)
throw|;
block|}
block|}
comment|/**    * Restore a {@link Reader} from a stream.    *    * @param in           the stream to read data from    * @return             a Reader    * @throws IOException If there is a low-level I/O error    * @lucene.internal    */
DECL|method|getReader
specifier|public
specifier|static
name|Reader
name|getReader
parameter_list|(
name|DataInput
name|in
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|int
name|version
init|=
name|CodecUtil
operator|.
name|checkHeader
argument_list|(
name|in
argument_list|,
name|CODEC_NAME
argument_list|,
name|VERSION_START
argument_list|,
name|VERSION_CURRENT
argument_list|)
decl_stmt|;
specifier|final
name|int
name|bitsPerValue
init|=
name|in
operator|.
name|readVInt
argument_list|()
decl_stmt|;
assert|assert
name|bitsPerValue
operator|>
literal|0
operator|&&
name|bitsPerValue
operator|<=
literal|64
operator|:
literal|"bitsPerValue="
operator|+
name|bitsPerValue
assert|;
specifier|final
name|int
name|valueCount
init|=
name|in
operator|.
name|readVInt
argument_list|()
decl_stmt|;
specifier|final
name|Format
name|format
init|=
name|Format
operator|.
name|byId
argument_list|(
name|in
operator|.
name|readVInt
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|getReaderNoHeader
argument_list|(
name|in
argument_list|,
name|format
argument_list|,
name|version
argument_list|,
name|valueCount
argument_list|,
name|bitsPerValue
argument_list|)
return|;
block|}
comment|/**    * Expert: Restore a {@link ReaderIterator} from a stream without reading    * metadata at the beginning of the stream. This method is useful to restore    * data from streams which have been created using    * {@link PackedInts#getWriterNoHeader(DataOutput, Format, int, int, int)}.    *    * @param in           the stream to read data from, positioned at the beginning of the packed values    * @param format       the format used to serialize    * @param version      the version used to serialize the data    * @param valueCount   how many values the stream holds    * @param bitsPerValue the number of bits per value    * @param mem          how much memory the iterator is allowed to use to read-ahead (likely to speed up iteration)    * @return             a ReaderIterator    * @see PackedInts#getWriterNoHeader(DataOutput, Format, int, int, int)    * @lucene.internal    */
DECL|method|getReaderIteratorNoHeader
specifier|public
specifier|static
name|ReaderIterator
name|getReaderIteratorNoHeader
parameter_list|(
name|DataInput
name|in
parameter_list|,
name|Format
name|format
parameter_list|,
name|int
name|version
parameter_list|,
name|int
name|valueCount
parameter_list|,
name|int
name|bitsPerValue
parameter_list|,
name|int
name|mem
parameter_list|)
block|{
name|checkVersion
argument_list|(
name|version
argument_list|)
expr_stmt|;
return|return
operator|new
name|PackedReaderIterator
argument_list|(
name|format
argument_list|,
name|version
argument_list|,
name|valueCount
argument_list|,
name|bitsPerValue
argument_list|,
name|in
argument_list|,
name|mem
argument_list|)
return|;
block|}
comment|/**    * Retrieve PackedInts as a {@link ReaderIterator}    * @param in positioned at the beginning of a stored packed int structure.    * @param mem how much memory the iterator is allowed to use to read-ahead (likely to speed up iteration)    * @return an iterator to access the values    * @throws IOException if the structure could not be retrieved.    * @lucene.internal    */
DECL|method|getReaderIterator
specifier|public
specifier|static
name|ReaderIterator
name|getReaderIterator
parameter_list|(
name|DataInput
name|in
parameter_list|,
name|int
name|mem
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|int
name|version
init|=
name|CodecUtil
operator|.
name|checkHeader
argument_list|(
name|in
argument_list|,
name|CODEC_NAME
argument_list|,
name|VERSION_START
argument_list|,
name|VERSION_CURRENT
argument_list|)
decl_stmt|;
specifier|final
name|int
name|bitsPerValue
init|=
name|in
operator|.
name|readVInt
argument_list|()
decl_stmt|;
assert|assert
name|bitsPerValue
operator|>
literal|0
operator|&&
name|bitsPerValue
operator|<=
literal|64
operator|:
literal|"bitsPerValue="
operator|+
name|bitsPerValue
assert|;
specifier|final
name|int
name|valueCount
init|=
name|in
operator|.
name|readVInt
argument_list|()
decl_stmt|;
specifier|final
name|Format
name|format
init|=
name|Format
operator|.
name|byId
argument_list|(
name|in
operator|.
name|readVInt
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|getReaderIteratorNoHeader
argument_list|(
name|in
argument_list|,
name|format
argument_list|,
name|version
argument_list|,
name|valueCount
argument_list|,
name|bitsPerValue
argument_list|,
name|mem
argument_list|)
return|;
block|}
comment|/**    * Expert: Construct a direct {@link Reader} from a stream without reading    * metadata at the beginning of the stream. This method is useful to restore    * data from streams which have been created using    * {@link PackedInts#getWriterNoHeader(DataOutput, Format, int, int, int)}.    *<p>    * The returned reader will have very little memory overhead, but every call    * to {@link Reader#get(int)} is likely to perform a disk seek.    *    * @param in           the stream to read data from    * @param format       the format used to serialize    * @param version      the version used to serialize the data    * @param valueCount   how many values the stream holds    * @param bitsPerValue the number of bits per value    * @return a direct Reader    * @lucene.internal    */
DECL|method|getDirectReaderNoHeader
specifier|public
specifier|static
name|Reader
name|getDirectReaderNoHeader
parameter_list|(
specifier|final
name|IndexInput
name|in
parameter_list|,
name|Format
name|format
parameter_list|,
name|int
name|version
parameter_list|,
name|int
name|valueCount
parameter_list|,
name|int
name|bitsPerValue
parameter_list|)
block|{
name|checkVersion
argument_list|(
name|version
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|format
condition|)
block|{
case|case
name|PACKED
case|:
return|return
operator|new
name|DirectPackedReader
argument_list|(
name|bitsPerValue
argument_list|,
name|valueCount
argument_list|,
name|in
argument_list|)
return|;
case|case
name|PACKED_SINGLE_BLOCK
case|:
return|return
operator|new
name|DirectPacked64SingleBlockReader
argument_list|(
name|bitsPerValue
argument_list|,
name|valueCount
argument_list|,
name|in
argument_list|)
return|;
default|default:
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"Unknwown format: "
operator|+
name|format
argument_list|)
throw|;
block|}
block|}
comment|/**    * Construct a direct {@link Reader} from an {@link IndexInput}. This method    * is useful to restore data from streams which have been created using    * {@link PackedInts#getWriter(DataOutput, int, int, float)}.    *<p>    * The returned reader will have very little memory overhead, but every call    * to {@link Reader#get(int)} is likely to perform a disk seek.    *    * @param in           the stream to read data from    * @return a direct Reader    * @throws IOException If there is a low-level I/O error    * @lucene.internal    */
DECL|method|getDirectReader
specifier|public
specifier|static
name|Reader
name|getDirectReader
parameter_list|(
name|IndexInput
name|in
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|int
name|version
init|=
name|CodecUtil
operator|.
name|checkHeader
argument_list|(
name|in
argument_list|,
name|CODEC_NAME
argument_list|,
name|VERSION_START
argument_list|,
name|VERSION_CURRENT
argument_list|)
decl_stmt|;
specifier|final
name|int
name|bitsPerValue
init|=
name|in
operator|.
name|readVInt
argument_list|()
decl_stmt|;
assert|assert
name|bitsPerValue
operator|>
literal|0
operator|&&
name|bitsPerValue
operator|<=
literal|64
operator|:
literal|"bitsPerValue="
operator|+
name|bitsPerValue
assert|;
specifier|final
name|int
name|valueCount
init|=
name|in
operator|.
name|readVInt
argument_list|()
decl_stmt|;
specifier|final
name|Format
name|format
init|=
name|Format
operator|.
name|byId
argument_list|(
name|in
operator|.
name|readVInt
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|getDirectReaderNoHeader
argument_list|(
name|in
argument_list|,
name|format
argument_list|,
name|version
argument_list|,
name|valueCount
argument_list|,
name|bitsPerValue
argument_list|)
return|;
block|}
comment|/**    * Create a packed integer array with the given amount of values initialized    * to 0. the valueCount and the bitsPerValue cannot be changed after creation.    * All Mutables known by this factory are kept fully in RAM.    *<p>    * Positive values of<code>acceptableOverheadRatio</code> will trade space    * for speed by selecting a faster but potentially less memory-efficient    * implementation. An<code>acceptableOverheadRatio</code> of    * {@link PackedInts#COMPACT} will make sure that the most memory-efficient    * implementation is selected whereas {@link PackedInts#FASTEST} will make sure    * that the fastest implementation is selected.    *    * @param valueCount   the number of elements    * @param bitsPerValue the number of bits available for any given value    * @param acceptableOverheadRatio an acceptable overhead    *        ratio per value    * @return a mutable packed integer array    * @lucene.internal    */
DECL|method|getMutable
specifier|public
specifier|static
name|Mutable
name|getMutable
parameter_list|(
name|int
name|valueCount
parameter_list|,
name|int
name|bitsPerValue
parameter_list|,
name|float
name|acceptableOverheadRatio
parameter_list|)
block|{
specifier|final
name|FormatAndBits
name|formatAndBits
init|=
name|fastestFormatAndBits
argument_list|(
name|valueCount
argument_list|,
name|bitsPerValue
argument_list|,
name|acceptableOverheadRatio
argument_list|)
decl_stmt|;
return|return
name|getMutable
argument_list|(
name|valueCount
argument_list|,
name|formatAndBits
operator|.
name|bitsPerValue
argument_list|,
name|formatAndBits
operator|.
name|format
argument_list|)
return|;
block|}
comment|/** Same as {@link #getMutable(int, int, float)} with a pre-computed number    *  of bits per value and format.    *  @lucene.internal */
DECL|method|getMutable
specifier|public
specifier|static
name|Mutable
name|getMutable
parameter_list|(
name|int
name|valueCount
parameter_list|,
name|int
name|bitsPerValue
parameter_list|,
name|PackedInts
operator|.
name|Format
name|format
parameter_list|)
block|{
assert|assert
name|valueCount
operator|>=
literal|0
assert|;
switch|switch
condition|(
name|format
condition|)
block|{
case|case
name|PACKED_SINGLE_BLOCK
case|:
return|return
name|Packed64SingleBlock
operator|.
name|create
argument_list|(
name|valueCount
argument_list|,
name|bitsPerValue
argument_list|)
return|;
case|case
name|PACKED
case|:
switch|switch
condition|(
name|bitsPerValue
condition|)
block|{
case|case
literal|8
case|:
return|return
operator|new
name|Direct8
argument_list|(
name|valueCount
argument_list|)
return|;
case|case
literal|16
case|:
return|return
operator|new
name|Direct16
argument_list|(
name|valueCount
argument_list|)
return|;
case|case
literal|32
case|:
return|return
operator|new
name|Direct32
argument_list|(
name|valueCount
argument_list|)
return|;
case|case
literal|64
case|:
return|return
operator|new
name|Direct64
argument_list|(
name|valueCount
argument_list|)
return|;
case|case
literal|24
case|:
if|if
condition|(
name|valueCount
operator|<=
name|Packed8ThreeBlocks
operator|.
name|MAX_SIZE
condition|)
block|{
return|return
operator|new
name|Packed8ThreeBlocks
argument_list|(
name|valueCount
argument_list|)
return|;
block|}
break|break;
case|case
literal|48
case|:
if|if
condition|(
name|valueCount
operator|<=
name|Packed16ThreeBlocks
operator|.
name|MAX_SIZE
condition|)
block|{
return|return
operator|new
name|Packed16ThreeBlocks
argument_list|(
name|valueCount
argument_list|)
return|;
block|}
break|break;
block|}
return|return
operator|new
name|Packed64
argument_list|(
name|valueCount
argument_list|,
name|bitsPerValue
argument_list|)
return|;
default|default:
throw|throw
operator|new
name|AssertionError
argument_list|()
throw|;
block|}
block|}
comment|/**    * Expert: Create a packed integer array writer for the given output, format,    * value count, and number of bits per value.    *<p>    * The resulting stream will be long-aligned. This means that depending on    * the format which is used, up to 63 bits will be wasted. An easy way to    * make sure that no space is lost is to always use a<code>valueCount</code>    * that is a multiple of 64.    *<p>    * This method does not write any metadata to the stream, meaning that it is    * your responsibility to store it somewhere else in order to be able to    * recover data from the stream later on:    *<ul>    *<li><code>format</code> (using {@link Format#getId()}),</li>    *<li><code>valueCount</code>,</li>    *<li><code>bitsPerValue</code>,</li>    *<li>{@link #VERSION_CURRENT}.</li>    *</ul>    *<p>    * It is possible to start writing values without knowing how many of them you    * are actually going to write. To do this, just pass<code>-1</code> as    *<code>valueCount</code>. On the other hand, for any positive value of    *<code>valueCount</code>, the returned writer will make sure that you don't    * write more values than expected and pad the end of stream with zeros in    * case you have written less than<code>valueCount</code> when calling    * {@link Writer#finish()}.    *<p>    * The<code>mem</code> parameter lets you control how much memory can be used    * to buffer changes in memory before flushing to disk. High values of    *<code>mem</code> are likely to improve throughput. On the other hand, if    * speed is not that important to you, a value of<code>0</code> will use as    * little memory as possible and should already offer reasonable throughput.    *    * @param out          the data output    * @param format       the format to use to serialize the values    * @param valueCount   the number of values    * @param bitsPerValue the number of bits per value    * @param mem          how much memory (in bytes) can be used to speed up serialization    * @return             a Writer    * @see PackedInts#getReaderIteratorNoHeader(DataInput, Format, int, int, int, int)    * @see PackedInts#getReaderNoHeader(DataInput, Format, int, int, int)    * @lucene.internal    */
DECL|method|getWriterNoHeader
specifier|public
specifier|static
name|Writer
name|getWriterNoHeader
parameter_list|(
name|DataOutput
name|out
parameter_list|,
name|Format
name|format
parameter_list|,
name|int
name|valueCount
parameter_list|,
name|int
name|bitsPerValue
parameter_list|,
name|int
name|mem
parameter_list|)
block|{
return|return
operator|new
name|PackedWriter
argument_list|(
name|format
argument_list|,
name|out
argument_list|,
name|valueCount
argument_list|,
name|bitsPerValue
argument_list|,
name|mem
argument_list|)
return|;
block|}
comment|/**    * Create a packed integer array writer for the given output, format, value    * count, and number of bits per value.    *<p>    * The resulting stream will be long-aligned. This means that depending on    * the format which is used under the hoods, up to 63 bits will be wasted.    * An easy way to make sure that no space is lost is to always use a    *<code>valueCount</code> that is a multiple of 64.    *<p>    * This method writes metadata to the stream, so that the resulting stream is    * sufficient to restore a {@link Reader} from it. You don't need to track    *<code>valueCount</code> or<code>bitsPerValue</code> by yourself. In case    * this is a problem, you should probably look at    * {@link #getWriterNoHeader(DataOutput, Format, int, int, int)}.    *<p>    * The<code>acceptableOverheadRatio</code> parameter controls how    * readers that will be restored from this stream trade space    * for speed by selecting a faster but potentially less memory-efficient    * implementation. An<code>acceptableOverheadRatio</code> of    * {@link PackedInts#COMPACT} will make sure that the most memory-efficient    * implementation is selected whereas {@link PackedInts#FASTEST} will make sure    * that the fastest implementation is selected. In case you are only interested    * in reading this stream sequentially later on, you should probably use    * {@link PackedInts#COMPACT}.    *    * @param out          the data output    * @param valueCount   the number of values    * @param bitsPerValue the number of bits per value    * @param acceptableOverheadRatio an acceptable overhead ratio per value    * @return             a Writer    * @throws IOException If there is a low-level I/O error    * @lucene.internal    */
DECL|method|getWriter
specifier|public
specifier|static
name|Writer
name|getWriter
parameter_list|(
name|DataOutput
name|out
parameter_list|,
name|int
name|valueCount
parameter_list|,
name|int
name|bitsPerValue
parameter_list|,
name|float
name|acceptableOverheadRatio
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|valueCount
operator|>=
literal|0
assert|;
specifier|final
name|FormatAndBits
name|formatAndBits
init|=
name|fastestFormatAndBits
argument_list|(
name|valueCount
argument_list|,
name|bitsPerValue
argument_list|,
name|acceptableOverheadRatio
argument_list|)
decl_stmt|;
specifier|final
name|Writer
name|writer
init|=
name|getWriterNoHeader
argument_list|(
name|out
argument_list|,
name|formatAndBits
operator|.
name|format
argument_list|,
name|valueCount
argument_list|,
name|formatAndBits
operator|.
name|bitsPerValue
argument_list|,
name|DEFAULT_BUFFER_SIZE
argument_list|)
decl_stmt|;
name|writer
operator|.
name|writeHeader
argument_list|()
expr_stmt|;
return|return
name|writer
return|;
block|}
comment|/** Returns how many bits are required to hold values up    *  to and including maxValue    *  NOTE: This method returns at least 1.    * @param maxValue the maximum value that should be representable.    * @return the amount of bits needed to represent values from 0 to maxValue.    * @lucene.internal    */
DECL|method|bitsRequired
specifier|public
specifier|static
name|int
name|bitsRequired
parameter_list|(
name|long
name|maxValue
parameter_list|)
block|{
if|if
condition|(
name|maxValue
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"maxValue must be non-negative (got: "
operator|+
name|maxValue
operator|+
literal|")"
argument_list|)
throw|;
block|}
return|return
name|unsignedBitsRequired
argument_list|(
name|maxValue
argument_list|)
return|;
block|}
comment|/** Returns how many bits are required to store<code>bits</code>,    * interpreted as an unsigned value.    * NOTE: This method returns at least 1.    * @lucene.internal    */
DECL|method|unsignedBitsRequired
specifier|public
specifier|static
name|int
name|unsignedBitsRequired
parameter_list|(
name|long
name|bits
parameter_list|)
block|{
return|return
name|Math
operator|.
name|max
argument_list|(
literal|1
argument_list|,
literal|64
operator|-
name|Long
operator|.
name|numberOfLeadingZeros
argument_list|(
name|bits
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Calculates the maximum unsigned long that can be expressed with the given    * number of bits.    * @param bitsPerValue the number of bits available for any given value.    * @return the maximum value for the given bits.    * @lucene.internal    */
DECL|method|maxValue
specifier|public
specifier|static
name|long
name|maxValue
parameter_list|(
name|int
name|bitsPerValue
parameter_list|)
block|{
return|return
name|bitsPerValue
operator|==
literal|64
condition|?
name|Long
operator|.
name|MAX_VALUE
else|:
operator|~
operator|(
operator|~
literal|0L
operator|<<
name|bitsPerValue
operator|)
return|;
block|}
comment|/**    * Copy<code>src[srcPos:srcPos+len]</code> into    *<code>dest[destPos:destPos+len]</code> using at most<code>mem</code>    * bytes.    */
DECL|method|copy
specifier|public
specifier|static
name|void
name|copy
parameter_list|(
name|Reader
name|src
parameter_list|,
name|int
name|srcPos
parameter_list|,
name|Mutable
name|dest
parameter_list|,
name|int
name|destPos
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|mem
parameter_list|)
block|{
assert|assert
name|srcPos
operator|+
name|len
operator|<=
name|src
operator|.
name|size
argument_list|()
assert|;
assert|assert
name|destPos
operator|+
name|len
operator|<=
name|dest
operator|.
name|size
argument_list|()
assert|;
specifier|final
name|int
name|capacity
init|=
name|mem
operator|>>>
literal|3
decl_stmt|;
if|if
condition|(
name|capacity
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
operator|++
name|i
control|)
block|{
name|dest
operator|.
name|set
argument_list|(
name|destPos
operator|++
argument_list|,
name|src
operator|.
name|get
argument_list|(
name|srcPos
operator|++
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
comment|// use bulk operations
specifier|final
name|long
index|[]
name|buf
init|=
operator|new
name|long
index|[
name|Math
operator|.
name|min
argument_list|(
name|capacity
argument_list|,
name|len
argument_list|)
index|]
decl_stmt|;
name|copy
argument_list|(
name|src
argument_list|,
name|srcPos
argument_list|,
name|dest
argument_list|,
name|destPos
argument_list|,
name|len
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Same as {@link #copy(Reader, int, Mutable, int, int, int)} but using a pre-allocated buffer. */
DECL|method|copy
specifier|static
name|void
name|copy
parameter_list|(
name|Reader
name|src
parameter_list|,
name|int
name|srcPos
parameter_list|,
name|Mutable
name|dest
parameter_list|,
name|int
name|destPos
parameter_list|,
name|int
name|len
parameter_list|,
name|long
index|[]
name|buf
parameter_list|)
block|{
assert|assert
name|buf
operator|.
name|length
operator|>
literal|0
assert|;
name|int
name|remaining
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
specifier|final
name|int
name|read
init|=
name|src
operator|.
name|get
argument_list|(
name|srcPos
argument_list|,
name|buf
argument_list|,
name|remaining
argument_list|,
name|Math
operator|.
name|min
argument_list|(
name|len
argument_list|,
name|buf
operator|.
name|length
operator|-
name|remaining
argument_list|)
argument_list|)
decl_stmt|;
assert|assert
name|read
operator|>
literal|0
assert|;
name|srcPos
operator|+=
name|read
expr_stmt|;
name|len
operator|-=
name|read
expr_stmt|;
name|remaining
operator|+=
name|read
expr_stmt|;
specifier|final
name|int
name|written
init|=
name|dest
operator|.
name|set
argument_list|(
name|destPos
argument_list|,
name|buf
argument_list|,
literal|0
argument_list|,
name|remaining
argument_list|)
decl_stmt|;
assert|assert
name|written
operator|>
literal|0
assert|;
name|destPos
operator|+=
name|written
expr_stmt|;
if|if
condition|(
name|written
operator|<
name|remaining
condition|)
block|{
name|System
operator|.
name|arraycopy
argument_list|(
name|buf
argument_list|,
name|written
argument_list|,
name|buf
argument_list|,
literal|0
argument_list|,
name|remaining
operator|-
name|written
argument_list|)
expr_stmt|;
block|}
name|remaining
operator|-=
name|written
expr_stmt|;
block|}
while|while
condition|(
name|remaining
operator|>
literal|0
condition|)
block|{
specifier|final
name|int
name|written
init|=
name|dest
operator|.
name|set
argument_list|(
name|destPos
argument_list|,
name|buf
argument_list|,
literal|0
argument_list|,
name|remaining
argument_list|)
decl_stmt|;
name|destPos
operator|+=
name|written
expr_stmt|;
name|remaining
operator|-=
name|written
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|buf
argument_list|,
name|written
argument_list|,
name|buf
argument_list|,
literal|0
argument_list|,
name|remaining
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Check that the block size is a power of 2, in the right bounds, and return    *  its log in base 2. */
DECL|method|checkBlockSize
specifier|static
name|int
name|checkBlockSize
parameter_list|(
name|int
name|blockSize
parameter_list|,
name|int
name|minBlockSize
parameter_list|,
name|int
name|maxBlockSize
parameter_list|)
block|{
if|if
condition|(
name|blockSize
argument_list|<
name|minBlockSize
operator|||
name|blockSize
argument_list|>
name|maxBlockSize
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"blockSize must be>= "
operator|+
name|minBlockSize
operator|+
literal|" and<= "
operator|+
name|maxBlockSize
operator|+
literal|", got "
operator|+
name|blockSize
argument_list|)
throw|;
block|}
if|if
condition|(
operator|(
name|blockSize
operator|&
operator|(
name|blockSize
operator|-
literal|1
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"blockSize must be a power of two, got "
operator|+
name|blockSize
argument_list|)
throw|;
block|}
return|return
name|Integer
operator|.
name|numberOfTrailingZeros
argument_list|(
name|blockSize
argument_list|)
return|;
block|}
comment|/** Return the number of blocks required to store<code>size</code> values on    *<code>blockSize</code>. */
DECL|method|numBlocks
specifier|static
name|int
name|numBlocks
parameter_list|(
name|long
name|size
parameter_list|,
name|int
name|blockSize
parameter_list|)
block|{
specifier|final
name|int
name|numBlocks
init|=
call|(
name|int
call|)
argument_list|(
name|size
operator|/
name|blockSize
argument_list|)
operator|+
operator|(
name|size
operator|%
name|blockSize
operator|==
literal|0
condition|?
literal|0
else|:
literal|1
operator|)
decl_stmt|;
if|if
condition|(
operator|(
name|long
operator|)
name|numBlocks
operator|*
name|blockSize
operator|<
name|size
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"size is too large for this block size"
argument_list|)
throw|;
block|}
return|return
name|numBlocks
return|;
block|}
block|}
end_class
end_unit
