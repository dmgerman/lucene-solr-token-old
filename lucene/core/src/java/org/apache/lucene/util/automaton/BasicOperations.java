begin_unit
begin_comment
comment|/*  * dk.brics.automaton  *   * Copyright (c) 2001-2009 Anders Moeller  * All rights reserved.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *   * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment
begin_package
DECL|package|org.apache.lucene.util.automaton
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|automaton
package|;
end_package
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|ArrayUtil
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|RamUsageEstimator
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|BitSet
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedList
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import
begin_comment
comment|/**  * Basic automata operations.  *   * @lucene.experimental  */
end_comment
begin_class
DECL|class|BasicOperations
specifier|final
specifier|public
class|class
name|BasicOperations
block|{
DECL|method|BasicOperations
specifier|private
name|BasicOperations
parameter_list|()
block|{}
comment|/**    * Returns an automaton that accepts the concatenation of the languages of the    * given automata.    *<p>    * Complexity: linear in number of states.    */
DECL|method|concatenate
specifier|static
specifier|public
name|Automaton
name|concatenate
parameter_list|(
name|Automaton
name|a1
parameter_list|,
name|Automaton
name|a2
parameter_list|)
block|{
if|if
condition|(
name|a1
operator|.
name|isSingleton
argument_list|()
operator|&&
name|a2
operator|.
name|isSingleton
argument_list|()
condition|)
return|return
name|BasicAutomata
operator|.
name|makeString
argument_list|(
name|a1
operator|.
name|singleton
operator|+
name|a2
operator|.
name|singleton
argument_list|)
return|;
if|if
condition|(
name|isEmpty
argument_list|(
name|a1
argument_list|)
operator|||
name|isEmpty
argument_list|(
name|a2
argument_list|)
condition|)
return|return
name|BasicAutomata
operator|.
name|makeEmpty
argument_list|()
return|;
comment|// adding epsilon transitions with the NFA concatenation algorithm
comment|// in this case always produces a resulting DFA, preventing expensive
comment|// redundant determinize() calls for this common case.
name|boolean
name|deterministic
init|=
name|a1
operator|.
name|isSingleton
argument_list|()
operator|&&
name|a2
operator|.
name|isDeterministic
argument_list|()
decl_stmt|;
if|if
condition|(
name|a1
operator|==
name|a2
condition|)
block|{
name|a1
operator|=
name|a1
operator|.
name|cloneExpanded
argument_list|()
expr_stmt|;
name|a2
operator|=
name|a2
operator|.
name|cloneExpanded
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|a1
operator|=
name|a1
operator|.
name|cloneExpandedIfRequired
argument_list|()
expr_stmt|;
name|a2
operator|=
name|a2
operator|.
name|cloneExpandedIfRequired
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|State
name|s
range|:
name|a1
operator|.
name|getAcceptStates
argument_list|()
control|)
block|{
name|s
operator|.
name|accept
operator|=
literal|false
expr_stmt|;
name|s
operator|.
name|addEpsilon
argument_list|(
name|a2
operator|.
name|initial
argument_list|)
expr_stmt|;
block|}
name|a1
operator|.
name|deterministic
operator|=
name|deterministic
expr_stmt|;
comment|//a1.clearHashCode();
name|a1
operator|.
name|clearNumberedStates
argument_list|()
expr_stmt|;
name|a1
operator|.
name|checkMinimizeAlways
argument_list|()
expr_stmt|;
return|return
name|a1
return|;
block|}
comment|/**    * Returns an automaton that accepts the concatenation of the languages of the    * given automata.    *<p>    * Complexity: linear in total number of states.    */
DECL|method|concatenate
specifier|static
specifier|public
name|Automaton
name|concatenate
parameter_list|(
name|List
argument_list|<
name|Automaton
argument_list|>
name|l
parameter_list|)
block|{
if|if
condition|(
name|l
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|BasicAutomata
operator|.
name|makeEmptyString
argument_list|()
return|;
name|boolean
name|all_singleton
init|=
literal|true
decl_stmt|;
for|for
control|(
name|Automaton
name|a
range|:
name|l
control|)
if|if
condition|(
operator|!
name|a
operator|.
name|isSingleton
argument_list|()
condition|)
block|{
name|all_singleton
operator|=
literal|false
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|all_singleton
condition|)
block|{
name|StringBuilder
name|b
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|Automaton
name|a
range|:
name|l
control|)
name|b
operator|.
name|append
argument_list|(
name|a
operator|.
name|singleton
argument_list|)
expr_stmt|;
return|return
name|BasicAutomata
operator|.
name|makeString
argument_list|(
name|b
operator|.
name|toString
argument_list|()
argument_list|)
return|;
block|}
else|else
block|{
for|for
control|(
name|Automaton
name|a
range|:
name|l
control|)
if|if
condition|(
name|BasicOperations
operator|.
name|isEmpty
argument_list|(
name|a
argument_list|)
condition|)
return|return
name|BasicAutomata
operator|.
name|makeEmpty
argument_list|()
return|;
name|Set
argument_list|<
name|Integer
argument_list|>
name|ids
init|=
operator|new
name|HashSet
argument_list|<
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|Automaton
name|a
range|:
name|l
control|)
name|ids
operator|.
name|add
argument_list|(
name|System
operator|.
name|identityHashCode
argument_list|(
name|a
argument_list|)
argument_list|)
expr_stmt|;
name|boolean
name|has_aliases
init|=
name|ids
operator|.
name|size
argument_list|()
operator|!=
name|l
operator|.
name|size
argument_list|()
decl_stmt|;
name|Automaton
name|b
init|=
name|l
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|has_aliases
condition|)
name|b
operator|=
name|b
operator|.
name|cloneExpanded
argument_list|()
expr_stmt|;
else|else
name|b
operator|=
name|b
operator|.
name|cloneExpandedIfRequired
argument_list|()
expr_stmt|;
name|Set
argument_list|<
name|State
argument_list|>
name|ac
init|=
name|b
operator|.
name|getAcceptStates
argument_list|()
decl_stmt|;
name|boolean
name|first
init|=
literal|true
decl_stmt|;
for|for
control|(
name|Automaton
name|a
range|:
name|l
control|)
if|if
condition|(
name|first
condition|)
name|first
operator|=
literal|false
expr_stmt|;
else|else
block|{
if|if
condition|(
name|a
operator|.
name|isEmptyString
argument_list|()
condition|)
continue|continue;
name|Automaton
name|aa
init|=
name|a
decl_stmt|;
if|if
condition|(
name|has_aliases
condition|)
name|aa
operator|=
name|aa
operator|.
name|cloneExpanded
argument_list|()
expr_stmt|;
else|else
name|aa
operator|=
name|aa
operator|.
name|cloneExpandedIfRequired
argument_list|()
expr_stmt|;
name|Set
argument_list|<
name|State
argument_list|>
name|ns
init|=
name|aa
operator|.
name|getAcceptStates
argument_list|()
decl_stmt|;
for|for
control|(
name|State
name|s
range|:
name|ac
control|)
block|{
name|s
operator|.
name|accept
operator|=
literal|false
expr_stmt|;
name|s
operator|.
name|addEpsilon
argument_list|(
name|aa
operator|.
name|initial
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|.
name|accept
condition|)
name|ns
operator|.
name|add
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
name|ac
operator|=
name|ns
expr_stmt|;
block|}
name|b
operator|.
name|deterministic
operator|=
literal|false
expr_stmt|;
comment|//b.clearHashCode();
name|b
operator|.
name|clearNumberedStates
argument_list|()
expr_stmt|;
name|b
operator|.
name|checkMinimizeAlways
argument_list|()
expr_stmt|;
return|return
name|b
return|;
block|}
block|}
comment|/**    * Returns an automaton that accepts the union of the empty string and the    * language of the given automaton.    *<p>    * Complexity: linear in number of states.    */
DECL|method|optional
specifier|static
specifier|public
name|Automaton
name|optional
parameter_list|(
name|Automaton
name|a
parameter_list|)
block|{
name|a
operator|=
name|a
operator|.
name|cloneExpandedIfRequired
argument_list|()
expr_stmt|;
name|State
name|s
init|=
operator|new
name|State
argument_list|()
decl_stmt|;
name|s
operator|.
name|addEpsilon
argument_list|(
name|a
operator|.
name|initial
argument_list|)
expr_stmt|;
name|s
operator|.
name|accept
operator|=
literal|true
expr_stmt|;
name|a
operator|.
name|initial
operator|=
name|s
expr_stmt|;
name|a
operator|.
name|deterministic
operator|=
literal|false
expr_stmt|;
comment|//a.clearHashCode();
name|a
operator|.
name|clearNumberedStates
argument_list|()
expr_stmt|;
name|a
operator|.
name|checkMinimizeAlways
argument_list|()
expr_stmt|;
return|return
name|a
return|;
block|}
comment|/**    * Returns an automaton that accepts the Kleene star (zero or more    * concatenated repetitions) of the language of the given automaton. Never    * modifies the input automaton language.    *<p>    * Complexity: linear in number of states.    */
DECL|method|repeat
specifier|static
specifier|public
name|Automaton
name|repeat
parameter_list|(
name|Automaton
name|a
parameter_list|)
block|{
name|a
operator|=
name|a
operator|.
name|cloneExpanded
argument_list|()
expr_stmt|;
name|State
name|s
init|=
operator|new
name|State
argument_list|()
decl_stmt|;
name|s
operator|.
name|accept
operator|=
literal|true
expr_stmt|;
name|s
operator|.
name|addEpsilon
argument_list|(
name|a
operator|.
name|initial
argument_list|)
expr_stmt|;
for|for
control|(
name|State
name|p
range|:
name|a
operator|.
name|getAcceptStates
argument_list|()
control|)
name|p
operator|.
name|addEpsilon
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|a
operator|.
name|initial
operator|=
name|s
expr_stmt|;
name|a
operator|.
name|deterministic
operator|=
literal|false
expr_stmt|;
comment|//a.clearHashCode();
name|a
operator|.
name|clearNumberedStates
argument_list|()
expr_stmt|;
name|a
operator|.
name|checkMinimizeAlways
argument_list|()
expr_stmt|;
return|return
name|a
return|;
block|}
comment|/**    * Returns an automaton that accepts<code>min</code> or more concatenated    * repetitions of the language of the given automaton.    *<p>    * Complexity: linear in number of states and in<code>min</code>.    */
DECL|method|repeat
specifier|static
specifier|public
name|Automaton
name|repeat
parameter_list|(
name|Automaton
name|a
parameter_list|,
name|int
name|min
parameter_list|)
block|{
if|if
condition|(
name|min
operator|==
literal|0
condition|)
return|return
name|repeat
argument_list|(
name|a
argument_list|)
return|;
name|List
argument_list|<
name|Automaton
argument_list|>
name|as
init|=
operator|new
name|ArrayList
argument_list|<
name|Automaton
argument_list|>
argument_list|()
decl_stmt|;
while|while
condition|(
name|min
operator|--
operator|>
literal|0
condition|)
name|as
operator|.
name|add
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|as
operator|.
name|add
argument_list|(
name|repeat
argument_list|(
name|a
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|concatenate
argument_list|(
name|as
argument_list|)
return|;
block|}
comment|/**    * Returns an automaton that accepts between<code>min</code> and    *<code>max</code> (including both) concatenated repetitions of the language    * of the given automaton.    *<p>    * Complexity: linear in number of states and in<code>min</code> and    *<code>max</code>.    */
DECL|method|repeat
specifier|static
specifier|public
name|Automaton
name|repeat
parameter_list|(
name|Automaton
name|a
parameter_list|,
name|int
name|min
parameter_list|,
name|int
name|max
parameter_list|)
block|{
if|if
condition|(
name|min
operator|>
name|max
condition|)
return|return
name|BasicAutomata
operator|.
name|makeEmpty
argument_list|()
return|;
name|max
operator|-=
name|min
expr_stmt|;
name|a
operator|.
name|expandSingleton
argument_list|()
expr_stmt|;
name|Automaton
name|b
decl_stmt|;
if|if
condition|(
name|min
operator|==
literal|0
condition|)
name|b
operator|=
name|BasicAutomata
operator|.
name|makeEmptyString
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|min
operator|==
literal|1
condition|)
name|b
operator|=
name|a
operator|.
name|clone
argument_list|()
expr_stmt|;
else|else
block|{
name|List
argument_list|<
name|Automaton
argument_list|>
name|as
init|=
operator|new
name|ArrayList
argument_list|<
name|Automaton
argument_list|>
argument_list|()
decl_stmt|;
while|while
condition|(
name|min
operator|--
operator|>
literal|0
condition|)
name|as
operator|.
name|add
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|b
operator|=
name|concatenate
argument_list|(
name|as
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|max
operator|>
literal|0
condition|)
block|{
name|Automaton
name|d
init|=
name|a
operator|.
name|clone
argument_list|()
decl_stmt|;
while|while
condition|(
operator|--
name|max
operator|>
literal|0
condition|)
block|{
name|Automaton
name|c
init|=
name|a
operator|.
name|clone
argument_list|()
decl_stmt|;
for|for
control|(
name|State
name|p
range|:
name|c
operator|.
name|getAcceptStates
argument_list|()
control|)
name|p
operator|.
name|addEpsilon
argument_list|(
name|d
operator|.
name|initial
argument_list|)
expr_stmt|;
name|d
operator|=
name|c
expr_stmt|;
block|}
for|for
control|(
name|State
name|p
range|:
name|b
operator|.
name|getAcceptStates
argument_list|()
control|)
name|p
operator|.
name|addEpsilon
argument_list|(
name|d
operator|.
name|initial
argument_list|)
expr_stmt|;
name|b
operator|.
name|deterministic
operator|=
literal|false
expr_stmt|;
comment|//b.clearHashCode();
name|b
operator|.
name|clearNumberedStates
argument_list|()
expr_stmt|;
name|b
operator|.
name|checkMinimizeAlways
argument_list|()
expr_stmt|;
block|}
return|return
name|b
return|;
block|}
comment|/**    * Returns a (deterministic) automaton that accepts the complement of the    * language of the given automaton.    *<p>    * Complexity: linear in number of states (if already deterministic).    */
DECL|method|complement
specifier|static
specifier|public
name|Automaton
name|complement
parameter_list|(
name|Automaton
name|a
parameter_list|)
block|{
name|a
operator|=
name|a
operator|.
name|cloneExpandedIfRequired
argument_list|()
expr_stmt|;
name|a
operator|.
name|determinize
argument_list|()
expr_stmt|;
name|a
operator|.
name|totalize
argument_list|()
expr_stmt|;
for|for
control|(
name|State
name|p
range|:
name|a
operator|.
name|getNumberedStates
argument_list|()
control|)
name|p
operator|.
name|accept
operator|=
operator|!
name|p
operator|.
name|accept
expr_stmt|;
name|a
operator|.
name|removeDeadTransitions
argument_list|()
expr_stmt|;
return|return
name|a
return|;
block|}
comment|/**    * Returns a (deterministic) automaton that accepts the intersection of the    * language of<code>a1</code> and the complement of the language of    *<code>a2</code>. As a side-effect, the automata may be determinized, if not    * already deterministic.    *<p>    * Complexity: quadratic in number of states (if already deterministic).    */
DECL|method|minus
specifier|static
specifier|public
name|Automaton
name|minus
parameter_list|(
name|Automaton
name|a1
parameter_list|,
name|Automaton
name|a2
parameter_list|)
block|{
if|if
condition|(
name|BasicOperations
operator|.
name|isEmpty
argument_list|(
name|a1
argument_list|)
operator|||
name|a1
operator|==
name|a2
condition|)
return|return
name|BasicAutomata
operator|.
name|makeEmpty
argument_list|()
return|;
if|if
condition|(
name|BasicOperations
operator|.
name|isEmpty
argument_list|(
name|a2
argument_list|)
condition|)
return|return
name|a1
operator|.
name|cloneIfRequired
argument_list|()
return|;
if|if
condition|(
name|a1
operator|.
name|isSingleton
argument_list|()
condition|)
block|{
if|if
condition|(
name|BasicOperations
operator|.
name|run
argument_list|(
name|a2
argument_list|,
name|a1
operator|.
name|singleton
argument_list|)
condition|)
return|return
name|BasicAutomata
operator|.
name|makeEmpty
argument_list|()
return|;
else|else
return|return
name|a1
operator|.
name|cloneIfRequired
argument_list|()
return|;
block|}
return|return
name|intersection
argument_list|(
name|a1
argument_list|,
name|a2
operator|.
name|complement
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Returns an automaton that accepts the intersection of the languages of the    * given automata. Never modifies the input automata languages.    *<p>    * Complexity: quadratic in number of states.    */
DECL|method|intersection
specifier|static
specifier|public
name|Automaton
name|intersection
parameter_list|(
name|Automaton
name|a1
parameter_list|,
name|Automaton
name|a2
parameter_list|)
block|{
if|if
condition|(
name|a1
operator|.
name|isSingleton
argument_list|()
condition|)
block|{
if|if
condition|(
name|BasicOperations
operator|.
name|run
argument_list|(
name|a2
argument_list|,
name|a1
operator|.
name|singleton
argument_list|)
condition|)
return|return
name|a1
operator|.
name|cloneIfRequired
argument_list|()
return|;
else|else
return|return
name|BasicAutomata
operator|.
name|makeEmpty
argument_list|()
return|;
block|}
if|if
condition|(
name|a2
operator|.
name|isSingleton
argument_list|()
condition|)
block|{
if|if
condition|(
name|BasicOperations
operator|.
name|run
argument_list|(
name|a1
argument_list|,
name|a2
operator|.
name|singleton
argument_list|)
condition|)
return|return
name|a2
operator|.
name|cloneIfRequired
argument_list|()
return|;
else|else
return|return
name|BasicAutomata
operator|.
name|makeEmpty
argument_list|()
return|;
block|}
if|if
condition|(
name|a1
operator|==
name|a2
condition|)
return|return
name|a1
operator|.
name|cloneIfRequired
argument_list|()
return|;
name|Transition
index|[]
index|[]
name|transitions1
init|=
name|a1
operator|.
name|getSortedTransitions
argument_list|()
decl_stmt|;
name|Transition
index|[]
index|[]
name|transitions2
init|=
name|a2
operator|.
name|getSortedTransitions
argument_list|()
decl_stmt|;
name|Automaton
name|c
init|=
operator|new
name|Automaton
argument_list|()
decl_stmt|;
name|LinkedList
argument_list|<
name|StatePair
argument_list|>
name|worklist
init|=
operator|new
name|LinkedList
argument_list|<
name|StatePair
argument_list|>
argument_list|()
decl_stmt|;
name|HashMap
argument_list|<
name|StatePair
argument_list|,
name|StatePair
argument_list|>
name|newstates
init|=
operator|new
name|HashMap
argument_list|<
name|StatePair
argument_list|,
name|StatePair
argument_list|>
argument_list|()
decl_stmt|;
name|StatePair
name|p
init|=
operator|new
name|StatePair
argument_list|(
name|c
operator|.
name|initial
argument_list|,
name|a1
operator|.
name|initial
argument_list|,
name|a2
operator|.
name|initial
argument_list|)
decl_stmt|;
name|worklist
operator|.
name|add
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|newstates
operator|.
name|put
argument_list|(
name|p
argument_list|,
name|p
argument_list|)
expr_stmt|;
while|while
condition|(
name|worklist
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|p
operator|=
name|worklist
operator|.
name|removeFirst
argument_list|()
expr_stmt|;
name|p
operator|.
name|s
operator|.
name|accept
operator|=
name|p
operator|.
name|s1
operator|.
name|accept
operator|&&
name|p
operator|.
name|s2
operator|.
name|accept
expr_stmt|;
name|Transition
index|[]
name|t1
init|=
name|transitions1
index|[
name|p
operator|.
name|s1
operator|.
name|number
index|]
decl_stmt|;
name|Transition
index|[]
name|t2
init|=
name|transitions2
index|[
name|p
operator|.
name|s2
operator|.
name|number
index|]
decl_stmt|;
for|for
control|(
name|int
name|n1
init|=
literal|0
init|,
name|b2
init|=
literal|0
init|;
name|n1
operator|<
name|t1
operator|.
name|length
condition|;
name|n1
operator|++
control|)
block|{
while|while
condition|(
name|b2
operator|<
name|t2
operator|.
name|length
operator|&&
name|t2
index|[
name|b2
index|]
operator|.
name|max
operator|<
name|t1
index|[
name|n1
index|]
operator|.
name|min
condition|)
name|b2
operator|++
expr_stmt|;
for|for
control|(
name|int
name|n2
init|=
name|b2
init|;
name|n2
operator|<
name|t2
operator|.
name|length
operator|&&
name|t1
index|[
name|n1
index|]
operator|.
name|max
operator|>=
name|t2
index|[
name|n2
index|]
operator|.
name|min
condition|;
name|n2
operator|++
control|)
if|if
condition|(
name|t2
index|[
name|n2
index|]
operator|.
name|max
operator|>=
name|t1
index|[
name|n1
index|]
operator|.
name|min
condition|)
block|{
name|StatePair
name|q
init|=
operator|new
name|StatePair
argument_list|(
name|t1
index|[
name|n1
index|]
operator|.
name|to
argument_list|,
name|t2
index|[
name|n2
index|]
operator|.
name|to
argument_list|)
decl_stmt|;
name|StatePair
name|r
init|=
name|newstates
operator|.
name|get
argument_list|(
name|q
argument_list|)
decl_stmt|;
if|if
condition|(
name|r
operator|==
literal|null
condition|)
block|{
name|q
operator|.
name|s
operator|=
operator|new
name|State
argument_list|()
expr_stmt|;
name|worklist
operator|.
name|add
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|newstates
operator|.
name|put
argument_list|(
name|q
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|r
operator|=
name|q
expr_stmt|;
block|}
name|int
name|min
init|=
name|t1
index|[
name|n1
index|]
operator|.
name|min
operator|>
name|t2
index|[
name|n2
index|]
operator|.
name|min
condition|?
name|t1
index|[
name|n1
index|]
operator|.
name|min
else|:
name|t2
index|[
name|n2
index|]
operator|.
name|min
decl_stmt|;
name|int
name|max
init|=
name|t1
index|[
name|n1
index|]
operator|.
name|max
operator|<
name|t2
index|[
name|n2
index|]
operator|.
name|max
condition|?
name|t1
index|[
name|n1
index|]
operator|.
name|max
else|:
name|t2
index|[
name|n2
index|]
operator|.
name|max
decl_stmt|;
name|p
operator|.
name|s
operator|.
name|addTransition
argument_list|(
operator|new
name|Transition
argument_list|(
name|min
argument_list|,
name|max
argument_list|,
name|r
operator|.
name|s
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|c
operator|.
name|deterministic
operator|=
name|a1
operator|.
name|deterministic
operator|&&
name|a2
operator|.
name|deterministic
expr_stmt|;
name|c
operator|.
name|removeDeadTransitions
argument_list|()
expr_stmt|;
name|c
operator|.
name|checkMinimizeAlways
argument_list|()
expr_stmt|;
return|return
name|c
return|;
block|}
comment|/** Returns true if these two automata accept exactly the    *  same language.  This is a costly computation!  Note    *  also that a1 and a2 will be determinized as a side    *  effect. */
DECL|method|sameLanguage
specifier|public
specifier|static
name|boolean
name|sameLanguage
parameter_list|(
name|Automaton
name|a1
parameter_list|,
name|Automaton
name|a2
parameter_list|)
block|{
if|if
condition|(
name|a1
operator|==
name|a2
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
name|a1
operator|.
name|isSingleton
argument_list|()
operator|&&
name|a2
operator|.
name|isSingleton
argument_list|()
condition|)
block|{
return|return
name|a1
operator|.
name|singleton
operator|.
name|equals
argument_list|(
name|a2
operator|.
name|singleton
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|a1
operator|.
name|isSingleton
argument_list|()
condition|)
block|{
comment|// subsetOf is faster if the first automaton is a singleton
return|return
name|subsetOf
argument_list|(
name|a1
argument_list|,
name|a2
argument_list|)
operator|&&
name|subsetOf
argument_list|(
name|a2
argument_list|,
name|a1
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|subsetOf
argument_list|(
name|a2
argument_list|,
name|a1
argument_list|)
operator|&&
name|subsetOf
argument_list|(
name|a1
argument_list|,
name|a2
argument_list|)
return|;
block|}
block|}
comment|/**    * Returns true if the language of<code>a1</code> is a subset of the language    * of<code>a2</code>. As a side-effect,<code>a2</code> is determinized if    * not already marked as deterministic.    *<p>    * Complexity: quadratic in number of states.    */
DECL|method|subsetOf
specifier|public
specifier|static
name|boolean
name|subsetOf
parameter_list|(
name|Automaton
name|a1
parameter_list|,
name|Automaton
name|a2
parameter_list|)
block|{
if|if
condition|(
name|a1
operator|==
name|a2
condition|)
return|return
literal|true
return|;
if|if
condition|(
name|a1
operator|.
name|isSingleton
argument_list|()
condition|)
block|{
if|if
condition|(
name|a2
operator|.
name|isSingleton
argument_list|()
condition|)
return|return
name|a1
operator|.
name|singleton
operator|.
name|equals
argument_list|(
name|a2
operator|.
name|singleton
argument_list|)
return|;
return|return
name|BasicOperations
operator|.
name|run
argument_list|(
name|a2
argument_list|,
name|a1
operator|.
name|singleton
argument_list|)
return|;
block|}
name|a2
operator|.
name|determinize
argument_list|()
expr_stmt|;
name|Transition
index|[]
index|[]
name|transitions1
init|=
name|a1
operator|.
name|getSortedTransitions
argument_list|()
decl_stmt|;
name|Transition
index|[]
index|[]
name|transitions2
init|=
name|a2
operator|.
name|getSortedTransitions
argument_list|()
decl_stmt|;
name|LinkedList
argument_list|<
name|StatePair
argument_list|>
name|worklist
init|=
operator|new
name|LinkedList
argument_list|<
name|StatePair
argument_list|>
argument_list|()
decl_stmt|;
name|HashSet
argument_list|<
name|StatePair
argument_list|>
name|visited
init|=
operator|new
name|HashSet
argument_list|<
name|StatePair
argument_list|>
argument_list|()
decl_stmt|;
name|StatePair
name|p
init|=
operator|new
name|StatePair
argument_list|(
name|a1
operator|.
name|initial
argument_list|,
name|a2
operator|.
name|initial
argument_list|)
decl_stmt|;
name|worklist
operator|.
name|add
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|visited
operator|.
name|add
argument_list|(
name|p
argument_list|)
expr_stmt|;
while|while
condition|(
name|worklist
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|p
operator|=
name|worklist
operator|.
name|removeFirst
argument_list|()
expr_stmt|;
if|if
condition|(
name|p
operator|.
name|s1
operator|.
name|accept
operator|&&
operator|!
name|p
operator|.
name|s2
operator|.
name|accept
condition|)
block|{
return|return
literal|false
return|;
block|}
name|Transition
index|[]
name|t1
init|=
name|transitions1
index|[
name|p
operator|.
name|s1
operator|.
name|number
index|]
decl_stmt|;
name|Transition
index|[]
name|t2
init|=
name|transitions2
index|[
name|p
operator|.
name|s2
operator|.
name|number
index|]
decl_stmt|;
for|for
control|(
name|int
name|n1
init|=
literal|0
init|,
name|b2
init|=
literal|0
init|;
name|n1
operator|<
name|t1
operator|.
name|length
condition|;
name|n1
operator|++
control|)
block|{
while|while
condition|(
name|b2
operator|<
name|t2
operator|.
name|length
operator|&&
name|t2
index|[
name|b2
index|]
operator|.
name|max
operator|<
name|t1
index|[
name|n1
index|]
operator|.
name|min
condition|)
name|b2
operator|++
expr_stmt|;
name|int
name|min1
init|=
name|t1
index|[
name|n1
index|]
operator|.
name|min
decl_stmt|,
name|max1
init|=
name|t1
index|[
name|n1
index|]
operator|.
name|max
decl_stmt|;
for|for
control|(
name|int
name|n2
init|=
name|b2
init|;
name|n2
operator|<
name|t2
operator|.
name|length
operator|&&
name|t1
index|[
name|n1
index|]
operator|.
name|max
operator|>=
name|t2
index|[
name|n2
index|]
operator|.
name|min
condition|;
name|n2
operator|++
control|)
block|{
if|if
condition|(
name|t2
index|[
name|n2
index|]
operator|.
name|min
operator|>
name|min1
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|t2
index|[
name|n2
index|]
operator|.
name|max
operator|<
name|Character
operator|.
name|MAX_CODE_POINT
condition|)
name|min1
operator|=
name|t2
index|[
name|n2
index|]
operator|.
name|max
operator|+
literal|1
expr_stmt|;
else|else
block|{
name|min1
operator|=
name|Character
operator|.
name|MAX_CODE_POINT
expr_stmt|;
name|max1
operator|=
name|Character
operator|.
name|MIN_CODE_POINT
expr_stmt|;
block|}
name|StatePair
name|q
init|=
operator|new
name|StatePair
argument_list|(
name|t1
index|[
name|n1
index|]
operator|.
name|to
argument_list|,
name|t2
index|[
name|n2
index|]
operator|.
name|to
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|visited
operator|.
name|contains
argument_list|(
name|q
argument_list|)
condition|)
block|{
name|worklist
operator|.
name|add
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|visited
operator|.
name|add
argument_list|(
name|q
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|min1
operator|<=
name|max1
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
block|}
return|return
literal|true
return|;
block|}
comment|/**    * Returns an automaton that accepts the union of the languages of the given    * automata.    *<p>    * Complexity: linear in number of states.    */
DECL|method|union
specifier|public
specifier|static
name|Automaton
name|union
parameter_list|(
name|Automaton
name|a1
parameter_list|,
name|Automaton
name|a2
parameter_list|)
block|{
if|if
condition|(
operator|(
name|a1
operator|.
name|isSingleton
argument_list|()
operator|&&
name|a2
operator|.
name|isSingleton
argument_list|()
operator|&&
name|a1
operator|.
name|singleton
operator|.
name|equals
argument_list|(
name|a2
operator|.
name|singleton
argument_list|)
operator|)
operator|||
name|a1
operator|==
name|a2
condition|)
return|return
name|a1
operator|.
name|cloneIfRequired
argument_list|()
return|;
if|if
condition|(
name|a1
operator|==
name|a2
condition|)
block|{
name|a1
operator|=
name|a1
operator|.
name|cloneExpanded
argument_list|()
expr_stmt|;
name|a2
operator|=
name|a2
operator|.
name|cloneExpanded
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|a1
operator|=
name|a1
operator|.
name|cloneExpandedIfRequired
argument_list|()
expr_stmt|;
name|a2
operator|=
name|a2
operator|.
name|cloneExpandedIfRequired
argument_list|()
expr_stmt|;
block|}
name|State
name|s
init|=
operator|new
name|State
argument_list|()
decl_stmt|;
name|s
operator|.
name|addEpsilon
argument_list|(
name|a1
operator|.
name|initial
argument_list|)
expr_stmt|;
name|s
operator|.
name|addEpsilon
argument_list|(
name|a2
operator|.
name|initial
argument_list|)
expr_stmt|;
name|a1
operator|.
name|initial
operator|=
name|s
expr_stmt|;
name|a1
operator|.
name|deterministic
operator|=
literal|false
expr_stmt|;
comment|//a1.clearHashCode();
name|a1
operator|.
name|clearNumberedStates
argument_list|()
expr_stmt|;
name|a1
operator|.
name|checkMinimizeAlways
argument_list|()
expr_stmt|;
return|return
name|a1
return|;
block|}
comment|/**    * Returns an automaton that accepts the union of the languages of the given    * automata.    *<p>    * Complexity: linear in number of states.    */
DECL|method|union
specifier|public
specifier|static
name|Automaton
name|union
parameter_list|(
name|Collection
argument_list|<
name|Automaton
argument_list|>
name|l
parameter_list|)
block|{
name|Set
argument_list|<
name|Integer
argument_list|>
name|ids
init|=
operator|new
name|HashSet
argument_list|<
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|Automaton
name|a
range|:
name|l
control|)
name|ids
operator|.
name|add
argument_list|(
name|System
operator|.
name|identityHashCode
argument_list|(
name|a
argument_list|)
argument_list|)
expr_stmt|;
name|boolean
name|has_aliases
init|=
name|ids
operator|.
name|size
argument_list|()
operator|!=
name|l
operator|.
name|size
argument_list|()
decl_stmt|;
name|State
name|s
init|=
operator|new
name|State
argument_list|()
decl_stmt|;
for|for
control|(
name|Automaton
name|b
range|:
name|l
control|)
block|{
if|if
condition|(
name|BasicOperations
operator|.
name|isEmpty
argument_list|(
name|b
argument_list|)
condition|)
continue|continue;
name|Automaton
name|bb
init|=
name|b
decl_stmt|;
if|if
condition|(
name|has_aliases
condition|)
name|bb
operator|=
name|bb
operator|.
name|cloneExpanded
argument_list|()
expr_stmt|;
else|else
name|bb
operator|=
name|bb
operator|.
name|cloneExpandedIfRequired
argument_list|()
expr_stmt|;
name|s
operator|.
name|addEpsilon
argument_list|(
name|bb
operator|.
name|initial
argument_list|)
expr_stmt|;
block|}
name|Automaton
name|a
init|=
operator|new
name|Automaton
argument_list|()
decl_stmt|;
name|a
operator|.
name|initial
operator|=
name|s
expr_stmt|;
name|a
operator|.
name|deterministic
operator|=
literal|false
expr_stmt|;
comment|//a.clearHashCode();
name|a
operator|.
name|clearNumberedStates
argument_list|()
expr_stmt|;
name|a
operator|.
name|checkMinimizeAlways
argument_list|()
expr_stmt|;
return|return
name|a
return|;
block|}
comment|// Simple custom ArrayList<Transition>
DECL|class|TransitionList
specifier|private
specifier|final
specifier|static
class|class
name|TransitionList
block|{
DECL|field|transitions
name|Transition
index|[]
name|transitions
init|=
operator|new
name|Transition
index|[
literal|2
index|]
decl_stmt|;
DECL|field|count
name|int
name|count
decl_stmt|;
DECL|method|add
specifier|public
name|void
name|add
parameter_list|(
name|Transition
name|t
parameter_list|)
block|{
if|if
condition|(
name|transitions
operator|.
name|length
operator|==
name|count
condition|)
block|{
name|Transition
index|[]
name|newArray
init|=
operator|new
name|Transition
index|[
name|ArrayUtil
operator|.
name|oversize
argument_list|(
literal|1
operator|+
name|count
argument_list|,
name|RamUsageEstimator
operator|.
name|NUM_BYTES_OBJECT_REF
argument_list|)
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|transitions
argument_list|,
literal|0
argument_list|,
name|newArray
argument_list|,
literal|0
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|transitions
operator|=
name|newArray
expr_stmt|;
block|}
name|transitions
index|[
name|count
operator|++
index|]
operator|=
name|t
expr_stmt|;
block|}
block|}
comment|// Holds all transitions that start on this int point, or
comment|// end at this point-1
DECL|class|PointTransitions
specifier|private
specifier|final
specifier|static
class|class
name|PointTransitions
implements|implements
name|Comparable
argument_list|<
name|PointTransitions
argument_list|>
block|{
DECL|field|point
name|int
name|point
decl_stmt|;
DECL|field|ends
specifier|final
name|TransitionList
name|ends
init|=
operator|new
name|TransitionList
argument_list|()
decl_stmt|;
DECL|field|starts
specifier|final
name|TransitionList
name|starts
init|=
operator|new
name|TransitionList
argument_list|()
decl_stmt|;
DECL|method|compareTo
specifier|public
name|int
name|compareTo
parameter_list|(
name|PointTransitions
name|other
parameter_list|)
block|{
return|return
name|point
operator|-
name|other
operator|.
name|point
return|;
block|}
DECL|method|reset
specifier|public
name|void
name|reset
parameter_list|(
name|int
name|point
parameter_list|)
block|{
name|this
operator|.
name|point
operator|=
name|point
expr_stmt|;
name|ends
operator|.
name|count
operator|=
literal|0
expr_stmt|;
name|starts
operator|.
name|count
operator|=
literal|0
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|equals
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|other
parameter_list|)
block|{
return|return
operator|(
operator|(
name|PointTransitions
operator|)
name|other
operator|)
operator|.
name|point
operator|==
name|point
return|;
block|}
annotation|@
name|Override
DECL|method|hashCode
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
name|point
return|;
block|}
block|}
DECL|class|PointTransitionSet
specifier|private
specifier|final
specifier|static
class|class
name|PointTransitionSet
block|{
DECL|field|count
name|int
name|count
decl_stmt|;
DECL|field|points
name|PointTransitions
index|[]
name|points
init|=
operator|new
name|PointTransitions
index|[
literal|5
index|]
decl_stmt|;
DECL|field|HASHMAP_CUTOVER
specifier|private
specifier|final
specifier|static
name|int
name|HASHMAP_CUTOVER
init|=
literal|30
decl_stmt|;
DECL|field|map
specifier|private
specifier|final
name|HashMap
argument_list|<
name|Integer
argument_list|,
name|PointTransitions
argument_list|>
name|map
init|=
operator|new
name|HashMap
argument_list|<
name|Integer
argument_list|,
name|PointTransitions
argument_list|>
argument_list|()
decl_stmt|;
DECL|field|useHash
specifier|private
name|boolean
name|useHash
init|=
literal|false
decl_stmt|;
DECL|method|next
specifier|private
name|PointTransitions
name|next
parameter_list|(
name|int
name|point
parameter_list|)
block|{
comment|// 1st time we are seeing this point
if|if
condition|(
name|count
operator|==
name|points
operator|.
name|length
condition|)
block|{
specifier|final
name|PointTransitions
index|[]
name|newArray
init|=
operator|new
name|PointTransitions
index|[
name|ArrayUtil
operator|.
name|oversize
argument_list|(
literal|1
operator|+
name|count
argument_list|,
name|RamUsageEstimator
operator|.
name|NUM_BYTES_OBJECT_REF
argument_list|)
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|points
argument_list|,
literal|0
argument_list|,
name|newArray
argument_list|,
literal|0
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|points
operator|=
name|newArray
expr_stmt|;
block|}
name|PointTransitions
name|points0
init|=
name|points
index|[
name|count
index|]
decl_stmt|;
if|if
condition|(
name|points0
operator|==
literal|null
condition|)
block|{
name|points0
operator|=
name|points
index|[
name|count
index|]
operator|=
operator|new
name|PointTransitions
argument_list|()
expr_stmt|;
block|}
name|points0
operator|.
name|reset
argument_list|(
name|point
argument_list|)
expr_stmt|;
name|count
operator|++
expr_stmt|;
return|return
name|points0
return|;
block|}
DECL|method|find
specifier|private
name|PointTransitions
name|find
parameter_list|(
name|int
name|point
parameter_list|)
block|{
if|if
condition|(
name|useHash
condition|)
block|{
specifier|final
name|Integer
name|pi
init|=
name|point
decl_stmt|;
name|PointTransitions
name|p
init|=
name|map
operator|.
name|get
argument_list|(
name|pi
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
operator|==
literal|null
condition|)
block|{
name|p
operator|=
name|next
argument_list|(
name|point
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
name|pi
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
return|return
name|p
return|;
block|}
else|else
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|points
index|[
name|i
index|]
operator|.
name|point
operator|==
name|point
condition|)
block|{
return|return
name|points
index|[
name|i
index|]
return|;
block|}
block|}
specifier|final
name|PointTransitions
name|p
init|=
name|next
argument_list|(
name|point
argument_list|)
decl_stmt|;
if|if
condition|(
name|count
operator|==
name|HASHMAP_CUTOVER
condition|)
block|{
comment|// switch to HashMap on the fly
assert|assert
name|map
operator|.
name|size
argument_list|()
operator|==
literal|0
assert|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|map
operator|.
name|put
argument_list|(
name|points
index|[
name|i
index|]
operator|.
name|point
argument_list|,
name|points
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|useHash
operator|=
literal|true
expr_stmt|;
block|}
return|return
name|p
return|;
block|}
block|}
DECL|method|reset
specifier|public
name|void
name|reset
parameter_list|()
block|{
if|if
condition|(
name|useHash
condition|)
block|{
name|map
operator|.
name|clear
argument_list|()
expr_stmt|;
name|useHash
operator|=
literal|false
expr_stmt|;
block|}
name|count
operator|=
literal|0
expr_stmt|;
block|}
DECL|method|sort
specifier|public
name|void
name|sort
parameter_list|()
block|{
comment|// mergesort seems to perform better on already sorted arrays:
if|if
condition|(
name|count
operator|>
literal|1
condition|)
name|ArrayUtil
operator|.
name|mergeSort
argument_list|(
name|points
argument_list|,
literal|0
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
DECL|method|add
specifier|public
name|void
name|add
parameter_list|(
name|Transition
name|t
parameter_list|)
block|{
name|find
argument_list|(
name|t
operator|.
name|min
argument_list|)
operator|.
name|starts
operator|.
name|add
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|find
argument_list|(
literal|1
operator|+
name|t
operator|.
name|max
argument_list|)
operator|.
name|ends
operator|.
name|add
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
name|StringBuilder
name|s
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|s
operator|.
name|append
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
name|s
operator|.
name|append
argument_list|(
name|points
index|[
name|i
index|]
operator|.
name|point
argument_list|)
operator|.
name|append
argument_list|(
literal|':'
argument_list|)
operator|.
name|append
argument_list|(
name|points
index|[
name|i
index|]
operator|.
name|starts
operator|.
name|count
argument_list|)
operator|.
name|append
argument_list|(
literal|','
argument_list|)
operator|.
name|append
argument_list|(
name|points
index|[
name|i
index|]
operator|.
name|ends
operator|.
name|count
argument_list|)
expr_stmt|;
block|}
return|return
name|s
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
comment|/**    * Determinizes the given automaton.    *<p>    * Worst case complexity: exponential in number of states.    */
DECL|method|determinize
specifier|public
specifier|static
name|void
name|determinize
parameter_list|(
name|Automaton
name|a
parameter_list|)
block|{
if|if
condition|(
name|a
operator|.
name|deterministic
operator|||
name|a
operator|.
name|isSingleton
argument_list|()
condition|)
block|{
return|return;
block|}
specifier|final
name|State
index|[]
name|allStates
init|=
name|a
operator|.
name|getNumberedStates
argument_list|()
decl_stmt|;
comment|// subset construction
specifier|final
name|boolean
name|initAccept
init|=
name|a
operator|.
name|initial
operator|.
name|accept
decl_stmt|;
specifier|final
name|int
name|initNumber
init|=
name|a
operator|.
name|initial
operator|.
name|number
decl_stmt|;
name|a
operator|.
name|initial
operator|=
operator|new
name|State
argument_list|()
expr_stmt|;
name|SortedIntSet
operator|.
name|FrozenIntSet
name|initialset
init|=
operator|new
name|SortedIntSet
operator|.
name|FrozenIntSet
argument_list|(
name|initNumber
argument_list|,
name|a
operator|.
name|initial
argument_list|)
decl_stmt|;
name|LinkedList
argument_list|<
name|SortedIntSet
operator|.
name|FrozenIntSet
argument_list|>
name|worklist
init|=
operator|new
name|LinkedList
argument_list|<
name|SortedIntSet
operator|.
name|FrozenIntSet
argument_list|>
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|SortedIntSet
operator|.
name|FrozenIntSet
argument_list|,
name|State
argument_list|>
name|newstate
init|=
operator|new
name|HashMap
argument_list|<
name|SortedIntSet
operator|.
name|FrozenIntSet
argument_list|,
name|State
argument_list|>
argument_list|()
decl_stmt|;
name|worklist
operator|.
name|add
argument_list|(
name|initialset
argument_list|)
expr_stmt|;
name|a
operator|.
name|initial
operator|.
name|accept
operator|=
name|initAccept
expr_stmt|;
name|newstate
operator|.
name|put
argument_list|(
name|initialset
argument_list|,
name|a
operator|.
name|initial
argument_list|)
expr_stmt|;
name|int
name|newStateUpto
init|=
literal|0
decl_stmt|;
name|State
index|[]
name|newStatesArray
init|=
operator|new
name|State
index|[
literal|5
index|]
decl_stmt|;
name|newStatesArray
index|[
name|newStateUpto
index|]
operator|=
name|a
operator|.
name|initial
expr_stmt|;
name|a
operator|.
name|initial
operator|.
name|number
operator|=
name|newStateUpto
expr_stmt|;
name|newStateUpto
operator|++
expr_stmt|;
comment|// like Set<Integer,PointTransitions>
specifier|final
name|PointTransitionSet
name|points
init|=
operator|new
name|PointTransitionSet
argument_list|()
decl_stmt|;
comment|// like SortedMap<Integer,Integer>
specifier|final
name|SortedIntSet
name|statesSet
init|=
operator|new
name|SortedIntSet
argument_list|(
literal|5
argument_list|)
decl_stmt|;
while|while
condition|(
name|worklist
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|SortedIntSet
operator|.
name|FrozenIntSet
name|s
init|=
name|worklist
operator|.
name|removeFirst
argument_list|()
decl_stmt|;
comment|// Collate all outgoing transitions by min/1+max:
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|s
operator|.
name|values
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|State
name|s0
init|=
name|allStates
index|[
name|s
operator|.
name|values
index|[
name|i
index|]
index|]
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|s0
operator|.
name|numTransitions
condition|;
name|j
operator|++
control|)
block|{
name|points
operator|.
name|add
argument_list|(
name|s0
operator|.
name|transitionsArray
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|points
operator|.
name|count
operator|==
literal|0
condition|)
block|{
comment|// No outgoing transitions -- skip it
continue|continue;
block|}
name|points
operator|.
name|sort
argument_list|()
expr_stmt|;
name|int
name|lastPoint
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|accCount
init|=
literal|0
decl_stmt|;
specifier|final
name|State
name|r
init|=
name|s
operator|.
name|state
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|points
operator|.
name|count
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|int
name|point
init|=
name|points
operator|.
name|points
index|[
name|i
index|]
operator|.
name|point
decl_stmt|;
if|if
condition|(
name|statesSet
operator|.
name|upto
operator|>
literal|0
condition|)
block|{
assert|assert
name|lastPoint
operator|!=
operator|-
literal|1
assert|;
name|statesSet
operator|.
name|computeHash
argument_list|()
expr_stmt|;
name|State
name|q
init|=
name|newstate
operator|.
name|get
argument_list|(
name|statesSet
argument_list|)
decl_stmt|;
if|if
condition|(
name|q
operator|==
literal|null
condition|)
block|{
name|q
operator|=
operator|new
name|State
argument_list|()
expr_stmt|;
specifier|final
name|SortedIntSet
operator|.
name|FrozenIntSet
name|p
init|=
name|statesSet
operator|.
name|freeze
argument_list|(
name|q
argument_list|)
decl_stmt|;
name|worklist
operator|.
name|add
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|newStateUpto
operator|==
name|newStatesArray
operator|.
name|length
condition|)
block|{
specifier|final
name|State
index|[]
name|newArray
init|=
operator|new
name|State
index|[
name|ArrayUtil
operator|.
name|oversize
argument_list|(
literal|1
operator|+
name|newStateUpto
argument_list|,
name|RamUsageEstimator
operator|.
name|NUM_BYTES_OBJECT_REF
argument_list|)
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|newStatesArray
argument_list|,
literal|0
argument_list|,
name|newArray
argument_list|,
literal|0
argument_list|,
name|newStateUpto
argument_list|)
expr_stmt|;
name|newStatesArray
operator|=
name|newArray
expr_stmt|;
block|}
name|newStatesArray
index|[
name|newStateUpto
index|]
operator|=
name|q
expr_stmt|;
name|q
operator|.
name|number
operator|=
name|newStateUpto
expr_stmt|;
name|newStateUpto
operator|++
expr_stmt|;
name|q
operator|.
name|accept
operator|=
name|accCount
operator|>
literal|0
expr_stmt|;
name|newstate
operator|.
name|put
argument_list|(
name|p
argument_list|,
name|q
argument_list|)
expr_stmt|;
block|}
else|else
block|{
assert|assert
operator|(
name|accCount
operator|>
literal|0
condition|?
literal|true
else|:
literal|false
operator|)
operator|==
name|q
operator|.
name|accept
operator|:
literal|"accCount="
operator|+
name|accCount
operator|+
literal|" vs existing accept="
operator|+
name|q
operator|.
name|accept
operator|+
literal|" states="
operator|+
name|statesSet
assert|;
block|}
name|r
operator|.
name|addTransition
argument_list|(
operator|new
name|Transition
argument_list|(
name|lastPoint
argument_list|,
name|point
operator|-
literal|1
argument_list|,
name|q
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// process transitions that end on this point
comment|// (closes an overlapping interval)
name|Transition
index|[]
name|transitions
init|=
name|points
operator|.
name|points
index|[
name|i
index|]
operator|.
name|ends
operator|.
name|transitions
decl_stmt|;
name|int
name|limit
init|=
name|points
operator|.
name|points
index|[
name|i
index|]
operator|.
name|ends
operator|.
name|count
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|limit
condition|;
name|j
operator|++
control|)
block|{
specifier|final
name|Transition
name|t
init|=
name|transitions
index|[
name|j
index|]
decl_stmt|;
specifier|final
name|Integer
name|num
init|=
name|t
operator|.
name|to
operator|.
name|number
decl_stmt|;
name|statesSet
operator|.
name|decr
argument_list|(
name|num
argument_list|)
expr_stmt|;
name|accCount
operator|-=
name|t
operator|.
name|to
operator|.
name|accept
condition|?
literal|1
else|:
literal|0
expr_stmt|;
block|}
name|points
operator|.
name|points
index|[
name|i
index|]
operator|.
name|ends
operator|.
name|count
operator|=
literal|0
expr_stmt|;
comment|// process transitions that start on this point
comment|// (opens a new interval)
name|transitions
operator|=
name|points
operator|.
name|points
index|[
name|i
index|]
operator|.
name|starts
operator|.
name|transitions
expr_stmt|;
name|limit
operator|=
name|points
operator|.
name|points
index|[
name|i
index|]
operator|.
name|starts
operator|.
name|count
expr_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|limit
condition|;
name|j
operator|++
control|)
block|{
specifier|final
name|Transition
name|t
init|=
name|transitions
index|[
name|j
index|]
decl_stmt|;
specifier|final
name|Integer
name|num
init|=
name|t
operator|.
name|to
operator|.
name|number
decl_stmt|;
name|statesSet
operator|.
name|incr
argument_list|(
name|num
argument_list|)
expr_stmt|;
name|accCount
operator|+=
name|t
operator|.
name|to
operator|.
name|accept
condition|?
literal|1
else|:
literal|0
expr_stmt|;
block|}
name|lastPoint
operator|=
name|point
expr_stmt|;
name|points
operator|.
name|points
index|[
name|i
index|]
operator|.
name|starts
operator|.
name|count
operator|=
literal|0
expr_stmt|;
block|}
name|points
operator|.
name|reset
argument_list|()
expr_stmt|;
assert|assert
name|statesSet
operator|.
name|upto
operator|==
literal|0
operator|:
literal|"upto="
operator|+
name|statesSet
operator|.
name|upto
assert|;
block|}
name|a
operator|.
name|deterministic
operator|=
literal|true
expr_stmt|;
name|a
operator|.
name|setNumberedStates
argument_list|(
name|newStatesArray
argument_list|,
name|newStateUpto
argument_list|)
expr_stmt|;
block|}
comment|/**    * Adds epsilon transitions to the given automaton. This method adds extra    * character interval transitions that are equivalent to the given set of    * epsilon transitions.    *     * @param pairs collection of {@link StatePair} objects representing pairs of    *          source/destination states where epsilon transitions should be    *          added    */
DECL|method|addEpsilons
specifier|public
specifier|static
name|void
name|addEpsilons
parameter_list|(
name|Automaton
name|a
parameter_list|,
name|Collection
argument_list|<
name|StatePair
argument_list|>
name|pairs
parameter_list|)
block|{
name|a
operator|.
name|expandSingleton
argument_list|()
expr_stmt|;
name|HashMap
argument_list|<
name|State
argument_list|,
name|HashSet
argument_list|<
name|State
argument_list|>
argument_list|>
name|forward
init|=
operator|new
name|HashMap
argument_list|<
name|State
argument_list|,
name|HashSet
argument_list|<
name|State
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
name|HashMap
argument_list|<
name|State
argument_list|,
name|HashSet
argument_list|<
name|State
argument_list|>
argument_list|>
name|back
init|=
operator|new
name|HashMap
argument_list|<
name|State
argument_list|,
name|HashSet
argument_list|<
name|State
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|StatePair
name|p
range|:
name|pairs
control|)
block|{
name|HashSet
argument_list|<
name|State
argument_list|>
name|to
init|=
name|forward
operator|.
name|get
argument_list|(
name|p
operator|.
name|s1
argument_list|)
decl_stmt|;
if|if
condition|(
name|to
operator|==
literal|null
condition|)
block|{
name|to
operator|=
operator|new
name|HashSet
argument_list|<
name|State
argument_list|>
argument_list|()
expr_stmt|;
name|forward
operator|.
name|put
argument_list|(
name|p
operator|.
name|s1
argument_list|,
name|to
argument_list|)
expr_stmt|;
block|}
name|to
operator|.
name|add
argument_list|(
name|p
operator|.
name|s2
argument_list|)
expr_stmt|;
name|HashSet
argument_list|<
name|State
argument_list|>
name|from
init|=
name|back
operator|.
name|get
argument_list|(
name|p
operator|.
name|s2
argument_list|)
decl_stmt|;
if|if
condition|(
name|from
operator|==
literal|null
condition|)
block|{
name|from
operator|=
operator|new
name|HashSet
argument_list|<
name|State
argument_list|>
argument_list|()
expr_stmt|;
name|back
operator|.
name|put
argument_list|(
name|p
operator|.
name|s2
argument_list|,
name|from
argument_list|)
expr_stmt|;
block|}
name|from
operator|.
name|add
argument_list|(
name|p
operator|.
name|s1
argument_list|)
expr_stmt|;
block|}
comment|// calculate epsilon closure
name|LinkedList
argument_list|<
name|StatePair
argument_list|>
name|worklist
init|=
operator|new
name|LinkedList
argument_list|<
name|StatePair
argument_list|>
argument_list|(
name|pairs
argument_list|)
decl_stmt|;
name|HashSet
argument_list|<
name|StatePair
argument_list|>
name|workset
init|=
operator|new
name|HashSet
argument_list|<
name|StatePair
argument_list|>
argument_list|(
name|pairs
argument_list|)
decl_stmt|;
while|while
condition|(
operator|!
name|worklist
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|StatePair
name|p
init|=
name|worklist
operator|.
name|removeFirst
argument_list|()
decl_stmt|;
name|workset
operator|.
name|remove
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|HashSet
argument_list|<
name|State
argument_list|>
name|to
init|=
name|forward
operator|.
name|get
argument_list|(
name|p
operator|.
name|s2
argument_list|)
decl_stmt|;
name|HashSet
argument_list|<
name|State
argument_list|>
name|from
init|=
name|back
operator|.
name|get
argument_list|(
name|p
operator|.
name|s1
argument_list|)
decl_stmt|;
if|if
condition|(
name|to
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|State
name|s
range|:
name|to
control|)
block|{
name|StatePair
name|pp
init|=
operator|new
name|StatePair
argument_list|(
name|p
operator|.
name|s1
argument_list|,
name|s
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|pairs
operator|.
name|contains
argument_list|(
name|pp
argument_list|)
condition|)
block|{
name|pairs
operator|.
name|add
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|forward
operator|.
name|get
argument_list|(
name|p
operator|.
name|s1
argument_list|)
operator|.
name|add
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|back
operator|.
name|get
argument_list|(
name|s
argument_list|)
operator|.
name|add
argument_list|(
name|p
operator|.
name|s1
argument_list|)
expr_stmt|;
name|worklist
operator|.
name|add
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|workset
operator|.
name|add
argument_list|(
name|pp
argument_list|)
expr_stmt|;
if|if
condition|(
name|from
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|State
name|q
range|:
name|from
control|)
block|{
name|StatePair
name|qq
init|=
operator|new
name|StatePair
argument_list|(
name|q
argument_list|,
name|p
operator|.
name|s1
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|workset
operator|.
name|contains
argument_list|(
name|qq
argument_list|)
condition|)
block|{
name|worklist
operator|.
name|add
argument_list|(
name|qq
argument_list|)
expr_stmt|;
name|workset
operator|.
name|add
argument_list|(
name|qq
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
block|}
block|}
comment|// add transitions
for|for
control|(
name|StatePair
name|p
range|:
name|pairs
control|)
name|p
operator|.
name|s1
operator|.
name|addEpsilon
argument_list|(
name|p
operator|.
name|s2
argument_list|)
expr_stmt|;
name|a
operator|.
name|deterministic
operator|=
literal|false
expr_stmt|;
comment|//a.clearHashCode();
name|a
operator|.
name|clearNumberedStates
argument_list|()
expr_stmt|;
name|a
operator|.
name|checkMinimizeAlways
argument_list|()
expr_stmt|;
block|}
comment|/**    * Returns true if the given automaton accepts the empty string and nothing    * else.    */
DECL|method|isEmptyString
specifier|public
specifier|static
name|boolean
name|isEmptyString
parameter_list|(
name|Automaton
name|a
parameter_list|)
block|{
if|if
condition|(
name|a
operator|.
name|isSingleton
argument_list|()
condition|)
return|return
name|a
operator|.
name|singleton
operator|.
name|length
argument_list|()
operator|==
literal|0
return|;
else|else
return|return
name|a
operator|.
name|initial
operator|.
name|accept
operator|&&
name|a
operator|.
name|initial
operator|.
name|numTransitions
argument_list|()
operator|==
literal|0
return|;
block|}
comment|/**    * Returns true if the given automaton accepts no strings.    */
DECL|method|isEmpty
specifier|public
specifier|static
name|boolean
name|isEmpty
parameter_list|(
name|Automaton
name|a
parameter_list|)
block|{
if|if
condition|(
name|a
operator|.
name|isSingleton
argument_list|()
condition|)
return|return
literal|false
return|;
return|return
operator|!
name|a
operator|.
name|initial
operator|.
name|accept
operator|&&
name|a
operator|.
name|initial
operator|.
name|numTransitions
argument_list|()
operator|==
literal|0
return|;
block|}
comment|/**    * Returns true if the given automaton accepts all strings.    */
DECL|method|isTotal
specifier|public
specifier|static
name|boolean
name|isTotal
parameter_list|(
name|Automaton
name|a
parameter_list|)
block|{
if|if
condition|(
name|a
operator|.
name|isSingleton
argument_list|()
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|a
operator|.
name|initial
operator|.
name|accept
operator|&&
name|a
operator|.
name|initial
operator|.
name|numTransitions
argument_list|()
operator|==
literal|1
condition|)
block|{
name|Transition
name|t
init|=
name|a
operator|.
name|initial
operator|.
name|getTransitions
argument_list|()
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
decl_stmt|;
return|return
name|t
operator|.
name|to
operator|==
name|a
operator|.
name|initial
operator|&&
name|t
operator|.
name|min
operator|==
name|Character
operator|.
name|MIN_CODE_POINT
operator|&&
name|t
operator|.
name|max
operator|==
name|Character
operator|.
name|MAX_CODE_POINT
return|;
block|}
return|return
literal|false
return|;
block|}
comment|/**    * Returns true if the given string is accepted by the automaton.    *<p>    * Complexity: linear in the length of the string.    *<p>    *<b>Note:</b> for full performance, use the {@link RunAutomaton} class.    */
DECL|method|run
specifier|public
specifier|static
name|boolean
name|run
parameter_list|(
name|Automaton
name|a
parameter_list|,
name|String
name|s
parameter_list|)
block|{
if|if
condition|(
name|a
operator|.
name|isSingleton
argument_list|()
condition|)
return|return
name|s
operator|.
name|equals
argument_list|(
name|a
operator|.
name|singleton
argument_list|)
return|;
if|if
condition|(
name|a
operator|.
name|deterministic
condition|)
block|{
name|State
name|p
init|=
name|a
operator|.
name|initial
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|,
name|cp
init|=
literal|0
init|;
name|i
operator|<
name|s
operator|.
name|length
argument_list|()
condition|;
name|i
operator|+=
name|Character
operator|.
name|charCount
argument_list|(
name|cp
argument_list|)
control|)
block|{
name|State
name|q
init|=
name|p
operator|.
name|step
argument_list|(
name|cp
operator|=
name|s
operator|.
name|codePointAt
argument_list|(
name|i
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|q
operator|==
literal|null
condition|)
return|return
literal|false
return|;
name|p
operator|=
name|q
expr_stmt|;
block|}
return|return
name|p
operator|.
name|accept
return|;
block|}
else|else
block|{
name|State
index|[]
name|states
init|=
name|a
operator|.
name|getNumberedStates
argument_list|()
decl_stmt|;
name|LinkedList
argument_list|<
name|State
argument_list|>
name|pp
init|=
operator|new
name|LinkedList
argument_list|<
name|State
argument_list|>
argument_list|()
decl_stmt|;
name|LinkedList
argument_list|<
name|State
argument_list|>
name|pp_other
init|=
operator|new
name|LinkedList
argument_list|<
name|State
argument_list|>
argument_list|()
decl_stmt|;
name|BitSet
name|bb
init|=
operator|new
name|BitSet
argument_list|(
name|states
operator|.
name|length
argument_list|)
decl_stmt|;
name|BitSet
name|bb_other
init|=
operator|new
name|BitSet
argument_list|(
name|states
operator|.
name|length
argument_list|)
decl_stmt|;
name|pp
operator|.
name|add
argument_list|(
name|a
operator|.
name|initial
argument_list|)
expr_stmt|;
name|ArrayList
argument_list|<
name|State
argument_list|>
name|dest
init|=
operator|new
name|ArrayList
argument_list|<
name|State
argument_list|>
argument_list|()
decl_stmt|;
name|boolean
name|accept
init|=
name|a
operator|.
name|initial
operator|.
name|accept
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|,
name|c
init|=
literal|0
init|;
name|i
operator|<
name|s
operator|.
name|length
argument_list|()
condition|;
name|i
operator|+=
name|Character
operator|.
name|charCount
argument_list|(
name|c
argument_list|)
control|)
block|{
name|c
operator|=
name|s
operator|.
name|codePointAt
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|accept
operator|=
literal|false
expr_stmt|;
name|pp_other
operator|.
name|clear
argument_list|()
expr_stmt|;
name|bb_other
operator|.
name|clear
argument_list|()
expr_stmt|;
for|for
control|(
name|State
name|p
range|:
name|pp
control|)
block|{
name|dest
operator|.
name|clear
argument_list|()
expr_stmt|;
name|p
operator|.
name|step
argument_list|(
name|c
argument_list|,
name|dest
argument_list|)
expr_stmt|;
for|for
control|(
name|State
name|q
range|:
name|dest
control|)
block|{
if|if
condition|(
name|q
operator|.
name|accept
condition|)
name|accept
operator|=
literal|true
expr_stmt|;
if|if
condition|(
operator|!
name|bb_other
operator|.
name|get
argument_list|(
name|q
operator|.
name|number
argument_list|)
condition|)
block|{
name|bb_other
operator|.
name|set
argument_list|(
name|q
operator|.
name|number
argument_list|)
expr_stmt|;
name|pp_other
operator|.
name|add
argument_list|(
name|q
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|LinkedList
argument_list|<
name|State
argument_list|>
name|tp
init|=
name|pp
decl_stmt|;
name|pp
operator|=
name|pp_other
expr_stmt|;
name|pp_other
operator|=
name|tp
expr_stmt|;
name|BitSet
name|tb
init|=
name|bb
decl_stmt|;
name|bb
operator|=
name|bb_other
expr_stmt|;
name|bb_other
operator|=
name|tb
expr_stmt|;
block|}
return|return
name|accept
return|;
block|}
block|}
block|}
end_class
end_unit
