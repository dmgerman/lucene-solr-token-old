begin_unit
begin_comment
comment|/*  * dk.brics.automaton  *   * Copyright (c) 2001-2009 Anders Moeller  * All rights reserved.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *   * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment
begin_package
DECL|package|org.apache.lucene.util.automaton
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|automaton
package|;
end_package
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|BitSet
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedList
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|ArrayUtil
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|IntsRef
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|RamUsageEstimator
import|;
end_import
begin_comment
comment|/**  * Basic automata operations.  *   * @lucene.experimental  */
end_comment
begin_class
DECL|class|BasicOperations
specifier|final
specifier|public
class|class
name|BasicOperations
block|{
DECL|method|BasicOperations
specifier|private
name|BasicOperations
parameter_list|()
block|{}
comment|/**    * Returns an automaton that accepts the concatenation of the languages of the    * given automata.    *<p>    * Complexity: linear in total number of states.    */
DECL|method|concatenateLight
specifier|static
specifier|public
name|LightAutomaton
name|concatenateLight
parameter_list|(
name|LightAutomaton
name|a1
parameter_list|,
name|LightAutomaton
name|a2
parameter_list|)
block|{
comment|// nocommit we lost the two-arg optimization here (prepend tiny automaton in front of huge one)
return|return
name|concatenateLight
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|a1
argument_list|,
name|a2
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Returns an automaton that accepts the concatenation of the languages of the    * given automata.    *<p>    * Complexity: linear in total number of states.    */
DECL|method|concatenateLight
specifier|static
specifier|public
name|LightAutomaton
name|concatenateLight
parameter_list|(
name|List
argument_list|<
name|LightAutomaton
argument_list|>
name|l
parameter_list|)
block|{
name|LightAutomaton
name|result
init|=
operator|new
name|LightAutomaton
argument_list|()
decl_stmt|;
name|LightAutomaton
operator|.
name|Transition
name|scratch
init|=
operator|new
name|LightAutomaton
operator|.
name|Transition
argument_list|()
decl_stmt|;
comment|// First pass: create all states
for|for
control|(
name|LightAutomaton
name|a
range|:
name|l
control|)
block|{
name|int
name|numStates
init|=
name|a
operator|.
name|getNumStates
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|s
init|=
literal|0
init|;
name|s
operator|<
name|numStates
condition|;
name|s
operator|++
control|)
block|{
name|result
operator|.
name|createState
argument_list|()
expr_stmt|;
block|}
block|}
comment|// Second pass: add transitions, carefully linking accept
comment|// states of A to init state of next A:
name|int
name|stateOffset
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|l
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|LightAutomaton
name|a
init|=
name|l
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|int
name|numStates
init|=
name|a
operator|.
name|getNumStates
argument_list|()
decl_stmt|;
name|LightAutomaton
name|nextA
init|=
operator|(
name|i
operator|==
name|l
operator|.
name|size
argument_list|()
operator|-
literal|1
operator|)
condition|?
literal|null
else|:
name|l
operator|.
name|get
argument_list|(
name|i
operator|+
literal|1
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|s
init|=
literal|0
init|;
name|s
operator|<
name|numStates
condition|;
name|s
operator|++
control|)
block|{
name|int
name|numTransitions
init|=
name|a
operator|.
name|initTransition
argument_list|(
name|s
argument_list|,
name|scratch
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|t
init|=
literal|0
init|;
name|t
operator|<
name|numTransitions
condition|;
name|t
operator|++
control|)
block|{
name|a
operator|.
name|getNextTransition
argument_list|(
name|scratch
argument_list|)
expr_stmt|;
name|result
operator|.
name|addTransition
argument_list|(
name|stateOffset
operator|+
name|s
argument_list|,
name|stateOffset
operator|+
name|scratch
operator|.
name|dest
argument_list|,
name|scratch
operator|.
name|min
argument_list|,
name|scratch
operator|.
name|max
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|a
operator|.
name|isAccept
argument_list|(
name|s
argument_list|)
condition|)
block|{
name|LightAutomaton
name|followA
init|=
name|nextA
decl_stmt|;
name|int
name|followOffset
init|=
name|stateOffset
decl_stmt|;
name|int
name|upto
init|=
name|i
operator|+
literal|1
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
if|if
condition|(
name|followA
operator|!=
literal|null
condition|)
block|{
comment|// Adds a "virtual" epsilon transition:
name|numTransitions
operator|=
name|followA
operator|.
name|initTransition
argument_list|(
literal|0
argument_list|,
name|scratch
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|t
init|=
literal|0
init|;
name|t
operator|<
name|numTransitions
condition|;
name|t
operator|++
control|)
block|{
name|followA
operator|.
name|getNextTransition
argument_list|(
name|scratch
argument_list|)
expr_stmt|;
name|result
operator|.
name|addTransition
argument_list|(
name|stateOffset
operator|+
name|s
argument_list|,
name|followOffset
operator|+
name|numStates
operator|+
name|scratch
operator|.
name|dest
argument_list|,
name|scratch
operator|.
name|min
argument_list|,
name|scratch
operator|.
name|max
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|followA
operator|.
name|isAccept
argument_list|(
literal|0
argument_list|)
condition|)
block|{
comment|// Keep chaining if followA accepts empty string
name|followOffset
operator|+=
name|followA
operator|.
name|getNumStates
argument_list|()
expr_stmt|;
name|followA
operator|=
operator|(
name|upto
operator|==
name|l
operator|.
name|size
argument_list|()
operator|-
literal|1
operator|)
condition|?
literal|null
else|:
name|l
operator|.
name|get
argument_list|(
name|upto
operator|+
literal|1
argument_list|)
expr_stmt|;
name|upto
operator|++
expr_stmt|;
block|}
else|else
block|{
break|break;
block|}
block|}
else|else
block|{
name|result
operator|.
name|setAccept
argument_list|(
name|stateOffset
operator|+
name|s
argument_list|,
literal|true
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
name|stateOffset
operator|+=
name|numStates
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|.
name|getNumStates
argument_list|()
operator|==
literal|0
condition|)
block|{
name|result
operator|.
name|createState
argument_list|()
expr_stmt|;
block|}
name|result
operator|.
name|finish
argument_list|()
expr_stmt|;
return|return
name|result
return|;
block|}
comment|/**    * Returns an automaton that accepts the union of the empty string and the    * language of the given automaton.    *<p>    * Complexity: linear in number of states.    */
DECL|method|optionalLight
specifier|static
specifier|public
name|LightAutomaton
name|optionalLight
parameter_list|(
name|LightAutomaton
name|a
parameter_list|)
block|{
name|LightAutomaton
name|result
init|=
operator|new
name|LightAutomaton
argument_list|()
decl_stmt|;
name|result
operator|.
name|createState
argument_list|()
expr_stmt|;
name|result
operator|.
name|setAccept
argument_list|(
literal|0
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|int
name|numStates
init|=
name|a
operator|.
name|getNumStates
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numStates
condition|;
name|i
operator|++
control|)
block|{
name|result
operator|.
name|createState
argument_list|()
expr_stmt|;
name|result
operator|.
name|setAccept
argument_list|(
name|i
operator|+
literal|1
argument_list|,
name|a
operator|.
name|isAccept
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|LightAutomaton
operator|.
name|Transition
name|t
init|=
operator|new
name|LightAutomaton
operator|.
name|Transition
argument_list|()
decl_stmt|;
name|int
name|count
init|=
name|a
operator|.
name|initTransition
argument_list|(
literal|0
argument_list|,
name|t
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|a
operator|.
name|getNextTransition
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|result
operator|.
name|addTransition
argument_list|(
literal|0
argument_list|,
literal|1
operator|+
name|t
operator|.
name|dest
argument_list|,
name|t
operator|.
name|min
argument_list|,
name|t
operator|.
name|max
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numStates
condition|;
name|i
operator|++
control|)
block|{
name|count
operator|=
name|a
operator|.
name|initTransition
argument_list|(
name|i
argument_list|,
name|t
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|count
condition|;
name|j
operator|++
control|)
block|{
name|a
operator|.
name|getNextTransition
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|result
operator|.
name|addTransition
argument_list|(
literal|1
operator|+
name|t
operator|.
name|source
argument_list|,
literal|1
operator|+
name|t
operator|.
name|dest
argument_list|,
name|t
operator|.
name|min
argument_list|,
name|t
operator|.
name|max
argument_list|)
expr_stmt|;
block|}
block|}
name|result
operator|.
name|finish
argument_list|()
expr_stmt|;
return|return
name|result
return|;
block|}
comment|/**    * Returns an automaton that accepts the Kleene star (zero or more    * concatenated repetitions) of the language of the given automaton. Never    * modifies the input automaton language.    *<p>    * Complexity: linear in number of states.    */
DECL|method|repeatLight
specifier|static
specifier|public
name|LightAutomaton
name|repeatLight
parameter_list|(
name|LightAutomaton
name|a
parameter_list|)
block|{
name|LightAutomaton
operator|.
name|Builder
name|builder
init|=
operator|new
name|LightAutomaton
operator|.
name|Builder
argument_list|()
decl_stmt|;
name|builder
operator|.
name|createState
argument_list|()
expr_stmt|;
name|builder
operator|.
name|setAccept
argument_list|(
literal|0
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|builder
operator|.
name|copy
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|LightAutomaton
operator|.
name|Transition
name|t
init|=
operator|new
name|LightAutomaton
operator|.
name|Transition
argument_list|()
decl_stmt|;
name|int
name|count
init|=
name|a
operator|.
name|initTransition
argument_list|(
literal|0
argument_list|,
name|t
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|a
operator|.
name|getNextTransition
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|builder
operator|.
name|addTransition
argument_list|(
literal|0
argument_list|,
name|t
operator|.
name|dest
operator|+
literal|1
argument_list|,
name|t
operator|.
name|min
argument_list|,
name|t
operator|.
name|max
argument_list|)
expr_stmt|;
block|}
name|int
name|numStates
init|=
name|a
operator|.
name|getNumStates
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|s
init|=
literal|0
init|;
name|s
operator|<
name|numStates
condition|;
name|s
operator|++
control|)
block|{
if|if
condition|(
name|a
operator|.
name|isAccept
argument_list|(
name|s
argument_list|)
condition|)
block|{
name|count
operator|=
name|a
operator|.
name|initTransition
argument_list|(
literal|0
argument_list|,
name|t
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|a
operator|.
name|getNextTransition
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|builder
operator|.
name|addTransition
argument_list|(
name|s
operator|+
literal|1
argument_list|,
name|t
operator|.
name|dest
operator|+
literal|1
argument_list|,
name|t
operator|.
name|min
argument_list|,
name|t
operator|.
name|max
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|builder
operator|.
name|finish
argument_list|()
return|;
block|}
comment|// nocommit make this privately computed in LA
comment|/** Returns true if the automaton is deterministic. */
DECL|method|isDeterministic
specifier|public
specifier|static
name|boolean
name|isDeterministic
parameter_list|(
name|LightAutomaton
name|a
parameter_list|)
block|{
name|BitSet
name|done
init|=
operator|new
name|BitSet
argument_list|(
name|a
operator|.
name|getNumStates
argument_list|()
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Integer
argument_list|>
name|queue
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|queue
operator|.
name|add
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|done
operator|.
name|set
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|LightAutomaton
operator|.
name|Transition
name|t
init|=
operator|new
name|LightAutomaton
operator|.
name|Transition
argument_list|()
decl_stmt|;
while|while
condition|(
name|queue
operator|.
name|isEmpty
argument_list|()
operator|==
literal|false
condition|)
block|{
name|int
name|state
init|=
name|queue
operator|.
name|remove
argument_list|(
name|queue
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
decl_stmt|;
name|int
name|count
init|=
name|a
operator|.
name|initTransition
argument_list|(
name|state
argument_list|,
name|t
argument_list|)
decl_stmt|;
name|int
name|lastMax
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|a
operator|.
name|getNextTransition
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|.
name|min
operator|<=
name|lastMax
condition|)
block|{
return|return
literal|false
return|;
block|}
name|lastMax
operator|=
name|t
operator|.
name|max
expr_stmt|;
if|if
condition|(
name|done
operator|.
name|get
argument_list|(
name|t
operator|.
name|dest
argument_list|)
operator|==
literal|false
condition|)
block|{
name|done
operator|.
name|set
argument_list|(
name|t
operator|.
name|dest
argument_list|)
expr_stmt|;
name|queue
operator|.
name|add
argument_list|(
name|t
operator|.
name|dest
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
literal|true
return|;
block|}
comment|/**    * Returns an automaton that accepts<code>min</code> or more concatenated    * repetitions of the language of the given automaton.    *<p>    * Complexity: linear in number of states and in<code>min</code>.    */
DECL|method|repeatLight
specifier|static
specifier|public
name|LightAutomaton
name|repeatLight
parameter_list|(
name|LightAutomaton
name|a
parameter_list|,
name|int
name|min
parameter_list|)
block|{
if|if
condition|(
name|min
operator|==
literal|0
condition|)
block|{
return|return
name|repeatLight
argument_list|(
name|a
argument_list|)
return|;
block|}
name|List
argument_list|<
name|LightAutomaton
argument_list|>
name|as
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
while|while
condition|(
name|min
operator|--
operator|>
literal|0
condition|)
block|{
name|as
operator|.
name|add
argument_list|(
name|a
argument_list|)
expr_stmt|;
block|}
name|as
operator|.
name|add
argument_list|(
name|repeatLight
argument_list|(
name|a
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|concatenateLight
argument_list|(
name|as
argument_list|)
return|;
block|}
comment|/**    * Returns an automaton that accepts between<code>min</code> and    *<code>max</code> (including both) concatenated repetitions of the language    * of the given automaton.    *<p>    * Complexity: linear in number of states and in<code>min</code> and    *<code>max</code>.    */
DECL|method|repeatLight
specifier|static
specifier|public
name|LightAutomaton
name|repeatLight
parameter_list|(
name|LightAutomaton
name|a
parameter_list|,
name|int
name|min
parameter_list|,
name|int
name|max
parameter_list|)
block|{
if|if
condition|(
name|min
operator|>
name|max
condition|)
block|{
return|return
name|BasicAutomata
operator|.
name|makeEmptyLight
argument_list|()
return|;
block|}
name|LightAutomaton
name|b
decl_stmt|;
if|if
condition|(
name|min
operator|==
literal|0
condition|)
block|{
name|b
operator|=
name|BasicAutomata
operator|.
name|makeEmptyStringLight
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|min
operator|==
literal|1
condition|)
block|{
name|b
operator|=
operator|new
name|LightAutomaton
argument_list|()
expr_stmt|;
name|b
operator|.
name|copy
argument_list|(
name|a
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|List
argument_list|<
name|LightAutomaton
argument_list|>
name|as
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|min
condition|;
name|i
operator|++
control|)
block|{
name|as
operator|.
name|add
argument_list|(
name|a
argument_list|)
expr_stmt|;
block|}
name|b
operator|=
name|concatenateLight
argument_list|(
name|as
argument_list|)
expr_stmt|;
block|}
name|Set
argument_list|<
name|Integer
argument_list|>
name|prevAcceptStates
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|(
name|b
operator|.
name|getAcceptStates
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|min
init|;
name|i
operator|<
name|max
condition|;
name|i
operator|++
control|)
block|{
name|int
name|numStates
init|=
name|b
operator|.
name|getNumStates
argument_list|()
decl_stmt|;
name|b
operator|.
name|copy
argument_list|(
name|a
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|s
range|:
name|prevAcceptStates
control|)
block|{
name|b
operator|.
name|addEpsilon
argument_list|(
name|s
argument_list|,
name|numStates
argument_list|)
expr_stmt|;
block|}
name|prevAcceptStates
operator|.
name|clear
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|s
range|:
name|a
operator|.
name|getAcceptStates
argument_list|()
control|)
block|{
name|prevAcceptStates
operator|.
name|add
argument_list|(
name|numStates
operator|+
name|s
argument_list|)
expr_stmt|;
block|}
block|}
name|b
operator|.
name|finish
argument_list|()
expr_stmt|;
return|return
name|b
return|;
block|}
comment|/**    * Returns a (deterministic) automaton that accepts the complement of the    * language of the given automaton.    *<p>    * Complexity: linear in number of states (if already deterministic).    */
DECL|method|complementLight
specifier|static
specifier|public
name|LightAutomaton
name|complementLight
parameter_list|(
name|LightAutomaton
name|a
parameter_list|)
block|{
name|a
operator|=
name|determinize
argument_list|(
name|a
argument_list|)
operator|.
name|totalize
argument_list|()
expr_stmt|;
name|int
name|numStates
init|=
name|a
operator|.
name|getNumStates
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|p
init|=
literal|0
init|;
name|p
operator|<
name|numStates
condition|;
name|p
operator|++
control|)
block|{
name|a
operator|.
name|setAccept
argument_list|(
name|p
argument_list|,
operator|!
name|a
operator|.
name|isAccept
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|removeDeadTransitions
argument_list|(
name|a
argument_list|)
return|;
block|}
comment|/**    * Returns a (deterministic) automaton that accepts the intersection of the    * language of<code>a1</code> and the complement of the language of    *<code>a2</code>. As a side-effect, the automata may be determinized, if not    * already deterministic.    *<p>    * Complexity: quadratic in number of states (if already deterministic).    */
DECL|method|minusLight
specifier|static
specifier|public
name|LightAutomaton
name|minusLight
parameter_list|(
name|LightAutomaton
name|a1
parameter_list|,
name|LightAutomaton
name|a2
parameter_list|)
block|{
if|if
condition|(
name|BasicOperations
operator|.
name|isEmpty
argument_list|(
name|a1
argument_list|)
operator|||
name|a1
operator|==
name|a2
condition|)
block|{
return|return
name|BasicAutomata
operator|.
name|makeEmptyLight
argument_list|()
return|;
block|}
if|if
condition|(
name|BasicOperations
operator|.
name|isEmpty
argument_list|(
name|a2
argument_list|)
condition|)
block|{
return|return
name|a1
return|;
block|}
return|return
name|intersectionLight
argument_list|(
name|a1
argument_list|,
name|complementLight
argument_list|(
name|a2
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Returns an automaton that accepts the intersection of the languages of the    * given automata. Never modifies the input automata languages.    *<p>    * Complexity: quadratic in number of states.    */
DECL|method|intersectionLight
specifier|static
specifier|public
name|LightAutomaton
name|intersectionLight
parameter_list|(
name|LightAutomaton
name|a1
parameter_list|,
name|LightAutomaton
name|a2
parameter_list|)
block|{
if|if
condition|(
name|a1
operator|==
name|a2
condition|)
block|{
return|return
name|a1
return|;
block|}
name|LightAutomaton
operator|.
name|Transition
index|[]
index|[]
name|transitions1
init|=
name|a1
operator|.
name|getSortedTransitions
argument_list|()
decl_stmt|;
name|LightAutomaton
operator|.
name|Transition
index|[]
index|[]
name|transitions2
init|=
name|a2
operator|.
name|getSortedTransitions
argument_list|()
decl_stmt|;
name|LightAutomaton
name|c
init|=
operator|new
name|LightAutomaton
argument_list|()
decl_stmt|;
name|c
operator|.
name|createState
argument_list|()
expr_stmt|;
name|LinkedList
argument_list|<
name|LightStatePair
argument_list|>
name|worklist
init|=
operator|new
name|LinkedList
argument_list|<>
argument_list|()
decl_stmt|;
name|HashMap
argument_list|<
name|LightStatePair
argument_list|,
name|LightStatePair
argument_list|>
name|newstates
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|LightStatePair
name|p
init|=
operator|new
name|LightStatePair
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|worklist
operator|.
name|add
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|newstates
operator|.
name|put
argument_list|(
name|p
argument_list|,
name|p
argument_list|)
expr_stmt|;
while|while
condition|(
name|worklist
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|p
operator|=
name|worklist
operator|.
name|removeFirst
argument_list|()
expr_stmt|;
name|c
operator|.
name|setAccept
argument_list|(
name|p
operator|.
name|s
argument_list|,
name|a1
operator|.
name|isAccept
argument_list|(
name|p
operator|.
name|s1
argument_list|)
operator|&&
name|a2
operator|.
name|isAccept
argument_list|(
name|p
operator|.
name|s2
argument_list|)
argument_list|)
expr_stmt|;
name|LightAutomaton
operator|.
name|Transition
index|[]
name|t1
init|=
name|transitions1
index|[
name|p
operator|.
name|s1
index|]
decl_stmt|;
name|LightAutomaton
operator|.
name|Transition
index|[]
name|t2
init|=
name|transitions2
index|[
name|p
operator|.
name|s2
index|]
decl_stmt|;
for|for
control|(
name|int
name|n1
init|=
literal|0
init|,
name|b2
init|=
literal|0
init|;
name|n1
operator|<
name|t1
operator|.
name|length
condition|;
name|n1
operator|++
control|)
block|{
while|while
condition|(
name|b2
operator|<
name|t2
operator|.
name|length
operator|&&
name|t2
index|[
name|b2
index|]
operator|.
name|max
operator|<
name|t1
index|[
name|n1
index|]
operator|.
name|min
condition|)
name|b2
operator|++
expr_stmt|;
for|for
control|(
name|int
name|n2
init|=
name|b2
init|;
name|n2
operator|<
name|t2
operator|.
name|length
operator|&&
name|t1
index|[
name|n1
index|]
operator|.
name|max
operator|>=
name|t2
index|[
name|n2
index|]
operator|.
name|min
condition|;
name|n2
operator|++
control|)
if|if
condition|(
name|t2
index|[
name|n2
index|]
operator|.
name|max
operator|>=
name|t1
index|[
name|n1
index|]
operator|.
name|min
condition|)
block|{
name|LightStatePair
name|q
init|=
operator|new
name|LightStatePair
argument_list|(
name|t1
index|[
name|n1
index|]
operator|.
name|dest
argument_list|,
name|t2
index|[
name|n2
index|]
operator|.
name|dest
argument_list|)
decl_stmt|;
name|LightStatePair
name|r
init|=
name|newstates
operator|.
name|get
argument_list|(
name|q
argument_list|)
decl_stmt|;
if|if
condition|(
name|r
operator|==
literal|null
condition|)
block|{
name|q
operator|.
name|s
operator|=
name|c
operator|.
name|createState
argument_list|()
expr_stmt|;
name|worklist
operator|.
name|add
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|newstates
operator|.
name|put
argument_list|(
name|q
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|r
operator|=
name|q
expr_stmt|;
block|}
name|int
name|min
init|=
name|t1
index|[
name|n1
index|]
operator|.
name|min
operator|>
name|t2
index|[
name|n2
index|]
operator|.
name|min
condition|?
name|t1
index|[
name|n1
index|]
operator|.
name|min
else|:
name|t2
index|[
name|n2
index|]
operator|.
name|min
decl_stmt|;
name|int
name|max
init|=
name|t1
index|[
name|n1
index|]
operator|.
name|max
operator|<
name|t2
index|[
name|n2
index|]
operator|.
name|max
condition|?
name|t1
index|[
name|n1
index|]
operator|.
name|max
else|:
name|t2
index|[
name|n2
index|]
operator|.
name|max
decl_stmt|;
name|c
operator|.
name|addTransition
argument_list|(
name|p
operator|.
name|s
argument_list|,
name|r
operator|.
name|s
argument_list|,
name|min
argument_list|,
name|max
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|c
operator|.
name|finish
argument_list|()
expr_stmt|;
return|return
name|removeDeadTransitions
argument_list|(
name|c
argument_list|)
return|;
block|}
comment|/**    * Returns an automaton that accepts the intersection of the languages of the    * given automata. Never modifies the input automata languages.    *<p>    * Complexity: quadratic in number of states.    */
comment|/*   // nocommit broken   static public LightAutomaton intersectionLight(LightAutomaton a1, LightAutomaton a2) {     if (a1 == a2) {       return a1;     }     LightAutomaton result = new LightAutomaton();     result.createState();     //Transition[][] transitions1 = a1.getSortedTransitions();     //Transition[][] transitions2 = a2.getSortedTransitions();     LinkedList<LightStatePair> worklist = new LinkedList<>();     HashMap<LightStatePair,LightStatePair> newstates = new HashMap<>();     LightStatePair p = new LightStatePair(0, 0, 0);     worklist.add(p);     newstates.put(p, p);     LightAutomaton.Transition t1 = new LightAutomaton.Transition();     LightAutomaton.Transition t2 = new LightAutomaton.Transition();     while (worklist.size()> 0) {       p = worklist.removeFirst();       result.setAccept(p.s, a1.isAccept(p.s1)&& a2.isAccept(p.s2));       int numT1 = a1.initTransition(p.s1, t1);       if (numT1> 0) {         a1.getNextTransition(t1);       }       int numT2 = a2.initTransition(p.s2, t2);       if (numT2> 0) {         a2.getNextTransition(t2);       }       //Transition[] t1 = transitions1[p.s1.number];       //Transition[] t2 = transitions2[p.s2.number];       for (int n1 = 0, b2 = 0; n1< numT1; n1++) {         while (b2< numT2&& t2.max< t1.min) {           b2++;           if (b2< numT2) {             a2.getNextTransition(t2);           }         }         for (int n2 = b2; n2< numT2&& t1.max>= t2.min; n2++) {           if (t2.max>= t1.min) {             LightStatePair q = new LightStatePair(t1.dest, t2.dest);             LightStatePair r = newstates.get(q);             if (r == null) {               q.s = result.createState();               worklist.add(q);               newstates.put(q, q);               r = q;             }             int min = t1.min> t2.min ? t1.min : t2.min;             int max = t1.max< t2.max ? t1.max : t2.max;             result.addTransition(p.s, r.s, min, max);           }           if (n2< numT2-1) {             a2.getNextTransition(t2);           }         }       }     }      result.finish();      return result.removeDeadTransitions();   }   */
comment|/** Returns true if these two automata accept exactly the    *  same language.  This is a costly computation!  Note    *  also that a1 and a2 will be determinized as a side    *  effect.  Both automata must be determinized first! */
DECL|method|sameLanguage
specifier|public
specifier|static
name|boolean
name|sameLanguage
parameter_list|(
name|LightAutomaton
name|a1
parameter_list|,
name|LightAutomaton
name|a2
parameter_list|)
block|{
if|if
condition|(
name|a1
operator|==
name|a2
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
name|a1
operator|.
name|isEmpty
argument_list|()
operator|&&
name|a2
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|true
return|;
block|}
return|return
name|subsetOf
argument_list|(
name|a2
argument_list|,
name|a1
argument_list|)
operator|&&
name|subsetOf
argument_list|(
name|a1
argument_list|,
name|a2
argument_list|)
return|;
block|}
comment|/**    * Returns true if the language of<code>a1</code> is a subset of the language    * of<code>a2</code>. Both automata must be determinized.    *<p>    * Complexity: quadratic in number of states.    */
DECL|method|subsetOf
specifier|public
specifier|static
name|boolean
name|subsetOf
parameter_list|(
name|LightAutomaton
name|a1
parameter_list|,
name|LightAutomaton
name|a2
parameter_list|)
block|{
assert|assert
name|isDeterministic
argument_list|(
name|a1
argument_list|)
assert|;
assert|assert
name|isDeterministic
argument_list|(
name|a2
argument_list|)
assert|;
comment|// TODO: cutover to iterators instead
name|LightAutomaton
operator|.
name|Transition
index|[]
index|[]
name|transitions1
init|=
name|a1
operator|.
name|getSortedTransitions
argument_list|()
decl_stmt|;
name|LightAutomaton
operator|.
name|Transition
index|[]
index|[]
name|transitions2
init|=
name|a2
operator|.
name|getSortedTransitions
argument_list|()
decl_stmt|;
name|LinkedList
argument_list|<
name|LightStatePair
argument_list|>
name|worklist
init|=
operator|new
name|LinkedList
argument_list|<>
argument_list|()
decl_stmt|;
name|HashSet
argument_list|<
name|LightStatePair
argument_list|>
name|visited
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
name|LightStatePair
name|p
init|=
operator|new
name|LightStatePair
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|worklist
operator|.
name|add
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|visited
operator|.
name|add
argument_list|(
name|p
argument_list|)
expr_stmt|;
while|while
condition|(
name|worklist
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|p
operator|=
name|worklist
operator|.
name|removeFirst
argument_list|()
expr_stmt|;
if|if
condition|(
name|a1
operator|.
name|isAccept
argument_list|(
name|p
operator|.
name|s1
argument_list|)
operator|&&
name|a2
operator|.
name|isAccept
argument_list|(
name|p
operator|.
name|s2
argument_list|)
operator|==
literal|false
condition|)
block|{
return|return
literal|false
return|;
block|}
name|LightAutomaton
operator|.
name|Transition
index|[]
name|t1
init|=
name|transitions1
index|[
name|p
operator|.
name|s1
index|]
decl_stmt|;
name|LightAutomaton
operator|.
name|Transition
index|[]
name|t2
init|=
name|transitions2
index|[
name|p
operator|.
name|s2
index|]
decl_stmt|;
for|for
control|(
name|int
name|n1
init|=
literal|0
init|,
name|b2
init|=
literal|0
init|;
name|n1
operator|<
name|t1
operator|.
name|length
condition|;
name|n1
operator|++
control|)
block|{
while|while
condition|(
name|b2
operator|<
name|t2
operator|.
name|length
operator|&&
name|t2
index|[
name|b2
index|]
operator|.
name|max
operator|<
name|t1
index|[
name|n1
index|]
operator|.
name|min
condition|)
block|{
name|b2
operator|++
expr_stmt|;
block|}
name|int
name|min1
init|=
name|t1
index|[
name|n1
index|]
operator|.
name|min
decl_stmt|,
name|max1
init|=
name|t1
index|[
name|n1
index|]
operator|.
name|max
decl_stmt|;
for|for
control|(
name|int
name|n2
init|=
name|b2
init|;
name|n2
operator|<
name|t2
operator|.
name|length
operator|&&
name|t1
index|[
name|n1
index|]
operator|.
name|max
operator|>=
name|t2
index|[
name|n2
index|]
operator|.
name|min
condition|;
name|n2
operator|++
control|)
block|{
if|if
condition|(
name|t2
index|[
name|n2
index|]
operator|.
name|min
operator|>
name|min1
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|t2
index|[
name|n2
index|]
operator|.
name|max
operator|<
name|Character
operator|.
name|MAX_CODE_POINT
condition|)
block|{
name|min1
operator|=
name|t2
index|[
name|n2
index|]
operator|.
name|max
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
name|min1
operator|=
name|Character
operator|.
name|MAX_CODE_POINT
expr_stmt|;
name|max1
operator|=
name|Character
operator|.
name|MIN_CODE_POINT
expr_stmt|;
block|}
name|LightStatePair
name|q
init|=
operator|new
name|LightStatePair
argument_list|(
name|t1
index|[
name|n1
index|]
operator|.
name|dest
argument_list|,
name|t2
index|[
name|n2
index|]
operator|.
name|dest
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|visited
operator|.
name|contains
argument_list|(
name|q
argument_list|)
condition|)
block|{
name|worklist
operator|.
name|add
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|visited
operator|.
name|add
argument_list|(
name|q
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|min1
operator|<=
name|max1
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
block|}
return|return
literal|true
return|;
block|}
comment|/**    * Returns true if the language of<code>a1</code> is a subset of the language    * of<code>a2</code>.  Both automata must be determinized.    *<p>    * Complexity: quadratic in number of states.    */
comment|/*   // nocommit low GC but broken!   public static boolean subsetOf(LightAutomaton a1, LightAutomaton a2) {     if (a1 == a2) return true;     LinkedList<LightStatePair> worklist = new LinkedList<>();     HashSet<LightStatePair> visited = new HashSet<>();     LightStatePair p = new LightStatePair(0, 0);     worklist.add(p);     visited.add(p);     LightAutomaton.Transition t1 = new LightAutomaton.Transition();     LightAutomaton.Transition t2 = new LightAutomaton.Transition();     while (worklist.size()> 0) {       p = worklist.removeFirst();       System.out.println("pop s1=" + p.s1 + " s2=" + p.s2);       if (a1.isAccept(p.s1)&& a2.isAccept(p.s2) == false) {         return false;       }        int numT1 = a1.initTransition(p.s1, t1);       for (int n1 = 0, b2 = 0; n1< numT1; n1++) {         int numT2 = a2.initTransition(p.s2, t2);         if (numT2> 0) {           a2.getNextTransition(t2);         }          a1.getNextTransition(t1);         while (b2< numT2&& t2.max< t1.min) {           b2++;           if (b2< numT2) {             a2.getNextTransition(t2);           }         }          int min1 = t1.min, max1 = t1.max;          for (int n2 = b2; n2< numT2&& t1.max>= t2.min; n2++) {           if (t2.min> min1) {             return false;           }           if (t2.max< Character.MAX_CODE_POINT) {             min1 = t2.max + 1;           } else {             min1 = Character.MAX_CODE_POINT;             max1 = Character.MIN_CODE_POINT;           }           LightStatePair q = new LightStatePair(t1.dest, t2.dest);           if (!visited.contains(q)) {             worklist.add(q);             visited.add(q);           }           if (n2< numT2-1) {             a2.getNextTransition(t2);           }         }         if (min1<= max1) {           return false;         }       }     }     return true;   }   */
comment|/**    * Returns an automaton that accepts the union of the languages of the given    * automata.    *<p>    * Complexity: linear in number of states.    */
DECL|method|unionLight
specifier|public
specifier|static
name|LightAutomaton
name|unionLight
parameter_list|(
name|LightAutomaton
name|a1
parameter_list|,
name|LightAutomaton
name|a2
parameter_list|)
block|{
return|return
name|unionLight
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|a1
argument_list|,
name|a2
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Returns an automaton that accepts the union of the languages of the given    * automata.    *<p>    * Complexity: linear in number of states.    */
comment|/*   public static LightAutomaton unionLight(Collection<LightAutomaton> l) {     LightAutomaton result = new LightAutomaton();     // Create initial node:     result.createState();     int stateOffset = 1;      // First pass, adding all states epsilon transitions:     LightAutomaton.Transition t = new LightAutomaton.Transition();     for(LightAutomaton a : l) {       int numStates = a.getNumStates();       if (a.isAccept(0)) {         // If any automaton accepts empty string, we do too:         result.setAccept(0, true);       }        for(int s=0;s<numStates;s++) {         int state = result.createState();         result.setAccept(state, a.isAccept(s));       }        // Add epsilon transition from new initial state to this automaton's initial state:       int numTransitions = a.initTransition(0, t);       for(int i=0;i<numTransitions;i++) {         a.getNextTransition(t);         result.addTransition(0, stateOffset + t.dest, t.min, t.max);       }        stateOffset += numStates;     }      // Second pass, copying over all other transitions:     stateOffset = 1;     for(LightAutomaton a : l) {       int numStates = a.getNumStates();       for(int s=0;s<numStates;s++) {         int numTransitions = a.initTransition(s, t);         for(int i=0;i<numTransitions;i++) {           a.getNextTransition(t);           result.addTransition(stateOffset + s, stateOffset + t.dest, t.min, t.max);         }       }        stateOffset += numStates;     }      result.finish();      return result;   }   */
DECL|method|unionLight
specifier|public
specifier|static
name|LightAutomaton
name|unionLight
parameter_list|(
name|Collection
argument_list|<
name|LightAutomaton
argument_list|>
name|l
parameter_list|)
block|{
name|LightAutomaton
name|result
init|=
operator|new
name|LightAutomaton
argument_list|()
decl_stmt|;
comment|// Create initial state:
name|result
operator|.
name|createState
argument_list|()
expr_stmt|;
comment|// Copy over all automata
name|LightAutomaton
operator|.
name|Transition
name|t
init|=
operator|new
name|LightAutomaton
operator|.
name|Transition
argument_list|()
decl_stmt|;
for|for
control|(
name|LightAutomaton
name|a
range|:
name|l
control|)
block|{
name|result
operator|.
name|copy
argument_list|(
name|a
argument_list|)
expr_stmt|;
block|}
comment|// Add epsilon transition from new initial state
name|int
name|stateOffset
init|=
literal|1
decl_stmt|;
for|for
control|(
name|LightAutomaton
name|a
range|:
name|l
control|)
block|{
if|if
condition|(
name|a
operator|.
name|getNumStates
argument_list|()
operator|==
literal|0
condition|)
block|{
continue|continue;
block|}
name|result
operator|.
name|addEpsilon
argument_list|(
literal|0
argument_list|,
name|stateOffset
argument_list|)
expr_stmt|;
name|stateOffset
operator|+=
name|a
operator|.
name|getNumStates
argument_list|()
expr_stmt|;
block|}
name|result
operator|.
name|finish
argument_list|()
expr_stmt|;
return|return
name|result
return|;
block|}
comment|// Simple custom ArrayList<Transition>
DECL|class|TransitionListLight
specifier|private
specifier|final
specifier|static
class|class
name|TransitionListLight
block|{
comment|// dest, min, max
DECL|field|transitions
name|int
index|[]
name|transitions
init|=
operator|new
name|int
index|[
literal|3
index|]
decl_stmt|;
DECL|field|next
name|int
name|next
decl_stmt|;
DECL|method|add
specifier|public
name|void
name|add
parameter_list|(
name|LightAutomaton
operator|.
name|Transition
name|t
parameter_list|)
block|{
if|if
condition|(
name|transitions
operator|.
name|length
operator|<
name|next
operator|+
literal|3
condition|)
block|{
name|transitions
operator|=
name|ArrayUtil
operator|.
name|grow
argument_list|(
name|transitions
argument_list|,
name|next
operator|+
literal|3
argument_list|)
expr_stmt|;
block|}
name|transitions
index|[
name|next
index|]
operator|=
name|t
operator|.
name|dest
expr_stmt|;
name|transitions
index|[
name|next
operator|+
literal|1
index|]
operator|=
name|t
operator|.
name|min
expr_stmt|;
name|transitions
index|[
name|next
operator|+
literal|2
index|]
operator|=
name|t
operator|.
name|max
expr_stmt|;
name|next
operator|+=
literal|3
expr_stmt|;
block|}
block|}
comment|// Holds all transitions that start on this int point, or
comment|// end at this point-1
DECL|class|PointTransitionsLight
specifier|private
specifier|final
specifier|static
class|class
name|PointTransitionsLight
implements|implements
name|Comparable
argument_list|<
name|PointTransitionsLight
argument_list|>
block|{
DECL|field|point
name|int
name|point
decl_stmt|;
DECL|field|ends
specifier|final
name|TransitionListLight
name|ends
init|=
operator|new
name|TransitionListLight
argument_list|()
decl_stmt|;
DECL|field|starts
specifier|final
name|TransitionListLight
name|starts
init|=
operator|new
name|TransitionListLight
argument_list|()
decl_stmt|;
annotation|@
name|Override
DECL|method|compareTo
specifier|public
name|int
name|compareTo
parameter_list|(
name|PointTransitionsLight
name|other
parameter_list|)
block|{
return|return
name|point
operator|-
name|other
operator|.
name|point
return|;
block|}
DECL|method|reset
specifier|public
name|void
name|reset
parameter_list|(
name|int
name|point
parameter_list|)
block|{
name|this
operator|.
name|point
operator|=
name|point
expr_stmt|;
name|ends
operator|.
name|next
operator|=
literal|0
expr_stmt|;
name|starts
operator|.
name|next
operator|=
literal|0
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|equals
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|other
parameter_list|)
block|{
return|return
operator|(
operator|(
name|PointTransitionsLight
operator|)
name|other
operator|)
operator|.
name|point
operator|==
name|point
return|;
block|}
annotation|@
name|Override
DECL|method|hashCode
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
name|point
return|;
block|}
block|}
DECL|class|PointTransitionSetLight
specifier|private
specifier|final
specifier|static
class|class
name|PointTransitionSetLight
block|{
DECL|field|count
name|int
name|count
decl_stmt|;
DECL|field|points
name|PointTransitionsLight
index|[]
name|points
init|=
operator|new
name|PointTransitionsLight
index|[
literal|5
index|]
decl_stmt|;
DECL|field|HASHMAP_CUTOVER
specifier|private
specifier|final
specifier|static
name|int
name|HASHMAP_CUTOVER
init|=
literal|30
decl_stmt|;
DECL|field|map
specifier|private
specifier|final
name|HashMap
argument_list|<
name|Integer
argument_list|,
name|PointTransitionsLight
argument_list|>
name|map
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
DECL|field|useHash
specifier|private
name|boolean
name|useHash
init|=
literal|false
decl_stmt|;
DECL|method|next
specifier|private
name|PointTransitionsLight
name|next
parameter_list|(
name|int
name|point
parameter_list|)
block|{
comment|// 1st time we are seeing this point
if|if
condition|(
name|count
operator|==
name|points
operator|.
name|length
condition|)
block|{
specifier|final
name|PointTransitionsLight
index|[]
name|newArray
init|=
operator|new
name|PointTransitionsLight
index|[
name|ArrayUtil
operator|.
name|oversize
argument_list|(
literal|1
operator|+
name|count
argument_list|,
name|RamUsageEstimator
operator|.
name|NUM_BYTES_OBJECT_REF
argument_list|)
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|points
argument_list|,
literal|0
argument_list|,
name|newArray
argument_list|,
literal|0
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|points
operator|=
name|newArray
expr_stmt|;
block|}
name|PointTransitionsLight
name|points0
init|=
name|points
index|[
name|count
index|]
decl_stmt|;
if|if
condition|(
name|points0
operator|==
literal|null
condition|)
block|{
name|points0
operator|=
name|points
index|[
name|count
index|]
operator|=
operator|new
name|PointTransitionsLight
argument_list|()
expr_stmt|;
block|}
name|points0
operator|.
name|reset
argument_list|(
name|point
argument_list|)
expr_stmt|;
name|count
operator|++
expr_stmt|;
return|return
name|points0
return|;
block|}
DECL|method|find
specifier|private
name|PointTransitionsLight
name|find
parameter_list|(
name|int
name|point
parameter_list|)
block|{
if|if
condition|(
name|useHash
condition|)
block|{
specifier|final
name|Integer
name|pi
init|=
name|point
decl_stmt|;
name|PointTransitionsLight
name|p
init|=
name|map
operator|.
name|get
argument_list|(
name|pi
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
operator|==
literal|null
condition|)
block|{
name|p
operator|=
name|next
argument_list|(
name|point
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
name|pi
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
return|return
name|p
return|;
block|}
else|else
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|points
index|[
name|i
index|]
operator|.
name|point
operator|==
name|point
condition|)
block|{
return|return
name|points
index|[
name|i
index|]
return|;
block|}
block|}
specifier|final
name|PointTransitionsLight
name|p
init|=
name|next
argument_list|(
name|point
argument_list|)
decl_stmt|;
if|if
condition|(
name|count
operator|==
name|HASHMAP_CUTOVER
condition|)
block|{
comment|// switch to HashMap on the fly
assert|assert
name|map
operator|.
name|size
argument_list|()
operator|==
literal|0
assert|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|map
operator|.
name|put
argument_list|(
name|points
index|[
name|i
index|]
operator|.
name|point
argument_list|,
name|points
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|useHash
operator|=
literal|true
expr_stmt|;
block|}
return|return
name|p
return|;
block|}
block|}
DECL|method|reset
specifier|public
name|void
name|reset
parameter_list|()
block|{
if|if
condition|(
name|useHash
condition|)
block|{
name|map
operator|.
name|clear
argument_list|()
expr_stmt|;
name|useHash
operator|=
literal|false
expr_stmt|;
block|}
name|count
operator|=
literal|0
expr_stmt|;
block|}
DECL|method|sort
specifier|public
name|void
name|sort
parameter_list|()
block|{
comment|// Tim sort performs well on already sorted arrays:
if|if
condition|(
name|count
operator|>
literal|1
condition|)
name|ArrayUtil
operator|.
name|timSort
argument_list|(
name|points
argument_list|,
literal|0
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
DECL|method|add
specifier|public
name|void
name|add
parameter_list|(
name|LightAutomaton
operator|.
name|Transition
name|t
parameter_list|)
block|{
name|find
argument_list|(
name|t
operator|.
name|min
argument_list|)
operator|.
name|starts
operator|.
name|add
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|find
argument_list|(
literal|1
operator|+
name|t
operator|.
name|max
argument_list|)
operator|.
name|ends
operator|.
name|add
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
name|StringBuilder
name|s
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|s
operator|.
name|append
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
name|s
operator|.
name|append
argument_list|(
name|points
index|[
name|i
index|]
operator|.
name|point
argument_list|)
operator|.
name|append
argument_list|(
literal|':'
argument_list|)
operator|.
name|append
argument_list|(
name|points
index|[
name|i
index|]
operator|.
name|starts
operator|.
name|next
operator|/
literal|3
argument_list|)
operator|.
name|append
argument_list|(
literal|','
argument_list|)
operator|.
name|append
argument_list|(
name|points
index|[
name|i
index|]
operator|.
name|ends
operator|.
name|next
operator|/
literal|3
argument_list|)
expr_stmt|;
block|}
return|return
name|s
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
comment|/**    * Determinizes the given automaton.    *<p>    * Worst case complexity: exponential in number of states.    */
DECL|method|determinize
specifier|public
specifier|static
name|LightAutomaton
name|determinize
parameter_list|(
name|LightAutomaton
name|a
parameter_list|)
block|{
if|if
condition|(
name|a
operator|.
name|getNumStates
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
name|a
return|;
block|}
comment|// subset construction
name|LightAutomaton
operator|.
name|Builder
name|b
init|=
operator|new
name|LightAutomaton
operator|.
name|Builder
argument_list|()
decl_stmt|;
comment|//System.out.println("DET:");
comment|//a.writeDot("/l/la/lucene/core/detin.dot");
name|SortedIntSetLight
operator|.
name|FrozenIntSetLight
name|initialset
init|=
operator|new
name|SortedIntSetLight
operator|.
name|FrozenIntSetLight
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|// Create state 0:
name|b
operator|.
name|createState
argument_list|()
expr_stmt|;
name|LinkedList
argument_list|<
name|SortedIntSetLight
operator|.
name|FrozenIntSetLight
argument_list|>
name|worklist
init|=
operator|new
name|LinkedList
argument_list|<>
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|SortedIntSetLight
operator|.
name|FrozenIntSetLight
argument_list|,
name|Integer
argument_list|>
name|newstate
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|worklist
operator|.
name|add
argument_list|(
name|initialset
argument_list|)
expr_stmt|;
name|b
operator|.
name|setAccept
argument_list|(
literal|0
argument_list|,
name|a
operator|.
name|isAccept
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|newstate
operator|.
name|put
argument_list|(
name|initialset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|int
name|newStateUpto
init|=
literal|0
decl_stmt|;
name|int
index|[]
name|newStatesArray
init|=
operator|new
name|int
index|[
literal|5
index|]
decl_stmt|;
name|newStatesArray
index|[
name|newStateUpto
index|]
operator|=
literal|0
expr_stmt|;
name|newStateUpto
operator|++
expr_stmt|;
comment|// like Set<Integer,PointTransitions>
specifier|final
name|PointTransitionSetLight
name|points
init|=
operator|new
name|PointTransitionSetLight
argument_list|()
decl_stmt|;
comment|// like SortedMap<Integer,Integer>
specifier|final
name|SortedIntSetLight
name|statesSet
init|=
operator|new
name|SortedIntSetLight
argument_list|(
literal|5
argument_list|)
decl_stmt|;
name|LightAutomaton
operator|.
name|Transition
name|scratch
init|=
operator|new
name|LightAutomaton
operator|.
name|Transition
argument_list|()
decl_stmt|;
while|while
condition|(
name|worklist
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|SortedIntSetLight
operator|.
name|FrozenIntSetLight
name|s
init|=
name|worklist
operator|.
name|removeFirst
argument_list|()
decl_stmt|;
comment|//System.out.println("det: pop set=" + s);
comment|// Collate all outgoing transitions by min/1+max:
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|s
operator|.
name|values
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|int
name|s0
init|=
name|s
operator|.
name|values
index|[
name|i
index|]
decl_stmt|;
name|int
name|numTransitions
init|=
name|a
operator|.
name|getNumTransitions
argument_list|(
name|s0
argument_list|)
decl_stmt|;
name|a
operator|.
name|initTransition
argument_list|(
name|s0
argument_list|,
name|scratch
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|numTransitions
condition|;
name|j
operator|++
control|)
block|{
name|a
operator|.
name|getNextTransition
argument_list|(
name|scratch
argument_list|)
expr_stmt|;
name|points
operator|.
name|add
argument_list|(
name|scratch
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|points
operator|.
name|count
operator|==
literal|0
condition|)
block|{
comment|// No outgoing transitions -- skip it
continue|continue;
block|}
name|points
operator|.
name|sort
argument_list|()
expr_stmt|;
name|int
name|lastPoint
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|accCount
init|=
literal|0
decl_stmt|;
specifier|final
name|int
name|r
init|=
name|s
operator|.
name|state
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|points
operator|.
name|count
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|int
name|point
init|=
name|points
operator|.
name|points
index|[
name|i
index|]
operator|.
name|point
decl_stmt|;
if|if
condition|(
name|statesSet
operator|.
name|upto
operator|>
literal|0
condition|)
block|{
assert|assert
name|lastPoint
operator|!=
operator|-
literal|1
assert|;
name|statesSet
operator|.
name|computeHash
argument_list|()
expr_stmt|;
name|Integer
name|q
init|=
name|newstate
operator|.
name|get
argument_list|(
name|statesSet
argument_list|)
decl_stmt|;
if|if
condition|(
name|q
operator|==
literal|null
condition|)
block|{
name|q
operator|=
name|b
operator|.
name|createState
argument_list|()
expr_stmt|;
specifier|final
name|SortedIntSetLight
operator|.
name|FrozenIntSetLight
name|p
init|=
name|statesSet
operator|.
name|freeze
argument_list|(
name|q
argument_list|)
decl_stmt|;
comment|//System.out.println("  make new state=" + q + " -> " + p + " accCount=" + accCount);
name|worklist
operator|.
name|add
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|b
operator|.
name|setAccept
argument_list|(
name|q
argument_list|,
name|accCount
operator|>
literal|0
argument_list|)
expr_stmt|;
name|newstate
operator|.
name|put
argument_list|(
name|p
argument_list|,
name|q
argument_list|)
expr_stmt|;
block|}
else|else
block|{
assert|assert
operator|(
name|accCount
operator|>
literal|0
condition|?
literal|true
else|:
literal|false
operator|)
operator|==
name|b
operator|.
name|isAccept
argument_list|(
name|q
argument_list|)
operator|:
literal|"accCount="
operator|+
name|accCount
operator|+
literal|" vs existing accept="
operator|+
name|b
operator|.
name|isAccept
argument_list|(
name|q
argument_list|)
operator|+
literal|" states="
operator|+
name|statesSet
assert|;
block|}
comment|// System.out.println("  add trans src=" + r + " dest=" + q + " min=" + lastPoint + " max=" + (point-1));
name|b
operator|.
name|addTransition
argument_list|(
name|r
argument_list|,
name|q
argument_list|,
name|lastPoint
argument_list|,
name|point
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|// process transitions that end on this point
comment|// (closes an overlapping interval)
name|int
index|[]
name|transitions
init|=
name|points
operator|.
name|points
index|[
name|i
index|]
operator|.
name|ends
operator|.
name|transitions
decl_stmt|;
name|int
name|limit
init|=
name|points
operator|.
name|points
index|[
name|i
index|]
operator|.
name|ends
operator|.
name|next
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|limit
condition|;
name|j
operator|+=
literal|3
control|)
block|{
name|int
name|dest
init|=
name|transitions
index|[
name|j
index|]
decl_stmt|;
name|statesSet
operator|.
name|decr
argument_list|(
name|dest
argument_list|)
expr_stmt|;
name|accCount
operator|-=
name|a
operator|.
name|isAccept
argument_list|(
name|dest
argument_list|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
block|}
name|points
operator|.
name|points
index|[
name|i
index|]
operator|.
name|ends
operator|.
name|next
operator|=
literal|0
expr_stmt|;
comment|// process transitions that start on this point
comment|// (opens a new interval)
name|transitions
operator|=
name|points
operator|.
name|points
index|[
name|i
index|]
operator|.
name|starts
operator|.
name|transitions
expr_stmt|;
name|limit
operator|=
name|points
operator|.
name|points
index|[
name|i
index|]
operator|.
name|starts
operator|.
name|next
expr_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|limit
condition|;
name|j
operator|+=
literal|3
control|)
block|{
name|int
name|dest
init|=
name|transitions
index|[
name|j
index|]
decl_stmt|;
name|statesSet
operator|.
name|incr
argument_list|(
name|dest
argument_list|)
expr_stmt|;
name|accCount
operator|+=
name|a
operator|.
name|isAccept
argument_list|(
name|dest
argument_list|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
block|}
name|lastPoint
operator|=
name|point
expr_stmt|;
name|points
operator|.
name|points
index|[
name|i
index|]
operator|.
name|starts
operator|.
name|next
operator|=
literal|0
expr_stmt|;
block|}
name|points
operator|.
name|reset
argument_list|()
expr_stmt|;
assert|assert
name|statesSet
operator|.
name|upto
operator|==
literal|0
operator|:
literal|"upto="
operator|+
name|statesSet
operator|.
name|upto
assert|;
block|}
return|return
name|b
operator|.
name|finish
argument_list|()
return|;
block|}
comment|/**    * Returns true if the given automaton accepts no strings.    */
DECL|method|isEmpty
specifier|public
specifier|static
name|boolean
name|isEmpty
parameter_list|(
name|LightAutomaton
name|a
parameter_list|)
block|{
return|return
name|a
operator|.
name|isAccept
argument_list|(
literal|0
argument_list|)
operator|==
literal|false
operator|&&
name|a
operator|.
name|getNumTransitions
argument_list|(
literal|0
argument_list|)
operator|==
literal|0
return|;
block|}
comment|/**    * Returns true if the given automaton accepts all strings.    */
DECL|method|isTotal
specifier|public
specifier|static
name|boolean
name|isTotal
parameter_list|(
name|LightAutomaton
name|a
parameter_list|)
block|{
if|if
condition|(
name|a
operator|.
name|isAccept
argument_list|(
literal|0
argument_list|)
operator|&&
name|a
operator|.
name|getNumTransitions
argument_list|(
literal|0
argument_list|)
operator|==
literal|1
condition|)
block|{
name|LightAutomaton
operator|.
name|Transition
name|t
init|=
operator|new
name|LightAutomaton
operator|.
name|Transition
argument_list|()
decl_stmt|;
name|a
operator|.
name|getTransition
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
name|t
operator|.
name|dest
operator|==
literal|0
operator|&&
name|t
operator|.
name|min
operator|==
name|Character
operator|.
name|MIN_CODE_POINT
operator|&&
name|t
operator|.
name|max
operator|==
name|Character
operator|.
name|MAX_CODE_POINT
return|;
block|}
return|return
literal|false
return|;
block|}
comment|/**    * Returns true if the given string is accepted by the automaton.  The input must be deterministic.    *<p>    * Complexity: linear in the length of the string.    *<p>    *<b>Note:</b> for full performance, use the {@link RunAutomaton} class.    */
DECL|method|run
specifier|public
specifier|static
name|boolean
name|run
parameter_list|(
name|LightAutomaton
name|a
parameter_list|,
name|String
name|s
parameter_list|)
block|{
comment|// nocommit too slow?
assert|assert
name|isDeterministic
argument_list|(
name|a
argument_list|)
assert|;
name|int
name|state
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|,
name|cp
init|=
literal|0
init|;
name|i
operator|<
name|s
operator|.
name|length
argument_list|()
condition|;
name|i
operator|+=
name|Character
operator|.
name|charCount
argument_list|(
name|cp
argument_list|)
control|)
block|{
name|int
name|nextState
init|=
name|a
operator|.
name|step
argument_list|(
name|state
argument_list|,
name|cp
operator|=
name|s
operator|.
name|codePointAt
argument_list|(
name|i
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|nextState
operator|==
operator|-
literal|1
condition|)
block|{
return|return
literal|false
return|;
block|}
name|state
operator|=
name|nextState
expr_stmt|;
block|}
return|return
name|a
operator|.
name|isAccept
argument_list|(
name|state
argument_list|)
return|;
block|}
comment|/**    * Returns true if the given string (expressed as unicode codepoints) is accepted by the automaton.  The input must be deterministic.    *<p>    * Complexity: linear in the length of the string.    *<p>    *<b>Note:</b> for full performance, use the {@link RunAutomaton} class.    */
DECL|method|run
specifier|public
specifier|static
name|boolean
name|run
parameter_list|(
name|LightAutomaton
name|a
parameter_list|,
name|IntsRef
name|s
parameter_list|)
block|{
comment|// nocommit too slow?
assert|assert
name|isDeterministic
argument_list|(
name|a
argument_list|)
assert|;
name|int
name|state
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|s
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|int
name|nextState
init|=
name|a
operator|.
name|step
argument_list|(
name|state
argument_list|,
name|s
operator|.
name|ints
index|[
name|s
operator|.
name|offset
operator|+
name|i
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|nextState
operator|==
operator|-
literal|1
condition|)
block|{
return|return
literal|false
return|;
block|}
name|state
operator|=
name|nextState
expr_stmt|;
block|}
return|return
name|a
operator|.
name|isAccept
argument_list|(
name|state
argument_list|)
return|;
block|}
comment|/**    * Returns the set of live states. A state is "live" if an accept state is    * reachable from it.    *     * @return set of {@link State} objects    */
comment|// nocommit public?
DECL|method|getLiveStates
specifier|private
specifier|static
name|BitSet
name|getLiveStates
parameter_list|(
name|LightAutomaton
name|a
parameter_list|)
block|{
name|int
name|numStates
init|=
name|a
operator|.
name|getNumStates
argument_list|()
decl_stmt|;
name|BitSet
name|liveSet
init|=
operator|new
name|BitSet
argument_list|(
name|numStates
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|state
range|:
name|a
operator|.
name|getAcceptStates
argument_list|()
control|)
block|{
name|liveSet
operator|.
name|set
argument_list|(
name|state
argument_list|)
expr_stmt|;
block|}
comment|// map<state, set<state>>
annotation|@
name|SuppressWarnings
argument_list|(
block|{
literal|"rawtypes"
block|,
literal|"unchecked"
block|}
argument_list|)
name|Set
argument_list|<
name|Integer
argument_list|>
name|map
index|[]
init|=
operator|new
name|Set
index|[
name|numStates
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numStates
condition|;
name|i
operator|++
control|)
block|{
name|map
index|[
name|i
index|]
operator|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
expr_stmt|;
block|}
name|LightAutomaton
operator|.
name|Transition
name|t
init|=
operator|new
name|LightAutomaton
operator|.
name|Transition
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|s
init|=
literal|0
init|;
name|s
operator|<
name|numStates
condition|;
name|s
operator|++
control|)
block|{
name|int
name|numTransitions
init|=
name|a
operator|.
name|initTransition
argument_list|(
name|s
argument_list|,
name|t
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numTransitions
condition|;
name|i
operator|++
control|)
block|{
name|a
operator|.
name|getNextTransition
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|map
index|[
name|t
operator|.
name|dest
index|]
operator|.
name|add
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
name|LinkedList
argument_list|<
name|Integer
argument_list|>
name|worklist
init|=
operator|new
name|LinkedList
argument_list|<>
argument_list|(
name|a
operator|.
name|getAcceptStates
argument_list|()
argument_list|)
decl_stmt|;
while|while
condition|(
name|worklist
operator|.
name|isEmpty
argument_list|()
operator|==
literal|false
condition|)
block|{
name|int
name|s
init|=
name|worklist
operator|.
name|removeFirst
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|p
range|:
name|map
index|[
name|s
index|]
control|)
block|{
if|if
condition|(
name|liveSet
operator|.
name|get
argument_list|(
name|p
argument_list|)
operator|==
literal|false
condition|)
block|{
name|liveSet
operator|.
name|set
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|worklist
operator|.
name|add
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|liveSet
return|;
block|}
comment|/**    * Removes transitions to dead states and calls {@link #reduce()}.    * (A state is "dead" if no accept state is    * reachable from it.)    */
DECL|method|removeDeadTransitions
specifier|public
specifier|static
name|LightAutomaton
name|removeDeadTransitions
parameter_list|(
name|LightAutomaton
name|a
parameter_list|)
block|{
name|int
name|numStates
init|=
name|a
operator|.
name|getNumStates
argument_list|()
decl_stmt|;
name|BitSet
name|liveSet
init|=
name|getLiveStates
argument_list|(
name|a
argument_list|)
decl_stmt|;
name|int
index|[]
name|map
init|=
operator|new
name|int
index|[
name|numStates
index|]
decl_stmt|;
name|LightAutomaton
name|result
init|=
operator|new
name|LightAutomaton
argument_list|()
decl_stmt|;
comment|//System.out.println("liveSet: " + liveSet + " numStates=" + numStates);
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numStates
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|liveSet
operator|.
name|get
argument_list|(
name|i
argument_list|)
condition|)
block|{
name|map
index|[
name|i
index|]
operator|=
name|result
operator|.
name|createState
argument_list|()
expr_stmt|;
name|result
operator|.
name|setAccept
argument_list|(
name|map
index|[
name|i
index|]
argument_list|,
name|a
operator|.
name|isAccept
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|LightAutomaton
operator|.
name|Transition
name|t
init|=
operator|new
name|LightAutomaton
operator|.
name|Transition
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numStates
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|liveSet
operator|.
name|get
argument_list|(
name|i
argument_list|)
condition|)
block|{
name|int
name|numTransitions
init|=
name|a
operator|.
name|initTransition
argument_list|(
name|i
argument_list|,
name|t
argument_list|)
decl_stmt|;
comment|// filter out transitions to dead states:
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|numTransitions
condition|;
name|j
operator|++
control|)
block|{
name|a
operator|.
name|getNextTransition
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|liveSet
operator|.
name|get
argument_list|(
name|t
operator|.
name|dest
argument_list|)
condition|)
block|{
name|result
operator|.
name|addTransition
argument_list|(
name|map
index|[
name|i
index|]
argument_list|,
name|map
index|[
name|t
operator|.
name|dest
index|]
argument_list|,
name|t
operator|.
name|min
argument_list|,
name|t
operator|.
name|max
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|// nocommit need test case for "accepts no strings"
name|result
operator|.
name|finish
argument_list|()
expr_stmt|;
return|return
name|result
return|;
block|}
block|}
end_class
end_unit
