begin_unit
begin_package
DECL|package|org.apache.lucene.util.automaton
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|automaton
package|;
end_package
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_comment
comment|//import java.io.IOException;
end_comment
begin_comment
comment|//import java.io.PrintWriter;
end_comment
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|BitSet
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|ArrayUtil
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|InPlaceMergeSorter
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|Sorter
import|;
end_import
begin_comment
comment|// TODO
end_comment
begin_comment
comment|//   - could use packed int arrays instead
end_comment
begin_comment
comment|//   - could encode dest w/ delta from to?
end_comment
begin_comment
comment|/** Represents an automaton and all its states and transitions.  States  *  are integers and must be created using {@link #createState}.  Mark a  *  state as an accept state using {@link #setAccept}.  Add transitions  *  using {@link #addTransition}.  Each state must have all of its  *  transitions added at once; if this is too restrictive then use  *  {@link Automaton.Builder} instead.  State 0 is always the  *  initial state.  Once a state is finished, either  *  because you've starting adding transitions to another state or you  *  call {@link #finishState}, then that states transitions are sorted  *  (first by min, then max, then dest) and reduced (transitions with  *  adjacent labels going to the same dest are combined).  *  * @lucene.experimental */
end_comment
begin_class
DECL|class|Automaton
specifier|public
class|class
name|Automaton
block|{
comment|/** Where we next write to the int[] states; this increments by 2 for    *  each added state because we pack a pointer to the transitions    *  array and a count of how many transitions leave the state.  */
DECL|field|nextState
specifier|private
name|int
name|nextState
decl_stmt|;
comment|/** Where we next write to in int[] transitions; this    *  increments by 3 for each added transition because we    *  pack min, max, dest in sequence. */
DECL|field|nextTransition
specifier|private
name|int
name|nextTransition
decl_stmt|;
comment|/** Current state we are adding transitions to; the caller    *  must add all transitions for this state before moving    *  onto another state. */
DECL|field|curState
specifier|private
name|int
name|curState
init|=
operator|-
literal|1
decl_stmt|;
comment|/** Index in the transitions array, where this states    *  leaving transitions are stored, or -1 if this state    *  has not added any transitions yet, followed by number    *  of transitions. */
DECL|field|states
specifier|private
name|int
index|[]
name|states
init|=
operator|new
name|int
index|[
literal|4
index|]
decl_stmt|;
comment|/** Holds toState, min, max for each transition. */
DECL|field|transitions
specifier|private
name|int
index|[]
name|transitions
init|=
operator|new
name|int
index|[
literal|6
index|]
decl_stmt|;
DECL|field|isAccept
specifier|private
specifier|final
name|BitSet
name|isAccept
init|=
operator|new
name|BitSet
argument_list|(
literal|4
argument_list|)
decl_stmt|;
comment|/** True if no state has two transitions leaving with the same label. */
DECL|field|deterministic
specifier|private
name|boolean
name|deterministic
init|=
literal|true
decl_stmt|;
comment|/** Sole constructor; creates an automaton with no states. */
DECL|method|Automaton
specifier|public
name|Automaton
parameter_list|()
block|{   }
comment|/** Create a new state. */
DECL|method|createState
specifier|public
name|int
name|createState
parameter_list|()
block|{
name|growStates
argument_list|()
expr_stmt|;
name|int
name|state
init|=
name|nextState
operator|/
literal|2
decl_stmt|;
name|states
index|[
name|nextState
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|nextState
operator|+=
literal|2
expr_stmt|;
return|return
name|state
return|;
block|}
comment|/** Set or clear this state as an accept state. */
DECL|method|setAccept
specifier|public
name|void
name|setAccept
parameter_list|(
name|int
name|state
parameter_list|,
name|boolean
name|accept
parameter_list|)
block|{
if|if
condition|(
name|state
operator|>=
name|getNumStates
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"state="
operator|+
name|state
operator|+
literal|" is out of bounds (numStates="
operator|+
name|getNumStates
argument_list|()
operator|+
literal|")"
argument_list|)
throw|;
block|}
if|if
condition|(
name|accept
condition|)
block|{
name|isAccept
operator|.
name|set
argument_list|(
name|state
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|isAccept
operator|.
name|clear
argument_list|(
name|state
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Sugar to get all transitions for all states.  This is    *  object-heavy; it's better to iterate state by state instead. */
DECL|method|getSortedTransitions
specifier|public
name|Transition
index|[]
index|[]
name|getSortedTransitions
parameter_list|()
block|{
name|int
name|numStates
init|=
name|getNumStates
argument_list|()
decl_stmt|;
name|Transition
index|[]
index|[]
name|transitions
init|=
operator|new
name|Transition
index|[
name|numStates
index|]
index|[]
decl_stmt|;
for|for
control|(
name|int
name|s
init|=
literal|0
init|;
name|s
operator|<
name|numStates
condition|;
name|s
operator|++
control|)
block|{
name|int
name|numTransitions
init|=
name|getNumTransitions
argument_list|(
name|s
argument_list|)
decl_stmt|;
name|transitions
index|[
name|s
index|]
operator|=
operator|new
name|Transition
index|[
name|numTransitions
index|]
expr_stmt|;
for|for
control|(
name|int
name|t
init|=
literal|0
init|;
name|t
operator|<
name|numTransitions
condition|;
name|t
operator|++
control|)
block|{
name|Transition
name|transition
init|=
operator|new
name|Transition
argument_list|()
decl_stmt|;
name|getTransition
argument_list|(
name|s
argument_list|,
name|t
argument_list|,
name|transition
argument_list|)
expr_stmt|;
name|transitions
index|[
name|s
index|]
index|[
name|t
index|]
operator|=
name|transition
expr_stmt|;
block|}
block|}
return|return
name|transitions
return|;
block|}
comment|/** Returns accept states.  If the bit is set then that state is an accept state. */
DECL|method|getAcceptStates
name|BitSet
name|getAcceptStates
parameter_list|()
block|{
return|return
name|isAccept
return|;
block|}
comment|/** Returns true if this state is an accept state. */
DECL|method|isAccept
specifier|public
name|boolean
name|isAccept
parameter_list|(
name|int
name|state
parameter_list|)
block|{
return|return
name|isAccept
operator|.
name|get
argument_list|(
name|state
argument_list|)
return|;
block|}
comment|/** Add a new transition with min = max = label. */
DECL|method|addTransition
specifier|public
name|void
name|addTransition
parameter_list|(
name|int
name|source
parameter_list|,
name|int
name|dest
parameter_list|,
name|int
name|label
parameter_list|)
block|{
name|addTransition
argument_list|(
name|source
argument_list|,
name|dest
argument_list|,
name|label
argument_list|,
name|label
argument_list|)
expr_stmt|;
block|}
comment|/** Add a new transition with the specified source, dest, min, max. */
DECL|method|addTransition
specifier|public
name|void
name|addTransition
parameter_list|(
name|int
name|source
parameter_list|,
name|int
name|dest
parameter_list|,
name|int
name|min
parameter_list|,
name|int
name|max
parameter_list|)
block|{
assert|assert
name|nextTransition
operator|%
literal|3
operator|==
literal|0
assert|;
if|if
condition|(
name|source
operator|>=
name|nextState
operator|/
literal|2
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"source="
operator|+
name|source
operator|+
literal|" is out of bounds (maxState is "
operator|+
operator|(
name|nextState
operator|/
literal|2
operator|-
literal|1
operator|)
operator|+
literal|")"
argument_list|)
throw|;
block|}
if|if
condition|(
name|dest
operator|>=
name|nextState
operator|/
literal|2
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"dest="
operator|+
name|dest
operator|+
literal|" is out of bounds (max state is "
operator|+
operator|(
name|nextState
operator|/
literal|2
operator|-
literal|1
operator|)
operator|+
literal|")"
argument_list|)
throw|;
block|}
name|growTransitions
argument_list|()
expr_stmt|;
if|if
condition|(
name|curState
operator|!=
name|source
condition|)
block|{
if|if
condition|(
name|curState
operator|!=
operator|-
literal|1
condition|)
block|{
name|finishCurrentState
argument_list|()
expr_stmt|;
block|}
comment|// Move to next source:
name|curState
operator|=
name|source
expr_stmt|;
if|if
condition|(
name|states
index|[
literal|2
operator|*
name|curState
index|]
operator|!=
operator|-
literal|1
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"from state ("
operator|+
name|source
operator|+
literal|") already had transitions added"
argument_list|)
throw|;
block|}
assert|assert
name|states
index|[
literal|2
operator|*
name|curState
operator|+
literal|1
index|]
operator|==
literal|0
assert|;
name|states
index|[
literal|2
operator|*
name|curState
index|]
operator|=
name|nextTransition
expr_stmt|;
block|}
name|transitions
index|[
name|nextTransition
operator|++
index|]
operator|=
name|dest
expr_stmt|;
name|transitions
index|[
name|nextTransition
operator|++
index|]
operator|=
name|min
expr_stmt|;
name|transitions
index|[
name|nextTransition
operator|++
index|]
operator|=
name|max
expr_stmt|;
comment|// Increment transition count for this state
name|states
index|[
literal|2
operator|*
name|curState
operator|+
literal|1
index|]
operator|++
expr_stmt|;
block|}
comment|/** Add a [virtual] epsilon transition between source and dest.    *  Dest state must already have all transitions added because this    *  method simply copies those same transitions over to source. */
DECL|method|addEpsilon
specifier|public
name|void
name|addEpsilon
parameter_list|(
name|int
name|source
parameter_list|,
name|int
name|dest
parameter_list|)
block|{
name|Transition
name|t
init|=
operator|new
name|Transition
argument_list|()
decl_stmt|;
name|int
name|count
init|=
name|initTransition
argument_list|(
name|dest
argument_list|,
name|t
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|getNextTransition
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|addTransition
argument_list|(
name|source
argument_list|,
name|t
operator|.
name|dest
argument_list|,
name|t
operator|.
name|min
argument_list|,
name|t
operator|.
name|max
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|isAccept
argument_list|(
name|dest
argument_list|)
condition|)
block|{
name|setAccept
argument_list|(
name|source
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Copies over all states/transitions from other.  The states numbers    *  are sequentially assigned (appended). */
DECL|method|copy
specifier|public
name|void
name|copy
parameter_list|(
name|Automaton
name|other
parameter_list|)
block|{
comment|// Bulk copy and then fixup the state pointers:
name|int
name|stateOffset
init|=
name|getNumStates
argument_list|()
decl_stmt|;
name|states
operator|=
name|ArrayUtil
operator|.
name|grow
argument_list|(
name|states
argument_list|,
name|nextState
operator|+
name|other
operator|.
name|nextState
argument_list|)
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|other
operator|.
name|states
argument_list|,
literal|0
argument_list|,
name|states
argument_list|,
name|nextState
argument_list|,
name|other
operator|.
name|nextState
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|other
operator|.
name|nextState
condition|;
name|i
operator|+=
literal|2
control|)
block|{
if|if
condition|(
name|states
index|[
name|nextState
operator|+
name|i
index|]
operator|!=
operator|-
literal|1
condition|)
block|{
name|states
index|[
name|nextState
operator|+
name|i
index|]
operator|+=
name|nextTransition
expr_stmt|;
block|}
block|}
name|nextState
operator|+=
name|other
operator|.
name|nextState
expr_stmt|;
name|int
name|otherNumStates
init|=
name|other
operator|.
name|getNumStates
argument_list|()
decl_stmt|;
name|BitSet
name|otherAcceptStates
init|=
name|other
operator|.
name|getAcceptStates
argument_list|()
decl_stmt|;
name|int
name|state
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|state
operator|<
name|otherNumStates
operator|&&
operator|(
name|state
operator|=
name|otherAcceptStates
operator|.
name|nextSetBit
argument_list|(
name|state
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|setAccept
argument_list|(
name|stateOffset
operator|+
name|state
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|state
operator|++
expr_stmt|;
block|}
comment|// Bulk copy and then fixup dest for each transition:
name|transitions
operator|=
name|ArrayUtil
operator|.
name|grow
argument_list|(
name|transitions
argument_list|,
name|nextTransition
operator|+
name|other
operator|.
name|nextTransition
argument_list|)
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|other
operator|.
name|transitions
argument_list|,
literal|0
argument_list|,
name|transitions
argument_list|,
name|nextTransition
argument_list|,
name|other
operator|.
name|nextTransition
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|other
operator|.
name|nextTransition
condition|;
name|i
operator|+=
literal|3
control|)
block|{
name|transitions
index|[
name|nextTransition
operator|+
name|i
index|]
operator|+=
name|stateOffset
expr_stmt|;
block|}
name|nextTransition
operator|+=
name|other
operator|.
name|nextTransition
expr_stmt|;
if|if
condition|(
name|other
operator|.
name|deterministic
operator|==
literal|false
condition|)
block|{
name|deterministic
operator|=
literal|false
expr_stmt|;
block|}
block|}
comment|/** Freezes the last state, sorting and reducing the transitions. */
DECL|method|finishCurrentState
specifier|private
name|void
name|finishCurrentState
parameter_list|()
block|{
name|int
name|numTransitions
init|=
name|states
index|[
literal|2
operator|*
name|curState
operator|+
literal|1
index|]
decl_stmt|;
assert|assert
name|numTransitions
operator|>
literal|0
assert|;
name|int
name|offset
init|=
name|states
index|[
literal|2
operator|*
name|curState
index|]
decl_stmt|;
name|int
name|start
init|=
name|offset
operator|/
literal|3
decl_stmt|;
name|destMinMaxSorter
operator|.
name|sort
argument_list|(
name|start
argument_list|,
name|start
operator|+
name|numTransitions
argument_list|)
expr_stmt|;
comment|// Reduce any "adjacent" transitions:
name|int
name|upto
init|=
literal|0
decl_stmt|;
name|int
name|min
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|max
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|dest
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numTransitions
condition|;
name|i
operator|++
control|)
block|{
name|int
name|tDest
init|=
name|transitions
index|[
name|offset
operator|+
literal|3
operator|*
name|i
index|]
decl_stmt|;
name|int
name|tMin
init|=
name|transitions
index|[
name|offset
operator|+
literal|3
operator|*
name|i
operator|+
literal|1
index|]
decl_stmt|;
name|int
name|tMax
init|=
name|transitions
index|[
name|offset
operator|+
literal|3
operator|*
name|i
operator|+
literal|2
index|]
decl_stmt|;
if|if
condition|(
name|dest
operator|==
name|tDest
condition|)
block|{
if|if
condition|(
name|tMin
operator|<=
name|max
operator|+
literal|1
condition|)
block|{
if|if
condition|(
name|tMax
operator|>
name|max
condition|)
block|{
name|max
operator|=
name|tMax
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|dest
operator|!=
operator|-
literal|1
condition|)
block|{
name|transitions
index|[
name|offset
operator|+
literal|3
operator|*
name|upto
index|]
operator|=
name|dest
expr_stmt|;
name|transitions
index|[
name|offset
operator|+
literal|3
operator|*
name|upto
operator|+
literal|1
index|]
operator|=
name|min
expr_stmt|;
name|transitions
index|[
name|offset
operator|+
literal|3
operator|*
name|upto
operator|+
literal|2
index|]
operator|=
name|max
expr_stmt|;
name|upto
operator|++
expr_stmt|;
block|}
name|min
operator|=
name|tMin
expr_stmt|;
name|max
operator|=
name|tMax
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|dest
operator|!=
operator|-
literal|1
condition|)
block|{
name|transitions
index|[
name|offset
operator|+
literal|3
operator|*
name|upto
index|]
operator|=
name|dest
expr_stmt|;
name|transitions
index|[
name|offset
operator|+
literal|3
operator|*
name|upto
operator|+
literal|1
index|]
operator|=
name|min
expr_stmt|;
name|transitions
index|[
name|offset
operator|+
literal|3
operator|*
name|upto
operator|+
literal|2
index|]
operator|=
name|max
expr_stmt|;
name|upto
operator|++
expr_stmt|;
block|}
name|dest
operator|=
name|tDest
expr_stmt|;
name|min
operator|=
name|tMin
expr_stmt|;
name|max
operator|=
name|tMax
expr_stmt|;
block|}
block|}
if|if
condition|(
name|dest
operator|!=
operator|-
literal|1
condition|)
block|{
comment|// Last transition
name|transitions
index|[
name|offset
operator|+
literal|3
operator|*
name|upto
index|]
operator|=
name|dest
expr_stmt|;
name|transitions
index|[
name|offset
operator|+
literal|3
operator|*
name|upto
operator|+
literal|1
index|]
operator|=
name|min
expr_stmt|;
name|transitions
index|[
name|offset
operator|+
literal|3
operator|*
name|upto
operator|+
literal|2
index|]
operator|=
name|max
expr_stmt|;
name|upto
operator|++
expr_stmt|;
block|}
name|nextTransition
operator|-=
operator|(
name|numTransitions
operator|-
name|upto
operator|)
operator|*
literal|3
expr_stmt|;
name|states
index|[
literal|2
operator|*
name|curState
operator|+
literal|1
index|]
operator|=
name|upto
expr_stmt|;
comment|// Sort transitions by min/max/dest:
name|minMaxDestSorter
operator|.
name|sort
argument_list|(
name|start
argument_list|,
name|start
operator|+
name|upto
argument_list|)
expr_stmt|;
if|if
condition|(
name|deterministic
operator|&&
name|upto
operator|>
literal|1
condition|)
block|{
name|int
name|lastMax
init|=
name|transitions
index|[
name|offset
operator|+
literal|2
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|upto
condition|;
name|i
operator|++
control|)
block|{
name|min
operator|=
name|transitions
index|[
name|offset
operator|+
literal|3
operator|*
name|i
operator|+
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|min
operator|<=
name|lastMax
condition|)
block|{
name|deterministic
operator|=
literal|false
expr_stmt|;
break|break;
block|}
name|lastMax
operator|=
name|transitions
index|[
name|offset
operator|+
literal|3
operator|*
name|i
operator|+
literal|2
index|]
expr_stmt|;
block|}
block|}
block|}
comment|/** Returns true if this automaton is deterministic (for ever state    *  there is only one transition for each label). */
DECL|method|isDeterministic
specifier|public
name|boolean
name|isDeterministic
parameter_list|()
block|{
return|return
name|deterministic
return|;
block|}
comment|/** Finishes the current state; call this once you are done adding    *  transitions for a state.  This is automatically called if you    *  start adding transitions to a new source state, but for the last    *  state you add you need to this method yourself. */
DECL|method|finishState
specifier|public
name|void
name|finishState
parameter_list|()
block|{
if|if
condition|(
name|curState
operator|!=
operator|-
literal|1
condition|)
block|{
name|finishCurrentState
argument_list|()
expr_stmt|;
name|curState
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
comment|// TODO: add finish() to shrink wrap the arrays?
comment|/** How many states this automaton has. */
DECL|method|getNumStates
specifier|public
name|int
name|getNumStates
parameter_list|()
block|{
return|return
name|nextState
operator|/
literal|2
return|;
block|}
comment|/** How many transitions this state has. */
DECL|method|getNumTransitions
specifier|public
name|int
name|getNumTransitions
parameter_list|(
name|int
name|state
parameter_list|)
block|{
name|int
name|count
init|=
name|states
index|[
literal|2
operator|*
name|state
operator|+
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|count
operator|==
operator|-
literal|1
condition|)
block|{
return|return
literal|0
return|;
block|}
else|else
block|{
return|return
name|count
return|;
block|}
block|}
DECL|method|growStates
specifier|private
name|void
name|growStates
parameter_list|()
block|{
if|if
condition|(
name|nextState
operator|+
literal|2
operator|>=
name|states
operator|.
name|length
condition|)
block|{
name|states
operator|=
name|ArrayUtil
operator|.
name|grow
argument_list|(
name|states
argument_list|,
name|nextState
operator|+
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|growTransitions
specifier|private
name|void
name|growTransitions
parameter_list|()
block|{
if|if
condition|(
name|nextTransition
operator|+
literal|3
operator|>=
name|transitions
operator|.
name|length
condition|)
block|{
name|transitions
operator|=
name|ArrayUtil
operator|.
name|grow
argument_list|(
name|transitions
argument_list|,
name|nextTransition
operator|+
literal|3
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Sorts transitions by dest, ascending, then min label ascending, then max label ascending */
DECL|field|destMinMaxSorter
specifier|private
specifier|final
name|Sorter
name|destMinMaxSorter
init|=
operator|new
name|InPlaceMergeSorter
argument_list|()
block|{
specifier|private
name|void
name|swapOne
parameter_list|(
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|)
block|{
name|int
name|x
init|=
name|transitions
index|[
name|i
index|]
decl_stmt|;
name|transitions
index|[
name|i
index|]
operator|=
name|transitions
index|[
name|j
index|]
expr_stmt|;
name|transitions
index|[
name|j
index|]
operator|=
name|x
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
name|void
name|swap
parameter_list|(
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|)
block|{
name|int
name|iStart
init|=
literal|3
operator|*
name|i
decl_stmt|;
name|int
name|jStart
init|=
literal|3
operator|*
name|j
decl_stmt|;
name|swapOne
argument_list|(
name|iStart
argument_list|,
name|jStart
argument_list|)
expr_stmt|;
name|swapOne
argument_list|(
name|iStart
operator|+
literal|1
argument_list|,
name|jStart
operator|+
literal|1
argument_list|)
expr_stmt|;
name|swapOne
argument_list|(
name|iStart
operator|+
literal|2
argument_list|,
name|jStart
operator|+
literal|2
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
annotation|@
name|Override
specifier|protected
name|int
name|compare
parameter_list|(
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|)
block|{
name|int
name|iStart
init|=
literal|3
operator|*
name|i
decl_stmt|;
name|int
name|jStart
init|=
literal|3
operator|*
name|j
decl_stmt|;
comment|// First dest:
name|int
name|iDest
init|=
name|transitions
index|[
name|iStart
index|]
decl_stmt|;
name|int
name|jDest
init|=
name|transitions
index|[
name|jStart
index|]
decl_stmt|;
if|if
condition|(
name|iDest
operator|<
name|jDest
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|iDest
operator|>
name|jDest
condition|)
block|{
return|return
literal|1
return|;
block|}
comment|// Then min:
name|int
name|iMin
init|=
name|transitions
index|[
name|iStart
operator|+
literal|1
index|]
decl_stmt|;
name|int
name|jMin
init|=
name|transitions
index|[
name|jStart
operator|+
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|iMin
operator|<
name|jMin
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|iMin
operator|>
name|jMin
condition|)
block|{
return|return
literal|1
return|;
block|}
comment|// Then max:
name|int
name|iMax
init|=
name|transitions
index|[
name|iStart
operator|+
literal|2
index|]
decl_stmt|;
name|int
name|jMax
init|=
name|transitions
index|[
name|jStart
operator|+
literal|2
index|]
decl_stmt|;
if|if
condition|(
name|iMax
operator|<
name|jMax
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|iMax
operator|>
name|jMax
condition|)
block|{
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
block|}
decl_stmt|;
comment|/** Sorts transitions by min label, ascending, then max label ascending, then dest ascending */
DECL|field|minMaxDestSorter
specifier|private
specifier|final
name|Sorter
name|minMaxDestSorter
init|=
operator|new
name|InPlaceMergeSorter
argument_list|()
block|{
specifier|private
name|void
name|swapOne
parameter_list|(
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|)
block|{
name|int
name|x
init|=
name|transitions
index|[
name|i
index|]
decl_stmt|;
name|transitions
index|[
name|i
index|]
operator|=
name|transitions
index|[
name|j
index|]
expr_stmt|;
name|transitions
index|[
name|j
index|]
operator|=
name|x
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
name|void
name|swap
parameter_list|(
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|)
block|{
name|int
name|iStart
init|=
literal|3
operator|*
name|i
decl_stmt|;
name|int
name|jStart
init|=
literal|3
operator|*
name|j
decl_stmt|;
name|swapOne
argument_list|(
name|iStart
argument_list|,
name|jStart
argument_list|)
expr_stmt|;
name|swapOne
argument_list|(
name|iStart
operator|+
literal|1
argument_list|,
name|jStart
operator|+
literal|1
argument_list|)
expr_stmt|;
name|swapOne
argument_list|(
name|iStart
operator|+
literal|2
argument_list|,
name|jStart
operator|+
literal|2
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
annotation|@
name|Override
specifier|protected
name|int
name|compare
parameter_list|(
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|)
block|{
name|int
name|iStart
init|=
literal|3
operator|*
name|i
decl_stmt|;
name|int
name|jStart
init|=
literal|3
operator|*
name|j
decl_stmt|;
comment|// First min:
name|int
name|iMin
init|=
name|transitions
index|[
name|iStart
operator|+
literal|1
index|]
decl_stmt|;
name|int
name|jMin
init|=
name|transitions
index|[
name|jStart
operator|+
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|iMin
operator|<
name|jMin
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|iMin
operator|>
name|jMin
condition|)
block|{
return|return
literal|1
return|;
block|}
comment|// Then max:
name|int
name|iMax
init|=
name|transitions
index|[
name|iStart
operator|+
literal|2
index|]
decl_stmt|;
name|int
name|jMax
init|=
name|transitions
index|[
name|jStart
operator|+
literal|2
index|]
decl_stmt|;
if|if
condition|(
name|iMax
operator|<
name|jMax
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|iMax
operator|>
name|jMax
condition|)
block|{
return|return
literal|1
return|;
block|}
comment|// Then dest:
name|int
name|iDest
init|=
name|transitions
index|[
name|iStart
index|]
decl_stmt|;
name|int
name|jDest
init|=
name|transitions
index|[
name|jStart
index|]
decl_stmt|;
if|if
condition|(
name|iDest
operator|<
name|jDest
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|iDest
operator|>
name|jDest
condition|)
block|{
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
block|}
decl_stmt|;
comment|/** Initialize the provided Transition to iterate through all transitions    *  leaving the specified state.  You must call {@link #getNextTransition} to    *  get each transition.  Returns the number of transitions    *  leaving this state. */
DECL|method|initTransition
specifier|public
name|int
name|initTransition
parameter_list|(
name|int
name|state
parameter_list|,
name|Transition
name|t
parameter_list|)
block|{
assert|assert
name|state
operator|<
name|nextState
operator|/
literal|2
operator|:
literal|"state="
operator|+
name|state
operator|+
literal|" nextState="
operator|+
name|nextState
assert|;
name|t
operator|.
name|source
operator|=
name|state
expr_stmt|;
name|t
operator|.
name|transitionUpto
operator|=
name|states
index|[
literal|2
operator|*
name|state
index|]
expr_stmt|;
return|return
name|getNumTransitions
argument_list|(
name|state
argument_list|)
return|;
block|}
comment|/** Iterate to the next transition after the provided one */
DECL|method|getNextTransition
specifier|public
name|void
name|getNextTransition
parameter_list|(
name|Transition
name|t
parameter_list|)
block|{
comment|// Make sure there is still a transition left:
assert|assert
operator|(
name|t
operator|.
name|transitionUpto
operator|+
literal|3
operator|-
name|states
index|[
literal|2
operator|*
name|t
operator|.
name|source
index|]
operator|)
operator|<=
literal|3
operator|*
name|states
index|[
literal|2
operator|*
name|t
operator|.
name|source
operator|+
literal|1
index|]
assert|;
name|t
operator|.
name|dest
operator|=
name|transitions
index|[
name|t
operator|.
name|transitionUpto
operator|++
index|]
expr_stmt|;
name|t
operator|.
name|min
operator|=
name|transitions
index|[
name|t
operator|.
name|transitionUpto
operator|++
index|]
expr_stmt|;
name|t
operator|.
name|max
operator|=
name|transitions
index|[
name|t
operator|.
name|transitionUpto
operator|++
index|]
expr_stmt|;
block|}
comment|/** Fill the provided {@link Transition} with the index'th    *  transition leaving the specified state. */
DECL|method|getTransition
specifier|public
name|void
name|getTransition
parameter_list|(
name|int
name|state
parameter_list|,
name|int
name|index
parameter_list|,
name|Transition
name|t
parameter_list|)
block|{
name|int
name|i
init|=
name|states
index|[
literal|2
operator|*
name|state
index|]
operator|+
literal|3
operator|*
name|index
decl_stmt|;
name|t
operator|.
name|source
operator|=
name|state
expr_stmt|;
name|t
operator|.
name|dest
operator|=
name|transitions
index|[
name|i
operator|++
index|]
expr_stmt|;
name|t
operator|.
name|min
operator|=
name|transitions
index|[
name|i
operator|++
index|]
expr_stmt|;
name|t
operator|.
name|max
operator|=
name|transitions
index|[
name|i
operator|++
index|]
expr_stmt|;
block|}
DECL|method|appendCharString
specifier|static
name|void
name|appendCharString
parameter_list|(
name|int
name|c
parameter_list|,
name|StringBuilder
name|b
parameter_list|)
block|{
if|if
condition|(
name|c
operator|>=
literal|0x21
operator|&&
name|c
operator|<=
literal|0x7e
operator|&&
name|c
operator|!=
literal|'\\'
operator|&&
name|c
operator|!=
literal|'"'
condition|)
name|b
operator|.
name|appendCodePoint
argument_list|(
name|c
argument_list|)
expr_stmt|;
else|else
block|{
name|b
operator|.
name|append
argument_list|(
literal|"\\\\U"
argument_list|)
expr_stmt|;
name|String
name|s
init|=
name|Integer
operator|.
name|toHexString
argument_list|(
name|c
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|<
literal|0x10
condition|)
name|b
operator|.
name|append
argument_list|(
literal|"0000000"
argument_list|)
operator|.
name|append
argument_list|(
name|s
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|<
literal|0x100
condition|)
name|b
operator|.
name|append
argument_list|(
literal|"000000"
argument_list|)
operator|.
name|append
argument_list|(
name|s
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|<
literal|0x1000
condition|)
name|b
operator|.
name|append
argument_list|(
literal|"00000"
argument_list|)
operator|.
name|append
argument_list|(
name|s
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|<
literal|0x10000
condition|)
name|b
operator|.
name|append
argument_list|(
literal|"0000"
argument_list|)
operator|.
name|append
argument_list|(
name|s
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|<
literal|0x100000
condition|)
name|b
operator|.
name|append
argument_list|(
literal|"000"
argument_list|)
operator|.
name|append
argument_list|(
name|s
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|<
literal|0x1000000
condition|)
name|b
operator|.
name|append
argument_list|(
literal|"00"
argument_list|)
operator|.
name|append
argument_list|(
name|s
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|<
literal|0x10000000
condition|)
name|b
operator|.
name|append
argument_list|(
literal|"0"
argument_list|)
operator|.
name|append
argument_list|(
name|s
argument_list|)
expr_stmt|;
else|else
name|b
operator|.
name|append
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*   public void writeDot(String fileName) {     if (fileName.indexOf('/') == -1) {       fileName = "/l/la/lucene/core/" + fileName + ".dot";     }     try {       PrintWriter pw = new PrintWriter(fileName);       pw.println(toDot());       pw.close();     } catch (IOException ioe) {       throw new RuntimeException(ioe);     }   }   */
comment|/** Returns the dot (graphviz) representation of this automaton.    *  This is extremely useful for visualizing the automaton. */
DECL|method|toDot
specifier|public
name|String
name|toDot
parameter_list|()
block|{
comment|// TODO: breadth first search so we can see get layered output...
name|StringBuilder
name|b
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|b
operator|.
name|append
argument_list|(
literal|"digraph Automaton {\n"
argument_list|)
expr_stmt|;
name|b
operator|.
name|append
argument_list|(
literal|"  rankdir = LR\n"
argument_list|)
expr_stmt|;
specifier|final
name|int
name|numStates
init|=
name|getNumStates
argument_list|()
decl_stmt|;
if|if
condition|(
name|numStates
operator|>
literal|0
condition|)
block|{
name|b
operator|.
name|append
argument_list|(
literal|"  initial [shape=plaintext,label=\"0\"]\n"
argument_list|)
expr_stmt|;
name|b
operator|.
name|append
argument_list|(
literal|"  initial -> 0\n"
argument_list|)
expr_stmt|;
block|}
name|Transition
name|t
init|=
operator|new
name|Transition
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|state
init|=
literal|0
init|;
name|state
operator|<
name|numStates
condition|;
name|state
operator|++
control|)
block|{
name|b
operator|.
name|append
argument_list|(
literal|"  "
argument_list|)
expr_stmt|;
name|b
operator|.
name|append
argument_list|(
name|state
argument_list|)
expr_stmt|;
if|if
condition|(
name|isAccept
argument_list|(
name|state
argument_list|)
condition|)
block|{
name|b
operator|.
name|append
argument_list|(
literal|" [shape=doublecircle,label=\""
operator|+
name|state
operator|+
literal|"\"]\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|b
operator|.
name|append
argument_list|(
literal|" [shape=circle,label=\""
operator|+
name|state
operator|+
literal|"\"]\n"
argument_list|)
expr_stmt|;
block|}
name|int
name|numTransitions
init|=
name|initTransition
argument_list|(
name|state
argument_list|,
name|t
argument_list|)
decl_stmt|;
comment|//System.out.println("toDot: state " + state + " has " + numTransitions + " transitions; t.nextTrans=" + t.transitionUpto);
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numTransitions
condition|;
name|i
operator|++
control|)
block|{
name|getNextTransition
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|//System.out.println("  t.nextTrans=" + t.transitionUpto);
assert|assert
name|t
operator|.
name|max
operator|>=
name|t
operator|.
name|min
assert|;
name|b
operator|.
name|append
argument_list|(
literal|"  "
argument_list|)
expr_stmt|;
name|b
operator|.
name|append
argument_list|(
name|state
argument_list|)
expr_stmt|;
name|b
operator|.
name|append
argument_list|(
literal|" -> "
argument_list|)
expr_stmt|;
name|b
operator|.
name|append
argument_list|(
name|t
operator|.
name|dest
argument_list|)
expr_stmt|;
name|b
operator|.
name|append
argument_list|(
literal|" [label=\""
argument_list|)
expr_stmt|;
name|appendCharString
argument_list|(
name|t
operator|.
name|min
argument_list|,
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|.
name|max
operator|!=
name|t
operator|.
name|min
condition|)
block|{
name|b
operator|.
name|append
argument_list|(
literal|'-'
argument_list|)
expr_stmt|;
name|appendCharString
argument_list|(
name|t
operator|.
name|max
argument_list|,
name|b
argument_list|)
expr_stmt|;
block|}
name|b
operator|.
name|append
argument_list|(
literal|"\"]\n"
argument_list|)
expr_stmt|;
comment|//System.out.println("  t=" + t);
block|}
block|}
name|b
operator|.
name|append
argument_list|(
literal|'}'
argument_list|)
expr_stmt|;
return|return
name|b
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**    * Returns sorted array of all interval start points.    */
DECL|method|getStartPoints
name|int
index|[]
name|getStartPoints
parameter_list|()
block|{
name|Set
argument_list|<
name|Integer
argument_list|>
name|pointset
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
name|pointset
operator|.
name|add
argument_list|(
name|Character
operator|.
name|MIN_CODE_POINT
argument_list|)
expr_stmt|;
comment|//System.out.println("getStartPoints");
for|for
control|(
name|int
name|s
init|=
literal|0
init|;
name|s
operator|<
name|nextState
condition|;
name|s
operator|+=
literal|2
control|)
block|{
name|int
name|trans
init|=
name|states
index|[
name|s
index|]
decl_stmt|;
name|int
name|limit
init|=
name|trans
operator|+
literal|3
operator|*
name|states
index|[
name|s
operator|+
literal|1
index|]
decl_stmt|;
comment|//System.out.println("  state=" + (s/2) + " trans=" + trans + " limit=" + limit);
while|while
condition|(
name|trans
operator|<
name|limit
condition|)
block|{
name|int
name|min
init|=
name|transitions
index|[
name|trans
operator|+
literal|1
index|]
decl_stmt|;
name|int
name|max
init|=
name|transitions
index|[
name|trans
operator|+
literal|2
index|]
decl_stmt|;
comment|//System.out.println("    min=" + min);
name|pointset
operator|.
name|add
argument_list|(
name|min
argument_list|)
expr_stmt|;
if|if
condition|(
name|max
operator|<
name|Character
operator|.
name|MAX_CODE_POINT
condition|)
block|{
name|pointset
operator|.
name|add
argument_list|(
name|max
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
name|trans
operator|+=
literal|3
expr_stmt|;
block|}
block|}
name|int
index|[]
name|points
init|=
operator|new
name|int
index|[
name|pointset
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
name|int
name|n
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Integer
name|m
range|:
name|pointset
control|)
block|{
name|points
index|[
name|n
operator|++
index|]
operator|=
name|m
expr_stmt|;
block|}
name|Arrays
operator|.
name|sort
argument_list|(
name|points
argument_list|)
expr_stmt|;
return|return
name|points
return|;
block|}
comment|/**    * Performs lookup in transitions, assuming determinism.    *     * @param state starting state    * @param label codepoint to look up    * @return destination state, -1 if no matching outgoing transition    */
DECL|method|step
specifier|public
name|int
name|step
parameter_list|(
name|int
name|state
parameter_list|,
name|int
name|label
parameter_list|)
block|{
assert|assert
name|state
operator|>=
literal|0
assert|;
assert|assert
name|label
operator|>=
literal|0
assert|;
name|int
name|trans
init|=
name|states
index|[
literal|2
operator|*
name|state
index|]
decl_stmt|;
name|int
name|limit
init|=
name|trans
operator|+
literal|3
operator|*
name|states
index|[
literal|2
operator|*
name|state
operator|+
literal|1
index|]
decl_stmt|;
comment|// TODO: we could do bin search; transitions are sorted
while|while
condition|(
name|trans
operator|<
name|limit
condition|)
block|{
name|int
name|dest
init|=
name|transitions
index|[
name|trans
index|]
decl_stmt|;
name|int
name|min
init|=
name|transitions
index|[
name|trans
operator|+
literal|1
index|]
decl_stmt|;
name|int
name|max
init|=
name|transitions
index|[
name|trans
operator|+
literal|2
index|]
decl_stmt|;
if|if
condition|(
name|min
operator|<=
name|label
operator|&&
name|label
operator|<=
name|max
condition|)
block|{
return|return
name|dest
return|;
block|}
name|trans
operator|+=
literal|3
expr_stmt|;
block|}
return|return
operator|-
literal|1
return|;
block|}
comment|/** Records new states and transitions and then {@link    *  #finish} creates the {@link Automaton}.  Use this    *  when you cannot create the Automaton directly because    *  it's too restrictive to have to add all transitions    *  leaving each state at once. */
DECL|class|Builder
specifier|public
specifier|static
class|class
name|Builder
block|{
DECL|field|transitions
specifier|private
name|int
index|[]
name|transitions
init|=
operator|new
name|int
index|[
literal|4
index|]
decl_stmt|;
DECL|field|nextTransition
specifier|private
name|int
name|nextTransition
decl_stmt|;
DECL|field|a
specifier|private
specifier|final
name|Automaton
name|a
init|=
operator|new
name|Automaton
argument_list|()
decl_stmt|;
comment|/** Sole constructor. */
DECL|method|Builder
specifier|public
name|Builder
parameter_list|()
block|{     }
comment|/** Add a new transition with min = max = label. */
DECL|method|addTransition
specifier|public
name|void
name|addTransition
parameter_list|(
name|int
name|source
parameter_list|,
name|int
name|dest
parameter_list|,
name|int
name|label
parameter_list|)
block|{
name|addTransition
argument_list|(
name|source
argument_list|,
name|dest
argument_list|,
name|label
argument_list|,
name|label
argument_list|)
expr_stmt|;
block|}
comment|/** Add a new transition with the specified source, dest, min, max. */
DECL|method|addTransition
specifier|public
name|void
name|addTransition
parameter_list|(
name|int
name|source
parameter_list|,
name|int
name|dest
parameter_list|,
name|int
name|min
parameter_list|,
name|int
name|max
parameter_list|)
block|{
if|if
condition|(
name|transitions
operator|.
name|length
operator|<
name|nextTransition
operator|+
literal|4
condition|)
block|{
name|transitions
operator|=
name|ArrayUtil
operator|.
name|grow
argument_list|(
name|transitions
argument_list|,
name|nextTransition
operator|+
literal|4
argument_list|)
expr_stmt|;
block|}
name|transitions
index|[
name|nextTransition
operator|++
index|]
operator|=
name|source
expr_stmt|;
name|transitions
index|[
name|nextTransition
operator|++
index|]
operator|=
name|dest
expr_stmt|;
name|transitions
index|[
name|nextTransition
operator|++
index|]
operator|=
name|min
expr_stmt|;
name|transitions
index|[
name|nextTransition
operator|++
index|]
operator|=
name|max
expr_stmt|;
block|}
comment|/** Sorts transitions first then min label ascending, then      *  max label ascending, then dest ascending */
DECL|field|sorter
specifier|private
specifier|final
name|Sorter
name|sorter
init|=
operator|new
name|InPlaceMergeSorter
argument_list|()
block|{
specifier|private
name|void
name|swapOne
parameter_list|(
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|)
block|{
name|int
name|x
init|=
name|transitions
index|[
name|i
index|]
decl_stmt|;
name|transitions
index|[
name|i
index|]
operator|=
name|transitions
index|[
name|j
index|]
expr_stmt|;
name|transitions
index|[
name|j
index|]
operator|=
name|x
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
name|void
name|swap
parameter_list|(
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|)
block|{
name|int
name|iStart
init|=
literal|4
operator|*
name|i
decl_stmt|;
name|int
name|jStart
init|=
literal|4
operator|*
name|j
decl_stmt|;
name|swapOne
argument_list|(
name|iStart
argument_list|,
name|jStart
argument_list|)
expr_stmt|;
name|swapOne
argument_list|(
name|iStart
operator|+
literal|1
argument_list|,
name|jStart
operator|+
literal|1
argument_list|)
expr_stmt|;
name|swapOne
argument_list|(
name|iStart
operator|+
literal|2
argument_list|,
name|jStart
operator|+
literal|2
argument_list|)
expr_stmt|;
name|swapOne
argument_list|(
name|iStart
operator|+
literal|3
argument_list|,
name|jStart
operator|+
literal|3
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
annotation|@
name|Override
specifier|protected
name|int
name|compare
parameter_list|(
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|)
block|{
name|int
name|iStart
init|=
literal|4
operator|*
name|i
decl_stmt|;
name|int
name|jStart
init|=
literal|4
operator|*
name|j
decl_stmt|;
comment|// First src:
name|int
name|iSrc
init|=
name|transitions
index|[
name|iStart
index|]
decl_stmt|;
name|int
name|jSrc
init|=
name|transitions
index|[
name|jStart
index|]
decl_stmt|;
if|if
condition|(
name|iSrc
operator|<
name|jSrc
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|iSrc
operator|>
name|jSrc
condition|)
block|{
return|return
literal|1
return|;
block|}
comment|// Then min:
name|int
name|iMin
init|=
name|transitions
index|[
name|iStart
operator|+
literal|2
index|]
decl_stmt|;
name|int
name|jMin
init|=
name|transitions
index|[
name|jStart
operator|+
literal|2
index|]
decl_stmt|;
if|if
condition|(
name|iMin
operator|<
name|jMin
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|iMin
operator|>
name|jMin
condition|)
block|{
return|return
literal|1
return|;
block|}
comment|// Then max:
name|int
name|iMax
init|=
name|transitions
index|[
name|iStart
operator|+
literal|3
index|]
decl_stmt|;
name|int
name|jMax
init|=
name|transitions
index|[
name|jStart
operator|+
literal|3
index|]
decl_stmt|;
if|if
condition|(
name|iMax
operator|<
name|jMax
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|iMax
operator|>
name|jMax
condition|)
block|{
return|return
literal|1
return|;
block|}
comment|// First dest:
name|int
name|iDest
init|=
name|transitions
index|[
name|iStart
operator|+
literal|1
index|]
decl_stmt|;
name|int
name|jDest
init|=
name|transitions
index|[
name|jStart
operator|+
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|iDest
operator|<
name|jDest
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|iDest
operator|>
name|jDest
condition|)
block|{
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
block|}
decl_stmt|;
comment|/** Compiles all added states and transitions into a new {@code Automaton}      *  and returns it. */
DECL|method|finish
specifier|public
name|Automaton
name|finish
parameter_list|()
block|{
comment|//System.out.println("LA.Builder.finish: count=" + (nextTransition/4));
comment|// TODO: we could make this more efficient,
comment|// e.g. somehow xfer the int[] to the automaton, or
comment|// alloc exactly the right size from the automaton
comment|//System.out.println("finish pending");
name|sorter
operator|.
name|sort
argument_list|(
literal|0
argument_list|,
name|nextTransition
operator|/
literal|4
argument_list|)
expr_stmt|;
name|int
name|upto
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|upto
operator|<
name|nextTransition
condition|)
block|{
name|a
operator|.
name|addTransition
argument_list|(
name|transitions
index|[
name|upto
index|]
argument_list|,
name|transitions
index|[
name|upto
operator|+
literal|1
index|]
argument_list|,
name|transitions
index|[
name|upto
operator|+
literal|2
index|]
argument_list|,
name|transitions
index|[
name|upto
operator|+
literal|3
index|]
argument_list|)
expr_stmt|;
name|upto
operator|+=
literal|4
expr_stmt|;
block|}
name|a
operator|.
name|finishState
argument_list|()
expr_stmt|;
return|return
name|a
return|;
block|}
comment|/** Create a new state. */
DECL|method|createState
specifier|public
name|int
name|createState
parameter_list|()
block|{
return|return
name|a
operator|.
name|createState
argument_list|()
return|;
block|}
comment|/** Set or clear this state as an accept state. */
DECL|method|setAccept
specifier|public
name|void
name|setAccept
parameter_list|(
name|int
name|state
parameter_list|,
name|boolean
name|accept
parameter_list|)
block|{
name|a
operator|.
name|setAccept
argument_list|(
name|state
argument_list|,
name|accept
argument_list|)
expr_stmt|;
block|}
comment|/** Returns true if this state is an accept state. */
DECL|method|isAccept
specifier|public
name|boolean
name|isAccept
parameter_list|(
name|int
name|state
parameter_list|)
block|{
return|return
name|a
operator|.
name|isAccept
argument_list|(
name|state
argument_list|)
return|;
block|}
comment|/** How many states this automaton has. */
DECL|method|getNumStates
specifier|public
name|int
name|getNumStates
parameter_list|()
block|{
return|return
name|a
operator|.
name|getNumStates
argument_list|()
return|;
block|}
comment|/** Copies over all states/transitions from other. */
DECL|method|copy
specifier|public
name|void
name|copy
parameter_list|(
name|Automaton
name|other
parameter_list|)
block|{
name|int
name|offset
init|=
name|getNumStates
argument_list|()
decl_stmt|;
name|int
name|otherNumStates
init|=
name|other
operator|.
name|getNumStates
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|s
init|=
literal|0
init|;
name|s
operator|<
name|otherNumStates
condition|;
name|s
operator|++
control|)
block|{
name|int
name|newState
init|=
name|createState
argument_list|()
decl_stmt|;
name|setAccept
argument_list|(
name|newState
argument_list|,
name|other
operator|.
name|isAccept
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|Transition
name|t
init|=
operator|new
name|Transition
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|s
init|=
literal|0
init|;
name|s
operator|<
name|otherNumStates
condition|;
name|s
operator|++
control|)
block|{
name|int
name|count
init|=
name|other
operator|.
name|initTransition
argument_list|(
name|s
argument_list|,
name|t
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|other
operator|.
name|getNextTransition
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|addTransition
argument_list|(
name|offset
operator|+
name|s
argument_list|,
name|offset
operator|+
name|t
operator|.
name|dest
argument_list|,
name|t
operator|.
name|min
argument_list|,
name|t
operator|.
name|max
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
end_class
end_unit
