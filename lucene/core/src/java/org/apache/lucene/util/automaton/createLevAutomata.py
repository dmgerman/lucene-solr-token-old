begin_unit
comment|'# Licensed to the Apache Software Foundation (ASF) under one or more'
nl|'\n'
comment|'# contributor license agreements.  See the NOTICE file distributed with'
nl|'\n'
comment|'# this work for additional information regarding copyright ownership.'
nl|'\n'
comment|'# The ASF licenses this file to You under the Apache License, Version 2.0'
nl|'\n'
comment|'# (the "License"); you may not use this file except in compliance with'
nl|'\n'
comment|'# the License.  You may obtain a copy of the License at'
nl|'\n'
comment|'#'
nl|'\n'
comment|'#     http://www.apache.org/licenses/LICENSE-2.0'
nl|'\n'
comment|'#'
nl|'\n'
comment|'# Unless required by applicable law or agreed to in writing, software'
nl|'\n'
comment|'# distributed under the License is distributed on an "AS IS" BASIS,'
nl|'\n'
comment|'# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.'
nl|'\n'
comment|'# See the License for the specific language governing permissions and'
nl|'\n'
comment|'# limitations under the License.'
nl|'\n'
nl|'\n'
comment|'# Note, this file is known to work with rev 120 of the moman'
nl|'\n'
comment|'# repository (http://bitbucket.org/jpbarrette/moman/overview)'
nl|'\n'
comment|'#'
nl|'\n'
comment|'# See also: http://sites.google.com/site/rrettesite/moman'
nl|'\n'
nl|'\n'
name|'import'
name|'math'
newline|'\n'
name|'import'
name|'os'
newline|'\n'
name|'import'
name|'sys'
newline|'\n'
comment|"#sys.path.insert(0, 'moman/finenight/python')"
nl|'\n'
name|'sys'
op|'.'
name|'path'
op|'.'
name|'insert'
op|'('
number|'0'
op|','
string|"'../../../../../../../../build/core/moman/finenight/python'"
op|')'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'  '
name|'from'
name|'possibleStates'
name|'import'
name|'genTransitions'
newline|'\n'
dedent|''
name|'except'
name|'ImportError'
op|':'
newline|'\n'
indent|'  '
name|'from'
name|'finenight'
op|'.'
name|'possibleStates'
name|'import'
name|'genTransitions'
newline|'\n'
nl|'\n'
DECL|variable|MODE
dedent|''
name|'MODE'
op|'='
string|"'array'"
newline|'\n'
DECL|variable|PACKED
name|'PACKED'
op|'='
name|'True'
newline|'\n'
DECL|variable|WORD
name|'WORD'
op|'='
number|'64'
newline|'\n'
DECL|variable|LOG2_WORD
name|'LOG2_WORD'
op|'='
name|'int'
op|'('
name|'math'
op|'.'
name|'log'
op|'('
name|'WORD'
op|')'
op|'/'
name|'math'
op|'.'
name|'log'
op|'('
number|'2'
op|')'
op|')'
newline|'\n'
comment|"#MODE = 'switch'"
nl|'\n'
nl|'\n'
DECL|class|LineOutput
name|'class'
name|'LineOutput'
op|':'
newline|'\n'
nl|'\n'
DECL|member|__init__
indent|'  '
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'indent'
op|'='
string|"''"
op|')'
op|':'
newline|'\n'
indent|'    '
name|'self'
op|'.'
name|'l'
op|'='
op|'['
op|']'
newline|'\n'
name|'self'
op|'.'
name|'_indent'
op|'='
name|'self'
op|'.'
name|'startIndent'
op|'='
name|'indent'
newline|'\n'
name|'self'
op|'.'
name|'inComment'
op|'='
name|'False'
newline|'\n'
nl|'\n'
DECL|member|__call__
dedent|''
name|'def'
name|'__call__'
op|'('
name|'self'
op|','
name|'s'
op|','
name|'indent'
op|'='
number|'0'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'if'
name|'s'
op|'.'
name|'find'
op|'('
string|"'}'"
op|')'
op|'!='
op|'-'
number|'1'
op|':'
newline|'\n'
indent|'      '
name|'assert'
name|'self'
op|'.'
name|'_indent'
op|'!='
name|'self'
op|'.'
name|'startIndent'
newline|'\n'
name|'self'
op|'.'
name|'_indent'
op|'='
name|'self'
op|'.'
name|'_indent'
op|'['
op|':'
op|'-'
number|'2'
op|']'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'indent'
op|'!='
number|'0'
op|':'
newline|'\n'
indent|'      '
name|'indent0'
op|'='
string|"'  '"
op|'*'
op|'('
name|'len'
op|'('
name|'self'
op|'.'
name|'_indent'
op|')'
op|'/'
number|'2'
op|'+'
name|'indent'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'      '
name|'indent0'
op|'='
name|'self'
op|'.'
name|'_indent'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'s'
op|'.'
name|'find'
op|'('
string|"'/*'"
op|')'
op|'!='
op|'-'
number|'1'
op|':'
newline|'\n'
indent|'      '
name|'if'
name|'s'
op|'.'
name|'find'
op|'('
string|"'*/'"
op|')'
op|'=='
op|'-'
number|'1'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'inComment'
op|'='
name|'True'
newline|'\n'
dedent|''
dedent|''
name|'elif'
name|'s'
op|'.'
name|'find'
op|'('
string|"'*/'"
op|')'
op|'!='
op|'-'
number|'1'
op|':'
newline|'\n'
indent|'      '
name|'self'
op|'.'
name|'inComment'
op|'='
name|'True'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'self'
op|'.'
name|'inComment'
op|':'
newline|'\n'
indent|'      '
name|'self'
op|'.'
name|'l'
op|'.'
name|'append'
op|'('
name|'indent0'
op|'+'
name|'s'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'      '
name|'self'
op|'.'
name|'l'
op|'.'
name|'append'
op|'('
name|'indent0'
op|'+'
name|'s'
op|'.'
name|'lstrip'
op|'('
op|')'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'self'
op|'.'
name|'inComment'
op|'='
name|'self'
op|'.'
name|'inComment'
name|'and'
name|'s'
op|'.'
name|'find'
op|'('
string|"'*/'"
op|')'
op|'=='
op|'-'
number|'1'
newline|'\n'
nl|'\n'
name|'if'
name|'s'
op|'.'
name|'find'
op|'('
string|"'{'"
op|')'
op|'!='
op|'-'
number|'1'
op|':'
newline|'\n'
indent|'      '
name|'self'
op|'.'
name|'_indent'
op|'+='
string|"'  '"
newline|'\n'
nl|'\n'
DECL|member|__str__
dedent|''
dedent|''
name|'def'
name|'__str__'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'if'
name|'True'
op|':'
newline|'\n'
indent|'      '
name|'assert'
name|'self'
op|'.'
name|'_indent'
op|'=='
name|'self'
op|'.'
name|'startIndent'
op|','
string|"'indent %d vs start indent %d'"
op|'%'
op|'('
name|'len'
op|'('
name|'self'
op|'.'
name|'_indent'
op|')'
op|','
name|'len'
op|'('
name|'self'
op|'.'
name|'startIndent'
op|')'
op|')'
newline|'\n'
dedent|''
name|'return'
string|"'\\n'"
op|'.'
name|'join'
op|'('
name|'self'
op|'.'
name|'l'
op|')'
newline|'\n'
nl|'\n'
DECL|member|indent
dedent|''
name|'def'
name|'indent'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'self'
op|'.'
name|'_indent'
op|'+='
string|"'  '"
newline|'\n'
nl|'\n'
DECL|member|outdent
dedent|''
name|'def'
name|'outdent'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'assert'
name|'self'
op|'.'
name|'_indent'
op|'!='
name|'self'
op|'.'
name|'startIndent'
newline|'\n'
name|'self'
op|'.'
name|'_indent'
op|'='
name|'self'
op|'.'
name|'_indent'
op|'['
op|':'
op|'-'
number|'2'
op|']'
newline|'\n'
nl|'\n'
DECL|function|charVarNumber
dedent|''
dedent|''
name|'def'
name|'charVarNumber'
op|'('
name|'charVar'
op|')'
op|':'
newline|'\n'
indent|'  '
string|'"""\n  Maps binary number (eg [1, 0, 1]) to its decimal value (5).\n  """'
newline|'\n'
nl|'\n'
name|'p'
op|'='
number|'1'
newline|'\n'
name|'sum'
op|'='
number|'0'
newline|'\n'
name|'downTo'
op|'='
name|'len'
op|'('
name|'charVar'
op|')'
op|'-'
number|'1'
newline|'\n'
name|'while'
name|'downTo'
op|'>='
number|'0'
op|':'
newline|'\n'
indent|'    '
name|'sum'
op|'+='
name|'p'
op|'*'
name|'int'
op|'('
name|'charVar'
op|'['
name|'downTo'
op|']'
op|')'
newline|'\n'
name|'p'
op|'*='
number|'2'
newline|'\n'
name|'downTo'
op|'-='
number|'1'
newline|'\n'
dedent|''
name|'return'
name|'sum'
newline|'\n'
nl|'\n'
DECL|function|main
dedent|''
name|'def'
name|'main'
op|'('
op|')'
op|':'
newline|'\n'
nl|'\n'
indent|'  '
name|'if'
name|'len'
op|'('
name|'sys'
op|'.'
name|'argv'
op|')'
op|'!='
number|'3'
op|':'
newline|'\n'
indent|'    '
name|'print'
newline|'\n'
name|'print'
string|"'Usage: python -u %s N <True/False>'"
op|'%'
name|'sys'
op|'.'
name|'argv'
op|'['
number|'0'
op|']'
newline|'\n'
name|'print'
newline|'\n'
name|'print'
string|"'NOTE: the resulting .java file is created in the current working dir!'"
newline|'\n'
name|'print'
newline|'\n'
name|'sys'
op|'.'
name|'exit'
op|'('
number|'1'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'n'
op|'='
name|'int'
op|'('
name|'sys'
op|'.'
name|'argv'
op|'['
number|'1'
op|']'
op|')'
newline|'\n'
nl|'\n'
name|'transpose'
op|'='
op|'('
name|'sys'
op|'.'
name|'argv'
op|'['
number|'2'
op|']'
op|'=='
string|'"True"'
op|')'
newline|'\n'
nl|'\n'
name|'tables'
op|'='
name|'genTransitions'
op|'('
name|'n'
op|','
name|'transpose'
op|')'
newline|'\n'
nl|'\n'
name|'stateMap'
op|'='
op|'{'
op|'}'
newline|'\n'
nl|'\n'
comment|'# init null state'
nl|'\n'
name|'stateMap'
op|'['
string|"'[]'"
op|']'
op|'='
op|'-'
number|'1'
newline|'\n'
nl|'\n'
comment|'# init start state'
nl|'\n'
name|'stateMap'
op|'['
string|"'[(0, 0)]'"
op|']'
op|'='
number|'0'
newline|'\n'
nl|'\n'
name|'w'
op|'='
name|'LineOutput'
op|'('
op|')'
newline|'\n'
nl|'\n'
name|'w'
op|'('
string|"'package org.apache.lucene.util.automaton;'"
op|')'
newline|'\n'
name|'w'
op|'('
string|"''"
op|')'
newline|'\n'
name|'w'
op|'('
string|"'/*'"
op|')'
newline|'\n'
name|'w'
op|'('
string|"' * Licensed to the Apache Software Foundation (ASF) under one or more'"
op|')'
newline|'\n'
name|'w'
op|'('
string|"' * contributor license agreements.  See the NOTICE file distributed with'"
op|')'
newline|'\n'
name|'w'
op|'('
string|"' * this work for additional information regarding copyright ownership.'"
op|')'
newline|'\n'
name|'w'
op|'('
string|"' * The ASF licenses this file to You under the Apache License, Version 2.0'"
op|')'
newline|'\n'
name|'w'
op|'('
string|'\' * (the "License"); you may not use this file except in compliance with\''
op|')'
newline|'\n'
name|'w'
op|'('
string|"' * the License.  You may obtain a copy of the License at'"
op|')'
newline|'\n'
name|'w'
op|'('
string|"' *'"
op|')'
newline|'\n'
name|'w'
op|'('
string|"' *     http://www.apache.org/licenses/LICENSE-2.0'"
op|')'
newline|'\n'
name|'w'
op|'('
string|"' *'"
op|')'
newline|'\n'
name|'w'
op|'('
string|"' * Unless required by applicable law or agreed to in writing, software'"
op|')'
newline|'\n'
name|'w'
op|'('
string|'\' * distributed under the License is distributed on an "AS IS" BASIS,\''
op|')'
newline|'\n'
name|'w'
op|'('
string|"' * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.'"
op|')'
newline|'\n'
name|'w'
op|'('
string|"' * See the License for the specific language governing permissions and'"
op|')'
newline|'\n'
name|'w'
op|'('
string|"' * limitations under the License.'"
op|')'
newline|'\n'
name|'w'
op|'('
string|"' */'"
op|')'
newline|'\n'
name|'w'
op|'('
string|"''"
op|')'
newline|'\n'
name|'w'
op|'('
string|"'// The following code was generated with the moman/finenight pkg'"
op|')'
newline|'\n'
name|'w'
op|'('
string|"'// This package is available under the MIT License, see NOTICE.txt'"
op|')'
newline|'\n'
name|'w'
op|'('
string|"'// for more details.'"
op|')'
newline|'\n'
name|'w'
op|'('
string|"''"
op|')'
newline|'\n'
name|'w'
op|'('
string|"'import org.apache.lucene.util.automaton.LevenshteinAutomata.ParametricDescription;'"
op|')'
newline|'\n'
name|'w'
op|'('
string|"''"
op|')'
newline|'\n'
name|'if'
name|'transpose'
op|':'
newline|'\n'
indent|'    '
name|'w'
op|'('
string|"'/** Parametric description for generating a Levenshtein automaton of degree %s, '"
op|'%'
name|'n'
op|')'
newline|'\n'
name|'w'
op|'('
string|"'    with transpositions as primitive edits */'"
op|')'
newline|'\n'
name|'className'
op|'='
string|"'Lev%dTParametricDescription'"
op|'%'
name|'n'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'    '
name|'w'
op|'('
string|"'/** Parametric description for generating a Levenshtein automaton of degree %s */'"
op|'%'
name|'n'
op|')'
newline|'\n'
name|'className'
op|'='
string|"'Lev%dParametricDescription'"
op|'%'
name|'n'
newline|'\n'
nl|'\n'
dedent|''
name|'w'
op|'('
string|"'class %s extends ParametricDescription {'"
op|'%'
name|'className'
op|')'
newline|'\n'
nl|'\n'
name|'w'
op|'('
string|"''"
op|')'
newline|'\n'
name|'w'
op|'('
string|"'@Override'"
op|')'
newline|'\n'
name|'w'
op|'('
string|"'int transition(int absState, int position, int vector) {'"
op|')'
newline|'\n'
nl|'\n'
name|'w'
op|'('
string|"'  // null absState should never be passed in'"
op|')'
newline|'\n'
name|'w'
op|'('
string|"'  assert absState != -1;'"
op|')'
newline|'\n'
nl|'\n'
name|'w'
op|'('
string|"''"
op|')'
newline|'\n'
name|'w'
op|'('
string|"'  // decode absState -> state, offset'"
op|')'
newline|'\n'
name|'w'
op|'('
string|"'  int state = absState/(w+1);'"
op|')'
newline|'\n'
name|'w'
op|'('
string|"'  int offset = absState%(w+1);'"
op|')'
newline|'\n'
name|'w'
op|'('
string|"'  assert offset >= 0;'"
op|')'
newline|'\n'
name|'w'
op|'('
string|"''"
op|')'
newline|'\n'
nl|'\n'
name|'machines'
op|'='
op|'['
op|']'
newline|'\n'
nl|'\n'
name|'for'
name|'i'
op|','
name|'map'
name|'in'
name|'enumerate'
op|'('
name|'tables'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'if'
name|'i'
op|'=='
number|'0'
op|':'
newline|'\n'
indent|'      '
name|'w'
op|'('
string|"'if (position == w) {'"
op|')'
newline|'\n'
dedent|''
name|'elif'
name|'i'
op|'=='
name|'len'
op|'('
name|'tables'
op|')'
op|'-'
number|'1'
op|':'
newline|'\n'
indent|'      '
name|'w'
op|'('
string|"'} else {'"
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'      '
name|'w'
op|'('
string|"'} else if (position == w-%d) {'"
op|'%'
name|'i'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'i'
op|'!='
number|'0'
name|'and'
name|'MODE'
op|'=='
string|"'switch'"
op|':'
newline|'\n'
indent|'      '
name|'w'
op|'('
string|"'switch(vector) {'"
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'l'
op|'='
name|'map'
op|'.'
name|'items'
op|'('
op|')'
newline|'\n'
name|'l'
op|'.'
name|'sort'
op|'('
op|')'
newline|'\n'
nl|'\n'
name|'numCasesPerVector'
op|'='
name|'None'
newline|'\n'
name|'numVectors'
op|'='
name|'len'
op|'('
name|'l'
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'MODE'
op|'=='
string|"'array'"
op|':'
newline|'\n'
indent|'      '
name|'toStateArray'
op|'='
op|'['
op|']'
newline|'\n'
name|'toOffsetIncrArray'
op|'='
op|'['
op|']'
newline|'\n'
nl|'\n'
dedent|''
name|'for'
name|'charVar'
op|','
name|'states'
name|'in'
name|'l'
op|':'
newline|'\n'
nl|'\n'
comment|"# somehow it's a string:"
nl|'\n'
indent|'      '
name|'charVar'
op|'='
name|'eval'
op|'('
name|'charVar'
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'i'
op|'!='
number|'0'
name|'and'
name|'MODE'
op|'=='
string|"'switch'"
op|':'
newline|'\n'
indent|'        '
name|'w'
op|'('
string|"'case %s: // <%s>'"
op|'%'
op|'('
name|'charVarNumber'
op|'('
name|'charVar'
op|')'
op|','
string|"','"
op|'.'
name|'join'
op|'('
op|'['
name|'str'
op|'('
name|'x'
op|')'
name|'for'
name|'x'
name|'in'
name|'charVar'
op|']'
op|')'
op|')'
op|')'
newline|'\n'
name|'w'
op|'.'
name|'indent'
op|'('
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'l'
op|'='
name|'states'
op|'.'
name|'items'
op|'('
op|')'
newline|'\n'
nl|'\n'
name|'byFromState'
op|'='
op|'{'
op|'}'
newline|'\n'
nl|'\n'
comment|'# first pass to assign states'
nl|'\n'
name|'byAction'
op|'='
op|'{'
op|'}'
newline|'\n'
name|'for'
name|'s'
op|','
op|'('
name|'toS'
op|','
name|'offset'
op|')'
name|'in'
name|'l'
op|':'
newline|'\n'
indent|'        '
name|'state'
op|'='
name|'str'
op|'('
name|'s'
op|')'
newline|'\n'
nl|'\n'
name|'toState'
op|'='
name|'str'
op|'('
name|'toS'
op|')'
newline|'\n'
name|'if'
name|'state'
name|'not'
name|'in'
name|'stateMap'
op|':'
newline|'\n'
indent|'          '
name|'stateMap'
op|'['
name|'state'
op|']'
op|'='
name|'len'
op|'('
name|'stateMap'
op|')'
op|'-'
number|'1'
newline|'\n'
dedent|''
name|'if'
name|'toState'
name|'not'
name|'in'
name|'stateMap'
op|':'
newline|'\n'
indent|'          '
name|'stateMap'
op|'['
name|'toState'
op|']'
op|'='
name|'len'
op|'('
name|'stateMap'
op|')'
op|'-'
number|'1'
newline|'\n'
nl|'\n'
dedent|''
name|'byFromState'
op|'['
name|'stateMap'
op|'['
name|'state'
op|']'
op|']'
op|'='
op|'('
number|'1'
op|'+'
name|'stateMap'
op|'['
name|'toState'
op|']'
op|','
name|'offset'
op|')'
newline|'\n'
nl|'\n'
name|'fromStateDesc'
op|'='
name|'s'
op|'['
number|'1'
op|':'
name|'len'
op|'('
name|'s'
op|')'
op|'-'
number|'1'
op|']'
newline|'\n'
name|'toStateDesc'
op|'='
string|"', '"
op|'.'
name|'join'
op|'('
op|'['
name|'str'
op|'('
name|'x'
op|')'
name|'for'
name|'x'
name|'in'
name|'toS'
op|']'
op|')'
newline|'\n'
nl|'\n'
name|'tup'
op|'='
op|'('
name|'stateMap'
op|'['
name|'toState'
op|']'
op|','
name|'toStateDesc'
op|','
name|'offset'
op|')'
newline|'\n'
name|'if'
name|'tup'
name|'not'
name|'in'
name|'byAction'
op|':'
newline|'\n'
indent|'          '
name|'byAction'
op|'['
name|'tup'
op|']'
op|'='
op|'['
op|']'
newline|'\n'
dedent|''
name|'byAction'
op|'['
name|'tup'
op|']'
op|'.'
name|'append'
op|'('
op|'('
name|'fromStateDesc'
op|','
name|'stateMap'
op|'['
name|'state'
op|']'
op|')'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'numCasesPerVector'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'        '
name|'numCasesPerVector'
op|'='
name|'len'
op|'('
name|'l'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
comment|'# we require this to be uniform... empirically it seems to be!'
nl|'\n'
indent|'        '
name|'assert'
name|'numCasesPerVector'
op|'=='
name|'len'
op|'('
name|'l'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'MODE'
op|'=='
string|"'array'"
op|':'
newline|'\n'
nl|'\n'
indent|'        '
name|'for'
name|'s'
name|'in'
name|'range'
op|'('
name|'numCasesPerVector'
op|')'
op|':'
newline|'\n'
indent|'          '
name|'toState'
op|','
name|'offsetIncr'
op|'='
name|'byFromState'
op|'['
name|'s'
op|']'
newline|'\n'
name|'toStateArray'
op|'.'
name|'append'
op|'('
name|'toState'
op|')'
newline|'\n'
name|'toOffsetIncrArray'
op|'.'
name|'append'
op|'('
name|'offsetIncr'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'else'
op|':'
newline|'\n'
nl|'\n'
comment|'# render switches'
nl|'\n'
indent|'        '
name|'w'
op|'('
string|"'switch(state) {   // %s cases'"
op|'%'
name|'len'
op|'('
name|'l'
op|')'
op|')'
newline|'\n'
nl|'\n'
name|'for'
op|'('
name|'toState'
op|','
name|'toStateDesc'
op|','
name|'offset'
op|')'
op|','
name|'lx'
name|'in'
name|'byAction'
op|'.'
name|'items'
op|'('
op|')'
op|':'
newline|'\n'
indent|'          '
name|'for'
name|'fromStateDesc'
op|','
name|'fromState'
name|'in'
name|'lx'
op|':'
newline|'\n'
indent|'            '
name|'w'
op|'('
string|"'case %s: // %s'"
op|'%'
op|'('
name|'fromState'
op|','
name|'fromStateDesc'
op|')'
op|')'
newline|'\n'
dedent|''
name|'w'
op|'.'
name|'indent'
op|'('
op|')'
newline|'\n'
name|'w'
op|'('
string|"'  state = %s; // %s'"
op|'%'
op|'('
name|'toState'
op|','
name|'toStateDesc'
op|')'
op|')'
newline|'\n'
name|'if'
name|'offset'
op|'>'
number|'0'
op|':'
newline|'\n'
indent|'            '
name|'w'
op|'('
string|"'  offset += %s;'"
op|'%'
name|'offset'
op|')'
newline|'\n'
dedent|''
name|'w'
op|'('
string|"'break;'"
op|')'
newline|'\n'
name|'w'
op|'.'
name|'outdent'
op|'('
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'w'
op|'('
string|"'}'"
op|')'
newline|'\n'
name|'if'
name|'i'
op|'!='
number|'0'
op|':'
newline|'\n'
indent|'          '
name|'w'
op|'('
string|"'break;'"
op|')'
newline|'\n'
name|'w'
op|'.'
name|'outdent'
op|'('
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
dedent|''
name|'if'
name|'MODE'
op|'=='
string|"'array'"
op|':'
newline|'\n'
comment|'# strangely state can come in wildly out of bounds....'
nl|'\n'
indent|'      '
name|'w'
op|'('
string|"'  if (state < %d) {'"
op|'%'
name|'numCasesPerVector'
op|')'
newline|'\n'
name|'w'
op|'('
string|"'    final int loc = vector * %d + state;'"
op|'%'
name|'numCasesPerVector'
op|')'
newline|'\n'
name|'if'
name|'PACKED'
op|':'
newline|'\n'
indent|'        '
name|'w'
op|'('
string|"'    offset += unpack(offsetIncrs%d, loc, NBITSOFFSET%d);'"
op|'%'
op|'('
name|'i'
op|','
name|'i'
op|')'
op|')'
newline|'\n'
name|'w'
op|'('
string|"'    state = unpack(toStates%d, loc, NBITSSTATES%d)-1;'"
op|'%'
op|'('
name|'i'
op|','
name|'i'
op|')'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'        '
name|'w'
op|'('
string|"'    offset += offsetIncrs%d[loc];'"
op|'%'
name|'i'
op|')'
newline|'\n'
name|'w'
op|'('
string|"'    state = toStates%d[loc]-1;'"
op|'%'
name|'i'
op|')'
newline|'\n'
dedent|''
name|'w'
op|'('
string|"'  }'"
op|')'
newline|'\n'
dedent|''
name|'elif'
name|'i'
op|'!='
number|'0'
op|':'
newline|'\n'
indent|'      '
name|'w'
op|'('
string|"'}'"
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'machines'
op|'.'
name|'append'
op|'('
op|'('
name|'toStateArray'
op|','
name|'toOffsetIncrArray'
op|','
name|'numCasesPerVector'
op|','
name|'numVectors'
op|')'
op|')'
newline|'\n'
nl|'\n'
comment|'# ends switch statement for machine'
nl|'\n'
dedent|''
name|'w'
op|'('
string|"'}'"
op|')'
newline|'\n'
nl|'\n'
name|'w'
op|'('
string|"''"
op|')'
newline|'\n'
nl|'\n'
name|'w'
op|'('
string|"'  if (state == -1) {'"
op|')'
newline|'\n'
name|'w'
op|'('
string|"'    // null state'"
op|')'
newline|'\n'
name|'w'
op|'('
string|"'    return -1;'"
op|')'
newline|'\n'
name|'w'
op|'('
string|"'  } else {'"
op|')'
newline|'\n'
name|'w'
op|'('
string|"'    // translate back to abs'"
op|')'
newline|'\n'
name|'w'
op|'('
string|"'    return state*(w+1)+offset;'"
op|')'
newline|'\n'
name|'w'
op|'('
string|"'  }'"
op|')'
newline|'\n'
nl|'\n'
comment|'# ends transition method'
nl|'\n'
name|'w'
op|'('
string|"'}'"
op|')'
newline|'\n'
nl|'\n'
name|'subs'
op|'='
op|'['
op|']'
newline|'\n'
name|'if'
name|'MODE'
op|'=='
string|"'array'"
op|':'
newline|'\n'
indent|'    '
name|'w'
op|'.'
name|'indent'
op|'('
op|')'
newline|'\n'
name|'for'
name|'i'
op|','
op|'('
name|'toStateArray'
op|','
name|'toOffsetIncrsArray'
op|','
name|'numCasesPerVector'
op|','
name|'numVectors'
op|')'
name|'in'
name|'enumerate'
op|'('
name|'machines'
op|')'
op|':'
newline|'\n'
indent|'      '
name|'w'
op|'('
string|"''"
op|')'
newline|'\n'
name|'w'
op|'.'
name|'outdent'
op|'('
op|')'
newline|'\n'
name|'w'
op|'('
string|"'// %d vectors; %d states per vector; array length = %d'"
op|'%'
op|'('
name|'numVectors'
op|','
name|'numCasesPerVector'
op|','
name|'numVectors'
op|'*'
name|'numCasesPerVector'
op|')'
op|')'
newline|'\n'
name|'w'
op|'.'
name|'indent'
op|'('
op|')'
newline|'\n'
name|'if'
name|'PACKED'
op|':'
newline|'\n'
comment|'# pack in python'
nl|'\n'
indent|'        '
name|'l'
op|','
name|'nbits'
op|'='
name|'pack'
op|'('
name|'toStateArray'
op|')'
newline|'\n'
name|'subs'
op|'.'
name|'append'
op|'('
op|'('
string|"'NBITSSTATES%d'"
op|'%'
name|'i'
op|','
name|'str'
op|'('
name|'nbits'
op|')'
op|')'
op|')'
newline|'\n'
name|'w'
op|'('
string|"'  private final static long[] toStates%d = new long[] /*%d bits per value */ %s;'"
op|'%'
op|'('
name|'i'
op|','
name|'nbits'
op|','
name|'renderList'
op|'('
op|'['
name|'hex'
op|'('
name|'long'
op|'('
name|'x'
op|')'
op|')'
name|'for'
name|'x'
name|'in'
name|'l'
op|']'
op|')'
op|')'
op|')'
newline|'\n'
nl|'\n'
name|'l'
op|','
name|'nbits'
op|'='
name|'pack'
op|'('
name|'toOffsetIncrsArray'
op|')'
newline|'\n'
name|'subs'
op|'.'
name|'append'
op|'('
op|'('
string|"'NBITSOFFSET%d'"
op|'%'
name|'i'
op|','
name|'str'
op|'('
name|'nbits'
op|')'
op|')'
op|')'
newline|'\n'
name|'w'
op|'('
string|"'  private final static long[] offsetIncrs%d = new long[] /*%d bits per value */ %s;'"
op|'%'
op|'('
name|'i'
op|','
name|'nbits'
op|','
name|'renderList'
op|'('
op|'['
name|'hex'
op|'('
name|'long'
op|'('
name|'x'
op|')'
op|')'
name|'for'
name|'x'
name|'in'
name|'l'
op|']'
op|')'
op|')'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'        '
name|'w'
op|'('
string|"'  private final static int[] toStates%d = new int[] %s;'"
op|'%'
op|'('
name|'i'
op|','
name|'renderList'
op|'('
op|'['
name|'str'
op|'('
name|'x'
op|')'
name|'for'
name|'x'
name|'in'
name|'toStateArray'
op|']'
op|')'
op|')'
op|')'
newline|'\n'
name|'w'
op|'('
string|"'  private final static int[] offsetIncrs%d = new int[] %s;'"
op|'%'
op|'('
name|'i'
op|','
name|'renderList'
op|'('
op|'['
name|'str'
op|'('
name|'x'
op|')'
name|'for'
name|'x'
name|'in'
name|'toStateArray'
op|']'
op|')'
op|')'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'w'
op|'.'
name|'outdent'
op|'('
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'stateMap2'
op|'='
name|'dict'
op|'('
op|'['
op|'['
name|'v'
op|','
name|'k'
op|']'
name|'for'
name|'k'
op|','
name|'v'
name|'in'
name|'stateMap'
op|'.'
name|'items'
op|'('
op|')'
op|']'
op|')'
newline|'\n'
name|'w'
op|'('
string|"''"
op|')'
newline|'\n'
name|'w'
op|'('
string|"'// state map'"
op|')'
newline|'\n'
name|'sum'
op|'='
number|'0'
newline|'\n'
name|'minErrors'
op|'='
op|'['
op|']'
newline|'\n'
name|'for'
name|'i'
name|'in'
name|'xrange'
op|'('
name|'len'
op|'('
name|'stateMap2'
op|')'
op|'-'
number|'1'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'w'
op|'('
string|"'//   %s -> %s'"
op|'%'
op|'('
name|'i'
op|','
name|'stateMap2'
op|'['
name|'i'
op|']'
op|')'
op|')'
newline|'\n'
comment|"# we replace t-notation as it's not relevant here"
nl|'\n'
name|'st'
op|'='
name|'stateMap2'
op|'['
name|'i'
op|']'
op|'.'
name|'replace'
op|'('
string|"'t'"
op|','
string|"''"
op|')'
newline|'\n'
nl|'\n'
name|'v'
op|'='
name|'eval'
op|'('
name|'st'
op|')'
newline|'\n'
name|'minError'
op|'='
name|'min'
op|'('
op|'['
op|'-'
name|'i'
op|'+'
name|'e'
name|'for'
name|'i'
op|','
name|'e'
name|'in'
name|'v'
op|']'
op|')'
newline|'\n'
name|'c'
op|'='
name|'len'
op|'('
name|'v'
op|')'
newline|'\n'
name|'sum'
op|'+='
name|'c'
newline|'\n'
name|'minErrors'
op|'.'
name|'append'
op|'('
name|'minError'
op|')'
newline|'\n'
dedent|''
name|'w'
op|'('
string|"''"
op|')'
newline|'\n'
nl|'\n'
name|'w'
op|'.'
name|'indent'
op|'('
op|')'
newline|'\n'
comment|"#w('private final static int[] minErrors = new int[] {%s};' % ','.join([str(x) for x in minErrors]))"
nl|'\n'
nl|'\n'
name|'w'
op|'.'
name|'outdent'
op|'('
op|')'
newline|'\n'
nl|'\n'
name|'w'
op|'('
string|"''"
op|')'
newline|'\n'
name|'w'
op|'('
string|"'  public %s(int w) {'"
op|'%'
name|'className'
op|')'
newline|'\n'
name|'w'
op|'('
string|"'    super(w, %d, new int[] {%s});'"
op|'%'
op|'('
name|'n'
op|','
string|"','"
op|'.'
name|'join'
op|'('
op|'['
name|'str'
op|'('
name|'x'
op|')'
name|'for'
name|'x'
name|'in'
name|'minErrors'
op|']'
op|')'
op|')'
op|','
name|'indent'
op|'='
number|'1'
op|')'
newline|'\n'
name|'w'
op|'('
string|"'  }'"
op|')'
newline|'\n'
nl|'\n'
name|'if'
number|'0'
op|':'
newline|'\n'
indent|'    '
name|'w'
op|'('
string|"''"
op|')'
newline|'\n'
name|'w'
op|'('
string|"'@Override'"
op|')'
newline|'\n'
name|'w'
op|'('
string|"'public int size() { // this can now move up?'"
op|')'
newline|'\n'
name|'w'
op|'('
string|"'  return %d*(w+1);'"
op|'%'
op|'('
name|'len'
op|'('
name|'stateMap2'
op|')'
op|'-'
number|'1'
op|')'
op|')'
newline|'\n'
name|'w'
op|'('
string|"'}'"
op|')'
newline|'\n'
nl|'\n'
name|'w'
op|'('
string|"''"
op|')'
newline|'\n'
name|'w'
op|'('
string|"'@Override'"
op|')'
newline|'\n'
name|'w'
op|'('
string|"'public int getPosition(int absState) { // this can now move up?'"
op|')'
newline|'\n'
name|'w'
op|'('
string|"'  return absState % (w+1);'"
op|')'
newline|'\n'
name|'w'
op|'('
string|"'}'"
op|')'
newline|'\n'
nl|'\n'
name|'w'
op|'('
string|"''"
op|')'
newline|'\n'
name|'w'
op|'('
string|"'@Override'"
op|')'
newline|'\n'
name|'w'
op|'('
string|"'public boolean isAccept(int absState) { // this can now move up?'"
op|')'
newline|'\n'
name|'w'
op|'('
string|"'  // decode absState -> state, offset'"
op|')'
newline|'\n'
name|'w'
op|'('
string|"'  int state = absState/(w+1);'"
op|')'
newline|'\n'
name|'w'
op|'('
string|"'  if (true || state < minErrors.length) {'"
op|')'
newline|'\n'
name|'w'
op|'('
string|"'    int offset = absState%(w+1);'"
op|')'
newline|'\n'
name|'w'
op|'('
string|"'    assert offset >= 0;'"
op|')'
newline|'\n'
name|'w'
op|'('
string|"'    return w - offset + minErrors[state] <= %d;'"
op|'%'
name|'n'
op|')'
newline|'\n'
name|'w'
op|'('
string|"'  } else {'"
op|')'
newline|'\n'
name|'w'
op|'('
string|"'    return false;'"
op|')'
newline|'\n'
name|'w'
op|'('
string|"'  }'"
op|')'
newline|'\n'
name|'w'
op|'('
string|"'}'"
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'MODE'
op|'=='
string|"'array'"
name|'and'
name|'PACKED'
op|':'
newline|'\n'
nl|'\n'
comment|'# we moved into super class'
nl|'\n'
indent|'    '
name|'if'
name|'False'
op|':'
newline|'\n'
indent|'      '
name|'w'
op|'('
string|"''"
op|')'
newline|'\n'
nl|'\n'
name|'v'
op|'='
number|'2'
newline|'\n'
name|'l'
op|'='
op|'['
op|']'
newline|'\n'
name|'for'
name|'i'
name|'in'
name|'range'
op|'('
number|'63'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'l'
op|'.'
name|'append'
op|'('
name|'hex'
op|'('
name|'v'
op|'-'
number|'1'
op|')'
op|')'
newline|'\n'
name|'v'
op|'*='
number|'2'
newline|'\n'
nl|'\n'
dedent|''
name|'w'
op|'('
string|"'private final static long[] MASKS = new long[] {%s};'"
op|'%'
string|"','"
op|'.'
name|'join'
op|'('
name|'l'
op|')'
op|','
name|'indent'
op|'='
number|'1'
op|')'
newline|'\n'
name|'w'
op|'('
string|"''"
op|')'
newline|'\n'
nl|'\n'
comment|'# unpack in java'
nl|'\n'
name|'w'
op|'('
string|"'private int unpack(long[] data, int index, int bitsPerValue) {'"
op|')'
newline|'\n'
name|'w'
op|'('
string|"'  final long bitLoc = bitsPerValue * index;'"
op|')'
newline|'\n'
name|'w'
op|'('
string|"'  final int dataLoc = (int) (bitLoc >> %d);'"
op|'%'
name|'LOG2_WORD'
op|')'
newline|'\n'
name|'w'
op|'('
string|"'  final int bitStart = (int) (bitLoc & %d);'"
op|'%'
op|'('
name|'WORD'
op|'-'
number|'1'
op|')'
op|')'
newline|'\n'
name|'w'
op|'('
string|'\'  //System.out.println("index=" + index + " dataLoc=" + dataLoc + " bitStart=" + bitStart + " bitsPerV=" + bitsPerValue);\''
op|')'
newline|'\n'
name|'w'
op|'('
string|"'  if (bitStart + bitsPerValue <= %d) {'"
op|'%'
name|'WORD'
op|')'
newline|'\n'
name|'w'
op|'('
string|"'    // not split'"
op|')'
newline|'\n'
name|'w'
op|'('
string|"'    return (int) ((data[dataLoc] >> bitStart) & MASKS[bitsPerValue-1]);'"
op|')'
newline|'\n'
name|'w'
op|'('
string|"'  } else {'"
op|')'
newline|'\n'
name|'w'
op|'('
string|"'    // split'"
op|')'
newline|'\n'
name|'w'
op|'('
string|"'    final int part = %d-bitStart;'"
op|'%'
name|'WORD'
op|')'
newline|'\n'
name|'w'
op|'('
string|"'    return (int) (((data[dataLoc] >> bitStart) & MASKS[part-1]) +'"
op|')'
newline|'\n'
name|'w'
op|'('
string|"'      ((data[1+dataLoc] & MASKS[bitsPerValue-part-1]) << part));'"
op|','
name|'indent'
op|'='
number|'1'
op|')'
newline|'\n'
name|'w'
op|'('
string|"'  }'"
op|')'
newline|'\n'
name|'w'
op|'('
string|"'}'"
op|')'
newline|'\n'
nl|'\n'
comment|'# class'
nl|'\n'
dedent|''
dedent|''
name|'w'
op|'('
string|"'}'"
op|')'
newline|'\n'
name|'w'
op|'('
string|"''"
op|')'
newline|'\n'
nl|'\n'
name|'fileOut'
op|'='
string|"'%s.java'"
op|'%'
name|'className'
newline|'\n'
nl|'\n'
name|'s'
op|'='
name|'str'
op|'('
name|'w'
op|')'
newline|'\n'
name|'for'
name|'sub'
op|','
name|'repl'
name|'in'
name|'subs'
op|':'
newline|'\n'
indent|'    '
name|'s'
op|'='
name|'s'
op|'.'
name|'replace'
op|'('
name|'sub'
op|','
name|'repl'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'open'
op|'('
name|'fileOut'
op|','
string|"'wb'"
op|')'
op|'.'
name|'write'
op|'('
name|'s'
op|')'
newline|'\n'
nl|'\n'
name|'print'
string|"'Wrote %s [%d lines; %.1f KB]'"
op|'%'
op|'('
name|'fileOut'
op|','
name|'len'
op|'('
name|'w'
op|'.'
name|'l'
op|')'
op|','
name|'os'
op|'.'
name|'path'
op|'.'
name|'getsize'
op|'('
name|'fileOut'
op|')'
op|'/'
number|'1024.'
op|')'
newline|'\n'
nl|'\n'
DECL|function|renderList
dedent|''
name|'def'
name|'renderList'
op|'('
name|'l'
op|')'
op|':'
newline|'\n'
indent|'  '
name|'lx'
op|'='
op|'['
string|"'    '"
op|']'
newline|'\n'
name|'for'
name|'i'
name|'in'
name|'xrange'
op|'('
name|'len'
op|'('
name|'l'
op|')'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'if'
name|'i'
op|'>'
number|'0'
op|':'
newline|'\n'
indent|'      '
name|'lx'
op|'.'
name|'append'
op|'('
string|"','"
op|')'
newline|'\n'
name|'if'
name|'i'
op|'%'
number|'4'
op|'=='
number|'0'
op|':'
newline|'\n'
indent|'        '
name|'lx'
op|'.'
name|'append'
op|'('
string|"'\\n    '"
op|')'
newline|'\n'
dedent|''
dedent|''
name|'lx'
op|'.'
name|'append'
op|'('
name|'l'
op|'['
name|'i'
op|']'
op|')'
newline|'\n'
dedent|''
name|'return'
string|"'{\\n%s\\n  }'"
op|'%'
string|"''"
op|'.'
name|'join'
op|'('
name|'lx'
op|')'
newline|'\n'
nl|'\n'
DECL|variable|MASKS
dedent|''
name|'MASKS'
op|'='
op|'['
op|']'
newline|'\n'
DECL|variable|v
name|'v'
op|'='
number|'2'
newline|'\n'
name|'for'
name|'i'
name|'in'
name|'xrange'
op|'('
number|'63'
op|')'
op|':'
newline|'\n'
indent|'  '
name|'MASKS'
op|'.'
name|'append'
op|'('
name|'v'
op|'-'
number|'1'
op|')'
newline|'\n'
name|'v'
op|'*='
number|'2'
newline|'\n'
nl|'\n'
comment|'# packs into longs; returns long[], numBits'
nl|'\n'
DECL|function|pack
dedent|''
name|'def'
name|'pack'
op|'('
name|'l'
op|')'
op|':'
newline|'\n'
indent|'  '
name|'maxV'
op|'='
name|'max'
op|'('
name|'l'
op|')'
newline|'\n'
name|'bitsPerValue'
op|'='
name|'max'
op|'('
number|'1'
op|','
name|'int'
op|'('
name|'math'
op|'.'
name|'ceil'
op|'('
name|'math'
op|'.'
name|'log'
op|'('
name|'maxV'
op|'+'
number|'1'
op|')'
op|'/'
name|'math'
op|'.'
name|'log'
op|'('
number|'2.0'
op|')'
op|')'
op|')'
op|')'
newline|'\n'
nl|'\n'
name|'bitsLeft'
op|'='
name|'WORD'
newline|'\n'
name|'pendingValue'
op|'='
number|'0'
newline|'\n'
nl|'\n'
name|'packed'
op|'='
op|'['
op|']'
newline|'\n'
name|'for'
name|'i'
name|'in'
name|'xrange'
op|'('
name|'len'
op|'('
name|'l'
op|')'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'v'
op|'='
name|'l'
op|'['
name|'i'
op|']'
newline|'\n'
name|'if'
name|'pendingValue'
op|'>'
number|'0'
op|':'
newline|'\n'
indent|'      '
name|'bitsUsed'
op|'='
name|'math'
op|'.'
name|'ceil'
op|'('
name|'math'
op|'.'
name|'log'
op|'('
name|'pendingValue'
op|')'
op|'/'
name|'math'
op|'.'
name|'log'
op|'('
number|'2.0'
op|')'
op|')'
newline|'\n'
name|'assert'
name|'bitsUsed'
op|'<='
op|'('
name|'WORD'
op|'-'
name|'bitsLeft'
op|')'
op|','
string|"'bitsLeft=%s (%s-%s=%s) bitsUsed=%s'"
op|'%'
op|'('
name|'bitsLeft'
op|','
name|'WORD'
op|','
name|'bitsLeft'
op|','
name|'WORD'
op|'-'
name|'bitsLeft'
op|','
name|'bitsUsed'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'bitsLeft'
op|'>='
name|'bitsPerValue'
op|':'
newline|'\n'
indent|'      '
name|'pendingValue'
op|'+='
name|'v'
op|'<<'
op|'('
name|'WORD'
op|'-'
name|'bitsLeft'
op|')'
newline|'\n'
name|'bitsLeft'
op|'-='
name|'bitsPerValue'
newline|'\n'
name|'if'
name|'bitsLeft'
op|'=='
number|'0'
op|':'
newline|'\n'
indent|'        '
name|'packed'
op|'.'
name|'append'
op|'('
name|'pendingValue'
op|')'
newline|'\n'
name|'bitsLeft'
op|'='
name|'WORD'
newline|'\n'
name|'pendingValue'
op|'='
number|'0'
newline|'\n'
dedent|''
dedent|''
name|'else'
op|':'
newline|'\n'
comment|'# split'
nl|'\n'
nl|'\n'
comment|'# bottom bitsLeft go in current word:'
nl|'\n'
indent|'      '
name|'pendingValue'
op|'+='
op|'('
name|'v'
op|'&'
name|'MASKS'
op|'['
name|'bitsLeft'
op|'-'
number|'1'
op|']'
op|')'
op|'<<'
op|'('
name|'WORD'
op|'-'
name|'bitsLeft'
op|')'
newline|'\n'
name|'packed'
op|'.'
name|'append'
op|'('
name|'pendingValue'
op|')'
newline|'\n'
nl|'\n'
name|'pendingValue'
op|'='
name|'v'
op|'>>'
name|'bitsLeft'
newline|'\n'
name|'bitsLeft'
op|'='
name|'WORD'
op|'-'
op|'('
name|'bitsPerValue'
op|'-'
name|'bitsLeft'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'if'
name|'bitsLeft'
op|'<'
name|'WORD'
op|':'
newline|'\n'
indent|'    '
name|'packed'
op|'.'
name|'append'
op|'('
name|'pendingValue'
op|')'
newline|'\n'
nl|'\n'
comment|'# verify(l, packed, bitsPerValue)'
nl|'\n'
nl|'\n'
dedent|''
name|'return'
name|'packed'
op|','
name|'bitsPerValue'
newline|'\n'
nl|'\n'
DECL|function|verify
dedent|''
name|'def'
name|'verify'
op|'('
name|'data'
op|','
name|'packedData'
op|','
name|'bitsPerValue'
op|')'
op|':'
newline|'\n'
indent|'  '
name|'for'
name|'i'
name|'in'
name|'range'
op|'('
name|'len'
op|'('
name|'data'
op|')'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'assert'
name|'data'
op|'['
name|'i'
op|']'
op|'=='
name|'unpack'
op|'('
name|'packedData'
op|','
name|'i'
op|','
name|'bitsPerValue'
op|')'
newline|'\n'
nl|'\n'
DECL|function|unpack
dedent|''
dedent|''
name|'def'
name|'unpack'
op|'('
name|'data'
op|','
name|'index'
op|','
name|'bitsPerValue'
op|')'
op|':'
newline|'\n'
indent|'  '
name|'bitLoc'
op|'='
name|'bitsPerValue'
op|'*'
name|'index'
newline|'\n'
name|'dataLoc'
op|'='
name|'int'
op|'('
name|'bitLoc'
op|'>>'
name|'LOG2_WORD'
op|')'
newline|'\n'
name|'bitStart'
op|'='
name|'int'
op|'('
name|'bitLoc'
op|'&'
op|'('
name|'WORD'
op|'-'
number|'1'
op|')'
op|')'
newline|'\n'
name|'if'
name|'bitStart'
op|'+'
name|'bitsPerValue'
op|'<='
name|'WORD'
op|':'
newline|'\n'
comment|'# not split'
nl|'\n'
indent|'    '
name|'return'
name|'int'
op|'('
op|'('
op|'('
name|'data'
op|'['
name|'dataLoc'
op|']'
op|'>>'
name|'bitStart'
op|')'
op|'&'
name|'MASKS'
op|'['
name|'bitsPerValue'
op|'-'
number|'1'
op|']'
op|')'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
comment|'# split'
nl|'\n'
indent|'    '
name|'part'
op|'='
name|'WORD'
op|'-'
name|'bitStart'
op|';'
newline|'\n'
name|'return'
name|'int'
op|'('
op|'('
op|'('
op|'('
name|'data'
op|'['
name|'dataLoc'
op|']'
op|'>>'
name|'bitStart'
op|')'
op|'&'
name|'MASKS'
op|'['
name|'part'
op|'-'
number|'1'
op|']'
op|')'
op|'+'
nl|'\n'
op|'('
op|'('
name|'data'
op|'['
number|'1'
op|'+'
name|'dataLoc'
op|']'
op|'&'
name|'MASKS'
op|'['
name|'bitsPerValue'
op|'-'
name|'part'
op|'-'
number|'1'
op|']'
op|')'
op|'<<'
name|'part'
op|')'
op|')'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'if'
name|'__name__'
op|'=='
string|"'__main__'"
op|':'
newline|'\n'
indent|'  '
name|'if'
name|'not'
name|'__debug__'
op|':'
newline|'\n'
indent|'    '
name|'print'
newline|'\n'
name|'print'
string|"'ERROR: please run without -O'"
newline|'\n'
name|'print'
newline|'\n'
name|'sys'
op|'.'
name|'exit'
op|'('
number|'1'
op|')'
newline|'\n'
dedent|''
name|'main'
op|'('
op|')'
newline|'\n'
dedent|''
endmarker|''
end_unit
