begin_unit
begin_package
DECL|package|org.apache.lucene.util
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
package|;
end_package
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|DocIdSet
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|DocIdSetIterator
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|ByteArrayDataInput
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|DataInput
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|packed
operator|.
name|MonotonicAppendingLongBuffer
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|packed
operator|.
name|PackedInts
import|;
end_import
begin_comment
comment|/**  * {@link DocIdSet} implementation based on word-aligned hybrid encoding on  * words of 8 bits.  *<p>This implementation doesn't support random-access but has a fast  * {@link DocIdSetIterator} which can advance in logarithmic time thanks to  * an index.</p>  *<p>The compression scheme is simplistic and should work well with sparse doc  * id sets while being only slightly larger than a {@link FixedBitSet} for  * incompressible sets (overhead&lt;2% in the worst case) in spite of the index.</p>  *<p><b>Format</b>: The format is byte-aligned. An 8-bits word is either clean,  * meaning composed only of zeros, or dirty, meaning that it contains at least one  * bit set. The idea is to encode sequences of clean words using run-length  * encoding and to leave sequences of dirty words as-is.</p>  *<table>  *<tr><th>Token</th><th>Clean length+</th><th>Dirty length+</th><th>Dirty words</th></tr>  *<tr><td>1 byte</td><td>0-n bytes</td><td>0-n bytes</td><td>0-n bytes</td></tr>  *</table>  *<ul>  *<li><b>Token</b> encodes the number of clean words minus 2 on the first 4  * bits and the number of dirty words minus 1 on the last 4 bits. The  * higher-order bit is a continuation bit, meaning that the number is incomplete  * and needs additional bytes to be read.</li>  *<li><b>Clean length+</b>: If clean length has its higher-order bit set,  * you need to read a {@link DataInput#readVInt() vint}, shift it by 3 bits on  * the left side and add it to the 3 bits which have been read in the token.</li>  *<li><b>Dirty length+</b> works the same way as<b>Clean length+</b> but  * for the length of dirty words.</li>  *<li><b>Dirty words</b> are the dirty words, there are<b>Dirty length</b>  * of them.</li>  *</ul>  *<p>This format cannot encode sequences of less than 2 clean words and 1 dirty  * word. The reason is that if you find a single clean word, you should rather  * encode it as a dirty word. This takes the same space as starting a new  * sequence (since you need one byte for the token) but will be lighter to  * decode. There is however an exception for the first sequence. Since the first  * sequence may start directly with a dirty word, the clean length is encoded  * directly, without subtracting 2.</p>  *<p>There is an additional restriction on the format: the sequence of dirty  * words must start and end with a non-null word and is not allowed to contain  * two consecutive null words. This restriction exists to make sure no space is  * wasted and to make sure iterators can read the next doc ID by reading at most  * 2 dirty words.</p>  * @lucene.experimental  */
end_comment
begin_class
DECL|class|WAH8DocIdSet
specifier|public
specifier|final
class|class
name|WAH8DocIdSet
extends|extends
name|DocIdSet
block|{
comment|// Minimum index interval, intervals below this value can't guarantee anymore
comment|// that this set implementation won't be significantly larger than a FixedBitSet
comment|// The reason is that a single sequence saves at least one byte and an index
comment|// entry requires at most 8 bytes (2 ints) so there shouldn't be more than one
comment|// index entry every 8 sequences
DECL|field|MIN_INDEX_INTERVAL
specifier|private
specifier|static
specifier|final
name|int
name|MIN_INDEX_INTERVAL
init|=
literal|8
decl_stmt|;
comment|/** Default index interval. */
DECL|field|DEFAULT_INDEX_INTERVAL
specifier|public
specifier|static
specifier|final
name|int
name|DEFAULT_INDEX_INTERVAL
init|=
name|MIN_INDEX_INTERVAL
decl_stmt|;
DECL|field|SINGLE_ZERO_BUFFER
specifier|private
specifier|static
specifier|final
name|MonotonicAppendingLongBuffer
name|SINGLE_ZERO_BUFFER
init|=
operator|new
name|MonotonicAppendingLongBuffer
argument_list|()
decl_stmt|;
DECL|field|EMPTY
specifier|private
specifier|static
name|WAH8DocIdSet
name|EMPTY
init|=
operator|new
name|WAH8DocIdSet
argument_list|(
operator|new
name|byte
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|SINGLE_ZERO_BUFFER
argument_list|,
name|SINGLE_ZERO_BUFFER
argument_list|)
decl_stmt|;
static|static
block|{
name|SINGLE_ZERO_BUFFER
operator|.
name|add
argument_list|(
literal|0L
argument_list|)
expr_stmt|;
name|SINGLE_ZERO_BUFFER
operator|.
name|freeze
argument_list|()
expr_stmt|;
block|}
DECL|field|SERIALIZED_LENGTH_COMPARATOR
specifier|private
specifier|static
specifier|final
name|Comparator
argument_list|<
name|Iterator
argument_list|>
name|SERIALIZED_LENGTH_COMPARATOR
init|=
operator|new
name|Comparator
argument_list|<
name|Iterator
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|int
name|compare
parameter_list|(
name|Iterator
name|wi1
parameter_list|,
name|Iterator
name|wi2
parameter_list|)
block|{
return|return
name|wi1
operator|.
name|in
operator|.
name|length
argument_list|()
operator|-
name|wi2
operator|.
name|in
operator|.
name|length
argument_list|()
return|;
block|}
block|}
decl_stmt|;
comment|/** Same as {@link #intersect(Collection, int)} with the default index interval. */
DECL|method|intersect
specifier|public
specifier|static
name|WAH8DocIdSet
name|intersect
parameter_list|(
name|Collection
argument_list|<
name|WAH8DocIdSet
argument_list|>
name|docIdSets
parameter_list|)
block|{
return|return
name|intersect
argument_list|(
name|docIdSets
argument_list|,
name|DEFAULT_INDEX_INTERVAL
argument_list|)
return|;
block|}
comment|/**    * Compute the intersection of the provided sets. This method is much faster than    * computing the intersection manually since it operates directly at the byte level.    */
DECL|method|intersect
specifier|public
specifier|static
name|WAH8DocIdSet
name|intersect
parameter_list|(
name|Collection
argument_list|<
name|WAH8DocIdSet
argument_list|>
name|docIdSets
parameter_list|,
name|int
name|indexInterval
parameter_list|)
block|{
switch|switch
condition|(
name|docIdSets
operator|.
name|size
argument_list|()
condition|)
block|{
case|case
literal|0
case|:
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"There must be at least one set to intersect"
argument_list|)
throw|;
case|case
literal|1
case|:
return|return
name|docIdSets
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
return|;
block|}
comment|// The logic below is similar to ConjunctionScorer
specifier|final
name|int
name|numSets
init|=
name|docIdSets
operator|.
name|size
argument_list|()
decl_stmt|;
specifier|final
name|Iterator
index|[]
name|iterators
init|=
operator|new
name|Iterator
index|[
name|numSets
index|]
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
name|WAH8DocIdSet
name|set
range|:
name|docIdSets
control|)
block|{
specifier|final
name|Iterator
name|it
init|=
name|set
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|iterators
index|[
name|i
operator|++
index|]
operator|=
name|it
expr_stmt|;
block|}
name|Arrays
operator|.
name|sort
argument_list|(
name|iterators
argument_list|,
name|SERIALIZED_LENGTH_COMPARATOR
argument_list|)
expr_stmt|;
specifier|final
name|WordBuilder
name|builder
init|=
operator|new
name|WordBuilder
argument_list|()
operator|.
name|setIndexInterval
argument_list|(
name|indexInterval
argument_list|)
decl_stmt|;
name|int
name|wordNum
init|=
literal|0
decl_stmt|;
name|main
label|:
while|while
condition|(
literal|true
condition|)
block|{
comment|// Advance the least costly iterator first
name|iterators
index|[
literal|0
index|]
operator|.
name|advanceWord
argument_list|(
name|wordNum
argument_list|)
expr_stmt|;
name|wordNum
operator|=
name|iterators
index|[
literal|0
index|]
operator|.
name|wordNum
expr_stmt|;
if|if
condition|(
name|wordNum
operator|==
name|DocIdSetIterator
operator|.
name|NO_MORE_DOCS
condition|)
block|{
break|break;
block|}
name|byte
name|word
init|=
name|iterators
index|[
literal|0
index|]
operator|.
name|word
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|numSets
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|iterators
index|[
name|i
index|]
operator|.
name|wordNum
operator|<
name|wordNum
condition|)
block|{
name|iterators
index|[
name|i
index|]
operator|.
name|advanceWord
argument_list|(
name|wordNum
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|iterators
index|[
name|i
index|]
operator|.
name|wordNum
operator|>
name|wordNum
condition|)
block|{
name|wordNum
operator|=
name|iterators
index|[
name|i
index|]
operator|.
name|wordNum
expr_stmt|;
continue|continue
name|main
continue|;
block|}
assert|assert
name|iterators
index|[
name|i
index|]
operator|.
name|wordNum
operator|==
name|wordNum
assert|;
name|word
operator|&=
name|iterators
index|[
name|i
index|]
operator|.
name|word
expr_stmt|;
if|if
condition|(
name|word
operator|==
literal|0
condition|)
block|{
comment|// There are common words, but they don't share any bit
operator|++
name|wordNum
expr_stmt|;
continue|continue
name|main
continue|;
block|}
block|}
comment|// Found a common word
assert|assert
name|word
operator|!=
literal|0
assert|;
name|builder
operator|.
name|addWord
argument_list|(
name|wordNum
argument_list|,
name|word
argument_list|)
expr_stmt|;
operator|++
name|wordNum
expr_stmt|;
block|}
return|return
name|builder
operator|.
name|build
argument_list|()
return|;
block|}
comment|/** Same as {@link #union(Collection, int)} with the default index interval. */
DECL|method|union
specifier|public
specifier|static
name|WAH8DocIdSet
name|union
parameter_list|(
name|Collection
argument_list|<
name|WAH8DocIdSet
argument_list|>
name|docIdSets
parameter_list|)
block|{
return|return
name|union
argument_list|(
name|docIdSets
argument_list|,
name|DEFAULT_INDEX_INTERVAL
argument_list|)
return|;
block|}
comment|/**    * Compute the union of the provided sets. This method is much faster than    * computing the union manually since it operates directly at the byte level.    */
DECL|method|union
specifier|public
specifier|static
name|WAH8DocIdSet
name|union
parameter_list|(
name|Collection
argument_list|<
name|WAH8DocIdSet
argument_list|>
name|docIdSets
parameter_list|,
name|int
name|indexInterval
parameter_list|)
block|{
switch|switch
condition|(
name|docIdSets
operator|.
name|size
argument_list|()
condition|)
block|{
case|case
literal|0
case|:
return|return
name|EMPTY
return|;
case|case
literal|1
case|:
return|return
name|docIdSets
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
return|;
block|}
comment|// The logic below is very similar to DisjunctionScorer
specifier|final
name|int
name|numSets
init|=
name|docIdSets
operator|.
name|size
argument_list|()
decl_stmt|;
specifier|final
name|PriorityQueue
argument_list|<
name|Iterator
argument_list|>
name|iterators
init|=
operator|new
name|PriorityQueue
argument_list|<
name|WAH8DocIdSet
operator|.
name|Iterator
argument_list|>
argument_list|(
name|numSets
argument_list|)
block|{
annotation|@
name|Override
specifier|protected
name|boolean
name|lessThan
parameter_list|(
name|Iterator
name|a
parameter_list|,
name|Iterator
name|b
parameter_list|)
block|{
return|return
name|a
operator|.
name|wordNum
operator|<
name|b
operator|.
name|wordNum
return|;
block|}
block|}
decl_stmt|;
for|for
control|(
name|WAH8DocIdSet
name|set
range|:
name|docIdSets
control|)
block|{
name|Iterator
name|iterator
init|=
name|set
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|iterator
operator|.
name|nextWord
argument_list|()
expr_stmt|;
name|iterators
operator|.
name|add
argument_list|(
name|iterator
argument_list|)
expr_stmt|;
block|}
name|Iterator
name|top
init|=
name|iterators
operator|.
name|top
argument_list|()
decl_stmt|;
if|if
condition|(
name|top
operator|.
name|wordNum
operator|==
name|Integer
operator|.
name|MAX_VALUE
condition|)
block|{
return|return
name|EMPTY
return|;
block|}
name|int
name|wordNum
init|=
name|top
operator|.
name|wordNum
decl_stmt|;
name|byte
name|word
init|=
name|top
operator|.
name|word
decl_stmt|;
specifier|final
name|WordBuilder
name|builder
init|=
operator|new
name|WordBuilder
argument_list|()
operator|.
name|setIndexInterval
argument_list|(
name|indexInterval
argument_list|)
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|top
operator|.
name|nextWord
argument_list|()
expr_stmt|;
name|iterators
operator|.
name|updateTop
argument_list|()
expr_stmt|;
name|top
operator|=
name|iterators
operator|.
name|top
argument_list|()
expr_stmt|;
if|if
condition|(
name|top
operator|.
name|wordNum
operator|==
name|wordNum
condition|)
block|{
name|word
operator||=
name|top
operator|.
name|word
expr_stmt|;
block|}
else|else
block|{
name|builder
operator|.
name|addWord
argument_list|(
name|wordNum
argument_list|,
name|word
argument_list|)
expr_stmt|;
if|if
condition|(
name|top
operator|.
name|wordNum
operator|==
name|Integer
operator|.
name|MAX_VALUE
condition|)
block|{
break|break;
block|}
name|wordNum
operator|=
name|top
operator|.
name|wordNum
expr_stmt|;
name|word
operator|=
name|top
operator|.
name|word
expr_stmt|;
block|}
block|}
return|return
name|builder
operator|.
name|build
argument_list|()
return|;
block|}
DECL|method|wordNum
specifier|static
name|int
name|wordNum
parameter_list|(
name|int
name|docID
parameter_list|)
block|{
assert|assert
name|docID
operator|>=
literal|0
assert|;
return|return
name|docID
operator|>>>
literal|3
return|;
block|}
comment|/** Word-based builder. */
DECL|class|WordBuilder
specifier|static
class|class
name|WordBuilder
block|{
DECL|field|out
specifier|final
name|GrowableByteArrayDataOutput
name|out
decl_stmt|;
DECL|field|dirtyWords
specifier|final
name|GrowableByteArrayDataOutput
name|dirtyWords
decl_stmt|;
DECL|field|clean
name|int
name|clean
decl_stmt|;
DECL|field|lastWordNum
name|int
name|lastWordNum
decl_stmt|;
DECL|field|numSequences
name|int
name|numSequences
decl_stmt|;
DECL|field|indexInterval
name|int
name|indexInterval
decl_stmt|;
DECL|field|cardinality
name|int
name|cardinality
decl_stmt|;
DECL|method|WordBuilder
name|WordBuilder
parameter_list|()
block|{
name|out
operator|=
operator|new
name|GrowableByteArrayDataOutput
argument_list|(
literal|1024
argument_list|)
expr_stmt|;
name|dirtyWords
operator|=
operator|new
name|GrowableByteArrayDataOutput
argument_list|(
literal|128
argument_list|)
expr_stmt|;
name|clean
operator|=
literal|0
expr_stmt|;
name|lastWordNum
operator|=
operator|-
literal|1
expr_stmt|;
name|numSequences
operator|=
literal|0
expr_stmt|;
name|indexInterval
operator|=
name|DEFAULT_INDEX_INTERVAL
expr_stmt|;
name|cardinality
operator|=
literal|0
expr_stmt|;
block|}
comment|/** Set the index interval. Smaller index intervals improve performance of      *  {@link DocIdSetIterator#advance(int)} but make the {@link DocIdSet}      *  larger. An index interval<code>i</code> makes the index add an overhead      *  which is at most<code>4/i</code>, but likely much less.The default index      *  interval is<code>8</code>, meaning the index has an overhead of at most      *  50%. To disable indexing, you can pass {@link Integer#MAX_VALUE} as an      *  index interval. */
DECL|method|setIndexInterval
specifier|public
name|WordBuilder
name|setIndexInterval
parameter_list|(
name|int
name|indexInterval
parameter_list|)
block|{
if|if
condition|(
name|indexInterval
operator|<
name|MIN_INDEX_INTERVAL
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"indexInterval must be>= "
operator|+
name|MIN_INDEX_INTERVAL
argument_list|)
throw|;
block|}
name|this
operator|.
name|indexInterval
operator|=
name|indexInterval
expr_stmt|;
return|return
name|this
return|;
block|}
DECL|method|writeHeader
name|void
name|writeHeader
parameter_list|(
name|int
name|cleanLength
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|int
name|cleanLengthMinus2
init|=
name|cleanLength
operator|-
literal|2
decl_stmt|;
specifier|final
name|int
name|dirtyLengthMinus1
init|=
name|dirtyWords
operator|.
name|length
operator|-
literal|1
decl_stmt|;
assert|assert
name|cleanLengthMinus2
operator|>=
literal|0
assert|;
assert|assert
name|dirtyLengthMinus1
operator|>=
literal|0
assert|;
name|int
name|token
init|=
operator|(
operator|(
name|cleanLengthMinus2
operator|&
literal|0x07
operator|)
operator|<<
literal|4
operator|)
operator||
operator|(
name|dirtyLengthMinus1
operator|&
literal|0x07
operator|)
decl_stmt|;
if|if
condition|(
name|cleanLengthMinus2
operator|>
literal|0x07
condition|)
block|{
name|token
operator||=
literal|1
operator|<<
literal|7
expr_stmt|;
block|}
if|if
condition|(
name|dirtyLengthMinus1
operator|>
literal|0x07
condition|)
block|{
name|token
operator||=
literal|1
operator|<<
literal|3
expr_stmt|;
block|}
name|out
operator|.
name|writeByte
argument_list|(
operator|(
name|byte
operator|)
name|token
argument_list|)
expr_stmt|;
if|if
condition|(
name|cleanLengthMinus2
operator|>
literal|0x07
condition|)
block|{
name|out
operator|.
name|writeVInt
argument_list|(
name|cleanLengthMinus2
operator|>>>
literal|3
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dirtyLengthMinus1
operator|>
literal|0x07
condition|)
block|{
name|out
operator|.
name|writeVInt
argument_list|(
name|dirtyLengthMinus1
operator|>>>
literal|3
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|writeSequence
name|void
name|writeSequence
parameter_list|(
name|int
name|cleanLength
parameter_list|)
block|{
try|try
block|{
name|writeHeader
argument_list|(
name|cleanLength
argument_list|)
expr_stmt|;
name|out
operator|.
name|writeBytes
argument_list|(
name|dirtyWords
operator|.
name|bytes
argument_list|,
name|dirtyWords
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|cannotHappen
parameter_list|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
name|cannotHappen
argument_list|)
throw|;
block|}
name|dirtyWords
operator|.
name|length
operator|=
literal|0
expr_stmt|;
operator|++
name|numSequences
expr_stmt|;
block|}
DECL|method|addWord
name|void
name|addWord
parameter_list|(
name|int
name|wordNum
parameter_list|,
name|byte
name|word
parameter_list|)
block|{
assert|assert
name|wordNum
operator|>
name|lastWordNum
assert|;
assert|assert
name|word
operator|!=
literal|0
assert|;
if|if
condition|(
name|lastWordNum
operator|==
operator|-
literal|1
condition|)
block|{
name|clean
operator|=
literal|2
operator|+
name|wordNum
expr_stmt|;
comment|// special case for the 1st sequence
name|dirtyWords
operator|.
name|writeByte
argument_list|(
name|word
argument_list|)
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|wordNum
operator|-
name|lastWordNum
condition|)
block|{
case|case
literal|1
case|:
name|dirtyWords
operator|.
name|writeByte
argument_list|(
name|word
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|dirtyWords
operator|.
name|writeByte
argument_list|(
operator|(
name|byte
operator|)
literal|0
argument_list|)
expr_stmt|;
name|dirtyWords
operator|.
name|writeByte
argument_list|(
name|word
argument_list|)
expr_stmt|;
break|break;
default|default:
name|writeSequence
argument_list|(
name|clean
argument_list|)
expr_stmt|;
name|clean
operator|=
name|wordNum
operator|-
name|lastWordNum
operator|-
literal|1
expr_stmt|;
name|dirtyWords
operator|.
name|writeByte
argument_list|(
name|word
argument_list|)
expr_stmt|;
block|}
block|}
name|lastWordNum
operator|=
name|wordNum
expr_stmt|;
name|cardinality
operator|+=
name|BitUtil
operator|.
name|bitCount
argument_list|(
name|word
argument_list|)
expr_stmt|;
block|}
comment|/** Build a new {@link WAH8DocIdSet}. */
DECL|method|build
specifier|public
name|WAH8DocIdSet
name|build
parameter_list|()
block|{
if|if
condition|(
name|cardinality
operator|==
literal|0
condition|)
block|{
assert|assert
name|lastWordNum
operator|==
operator|-
literal|1
assert|;
return|return
name|EMPTY
return|;
block|}
name|writeSequence
argument_list|(
name|clean
argument_list|)
expr_stmt|;
specifier|final
name|byte
index|[]
name|data
init|=
name|Arrays
operator|.
name|copyOf
argument_list|(
name|out
operator|.
name|bytes
argument_list|,
name|out
operator|.
name|length
argument_list|)
decl_stmt|;
comment|// Now build the index
specifier|final
name|int
name|valueCount
init|=
operator|(
name|numSequences
operator|-
literal|1
operator|)
operator|/
name|indexInterval
operator|+
literal|1
decl_stmt|;
specifier|final
name|MonotonicAppendingLongBuffer
name|indexPositions
decl_stmt|,
name|indexWordNums
decl_stmt|;
if|if
condition|(
name|valueCount
operator|<=
literal|1
condition|)
block|{
name|indexPositions
operator|=
name|indexWordNums
operator|=
name|SINGLE_ZERO_BUFFER
expr_stmt|;
block|}
else|else
block|{
specifier|final
name|int
name|pageSize
init|=
literal|128
decl_stmt|;
specifier|final
name|int
name|initialPageCount
init|=
operator|(
name|valueCount
operator|+
name|pageSize
operator|-
literal|1
operator|)
operator|/
name|pageSize
decl_stmt|;
specifier|final
name|MonotonicAppendingLongBuffer
name|positions
init|=
operator|new
name|MonotonicAppendingLongBuffer
argument_list|(
name|initialPageCount
argument_list|,
name|pageSize
argument_list|,
name|PackedInts
operator|.
name|COMPACT
argument_list|)
decl_stmt|;
specifier|final
name|MonotonicAppendingLongBuffer
name|wordNums
init|=
operator|new
name|MonotonicAppendingLongBuffer
argument_list|(
name|initialPageCount
argument_list|,
name|pageSize
argument_list|,
name|PackedInts
operator|.
name|COMPACT
argument_list|)
decl_stmt|;
name|positions
operator|.
name|add
argument_list|(
literal|0L
argument_list|)
expr_stmt|;
name|wordNums
operator|.
name|add
argument_list|(
literal|0L
argument_list|)
expr_stmt|;
specifier|final
name|Iterator
name|it
init|=
operator|new
name|Iterator
argument_list|(
name|data
argument_list|,
name|cardinality
argument_list|,
name|Integer
operator|.
name|MAX_VALUE
argument_list|,
name|SINGLE_ZERO_BUFFER
argument_list|,
name|SINGLE_ZERO_BUFFER
argument_list|)
decl_stmt|;
assert|assert
name|it
operator|.
name|in
operator|.
name|getPosition
argument_list|()
operator|==
literal|0
assert|;
assert|assert
name|it
operator|.
name|wordNum
operator|==
operator|-
literal|1
assert|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|valueCount
condition|;
operator|++
name|i
control|)
block|{
comment|// skip indexInterval sequences
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|indexInterval
condition|;
operator|++
name|j
control|)
block|{
specifier|final
name|boolean
name|readSequence
init|=
name|it
operator|.
name|readSequence
argument_list|()
decl_stmt|;
assert|assert
name|readSequence
assert|;
name|it
operator|.
name|skipDirtyBytes
argument_list|()
expr_stmt|;
block|}
specifier|final
name|int
name|position
init|=
name|it
operator|.
name|in
operator|.
name|getPosition
argument_list|()
decl_stmt|;
specifier|final
name|int
name|wordNum
init|=
name|it
operator|.
name|wordNum
decl_stmt|;
name|positions
operator|.
name|add
argument_list|(
name|position
argument_list|)
expr_stmt|;
name|wordNums
operator|.
name|add
argument_list|(
name|wordNum
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
name|positions
operator|.
name|freeze
argument_list|()
expr_stmt|;
name|wordNums
operator|.
name|freeze
argument_list|()
expr_stmt|;
name|indexPositions
operator|=
name|positions
expr_stmt|;
name|indexWordNums
operator|=
name|wordNums
expr_stmt|;
block|}
return|return
operator|new
name|WAH8DocIdSet
argument_list|(
name|data
argument_list|,
name|cardinality
argument_list|,
name|indexInterval
argument_list|,
name|indexPositions
argument_list|,
name|indexWordNums
argument_list|)
return|;
block|}
block|}
comment|/** A builder for {@link WAH8DocIdSet}s. */
DECL|class|Builder
specifier|public
specifier|static
specifier|final
class|class
name|Builder
extends|extends
name|WordBuilder
block|{
DECL|field|lastDocID
specifier|private
name|int
name|lastDocID
decl_stmt|;
DECL|field|wordNum
DECL|field|word
specifier|private
name|int
name|wordNum
decl_stmt|,
name|word
decl_stmt|;
comment|/** Sole constructor */
DECL|method|Builder
specifier|public
name|Builder
parameter_list|()
block|{
name|super
argument_list|()
expr_stmt|;
name|lastDocID
operator|=
operator|-
literal|1
expr_stmt|;
name|wordNum
operator|=
operator|-
literal|1
expr_stmt|;
name|word
operator|=
literal|0
expr_stmt|;
block|}
comment|/** Add a document to this builder. Documents must be added in order. */
DECL|method|add
specifier|public
name|Builder
name|add
parameter_list|(
name|int
name|docID
parameter_list|)
block|{
if|if
condition|(
name|docID
operator|<=
name|lastDocID
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Doc ids must be added in-order, got "
operator|+
name|docID
operator|+
literal|" which is<= lastDocID="
operator|+
name|lastDocID
argument_list|)
throw|;
block|}
specifier|final
name|int
name|wordNum
init|=
name|wordNum
argument_list|(
name|docID
argument_list|)
decl_stmt|;
if|if
condition|(
name|this
operator|.
name|wordNum
operator|==
operator|-
literal|1
condition|)
block|{
name|this
operator|.
name|wordNum
operator|=
name|wordNum
expr_stmt|;
name|word
operator|=
literal|1
operator|<<
operator|(
name|docID
operator|&
literal|0x07
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|wordNum
operator|==
name|this
operator|.
name|wordNum
condition|)
block|{
name|word
operator||=
literal|1
operator|<<
operator|(
name|docID
operator|&
literal|0x07
operator|)
expr_stmt|;
block|}
else|else
block|{
name|addWord
argument_list|(
name|this
operator|.
name|wordNum
argument_list|,
operator|(
name|byte
operator|)
name|word
argument_list|)
expr_stmt|;
name|this
operator|.
name|wordNum
operator|=
name|wordNum
expr_stmt|;
name|word
operator|=
literal|1
operator|<<
operator|(
name|docID
operator|&
literal|0x07
operator|)
expr_stmt|;
block|}
name|lastDocID
operator|=
name|docID
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/** Add the content of the provided {@link DocIdSetIterator}. */
DECL|method|add
specifier|public
name|Builder
name|add
parameter_list|(
name|DocIdSetIterator
name|disi
parameter_list|)
throws|throws
name|IOException
block|{
for|for
control|(
name|int
name|doc
init|=
name|disi
operator|.
name|nextDoc
argument_list|()
init|;
name|doc
operator|!=
name|DocIdSetIterator
operator|.
name|NO_MORE_DOCS
condition|;
name|doc
operator|=
name|disi
operator|.
name|nextDoc
argument_list|()
control|)
block|{
name|add
argument_list|(
name|doc
argument_list|)
expr_stmt|;
block|}
return|return
name|this
return|;
block|}
annotation|@
name|Override
DECL|method|setIndexInterval
specifier|public
name|Builder
name|setIndexInterval
parameter_list|(
name|int
name|indexInterval
parameter_list|)
block|{
return|return
operator|(
name|Builder
operator|)
name|super
operator|.
name|setIndexInterval
argument_list|(
name|indexInterval
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|build
specifier|public
name|WAH8DocIdSet
name|build
parameter_list|()
block|{
if|if
condition|(
name|this
operator|.
name|wordNum
operator|!=
operator|-
literal|1
condition|)
block|{
name|addWord
argument_list|(
name|wordNum
argument_list|,
operator|(
name|byte
operator|)
name|word
argument_list|)
expr_stmt|;
block|}
return|return
name|super
operator|.
name|build
argument_list|()
return|;
block|}
block|}
comment|// where the doc IDs are stored
DECL|field|data
specifier|private
specifier|final
name|byte
index|[]
name|data
decl_stmt|;
DECL|field|cardinality
specifier|private
specifier|final
name|int
name|cardinality
decl_stmt|;
DECL|field|indexInterval
specifier|private
specifier|final
name|int
name|indexInterval
decl_stmt|;
comment|// index for advance(int)
DECL|field|positions
DECL|field|wordNums
specifier|private
specifier|final
name|MonotonicAppendingLongBuffer
name|positions
decl_stmt|,
name|wordNums
decl_stmt|;
comment|// wordNums[i] starts at the sequence at positions[i]
DECL|method|WAH8DocIdSet
name|WAH8DocIdSet
parameter_list|(
name|byte
index|[]
name|data
parameter_list|,
name|int
name|cardinality
parameter_list|,
name|int
name|indexInterval
parameter_list|,
name|MonotonicAppendingLongBuffer
name|positions
parameter_list|,
name|MonotonicAppendingLongBuffer
name|wordNums
parameter_list|)
block|{
name|this
operator|.
name|data
operator|=
name|data
expr_stmt|;
name|this
operator|.
name|cardinality
operator|=
name|cardinality
expr_stmt|;
name|this
operator|.
name|indexInterval
operator|=
name|indexInterval
expr_stmt|;
name|this
operator|.
name|positions
operator|=
name|positions
expr_stmt|;
name|this
operator|.
name|wordNums
operator|=
name|wordNums
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|isCacheable
specifier|public
name|boolean
name|isCacheable
parameter_list|()
block|{
return|return
literal|true
return|;
block|}
annotation|@
name|Override
DECL|method|iterator
specifier|public
name|Iterator
name|iterator
parameter_list|()
block|{
return|return
operator|new
name|Iterator
argument_list|(
name|data
argument_list|,
name|cardinality
argument_list|,
name|indexInterval
argument_list|,
name|positions
argument_list|,
name|wordNums
argument_list|)
return|;
block|}
DECL|method|readLength
specifier|static
name|int
name|readLength
parameter_list|(
name|ByteArrayDataInput
name|in
parameter_list|,
name|int
name|len
parameter_list|)
block|{
if|if
condition|(
operator|(
name|len
operator|&
literal|0x08
operator|)
operator|==
literal|0
condition|)
block|{
comment|// no continuation bit
return|return
name|len
return|;
block|}
return|return
operator|(
name|len
operator|&
literal|0x07
operator|)
operator||
operator|(
name|in
operator|.
name|readVInt
argument_list|()
operator|<<
literal|3
operator|)
return|;
block|}
DECL|class|Iterator
specifier|static
class|class
name|Iterator
extends|extends
name|DocIdSetIterator
block|{
DECL|field|in
specifier|final
name|ByteArrayDataInput
name|in
decl_stmt|;
DECL|field|cardinality
specifier|final
name|int
name|cardinality
decl_stmt|;
DECL|field|indexInterval
specifier|final
name|int
name|indexInterval
decl_stmt|;
DECL|field|positions
DECL|field|wordNums
specifier|final
name|MonotonicAppendingLongBuffer
name|positions
decl_stmt|,
name|wordNums
decl_stmt|;
DECL|field|dirtyLength
name|int
name|dirtyLength
decl_stmt|;
DECL|field|wordNum
name|int
name|wordNum
decl_stmt|;
comment|// byte offset
DECL|field|word
name|byte
name|word
decl_stmt|;
comment|// current word
DECL|field|bitList
name|int
name|bitList
decl_stmt|;
comment|// list of bits set in the current word
DECL|field|sequenceNum
name|int
name|sequenceNum
decl_stmt|;
comment|// in which sequence are we?
DECL|field|docID
name|int
name|docID
decl_stmt|;
DECL|method|Iterator
name|Iterator
parameter_list|(
name|byte
index|[]
name|data
parameter_list|,
name|int
name|cardinality
parameter_list|,
name|int
name|indexInterval
parameter_list|,
name|MonotonicAppendingLongBuffer
name|positions
parameter_list|,
name|MonotonicAppendingLongBuffer
name|wordNums
parameter_list|)
block|{
name|this
operator|.
name|in
operator|=
operator|new
name|ByteArrayDataInput
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|this
operator|.
name|cardinality
operator|=
name|cardinality
expr_stmt|;
name|this
operator|.
name|indexInterval
operator|=
name|indexInterval
expr_stmt|;
name|this
operator|.
name|positions
operator|=
name|positions
expr_stmt|;
name|this
operator|.
name|wordNums
operator|=
name|wordNums
expr_stmt|;
name|wordNum
operator|=
operator|-
literal|1
expr_stmt|;
name|word
operator|=
literal|0
expr_stmt|;
name|bitList
operator|=
literal|0
expr_stmt|;
name|sequenceNum
operator|=
operator|-
literal|1
expr_stmt|;
name|docID
operator|=
operator|-
literal|1
expr_stmt|;
block|}
DECL|method|readSequence
name|boolean
name|readSequence
parameter_list|()
block|{
if|if
condition|(
name|in
operator|.
name|eof
argument_list|()
condition|)
block|{
name|wordNum
operator|=
name|Integer
operator|.
name|MAX_VALUE
expr_stmt|;
return|return
literal|false
return|;
block|}
specifier|final
name|int
name|token
init|=
name|in
operator|.
name|readByte
argument_list|()
operator|&
literal|0xFF
decl_stmt|;
specifier|final
name|int
name|cleanLength
init|=
operator|(
name|in
operator|.
name|getPosition
argument_list|()
operator|==
literal|1
condition|?
literal|0
else|:
literal|2
operator|)
operator|+
name|readLength
argument_list|(
name|in
argument_list|,
name|token
operator|>>>
literal|4
argument_list|)
decl_stmt|;
name|wordNum
operator|+=
name|cleanLength
expr_stmt|;
name|dirtyLength
operator|=
literal|1
operator|+
name|readLength
argument_list|(
name|in
argument_list|,
name|token
operator|&
literal|0x0F
argument_list|)
expr_stmt|;
operator|++
name|sequenceNum
expr_stmt|;
return|return
literal|true
return|;
block|}
DECL|method|skipDirtyBytes
name|void
name|skipDirtyBytes
parameter_list|(
name|int
name|count
parameter_list|)
block|{
assert|assert
name|count
operator|>=
literal|0
assert|;
assert|assert
name|count
operator|<=
name|dirtyLength
assert|;
name|in
operator|.
name|skipBytes
argument_list|(
name|count
argument_list|)
expr_stmt|;
name|wordNum
operator|+=
name|count
expr_stmt|;
name|dirtyLength
operator|-=
name|count
expr_stmt|;
block|}
DECL|method|skipDirtyBytes
name|void
name|skipDirtyBytes
parameter_list|()
block|{
name|in
operator|.
name|skipBytes
argument_list|(
name|dirtyLength
argument_list|)
expr_stmt|;
name|wordNum
operator|+=
name|dirtyLength
expr_stmt|;
name|dirtyLength
operator|=
literal|0
expr_stmt|;
block|}
DECL|method|nextWord
name|void
name|nextWord
parameter_list|()
block|{
if|if
condition|(
name|dirtyLength
operator|==
literal|0
operator|&&
operator|!
name|readSequence
argument_list|()
condition|)
block|{
return|return;
block|}
name|word
operator|=
name|in
operator|.
name|readByte
argument_list|()
expr_stmt|;
if|if
condition|(
name|word
operator|==
literal|0
condition|)
block|{
name|word
operator|=
name|in
operator|.
name|readByte
argument_list|()
expr_stmt|;
assert|assert
name|word
operator|!=
literal|0
assert|;
comment|// there can never be two consecutive null dirty words
operator|++
name|wordNum
expr_stmt|;
operator|--
name|dirtyLength
expr_stmt|;
block|}
operator|++
name|wordNum
expr_stmt|;
operator|--
name|dirtyLength
expr_stmt|;
block|}
DECL|method|forwardBinarySearch
name|int
name|forwardBinarySearch
parameter_list|(
name|int
name|targetWordNum
parameter_list|)
block|{
comment|// advance forward and double the window at each step
specifier|final
name|int
name|indexSize
init|=
operator|(
name|int
operator|)
name|wordNums
operator|.
name|size
argument_list|()
decl_stmt|;
name|int
name|lo
init|=
name|sequenceNum
operator|/
name|indexInterval
decl_stmt|,
name|hi
init|=
name|lo
operator|+
literal|1
decl_stmt|;
assert|assert
name|sequenceNum
operator|==
operator|-
literal|1
operator|||
name|wordNums
operator|.
name|get
argument_list|(
name|lo
argument_list|)
operator|<=
name|wordNum
assert|;
assert|assert
name|lo
operator|+
literal|1
operator|==
name|wordNums
operator|.
name|size
argument_list|()
operator|||
name|wordNums
operator|.
name|get
argument_list|(
name|lo
operator|+
literal|1
argument_list|)
operator|>
name|wordNum
assert|;
while|while
condition|(
literal|true
condition|)
block|{
if|if
condition|(
name|hi
operator|>=
name|indexSize
condition|)
block|{
name|hi
operator|=
name|indexSize
operator|-
literal|1
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|wordNums
operator|.
name|get
argument_list|(
name|hi
argument_list|)
operator|>=
name|targetWordNum
condition|)
block|{
break|break;
block|}
specifier|final
name|int
name|newLo
init|=
name|hi
decl_stmt|;
name|hi
operator|+=
operator|(
name|hi
operator|-
name|lo
operator|)
operator|<<
literal|1
expr_stmt|;
name|lo
operator|=
name|newLo
expr_stmt|;
block|}
comment|// we found a window containing our target, let's binary search now
while|while
condition|(
name|lo
operator|<=
name|hi
condition|)
block|{
specifier|final
name|int
name|mid
init|=
operator|(
name|lo
operator|+
name|hi
operator|)
operator|>>>
literal|1
decl_stmt|;
specifier|final
name|int
name|midWordNum
init|=
operator|(
name|int
operator|)
name|wordNums
operator|.
name|get
argument_list|(
name|mid
argument_list|)
decl_stmt|;
if|if
condition|(
name|midWordNum
operator|<=
name|targetWordNum
condition|)
block|{
name|lo
operator|=
name|mid
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
name|hi
operator|=
name|mid
operator|-
literal|1
expr_stmt|;
block|}
block|}
assert|assert
name|wordNums
operator|.
name|get
argument_list|(
name|hi
argument_list|)
operator|<=
name|targetWordNum
assert|;
assert|assert
name|hi
operator|+
literal|1
operator|==
name|wordNums
operator|.
name|size
argument_list|()
operator|||
name|wordNums
operator|.
name|get
argument_list|(
name|hi
operator|+
literal|1
argument_list|)
operator|>
name|targetWordNum
assert|;
return|return
name|hi
return|;
block|}
DECL|method|advanceWord
name|void
name|advanceWord
parameter_list|(
name|int
name|targetWordNum
parameter_list|)
block|{
assert|assert
name|targetWordNum
operator|>
name|wordNum
assert|;
name|int
name|delta
init|=
name|targetWordNum
operator|-
name|wordNum
decl_stmt|;
if|if
condition|(
name|delta
operator|<=
name|dirtyLength
operator|+
literal|1
condition|)
block|{
if|if
condition|(
name|delta
operator|>
literal|1
condition|)
block|{
name|skipDirtyBytes
argument_list|(
name|delta
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|skipDirtyBytes
argument_list|()
expr_stmt|;
assert|assert
name|dirtyLength
operator|==
literal|0
assert|;
comment|// use the index
specifier|final
name|int
name|i
init|=
name|forwardBinarySearch
argument_list|(
name|targetWordNum
argument_list|)
decl_stmt|;
specifier|final
name|int
name|position
init|=
operator|(
name|int
operator|)
name|positions
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|position
operator|>
name|in
operator|.
name|getPosition
argument_list|()
condition|)
block|{
comment|// if the binary search returned a backward offset, don't move
name|wordNum
operator|=
operator|(
name|int
operator|)
name|wordNums
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|-
literal|1
expr_stmt|;
name|in
operator|.
name|setPosition
argument_list|(
name|position
argument_list|)
expr_stmt|;
name|sequenceNum
operator|=
name|i
operator|*
name|indexInterval
operator|-
literal|1
expr_stmt|;
block|}
while|while
condition|(
literal|true
condition|)
block|{
if|if
condition|(
operator|!
name|readSequence
argument_list|()
condition|)
block|{
return|return;
block|}
name|delta
operator|=
name|targetWordNum
operator|-
name|wordNum
expr_stmt|;
if|if
condition|(
name|delta
operator|<=
name|dirtyLength
operator|+
literal|1
condition|)
block|{
if|if
condition|(
name|delta
operator|>
literal|1
condition|)
block|{
name|skipDirtyBytes
argument_list|(
name|delta
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
name|skipDirtyBytes
argument_list|()
expr_stmt|;
block|}
block|}
name|nextWord
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|docID
specifier|public
name|int
name|docID
parameter_list|()
block|{
return|return
name|docID
return|;
block|}
annotation|@
name|Override
DECL|method|nextDoc
specifier|public
name|int
name|nextDoc
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|bitList
operator|!=
literal|0
condition|)
block|{
comment|// there are remaining bits in the current word
name|docID
operator|=
operator|(
name|wordNum
operator|<<
literal|3
operator|)
operator||
operator|(
operator|(
name|bitList
operator|&
literal|0x0F
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
name|bitList
operator|>>>=
literal|4
expr_stmt|;
return|return
name|docID
return|;
block|}
name|nextWord
argument_list|()
expr_stmt|;
if|if
condition|(
name|wordNum
operator|==
name|Integer
operator|.
name|MAX_VALUE
condition|)
block|{
return|return
name|docID
operator|=
name|NO_MORE_DOCS
return|;
block|}
name|bitList
operator|=
name|BitUtil
operator|.
name|bitList
argument_list|(
name|word
argument_list|)
expr_stmt|;
assert|assert
name|bitList
operator|!=
literal|0
assert|;
name|docID
operator|=
operator|(
name|wordNum
operator|<<
literal|3
operator|)
operator||
operator|(
operator|(
name|bitList
operator|&
literal|0x0F
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
name|bitList
operator|>>>=
literal|4
expr_stmt|;
return|return
name|docID
return|;
block|}
annotation|@
name|Override
DECL|method|advance
specifier|public
name|int
name|advance
parameter_list|(
name|int
name|target
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|target
operator|>
name|docID
assert|;
specifier|final
name|int
name|targetWordNum
init|=
name|wordNum
argument_list|(
name|target
argument_list|)
decl_stmt|;
if|if
condition|(
name|targetWordNum
operator|>
name|wordNum
condition|)
block|{
name|advanceWord
argument_list|(
name|targetWordNum
argument_list|)
expr_stmt|;
name|bitList
operator|=
name|BitUtil
operator|.
name|bitList
argument_list|(
name|word
argument_list|)
expr_stmt|;
block|}
return|return
name|slowAdvance
argument_list|(
name|target
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|cost
specifier|public
name|long
name|cost
parameter_list|()
block|{
return|return
name|cardinality
return|;
block|}
block|}
comment|/** Return the number of documents in this {@link DocIdSet} in constant time. */
DECL|method|cardinality
specifier|public
name|int
name|cardinality
parameter_list|()
block|{
return|return
name|cardinality
return|;
block|}
comment|/** Return the memory usage of this class in bytes. */
DECL|method|ramBytesUsed
specifier|public
name|long
name|ramBytesUsed
parameter_list|()
block|{
return|return
name|RamUsageEstimator
operator|.
name|alignObjectSize
argument_list|(
literal|3
operator|*
name|RamUsageEstimator
operator|.
name|NUM_BYTES_OBJECT_REF
operator|+
literal|2
operator|*
name|RamUsageEstimator
operator|.
name|NUM_BYTES_INT
argument_list|)
operator|+
name|RamUsageEstimator
operator|.
name|sizeOf
argument_list|(
name|data
argument_list|)
operator|+
name|positions
operator|.
name|ramBytesUsed
argument_list|()
operator|+
name|wordNums
operator|.
name|ramBytesUsed
argument_list|()
return|;
block|}
block|}
end_class
end_unit
