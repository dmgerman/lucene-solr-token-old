begin_unit
begin_comment
comment|/*  * dk.brics.automaton  *   * Copyright (c) 2001-2009 Anders Moeller  * All rights reserved.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *   * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment
begin_package
DECL|package|org.apache.lucene.util.automaton
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|automaton
package|;
end_package
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|*
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|BytesRef
import|;
end_import
begin_comment
comment|/**  * Construction of basic automata.  *   * @lucene.experimental  */
end_comment
begin_class
DECL|class|Automata
specifier|final
specifier|public
class|class
name|Automata
block|{
DECL|method|Automata
specifier|private
name|Automata
parameter_list|()
block|{}
comment|/**    * Returns a new (deterministic) automaton with the empty language.    */
DECL|method|makeEmpty
specifier|public
specifier|static
name|Automaton
name|makeEmpty
parameter_list|()
block|{
name|Automaton
name|a
init|=
operator|new
name|Automaton
argument_list|()
decl_stmt|;
name|a
operator|.
name|finishState
argument_list|()
expr_stmt|;
return|return
name|a
return|;
block|}
comment|/**    * Returns a new (deterministic) automaton that accepts only the empty string.    */
DECL|method|makeEmptyString
specifier|public
specifier|static
name|Automaton
name|makeEmptyString
parameter_list|()
block|{
name|Automaton
name|a
init|=
operator|new
name|Automaton
argument_list|()
decl_stmt|;
name|a
operator|.
name|createState
argument_list|()
expr_stmt|;
name|a
operator|.
name|setAccept
argument_list|(
literal|0
argument_list|,
literal|true
argument_list|)
expr_stmt|;
return|return
name|a
return|;
block|}
comment|/**    * Returns a new (deterministic) automaton that accepts all strings.    */
DECL|method|makeAnyString
specifier|public
specifier|static
name|Automaton
name|makeAnyString
parameter_list|()
block|{
name|Automaton
name|a
init|=
operator|new
name|Automaton
argument_list|()
decl_stmt|;
name|int
name|s
init|=
name|a
operator|.
name|createState
argument_list|()
decl_stmt|;
name|a
operator|.
name|setAccept
argument_list|(
name|s
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|a
operator|.
name|addTransition
argument_list|(
name|s
argument_list|,
name|s
argument_list|,
name|Character
operator|.
name|MIN_CODE_POINT
argument_list|,
name|Character
operator|.
name|MAX_CODE_POINT
argument_list|)
expr_stmt|;
name|a
operator|.
name|finishState
argument_list|()
expr_stmt|;
return|return
name|a
return|;
block|}
comment|/**    * Returns a new (deterministic) automaton that accepts any single codepoint.    */
DECL|method|makeAnyChar
specifier|public
specifier|static
name|Automaton
name|makeAnyChar
parameter_list|()
block|{
return|return
name|makeCharRange
argument_list|(
name|Character
operator|.
name|MIN_CODE_POINT
argument_list|,
name|Character
operator|.
name|MAX_CODE_POINT
argument_list|)
return|;
block|}
comment|/** Accept any single character starting from the specified state, returning the new state */
DECL|method|appendAnyChar
specifier|public
specifier|static
name|int
name|appendAnyChar
parameter_list|(
name|Automaton
name|a
parameter_list|,
name|int
name|state
parameter_list|)
block|{
name|int
name|newState
init|=
name|a
operator|.
name|createState
argument_list|()
decl_stmt|;
name|a
operator|.
name|addTransition
argument_list|(
name|state
argument_list|,
name|newState
argument_list|,
name|Character
operator|.
name|MIN_CODE_POINT
argument_list|,
name|Character
operator|.
name|MAX_CODE_POINT
argument_list|)
expr_stmt|;
return|return
name|newState
return|;
block|}
comment|/**    * Returns a new (deterministic) automaton that accepts a single codepoint of    * the given value.    */
DECL|method|makeChar
specifier|public
specifier|static
name|Automaton
name|makeChar
parameter_list|(
name|int
name|c
parameter_list|)
block|{
return|return
name|makeCharRange
argument_list|(
name|c
argument_list|,
name|c
argument_list|)
return|;
block|}
comment|/** Appends the specified character to the specified state, returning a new state. */
DECL|method|appendChar
specifier|public
specifier|static
name|int
name|appendChar
parameter_list|(
name|Automaton
name|a
parameter_list|,
name|int
name|state
parameter_list|,
name|int
name|c
parameter_list|)
block|{
name|int
name|newState
init|=
name|a
operator|.
name|createState
argument_list|()
decl_stmt|;
name|a
operator|.
name|addTransition
argument_list|(
name|state
argument_list|,
name|newState
argument_list|,
name|c
argument_list|,
name|c
argument_list|)
expr_stmt|;
return|return
name|newState
return|;
block|}
comment|/**    * Returns a new (deterministic) automaton that accepts a single codepoint whose    * value is in the given interval (including both end points).    */
DECL|method|makeCharRange
specifier|public
specifier|static
name|Automaton
name|makeCharRange
parameter_list|(
name|int
name|min
parameter_list|,
name|int
name|max
parameter_list|)
block|{
if|if
condition|(
name|min
operator|>
name|max
condition|)
block|{
return|return
name|makeEmpty
argument_list|()
return|;
block|}
name|Automaton
name|a
init|=
operator|new
name|Automaton
argument_list|()
decl_stmt|;
name|int
name|s1
init|=
name|a
operator|.
name|createState
argument_list|()
decl_stmt|;
name|int
name|s2
init|=
name|a
operator|.
name|createState
argument_list|()
decl_stmt|;
name|a
operator|.
name|setAccept
argument_list|(
name|s2
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|a
operator|.
name|addTransition
argument_list|(
name|s1
argument_list|,
name|s2
argument_list|,
name|min
argument_list|,
name|max
argument_list|)
expr_stmt|;
name|a
operator|.
name|finishState
argument_list|()
expr_stmt|;
return|return
name|a
return|;
block|}
comment|/**    * Constructs sub-automaton corresponding to decimal numbers of length    * x.substring(n).length().    */
DECL|method|anyOfRightLength
specifier|private
specifier|static
name|int
name|anyOfRightLength
parameter_list|(
name|Automaton
operator|.
name|Builder
name|builder
parameter_list|,
name|String
name|x
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|int
name|s
init|=
name|builder
operator|.
name|createState
argument_list|()
decl_stmt|;
if|if
condition|(
name|x
operator|.
name|length
argument_list|()
operator|==
name|n
condition|)
block|{
name|builder
operator|.
name|setAccept
argument_list|(
name|s
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|builder
operator|.
name|addTransition
argument_list|(
name|s
argument_list|,
name|anyOfRightLength
argument_list|(
name|builder
argument_list|,
name|x
argument_list|,
name|n
operator|+
literal|1
argument_list|)
argument_list|,
literal|'0'
argument_list|,
literal|'9'
argument_list|)
expr_stmt|;
block|}
return|return
name|s
return|;
block|}
comment|/**    * Constructs sub-automaton corresponding to decimal numbers of value at least    * x.substring(n) and length x.substring(n).length().    */
DECL|method|atLeast
specifier|private
specifier|static
name|int
name|atLeast
parameter_list|(
name|Automaton
operator|.
name|Builder
name|builder
parameter_list|,
name|String
name|x
parameter_list|,
name|int
name|n
parameter_list|,
name|Collection
argument_list|<
name|Integer
argument_list|>
name|initials
parameter_list|,
name|boolean
name|zeros
parameter_list|)
block|{
name|int
name|s
init|=
name|builder
operator|.
name|createState
argument_list|()
decl_stmt|;
if|if
condition|(
name|x
operator|.
name|length
argument_list|()
operator|==
name|n
condition|)
block|{
name|builder
operator|.
name|setAccept
argument_list|(
name|s
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|zeros
condition|)
block|{
name|initials
operator|.
name|add
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
name|char
name|c
init|=
name|x
operator|.
name|charAt
argument_list|(
name|n
argument_list|)
decl_stmt|;
name|builder
operator|.
name|addTransition
argument_list|(
name|s
argument_list|,
name|atLeast
argument_list|(
name|builder
argument_list|,
name|x
argument_list|,
name|n
operator|+
literal|1
argument_list|,
name|initials
argument_list|,
name|zeros
operator|&&
name|c
operator|==
literal|'0'
argument_list|)
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|<
literal|'9'
condition|)
block|{
name|builder
operator|.
name|addTransition
argument_list|(
name|s
argument_list|,
name|anyOfRightLength
argument_list|(
name|builder
argument_list|,
name|x
argument_list|,
name|n
operator|+
literal|1
argument_list|)
argument_list|,
call|(
name|char
call|)
argument_list|(
name|c
operator|+
literal|1
argument_list|)
argument_list|,
literal|'9'
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|s
return|;
block|}
comment|/**    * Constructs sub-automaton corresponding to decimal numbers of value at most    * x.substring(n) and length x.substring(n).length().    */
DECL|method|atMost
specifier|private
specifier|static
name|int
name|atMost
parameter_list|(
name|Automaton
operator|.
name|Builder
name|builder
parameter_list|,
name|String
name|x
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|int
name|s
init|=
name|builder
operator|.
name|createState
argument_list|()
decl_stmt|;
if|if
condition|(
name|x
operator|.
name|length
argument_list|()
operator|==
name|n
condition|)
block|{
name|builder
operator|.
name|setAccept
argument_list|(
name|s
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
name|c
init|=
name|x
operator|.
name|charAt
argument_list|(
name|n
argument_list|)
decl_stmt|;
name|builder
operator|.
name|addTransition
argument_list|(
name|s
argument_list|,
name|atMost
argument_list|(
name|builder
argument_list|,
name|x
argument_list|,
operator|(
name|char
operator|)
name|n
operator|+
literal|1
argument_list|)
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|>
literal|'0'
condition|)
block|{
name|builder
operator|.
name|addTransition
argument_list|(
name|s
argument_list|,
name|anyOfRightLength
argument_list|(
name|builder
argument_list|,
name|x
argument_list|,
name|n
operator|+
literal|1
argument_list|)
argument_list|,
literal|'0'
argument_list|,
call|(
name|char
call|)
argument_list|(
name|c
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|s
return|;
block|}
comment|/**    * Constructs sub-automaton corresponding to decimal numbers of value between    * x.substring(n) and y.substring(n) and of length x.substring(n).length()    * (which must be equal to y.substring(n).length()).    */
DECL|method|between
specifier|private
specifier|static
name|int
name|between
parameter_list|(
name|Automaton
operator|.
name|Builder
name|builder
parameter_list|,
name|String
name|x
parameter_list|,
name|String
name|y
parameter_list|,
name|int
name|n
parameter_list|,
name|Collection
argument_list|<
name|Integer
argument_list|>
name|initials
parameter_list|,
name|boolean
name|zeros
parameter_list|)
block|{
name|int
name|s
init|=
name|builder
operator|.
name|createState
argument_list|()
decl_stmt|;
if|if
condition|(
name|x
operator|.
name|length
argument_list|()
operator|==
name|n
condition|)
block|{
name|builder
operator|.
name|setAccept
argument_list|(
name|s
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|zeros
condition|)
block|{
name|initials
operator|.
name|add
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
name|char
name|cx
init|=
name|x
operator|.
name|charAt
argument_list|(
name|n
argument_list|)
decl_stmt|;
name|char
name|cy
init|=
name|y
operator|.
name|charAt
argument_list|(
name|n
argument_list|)
decl_stmt|;
if|if
condition|(
name|cx
operator|==
name|cy
condition|)
block|{
name|builder
operator|.
name|addTransition
argument_list|(
name|s
argument_list|,
name|between
argument_list|(
name|builder
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|n
operator|+
literal|1
argument_list|,
name|initials
argument_list|,
name|zeros
operator|&&
name|cx
operator|==
literal|'0'
argument_list|)
argument_list|,
name|cx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// cx<cy
name|builder
operator|.
name|addTransition
argument_list|(
name|s
argument_list|,
name|atLeast
argument_list|(
name|builder
argument_list|,
name|x
argument_list|,
name|n
operator|+
literal|1
argument_list|,
name|initials
argument_list|,
name|zeros
operator|&&
name|cx
operator|==
literal|'0'
argument_list|)
argument_list|,
name|cx
argument_list|)
expr_stmt|;
name|builder
operator|.
name|addTransition
argument_list|(
name|s
argument_list|,
name|atMost
argument_list|(
name|builder
argument_list|,
name|y
argument_list|,
name|n
operator|+
literal|1
argument_list|)
argument_list|,
name|cy
argument_list|)
expr_stmt|;
if|if
condition|(
name|cx
operator|+
literal|1
operator|<
name|cy
condition|)
block|{
name|builder
operator|.
name|addTransition
argument_list|(
name|s
argument_list|,
name|anyOfRightLength
argument_list|(
name|builder
argument_list|,
name|x
argument_list|,
name|n
operator|+
literal|1
argument_list|)
argument_list|,
call|(
name|char
call|)
argument_list|(
name|cx
operator|+
literal|1
argument_list|)
argument_list|,
call|(
name|char
call|)
argument_list|(
name|cy
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|s
return|;
block|}
comment|/**    * Returns a new automaton that accepts strings representing decimal    * non-negative integers in the given interval.    *     * @param min minimal value of interval    * @param max maximal value of interval (both end points are included in the    *          interval)    * @param digits if>0, use fixed number of digits (strings must be prefixed    *          by 0's to obtain the right length) - otherwise, the number of    *          digits is not fixed (any number of leading 0s is accepted)    * @exception IllegalArgumentException if min>max or if numbers in the    *              interval cannot be expressed with the given fixed number of    *              digits    */
DECL|method|makeInterval
specifier|public
specifier|static
name|Automaton
name|makeInterval
parameter_list|(
name|int
name|min
parameter_list|,
name|int
name|max
parameter_list|,
name|int
name|digits
parameter_list|)
throws|throws
name|IllegalArgumentException
block|{
name|String
name|x
init|=
name|Integer
operator|.
name|toString
argument_list|(
name|min
argument_list|)
decl_stmt|;
name|String
name|y
init|=
name|Integer
operator|.
name|toString
argument_list|(
name|max
argument_list|)
decl_stmt|;
if|if
condition|(
name|min
operator|>
name|max
operator|||
operator|(
name|digits
operator|>
literal|0
operator|&&
name|y
operator|.
name|length
argument_list|()
operator|>
name|digits
operator|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|()
throw|;
block|}
name|int
name|d
decl_stmt|;
if|if
condition|(
name|digits
operator|>
literal|0
condition|)
name|d
operator|=
name|digits
expr_stmt|;
else|else
name|d
operator|=
name|y
operator|.
name|length
argument_list|()
expr_stmt|;
name|StringBuilder
name|bx
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|x
operator|.
name|length
argument_list|()
init|;
name|i
operator|<
name|d
condition|;
name|i
operator|++
control|)
block|{
name|bx
operator|.
name|append
argument_list|(
literal|'0'
argument_list|)
expr_stmt|;
block|}
name|bx
operator|.
name|append
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|x
operator|=
name|bx
operator|.
name|toString
argument_list|()
expr_stmt|;
name|StringBuilder
name|by
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|y
operator|.
name|length
argument_list|()
init|;
name|i
operator|<
name|d
condition|;
name|i
operator|++
control|)
block|{
name|by
operator|.
name|append
argument_list|(
literal|'0'
argument_list|)
expr_stmt|;
block|}
name|by
operator|.
name|append
argument_list|(
name|y
argument_list|)
expr_stmt|;
name|y
operator|=
name|by
operator|.
name|toString
argument_list|()
expr_stmt|;
name|Automaton
operator|.
name|Builder
name|builder
init|=
operator|new
name|Automaton
operator|.
name|Builder
argument_list|()
decl_stmt|;
if|if
condition|(
name|digits
operator|<=
literal|0
condition|)
block|{
comment|// Reserve the "real" initial state:
name|builder
operator|.
name|createState
argument_list|()
expr_stmt|;
block|}
name|Collection
argument_list|<
name|Integer
argument_list|>
name|initials
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|between
argument_list|(
name|builder
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
literal|0
argument_list|,
name|initials
argument_list|,
name|digits
operator|<=
literal|0
argument_list|)
expr_stmt|;
name|Automaton
name|a1
init|=
name|builder
operator|.
name|finish
argument_list|()
decl_stmt|;
if|if
condition|(
name|digits
operator|<=
literal|0
condition|)
block|{
name|a1
operator|.
name|addTransition
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|'0'
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|p
range|:
name|initials
control|)
block|{
name|a1
operator|.
name|addEpsilon
argument_list|(
literal|0
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
name|a1
operator|.
name|finishState
argument_list|()
expr_stmt|;
block|}
return|return
name|a1
return|;
block|}
comment|/**    * Returns a new (deterministic) automaton that accepts the single given    * string.    */
DECL|method|makeString
specifier|public
specifier|static
name|Automaton
name|makeString
parameter_list|(
name|String
name|s
parameter_list|)
block|{
name|Automaton
name|a
init|=
operator|new
name|Automaton
argument_list|()
decl_stmt|;
name|int
name|lastState
init|=
name|a
operator|.
name|createState
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|,
name|cp
init|=
literal|0
init|;
name|i
operator|<
name|s
operator|.
name|length
argument_list|()
condition|;
name|i
operator|+=
name|Character
operator|.
name|charCount
argument_list|(
name|cp
argument_list|)
control|)
block|{
name|int
name|state
init|=
name|a
operator|.
name|createState
argument_list|()
decl_stmt|;
name|cp
operator|=
name|s
operator|.
name|codePointAt
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|a
operator|.
name|addTransition
argument_list|(
name|lastState
argument_list|,
name|state
argument_list|,
name|cp
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|lastState
operator|=
name|state
expr_stmt|;
block|}
name|a
operator|.
name|setAccept
argument_list|(
name|lastState
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|a
operator|.
name|finishState
argument_list|()
expr_stmt|;
assert|assert
name|a
operator|.
name|isDeterministic
argument_list|()
assert|;
assert|assert
name|Operations
operator|.
name|hasDeadStates
argument_list|(
name|a
argument_list|)
operator|==
literal|false
assert|;
return|return
name|a
return|;
block|}
comment|/**    * Returns a new (deterministic) automaton that accepts the single given    * string from the specified unicode code points.    */
DECL|method|makeString
specifier|public
specifier|static
name|Automaton
name|makeString
parameter_list|(
name|int
index|[]
name|word
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|)
block|{
name|Automaton
name|a
init|=
operator|new
name|Automaton
argument_list|()
decl_stmt|;
name|a
operator|.
name|createState
argument_list|()
expr_stmt|;
name|int
name|s
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|offset
init|;
name|i
operator|<
name|offset
operator|+
name|length
condition|;
name|i
operator|++
control|)
block|{
name|int
name|s2
init|=
name|a
operator|.
name|createState
argument_list|()
decl_stmt|;
name|a
operator|.
name|addTransition
argument_list|(
name|s
argument_list|,
name|s2
argument_list|,
name|word
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|s
operator|=
name|s2
expr_stmt|;
block|}
name|a
operator|.
name|setAccept
argument_list|(
name|s
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|a
operator|.
name|finishState
argument_list|()
expr_stmt|;
return|return
name|a
return|;
block|}
comment|/**    * Returns a new (deterministic and minimal) automaton that accepts the union    * of the given collection of {@link BytesRef}s representing UTF-8 encoded    * strings.    *     * @param utf8Strings    *          The input strings, UTF-8 encoded. The collection must be in sorted    *          order.    *     * @return An {@link Automaton} accepting all input strings. The resulting    *         automaton is codepoint based (full unicode codepoints on    *         transitions).    */
DECL|method|makeStringUnion
specifier|public
specifier|static
name|Automaton
name|makeStringUnion
parameter_list|(
name|Collection
argument_list|<
name|BytesRef
argument_list|>
name|utf8Strings
parameter_list|)
block|{
if|if
condition|(
name|utf8Strings
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
name|makeEmpty
argument_list|()
return|;
block|}
else|else
block|{
return|return
name|DaciukMihovAutomatonBuilder
operator|.
name|build
argument_list|(
name|utf8Strings
argument_list|)
return|;
block|}
block|}
block|}
end_class
end_unit
