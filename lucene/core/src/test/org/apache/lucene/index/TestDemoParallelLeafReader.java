begin_unit
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_package
DECL|package|org.apache.lucene.index
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
package|;
end_package
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Closeable
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|DirectoryStream
import|;
end_import
begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|Files
import|;
end_import
begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|Path
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentHashMap
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicLong
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Pattern
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|document
operator|.
name|LongPoint
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|document
operator|.
name|Document
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|document
operator|.
name|Field
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|document
operator|.
name|NumericDocValuesField
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|PointRangeQuery
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|IndexSearcher
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|MatchAllDocsQuery
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|ScoreDoc
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|Sort
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|SortField
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|TopDocs
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|Directory
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|FSDirectory
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|IOContext
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|MockDirectoryWrapper
operator|.
name|Throttling
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|MockDirectoryWrapper
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|Bits
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|IOUtils
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|LuceneTestCase
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|StringHelper
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|TestUtil
import|;
end_import
begin_comment
comment|// TODO:
end_comment
begin_comment
comment|//   - old parallel indices are only pruned on commit/close; can we do it on refresh?
end_comment
begin_comment
comment|/** Simple example showing how to use ParallelLeafReader to index new  *  stuff (postings, DVs, etc.) from previously stored fields, on the  *  fly (during NRT reader reopen), after the  initial indexing.  The  *  test indexes just a single stored field with text "content X" (X is  *  a number embedded in the text).  *  *  Then, on reopen, for any newly created segments (flush or merge), it  *  builds a new parallel segment by loading all stored docs, parsing  *  out that X, and adding it as DV and numeric indexed (trie) field.  *  *  Finally, for searching, it builds a top-level MultiReader, with  *  ParallelLeafReader for each segment, and then tests that random  *  numeric range queries, and sorting by the new DV field, work  *  correctly.  *  *  Each per-segment index lives in a private directory next to the main  *  index, and they are deleted once their segments are removed from the  *  index.  They are "volatile", meaning if e.g. the index is replicated to  *  another machine, it's OK to not copy parallel segments indices,  *  since they will just be regnerated (at a cost though). */
end_comment
begin_comment
comment|// @SuppressSysoutChecks(bugUrl="we print stuff")
end_comment
begin_class
DECL|class|TestDemoParallelLeafReader
specifier|public
class|class
name|TestDemoParallelLeafReader
extends|extends
name|LuceneTestCase
block|{
DECL|field|DEBUG
specifier|static
specifier|final
name|boolean
name|DEBUG
init|=
literal|false
decl_stmt|;
DECL|class|ReindexingReader
specifier|static
specifier|abstract
class|class
name|ReindexingReader
implements|implements
name|Closeable
block|{
comment|/** Key used to store the current schema gen in the SegmentInfo diagnostics */
DECL|field|SCHEMA_GEN_KEY
specifier|public
specifier|final
specifier|static
name|String
name|SCHEMA_GEN_KEY
init|=
literal|"schema_gen"
decl_stmt|;
DECL|field|w
specifier|public
specifier|final
name|IndexWriter
name|w
decl_stmt|;
DECL|field|mgr
specifier|public
specifier|final
name|ReaderManager
name|mgr
decl_stmt|;
DECL|field|indexDir
specifier|private
specifier|final
name|Directory
name|indexDir
decl_stmt|;
DECL|field|root
specifier|private
specifier|final
name|Path
name|root
decl_stmt|;
DECL|field|segsPath
specifier|private
specifier|final
name|Path
name|segsPath
decl_stmt|;
comment|/** Which segments have been closed, but their parallel index is not yet not removed. */
DECL|field|closedSegments
specifier|private
specifier|final
name|Set
argument_list|<
name|SegmentIDAndGen
argument_list|>
name|closedSegments
init|=
name|Collections
operator|.
name|newSetFromMap
argument_list|(
operator|new
name|ConcurrentHashMap
argument_list|<
name|SegmentIDAndGen
argument_list|,
name|Boolean
argument_list|>
argument_list|()
argument_list|)
decl_stmt|;
comment|/** Holds currently open parallel readers for each segment. */
DECL|field|parallelReaders
specifier|private
specifier|final
name|Map
argument_list|<
name|SegmentIDAndGen
argument_list|,
name|LeafReader
argument_list|>
name|parallelReaders
init|=
operator|new
name|ConcurrentHashMap
argument_list|<>
argument_list|()
decl_stmt|;
DECL|method|printRefCounts
name|void
name|printRefCounts
parameter_list|()
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"All refCounts:"
argument_list|)
expr_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|SegmentIDAndGen
argument_list|,
name|LeafReader
argument_list|>
name|ent
range|:
name|parallelReaders
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"  "
operator|+
name|ent
operator|.
name|getKey
argument_list|()
operator|+
literal|" "
operator|+
name|ent
operator|.
name|getValue
argument_list|()
operator|+
literal|" refCount="
operator|+
name|ent
operator|.
name|getValue
argument_list|()
operator|.
name|getRefCount
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|ReindexingReader
specifier|public
name|ReindexingReader
parameter_list|(
name|Path
name|root
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|root
operator|=
name|root
expr_stmt|;
comment|// Normal index is stored under "index":
name|indexDir
operator|=
name|openDirectory
argument_list|(
name|root
operator|.
name|resolve
argument_list|(
literal|"index"
argument_list|)
argument_list|)
expr_stmt|;
comment|// Per-segment parallel indices are stored under subdirs "segs":
name|segsPath
operator|=
name|root
operator|.
name|resolve
argument_list|(
literal|"segs"
argument_list|)
expr_stmt|;
name|Files
operator|.
name|createDirectories
argument_list|(
name|segsPath
argument_list|)
expr_stmt|;
name|IndexWriterConfig
name|iwc
init|=
name|getIndexWriterConfig
argument_list|()
decl_stmt|;
name|iwc
operator|.
name|setMergePolicy
argument_list|(
operator|new
name|ReindexingMergePolicy
argument_list|(
name|iwc
operator|.
name|getMergePolicy
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|DEBUG
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"TEST: use IWC:\n"
operator|+
name|iwc
argument_list|)
expr_stmt|;
block|}
name|w
operator|=
operator|new
name|IndexWriter
argument_list|(
name|indexDir
argument_list|,
name|iwc
argument_list|)
expr_stmt|;
name|w
operator|.
name|getConfig
argument_list|()
operator|.
name|setMergedSegmentWarmer
argument_list|(
operator|new
name|IndexWriter
operator|.
name|IndexReaderWarmer
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|warm
parameter_list|(
name|LeafReader
name|reader
parameter_list|)
throws|throws
name|IOException
block|{
comment|// This will build the parallel index for the merged segment before the merge becomes visible, so reopen delay is only due to
comment|// newly flushed segments:
if|if
condition|(
name|DEBUG
condition|)
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|": TEST: now warm "
operator|+
name|reader
argument_list|)
expr_stmt|;
comment|// TODO: it's not great that we pass false here; it means we close the reader& reopen again for NRT reader; still we did "warm" by
comment|// building the parallel index, if necessary
name|getParallelLeafReader
argument_list|(
name|reader
argument_list|,
literal|false
argument_list|,
name|getCurrentSchemaGen
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
comment|// start with empty commit:
name|w
operator|.
name|commit
argument_list|()
expr_stmt|;
name|mgr
operator|=
operator|new
name|ReaderManager
argument_list|(
operator|new
name|ParallelLeafDirectoryReader
argument_list|(
name|DirectoryReader
operator|.
name|open
argument_list|(
name|w
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|getIndexWriterConfig
specifier|protected
specifier|abstract
name|IndexWriterConfig
name|getIndexWriterConfig
parameter_list|()
throws|throws
name|IOException
function_decl|;
comment|/** Optional method to validate that the provided parallell reader in fact reflects the changes in schemaGen. */
DECL|method|checkParallelReader
specifier|protected
name|void
name|checkParallelReader
parameter_list|(
name|LeafReader
name|reader
parameter_list|,
name|LeafReader
name|parallelReader
parameter_list|,
name|long
name|schemaGen
parameter_list|)
throws|throws
name|IOException
block|{     }
comment|/** Override to customize Directory impl. */
DECL|method|openDirectory
specifier|protected
name|Directory
name|openDirectory
parameter_list|(
name|Path
name|path
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|FSDirectory
operator|.
name|open
argument_list|(
name|path
argument_list|)
return|;
block|}
DECL|method|commit
specifier|public
name|void
name|commit
parameter_list|()
throws|throws
name|IOException
block|{
name|w
operator|.
name|commit
argument_list|()
expr_stmt|;
block|}
DECL|method|getCurrentReader
name|LeafReader
name|getCurrentReader
parameter_list|(
name|LeafReader
name|reader
parameter_list|,
name|long
name|schemaGen
parameter_list|)
throws|throws
name|IOException
block|{
name|LeafReader
name|parallelReader
init|=
name|getParallelLeafReader
argument_list|(
name|reader
argument_list|,
literal|true
argument_list|,
name|schemaGen
argument_list|)
decl_stmt|;
if|if
condition|(
name|parallelReader
operator|!=
literal|null
condition|)
block|{
comment|// We should not be embedding one ParallelLeafReader inside another:
name|assertFalse
argument_list|(
name|parallelReader
operator|instanceof
name|ParallelLeafReader
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|reader
operator|instanceof
name|ParallelLeafReader
argument_list|)
expr_stmt|;
comment|// NOTE: important that parallelReader is first, so if there are field name overlaps, because changes to the schema
comment|// overwrote existing field names, it wins:
name|LeafReader
name|newReader
init|=
operator|new
name|ParallelLeafReader
argument_list|(
literal|false
argument_list|,
name|parallelReader
argument_list|,
name|reader
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|Bits
name|getLiveDocs
parameter_list|()
block|{
return|return
name|getParallelReaders
argument_list|()
index|[
literal|1
index|]
operator|.
name|getLiveDocs
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|numDocs
parameter_list|()
block|{
return|return
name|getParallelReaders
argument_list|()
index|[
literal|1
index|]
operator|.
name|numDocs
argument_list|()
return|;
block|}
block|}
decl_stmt|;
comment|// Because ParallelLeafReader does its own (extra) incRef:
name|parallelReader
operator|.
name|decRef
argument_list|()
expr_stmt|;
return|return
name|newReader
return|;
block|}
else|else
block|{
comment|// This segment was already current as of currentSchemaGen:
return|return
name|reader
return|;
block|}
block|}
DECL|class|ParallelLeafDirectoryReader
specifier|private
class|class
name|ParallelLeafDirectoryReader
extends|extends
name|FilterDirectoryReader
block|{
DECL|method|ParallelLeafDirectoryReader
specifier|public
name|ParallelLeafDirectoryReader
parameter_list|(
name|DirectoryReader
name|in
parameter_list|)
throws|throws
name|IOException
block|{
name|super
argument_list|(
name|in
argument_list|,
operator|new
name|FilterDirectoryReader
operator|.
name|SubReaderWrapper
argument_list|()
block|{
specifier|final
name|long
name|currentSchemaGen
init|=
name|getCurrentSchemaGen
argument_list|()
decl_stmt|;
annotation|@
name|Override
specifier|public
name|LeafReader
name|wrap
parameter_list|(
name|LeafReader
name|reader
parameter_list|)
block|{
try|try
block|{
return|return
name|getCurrentReader
argument_list|(
name|reader
argument_list|,
name|currentSchemaGen
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
comment|// TODO: must close on exc here:
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|ioe
argument_list|)
throw|;
block|}
block|}
block|}
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|doWrapDirectoryReader
specifier|protected
name|DirectoryReader
name|doWrapDirectoryReader
parameter_list|(
name|DirectoryReader
name|in
parameter_list|)
throws|throws
name|IOException
block|{
return|return
operator|new
name|ParallelLeafDirectoryReader
argument_list|(
name|in
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|doClose
specifier|protected
name|void
name|doClose
parameter_list|()
throws|throws
name|IOException
block|{
name|Throwable
name|firstExc
init|=
literal|null
decl_stmt|;
for|for
control|(
specifier|final
name|LeafReader
name|r
range|:
name|getSequentialSubReaders
argument_list|()
control|)
block|{
if|if
condition|(
name|r
operator|instanceof
name|ParallelLeafReader
condition|)
block|{
comment|// try to close each reader, even if an exception is thrown
try|try
block|{
name|r
operator|.
name|decRef
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
if|if
condition|(
name|firstExc
operator|==
literal|null
condition|)
block|{
name|firstExc
operator|=
name|t
expr_stmt|;
block|}
block|}
block|}
block|}
comment|// Also close in, so it decRef's the SegmentInfos
try|try
block|{
name|in
operator|.
name|doClose
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
if|if
condition|(
name|firstExc
operator|==
literal|null
condition|)
block|{
name|firstExc
operator|=
name|t
expr_stmt|;
block|}
block|}
comment|// throw the first exception
name|IOUtils
operator|.
name|reThrow
argument_list|(
name|firstExc
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|close
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
name|w
operator|.
name|close
argument_list|()
expr_stmt|;
if|if
condition|(
name|DEBUG
condition|)
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"TEST: after close writer index="
operator|+
name|SegmentInfos
operator|.
name|readLatestCommit
argument_list|(
name|indexDir
argument_list|)
argument_list|)
expr_stmt|;
comment|/*       DirectoryReader r = mgr.acquire();       try {         TestUtil.checkReader(r);       } finally {         mgr.release(r);       }       */
name|mgr
operator|.
name|close
argument_list|()
expr_stmt|;
name|pruneOldSegments
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|assertNoExtraSegments
argument_list|()
expr_stmt|;
name|indexDir
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
comment|// Make sure we deleted all parallel indices for segments that are no longer in the main index:
DECL|method|assertNoExtraSegments
specifier|private
name|void
name|assertNoExtraSegments
parameter_list|()
throws|throws
name|IOException
block|{
name|Set
argument_list|<
name|String
argument_list|>
name|liveIDs
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|SegmentCommitInfo
name|info
range|:
name|SegmentInfos
operator|.
name|readLatestCommit
argument_list|(
name|indexDir
argument_list|)
control|)
block|{
name|String
name|idString
init|=
name|StringHelper
operator|.
name|idToString
argument_list|(
name|info
operator|.
name|info
operator|.
name|getId
argument_list|()
argument_list|)
decl_stmt|;
name|liveIDs
operator|.
name|add
argument_list|(
name|idString
argument_list|)
expr_stmt|;
block|}
comment|// At this point (closing) the only segments in closedSegments should be the still-live ones:
for|for
control|(
name|SegmentIDAndGen
name|segIDGen
range|:
name|closedSegments
control|)
block|{
name|assertTrue
argument_list|(
name|liveIDs
operator|.
name|contains
argument_list|(
name|segIDGen
operator|.
name|segID
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|boolean
name|fail
init|=
literal|false
decl_stmt|;
for|for
control|(
name|Path
name|path
range|:
name|segSubDirs
argument_list|(
name|segsPath
argument_list|)
control|)
block|{
name|SegmentIDAndGen
name|segIDGen
init|=
operator|new
name|SegmentIDAndGen
argument_list|(
name|path
operator|.
name|getFileName
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|liveIDs
operator|.
name|contains
argument_list|(
name|segIDGen
operator|.
name|segID
argument_list|)
operator|==
literal|false
condition|)
block|{
if|if
condition|(
name|DEBUG
condition|)
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"TEST: fail seg="
operator|+
name|path
operator|.
name|getFileName
argument_list|()
operator|+
literal|" is not live but still has a parallel index"
argument_list|)
expr_stmt|;
name|fail
operator|=
literal|true
expr_stmt|;
block|}
block|}
name|assertFalse
argument_list|(
name|fail
argument_list|)
expr_stmt|;
block|}
DECL|class|SegmentIDAndGen
specifier|private
specifier|static
class|class
name|SegmentIDAndGen
block|{
DECL|field|segID
specifier|public
specifier|final
name|String
name|segID
decl_stmt|;
DECL|field|schemaGen
specifier|public
specifier|final
name|long
name|schemaGen
decl_stmt|;
DECL|method|SegmentIDAndGen
specifier|public
name|SegmentIDAndGen
parameter_list|(
name|String
name|segID
parameter_list|,
name|long
name|schemaGen
parameter_list|)
block|{
name|this
operator|.
name|segID
operator|=
name|segID
expr_stmt|;
name|this
operator|.
name|schemaGen
operator|=
name|schemaGen
expr_stmt|;
block|}
DECL|method|SegmentIDAndGen
specifier|public
name|SegmentIDAndGen
parameter_list|(
name|String
name|s
parameter_list|)
block|{
name|String
index|[]
name|parts
init|=
name|s
operator|.
name|split
argument_list|(
literal|"_"
argument_list|)
decl_stmt|;
if|if
condition|(
name|parts
operator|.
name|length
operator|!=
literal|2
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"invalid SegmentIDAndGen \""
operator|+
name|s
operator|+
literal|"\""
argument_list|)
throw|;
block|}
comment|// TODO: better checking of segID?
name|segID
operator|=
name|parts
index|[
literal|0
index|]
expr_stmt|;
name|schemaGen
operator|=
name|Long
operator|.
name|parseLong
argument_list|(
name|parts
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|hashCode
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
call|(
name|int
call|)
argument_list|(
name|segID
operator|.
name|hashCode
argument_list|()
operator|*
name|schemaGen
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|equals
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|_other
parameter_list|)
block|{
if|if
condition|(
name|_other
operator|instanceof
name|SegmentIDAndGen
condition|)
block|{
name|SegmentIDAndGen
name|other
init|=
operator|(
name|SegmentIDAndGen
operator|)
name|_other
decl_stmt|;
return|return
name|segID
operator|.
name|equals
argument_list|(
name|other
operator|.
name|segID
argument_list|)
operator|&&
name|schemaGen
operator|==
name|other
operator|.
name|schemaGen
return|;
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|segID
operator|+
literal|"_"
operator|+
name|schemaGen
return|;
block|}
block|}
DECL|class|ParallelReaderClosed
specifier|private
class|class
name|ParallelReaderClosed
implements|implements
name|LeafReader
operator|.
name|ReaderClosedListener
block|{
DECL|field|segIDGen
specifier|private
specifier|final
name|SegmentIDAndGen
name|segIDGen
decl_stmt|;
DECL|field|dir
specifier|private
specifier|final
name|Directory
name|dir
decl_stmt|;
DECL|method|ParallelReaderClosed
specifier|public
name|ParallelReaderClosed
parameter_list|(
name|SegmentIDAndGen
name|segIDGen
parameter_list|,
name|Directory
name|dir
parameter_list|)
block|{
name|this
operator|.
name|segIDGen
operator|=
name|segIDGen
expr_stmt|;
name|this
operator|.
name|dir
operator|=
name|dir
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|onClose
specifier|public
name|void
name|onClose
parameter_list|(
name|IndexReader
name|ignored
parameter_list|)
block|{
try|try
block|{
comment|// TODO: make this sync finer, i.e. just the segment + schemaGen
synchronized|synchronized
init|(
name|ReindexingReader
operator|.
name|this
init|)
block|{
if|if
condition|(
name|DEBUG
condition|)
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|": TEST: now close parallel parLeafReader dir="
operator|+
name|dir
operator|+
literal|" segIDGen="
operator|+
name|segIDGen
argument_list|)
expr_stmt|;
name|parallelReaders
operator|.
name|remove
argument_list|(
name|segIDGen
argument_list|)
expr_stmt|;
name|dir
operator|.
name|close
argument_list|()
expr_stmt|;
name|closedSegments
operator|.
name|add
argument_list|(
name|segIDGen
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"TEST: hit IOExc closing dir="
operator|+
name|dir
argument_list|)
expr_stmt|;
name|ioe
operator|.
name|printStackTrace
argument_list|(
name|System
operator|.
name|out
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|ioe
argument_list|)
throw|;
block|}
block|}
block|}
comment|// Returns a ref
DECL|method|getParallelLeafReader
name|LeafReader
name|getParallelLeafReader
parameter_list|(
specifier|final
name|LeafReader
name|leaf
parameter_list|,
name|boolean
name|doCache
parameter_list|,
name|long
name|schemaGen
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|leaf
operator|instanceof
name|SegmentReader
assert|;
name|SegmentInfo
name|info
init|=
operator|(
operator|(
name|SegmentReader
operator|)
name|leaf
operator|)
operator|.
name|getSegmentInfo
argument_list|()
operator|.
name|info
decl_stmt|;
name|long
name|infoSchemaGen
init|=
name|getSchemaGen
argument_list|(
name|info
argument_list|)
decl_stmt|;
if|if
condition|(
name|DEBUG
condition|)
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|": TEST: getParallelLeafReader: "
operator|+
name|leaf
operator|+
literal|" infoSchemaGen="
operator|+
name|infoSchemaGen
operator|+
literal|" vs schemaGen="
operator|+
name|schemaGen
operator|+
literal|" doCache="
operator|+
name|doCache
argument_list|)
expr_stmt|;
if|if
condition|(
name|infoSchemaGen
operator|==
name|schemaGen
condition|)
block|{
if|if
condition|(
name|DEBUG
condition|)
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|": TEST: segment is already current schemaGen="
operator|+
name|schemaGen
operator|+
literal|"; skipping"
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
if|if
condition|(
name|infoSchemaGen
operator|>
name|schemaGen
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"segment infoSchemaGen ("
operator|+
name|infoSchemaGen
operator|+
literal|") cannot be greater than requested schemaGen ("
operator|+
name|schemaGen
operator|+
literal|")"
argument_list|)
throw|;
block|}
specifier|final
name|SegmentIDAndGen
name|segIDGen
init|=
operator|new
name|SegmentIDAndGen
argument_list|(
name|StringHelper
operator|.
name|idToString
argument_list|(
name|info
operator|.
name|getId
argument_list|()
argument_list|)
argument_list|,
name|schemaGen
argument_list|)
decl_stmt|;
comment|// While loop because the parallel reader may be closed out from under us, so we must retry:
while|while
condition|(
literal|true
condition|)
block|{
comment|// TODO: make this sync finer, i.e. just the segment + schemaGen
synchronized|synchronized
init|(
name|this
init|)
block|{
name|LeafReader
name|parReader
init|=
name|parallelReaders
operator|.
name|get
argument_list|(
name|segIDGen
argument_list|)
decl_stmt|;
assert|assert
name|doCache
operator|||
name|parReader
operator|==
literal|null
assert|;
if|if
condition|(
name|parReader
operator|==
literal|null
condition|)
block|{
name|Path
name|leafIndex
init|=
name|segsPath
operator|.
name|resolve
argument_list|(
name|segIDGen
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|Directory
name|dir
init|=
name|openDirectory
argument_list|(
name|leafIndex
argument_list|)
decl_stmt|;
if|if
condition|(
name|slowFileExists
argument_list|(
name|dir
argument_list|,
literal|"done"
argument_list|)
operator|==
literal|false
condition|)
block|{
if|if
condition|(
name|DEBUG
condition|)
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|": TEST: build segment index for "
operator|+
name|leaf
operator|+
literal|" "
operator|+
name|segIDGen
operator|+
literal|" (source: "
operator|+
name|info
operator|.
name|getDiagnostics
argument_list|()
operator|.
name|get
argument_list|(
literal|"source"
argument_list|)
operator|+
literal|") dir="
operator|+
name|leafIndex
argument_list|)
expr_stmt|;
if|if
condition|(
name|dir
operator|.
name|listAll
argument_list|()
operator|.
name|length
operator|!=
literal|0
condition|)
block|{
comment|// It crashed before finishing last time:
if|if
condition|(
name|DEBUG
condition|)
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|": TEST: remove old incomplete index files: "
operator|+
name|leafIndex
argument_list|)
expr_stmt|;
name|IOUtils
operator|.
name|rm
argument_list|(
name|leafIndex
argument_list|)
expr_stmt|;
block|}
name|reindex
argument_list|(
name|infoSchemaGen
argument_list|,
name|schemaGen
argument_list|,
name|leaf
argument_list|,
name|dir
argument_list|)
expr_stmt|;
comment|// Marker file, telling us this index is in fact done.  This way if we crash while doing the reindexing for a given segment, we will
comment|// later try again:
name|dir
operator|.
name|createOutput
argument_list|(
literal|"done"
argument_list|,
name|IOContext
operator|.
name|DEFAULT
argument_list|)
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|DEBUG
condition|)
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|": TEST: segment index already exists for "
operator|+
name|leaf
operator|+
literal|" "
operator|+
name|segIDGen
operator|+
literal|" (source: "
operator|+
name|info
operator|.
name|getDiagnostics
argument_list|()
operator|.
name|get
argument_list|(
literal|"source"
argument_list|)
operator|+
literal|") dir="
operator|+
name|leafIndex
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|DEBUG
condition|)
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|": TEST: now check index "
operator|+
name|dir
argument_list|)
expr_stmt|;
comment|//TestUtil.checkIndex(dir);
name|SegmentInfos
name|infos
init|=
name|SegmentInfos
operator|.
name|readLatestCommit
argument_list|(
name|dir
argument_list|)
decl_stmt|;
specifier|final
name|LeafReader
name|parLeafReader
decl_stmt|;
if|if
condition|(
name|infos
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
name|parLeafReader
operator|=
operator|new
name|SegmentReader
argument_list|(
name|infos
operator|.
name|info
argument_list|(
literal|0
argument_list|)
argument_list|,
name|IOContext
operator|.
name|DEFAULT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// This just means we didn't forceMerge above:
name|parLeafReader
operator|=
name|SlowCompositeReaderWrapper
operator|.
name|wrap
argument_list|(
name|DirectoryReader
operator|.
name|open
argument_list|(
name|dir
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|//checkParallelReader(leaf, parLeafReader, schemaGen);
if|if
condition|(
name|DEBUG
condition|)
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|": TEST: opened parallel reader: "
operator|+
name|parLeafReader
argument_list|)
expr_stmt|;
if|if
condition|(
name|doCache
condition|)
block|{
name|parallelReaders
operator|.
name|put
argument_list|(
name|segIDGen
argument_list|,
name|parLeafReader
argument_list|)
expr_stmt|;
comment|// Our id+gen could have been previously closed, e.g. if it was a merged segment that was warmed, so we must clear this else
comment|// the pruning may remove our directory:
name|closedSegments
operator|.
name|remove
argument_list|(
name|segIDGen
argument_list|)
expr_stmt|;
name|parLeafReader
operator|.
name|addReaderClosedListener
argument_list|(
operator|new
name|ParallelReaderClosed
argument_list|(
name|segIDGen
argument_list|,
name|dir
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Used only for merged segment warming:
comment|// Messy: we close this reader now, instead of leaving open for reuse:
if|if
condition|(
name|DEBUG
condition|)
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"TEST: now decRef non cached refCount="
operator|+
name|parLeafReader
operator|.
name|getRefCount
argument_list|()
argument_list|)
expr_stmt|;
name|parLeafReader
operator|.
name|decRef
argument_list|()
expr_stmt|;
name|dir
operator|.
name|close
argument_list|()
expr_stmt|;
comment|// Must do this after dir is closed, else another thread could "rm -rf" while we are closing (which makes MDW.close's
comment|// checkIndex angry):
name|closedSegments
operator|.
name|add
argument_list|(
name|segIDGen
argument_list|)
expr_stmt|;
name|parReader
operator|=
literal|null
expr_stmt|;
block|}
name|parReader
operator|=
name|parLeafReader
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|parReader
operator|.
name|tryIncRef
argument_list|()
operator|==
literal|false
condition|)
block|{
comment|// We failed: this reader just got closed by another thread, e.g. refresh thread opening a new reader, so this reader is now
comment|// closed and we must try again.
if|if
condition|(
name|DEBUG
condition|)
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|": TEST: tryIncRef failed for "
operator|+
name|parReader
operator|+
literal|"; retry"
argument_list|)
expr_stmt|;
name|parReader
operator|=
literal|null
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|DEBUG
condition|)
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|": TEST: use existing already opened parReader="
operator|+
name|parReader
operator|+
literal|" refCount="
operator|+
name|parReader
operator|.
name|getRefCount
argument_list|()
argument_list|)
expr_stmt|;
comment|//checkParallelReader(leaf, parReader, schemaGen);
block|}
comment|// We return the new reference to caller
return|return
name|parReader
return|;
block|}
block|}
block|}
comment|// TODO: we could pass a writer already opened...?
DECL|method|reindex
specifier|protected
specifier|abstract
name|void
name|reindex
parameter_list|(
name|long
name|oldSchemaGen
parameter_list|,
name|long
name|newSchemaGen
parameter_list|,
name|LeafReader
name|reader
parameter_list|,
name|Directory
name|parallelDir
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|/** Returns the gen for the current schema. */
DECL|method|getCurrentSchemaGen
specifier|protected
specifier|abstract
name|long
name|getCurrentSchemaGen
parameter_list|()
function_decl|;
comment|/** Returns the gen that should be merged, meaning those changes will be folded back into the main index. */
DECL|method|getMergingSchemaGen
specifier|protected
name|long
name|getMergingSchemaGen
parameter_list|()
block|{
return|return
name|getCurrentSchemaGen
argument_list|()
return|;
block|}
comment|/** Removes the parallel index that are no longer in the last commit point.  We can't      *  remove this when the parallel reader is closed because it may still be referenced by      *  the last commit. */
DECL|method|pruneOldSegments
specifier|private
name|void
name|pruneOldSegments
parameter_list|(
name|boolean
name|removeOldGens
parameter_list|)
throws|throws
name|IOException
block|{
name|SegmentInfos
name|lastCommit
init|=
name|SegmentInfos
operator|.
name|readLatestCommit
argument_list|(
name|indexDir
argument_list|)
decl_stmt|;
if|if
condition|(
name|DEBUG
condition|)
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"TEST: prune"
argument_list|)
expr_stmt|;
name|Set
argument_list|<
name|String
argument_list|>
name|liveIDs
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|SegmentCommitInfo
name|info
range|:
name|lastCommit
control|)
block|{
name|String
name|idString
init|=
name|StringHelper
operator|.
name|idToString
argument_list|(
name|info
operator|.
name|info
operator|.
name|getId
argument_list|()
argument_list|)
decl_stmt|;
name|liveIDs
operator|.
name|add
argument_list|(
name|idString
argument_list|)
expr_stmt|;
block|}
name|long
name|currentSchemaGen
init|=
name|getCurrentSchemaGen
argument_list|()
decl_stmt|;
if|if
condition|(
name|Files
operator|.
name|exists
argument_list|(
name|segsPath
argument_list|)
condition|)
block|{
for|for
control|(
name|Path
name|path
range|:
name|segSubDirs
argument_list|(
name|segsPath
argument_list|)
control|)
block|{
if|if
condition|(
name|Files
operator|.
name|isDirectory
argument_list|(
name|path
argument_list|)
condition|)
block|{
name|SegmentIDAndGen
name|segIDGen
init|=
operator|new
name|SegmentIDAndGen
argument_list|(
name|path
operator|.
name|getFileName
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
assert|assert
name|segIDGen
operator|.
name|schemaGen
operator|<=
name|currentSchemaGen
assert|;
if|if
condition|(
name|liveIDs
operator|.
name|contains
argument_list|(
name|segIDGen
operator|.
name|segID
argument_list|)
operator|==
literal|false
operator|&&
operator|(
name|closedSegments
operator|.
name|contains
argument_list|(
name|segIDGen
argument_list|)
operator|||
operator|(
name|removeOldGens
operator|&&
name|segIDGen
operator|.
name|schemaGen
operator|<
name|currentSchemaGen
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|DEBUG
condition|)
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"TEST: remove "
operator|+
name|segIDGen
argument_list|)
expr_stmt|;
try|try
block|{
name|IOUtils
operator|.
name|rm
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|closedSegments
operator|.
name|remove
argument_list|(
name|segIDGen
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
comment|// OK, we'll retry later
if|if
condition|(
name|DEBUG
condition|)
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"TEST: ignore ioe during delete "
operator|+
name|path
operator|+
literal|":"
operator|+
name|ioe
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
block|}
comment|/** Just replaces the sub-readers with parallel readers, so reindexed fields are merged into new segments. */
DECL|class|ReindexingMergePolicy
specifier|private
class|class
name|ReindexingMergePolicy
extends|extends
name|MergePolicyWrapper
block|{
DECL|class|ReindexingOneMerge
class|class
name|ReindexingOneMerge
extends|extends
name|OneMerge
block|{
DECL|field|parallelReaders
name|List
argument_list|<
name|LeafReader
argument_list|>
name|parallelReaders
decl_stmt|;
DECL|field|schemaGen
specifier|final
name|long
name|schemaGen
decl_stmt|;
DECL|method|ReindexingOneMerge
name|ReindexingOneMerge
parameter_list|(
name|List
argument_list|<
name|SegmentCommitInfo
argument_list|>
name|segments
parameter_list|)
block|{
name|super
argument_list|(
name|segments
argument_list|)
expr_stmt|;
comment|// Commit up front to which schemaGen we will merge; we don't want a schema change sneaking in for some of our leaf readers but not others:
name|schemaGen
operator|=
name|getMergingSchemaGen
argument_list|()
expr_stmt|;
name|long
name|currentSchemaGen
init|=
name|getCurrentSchemaGen
argument_list|()
decl_stmt|;
comment|// Defensive sanity check:
if|if
condition|(
name|schemaGen
operator|>
name|currentSchemaGen
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"currentSchemaGen ("
operator|+
name|currentSchemaGen
operator|+
literal|") must always be>= mergingSchemaGen ("
operator|+
name|schemaGen
operator|+
literal|")"
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
DECL|method|getMergeReaders
specifier|public
name|List
argument_list|<
name|CodecReader
argument_list|>
name|getMergeReaders
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|parallelReaders
operator|==
literal|null
condition|)
block|{
name|parallelReaders
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
expr_stmt|;
for|for
control|(
name|CodecReader
name|reader
range|:
name|super
operator|.
name|getMergeReaders
argument_list|()
control|)
block|{
name|parallelReaders
operator|.
name|add
argument_list|(
name|getCurrentReader
argument_list|(
operator|(
name|SegmentReader
operator|)
name|reader
argument_list|,
name|schemaGen
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|// TODO: fix ParallelLeafReader, if this is a good use case
name|List
argument_list|<
name|CodecReader
argument_list|>
name|mergeReaders
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|LeafReader
name|reader
range|:
name|parallelReaders
control|)
block|{
name|mergeReaders
operator|.
name|add
argument_list|(
name|SlowCodecReaderWrapper
operator|.
name|wrap
argument_list|(
name|reader
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|mergeReaders
return|;
block|}
annotation|@
name|Override
DECL|method|mergeFinished
specifier|public
name|void
name|mergeFinished
parameter_list|()
throws|throws
name|IOException
block|{
name|Throwable
name|th
init|=
literal|null
decl_stmt|;
for|for
control|(
name|LeafReader
name|r
range|:
name|parallelReaders
control|)
block|{
if|if
condition|(
name|r
operator|instanceof
name|ParallelLeafReader
condition|)
block|{
try|try
block|{
name|r
operator|.
name|decRef
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
if|if
condition|(
name|th
operator|==
literal|null
condition|)
block|{
name|th
operator|=
name|t
expr_stmt|;
block|}
block|}
block|}
block|}
comment|// If any error occured, throw it.
name|IOUtils
operator|.
name|reThrow
argument_list|(
name|th
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|setMergeInfo
specifier|public
name|void
name|setMergeInfo
parameter_list|(
name|SegmentCommitInfo
name|info
parameter_list|)
block|{
comment|// Record that this merged segment is current as of this schemaGen:
name|info
operator|.
name|info
operator|.
name|getDiagnostics
argument_list|()
operator|.
name|put
argument_list|(
name|SCHEMA_GEN_KEY
argument_list|,
name|Long
operator|.
name|toString
argument_list|(
name|schemaGen
argument_list|)
argument_list|)
expr_stmt|;
name|super
operator|.
name|setMergeInfo
argument_list|(
name|info
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|getDocMap
specifier|public
name|MergePolicy
operator|.
name|DocMap
name|getDocMap
parameter_list|(
specifier|final
name|MergeState
name|mergeState
parameter_list|)
block|{
return|return
name|super
operator|.
name|getDocMap
argument_list|(
name|mergeState
argument_list|)
return|;
block|}
block|}
DECL|class|ReindexingMergeSpecification
class|class
name|ReindexingMergeSpecification
extends|extends
name|MergeSpecification
block|{
annotation|@
name|Override
DECL|method|add
specifier|public
name|void
name|add
parameter_list|(
name|OneMerge
name|merge
parameter_list|)
block|{
name|super
operator|.
name|add
argument_list|(
operator|new
name|ReindexingOneMerge
argument_list|(
name|merge
operator|.
name|segments
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|segString
specifier|public
name|String
name|segString
parameter_list|(
name|Directory
name|dir
parameter_list|)
block|{
return|return
literal|"ReindexingMergeSpec("
operator|+
name|super
operator|.
name|segString
argument_list|(
name|dir
argument_list|)
operator|+
literal|")"
return|;
block|}
block|}
DECL|method|wrap
name|MergeSpecification
name|wrap
parameter_list|(
name|MergeSpecification
name|spec
parameter_list|)
block|{
name|MergeSpecification
name|wrapped
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|spec
operator|!=
literal|null
condition|)
block|{
name|wrapped
operator|=
operator|new
name|ReindexingMergeSpecification
argument_list|()
expr_stmt|;
for|for
control|(
name|OneMerge
name|merge
range|:
name|spec
operator|.
name|merges
control|)
block|{
name|wrapped
operator|.
name|add
argument_list|(
name|merge
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|wrapped
return|;
block|}
comment|/** Create a new {@code MergePolicy} that sorts documents with the given {@code sort}. */
DECL|method|ReindexingMergePolicy
specifier|public
name|ReindexingMergePolicy
parameter_list|(
name|MergePolicy
name|in
parameter_list|)
block|{
name|super
argument_list|(
name|in
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|findMerges
specifier|public
name|MergeSpecification
name|findMerges
parameter_list|(
name|MergeTrigger
name|mergeTrigger
parameter_list|,
name|SegmentInfos
name|segmentInfos
parameter_list|,
name|IndexWriter
name|writer
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|wrap
argument_list|(
name|in
operator|.
name|findMerges
argument_list|(
name|mergeTrigger
argument_list|,
name|segmentInfos
argument_list|,
name|writer
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|findForcedMerges
specifier|public
name|MergeSpecification
name|findForcedMerges
parameter_list|(
name|SegmentInfos
name|segmentInfos
parameter_list|,
name|int
name|maxSegmentCount
parameter_list|,
name|Map
argument_list|<
name|SegmentCommitInfo
argument_list|,
name|Boolean
argument_list|>
name|segmentsToMerge
parameter_list|,
name|IndexWriter
name|writer
parameter_list|)
throws|throws
name|IOException
block|{
comment|// TODO: do we need to force-force this?  Ie, wrapped MP may think index is already optimized, yet maybe its schemaGen is old?  need test!
return|return
name|wrap
argument_list|(
name|in
operator|.
name|findForcedMerges
argument_list|(
name|segmentInfos
argument_list|,
name|maxSegmentCount
argument_list|,
name|segmentsToMerge
argument_list|,
name|writer
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|findForcedDeletesMerges
specifier|public
name|MergeSpecification
name|findForcedDeletesMerges
parameter_list|(
name|SegmentInfos
name|segmentInfos
parameter_list|,
name|IndexWriter
name|writer
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|wrap
argument_list|(
name|in
operator|.
name|findForcedDeletesMerges
argument_list|(
name|segmentInfos
argument_list|,
name|writer
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|useCompoundFile
specifier|public
name|boolean
name|useCompoundFile
parameter_list|(
name|SegmentInfos
name|segments
parameter_list|,
name|SegmentCommitInfo
name|newSegment
parameter_list|,
name|IndexWriter
name|writer
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|in
operator|.
name|useCompoundFile
argument_list|(
name|segments
argument_list|,
name|newSegment
argument_list|,
name|writer
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"ReindexingMergePolicy("
operator|+
name|in
operator|+
literal|")"
return|;
block|}
block|}
DECL|method|getSchemaGen
specifier|static
name|long
name|getSchemaGen
parameter_list|(
name|SegmentInfo
name|info
parameter_list|)
block|{
name|String
name|s
init|=
name|info
operator|.
name|getDiagnostics
argument_list|()
operator|.
name|get
argument_list|(
name|SCHEMA_GEN_KEY
argument_list|)
decl_stmt|;
if|if
condition|(
name|s
operator|==
literal|null
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
else|else
block|{
return|return
name|Long
operator|.
name|parseLong
argument_list|(
name|s
argument_list|)
return|;
block|}
block|}
block|}
DECL|method|getReindexer
specifier|private
name|ReindexingReader
name|getReindexer
parameter_list|(
name|Path
name|root
parameter_list|)
throws|throws
name|IOException
block|{
return|return
operator|new
name|ReindexingReader
argument_list|(
name|root
argument_list|)
block|{
annotation|@
name|Override
specifier|protected
name|IndexWriterConfig
name|getIndexWriterConfig
parameter_list|()
throws|throws
name|IOException
block|{
name|IndexWriterConfig
name|iwc
init|=
name|newIndexWriterConfig
argument_list|()
decl_stmt|;
name|TieredMergePolicy
name|tmp
init|=
operator|new
name|TieredMergePolicy
argument_list|()
decl_stmt|;
comment|// We write tiny docs, so we need tiny floor to avoid O(N^2) merging:
name|tmp
operator|.
name|setFloorSegmentMB
argument_list|(
literal|.01
argument_list|)
expr_stmt|;
name|iwc
operator|.
name|setMergePolicy
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
return|return
name|iwc
return|;
block|}
annotation|@
name|Override
specifier|protected
name|Directory
name|openDirectory
parameter_list|(
name|Path
name|path
parameter_list|)
throws|throws
name|IOException
block|{
name|MockDirectoryWrapper
name|dir
init|=
name|newMockFSDirectory
argument_list|(
name|path
argument_list|)
decl_stmt|;
name|dir
operator|.
name|setUseSlowOpenClosers
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|dir
operator|.
name|setThrottling
argument_list|(
name|Throttling
operator|.
name|NEVER
argument_list|)
expr_stmt|;
return|return
name|dir
return|;
block|}
annotation|@
name|Override
specifier|protected
name|void
name|reindex
parameter_list|(
name|long
name|oldSchemaGen
parameter_list|,
name|long
name|newSchemaGen
parameter_list|,
name|LeafReader
name|reader
parameter_list|,
name|Directory
name|parallelDir
parameter_list|)
throws|throws
name|IOException
block|{
name|IndexWriterConfig
name|iwc
init|=
name|newIndexWriterConfig
argument_list|()
decl_stmt|;
comment|// The order of our docIDs must precisely matching incoming reader:
name|iwc
operator|.
name|setMergePolicy
argument_list|(
operator|new
name|LogByteSizeMergePolicy
argument_list|()
argument_list|)
expr_stmt|;
name|IndexWriter
name|w
init|=
operator|new
name|IndexWriter
argument_list|(
name|parallelDir
argument_list|,
name|iwc
argument_list|)
decl_stmt|;
name|int
name|maxDoc
init|=
name|reader
operator|.
name|maxDoc
argument_list|()
decl_stmt|;
comment|// Slowly parse the stored field into a new doc values field:
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|maxDoc
condition|;
name|i
operator|++
control|)
block|{
comment|// TODO: is this still O(blockSize^2)?
name|Document
name|oldDoc
init|=
name|reader
operator|.
name|document
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|Document
name|newDoc
init|=
operator|new
name|Document
argument_list|()
decl_stmt|;
name|long
name|value
init|=
name|Long
operator|.
name|parseLong
argument_list|(
name|oldDoc
operator|.
name|get
argument_list|(
literal|"text"
argument_list|)
operator|.
name|split
argument_list|(
literal|" "
argument_list|)
index|[
literal|1
index|]
argument_list|)
decl_stmt|;
name|newDoc
operator|.
name|add
argument_list|(
operator|new
name|NumericDocValuesField
argument_list|(
literal|"number"
argument_list|,
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|newDoc
operator|.
name|add
argument_list|(
operator|new
name|LongPoint
argument_list|(
literal|"number"
argument_list|,
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|w
operator|.
name|addDocument
argument_list|(
name|newDoc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|random
argument_list|()
operator|.
name|nextBoolean
argument_list|()
condition|)
block|{
name|w
operator|.
name|forceMerge
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|w
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
name|long
name|getCurrentSchemaGen
parameter_list|()
block|{
return|return
literal|0
return|;
block|}
block|}
return|;
block|}
comment|/** Schema change by adding a new number_<schemaGen> DV field each time. */
DECL|method|getReindexerNewDVFields
specifier|private
name|ReindexingReader
name|getReindexerNewDVFields
parameter_list|(
name|Path
name|root
parameter_list|,
specifier|final
name|AtomicLong
name|currentSchemaGen
parameter_list|)
throws|throws
name|IOException
block|{
return|return
operator|new
name|ReindexingReader
argument_list|(
name|root
argument_list|)
block|{
annotation|@
name|Override
specifier|protected
name|IndexWriterConfig
name|getIndexWriterConfig
parameter_list|()
throws|throws
name|IOException
block|{
name|IndexWriterConfig
name|iwc
init|=
name|newIndexWriterConfig
argument_list|()
decl_stmt|;
name|TieredMergePolicy
name|tmp
init|=
operator|new
name|TieredMergePolicy
argument_list|()
decl_stmt|;
comment|// We write tiny docs, so we need tiny floor to avoid O(N^2) merging:
name|tmp
operator|.
name|setFloorSegmentMB
argument_list|(
literal|.01
argument_list|)
expr_stmt|;
name|iwc
operator|.
name|setMergePolicy
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
return|return
name|iwc
return|;
block|}
annotation|@
name|Override
specifier|protected
name|Directory
name|openDirectory
parameter_list|(
name|Path
name|path
parameter_list|)
throws|throws
name|IOException
block|{
name|MockDirectoryWrapper
name|dir
init|=
name|newMockFSDirectory
argument_list|(
name|path
argument_list|)
decl_stmt|;
name|dir
operator|.
name|setUseSlowOpenClosers
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|dir
operator|.
name|setThrottling
argument_list|(
name|Throttling
operator|.
name|NEVER
argument_list|)
expr_stmt|;
return|return
name|dir
return|;
block|}
annotation|@
name|Override
specifier|protected
name|void
name|reindex
parameter_list|(
name|long
name|oldSchemaGen
parameter_list|,
name|long
name|newSchemaGen
parameter_list|,
name|LeafReader
name|reader
parameter_list|,
name|Directory
name|parallelDir
parameter_list|)
throws|throws
name|IOException
block|{
name|IndexWriterConfig
name|iwc
init|=
name|newIndexWriterConfig
argument_list|()
decl_stmt|;
comment|// The order of our docIDs must precisely matching incoming reader:
name|iwc
operator|.
name|setMergePolicy
argument_list|(
operator|new
name|LogByteSizeMergePolicy
argument_list|()
argument_list|)
expr_stmt|;
name|IndexWriter
name|w
init|=
operator|new
name|IndexWriter
argument_list|(
name|parallelDir
argument_list|,
name|iwc
argument_list|)
decl_stmt|;
name|int
name|maxDoc
init|=
name|reader
operator|.
name|maxDoc
argument_list|()
decl_stmt|;
if|if
condition|(
name|oldSchemaGen
operator|<=
literal|0
condition|)
block|{
comment|// Must slowly parse the stored field into a new doc values field:
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|maxDoc
condition|;
name|i
operator|++
control|)
block|{
comment|// TODO: is this still O(blockSize^2)?
name|Document
name|oldDoc
init|=
name|reader
operator|.
name|document
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|Document
name|newDoc
init|=
operator|new
name|Document
argument_list|()
decl_stmt|;
name|long
name|value
init|=
name|Long
operator|.
name|parseLong
argument_list|(
name|oldDoc
operator|.
name|get
argument_list|(
literal|"text"
argument_list|)
operator|.
name|split
argument_list|(
literal|" "
argument_list|)
index|[
literal|1
index|]
argument_list|)
decl_stmt|;
name|newDoc
operator|.
name|add
argument_list|(
operator|new
name|NumericDocValuesField
argument_list|(
literal|"number_"
operator|+
name|newSchemaGen
argument_list|,
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|newDoc
operator|.
name|add
argument_list|(
operator|new
name|LongPoint
argument_list|(
literal|"number"
argument_list|,
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|w
operator|.
name|addDocument
argument_list|(
name|newDoc
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// Just carry over doc values from previous field:
name|NumericDocValues
name|oldValues
init|=
name|reader
operator|.
name|getNumericDocValues
argument_list|(
literal|"number_"
operator|+
name|oldSchemaGen
argument_list|)
decl_stmt|;
name|assertNotNull
argument_list|(
literal|"oldSchemaGen="
operator|+
name|oldSchemaGen
argument_list|,
name|oldValues
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|maxDoc
condition|;
name|i
operator|++
control|)
block|{
comment|// TODO: is this still O(blockSize^2)?
name|Document
name|oldDoc
init|=
name|reader
operator|.
name|document
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|Document
name|newDoc
init|=
operator|new
name|Document
argument_list|()
decl_stmt|;
name|newDoc
operator|.
name|add
argument_list|(
operator|new
name|NumericDocValuesField
argument_list|(
literal|"number_"
operator|+
name|newSchemaGen
argument_list|,
name|oldValues
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|w
operator|.
name|addDocument
argument_list|(
name|newDoc
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|random
argument_list|()
operator|.
name|nextBoolean
argument_list|()
condition|)
block|{
name|w
operator|.
name|forceMerge
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|w
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
name|long
name|getCurrentSchemaGen
parameter_list|()
block|{
return|return
name|currentSchemaGen
operator|.
name|get
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|protected
name|void
name|checkParallelReader
parameter_list|(
name|LeafReader
name|r
parameter_list|,
name|LeafReader
name|parR
parameter_list|,
name|long
name|schemaGen
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|fieldName
init|=
literal|"number_"
operator|+
name|schemaGen
decl_stmt|;
if|if
condition|(
name|DEBUG
condition|)
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|": TEST: now check parallel number DVs field="
operator|+
name|fieldName
operator|+
literal|" r="
operator|+
name|r
operator|+
literal|" parR="
operator|+
name|parR
argument_list|)
expr_stmt|;
name|NumericDocValues
name|numbers
init|=
name|parR
operator|.
name|getNumericDocValues
argument_list|(
name|fieldName
argument_list|)
decl_stmt|;
if|if
condition|(
name|numbers
operator|==
literal|null
condition|)
block|{
return|return;
block|}
name|int
name|maxDoc
init|=
name|r
operator|.
name|maxDoc
argument_list|()
decl_stmt|;
name|boolean
name|failed
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|maxDoc
condition|;
name|i
operator|++
control|)
block|{
name|Document
name|oldDoc
init|=
name|r
operator|.
name|document
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|long
name|value
init|=
name|Long
operator|.
name|parseLong
argument_list|(
name|oldDoc
operator|.
name|get
argument_list|(
literal|"text"
argument_list|)
operator|.
name|split
argument_list|(
literal|" "
argument_list|)
index|[
literal|1
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|!=
name|numbers
operator|.
name|get
argument_list|(
name|i
argument_list|)
condition|)
block|{
if|if
condition|(
name|DEBUG
condition|)
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"FAIL: docID="
operator|+
name|i
operator|+
literal|" "
operator|+
name|oldDoc
operator|+
literal|" value="
operator|+
name|value
operator|+
literal|" number="
operator|+
name|numbers
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|+
literal|" numbers="
operator|+
name|numbers
argument_list|)
expr_stmt|;
name|failed
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|failed
condition|)
block|{
if|if
condition|(
name|DEBUG
condition|)
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"OK: docID="
operator|+
name|i
operator|+
literal|" "
operator|+
name|oldDoc
operator|+
literal|" value="
operator|+
name|value
operator|+
literal|" number="
operator|+
name|numbers
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|assertFalse
argument_list|(
literal|"FAILED field="
operator|+
name|fieldName
operator|+
literal|" r="
operator|+
name|r
argument_list|,
name|failed
argument_list|)
expr_stmt|;
block|}
block|}
return|;
block|}
comment|/** Schema change by adding changing how the same "number" DV field is indexed. */
DECL|method|getReindexerSameDVField
specifier|private
name|ReindexingReader
name|getReindexerSameDVField
parameter_list|(
name|Path
name|root
parameter_list|,
specifier|final
name|AtomicLong
name|currentSchemaGen
parameter_list|,
specifier|final
name|AtomicLong
name|mergingSchemaGen
parameter_list|)
throws|throws
name|IOException
block|{
return|return
operator|new
name|ReindexingReader
argument_list|(
name|root
argument_list|)
block|{
annotation|@
name|Override
specifier|protected
name|IndexWriterConfig
name|getIndexWriterConfig
parameter_list|()
throws|throws
name|IOException
block|{
name|IndexWriterConfig
name|iwc
init|=
name|newIndexWriterConfig
argument_list|()
decl_stmt|;
name|TieredMergePolicy
name|tmp
init|=
operator|new
name|TieredMergePolicy
argument_list|()
decl_stmt|;
comment|// We write tiny docs, so we need tiny floor to avoid O(N^2) merging:
name|tmp
operator|.
name|setFloorSegmentMB
argument_list|(
literal|.01
argument_list|)
expr_stmt|;
name|iwc
operator|.
name|setMergePolicy
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|TEST_NIGHTLY
condition|)
block|{
comment|// during nightly tests, we might use too many files if we arent careful
name|iwc
operator|.
name|setUseCompoundFile
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
return|return
name|iwc
return|;
block|}
annotation|@
name|Override
specifier|protected
name|Directory
name|openDirectory
parameter_list|(
name|Path
name|path
parameter_list|)
throws|throws
name|IOException
block|{
name|MockDirectoryWrapper
name|dir
init|=
name|newMockFSDirectory
argument_list|(
name|path
argument_list|)
decl_stmt|;
name|dir
operator|.
name|setUseSlowOpenClosers
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|dir
operator|.
name|setThrottling
argument_list|(
name|Throttling
operator|.
name|NEVER
argument_list|)
expr_stmt|;
return|return
name|dir
return|;
block|}
annotation|@
name|Override
specifier|protected
name|void
name|reindex
parameter_list|(
name|long
name|oldSchemaGen
parameter_list|,
name|long
name|newSchemaGen
parameter_list|,
name|LeafReader
name|reader
parameter_list|,
name|Directory
name|parallelDir
parameter_list|)
throws|throws
name|IOException
block|{
name|IndexWriterConfig
name|iwc
init|=
name|newIndexWriterConfig
argument_list|()
decl_stmt|;
comment|// The order of our docIDs must precisely matching incoming reader:
name|iwc
operator|.
name|setMergePolicy
argument_list|(
operator|new
name|LogByteSizeMergePolicy
argument_list|()
argument_list|)
expr_stmt|;
name|IndexWriter
name|w
init|=
operator|new
name|IndexWriter
argument_list|(
name|parallelDir
argument_list|,
name|iwc
argument_list|)
decl_stmt|;
name|int
name|maxDoc
init|=
name|reader
operator|.
name|maxDoc
argument_list|()
decl_stmt|;
if|if
condition|(
name|oldSchemaGen
operator|<=
literal|0
condition|)
block|{
comment|// Must slowly parse the stored field into a new doc values field:
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|maxDoc
condition|;
name|i
operator|++
control|)
block|{
comment|// TODO: is this still O(blockSize^2)?
name|Document
name|oldDoc
init|=
name|reader
operator|.
name|document
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|Document
name|newDoc
init|=
operator|new
name|Document
argument_list|()
decl_stmt|;
name|long
name|value
init|=
name|Long
operator|.
name|parseLong
argument_list|(
name|oldDoc
operator|.
name|get
argument_list|(
literal|"text"
argument_list|)
operator|.
name|split
argument_list|(
literal|" "
argument_list|)
index|[
literal|1
index|]
argument_list|)
decl_stmt|;
name|newDoc
operator|.
name|add
argument_list|(
operator|new
name|NumericDocValuesField
argument_list|(
literal|"number"
argument_list|,
name|newSchemaGen
operator|*
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|newDoc
operator|.
name|add
argument_list|(
operator|new
name|LongPoint
argument_list|(
literal|"number"
argument_list|,
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|w
operator|.
name|addDocument
argument_list|(
name|newDoc
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// Just carry over doc values from previous field:
name|NumericDocValues
name|oldValues
init|=
name|reader
operator|.
name|getNumericDocValues
argument_list|(
literal|"number"
argument_list|)
decl_stmt|;
name|assertNotNull
argument_list|(
literal|"oldSchemaGen="
operator|+
name|oldSchemaGen
argument_list|,
name|oldValues
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|maxDoc
condition|;
name|i
operator|++
control|)
block|{
comment|// TODO: is this still O(blockSize^2)?
name|Document
name|oldDoc
init|=
name|reader
operator|.
name|document
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|Document
name|newDoc
init|=
operator|new
name|Document
argument_list|()
decl_stmt|;
name|newDoc
operator|.
name|add
argument_list|(
operator|new
name|NumericDocValuesField
argument_list|(
literal|"number"
argument_list|,
name|newSchemaGen
operator|*
operator|(
name|oldValues
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|/
name|oldSchemaGen
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|w
operator|.
name|addDocument
argument_list|(
name|newDoc
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|random
argument_list|()
operator|.
name|nextBoolean
argument_list|()
condition|)
block|{
name|w
operator|.
name|forceMerge
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|w
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
name|long
name|getCurrentSchemaGen
parameter_list|()
block|{
return|return
name|currentSchemaGen
operator|.
name|get
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|protected
name|long
name|getMergingSchemaGen
parameter_list|()
block|{
return|return
name|mergingSchemaGen
operator|.
name|get
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|protected
name|void
name|checkParallelReader
parameter_list|(
name|LeafReader
name|r
parameter_list|,
name|LeafReader
name|parR
parameter_list|,
name|long
name|schemaGen
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|DEBUG
condition|)
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|": TEST: now check parallel number DVs r="
operator|+
name|r
operator|+
literal|" parR="
operator|+
name|parR
argument_list|)
expr_stmt|;
name|NumericDocValues
name|numbers
init|=
name|parR
operator|.
name|getNumericDocValues
argument_list|(
literal|"numbers"
argument_list|)
decl_stmt|;
if|if
condition|(
name|numbers
operator|==
literal|null
condition|)
block|{
return|return;
block|}
name|int
name|maxDoc
init|=
name|r
operator|.
name|maxDoc
argument_list|()
decl_stmt|;
name|boolean
name|failed
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|maxDoc
condition|;
name|i
operator|++
control|)
block|{
name|Document
name|oldDoc
init|=
name|r
operator|.
name|document
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|long
name|value
init|=
name|Long
operator|.
name|parseLong
argument_list|(
name|oldDoc
operator|.
name|get
argument_list|(
literal|"text"
argument_list|)
operator|.
name|split
argument_list|(
literal|" "
argument_list|)
index|[
literal|1
index|]
argument_list|)
decl_stmt|;
name|value
operator|*=
name|schemaGen
expr_stmt|;
if|if
condition|(
name|value
operator|!=
name|numbers
operator|.
name|get
argument_list|(
name|i
argument_list|)
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"FAIL: docID="
operator|+
name|i
operator|+
literal|" "
operator|+
name|oldDoc
operator|+
literal|" value="
operator|+
name|value
operator|+
literal|" number="
operator|+
name|numbers
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|+
literal|" numbers="
operator|+
name|numbers
argument_list|)
expr_stmt|;
name|failed
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|failed
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"OK: docID="
operator|+
name|i
operator|+
literal|" "
operator|+
name|oldDoc
operator|+
literal|" value="
operator|+
name|value
operator|+
literal|" number="
operator|+
name|numbers
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|assertFalse
argument_list|(
literal|"FAILED r="
operator|+
name|r
argument_list|,
name|failed
argument_list|)
expr_stmt|;
block|}
block|}
return|;
block|}
DECL|method|testBasicMultipleSchemaGens
specifier|public
name|void
name|testBasicMultipleSchemaGens
parameter_list|()
throws|throws
name|Exception
block|{
name|AtomicLong
name|currentSchemaGen
init|=
operator|new
name|AtomicLong
argument_list|()
decl_stmt|;
comment|// TODO: separate refresh thread, search threads, indexing threads
name|Path
name|root
init|=
name|createTempDir
argument_list|()
decl_stmt|;
name|ReindexingReader
name|reindexer
init|=
name|getReindexerNewDVFields
argument_list|(
name|root
argument_list|,
name|currentSchemaGen
argument_list|)
decl_stmt|;
name|reindexer
operator|.
name|commit
argument_list|()
expr_stmt|;
name|Document
name|doc
init|=
operator|new
name|Document
argument_list|()
decl_stmt|;
name|doc
operator|.
name|add
argument_list|(
name|newTextField
argument_list|(
literal|"text"
argument_list|,
literal|"number "
operator|+
name|random
argument_list|()
operator|.
name|nextLong
argument_list|()
argument_list|,
name|Field
operator|.
name|Store
operator|.
name|YES
argument_list|)
argument_list|)
expr_stmt|;
name|reindexer
operator|.
name|w
operator|.
name|addDocument
argument_list|(
name|doc
argument_list|)
expr_stmt|;
if|if
condition|(
name|DEBUG
condition|)
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|": TEST: refresh @ 1 doc"
argument_list|)
expr_stmt|;
name|reindexer
operator|.
name|mgr
operator|.
name|maybeRefresh
argument_list|()
expr_stmt|;
name|DirectoryReader
name|r
init|=
name|reindexer
operator|.
name|mgr
operator|.
name|acquire
argument_list|()
decl_stmt|;
if|if
condition|(
name|DEBUG
condition|)
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|": TEST: got reader="
operator|+
name|r
argument_list|)
expr_stmt|;
try|try
block|{
name|checkAllNumberDVs
argument_list|(
name|r
argument_list|,
literal|"number_"
operator|+
name|currentSchemaGen
operator|.
name|get
argument_list|()
argument_list|,
literal|true
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|reindexer
operator|.
name|mgr
operator|.
name|release
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
comment|//reindexer.printRefCounts();
name|currentSchemaGen
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
if|if
condition|(
name|DEBUG
condition|)
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|": TEST: increment schemaGen"
argument_list|)
expr_stmt|;
if|if
condition|(
name|DEBUG
condition|)
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|": TEST: commit"
argument_list|)
expr_stmt|;
name|reindexer
operator|.
name|commit
argument_list|()
expr_stmt|;
name|doc
operator|=
operator|new
name|Document
argument_list|()
expr_stmt|;
name|doc
operator|.
name|add
argument_list|(
name|newTextField
argument_list|(
literal|"text"
argument_list|,
literal|"number "
operator|+
name|random
argument_list|()
operator|.
name|nextLong
argument_list|()
argument_list|,
name|Field
operator|.
name|Store
operator|.
name|YES
argument_list|)
argument_list|)
expr_stmt|;
name|reindexer
operator|.
name|w
operator|.
name|addDocument
argument_list|(
name|doc
argument_list|)
expr_stmt|;
if|if
condition|(
name|DEBUG
condition|)
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"TEST: refresh @ 2 docs"
argument_list|)
expr_stmt|;
name|reindexer
operator|.
name|mgr
operator|.
name|maybeRefresh
argument_list|()
expr_stmt|;
comment|//reindexer.printRefCounts();
name|r
operator|=
name|reindexer
operator|.
name|mgr
operator|.
name|acquire
argument_list|()
expr_stmt|;
if|if
condition|(
name|DEBUG
condition|)
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"TEST: got reader="
operator|+
name|r
argument_list|)
expr_stmt|;
try|try
block|{
name|checkAllNumberDVs
argument_list|(
name|r
argument_list|,
literal|"number_"
operator|+
name|currentSchemaGen
operator|.
name|get
argument_list|()
argument_list|,
literal|true
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|reindexer
operator|.
name|mgr
operator|.
name|release
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|DEBUG
condition|)
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"TEST: forceMerge"
argument_list|)
expr_stmt|;
name|reindexer
operator|.
name|w
operator|.
name|forceMerge
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|currentSchemaGen
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
if|if
condition|(
name|DEBUG
condition|)
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"TEST: commit"
argument_list|)
expr_stmt|;
name|reindexer
operator|.
name|commit
argument_list|()
expr_stmt|;
if|if
condition|(
name|DEBUG
condition|)
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"TEST: refresh after forceMerge"
argument_list|)
expr_stmt|;
name|reindexer
operator|.
name|mgr
operator|.
name|maybeRefresh
argument_list|()
expr_stmt|;
name|r
operator|=
name|reindexer
operator|.
name|mgr
operator|.
name|acquire
argument_list|()
expr_stmt|;
if|if
condition|(
name|DEBUG
condition|)
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"TEST: got reader="
operator|+
name|r
argument_list|)
expr_stmt|;
try|try
block|{
name|checkAllNumberDVs
argument_list|(
name|r
argument_list|,
literal|"number_"
operator|+
name|currentSchemaGen
operator|.
name|get
argument_list|()
argument_list|,
literal|true
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|reindexer
operator|.
name|mgr
operator|.
name|release
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|DEBUG
condition|)
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"TEST: close writer"
argument_list|)
expr_stmt|;
name|reindexer
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
DECL|method|testRandomMultipleSchemaGens
specifier|public
name|void
name|testRandomMultipleSchemaGens
parameter_list|()
throws|throws
name|Exception
block|{
name|AtomicLong
name|currentSchemaGen
init|=
operator|new
name|AtomicLong
argument_list|()
decl_stmt|;
name|ReindexingReader
name|reindexer
init|=
literal|null
decl_stmt|;
comment|// TODO: separate refresh thread, search threads, indexing threads
name|int
name|numDocs
init|=
name|atLeast
argument_list|(
name|TEST_NIGHTLY
condition|?
literal|20000
else|:
literal|1000
argument_list|)
decl_stmt|;
name|int
name|maxID
init|=
literal|0
decl_stmt|;
name|Path
name|root
init|=
name|createTempDir
argument_list|()
decl_stmt|;
name|int
name|refreshEveryNumDocs
init|=
literal|100
decl_stmt|;
name|int
name|commitCloseNumDocs
init|=
literal|1000
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numDocs
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|reindexer
operator|==
literal|null
condition|)
block|{
name|reindexer
operator|=
name|getReindexerNewDVFields
argument_list|(
name|root
argument_list|,
name|currentSchemaGen
argument_list|)
expr_stmt|;
block|}
name|Document
name|doc
init|=
operator|new
name|Document
argument_list|()
decl_stmt|;
name|String
name|id
decl_stmt|;
name|String
name|updateID
decl_stmt|;
if|if
condition|(
name|maxID
operator|>
literal|0
operator|&&
name|random
argument_list|()
operator|.
name|nextInt
argument_list|(
literal|10
argument_list|)
operator|==
literal|7
condition|)
block|{
comment|// Replace a doc
name|id
operator|=
literal|""
operator|+
name|random
argument_list|()
operator|.
name|nextInt
argument_list|(
name|maxID
argument_list|)
expr_stmt|;
name|updateID
operator|=
name|id
expr_stmt|;
block|}
else|else
block|{
name|id
operator|=
literal|""
operator|+
operator|(
name|maxID
operator|++
operator|)
expr_stmt|;
name|updateID
operator|=
literal|null
expr_stmt|;
block|}
name|doc
operator|.
name|add
argument_list|(
name|newStringField
argument_list|(
literal|"id"
argument_list|,
name|id
argument_list|,
name|Field
operator|.
name|Store
operator|.
name|NO
argument_list|)
argument_list|)
expr_stmt|;
name|doc
operator|.
name|add
argument_list|(
name|newTextField
argument_list|(
literal|"text"
argument_list|,
literal|"number "
operator|+
name|random
argument_list|()
operator|.
name|nextLong
argument_list|()
argument_list|,
name|Field
operator|.
name|Store
operator|.
name|YES
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|updateID
operator|==
literal|null
condition|)
block|{
name|reindexer
operator|.
name|w
operator|.
name|addDocument
argument_list|(
name|doc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|reindexer
operator|.
name|w
operator|.
name|updateDocument
argument_list|(
operator|new
name|Term
argument_list|(
literal|"id"
argument_list|,
name|updateID
argument_list|)
argument_list|,
name|doc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|random
argument_list|()
operator|.
name|nextInt
argument_list|(
name|refreshEveryNumDocs
argument_list|)
operator|==
literal|17
condition|)
block|{
if|if
condition|(
name|DEBUG
condition|)
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|": TEST TOP: refresh @ "
operator|+
operator|(
name|i
operator|+
literal|1
operator|)
operator|+
literal|" docs"
argument_list|)
expr_stmt|;
name|reindexer
operator|.
name|mgr
operator|.
name|maybeRefresh
argument_list|()
expr_stmt|;
name|DirectoryReader
name|r
init|=
name|reindexer
operator|.
name|mgr
operator|.
name|acquire
argument_list|()
decl_stmt|;
if|if
condition|(
name|DEBUG
condition|)
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|": TEST TOP: got reader="
operator|+
name|r
argument_list|)
expr_stmt|;
try|try
block|{
name|checkAllNumberDVs
argument_list|(
name|r
argument_list|,
literal|"number_"
operator|+
name|currentSchemaGen
operator|.
name|get
argument_list|()
argument_list|,
literal|true
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|reindexer
operator|.
name|mgr
operator|.
name|release
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|DEBUG
condition|)
name|reindexer
operator|.
name|printRefCounts
argument_list|()
expr_stmt|;
name|refreshEveryNumDocs
operator|=
call|(
name|int
call|)
argument_list|(
literal|1.25
operator|*
name|refreshEveryNumDocs
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|random
argument_list|()
operator|.
name|nextInt
argument_list|(
literal|500
argument_list|)
operator|==
literal|17
condition|)
block|{
name|currentSchemaGen
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
if|if
condition|(
name|DEBUG
condition|)
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|": TEST TOP: advance schemaGen to "
operator|+
name|currentSchemaGen
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|>
literal|0
operator|&&
name|random
argument_list|()
operator|.
name|nextInt
argument_list|(
literal|10
argument_list|)
operator|==
literal|7
condition|)
block|{
comment|// Random delete:
name|reindexer
operator|.
name|w
operator|.
name|deleteDocuments
argument_list|(
operator|new
name|Term
argument_list|(
literal|"id"
argument_list|,
literal|""
operator|+
name|random
argument_list|()
operator|.
name|nextInt
argument_list|(
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|random
argument_list|()
operator|.
name|nextInt
argument_list|(
name|commitCloseNumDocs
argument_list|)
operator|==
literal|17
condition|)
block|{
if|if
condition|(
name|DEBUG
condition|)
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|": TEST TOP: commit @ "
operator|+
operator|(
name|i
operator|+
literal|1
operator|)
operator|+
literal|" docs"
argument_list|)
expr_stmt|;
name|reindexer
operator|.
name|commit
argument_list|()
expr_stmt|;
comment|//reindexer.printRefCounts();
name|commitCloseNumDocs
operator|=
call|(
name|int
call|)
argument_list|(
literal|1.25
operator|*
name|commitCloseNumDocs
argument_list|)
expr_stmt|;
block|}
comment|// Sometimes close& reopen writer/manager, to confirm the parallel segments persist:
if|if
condition|(
name|random
argument_list|()
operator|.
name|nextInt
argument_list|(
name|commitCloseNumDocs
argument_list|)
operator|==
literal|17
condition|)
block|{
if|if
condition|(
name|DEBUG
condition|)
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|": TEST TOP: close writer @ "
operator|+
operator|(
name|i
operator|+
literal|1
operator|)
operator|+
literal|" docs"
argument_list|)
expr_stmt|;
name|reindexer
operator|.
name|close
argument_list|()
expr_stmt|;
name|reindexer
operator|=
literal|null
expr_stmt|;
name|commitCloseNumDocs
operator|=
call|(
name|int
call|)
argument_list|(
literal|1.25
operator|*
name|commitCloseNumDocs
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|reindexer
operator|!=
literal|null
condition|)
block|{
name|reindexer
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
comment|/** First schema change creates a new "number" DV field off the stored field; subsequent changes just change the value of that number    *  field for all docs. */
DECL|method|testRandomMultipleSchemaGensSameField
specifier|public
name|void
name|testRandomMultipleSchemaGensSameField
parameter_list|()
throws|throws
name|Exception
block|{
name|AtomicLong
name|currentSchemaGen
init|=
operator|new
name|AtomicLong
argument_list|()
decl_stmt|;
name|AtomicLong
name|mergingSchemaGen
init|=
operator|new
name|AtomicLong
argument_list|()
decl_stmt|;
name|ReindexingReader
name|reindexer
init|=
literal|null
decl_stmt|;
comment|// TODO: separate refresh thread, search threads, indexing threads
name|int
name|numDocs
init|=
name|atLeast
argument_list|(
name|TEST_NIGHTLY
condition|?
literal|20000
else|:
literal|1000
argument_list|)
decl_stmt|;
name|int
name|maxID
init|=
literal|0
decl_stmt|;
name|Path
name|root
init|=
name|createTempDir
argument_list|()
decl_stmt|;
name|int
name|refreshEveryNumDocs
init|=
literal|100
decl_stmt|;
name|int
name|commitCloseNumDocs
init|=
literal|1000
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numDocs
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|reindexer
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|DEBUG
condition|)
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|": TEST TOP: open new reader/writer"
argument_list|)
expr_stmt|;
name|reindexer
operator|=
name|getReindexerSameDVField
argument_list|(
name|root
argument_list|,
name|currentSchemaGen
argument_list|,
name|mergingSchemaGen
argument_list|)
expr_stmt|;
block|}
name|Document
name|doc
init|=
operator|new
name|Document
argument_list|()
decl_stmt|;
name|String
name|id
decl_stmt|;
name|String
name|updateID
decl_stmt|;
if|if
condition|(
name|maxID
operator|>
literal|0
operator|&&
name|random
argument_list|()
operator|.
name|nextInt
argument_list|(
literal|10
argument_list|)
operator|==
literal|7
condition|)
block|{
comment|// Replace a doc
name|id
operator|=
literal|""
operator|+
name|random
argument_list|()
operator|.
name|nextInt
argument_list|(
name|maxID
argument_list|)
expr_stmt|;
name|updateID
operator|=
name|id
expr_stmt|;
block|}
else|else
block|{
name|id
operator|=
literal|""
operator|+
operator|(
name|maxID
operator|++
operator|)
expr_stmt|;
name|updateID
operator|=
literal|null
expr_stmt|;
block|}
name|doc
operator|.
name|add
argument_list|(
name|newStringField
argument_list|(
literal|"id"
argument_list|,
name|id
argument_list|,
name|Field
operator|.
name|Store
operator|.
name|NO
argument_list|)
argument_list|)
expr_stmt|;
name|doc
operator|.
name|add
argument_list|(
name|newTextField
argument_list|(
literal|"text"
argument_list|,
literal|"number "
operator|+
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|random
argument_list|()
argument_list|,
operator|-
literal|10000
argument_list|,
literal|10000
argument_list|)
argument_list|,
name|Field
operator|.
name|Store
operator|.
name|YES
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|updateID
operator|==
literal|null
condition|)
block|{
name|reindexer
operator|.
name|w
operator|.
name|addDocument
argument_list|(
name|doc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|reindexer
operator|.
name|w
operator|.
name|updateDocument
argument_list|(
operator|new
name|Term
argument_list|(
literal|"id"
argument_list|,
name|updateID
argument_list|)
argument_list|,
name|doc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|random
argument_list|()
operator|.
name|nextInt
argument_list|(
name|refreshEveryNumDocs
argument_list|)
operator|==
literal|17
condition|)
block|{
if|if
condition|(
name|DEBUG
condition|)
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|": TEST TOP: refresh @ "
operator|+
operator|(
name|i
operator|+
literal|1
operator|)
operator|+
literal|" docs"
argument_list|)
expr_stmt|;
name|reindexer
operator|.
name|mgr
operator|.
name|maybeRefresh
argument_list|()
expr_stmt|;
name|DirectoryReader
name|r
init|=
name|reindexer
operator|.
name|mgr
operator|.
name|acquire
argument_list|()
decl_stmt|;
if|if
condition|(
name|DEBUG
condition|)
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|": TEST TOP: got reader="
operator|+
name|r
argument_list|)
expr_stmt|;
try|try
block|{
name|checkAllNumberDVs
argument_list|(
name|r
argument_list|,
literal|"number"
argument_list|,
literal|true
argument_list|,
operator|(
name|int
operator|)
name|currentSchemaGen
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|reindexer
operator|.
name|mgr
operator|.
name|release
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|DEBUG
condition|)
name|reindexer
operator|.
name|printRefCounts
argument_list|()
expr_stmt|;
name|refreshEveryNumDocs
operator|=
call|(
name|int
call|)
argument_list|(
literal|1.25
operator|*
name|refreshEveryNumDocs
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|random
argument_list|()
operator|.
name|nextInt
argument_list|(
literal|500
argument_list|)
operator|==
literal|17
condition|)
block|{
name|currentSchemaGen
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
if|if
condition|(
name|DEBUG
condition|)
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|": TEST TOP: advance schemaGen to "
operator|+
name|currentSchemaGen
argument_list|)
expr_stmt|;
if|if
condition|(
name|random
argument_list|()
operator|.
name|nextBoolean
argument_list|()
condition|)
block|{
name|mergingSchemaGen
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
if|if
condition|(
name|DEBUG
condition|)
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|": TEST TOP: advance mergingSchemaGen to "
operator|+
name|mergingSchemaGen
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|i
operator|>
literal|0
operator|&&
name|random
argument_list|()
operator|.
name|nextInt
argument_list|(
literal|10
argument_list|)
operator|==
literal|7
condition|)
block|{
comment|// Random delete:
name|reindexer
operator|.
name|w
operator|.
name|deleteDocuments
argument_list|(
operator|new
name|Term
argument_list|(
literal|"id"
argument_list|,
literal|""
operator|+
name|random
argument_list|()
operator|.
name|nextInt
argument_list|(
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|random
argument_list|()
operator|.
name|nextInt
argument_list|(
name|commitCloseNumDocs
argument_list|)
operator|==
literal|17
condition|)
block|{
if|if
condition|(
name|DEBUG
condition|)
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|": TEST TOP: commit @ "
operator|+
operator|(
name|i
operator|+
literal|1
operator|)
operator|+
literal|" docs"
argument_list|)
expr_stmt|;
name|reindexer
operator|.
name|commit
argument_list|()
expr_stmt|;
comment|//reindexer.printRefCounts();
name|commitCloseNumDocs
operator|=
call|(
name|int
call|)
argument_list|(
literal|1.25
operator|*
name|commitCloseNumDocs
argument_list|)
expr_stmt|;
block|}
comment|// Sometimes close& reopen writer/manager, to confirm the parallel segments persist:
if|if
condition|(
name|random
argument_list|()
operator|.
name|nextInt
argument_list|(
name|commitCloseNumDocs
argument_list|)
operator|==
literal|17
condition|)
block|{
if|if
condition|(
name|DEBUG
condition|)
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|": TEST TOP: close writer @ "
operator|+
operator|(
name|i
operator|+
literal|1
operator|)
operator|+
literal|" docs"
argument_list|)
expr_stmt|;
name|reindexer
operator|.
name|close
argument_list|()
expr_stmt|;
name|reindexer
operator|=
literal|null
expr_stmt|;
name|commitCloseNumDocs
operator|=
call|(
name|int
call|)
argument_list|(
literal|1.25
operator|*
name|commitCloseNumDocs
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|reindexer
operator|!=
literal|null
condition|)
block|{
name|reindexer
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
comment|// Verify main index never reflects schema changes beyond mergingSchemaGen:
try|try
init|(
name|Directory
name|dir
init|=
name|newFSDirectory
argument_list|(
name|root
operator|.
name|resolve
argument_list|(
literal|"index"
argument_list|)
argument_list|)
init|;
name|IndexReader
name|r
operator|=
name|DirectoryReader
operator|.
name|open
argument_list|(
name|dir
argument_list|)
init|)
block|{
for|for
control|(
name|LeafReaderContext
name|ctx
range|:
name|r
operator|.
name|leaves
argument_list|()
control|)
block|{
name|LeafReader
name|leaf
init|=
name|ctx
operator|.
name|reader
argument_list|()
decl_stmt|;
name|NumericDocValues
name|numbers
init|=
name|leaf
operator|.
name|getNumericDocValues
argument_list|(
literal|"number"
argument_list|)
decl_stmt|;
if|if
condition|(
name|numbers
operator|!=
literal|null
condition|)
block|{
name|int
name|maxDoc
init|=
name|leaf
operator|.
name|maxDoc
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|maxDoc
condition|;
name|i
operator|++
control|)
block|{
name|Document
name|doc
init|=
name|leaf
operator|.
name|document
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|long
name|value
init|=
name|Long
operator|.
name|parseLong
argument_list|(
name|doc
operator|.
name|get
argument_list|(
literal|"text"
argument_list|)
operator|.
name|split
argument_list|(
literal|" "
argument_list|)
index|[
literal|1
index|]
argument_list|)
decl_stmt|;
name|long
name|dvValue
init|=
name|numbers
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|==
literal|0
condition|)
block|{
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|dvValue
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|assertTrue
argument_list|(
name|dvValue
operator|%
name|value
operator|==
literal|0
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|dvValue
operator|/
name|value
operator|<=
name|mergingSchemaGen
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
block|}
DECL|method|testBasic
specifier|public
name|void
name|testBasic
parameter_list|()
throws|throws
name|Exception
block|{
name|Path
name|tempPath
init|=
name|createTempDir
argument_list|()
decl_stmt|;
name|ReindexingReader
name|reindexer
init|=
name|getReindexer
argument_list|(
name|tempPath
argument_list|)
decl_stmt|;
comment|// Start with initial empty commit:
name|reindexer
operator|.
name|commit
argument_list|()
expr_stmt|;
name|Document
name|doc
init|=
operator|new
name|Document
argument_list|()
decl_stmt|;
name|doc
operator|.
name|add
argument_list|(
name|newTextField
argument_list|(
literal|"text"
argument_list|,
literal|"number "
operator|+
name|random
argument_list|()
operator|.
name|nextLong
argument_list|()
argument_list|,
name|Field
operator|.
name|Store
operator|.
name|YES
argument_list|)
argument_list|)
expr_stmt|;
name|reindexer
operator|.
name|w
operator|.
name|addDocument
argument_list|(
name|doc
argument_list|)
expr_stmt|;
if|if
condition|(
name|DEBUG
condition|)
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"TEST: refresh @ 1 doc"
argument_list|)
expr_stmt|;
name|reindexer
operator|.
name|mgr
operator|.
name|maybeRefresh
argument_list|()
expr_stmt|;
name|DirectoryReader
name|r
init|=
name|reindexer
operator|.
name|mgr
operator|.
name|acquire
argument_list|()
decl_stmt|;
if|if
condition|(
name|DEBUG
condition|)
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"TEST: got reader="
operator|+
name|r
argument_list|)
expr_stmt|;
try|try
block|{
name|checkAllNumberDVs
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|IndexSearcher
name|s
init|=
name|newSearcher
argument_list|(
name|r
argument_list|)
decl_stmt|;
name|testNumericDVSort
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|testPointRangeQuery
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|reindexer
operator|.
name|mgr
operator|.
name|release
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
comment|//reindexer.printRefCounts();
if|if
condition|(
name|DEBUG
condition|)
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"TEST: commit"
argument_list|)
expr_stmt|;
name|reindexer
operator|.
name|commit
argument_list|()
expr_stmt|;
name|doc
operator|=
operator|new
name|Document
argument_list|()
expr_stmt|;
name|doc
operator|.
name|add
argument_list|(
name|newTextField
argument_list|(
literal|"text"
argument_list|,
literal|"number "
operator|+
name|random
argument_list|()
operator|.
name|nextLong
argument_list|()
argument_list|,
name|Field
operator|.
name|Store
operator|.
name|YES
argument_list|)
argument_list|)
expr_stmt|;
name|reindexer
operator|.
name|w
operator|.
name|addDocument
argument_list|(
name|doc
argument_list|)
expr_stmt|;
if|if
condition|(
name|DEBUG
condition|)
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"TEST: refresh @ 2 docs"
argument_list|)
expr_stmt|;
name|reindexer
operator|.
name|mgr
operator|.
name|maybeRefresh
argument_list|()
expr_stmt|;
comment|//reindexer.printRefCounts();
name|r
operator|=
name|reindexer
operator|.
name|mgr
operator|.
name|acquire
argument_list|()
expr_stmt|;
if|if
condition|(
name|DEBUG
condition|)
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"TEST: got reader="
operator|+
name|r
argument_list|)
expr_stmt|;
try|try
block|{
name|checkAllNumberDVs
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|IndexSearcher
name|s
init|=
name|newSearcher
argument_list|(
name|r
argument_list|)
decl_stmt|;
name|testNumericDVSort
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|testPointRangeQuery
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|reindexer
operator|.
name|mgr
operator|.
name|release
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|DEBUG
condition|)
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"TEST: forceMerge"
argument_list|)
expr_stmt|;
name|reindexer
operator|.
name|w
operator|.
name|forceMerge
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|DEBUG
condition|)
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"TEST: commit"
argument_list|)
expr_stmt|;
name|reindexer
operator|.
name|commit
argument_list|()
expr_stmt|;
if|if
condition|(
name|DEBUG
condition|)
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"TEST: refresh after forceMerge"
argument_list|)
expr_stmt|;
name|reindexer
operator|.
name|mgr
operator|.
name|maybeRefresh
argument_list|()
expr_stmt|;
name|r
operator|=
name|reindexer
operator|.
name|mgr
operator|.
name|acquire
argument_list|()
expr_stmt|;
if|if
condition|(
name|DEBUG
condition|)
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"TEST: got reader="
operator|+
name|r
argument_list|)
expr_stmt|;
try|try
block|{
name|checkAllNumberDVs
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|IndexSearcher
name|s
init|=
name|newSearcher
argument_list|(
name|r
argument_list|)
decl_stmt|;
name|testNumericDVSort
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|testPointRangeQuery
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|reindexer
operator|.
name|mgr
operator|.
name|release
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|DEBUG
condition|)
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"TEST: close writer"
argument_list|)
expr_stmt|;
name|reindexer
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
DECL|method|testRandom
specifier|public
name|void
name|testRandom
parameter_list|()
throws|throws
name|Exception
block|{
name|Path
name|root
init|=
name|createTempDir
argument_list|()
decl_stmt|;
name|ReindexingReader
name|reindexer
init|=
literal|null
decl_stmt|;
comment|// TODO: separate refresh thread, search threads, indexing threads
name|int
name|numDocs
init|=
name|atLeast
argument_list|(
name|TEST_NIGHTLY
condition|?
literal|20000
else|:
literal|1000
argument_list|)
decl_stmt|;
name|int
name|maxID
init|=
literal|0
decl_stmt|;
name|int
name|refreshEveryNumDocs
init|=
literal|100
decl_stmt|;
name|int
name|commitCloseNumDocs
init|=
literal|1000
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numDocs
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|reindexer
operator|==
literal|null
condition|)
block|{
name|reindexer
operator|=
name|getReindexer
argument_list|(
name|root
argument_list|)
expr_stmt|;
block|}
name|Document
name|doc
init|=
operator|new
name|Document
argument_list|()
decl_stmt|;
name|String
name|id
decl_stmt|;
name|String
name|updateID
decl_stmt|;
if|if
condition|(
name|maxID
operator|>
literal|0
operator|&&
name|random
argument_list|()
operator|.
name|nextInt
argument_list|(
literal|10
argument_list|)
operator|==
literal|7
condition|)
block|{
comment|// Replace a doc
name|id
operator|=
literal|""
operator|+
name|random
argument_list|()
operator|.
name|nextInt
argument_list|(
name|maxID
argument_list|)
expr_stmt|;
name|updateID
operator|=
name|id
expr_stmt|;
block|}
else|else
block|{
name|id
operator|=
literal|""
operator|+
operator|(
name|maxID
operator|++
operator|)
expr_stmt|;
name|updateID
operator|=
literal|null
expr_stmt|;
block|}
name|doc
operator|.
name|add
argument_list|(
name|newStringField
argument_list|(
literal|"id"
argument_list|,
name|id
argument_list|,
name|Field
operator|.
name|Store
operator|.
name|NO
argument_list|)
argument_list|)
expr_stmt|;
name|doc
operator|.
name|add
argument_list|(
name|newTextField
argument_list|(
literal|"text"
argument_list|,
literal|"number "
operator|+
name|random
argument_list|()
operator|.
name|nextLong
argument_list|()
argument_list|,
name|Field
operator|.
name|Store
operator|.
name|YES
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|updateID
operator|==
literal|null
condition|)
block|{
name|reindexer
operator|.
name|w
operator|.
name|addDocument
argument_list|(
name|doc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|reindexer
operator|.
name|w
operator|.
name|updateDocument
argument_list|(
operator|new
name|Term
argument_list|(
literal|"id"
argument_list|,
name|updateID
argument_list|)
argument_list|,
name|doc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|random
argument_list|()
operator|.
name|nextInt
argument_list|(
name|refreshEveryNumDocs
argument_list|)
operator|==
literal|17
condition|)
block|{
if|if
condition|(
name|DEBUG
condition|)
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"TEST: refresh @ "
operator|+
operator|(
name|i
operator|+
literal|1
operator|)
operator|+
literal|" docs"
argument_list|)
expr_stmt|;
name|reindexer
operator|.
name|mgr
operator|.
name|maybeRefresh
argument_list|()
expr_stmt|;
name|DirectoryReader
name|r
init|=
name|reindexer
operator|.
name|mgr
operator|.
name|acquire
argument_list|()
decl_stmt|;
if|if
condition|(
name|DEBUG
condition|)
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"TEST: got reader="
operator|+
name|r
argument_list|)
expr_stmt|;
try|try
block|{
name|checkAllNumberDVs
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|IndexSearcher
name|s
init|=
name|newSearcher
argument_list|(
name|r
argument_list|)
decl_stmt|;
name|testNumericDVSort
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|testPointRangeQuery
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|reindexer
operator|.
name|mgr
operator|.
name|release
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
name|refreshEveryNumDocs
operator|=
call|(
name|int
call|)
argument_list|(
literal|1.25
operator|*
name|refreshEveryNumDocs
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|>
literal|0
operator|&&
name|random
argument_list|()
operator|.
name|nextInt
argument_list|(
literal|10
argument_list|)
operator|==
literal|7
condition|)
block|{
comment|// Random delete:
name|reindexer
operator|.
name|w
operator|.
name|deleteDocuments
argument_list|(
operator|new
name|Term
argument_list|(
literal|"id"
argument_list|,
literal|""
operator|+
name|random
argument_list|()
operator|.
name|nextInt
argument_list|(
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|random
argument_list|()
operator|.
name|nextInt
argument_list|(
name|commitCloseNumDocs
argument_list|)
operator|==
literal|17
condition|)
block|{
if|if
condition|(
name|DEBUG
condition|)
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"TEST: commit @ "
operator|+
operator|(
name|i
operator|+
literal|1
operator|)
operator|+
literal|" docs"
argument_list|)
expr_stmt|;
name|reindexer
operator|.
name|commit
argument_list|()
expr_stmt|;
name|commitCloseNumDocs
operator|=
call|(
name|int
call|)
argument_list|(
literal|1.25
operator|*
name|commitCloseNumDocs
argument_list|)
expr_stmt|;
block|}
comment|// Sometimes close& reopen writer/manager, to confirm the parallel segments persist:
if|if
condition|(
name|random
argument_list|()
operator|.
name|nextInt
argument_list|(
name|commitCloseNumDocs
argument_list|)
operator|==
literal|17
condition|)
block|{
if|if
condition|(
name|DEBUG
condition|)
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"TEST: close writer @ "
operator|+
operator|(
name|i
operator|+
literal|1
operator|)
operator|+
literal|" docs"
argument_list|)
expr_stmt|;
name|reindexer
operator|.
name|close
argument_list|()
expr_stmt|;
name|reindexer
operator|=
literal|null
expr_stmt|;
name|commitCloseNumDocs
operator|=
call|(
name|int
call|)
argument_list|(
literal|1.25
operator|*
name|commitCloseNumDocs
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|reindexer
operator|!=
literal|null
condition|)
block|{
name|reindexer
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|checkAllNumberDVs
specifier|private
specifier|static
name|void
name|checkAllNumberDVs
parameter_list|(
name|IndexReader
name|r
parameter_list|)
throws|throws
name|IOException
block|{
name|checkAllNumberDVs
argument_list|(
name|r
argument_list|,
literal|"number"
argument_list|,
literal|true
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
DECL|method|checkAllNumberDVs
specifier|private
specifier|static
name|void
name|checkAllNumberDVs
parameter_list|(
name|IndexReader
name|r
parameter_list|,
name|String
name|fieldName
parameter_list|,
name|boolean
name|doThrow
parameter_list|,
name|int
name|multiplier
parameter_list|)
throws|throws
name|IOException
block|{
name|NumericDocValues
name|numbers
init|=
name|MultiDocValues
operator|.
name|getNumericValues
argument_list|(
name|r
argument_list|,
name|fieldName
argument_list|)
decl_stmt|;
name|int
name|maxDoc
init|=
name|r
operator|.
name|maxDoc
argument_list|()
decl_stmt|;
name|boolean
name|failed
init|=
literal|false
decl_stmt|;
name|long
name|t0
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|maxDoc
condition|;
name|i
operator|++
control|)
block|{
name|Document
name|oldDoc
init|=
name|r
operator|.
name|document
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|long
name|value
init|=
name|multiplier
operator|*
name|Long
operator|.
name|parseLong
argument_list|(
name|oldDoc
operator|.
name|get
argument_list|(
literal|"text"
argument_list|)
operator|.
name|split
argument_list|(
literal|" "
argument_list|)
index|[
literal|1
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|!=
name|numbers
operator|.
name|get
argument_list|(
name|i
argument_list|)
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"FAIL: docID="
operator|+
name|i
operator|+
literal|" "
operator|+
name|oldDoc
operator|+
literal|" value="
operator|+
name|value
operator|+
literal|" number="
operator|+
name|numbers
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|+
literal|" numbers="
operator|+
name|numbers
argument_list|)
expr_stmt|;
name|failed
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|failed
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"OK: docID="
operator|+
name|i
operator|+
literal|" "
operator|+
name|oldDoc
operator|+
literal|" value="
operator|+
name|value
operator|+
literal|" number="
operator|+
name|numbers
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|failed
condition|)
block|{
if|if
condition|(
name|r
operator|instanceof
name|LeafReader
operator|==
literal|false
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"TEST FAILED; check leaves"
argument_list|)
expr_stmt|;
for|for
control|(
name|LeafReaderContext
name|ctx
range|:
name|r
operator|.
name|leaves
argument_list|()
control|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"CHECK LEAF="
operator|+
name|ctx
operator|.
name|reader
argument_list|()
argument_list|)
expr_stmt|;
name|checkAllNumberDVs
argument_list|(
name|ctx
operator|.
name|reader
argument_list|()
argument_list|,
name|fieldName
argument_list|,
literal|false
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|doThrow
condition|)
block|{
name|assertFalse
argument_list|(
literal|"FAILED field="
operator|+
name|fieldName
operator|+
literal|" r="
operator|+
name|r
argument_list|,
name|failed
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"FAILED field="
operator|+
name|fieldName
operator|+
literal|" r="
operator|+
name|r
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|testNumericDVSort
specifier|private
specifier|static
name|void
name|testNumericDVSort
parameter_list|(
name|IndexSearcher
name|s
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Confirm we can sort by the new DV field:
name|TopDocs
name|hits
init|=
name|s
operator|.
name|search
argument_list|(
operator|new
name|MatchAllDocsQuery
argument_list|()
argument_list|,
literal|100
argument_list|,
operator|new
name|Sort
argument_list|(
operator|new
name|SortField
argument_list|(
literal|"number"
argument_list|,
name|SortField
operator|.
name|Type
operator|.
name|LONG
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|NumericDocValues
name|numbers
init|=
name|MultiDocValues
operator|.
name|getNumericValues
argument_list|(
name|s
operator|.
name|getIndexReader
argument_list|()
argument_list|,
literal|"number"
argument_list|)
decl_stmt|;
name|long
name|last
init|=
name|Long
operator|.
name|MIN_VALUE
decl_stmt|;
for|for
control|(
name|ScoreDoc
name|scoreDoc
range|:
name|hits
operator|.
name|scoreDocs
control|)
block|{
name|long
name|value
init|=
name|Long
operator|.
name|parseLong
argument_list|(
name|s
operator|.
name|doc
argument_list|(
name|scoreDoc
operator|.
name|doc
argument_list|)
operator|.
name|get
argument_list|(
literal|"text"
argument_list|)
operator|.
name|split
argument_list|(
literal|" "
argument_list|)
index|[
literal|1
index|]
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|value
operator|>=
name|last
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|value
argument_list|,
name|numbers
operator|.
name|get
argument_list|(
name|scoreDoc
operator|.
name|doc
argument_list|)
argument_list|)
expr_stmt|;
name|last
operator|=
name|value
expr_stmt|;
block|}
block|}
DECL|method|testPointRangeQuery
specifier|private
specifier|static
name|void
name|testPointRangeQuery
parameter_list|(
name|IndexSearcher
name|s
parameter_list|)
throws|throws
name|IOException
block|{
name|NumericDocValues
name|numbers
init|=
name|MultiDocValues
operator|.
name|getNumericValues
argument_list|(
name|s
operator|.
name|getIndexReader
argument_list|()
argument_list|,
literal|"number"
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|100
condition|;
name|i
operator|++
control|)
block|{
comment|// Confirm we can range search by the new indexed (numeric) field:
name|long
name|min
init|=
name|random
argument_list|()
operator|.
name|nextLong
argument_list|()
decl_stmt|;
name|long
name|max
init|=
name|random
argument_list|()
operator|.
name|nextLong
argument_list|()
decl_stmt|;
if|if
condition|(
name|min
operator|>
name|max
condition|)
block|{
name|long
name|x
init|=
name|min
decl_stmt|;
name|min
operator|=
name|max
expr_stmt|;
name|max
operator|=
name|x
expr_stmt|;
block|}
name|TopDocs
name|hits
init|=
name|s
operator|.
name|search
argument_list|(
name|PointRangeQuery
operator|.
name|new1DLongRange
argument_list|(
literal|"number"
argument_list|,
name|min
argument_list|,
literal|true
argument_list|,
name|max
argument_list|,
literal|true
argument_list|)
argument_list|,
literal|100
argument_list|)
decl_stmt|;
for|for
control|(
name|ScoreDoc
name|scoreDoc
range|:
name|hits
operator|.
name|scoreDocs
control|)
block|{
name|long
name|value
init|=
name|Long
operator|.
name|parseLong
argument_list|(
name|s
operator|.
name|doc
argument_list|(
name|scoreDoc
operator|.
name|doc
argument_list|)
operator|.
name|get
argument_list|(
literal|"text"
argument_list|)
operator|.
name|split
argument_list|(
literal|" "
argument_list|)
index|[
literal|1
index|]
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|value
operator|>=
name|min
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|value
operator|<=
name|max
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|value
argument_list|,
name|numbers
operator|.
name|get
argument_list|(
name|scoreDoc
operator|.
name|doc
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// TODO: maybe the leading id could be further restricted?  It's from StringHelper.idToString:
DECL|field|SEG_GEN_SUB_DIR_PATTERN
specifier|static
specifier|final
name|Pattern
name|SEG_GEN_SUB_DIR_PATTERN
init|=
name|Pattern
operator|.
name|compile
argument_list|(
literal|"^[a-z0-9]+_([0-9]+)$"
argument_list|)
decl_stmt|;
DECL|method|segSubDirs
specifier|private
specifier|static
name|List
argument_list|<
name|Path
argument_list|>
name|segSubDirs
parameter_list|(
name|Path
name|segsPath
parameter_list|)
throws|throws
name|IOException
block|{
name|List
argument_list|<
name|Path
argument_list|>
name|result
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
try|try
init|(
name|DirectoryStream
argument_list|<
name|Path
argument_list|>
name|stream
init|=
name|Files
operator|.
name|newDirectoryStream
argument_list|(
name|segsPath
argument_list|)
init|)
block|{
for|for
control|(
name|Path
name|path
range|:
name|stream
control|)
block|{
comment|// Must be form<segIDString>_<longGen>
if|if
condition|(
name|Files
operator|.
name|isDirectory
argument_list|(
name|path
argument_list|)
operator|&&
name|SEG_GEN_SUB_DIR_PATTERN
operator|.
name|matcher
argument_list|(
name|path
operator|.
name|getFileName
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
operator|.
name|matches
argument_list|()
condition|)
block|{
name|result
operator|.
name|add
argument_list|(
name|path
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|result
return|;
block|}
comment|// TODO: test exceptions
block|}
end_class
end_unit
