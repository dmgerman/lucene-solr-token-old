begin_unit
begin_package
DECL|package|org.apache.lucene.index
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
package|;
end_package
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ByteArrayOutputStream
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|PrintStream
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Reader
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Random
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|CountDownLatch
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicBoolean
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicInteger
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|*
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|document
operator|.
name|Document
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|document
operator|.
name|Field
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|document
operator|.
name|FieldType
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|document
operator|.
name|NumericDocValuesField
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|document
operator|.
name|StringField
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|IndexSearcher
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|ScoreDoc
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|TermQuery
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|Directory
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|MockDirectoryWrapper
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|RAMDirectory
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|LuceneTestCase
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|_TestUtil
import|;
end_import
begin_class
DECL|class|TestIndexWriterDelete
specifier|public
class|class
name|TestIndexWriterDelete
extends|extends
name|LuceneTestCase
block|{
comment|// test the simple case
DECL|method|testSimpleCase
specifier|public
name|void
name|testSimpleCase
parameter_list|()
throws|throws
name|IOException
block|{
name|String
index|[]
name|keywords
init|=
block|{
literal|"1"
block|,
literal|"2"
block|}
decl_stmt|;
name|String
index|[]
name|unindexed
init|=
block|{
literal|"Netherlands"
block|,
literal|"Italy"
block|}
decl_stmt|;
name|String
index|[]
name|unstored
init|=
block|{
literal|"Amsterdam has lots of bridges"
block|,
literal|"Venice has lots of canals"
block|}
decl_stmt|;
name|String
index|[]
name|text
init|=
block|{
literal|"Amsterdam"
block|,
literal|"Venice"
block|}
decl_stmt|;
name|Directory
name|dir
init|=
name|newDirectory
argument_list|()
decl_stmt|;
name|IndexWriter
name|modifier
init|=
operator|new
name|IndexWriter
argument_list|(
name|dir
argument_list|,
name|newIndexWriterConfig
argument_list|(
name|TEST_VERSION_CURRENT
argument_list|,
operator|new
name|MockAnalyzer
argument_list|(
name|random
argument_list|()
argument_list|,
name|MockTokenizer
operator|.
name|WHITESPACE
argument_list|,
literal|false
argument_list|)
argument_list|)
operator|.
name|setMaxBufferedDeleteTerms
argument_list|(
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|FieldType
name|custom1
init|=
operator|new
name|FieldType
argument_list|()
decl_stmt|;
name|custom1
operator|.
name|setStored
argument_list|(
literal|true
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|keywords
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|Document
name|doc
init|=
operator|new
name|Document
argument_list|()
decl_stmt|;
name|doc
operator|.
name|add
argument_list|(
name|newStringField
argument_list|(
literal|"id"
argument_list|,
name|keywords
index|[
name|i
index|]
argument_list|,
name|Field
operator|.
name|Store
operator|.
name|YES
argument_list|)
argument_list|)
expr_stmt|;
name|doc
operator|.
name|add
argument_list|(
name|newField
argument_list|(
literal|"country"
argument_list|,
name|unindexed
index|[
name|i
index|]
argument_list|,
name|custom1
argument_list|)
argument_list|)
expr_stmt|;
name|doc
operator|.
name|add
argument_list|(
name|newTextField
argument_list|(
literal|"contents"
argument_list|,
name|unstored
index|[
name|i
index|]
argument_list|,
name|Field
operator|.
name|Store
operator|.
name|NO
argument_list|)
argument_list|)
expr_stmt|;
name|doc
operator|.
name|add
argument_list|(
name|newTextField
argument_list|(
literal|"city"
argument_list|,
name|text
index|[
name|i
index|]
argument_list|,
name|Field
operator|.
name|Store
operator|.
name|YES
argument_list|)
argument_list|)
expr_stmt|;
name|modifier
operator|.
name|addDocument
argument_list|(
name|doc
argument_list|)
expr_stmt|;
block|}
name|modifier
operator|.
name|forceMerge
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|modifier
operator|.
name|commit
argument_list|()
expr_stmt|;
name|Term
name|term
init|=
operator|new
name|Term
argument_list|(
literal|"city"
argument_list|,
literal|"Amsterdam"
argument_list|)
decl_stmt|;
name|int
name|hitCount
init|=
name|getHitCount
argument_list|(
name|dir
argument_list|,
name|term
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|hitCount
argument_list|)
expr_stmt|;
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"\nTEST: now delete by term="
operator|+
name|term
argument_list|)
expr_stmt|;
block|}
name|modifier
operator|.
name|deleteDocuments
argument_list|(
name|term
argument_list|)
expr_stmt|;
name|modifier
operator|.
name|commit
argument_list|()
expr_stmt|;
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"\nTEST: now getHitCount"
argument_list|)
expr_stmt|;
block|}
name|hitCount
operator|=
name|getHitCount
argument_list|(
name|dir
argument_list|,
name|term
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|hitCount
argument_list|)
expr_stmt|;
name|modifier
operator|.
name|close
argument_list|()
expr_stmt|;
name|dir
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
comment|// test when delete terms only apply to disk segments
DECL|method|testNonRAMDelete
specifier|public
name|void
name|testNonRAMDelete
parameter_list|()
throws|throws
name|IOException
block|{
name|Directory
name|dir
init|=
name|newDirectory
argument_list|()
decl_stmt|;
name|IndexWriter
name|modifier
init|=
operator|new
name|IndexWriter
argument_list|(
name|dir
argument_list|,
name|newIndexWriterConfig
argument_list|(
name|TEST_VERSION_CURRENT
argument_list|,
operator|new
name|MockAnalyzer
argument_list|(
name|random
argument_list|()
argument_list|,
name|MockTokenizer
operator|.
name|WHITESPACE
argument_list|,
literal|false
argument_list|)
argument_list|)
operator|.
name|setMaxBufferedDocs
argument_list|(
literal|2
argument_list|)
operator|.
name|setMaxBufferedDeleteTerms
argument_list|(
literal|2
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|id
init|=
literal|0
decl_stmt|;
name|int
name|value
init|=
literal|100
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|7
condition|;
name|i
operator|++
control|)
block|{
name|addDoc
argument_list|(
name|modifier
argument_list|,
operator|++
name|id
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
name|modifier
operator|.
name|commit
argument_list|()
expr_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|modifier
operator|.
name|getNumBufferedDocuments
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|0
operator|<
name|modifier
operator|.
name|getSegmentCount
argument_list|()
argument_list|)
expr_stmt|;
name|modifier
operator|.
name|commit
argument_list|()
expr_stmt|;
name|IndexReader
name|reader
init|=
name|DirectoryReader
operator|.
name|open
argument_list|(
name|dir
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|7
argument_list|,
name|reader
operator|.
name|numDocs
argument_list|()
argument_list|)
expr_stmt|;
name|reader
operator|.
name|close
argument_list|()
expr_stmt|;
name|modifier
operator|.
name|deleteDocuments
argument_list|(
operator|new
name|Term
argument_list|(
literal|"value"
argument_list|,
name|String
operator|.
name|valueOf
argument_list|(
name|value
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|modifier
operator|.
name|commit
argument_list|()
expr_stmt|;
name|reader
operator|=
name|DirectoryReader
operator|.
name|open
argument_list|(
name|dir
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|reader
operator|.
name|numDocs
argument_list|()
argument_list|)
expr_stmt|;
name|reader
operator|.
name|close
argument_list|()
expr_stmt|;
name|modifier
operator|.
name|close
argument_list|()
expr_stmt|;
name|dir
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
DECL|method|testMaxBufferedDeletes
specifier|public
name|void
name|testMaxBufferedDeletes
parameter_list|()
throws|throws
name|IOException
block|{
name|Directory
name|dir
init|=
name|newDirectory
argument_list|()
decl_stmt|;
name|IndexWriter
name|writer
init|=
operator|new
name|IndexWriter
argument_list|(
name|dir
argument_list|,
name|newIndexWriterConfig
argument_list|(
name|TEST_VERSION_CURRENT
argument_list|,
operator|new
name|MockAnalyzer
argument_list|(
name|random
argument_list|()
argument_list|,
name|MockTokenizer
operator|.
name|WHITESPACE
argument_list|,
literal|false
argument_list|)
argument_list|)
operator|.
name|setMaxBufferedDeleteTerms
argument_list|(
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|writer
operator|.
name|addDocument
argument_list|(
operator|new
name|Document
argument_list|()
argument_list|)
expr_stmt|;
name|writer
operator|.
name|deleteDocuments
argument_list|(
operator|new
name|Term
argument_list|(
literal|"foobar"
argument_list|,
literal|"1"
argument_list|)
argument_list|)
expr_stmt|;
name|writer
operator|.
name|deleteDocuments
argument_list|(
operator|new
name|Term
argument_list|(
literal|"foobar"
argument_list|,
literal|"1"
argument_list|)
argument_list|)
expr_stmt|;
name|writer
operator|.
name|deleteDocuments
argument_list|(
operator|new
name|Term
argument_list|(
literal|"foobar"
argument_list|,
literal|"1"
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|3
argument_list|,
name|writer
operator|.
name|getFlushDeletesCount
argument_list|()
argument_list|)
expr_stmt|;
name|writer
operator|.
name|close
argument_list|()
expr_stmt|;
name|dir
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
comment|// test when delete terms only apply to ram segments
DECL|method|testRAMDeletes
specifier|public
name|void
name|testRAMDeletes
parameter_list|()
throws|throws
name|IOException
block|{
for|for
control|(
name|int
name|t
init|=
literal|0
init|;
name|t
operator|<
literal|2
condition|;
name|t
operator|++
control|)
block|{
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"TEST: t="
operator|+
name|t
argument_list|)
expr_stmt|;
block|}
name|Directory
name|dir
init|=
name|newDirectory
argument_list|()
decl_stmt|;
name|IndexWriter
name|modifier
init|=
operator|new
name|IndexWriter
argument_list|(
name|dir
argument_list|,
name|newIndexWriterConfig
argument_list|(
name|TEST_VERSION_CURRENT
argument_list|,
operator|new
name|MockAnalyzer
argument_list|(
name|random
argument_list|()
argument_list|,
name|MockTokenizer
operator|.
name|WHITESPACE
argument_list|,
literal|false
argument_list|)
argument_list|)
operator|.
name|setMaxBufferedDocs
argument_list|(
literal|4
argument_list|)
operator|.
name|setMaxBufferedDeleteTerms
argument_list|(
literal|4
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|id
init|=
literal|0
decl_stmt|;
name|int
name|value
init|=
literal|100
decl_stmt|;
name|addDoc
argument_list|(
name|modifier
argument_list|,
operator|++
name|id
argument_list|,
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|==
name|t
condition|)
name|modifier
operator|.
name|deleteDocuments
argument_list|(
operator|new
name|Term
argument_list|(
literal|"value"
argument_list|,
name|String
operator|.
name|valueOf
argument_list|(
name|value
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|modifier
operator|.
name|deleteDocuments
argument_list|(
operator|new
name|TermQuery
argument_list|(
operator|new
name|Term
argument_list|(
literal|"value"
argument_list|,
name|String
operator|.
name|valueOf
argument_list|(
name|value
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|addDoc
argument_list|(
name|modifier
argument_list|,
operator|++
name|id
argument_list|,
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|==
name|t
condition|)
block|{
name|modifier
operator|.
name|deleteDocuments
argument_list|(
operator|new
name|Term
argument_list|(
literal|"value"
argument_list|,
name|String
operator|.
name|valueOf
argument_list|(
name|value
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|2
argument_list|,
name|modifier
operator|.
name|getNumBufferedDeleteTerms
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|modifier
operator|.
name|getBufferedDeleteTermsSize
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
name|modifier
operator|.
name|deleteDocuments
argument_list|(
operator|new
name|TermQuery
argument_list|(
operator|new
name|Term
argument_list|(
literal|"value"
argument_list|,
name|String
operator|.
name|valueOf
argument_list|(
name|value
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|addDoc
argument_list|(
name|modifier
argument_list|,
operator|++
name|id
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|modifier
operator|.
name|getSegmentCount
argument_list|()
argument_list|)
expr_stmt|;
name|modifier
operator|.
name|commit
argument_list|()
expr_stmt|;
name|IndexReader
name|reader
init|=
name|DirectoryReader
operator|.
name|open
argument_list|(
name|dir
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|reader
operator|.
name|numDocs
argument_list|()
argument_list|)
expr_stmt|;
name|int
name|hitCount
init|=
name|getHitCount
argument_list|(
name|dir
argument_list|,
operator|new
name|Term
argument_list|(
literal|"id"
argument_list|,
name|String
operator|.
name|valueOf
argument_list|(
name|id
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|hitCount
argument_list|)
expr_stmt|;
name|reader
operator|.
name|close
argument_list|()
expr_stmt|;
name|modifier
operator|.
name|close
argument_list|()
expr_stmt|;
name|dir
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
comment|// test when delete terms apply to both disk and ram segments
DECL|method|testBothDeletes
specifier|public
name|void
name|testBothDeletes
parameter_list|()
throws|throws
name|IOException
block|{
name|Directory
name|dir
init|=
name|newDirectory
argument_list|()
decl_stmt|;
name|IndexWriter
name|modifier
init|=
operator|new
name|IndexWriter
argument_list|(
name|dir
argument_list|,
name|newIndexWriterConfig
argument_list|(
name|TEST_VERSION_CURRENT
argument_list|,
operator|new
name|MockAnalyzer
argument_list|(
name|random
argument_list|()
argument_list|,
name|MockTokenizer
operator|.
name|WHITESPACE
argument_list|,
literal|false
argument_list|)
argument_list|)
operator|.
name|setMaxBufferedDocs
argument_list|(
literal|100
argument_list|)
operator|.
name|setMaxBufferedDeleteTerms
argument_list|(
literal|100
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|id
init|=
literal|0
decl_stmt|;
name|int
name|value
init|=
literal|100
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|5
condition|;
name|i
operator|++
control|)
block|{
name|addDoc
argument_list|(
name|modifier
argument_list|,
operator|++
name|id
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
name|value
operator|=
literal|200
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|5
condition|;
name|i
operator|++
control|)
block|{
name|addDoc
argument_list|(
name|modifier
argument_list|,
operator|++
name|id
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
name|modifier
operator|.
name|commit
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|5
condition|;
name|i
operator|++
control|)
block|{
name|addDoc
argument_list|(
name|modifier
argument_list|,
operator|++
name|id
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
name|modifier
operator|.
name|deleteDocuments
argument_list|(
operator|new
name|Term
argument_list|(
literal|"value"
argument_list|,
name|String
operator|.
name|valueOf
argument_list|(
name|value
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|modifier
operator|.
name|commit
argument_list|()
expr_stmt|;
name|IndexReader
name|reader
init|=
name|DirectoryReader
operator|.
name|open
argument_list|(
name|dir
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|5
argument_list|,
name|reader
operator|.
name|numDocs
argument_list|()
argument_list|)
expr_stmt|;
name|modifier
operator|.
name|close
argument_list|()
expr_stmt|;
name|reader
operator|.
name|close
argument_list|()
expr_stmt|;
name|dir
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
comment|// test that batched delete terms are flushed together
DECL|method|testBatchDeletes
specifier|public
name|void
name|testBatchDeletes
parameter_list|()
throws|throws
name|IOException
block|{
name|Directory
name|dir
init|=
name|newDirectory
argument_list|()
decl_stmt|;
name|IndexWriter
name|modifier
init|=
operator|new
name|IndexWriter
argument_list|(
name|dir
argument_list|,
name|newIndexWriterConfig
argument_list|(
name|TEST_VERSION_CURRENT
argument_list|,
operator|new
name|MockAnalyzer
argument_list|(
name|random
argument_list|()
argument_list|,
name|MockTokenizer
operator|.
name|WHITESPACE
argument_list|,
literal|false
argument_list|)
argument_list|)
operator|.
name|setMaxBufferedDocs
argument_list|(
literal|2
argument_list|)
operator|.
name|setMaxBufferedDeleteTerms
argument_list|(
literal|2
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|id
init|=
literal|0
decl_stmt|;
name|int
name|value
init|=
literal|100
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|7
condition|;
name|i
operator|++
control|)
block|{
name|addDoc
argument_list|(
name|modifier
argument_list|,
operator|++
name|id
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
name|modifier
operator|.
name|commit
argument_list|()
expr_stmt|;
name|IndexReader
name|reader
init|=
name|DirectoryReader
operator|.
name|open
argument_list|(
name|dir
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|7
argument_list|,
name|reader
operator|.
name|numDocs
argument_list|()
argument_list|)
expr_stmt|;
name|reader
operator|.
name|close
argument_list|()
expr_stmt|;
name|id
operator|=
literal|0
expr_stmt|;
name|modifier
operator|.
name|deleteDocuments
argument_list|(
operator|new
name|Term
argument_list|(
literal|"id"
argument_list|,
name|String
operator|.
name|valueOf
argument_list|(
operator|++
name|id
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|modifier
operator|.
name|deleteDocuments
argument_list|(
operator|new
name|Term
argument_list|(
literal|"id"
argument_list|,
name|String
operator|.
name|valueOf
argument_list|(
operator|++
name|id
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|modifier
operator|.
name|commit
argument_list|()
expr_stmt|;
name|reader
operator|=
name|DirectoryReader
operator|.
name|open
argument_list|(
name|dir
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|5
argument_list|,
name|reader
operator|.
name|numDocs
argument_list|()
argument_list|)
expr_stmt|;
name|reader
operator|.
name|close
argument_list|()
expr_stmt|;
name|Term
index|[]
name|terms
init|=
operator|new
name|Term
index|[
literal|3
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|terms
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|terms
index|[
name|i
index|]
operator|=
operator|new
name|Term
argument_list|(
literal|"id"
argument_list|,
name|String
operator|.
name|valueOf
argument_list|(
operator|++
name|id
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|modifier
operator|.
name|deleteDocuments
argument_list|(
name|terms
argument_list|)
expr_stmt|;
name|modifier
operator|.
name|commit
argument_list|()
expr_stmt|;
name|reader
operator|=
name|DirectoryReader
operator|.
name|open
argument_list|(
name|dir
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|2
argument_list|,
name|reader
operator|.
name|numDocs
argument_list|()
argument_list|)
expr_stmt|;
name|reader
operator|.
name|close
argument_list|()
expr_stmt|;
name|modifier
operator|.
name|close
argument_list|()
expr_stmt|;
name|dir
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
comment|// test deleteAll()
DECL|method|testDeleteAll
specifier|public
name|void
name|testDeleteAll
parameter_list|()
throws|throws
name|IOException
block|{
name|Directory
name|dir
init|=
name|newDirectory
argument_list|()
decl_stmt|;
name|IndexWriter
name|modifier
init|=
operator|new
name|IndexWriter
argument_list|(
name|dir
argument_list|,
name|newIndexWriterConfig
argument_list|(
name|TEST_VERSION_CURRENT
argument_list|,
operator|new
name|MockAnalyzer
argument_list|(
name|random
argument_list|()
argument_list|,
name|MockTokenizer
operator|.
name|WHITESPACE
argument_list|,
literal|false
argument_list|)
argument_list|)
operator|.
name|setMaxBufferedDocs
argument_list|(
literal|2
argument_list|)
operator|.
name|setMaxBufferedDeleteTerms
argument_list|(
literal|2
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|id
init|=
literal|0
decl_stmt|;
name|int
name|value
init|=
literal|100
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|7
condition|;
name|i
operator|++
control|)
block|{
name|addDoc
argument_list|(
name|modifier
argument_list|,
operator|++
name|id
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
name|modifier
operator|.
name|commit
argument_list|()
expr_stmt|;
name|IndexReader
name|reader
init|=
name|DirectoryReader
operator|.
name|open
argument_list|(
name|dir
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|7
argument_list|,
name|reader
operator|.
name|numDocs
argument_list|()
argument_list|)
expr_stmt|;
name|reader
operator|.
name|close
argument_list|()
expr_stmt|;
comment|// Add 1 doc (so we will have something buffered)
name|addDoc
argument_list|(
name|modifier
argument_list|,
literal|99
argument_list|,
name|value
argument_list|)
expr_stmt|;
comment|// Delete all
name|modifier
operator|.
name|deleteAll
argument_list|()
expr_stmt|;
comment|// Delete all shouldn't be on disk yet
name|reader
operator|=
name|DirectoryReader
operator|.
name|open
argument_list|(
name|dir
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|7
argument_list|,
name|reader
operator|.
name|numDocs
argument_list|()
argument_list|)
expr_stmt|;
name|reader
operator|.
name|close
argument_list|()
expr_stmt|;
comment|// Add a doc and update a doc (after the deleteAll, before the commit)
name|addDoc
argument_list|(
name|modifier
argument_list|,
literal|101
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|updateDoc
argument_list|(
name|modifier
argument_list|,
literal|102
argument_list|,
name|value
argument_list|)
expr_stmt|;
comment|// commit the delete all
name|modifier
operator|.
name|commit
argument_list|()
expr_stmt|;
comment|// Validate there are no docs left
name|reader
operator|=
name|DirectoryReader
operator|.
name|open
argument_list|(
name|dir
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|2
argument_list|,
name|reader
operator|.
name|numDocs
argument_list|()
argument_list|)
expr_stmt|;
name|reader
operator|.
name|close
argument_list|()
expr_stmt|;
name|modifier
operator|.
name|close
argument_list|()
expr_stmt|;
name|dir
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
DECL|method|testDeleteAllNoDeadLock
specifier|public
name|void
name|testDeleteAllNoDeadLock
parameter_list|()
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|Directory
name|dir
init|=
name|newDirectory
argument_list|()
decl_stmt|;
specifier|final
name|RandomIndexWriter
name|modifier
init|=
operator|new
name|RandomIndexWriter
argument_list|(
name|random
argument_list|()
argument_list|,
name|dir
argument_list|)
decl_stmt|;
name|int
name|numThreads
init|=
name|atLeast
argument_list|(
literal|2
argument_list|)
decl_stmt|;
name|Thread
index|[]
name|threads
init|=
operator|new
name|Thread
index|[
name|numThreads
index|]
decl_stmt|;
specifier|final
name|CountDownLatch
name|latch
init|=
operator|new
name|CountDownLatch
argument_list|(
literal|1
argument_list|)
decl_stmt|;
specifier|final
name|CountDownLatch
name|doneLatch
init|=
operator|new
name|CountDownLatch
argument_list|(
name|numThreads
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numThreads
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|int
name|offset
init|=
name|i
decl_stmt|;
name|threads
index|[
name|i
index|]
operator|=
operator|new
name|Thread
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
name|int
name|id
init|=
name|offset
operator|*
literal|1000
decl_stmt|;
name|int
name|value
init|=
literal|100
decl_stmt|;
try|try
block|{
name|latch
operator|.
name|await
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|1000
condition|;
name|i
operator|++
control|)
block|{
name|Document
name|doc
init|=
operator|new
name|Document
argument_list|()
decl_stmt|;
name|doc
operator|.
name|add
argument_list|(
name|newTextField
argument_list|(
literal|"content"
argument_list|,
literal|"aaa"
argument_list|,
name|Field
operator|.
name|Store
operator|.
name|NO
argument_list|)
argument_list|)
expr_stmt|;
name|doc
operator|.
name|add
argument_list|(
name|newStringField
argument_list|(
literal|"id"
argument_list|,
name|String
operator|.
name|valueOf
argument_list|(
name|id
operator|++
argument_list|)
argument_list|,
name|Field
operator|.
name|Store
operator|.
name|YES
argument_list|)
argument_list|)
expr_stmt|;
name|doc
operator|.
name|add
argument_list|(
name|newStringField
argument_list|(
literal|"value"
argument_list|,
name|String
operator|.
name|valueOf
argument_list|(
name|value
argument_list|)
argument_list|,
name|Field
operator|.
name|Store
operator|.
name|NO
argument_list|)
argument_list|)
expr_stmt|;
name|doc
operator|.
name|add
argument_list|(
operator|new
name|NumericDocValuesField
argument_list|(
literal|"dv"
argument_list|,
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|modifier
operator|.
name|addDocument
argument_list|(
name|doc
argument_list|)
expr_stmt|;
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"\tThread["
operator|+
name|offset
operator|+
literal|"]: add doc: "
operator|+
name|id
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
finally|finally
block|{
name|doneLatch
operator|.
name|countDown
argument_list|()
expr_stmt|;
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"\tThread["
operator|+
name|offset
operator|+
literal|"]: done indexing"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
expr_stmt|;
name|threads
index|[
name|i
index|]
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
name|latch
operator|.
name|countDown
argument_list|()
expr_stmt|;
while|while
condition|(
operator|!
name|doneLatch
operator|.
name|await
argument_list|(
literal|1
argument_list|,
name|TimeUnit
operator|.
name|MILLISECONDS
argument_list|)
condition|)
block|{
name|modifier
operator|.
name|deleteAll
argument_list|()
expr_stmt|;
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"del all"
argument_list|)
expr_stmt|;
block|}
block|}
name|modifier
operator|.
name|deleteAll
argument_list|()
expr_stmt|;
for|for
control|(
name|Thread
name|thread
range|:
name|threads
control|)
block|{
name|thread
operator|.
name|join
argument_list|()
expr_stmt|;
block|}
name|modifier
operator|.
name|close
argument_list|()
expr_stmt|;
name|DirectoryReader
name|reader
init|=
name|DirectoryReader
operator|.
name|open
argument_list|(
name|dir
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|reader
operator|.
name|maxDoc
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|reader
operator|.
name|numDocs
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|reader
operator|.
name|numDeletedDocs
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|reader
operator|.
name|close
argument_list|()
expr_stmt|;
name|dir
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
comment|// test rollback of deleteAll()
DECL|method|testDeleteAllRollback
specifier|public
name|void
name|testDeleteAllRollback
parameter_list|()
throws|throws
name|IOException
block|{
name|Directory
name|dir
init|=
name|newDirectory
argument_list|()
decl_stmt|;
name|IndexWriter
name|modifier
init|=
operator|new
name|IndexWriter
argument_list|(
name|dir
argument_list|,
name|newIndexWriterConfig
argument_list|(
name|TEST_VERSION_CURRENT
argument_list|,
operator|new
name|MockAnalyzer
argument_list|(
name|random
argument_list|()
argument_list|,
name|MockTokenizer
operator|.
name|WHITESPACE
argument_list|,
literal|false
argument_list|)
argument_list|)
operator|.
name|setMaxBufferedDocs
argument_list|(
literal|2
argument_list|)
operator|.
name|setMaxBufferedDeleteTerms
argument_list|(
literal|2
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|id
init|=
literal|0
decl_stmt|;
name|int
name|value
init|=
literal|100
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|7
condition|;
name|i
operator|++
control|)
block|{
name|addDoc
argument_list|(
name|modifier
argument_list|,
operator|++
name|id
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
name|modifier
operator|.
name|commit
argument_list|()
expr_stmt|;
name|addDoc
argument_list|(
name|modifier
argument_list|,
operator|++
name|id
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|IndexReader
name|reader
init|=
name|DirectoryReader
operator|.
name|open
argument_list|(
name|dir
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|7
argument_list|,
name|reader
operator|.
name|numDocs
argument_list|()
argument_list|)
expr_stmt|;
name|reader
operator|.
name|close
argument_list|()
expr_stmt|;
comment|// Delete all
name|modifier
operator|.
name|deleteAll
argument_list|()
expr_stmt|;
comment|// Roll it back
name|modifier
operator|.
name|rollback
argument_list|()
expr_stmt|;
name|modifier
operator|.
name|close
argument_list|()
expr_stmt|;
comment|// Validate that the docs are still there
name|reader
operator|=
name|DirectoryReader
operator|.
name|open
argument_list|(
name|dir
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|7
argument_list|,
name|reader
operator|.
name|numDocs
argument_list|()
argument_list|)
expr_stmt|;
name|reader
operator|.
name|close
argument_list|()
expr_stmt|;
name|dir
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
comment|// test deleteAll() w/ near real-time reader
DECL|method|testDeleteAllNRT
specifier|public
name|void
name|testDeleteAllNRT
parameter_list|()
throws|throws
name|IOException
block|{
name|Directory
name|dir
init|=
name|newDirectory
argument_list|()
decl_stmt|;
name|IndexWriter
name|modifier
init|=
operator|new
name|IndexWriter
argument_list|(
name|dir
argument_list|,
name|newIndexWriterConfig
argument_list|(
name|TEST_VERSION_CURRENT
argument_list|,
operator|new
name|MockAnalyzer
argument_list|(
name|random
argument_list|()
argument_list|,
name|MockTokenizer
operator|.
name|WHITESPACE
argument_list|,
literal|false
argument_list|)
argument_list|)
operator|.
name|setMaxBufferedDocs
argument_list|(
literal|2
argument_list|)
operator|.
name|setMaxBufferedDeleteTerms
argument_list|(
literal|2
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|id
init|=
literal|0
decl_stmt|;
name|int
name|value
init|=
literal|100
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|7
condition|;
name|i
operator|++
control|)
block|{
name|addDoc
argument_list|(
name|modifier
argument_list|,
operator|++
name|id
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
name|modifier
operator|.
name|commit
argument_list|()
expr_stmt|;
name|IndexReader
name|reader
init|=
name|modifier
operator|.
name|getReader
argument_list|()
decl_stmt|;
name|assertEquals
argument_list|(
literal|7
argument_list|,
name|reader
operator|.
name|numDocs
argument_list|()
argument_list|)
expr_stmt|;
name|reader
operator|.
name|close
argument_list|()
expr_stmt|;
name|addDoc
argument_list|(
name|modifier
argument_list|,
operator|++
name|id
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|addDoc
argument_list|(
name|modifier
argument_list|,
operator|++
name|id
argument_list|,
name|value
argument_list|)
expr_stmt|;
comment|// Delete all
name|modifier
operator|.
name|deleteAll
argument_list|()
expr_stmt|;
name|reader
operator|=
name|modifier
operator|.
name|getReader
argument_list|()
expr_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|reader
operator|.
name|numDocs
argument_list|()
argument_list|)
expr_stmt|;
name|reader
operator|.
name|close
argument_list|()
expr_stmt|;
comment|// Roll it back
name|modifier
operator|.
name|rollback
argument_list|()
expr_stmt|;
name|modifier
operator|.
name|close
argument_list|()
expr_stmt|;
comment|// Validate that the docs are still there
name|reader
operator|=
name|DirectoryReader
operator|.
name|open
argument_list|(
name|dir
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|7
argument_list|,
name|reader
operator|.
name|numDocs
argument_list|()
argument_list|)
expr_stmt|;
name|reader
operator|.
name|close
argument_list|()
expr_stmt|;
name|dir
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
DECL|method|updateDoc
specifier|private
name|void
name|updateDoc
parameter_list|(
name|IndexWriter
name|modifier
parameter_list|,
name|int
name|id
parameter_list|,
name|int
name|value
parameter_list|)
throws|throws
name|IOException
block|{
name|Document
name|doc
init|=
operator|new
name|Document
argument_list|()
decl_stmt|;
name|doc
operator|.
name|add
argument_list|(
name|newTextField
argument_list|(
literal|"content"
argument_list|,
literal|"aaa"
argument_list|,
name|Field
operator|.
name|Store
operator|.
name|NO
argument_list|)
argument_list|)
expr_stmt|;
name|doc
operator|.
name|add
argument_list|(
name|newStringField
argument_list|(
literal|"id"
argument_list|,
name|String
operator|.
name|valueOf
argument_list|(
name|id
argument_list|)
argument_list|,
name|Field
operator|.
name|Store
operator|.
name|YES
argument_list|)
argument_list|)
expr_stmt|;
name|doc
operator|.
name|add
argument_list|(
name|newStringField
argument_list|(
literal|"value"
argument_list|,
name|String
operator|.
name|valueOf
argument_list|(
name|value
argument_list|)
argument_list|,
name|Field
operator|.
name|Store
operator|.
name|NO
argument_list|)
argument_list|)
expr_stmt|;
name|doc
operator|.
name|add
argument_list|(
operator|new
name|NumericDocValuesField
argument_list|(
literal|"dv"
argument_list|,
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|modifier
operator|.
name|updateDocument
argument_list|(
operator|new
name|Term
argument_list|(
literal|"id"
argument_list|,
name|String
operator|.
name|valueOf
argument_list|(
name|id
argument_list|)
argument_list|)
argument_list|,
name|doc
argument_list|)
expr_stmt|;
block|}
DECL|method|addDoc
specifier|private
name|void
name|addDoc
parameter_list|(
name|IndexWriter
name|modifier
parameter_list|,
name|int
name|id
parameter_list|,
name|int
name|value
parameter_list|)
throws|throws
name|IOException
block|{
name|Document
name|doc
init|=
operator|new
name|Document
argument_list|()
decl_stmt|;
name|doc
operator|.
name|add
argument_list|(
name|newTextField
argument_list|(
literal|"content"
argument_list|,
literal|"aaa"
argument_list|,
name|Field
operator|.
name|Store
operator|.
name|NO
argument_list|)
argument_list|)
expr_stmt|;
name|doc
operator|.
name|add
argument_list|(
name|newStringField
argument_list|(
literal|"id"
argument_list|,
name|String
operator|.
name|valueOf
argument_list|(
name|id
argument_list|)
argument_list|,
name|Field
operator|.
name|Store
operator|.
name|YES
argument_list|)
argument_list|)
expr_stmt|;
name|doc
operator|.
name|add
argument_list|(
name|newStringField
argument_list|(
literal|"value"
argument_list|,
name|String
operator|.
name|valueOf
argument_list|(
name|value
argument_list|)
argument_list|,
name|Field
operator|.
name|Store
operator|.
name|NO
argument_list|)
argument_list|)
expr_stmt|;
name|doc
operator|.
name|add
argument_list|(
operator|new
name|NumericDocValuesField
argument_list|(
literal|"dv"
argument_list|,
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|modifier
operator|.
name|addDocument
argument_list|(
name|doc
argument_list|)
expr_stmt|;
block|}
DECL|method|getHitCount
specifier|private
name|int
name|getHitCount
parameter_list|(
name|Directory
name|dir
parameter_list|,
name|Term
name|term
parameter_list|)
throws|throws
name|IOException
block|{
name|IndexReader
name|reader
init|=
name|DirectoryReader
operator|.
name|open
argument_list|(
name|dir
argument_list|)
decl_stmt|;
name|IndexSearcher
name|searcher
init|=
name|newSearcher
argument_list|(
name|reader
argument_list|)
decl_stmt|;
name|int
name|hitCount
init|=
name|searcher
operator|.
name|search
argument_list|(
operator|new
name|TermQuery
argument_list|(
name|term
argument_list|)
argument_list|,
literal|null
argument_list|,
literal|1000
argument_list|)
operator|.
name|totalHits
decl_stmt|;
name|reader
operator|.
name|close
argument_list|()
expr_stmt|;
return|return
name|hitCount
return|;
block|}
DECL|method|testDeletesOnDiskFull
specifier|public
name|void
name|testDeletesOnDiskFull
parameter_list|()
throws|throws
name|IOException
block|{
name|doTestOperationsOnDiskFull
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
DECL|method|testUpdatesOnDiskFull
specifier|public
name|void
name|testUpdatesOnDiskFull
parameter_list|()
throws|throws
name|IOException
block|{
name|doTestOperationsOnDiskFull
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
comment|/**    * Make sure if modifier tries to commit but hits disk full that modifier    * remains consistent and usable. Similar to TestIndexReader.testDiskFull().    */
DECL|method|doTestOperationsOnDiskFull
specifier|private
name|void
name|doTestOperationsOnDiskFull
parameter_list|(
name|boolean
name|updates
parameter_list|)
throws|throws
name|IOException
block|{
name|Term
name|searchTerm
init|=
operator|new
name|Term
argument_list|(
literal|"content"
argument_list|,
literal|"aaa"
argument_list|)
decl_stmt|;
name|int
name|START_COUNT
init|=
literal|157
decl_stmt|;
name|int
name|END_COUNT
init|=
literal|144
decl_stmt|;
comment|// First build up a starting index:
name|MockDirectoryWrapper
name|startDir
init|=
name|newMockDirectory
argument_list|()
decl_stmt|;
comment|// TODO: find the resource leak that only occurs sometimes here.
name|startDir
operator|.
name|setNoDeleteOpenFile
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|IndexWriter
name|writer
init|=
operator|new
name|IndexWriter
argument_list|(
name|startDir
argument_list|,
name|newIndexWriterConfig
argument_list|(
name|TEST_VERSION_CURRENT
argument_list|,
operator|new
name|MockAnalyzer
argument_list|(
name|random
argument_list|()
argument_list|,
name|MockTokenizer
operator|.
name|WHITESPACE
argument_list|,
literal|false
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|157
condition|;
name|i
operator|++
control|)
block|{
name|Document
name|d
init|=
operator|new
name|Document
argument_list|()
decl_stmt|;
name|d
operator|.
name|add
argument_list|(
name|newStringField
argument_list|(
literal|"id"
argument_list|,
name|Integer
operator|.
name|toString
argument_list|(
name|i
argument_list|)
argument_list|,
name|Field
operator|.
name|Store
operator|.
name|YES
argument_list|)
argument_list|)
expr_stmt|;
name|d
operator|.
name|add
argument_list|(
name|newTextField
argument_list|(
literal|"content"
argument_list|,
literal|"aaa "
operator|+
name|i
argument_list|,
name|Field
operator|.
name|Store
operator|.
name|NO
argument_list|)
argument_list|)
expr_stmt|;
name|d
operator|.
name|add
argument_list|(
operator|new
name|NumericDocValuesField
argument_list|(
literal|"dv"
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|writer
operator|.
name|addDocument
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
name|writer
operator|.
name|close
argument_list|()
expr_stmt|;
name|long
name|diskUsage
init|=
name|startDir
operator|.
name|sizeInBytes
argument_list|()
decl_stmt|;
name|long
name|diskFree
init|=
name|diskUsage
operator|+
literal|10
decl_stmt|;
name|IOException
name|err
init|=
literal|null
decl_stmt|;
name|boolean
name|done
init|=
literal|false
decl_stmt|;
comment|// Iterate w/ ever increasing free disk space:
while|while
condition|(
operator|!
name|done
condition|)
block|{
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"TEST: cycle"
argument_list|)
expr_stmt|;
block|}
name|MockDirectoryWrapper
name|dir
init|=
operator|new
name|MockDirectoryWrapper
argument_list|(
name|random
argument_list|()
argument_list|,
operator|new
name|RAMDirectory
argument_list|(
name|startDir
argument_list|,
name|newIOContext
argument_list|(
name|random
argument_list|()
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|dir
operator|.
name|setPreventDoubleWrite
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|IndexWriter
name|modifier
init|=
operator|new
name|IndexWriter
argument_list|(
name|dir
argument_list|,
name|newIndexWriterConfig
argument_list|(
name|TEST_VERSION_CURRENT
argument_list|,
operator|new
name|MockAnalyzer
argument_list|(
name|random
argument_list|()
argument_list|,
name|MockTokenizer
operator|.
name|WHITESPACE
argument_list|,
literal|false
argument_list|)
argument_list|)
operator|.
name|setMaxBufferedDocs
argument_list|(
literal|1000
argument_list|)
operator|.
name|setMaxBufferedDeleteTerms
argument_list|(
literal|1000
argument_list|)
operator|.
name|setMergeScheduler
argument_list|(
operator|new
name|ConcurrentMergeScheduler
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
operator|(
operator|(
name|ConcurrentMergeScheduler
operator|)
name|modifier
operator|.
name|getConfig
argument_list|()
operator|.
name|getMergeScheduler
argument_list|()
operator|)
operator|.
name|setSuppressExceptions
argument_list|()
expr_stmt|;
comment|// For each disk size, first try to commit against
comment|// dir that will hit random IOExceptions& disk
comment|// full; after, give it infinite disk space& turn
comment|// off random IOExceptions& retry w/ same reader:
name|boolean
name|success
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|x
init|=
literal|0
init|;
name|x
operator|<
literal|2
condition|;
name|x
operator|++
control|)
block|{
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"TEST: x="
operator|+
name|x
argument_list|)
expr_stmt|;
block|}
name|double
name|rate
init|=
literal|0.1
decl_stmt|;
name|double
name|diskRatio
init|=
operator|(
operator|(
name|double
operator|)
name|diskFree
operator|)
operator|/
name|diskUsage
decl_stmt|;
name|long
name|thisDiskFree
decl_stmt|;
name|String
name|testName
decl_stmt|;
if|if
condition|(
literal|0
operator|==
name|x
condition|)
block|{
name|thisDiskFree
operator|=
name|diskFree
expr_stmt|;
if|if
condition|(
name|diskRatio
operator|>=
literal|2.0
condition|)
block|{
name|rate
operator|/=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|diskRatio
operator|>=
literal|4.0
condition|)
block|{
name|rate
operator|/=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|diskRatio
operator|>=
literal|6.0
condition|)
block|{
name|rate
operator|=
literal|0.0
expr_stmt|;
block|}
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"\ncycle: "
operator|+
name|diskFree
operator|+
literal|" bytes"
argument_list|)
expr_stmt|;
block|}
name|testName
operator|=
literal|"disk full during reader.close() @ "
operator|+
name|thisDiskFree
operator|+
literal|" bytes"
expr_stmt|;
name|dir
operator|.
name|setRandomIOExceptionRateOnOpen
argument_list|(
name|random
argument_list|()
operator|.
name|nextDouble
argument_list|()
operator|*
literal|0.01
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|thisDiskFree
operator|=
literal|0
expr_stmt|;
name|rate
operator|=
literal|0.0
expr_stmt|;
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"\ncycle: same writer: unlimited disk space"
argument_list|)
expr_stmt|;
block|}
name|testName
operator|=
literal|"reader re-use after disk full"
expr_stmt|;
name|dir
operator|.
name|setRandomIOExceptionRateOnOpen
argument_list|(
literal|0.0
argument_list|)
expr_stmt|;
block|}
name|dir
operator|.
name|setMaxSizeInBytes
argument_list|(
name|thisDiskFree
argument_list|)
expr_stmt|;
name|dir
operator|.
name|setRandomIOExceptionRate
argument_list|(
name|rate
argument_list|)
expr_stmt|;
try|try
block|{
if|if
condition|(
literal|0
operator|==
name|x
condition|)
block|{
name|int
name|docId
init|=
literal|12
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|13
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|updates
condition|)
block|{
name|Document
name|d
init|=
operator|new
name|Document
argument_list|()
decl_stmt|;
name|d
operator|.
name|add
argument_list|(
name|newStringField
argument_list|(
literal|"id"
argument_list|,
name|Integer
operator|.
name|toString
argument_list|(
name|i
argument_list|)
argument_list|,
name|Field
operator|.
name|Store
operator|.
name|YES
argument_list|)
argument_list|)
expr_stmt|;
name|d
operator|.
name|add
argument_list|(
name|newTextField
argument_list|(
literal|"content"
argument_list|,
literal|"bbb "
operator|+
name|i
argument_list|,
name|Field
operator|.
name|Store
operator|.
name|NO
argument_list|)
argument_list|)
expr_stmt|;
name|d
operator|.
name|add
argument_list|(
operator|new
name|NumericDocValuesField
argument_list|(
literal|"dv"
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|modifier
operator|.
name|updateDocument
argument_list|(
operator|new
name|Term
argument_list|(
literal|"id"
argument_list|,
name|Integer
operator|.
name|toString
argument_list|(
name|docId
argument_list|)
argument_list|)
argument_list|,
name|d
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// deletes
name|modifier
operator|.
name|deleteDocuments
argument_list|(
operator|new
name|Term
argument_list|(
literal|"id"
argument_list|,
name|Integer
operator|.
name|toString
argument_list|(
name|docId
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|// modifier.setNorm(docId, "contents", (float)2.0);
block|}
name|docId
operator|+=
literal|12
expr_stmt|;
block|}
block|}
name|modifier
operator|.
name|close
argument_list|()
expr_stmt|;
name|success
operator|=
literal|true
expr_stmt|;
if|if
condition|(
literal|0
operator|==
name|x
condition|)
block|{
name|done
operator|=
literal|true
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"  hit IOException: "
operator|+
name|e
argument_list|)
expr_stmt|;
name|e
operator|.
name|printStackTrace
argument_list|(
name|System
operator|.
name|out
argument_list|)
expr_stmt|;
block|}
name|err
operator|=
name|e
expr_stmt|;
if|if
condition|(
literal|1
operator|==
name|x
condition|)
block|{
name|e
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
name|fail
argument_list|(
name|testName
operator|+
literal|" hit IOException after disk space was freed up"
argument_list|)
expr_stmt|;
block|}
block|}
comment|// prevent throwing a random exception here!!
specifier|final
name|double
name|randomIOExceptionRate
init|=
name|dir
operator|.
name|getRandomIOExceptionRate
argument_list|()
decl_stmt|;
specifier|final
name|long
name|maxSizeInBytes
init|=
name|dir
operator|.
name|getMaxSizeInBytes
argument_list|()
decl_stmt|;
name|dir
operator|.
name|setRandomIOExceptionRate
argument_list|(
literal|0.0
argument_list|)
expr_stmt|;
name|dir
operator|.
name|setRandomIOExceptionRateOnOpen
argument_list|(
literal|0.0
argument_list|)
expr_stmt|;
name|dir
operator|.
name|setMaxSizeInBytes
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|success
condition|)
block|{
comment|// Must force the close else the writer can have
comment|// open files which cause exc in MockRAMDir.close
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"TEST: now rollback"
argument_list|)
expr_stmt|;
block|}
name|modifier
operator|.
name|rollback
argument_list|()
expr_stmt|;
block|}
comment|// If the close() succeeded, make sure there are
comment|// no unreferenced files.
if|if
condition|(
name|success
condition|)
block|{
name|_TestUtil
operator|.
name|checkIndex
argument_list|(
name|dir
argument_list|)
expr_stmt|;
name|TestIndexWriter
operator|.
name|assertNoUnreferencedFiles
argument_list|(
name|dir
argument_list|,
literal|"after writer.close"
argument_list|)
expr_stmt|;
block|}
name|dir
operator|.
name|setRandomIOExceptionRate
argument_list|(
name|randomIOExceptionRate
argument_list|)
expr_stmt|;
name|dir
operator|.
name|setMaxSizeInBytes
argument_list|(
name|maxSizeInBytes
argument_list|)
expr_stmt|;
comment|// Finally, verify index is not corrupt, and, if
comment|// we succeeded, we see all docs changed, and if
comment|// we failed, we see either all docs or no docs
comment|// changed (transactional semantics):
name|IndexReader
name|newReader
init|=
literal|null
decl_stmt|;
try|try
block|{
name|newReader
operator|=
name|DirectoryReader
operator|.
name|open
argument_list|(
name|dir
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|e
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
name|fail
argument_list|(
name|testName
operator|+
literal|":exception when creating IndexReader after disk full during close: "
operator|+
name|e
argument_list|)
expr_stmt|;
block|}
name|IndexSearcher
name|searcher
init|=
name|newSearcher
argument_list|(
name|newReader
argument_list|)
decl_stmt|;
name|ScoreDoc
index|[]
name|hits
init|=
literal|null
decl_stmt|;
try|try
block|{
name|hits
operator|=
name|searcher
operator|.
name|search
argument_list|(
operator|new
name|TermQuery
argument_list|(
name|searchTerm
argument_list|)
argument_list|,
literal|null
argument_list|,
literal|1000
argument_list|)
operator|.
name|scoreDocs
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|e
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
name|fail
argument_list|(
name|testName
operator|+
literal|": exception when searching: "
operator|+
name|e
argument_list|)
expr_stmt|;
block|}
name|int
name|result2
init|=
name|hits
operator|.
name|length
decl_stmt|;
if|if
condition|(
name|success
condition|)
block|{
if|if
condition|(
name|x
operator|==
literal|0
operator|&&
name|result2
operator|!=
name|END_COUNT
condition|)
block|{
name|fail
argument_list|(
name|testName
operator|+
literal|": method did not throw exception but hits.length for search on term 'aaa' is "
operator|+
name|result2
operator|+
literal|" instead of expected "
operator|+
name|END_COUNT
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|x
operator|==
literal|1
operator|&&
name|result2
operator|!=
name|START_COUNT
operator|&&
name|result2
operator|!=
name|END_COUNT
condition|)
block|{
comment|// It's possible that the first exception was
comment|// "recoverable" wrt pending deletes, in which
comment|// case the pending deletes are retained and
comment|// then re-flushing (with plenty of disk
comment|// space) will succeed in flushing the
comment|// deletes:
name|fail
argument_list|(
name|testName
operator|+
literal|": method did not throw exception but hits.length for search on term 'aaa' is "
operator|+
name|result2
operator|+
literal|" instead of expected "
operator|+
name|START_COUNT
operator|+
literal|" or "
operator|+
name|END_COUNT
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// On hitting exception we still may have added
comment|// all docs:
if|if
condition|(
name|result2
operator|!=
name|START_COUNT
operator|&&
name|result2
operator|!=
name|END_COUNT
condition|)
block|{
name|err
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
name|fail
argument_list|(
name|testName
operator|+
literal|": method did throw exception but hits.length for search on term 'aaa' is "
operator|+
name|result2
operator|+
literal|" instead of expected "
operator|+
name|START_COUNT
operator|+
literal|" or "
operator|+
name|END_COUNT
argument_list|)
expr_stmt|;
block|}
block|}
name|newReader
operator|.
name|close
argument_list|()
expr_stmt|;
if|if
condition|(
name|result2
operator|==
name|END_COUNT
condition|)
block|{
break|break;
block|}
block|}
name|dir
operator|.
name|close
argument_list|()
expr_stmt|;
name|modifier
operator|.
name|close
argument_list|()
expr_stmt|;
comment|// Try again with 10 more bytes of free space:
name|diskFree
operator|+=
literal|10
expr_stmt|;
block|}
name|startDir
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
comment|// This test tests that buffered deletes are cleared when
comment|// an Exception is hit during flush.
DECL|method|testErrorAfterApplyDeletes
specifier|public
name|void
name|testErrorAfterApplyDeletes
parameter_list|()
throws|throws
name|IOException
block|{
name|MockDirectoryWrapper
operator|.
name|Failure
name|failure
init|=
operator|new
name|MockDirectoryWrapper
operator|.
name|Failure
argument_list|()
block|{
name|boolean
name|sawMaybe
init|=
literal|false
decl_stmt|;
name|boolean
name|failed
init|=
literal|false
decl_stmt|;
name|Thread
name|thread
decl_stmt|;
annotation|@
name|Override
specifier|public
name|MockDirectoryWrapper
operator|.
name|Failure
name|reset
parameter_list|()
block|{
name|thread
operator|=
name|Thread
operator|.
name|currentThread
argument_list|()
expr_stmt|;
name|sawMaybe
operator|=
literal|false
expr_stmt|;
name|failed
operator|=
literal|false
expr_stmt|;
return|return
name|this
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|eval
parameter_list|(
name|MockDirectoryWrapper
name|dir
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|Thread
operator|.
name|currentThread
argument_list|()
operator|!=
name|thread
condition|)
block|{
comment|// don't fail during merging
return|return;
block|}
if|if
condition|(
name|sawMaybe
operator|&&
operator|!
name|failed
condition|)
block|{
name|boolean
name|seen
init|=
literal|false
decl_stmt|;
name|StackTraceElement
index|[]
name|trace
init|=
operator|new
name|Exception
argument_list|()
operator|.
name|getStackTrace
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|trace
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
literal|"applyDeletes"
operator|.
name|equals
argument_list|(
name|trace
index|[
name|i
index|]
operator|.
name|getMethodName
argument_list|()
argument_list|)
condition|)
block|{
name|seen
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|seen
condition|)
block|{
comment|// Only fail once we are no longer in applyDeletes
name|failed
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"TEST: mock failure: now fail"
argument_list|)
expr_stmt|;
operator|new
name|Throwable
argument_list|()
operator|.
name|printStackTrace
argument_list|(
name|System
operator|.
name|out
argument_list|)
expr_stmt|;
block|}
throw|throw
operator|new
name|IOException
argument_list|(
literal|"fail after applyDeletes"
argument_list|)
throw|;
block|}
block|}
if|if
condition|(
operator|!
name|failed
condition|)
block|{
name|StackTraceElement
index|[]
name|trace
init|=
operator|new
name|Exception
argument_list|()
operator|.
name|getStackTrace
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|trace
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
literal|"applyDeletes"
operator|.
name|equals
argument_list|(
name|trace
index|[
name|i
index|]
operator|.
name|getMethodName
argument_list|()
argument_list|)
condition|)
block|{
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"TEST: mock failure: saw applyDeletes"
argument_list|)
expr_stmt|;
operator|new
name|Throwable
argument_list|()
operator|.
name|printStackTrace
argument_list|(
name|System
operator|.
name|out
argument_list|)
expr_stmt|;
block|}
name|sawMaybe
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
block|}
decl_stmt|;
comment|// create a couple of files
name|String
index|[]
name|keywords
init|=
block|{
literal|"1"
block|,
literal|"2"
block|}
decl_stmt|;
name|String
index|[]
name|unindexed
init|=
block|{
literal|"Netherlands"
block|,
literal|"Italy"
block|}
decl_stmt|;
name|String
index|[]
name|unstored
init|=
block|{
literal|"Amsterdam has lots of bridges"
block|,
literal|"Venice has lots of canals"
block|}
decl_stmt|;
name|String
index|[]
name|text
init|=
block|{
literal|"Amsterdam"
block|,
literal|"Venice"
block|}
decl_stmt|;
name|MockDirectoryWrapper
name|dir
init|=
name|newMockDirectory
argument_list|()
decl_stmt|;
name|IndexWriter
name|modifier
init|=
operator|new
name|IndexWriter
argument_list|(
name|dir
argument_list|,
name|newIndexWriterConfig
argument_list|(
name|TEST_VERSION_CURRENT
argument_list|,
operator|new
name|MockAnalyzer
argument_list|(
name|random
argument_list|()
argument_list|,
name|MockTokenizer
operator|.
name|WHITESPACE
argument_list|,
literal|false
argument_list|)
argument_list|)
operator|.
name|setMaxBufferedDeleteTerms
argument_list|(
literal|2
argument_list|)
operator|.
name|setReaderPooling
argument_list|(
literal|false
argument_list|)
operator|.
name|setMergePolicy
argument_list|(
name|newLogMergePolicy
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|MergePolicy
name|lmp
init|=
name|modifier
operator|.
name|getConfig
argument_list|()
operator|.
name|getMergePolicy
argument_list|()
decl_stmt|;
name|lmp
operator|.
name|setNoCFSRatio
argument_list|(
literal|1.0
argument_list|)
expr_stmt|;
name|dir
operator|.
name|failOn
argument_list|(
name|failure
operator|.
name|reset
argument_list|()
argument_list|)
expr_stmt|;
name|FieldType
name|custom1
init|=
operator|new
name|FieldType
argument_list|()
decl_stmt|;
name|custom1
operator|.
name|setStored
argument_list|(
literal|true
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|keywords
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|Document
name|doc
init|=
operator|new
name|Document
argument_list|()
decl_stmt|;
name|doc
operator|.
name|add
argument_list|(
name|newStringField
argument_list|(
literal|"id"
argument_list|,
name|keywords
index|[
name|i
index|]
argument_list|,
name|Field
operator|.
name|Store
operator|.
name|YES
argument_list|)
argument_list|)
expr_stmt|;
name|doc
operator|.
name|add
argument_list|(
name|newField
argument_list|(
literal|"country"
argument_list|,
name|unindexed
index|[
name|i
index|]
argument_list|,
name|custom1
argument_list|)
argument_list|)
expr_stmt|;
name|doc
operator|.
name|add
argument_list|(
name|newTextField
argument_list|(
literal|"contents"
argument_list|,
name|unstored
index|[
name|i
index|]
argument_list|,
name|Field
operator|.
name|Store
operator|.
name|NO
argument_list|)
argument_list|)
expr_stmt|;
name|doc
operator|.
name|add
argument_list|(
name|newTextField
argument_list|(
literal|"city"
argument_list|,
name|text
index|[
name|i
index|]
argument_list|,
name|Field
operator|.
name|Store
operator|.
name|YES
argument_list|)
argument_list|)
expr_stmt|;
name|modifier
operator|.
name|addDocument
argument_list|(
name|doc
argument_list|)
expr_stmt|;
block|}
comment|// flush (and commit if ac)
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"TEST: now full merge"
argument_list|)
expr_stmt|;
block|}
name|modifier
operator|.
name|forceMerge
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"TEST: now commit"
argument_list|)
expr_stmt|;
block|}
name|modifier
operator|.
name|commit
argument_list|()
expr_stmt|;
comment|// one of the two files hits
name|Term
name|term
init|=
operator|new
name|Term
argument_list|(
literal|"city"
argument_list|,
literal|"Amsterdam"
argument_list|)
decl_stmt|;
name|int
name|hitCount
init|=
name|getHitCount
argument_list|(
name|dir
argument_list|,
name|term
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|hitCount
argument_list|)
expr_stmt|;
comment|// open the writer again (closed above)
comment|// delete the doc
comment|// max buf del terms is two, so this is buffered
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"TEST: delete term="
operator|+
name|term
argument_list|)
expr_stmt|;
block|}
name|modifier
operator|.
name|deleteDocuments
argument_list|(
name|term
argument_list|)
expr_stmt|;
comment|// add a doc (needed for the !ac case; see below)
comment|// doc remains buffered
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"TEST: add empty doc"
argument_list|)
expr_stmt|;
block|}
name|Document
name|doc
init|=
operator|new
name|Document
argument_list|()
decl_stmt|;
name|modifier
operator|.
name|addDocument
argument_list|(
name|doc
argument_list|)
expr_stmt|;
comment|// commit the changes, the buffered deletes, and the new doc
comment|// The failure object will fail on the first write after the del
comment|// file gets created when processing the buffered delete
comment|// in the ac case, this will be when writing the new segments
comment|// files so we really don't need the new doc, but it's harmless
comment|// a new segments file won't be created but in this
comment|// case, creation of the cfs file happens next so we
comment|// need the doc (to test that it's okay that we don't
comment|// lose deletes if failing while creating the cfs file)
name|boolean
name|failed
init|=
literal|false
decl_stmt|;
try|try
block|{
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"TEST: now commit for failure"
argument_list|)
expr_stmt|;
block|}
name|modifier
operator|.
name|commit
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
comment|// expected
name|failed
operator|=
literal|true
expr_stmt|;
block|}
name|assertTrue
argument_list|(
name|failed
argument_list|)
expr_stmt|;
comment|// The commit above failed, so we need to retry it (which will
comment|// succeed, because the failure is a one-shot)
name|modifier
operator|.
name|commit
argument_list|()
expr_stmt|;
name|hitCount
operator|=
name|getHitCount
argument_list|(
name|dir
argument_list|,
name|term
argument_list|)
expr_stmt|;
comment|// Make sure the delete was successfully flushed:
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|hitCount
argument_list|)
expr_stmt|;
name|modifier
operator|.
name|close
argument_list|()
expr_stmt|;
name|dir
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
comment|// This test tests that the files created by the docs writer before
comment|// a segment is written are cleaned up if there's an i/o error
DECL|method|testErrorInDocsWriterAdd
specifier|public
name|void
name|testErrorInDocsWriterAdd
parameter_list|()
throws|throws
name|IOException
block|{
name|MockDirectoryWrapper
operator|.
name|Failure
name|failure
init|=
operator|new
name|MockDirectoryWrapper
operator|.
name|Failure
argument_list|()
block|{
name|boolean
name|failed
init|=
literal|false
decl_stmt|;
annotation|@
name|Override
specifier|public
name|MockDirectoryWrapper
operator|.
name|Failure
name|reset
parameter_list|()
block|{
name|failed
operator|=
literal|false
expr_stmt|;
return|return
name|this
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|eval
parameter_list|(
name|MockDirectoryWrapper
name|dir
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|failed
condition|)
block|{
name|failed
operator|=
literal|true
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
literal|"fail in add doc"
argument_list|)
throw|;
block|}
block|}
block|}
decl_stmt|;
comment|// create a couple of files
name|String
index|[]
name|keywords
init|=
block|{
literal|"1"
block|,
literal|"2"
block|}
decl_stmt|;
name|String
index|[]
name|unindexed
init|=
block|{
literal|"Netherlands"
block|,
literal|"Italy"
block|}
decl_stmt|;
name|String
index|[]
name|unstored
init|=
block|{
literal|"Amsterdam has lots of bridges"
block|,
literal|"Venice has lots of canals"
block|}
decl_stmt|;
name|String
index|[]
name|text
init|=
block|{
literal|"Amsterdam"
block|,
literal|"Venice"
block|}
decl_stmt|;
name|MockDirectoryWrapper
name|dir
init|=
name|newMockDirectory
argument_list|()
decl_stmt|;
name|IndexWriter
name|modifier
init|=
operator|new
name|IndexWriter
argument_list|(
name|dir
argument_list|,
name|newIndexWriterConfig
argument_list|(
name|TEST_VERSION_CURRENT
argument_list|,
operator|new
name|MockAnalyzer
argument_list|(
name|random
argument_list|()
argument_list|,
name|MockTokenizer
operator|.
name|WHITESPACE
argument_list|,
literal|false
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|modifier
operator|.
name|commit
argument_list|()
expr_stmt|;
name|dir
operator|.
name|failOn
argument_list|(
name|failure
operator|.
name|reset
argument_list|()
argument_list|)
expr_stmt|;
name|FieldType
name|custom1
init|=
operator|new
name|FieldType
argument_list|()
decl_stmt|;
name|custom1
operator|.
name|setStored
argument_list|(
literal|true
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|keywords
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|Document
name|doc
init|=
operator|new
name|Document
argument_list|()
decl_stmt|;
name|doc
operator|.
name|add
argument_list|(
name|newStringField
argument_list|(
literal|"id"
argument_list|,
name|keywords
index|[
name|i
index|]
argument_list|,
name|Field
operator|.
name|Store
operator|.
name|YES
argument_list|)
argument_list|)
expr_stmt|;
name|doc
operator|.
name|add
argument_list|(
name|newField
argument_list|(
literal|"country"
argument_list|,
name|unindexed
index|[
name|i
index|]
argument_list|,
name|custom1
argument_list|)
argument_list|)
expr_stmt|;
name|doc
operator|.
name|add
argument_list|(
name|newTextField
argument_list|(
literal|"contents"
argument_list|,
name|unstored
index|[
name|i
index|]
argument_list|,
name|Field
operator|.
name|Store
operator|.
name|NO
argument_list|)
argument_list|)
expr_stmt|;
name|doc
operator|.
name|add
argument_list|(
name|newTextField
argument_list|(
literal|"city"
argument_list|,
name|text
index|[
name|i
index|]
argument_list|,
name|Field
operator|.
name|Store
operator|.
name|YES
argument_list|)
argument_list|)
expr_stmt|;
try|try
block|{
name|modifier
operator|.
name|addDocument
argument_list|(
name|doc
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|io
parameter_list|)
block|{
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"TEST: got expected exc:"
argument_list|)
expr_stmt|;
name|io
operator|.
name|printStackTrace
argument_list|(
name|System
operator|.
name|out
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
name|modifier
operator|.
name|close
argument_list|()
expr_stmt|;
name|TestIndexWriter
operator|.
name|assertNoUnreferencedFiles
argument_list|(
name|dir
argument_list|,
literal|"docsWriter.abort() failed to delete unreferenced files"
argument_list|)
expr_stmt|;
name|dir
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
DECL|method|testDeleteNullQuery
specifier|public
name|void
name|testDeleteNullQuery
parameter_list|()
throws|throws
name|IOException
block|{
name|Directory
name|dir
init|=
name|newDirectory
argument_list|()
decl_stmt|;
name|IndexWriter
name|modifier
init|=
operator|new
name|IndexWriter
argument_list|(
name|dir
argument_list|,
operator|new
name|IndexWriterConfig
argument_list|(
name|TEST_VERSION_CURRENT
argument_list|,
operator|new
name|MockAnalyzer
argument_list|(
name|random
argument_list|()
argument_list|,
name|MockTokenizer
operator|.
name|WHITESPACE
argument_list|,
literal|false
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|5
condition|;
name|i
operator|++
control|)
block|{
name|addDoc
argument_list|(
name|modifier
argument_list|,
name|i
argument_list|,
literal|2
operator|*
name|i
argument_list|)
expr_stmt|;
block|}
name|modifier
operator|.
name|deleteDocuments
argument_list|(
operator|new
name|TermQuery
argument_list|(
operator|new
name|Term
argument_list|(
literal|"nada"
argument_list|,
literal|"nada"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|modifier
operator|.
name|commit
argument_list|()
expr_stmt|;
name|assertEquals
argument_list|(
literal|5
argument_list|,
name|modifier
operator|.
name|numDocs
argument_list|()
argument_list|)
expr_stmt|;
name|modifier
operator|.
name|close
argument_list|()
expr_stmt|;
name|dir
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
DECL|method|testDeleteAllSlowly
specifier|public
name|void
name|testDeleteAllSlowly
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|Directory
name|dir
init|=
name|newDirectory
argument_list|()
decl_stmt|;
name|RandomIndexWriter
name|w
init|=
operator|new
name|RandomIndexWriter
argument_list|(
name|random
argument_list|()
argument_list|,
name|dir
argument_list|)
decl_stmt|;
specifier|final
name|int
name|NUM_DOCS
init|=
name|atLeast
argument_list|(
literal|1000
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|Integer
argument_list|>
name|ids
init|=
operator|new
name|ArrayList
argument_list|<
name|Integer
argument_list|>
argument_list|(
name|NUM_DOCS
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|id
init|=
literal|0
init|;
name|id
operator|<
name|NUM_DOCS
condition|;
name|id
operator|++
control|)
block|{
name|ids
operator|.
name|add
argument_list|(
name|id
argument_list|)
expr_stmt|;
block|}
name|Collections
operator|.
name|shuffle
argument_list|(
name|ids
argument_list|,
name|random
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|id
range|:
name|ids
control|)
block|{
name|Document
name|doc
init|=
operator|new
name|Document
argument_list|()
decl_stmt|;
name|doc
operator|.
name|add
argument_list|(
name|newStringField
argument_list|(
literal|"id"
argument_list|,
literal|""
operator|+
name|id
argument_list|,
name|Field
operator|.
name|Store
operator|.
name|NO
argument_list|)
argument_list|)
expr_stmt|;
name|w
operator|.
name|addDocument
argument_list|(
name|doc
argument_list|)
expr_stmt|;
block|}
name|Collections
operator|.
name|shuffle
argument_list|(
name|ids
argument_list|,
name|random
argument_list|()
argument_list|)
expr_stmt|;
name|int
name|upto
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|upto
operator|<
name|ids
operator|.
name|size
argument_list|()
condition|)
block|{
specifier|final
name|int
name|left
init|=
name|ids
operator|.
name|size
argument_list|()
operator|-
name|upto
decl_stmt|;
specifier|final
name|int
name|inc
init|=
name|Math
operator|.
name|min
argument_list|(
name|left
argument_list|,
name|_TestUtil
operator|.
name|nextInt
argument_list|(
name|random
argument_list|()
argument_list|,
literal|1
argument_list|,
literal|20
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|int
name|limit
init|=
name|upto
operator|+
name|inc
decl_stmt|;
while|while
condition|(
name|upto
operator|<
name|limit
condition|)
block|{
name|w
operator|.
name|deleteDocuments
argument_list|(
operator|new
name|Term
argument_list|(
literal|"id"
argument_list|,
literal|""
operator|+
name|ids
operator|.
name|get
argument_list|(
name|upto
operator|++
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|final
name|IndexReader
name|r
init|=
name|w
operator|.
name|getReader
argument_list|()
decl_stmt|;
name|assertEquals
argument_list|(
name|NUM_DOCS
operator|-
name|upto
argument_list|,
name|r
operator|.
name|numDocs
argument_list|()
argument_list|)
expr_stmt|;
name|r
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
name|w
operator|.
name|close
argument_list|()
expr_stmt|;
name|dir
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
DECL|method|testIndexingThenDeleting
specifier|public
name|void
name|testIndexingThenDeleting
parameter_list|()
throws|throws
name|Exception
block|{
comment|// TODO: move this test to its own class and just @SuppressCodecs?
comment|// TODO: is it enough to just use newFSDirectory?
specifier|final
name|String
name|fieldFormat
init|=
name|_TestUtil
operator|.
name|getPostingsFormat
argument_list|(
literal|"field"
argument_list|)
decl_stmt|;
name|assumeFalse
argument_list|(
literal|"This test cannot run with Memory codec"
argument_list|,
name|fieldFormat
operator|.
name|equals
argument_list|(
literal|"Memory"
argument_list|)
argument_list|)
expr_stmt|;
name|assumeFalse
argument_list|(
literal|"This test cannot run with SimpleText codec"
argument_list|,
name|fieldFormat
operator|.
name|equals
argument_list|(
literal|"SimpleText"
argument_list|)
argument_list|)
expr_stmt|;
name|assumeFalse
argument_list|(
literal|"This test cannot run with Direct codec"
argument_list|,
name|fieldFormat
operator|.
name|equals
argument_list|(
literal|"Direct"
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|Random
name|r
init|=
name|random
argument_list|()
decl_stmt|;
name|Directory
name|dir
init|=
name|newDirectory
argument_list|()
decl_stmt|;
comment|// note this test explicitly disables payloads
specifier|final
name|Analyzer
name|analyzer
init|=
operator|new
name|Analyzer
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|TokenStreamComponents
name|createComponents
parameter_list|(
name|String
name|fieldName
parameter_list|,
name|Reader
name|reader
parameter_list|)
block|{
return|return
operator|new
name|TokenStreamComponents
argument_list|(
operator|new
name|MockTokenizer
argument_list|(
name|reader
argument_list|,
name|MockTokenizer
operator|.
name|WHITESPACE
argument_list|,
literal|true
argument_list|)
argument_list|)
return|;
block|}
block|}
decl_stmt|;
name|IndexWriter
name|w
init|=
operator|new
name|IndexWriter
argument_list|(
name|dir
argument_list|,
name|newIndexWriterConfig
argument_list|(
name|TEST_VERSION_CURRENT
argument_list|,
name|analyzer
argument_list|)
operator|.
name|setRAMBufferSizeMB
argument_list|(
literal|1.0
argument_list|)
operator|.
name|setMaxBufferedDocs
argument_list|(
name|IndexWriterConfig
operator|.
name|DISABLE_AUTO_FLUSH
argument_list|)
operator|.
name|setMaxBufferedDeleteTerms
argument_list|(
name|IndexWriterConfig
operator|.
name|DISABLE_AUTO_FLUSH
argument_list|)
argument_list|)
decl_stmt|;
name|Document
name|doc
init|=
operator|new
name|Document
argument_list|()
decl_stmt|;
name|doc
operator|.
name|add
argument_list|(
name|newTextField
argument_list|(
literal|"field"
argument_list|,
literal|"go 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20"
argument_list|,
name|Field
operator|.
name|Store
operator|.
name|NO
argument_list|)
argument_list|)
expr_stmt|;
name|int
name|num
init|=
name|atLeast
argument_list|(
literal|3
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|iter
init|=
literal|0
init|;
name|iter
operator|<
name|num
condition|;
name|iter
operator|++
control|)
block|{
name|int
name|count
init|=
literal|0
decl_stmt|;
specifier|final
name|boolean
name|doIndexing
init|=
name|r
operator|.
name|nextBoolean
argument_list|()
decl_stmt|;
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"TEST: iter doIndexing="
operator|+
name|doIndexing
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|doIndexing
condition|)
block|{
comment|// Add docs until a flush is triggered
specifier|final
name|int
name|startFlushCount
init|=
name|w
operator|.
name|getFlushCount
argument_list|()
decl_stmt|;
while|while
condition|(
name|w
operator|.
name|getFlushCount
argument_list|()
operator|==
name|startFlushCount
condition|)
block|{
name|w
operator|.
name|addDocument
argument_list|(
name|doc
argument_list|)
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// Delete docs until a flush is triggered
specifier|final
name|int
name|startFlushCount
init|=
name|w
operator|.
name|getFlushCount
argument_list|()
decl_stmt|;
while|while
condition|(
name|w
operator|.
name|getFlushCount
argument_list|()
operator|==
name|startFlushCount
condition|)
block|{
name|w
operator|.
name|deleteDocuments
argument_list|(
operator|new
name|Term
argument_list|(
literal|"foo"
argument_list|,
literal|""
operator|+
name|count
argument_list|)
argument_list|)
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
block|}
name|assertTrue
argument_list|(
literal|"flush happened too quickly during "
operator|+
operator|(
name|doIndexing
condition|?
literal|"indexing"
else|:
literal|"deleting"
operator|)
operator|+
literal|" count="
operator|+
name|count
argument_list|,
name|count
operator|>
literal|2500
argument_list|)
expr_stmt|;
block|}
name|w
operator|.
name|close
argument_list|()
expr_stmt|;
name|dir
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
comment|// LUCENE-3340: make sure deletes that we don't apply
comment|// during flush (ie are just pushed into the stream) are
comment|// in fact later flushed due to their RAM usage:
DECL|method|testFlushPushedDeletesByRAM
specifier|public
name|void
name|testFlushPushedDeletesByRAM
parameter_list|()
throws|throws
name|Exception
block|{
name|Directory
name|dir
init|=
name|newDirectory
argument_list|()
decl_stmt|;
comment|// Cannot use RandomIndexWriter because we don't want to
comment|// ever call commit() for this test:
comment|// note: tiny rambuffer used, as with a 1MB buffer the test is too slow (flush @ 128,999)
name|IndexWriter
name|w
init|=
operator|new
name|IndexWriter
argument_list|(
name|dir
argument_list|,
name|newIndexWriterConfig
argument_list|(
name|TEST_VERSION_CURRENT
argument_list|,
operator|new
name|MockAnalyzer
argument_list|(
name|random
argument_list|()
argument_list|)
argument_list|)
operator|.
name|setRAMBufferSizeMB
argument_list|(
literal|0.1f
argument_list|)
operator|.
name|setMaxBufferedDocs
argument_list|(
literal|1000
argument_list|)
operator|.
name|setMergePolicy
argument_list|(
name|NoMergePolicy
operator|.
name|NO_COMPOUND_FILES
argument_list|)
operator|.
name|setReaderPooling
argument_list|(
literal|false
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|Document
name|doc
init|=
operator|new
name|Document
argument_list|()
decl_stmt|;
name|doc
operator|.
name|add
argument_list|(
operator|new
name|StringField
argument_list|(
literal|"id"
argument_list|,
name|count
operator|+
literal|""
argument_list|,
name|Field
operator|.
name|Store
operator|.
name|NO
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|Term
name|delTerm
decl_stmt|;
if|if
condition|(
name|count
operator|==
literal|1010
condition|)
block|{
comment|// This is the only delete that applies
name|delTerm
operator|=
operator|new
name|Term
argument_list|(
literal|"id"
argument_list|,
literal|""
operator|+
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// These get buffered, taking up RAM, but delete
comment|// nothing when applied:
name|delTerm
operator|=
operator|new
name|Term
argument_list|(
literal|"id"
argument_list|,
literal|"x"
operator|+
name|count
argument_list|)
expr_stmt|;
block|}
name|w
operator|.
name|updateDocument
argument_list|(
name|delTerm
argument_list|,
name|doc
argument_list|)
expr_stmt|;
comment|// Eventually segment 0 should get a del docs:
comment|// TODO: fix this test
if|if
condition|(
name|dir
operator|.
name|fileExists
argument_list|(
literal|"_0_1.del"
argument_list|)
operator|||
name|dir
operator|.
name|fileExists
argument_list|(
literal|"_0_1.liv"
argument_list|)
condition|)
block|{
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"TEST: deletes created @ count="
operator|+
name|count
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
name|count
operator|++
expr_stmt|;
comment|// Today we applyDeletes @ count=21553; even if we make
comment|// sizable improvements to RAM efficiency of buffered
comment|// del term we're unlikely to go over 100K:
if|if
condition|(
name|count
operator|>
literal|100000
condition|)
block|{
name|fail
argument_list|(
literal|"delete's were not applied"
argument_list|)
expr_stmt|;
block|}
block|}
name|w
operator|.
name|close
argument_list|()
expr_stmt|;
name|dir
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
comment|// LUCENE-3340: make sure deletes that we don't apply
comment|// during flush (ie are just pushed into the stream) are
comment|// in fact later flushed due to their RAM usage:
DECL|method|testFlushPushedDeletesByCount
specifier|public
name|void
name|testFlushPushedDeletesByCount
parameter_list|()
throws|throws
name|Exception
block|{
name|Directory
name|dir
init|=
name|newDirectory
argument_list|()
decl_stmt|;
comment|// Cannot use RandomIndexWriter because we don't want to
comment|// ever call commit() for this test:
specifier|final
name|int
name|flushAtDelCount
init|=
name|atLeast
argument_list|(
literal|1020
argument_list|)
decl_stmt|;
name|IndexWriter
name|w
init|=
operator|new
name|IndexWriter
argument_list|(
name|dir
argument_list|,
name|newIndexWriterConfig
argument_list|(
name|TEST_VERSION_CURRENT
argument_list|,
operator|new
name|MockAnalyzer
argument_list|(
name|random
argument_list|()
argument_list|)
argument_list|)
operator|.
name|setMaxBufferedDeleteTerms
argument_list|(
name|flushAtDelCount
argument_list|)
operator|.
name|setMaxBufferedDocs
argument_list|(
literal|1000
argument_list|)
operator|.
name|setRAMBufferSizeMB
argument_list|(
name|IndexWriterConfig
operator|.
name|DISABLE_AUTO_FLUSH
argument_list|)
operator|.
name|setMergePolicy
argument_list|(
name|NoMergePolicy
operator|.
name|NO_COMPOUND_FILES
argument_list|)
operator|.
name|setReaderPooling
argument_list|(
literal|false
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|Document
name|doc
init|=
operator|new
name|Document
argument_list|()
decl_stmt|;
name|doc
operator|.
name|add
argument_list|(
operator|new
name|StringField
argument_list|(
literal|"id"
argument_list|,
name|count
operator|+
literal|""
argument_list|,
name|Field
operator|.
name|Store
operator|.
name|NO
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|Term
name|delTerm
decl_stmt|;
if|if
condition|(
name|count
operator|==
literal|1010
condition|)
block|{
comment|// This is the only delete that applies
name|delTerm
operator|=
operator|new
name|Term
argument_list|(
literal|"id"
argument_list|,
literal|""
operator|+
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// These get buffered, taking up RAM, but delete
comment|// nothing when applied:
name|delTerm
operator|=
operator|new
name|Term
argument_list|(
literal|"id"
argument_list|,
literal|"x"
operator|+
name|count
argument_list|)
expr_stmt|;
block|}
name|w
operator|.
name|updateDocument
argument_list|(
name|delTerm
argument_list|,
name|doc
argument_list|)
expr_stmt|;
comment|// Eventually segment 0 should get a del docs:
comment|// TODO: fix this test
if|if
condition|(
name|dir
operator|.
name|fileExists
argument_list|(
literal|"_0_1.del"
argument_list|)
operator|||
name|dir
operator|.
name|fileExists
argument_list|(
literal|"_0_1.liv"
argument_list|)
condition|)
block|{
break|break;
block|}
name|count
operator|++
expr_stmt|;
if|if
condition|(
name|count
operator|>
name|flushAtDelCount
condition|)
block|{
name|fail
argument_list|(
literal|"delete's were not applied at count="
operator|+
name|flushAtDelCount
argument_list|)
expr_stmt|;
block|}
block|}
name|w
operator|.
name|close
argument_list|()
expr_stmt|;
name|dir
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
comment|// Make sure buffered (pushed) deletes don't use up so
comment|// much RAM that it forces long tail of tiny segments:
annotation|@
name|Nightly
DECL|method|testApplyDeletesOnFlush
specifier|public
name|void
name|testApplyDeletesOnFlush
parameter_list|()
throws|throws
name|Exception
block|{
name|Directory
name|dir
init|=
name|newDirectory
argument_list|()
decl_stmt|;
comment|// Cannot use RandomIndexWriter because we don't want to
comment|// ever call commit() for this test:
specifier|final
name|AtomicInteger
name|docsInSegment
init|=
operator|new
name|AtomicInteger
argument_list|()
decl_stmt|;
specifier|final
name|AtomicBoolean
name|closing
init|=
operator|new
name|AtomicBoolean
argument_list|()
decl_stmt|;
specifier|final
name|AtomicBoolean
name|sawAfterFlush
init|=
operator|new
name|AtomicBoolean
argument_list|()
decl_stmt|;
name|IndexWriter
name|w
init|=
operator|new
name|IndexWriter
argument_list|(
name|dir
argument_list|,
name|newIndexWriterConfig
argument_list|(
name|TEST_VERSION_CURRENT
argument_list|,
operator|new
name|MockAnalyzer
argument_list|(
name|random
argument_list|()
argument_list|)
argument_list|)
operator|.
name|setRAMBufferSizeMB
argument_list|(
literal|0.5
argument_list|)
operator|.
name|setMaxBufferedDocs
argument_list|(
operator|-
literal|1
argument_list|)
operator|.
name|setMergePolicy
argument_list|(
name|NoMergePolicy
operator|.
name|NO_COMPOUND_FILES
argument_list|)
operator|.
name|setReaderPooling
argument_list|(
literal|false
argument_list|)
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|void
name|doAfterFlush
parameter_list|()
block|{
name|assertTrue
argument_list|(
literal|"only "
operator|+
name|docsInSegment
operator|.
name|get
argument_list|()
operator|+
literal|" in segment"
argument_list|,
name|closing
operator|.
name|get
argument_list|()
operator|||
name|docsInSegment
operator|.
name|get
argument_list|()
operator|>=
literal|7
argument_list|)
expr_stmt|;
name|docsInSegment
operator|.
name|set
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|sawAfterFlush
operator|.
name|set
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
decl_stmt|;
name|int
name|id
init|=
literal|0
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|termIDX
init|=
literal|0
init|;
name|termIDX
operator|<
literal|100
condition|;
name|termIDX
operator|++
control|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|' '
argument_list|)
operator|.
name|append
argument_list|(
name|_TestUtil
operator|.
name|randomRealisticUnicodeString
argument_list|(
name|random
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|id
operator|==
literal|500
condition|)
block|{
name|w
operator|.
name|deleteDocuments
argument_list|(
operator|new
name|Term
argument_list|(
literal|"id"
argument_list|,
literal|"0"
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|Document
name|doc
init|=
operator|new
name|Document
argument_list|()
decl_stmt|;
name|doc
operator|.
name|add
argument_list|(
name|newStringField
argument_list|(
literal|"id"
argument_list|,
literal|""
operator|+
name|id
argument_list|,
name|Field
operator|.
name|Store
operator|.
name|NO
argument_list|)
argument_list|)
expr_stmt|;
name|doc
operator|.
name|add
argument_list|(
name|newTextField
argument_list|(
literal|"body"
argument_list|,
name|sb
operator|.
name|toString
argument_list|()
argument_list|,
name|Field
operator|.
name|Store
operator|.
name|NO
argument_list|)
argument_list|)
expr_stmt|;
name|w
operator|.
name|updateDocument
argument_list|(
operator|new
name|Term
argument_list|(
literal|"id"
argument_list|,
literal|""
operator|+
name|id
argument_list|)
argument_list|,
name|doc
argument_list|)
expr_stmt|;
name|docsInSegment
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
comment|// TODO: fix this test
if|if
condition|(
name|dir
operator|.
name|fileExists
argument_list|(
literal|"_0_1.del"
argument_list|)
operator|||
name|dir
operator|.
name|fileExists
argument_list|(
literal|"_0_1.liv"
argument_list|)
condition|)
block|{
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"TEST: deletes created @ id="
operator|+
name|id
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
name|id
operator|++
expr_stmt|;
block|}
name|closing
operator|.
name|set
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|sawAfterFlush
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
name|w
operator|.
name|close
argument_list|()
expr_stmt|;
name|dir
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
comment|// LUCENE-4455
DECL|method|testDeletesCheckIndexOutput
specifier|public
name|void
name|testDeletesCheckIndexOutput
parameter_list|()
throws|throws
name|Exception
block|{
name|Directory
name|dir
init|=
name|newDirectory
argument_list|()
decl_stmt|;
name|IndexWriterConfig
name|iwc
init|=
operator|new
name|IndexWriterConfig
argument_list|(
name|TEST_VERSION_CURRENT
argument_list|,
operator|new
name|MockAnalyzer
argument_list|(
name|random
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|iwc
operator|.
name|setMaxBufferedDocs
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|IndexWriter
name|w
init|=
operator|new
name|IndexWriter
argument_list|(
name|dir
argument_list|,
name|iwc
operator|.
name|clone
argument_list|()
argument_list|)
decl_stmt|;
name|Document
name|doc
init|=
operator|new
name|Document
argument_list|()
decl_stmt|;
name|doc
operator|.
name|add
argument_list|(
name|newField
argument_list|(
literal|"field"
argument_list|,
literal|"0"
argument_list|,
name|StringField
operator|.
name|TYPE_NOT_STORED
argument_list|)
argument_list|)
expr_stmt|;
name|w
operator|.
name|addDocument
argument_list|(
name|doc
argument_list|)
expr_stmt|;
name|doc
operator|=
operator|new
name|Document
argument_list|()
expr_stmt|;
name|doc
operator|.
name|add
argument_list|(
name|newField
argument_list|(
literal|"field"
argument_list|,
literal|"1"
argument_list|,
name|StringField
operator|.
name|TYPE_NOT_STORED
argument_list|)
argument_list|)
expr_stmt|;
name|w
operator|.
name|addDocument
argument_list|(
name|doc
argument_list|)
expr_stmt|;
name|w
operator|.
name|commit
argument_list|()
expr_stmt|;
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|w
operator|.
name|getSegmentCount
argument_list|()
argument_list|)
expr_stmt|;
name|w
operator|.
name|deleteDocuments
argument_list|(
operator|new
name|Term
argument_list|(
literal|"field"
argument_list|,
literal|"0"
argument_list|)
argument_list|)
expr_stmt|;
name|w
operator|.
name|commit
argument_list|()
expr_stmt|;
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|w
operator|.
name|getSegmentCount
argument_list|()
argument_list|)
expr_stmt|;
name|w
operator|.
name|close
argument_list|()
expr_stmt|;
name|ByteArrayOutputStream
name|bos
init|=
operator|new
name|ByteArrayOutputStream
argument_list|(
literal|1024
argument_list|)
decl_stmt|;
name|CheckIndex
name|checker
init|=
operator|new
name|CheckIndex
argument_list|(
name|dir
argument_list|)
decl_stmt|;
name|checker
operator|.
name|setInfoStream
argument_list|(
operator|new
name|PrintStream
argument_list|(
name|bos
argument_list|,
literal|false
argument_list|,
literal|"UTF-8"
argument_list|)
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|CheckIndex
operator|.
name|Status
name|indexStatus
init|=
name|checker
operator|.
name|checkIndex
argument_list|(
literal|null
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|indexStatus
operator|.
name|clean
argument_list|)
expr_stmt|;
name|String
name|s
init|=
name|bos
operator|.
name|toString
argument_list|(
literal|"UTF-8"
argument_list|)
decl_stmt|;
comment|// Segment should have deletions:
name|assertTrue
argument_list|(
name|s
operator|.
name|contains
argument_list|(
literal|"has deletions"
argument_list|)
argument_list|)
expr_stmt|;
name|w
operator|=
operator|new
name|IndexWriter
argument_list|(
name|dir
argument_list|,
name|iwc
operator|.
name|clone
argument_list|()
argument_list|)
expr_stmt|;
name|w
operator|.
name|forceMerge
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|w
operator|.
name|close
argument_list|()
expr_stmt|;
name|bos
operator|=
operator|new
name|ByteArrayOutputStream
argument_list|(
literal|1024
argument_list|)
expr_stmt|;
name|checker
operator|.
name|setInfoStream
argument_list|(
operator|new
name|PrintStream
argument_list|(
name|bos
argument_list|,
literal|false
argument_list|,
literal|"UTF-8"
argument_list|)
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|indexStatus
operator|=
name|checker
operator|.
name|checkIndex
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|indexStatus
operator|.
name|clean
argument_list|)
expr_stmt|;
name|s
operator|=
name|bos
operator|.
name|toString
argument_list|(
literal|"UTF-8"
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|s
operator|.
name|contains
argument_list|(
literal|"has deletions"
argument_list|)
argument_list|)
expr_stmt|;
name|dir
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
DECL|method|testTryDeleteDocument
specifier|public
name|void
name|testTryDeleteDocument
parameter_list|()
throws|throws
name|Exception
block|{
name|Directory
name|d
init|=
name|newDirectory
argument_list|()
decl_stmt|;
name|IndexWriterConfig
name|iwc
init|=
operator|new
name|IndexWriterConfig
argument_list|(
name|TEST_VERSION_CURRENT
argument_list|,
operator|new
name|MockAnalyzer
argument_list|(
name|random
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|IndexWriter
name|w
init|=
operator|new
name|IndexWriter
argument_list|(
name|d
argument_list|,
name|iwc
argument_list|)
decl_stmt|;
name|Document
name|doc
init|=
operator|new
name|Document
argument_list|()
decl_stmt|;
name|w
operator|.
name|addDocument
argument_list|(
name|doc
argument_list|)
expr_stmt|;
name|w
operator|.
name|addDocument
argument_list|(
name|doc
argument_list|)
expr_stmt|;
name|w
operator|.
name|addDocument
argument_list|(
name|doc
argument_list|)
expr_stmt|;
name|w
operator|.
name|close
argument_list|()
expr_stmt|;
name|iwc
operator|=
operator|new
name|IndexWriterConfig
argument_list|(
name|TEST_VERSION_CURRENT
argument_list|,
operator|new
name|MockAnalyzer
argument_list|(
name|random
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|iwc
operator|.
name|setOpenMode
argument_list|(
name|IndexWriterConfig
operator|.
name|OpenMode
operator|.
name|APPEND
argument_list|)
expr_stmt|;
name|w
operator|=
operator|new
name|IndexWriter
argument_list|(
name|d
argument_list|,
name|iwc
argument_list|)
expr_stmt|;
name|IndexReader
name|r
init|=
name|DirectoryReader
operator|.
name|open
argument_list|(
name|w
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|w
operator|.
name|tryDeleteDocument
argument_list|(
name|r
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|w
operator|.
name|tryDeleteDocument
argument_list|(
name|r
operator|.
name|leaves
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|reader
argument_list|()
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|r
operator|.
name|close
argument_list|()
expr_stmt|;
name|w
operator|.
name|close
argument_list|()
expr_stmt|;
name|r
operator|=
name|DirectoryReader
operator|.
name|open
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|2
argument_list|,
name|r
operator|.
name|numDeletedDocs
argument_list|()
argument_list|)
expr_stmt|;
name|assertNotNull
argument_list|(
name|MultiFields
operator|.
name|getLiveDocs
argument_list|(
name|r
argument_list|)
argument_list|)
expr_stmt|;
name|r
operator|.
name|close
argument_list|()
expr_stmt|;
name|d
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
DECL|class|FakeIOException
specifier|private
specifier|static
class|class
name|FakeIOException
extends|extends
name|IOException
block|{   }
comment|// Make sure if we hit disk full, and then later disk
comment|// frees up, and we successfully close IW or open an NRT
comment|// reader, we don't lose any deletes:
DECL|method|testNoLostDeletesOnDiskFull
specifier|public
name|void
name|testNoLostDeletesOnDiskFull
parameter_list|()
throws|throws
name|Exception
block|{
name|int
name|deleteCount
init|=
literal|0
decl_stmt|;
name|int
name|docBase
init|=
literal|0
decl_stmt|;
name|int
name|docCount
init|=
literal|0
decl_stmt|;
name|MockDirectoryWrapper
name|dir
init|=
name|newMockDirectory
argument_list|()
decl_stmt|;
specifier|final
name|AtomicBoolean
name|shouldFail
init|=
operator|new
name|AtomicBoolean
argument_list|()
decl_stmt|;
name|dir
operator|.
name|failOn
argument_list|(
operator|new
name|MockDirectoryWrapper
operator|.
name|Failure
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|eval
parameter_list|(
name|MockDirectoryWrapper
name|dir
parameter_list|)
throws|throws
name|IOException
block|{
name|StackTraceElement
index|[]
name|trace
init|=
operator|new
name|Exception
argument_list|()
operator|.
name|getStackTrace
argument_list|()
decl_stmt|;
if|if
condition|(
name|shouldFail
operator|.
name|get
argument_list|()
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|trace
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
literal|"writeLiveDocs"
operator|.
name|equals
argument_list|(
name|trace
index|[
name|i
index|]
operator|.
name|getMethodName
argument_list|()
argument_list|)
condition|)
block|{
comment|// Only sometimes throw the exc, so we get
comment|// it sometimes on creating the file, on
comment|// flushing buffer, on closing the file:
if|if
condition|(
name|random
argument_list|()
operator|.
name|nextInt
argument_list|(
literal|3
argument_list|)
operator|==
literal|2
condition|)
block|{
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"TEST: now fail; exc:"
argument_list|)
expr_stmt|;
operator|new
name|Throwable
argument_list|()
operator|.
name|printStackTrace
argument_list|(
name|System
operator|.
name|out
argument_list|)
expr_stmt|;
block|}
name|shouldFail
operator|.
name|set
argument_list|(
literal|false
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|FakeIOException
argument_list|()
throw|;
block|}
else|else
block|{
break|break;
block|}
block|}
block|}
block|}
block|}
block|}
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|iter
init|=
literal|0
init|;
name|iter
operator|<
literal|10
operator|*
name|RANDOM_MULTIPLIER
condition|;
name|iter
operator|++
control|)
block|{
name|int
name|numDocs
init|=
name|atLeast
argument_list|(
literal|100
argument_list|)
decl_stmt|;
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"\nTEST: iter="
operator|+
name|iter
operator|+
literal|" numDocs="
operator|+
name|numDocs
operator|+
literal|" docBase="
operator|+
name|docBase
argument_list|)
expr_stmt|;
block|}
name|IndexWriterConfig
name|iwc
init|=
name|newIndexWriterConfig
argument_list|(
name|TEST_VERSION_CURRENT
argument_list|,
operator|new
name|MockAnalyzer
argument_list|(
name|random
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|IndexWriter
name|w
init|=
operator|new
name|IndexWriter
argument_list|(
name|dir
argument_list|,
name|iwc
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numDocs
condition|;
name|i
operator|++
control|)
block|{
name|Document
name|doc
init|=
operator|new
name|Document
argument_list|()
decl_stmt|;
name|doc
operator|.
name|add
argument_list|(
operator|new
name|StringField
argument_list|(
literal|"id"
argument_list|,
literal|""
operator|+
operator|(
name|docBase
operator|+
name|i
operator|)
argument_list|,
name|Field
operator|.
name|Store
operator|.
name|NO
argument_list|)
argument_list|)
expr_stmt|;
name|w
operator|.
name|addDocument
argument_list|(
name|doc
argument_list|)
expr_stmt|;
block|}
name|docCount
operator|+=
name|numDocs
expr_stmt|;
name|IndexReader
name|r
init|=
name|w
operator|.
name|getReader
argument_list|()
decl_stmt|;
name|assertEquals
argument_list|(
name|docCount
operator|-
name|deleteCount
argument_list|,
name|r
operator|.
name|numDocs
argument_list|()
argument_list|)
expr_stmt|;
name|r
operator|.
name|close
argument_list|()
expr_stmt|;
comment|// TODO: we could also install an infoStream and try
comment|// to fail in "more evil" places inside BDS
name|shouldFail
operator|.
name|set
argument_list|(
literal|true
argument_list|)
expr_stmt|;
try|try
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numDocs
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|random
argument_list|()
operator|.
name|nextInt
argument_list|(
literal|10
argument_list|)
operator|==
literal|7
condition|)
block|{
name|deleteCount
operator|++
expr_stmt|;
name|w
operator|.
name|deleteDocuments
argument_list|(
operator|new
name|Term
argument_list|(
literal|"id"
argument_list|,
literal|""
operator|+
operator|(
name|docBase
operator|+
name|i
operator|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|w
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|FakeIOException
name|ioe
parameter_list|)
block|{
comment|// expected
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"TEST: w.close() hit expected IOE"
argument_list|)
expr_stmt|;
block|}
comment|// No exception should happen here (we only fail once):
name|w
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
name|shouldFail
operator|.
name|set
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|r
operator|=
name|DirectoryReader
operator|.
name|open
argument_list|(
name|dir
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|docCount
operator|-
name|deleteCount
argument_list|,
name|r
operator|.
name|numDocs
argument_list|()
argument_list|)
expr_stmt|;
name|r
operator|.
name|close
argument_list|()
expr_stmt|;
name|docBase
operator|+=
name|numDocs
expr_stmt|;
block|}
name|dir
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
end_class
end_unit
