begin_unit
begin_package
DECL|package|org.apache.lucene.index
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
package|;
end_package
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Closeable
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|EnumSet
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
operator|.
name|Entry
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Random
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|CountDownLatch
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicBoolean
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|MockAnalyzer
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|document
operator|.
name|BinaryDocValuesField
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|document
operator|.
name|Document
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|document
operator|.
name|Field
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|document
operator|.
name|NumericDocValuesField
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|document
operator|.
name|SortedDocValuesField
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|document
operator|.
name|StringField
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|document
operator|.
name|TextField
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|FieldInfo
operator|.
name|DocValuesType
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|BooleanClause
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|BooleanQuery
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|DocIdSetIterator
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|FieldCache
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|IndexSearcher
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|ScoreDoc
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|TermQuery
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|TopDocs
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|Directory
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|BytesRef
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|BytesRefHash
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|FixedBitSet
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|LuceneTestCase
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|_TestUtil
import|;
end_import
begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Assume
import|;
end_import
begin_comment
comment|/**  *   * Tests DocValues integration into IndexWriter& Codecs  *   */
end_comment
begin_class
DECL|class|TestDocValuesIndexing
specifier|public
class|class
name|TestDocValuesIndexing
extends|extends
name|LuceneTestCase
block|{
comment|/*    * - add test for multi segment case with deletes    * - add multithreaded tests / integrate into stress indexing?    */
comment|/*    * Simple test case to show how to use the API    */
DECL|method|testDocValuesSimple
specifier|public
name|void
name|testDocValuesSimple
parameter_list|()
throws|throws
name|IOException
block|{
name|Directory
name|dir
init|=
name|newDirectory
argument_list|()
decl_stmt|;
name|IndexWriter
name|writer
init|=
operator|new
name|IndexWriter
argument_list|(
name|dir
argument_list|,
name|writerConfig
argument_list|(
literal|false
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|5
condition|;
name|i
operator|++
control|)
block|{
name|Document
name|doc
init|=
operator|new
name|Document
argument_list|()
decl_stmt|;
name|doc
operator|.
name|add
argument_list|(
operator|new
name|NumericDocValuesField
argument_list|(
literal|"docId"
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|doc
operator|.
name|add
argument_list|(
operator|new
name|TextField
argument_list|(
literal|"docId"
argument_list|,
literal|""
operator|+
name|i
argument_list|,
name|Field
operator|.
name|Store
operator|.
name|NO
argument_list|)
argument_list|)
expr_stmt|;
name|writer
operator|.
name|addDocument
argument_list|(
name|doc
argument_list|)
expr_stmt|;
block|}
name|writer
operator|.
name|commit
argument_list|()
expr_stmt|;
name|writer
operator|.
name|forceMerge
argument_list|(
literal|1
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|writer
operator|.
name|close
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|DirectoryReader
name|reader
init|=
name|DirectoryReader
operator|.
name|open
argument_list|(
name|dir
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|reader
operator|.
name|leaves
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|IndexSearcher
name|searcher
init|=
operator|new
name|IndexSearcher
argument_list|(
name|reader
argument_list|)
decl_stmt|;
name|BooleanQuery
name|query
init|=
operator|new
name|BooleanQuery
argument_list|()
decl_stmt|;
name|query
operator|.
name|add
argument_list|(
operator|new
name|TermQuery
argument_list|(
operator|new
name|Term
argument_list|(
literal|"docId"
argument_list|,
literal|"0"
argument_list|)
argument_list|)
argument_list|,
name|BooleanClause
operator|.
name|Occur
operator|.
name|SHOULD
argument_list|)
expr_stmt|;
name|query
operator|.
name|add
argument_list|(
operator|new
name|TermQuery
argument_list|(
operator|new
name|Term
argument_list|(
literal|"docId"
argument_list|,
literal|"1"
argument_list|)
argument_list|)
argument_list|,
name|BooleanClause
operator|.
name|Occur
operator|.
name|SHOULD
argument_list|)
expr_stmt|;
name|query
operator|.
name|add
argument_list|(
operator|new
name|TermQuery
argument_list|(
operator|new
name|Term
argument_list|(
literal|"docId"
argument_list|,
literal|"2"
argument_list|)
argument_list|)
argument_list|,
name|BooleanClause
operator|.
name|Occur
operator|.
name|SHOULD
argument_list|)
expr_stmt|;
name|query
operator|.
name|add
argument_list|(
operator|new
name|TermQuery
argument_list|(
operator|new
name|Term
argument_list|(
literal|"docId"
argument_list|,
literal|"3"
argument_list|)
argument_list|)
argument_list|,
name|BooleanClause
operator|.
name|Occur
operator|.
name|SHOULD
argument_list|)
expr_stmt|;
name|query
operator|.
name|add
argument_list|(
operator|new
name|TermQuery
argument_list|(
operator|new
name|Term
argument_list|(
literal|"docId"
argument_list|,
literal|"4"
argument_list|)
argument_list|)
argument_list|,
name|BooleanClause
operator|.
name|Occur
operator|.
name|SHOULD
argument_list|)
expr_stmt|;
name|TopDocs
name|search
init|=
name|searcher
operator|.
name|search
argument_list|(
name|query
argument_list|,
literal|10
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|5
argument_list|,
name|search
operator|.
name|totalHits
argument_list|)
expr_stmt|;
name|ScoreDoc
index|[]
name|scoreDocs
init|=
name|search
operator|.
name|scoreDocs
decl_stmt|;
name|NumericDocValues
name|docValues
init|=
name|numeric
argument_list|(
name|reader
argument_list|,
literal|"docId"
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|scoreDocs
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|assertEquals
argument_list|(
name|i
argument_list|,
name|scoreDocs
index|[
name|i
index|]
operator|.
name|doc
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|i
argument_list|,
name|docValues
operator|.
name|get
argument_list|(
name|scoreDocs
index|[
name|i
index|]
operator|.
name|doc
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|reader
operator|.
name|close
argument_list|()
expr_stmt|;
name|dir
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
DECL|method|testIndexBytesNoDeletes
specifier|public
name|void
name|testIndexBytesNoDeletes
parameter_list|()
throws|throws
name|IOException
block|{
name|runTestIndexBytes
argument_list|(
name|writerConfig
argument_list|(
name|random
argument_list|()
operator|.
name|nextBoolean
argument_list|()
argument_list|)
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
DECL|method|testIndexBytesDeletes
specifier|public
name|void
name|testIndexBytesDeletes
parameter_list|()
throws|throws
name|IOException
block|{
name|runTestIndexBytes
argument_list|(
name|writerConfig
argument_list|(
name|random
argument_list|()
operator|.
name|nextBoolean
argument_list|()
argument_list|)
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
DECL|method|testIndexNumericsNoDeletes
specifier|public
name|void
name|testIndexNumericsNoDeletes
parameter_list|()
throws|throws
name|IOException
block|{
name|runTestNumerics
argument_list|(
name|writerConfig
argument_list|(
name|random
argument_list|()
operator|.
name|nextBoolean
argument_list|()
argument_list|)
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
DECL|method|testIndexNumericsDeletes
specifier|public
name|void
name|testIndexNumericsDeletes
parameter_list|()
throws|throws
name|IOException
block|{
name|runTestNumerics
argument_list|(
name|writerConfig
argument_list|(
name|random
argument_list|()
operator|.
name|nextBoolean
argument_list|()
argument_list|)
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
DECL|method|testAddIndexes
specifier|public
name|void
name|testAddIndexes
parameter_list|()
throws|throws
name|IOException
block|{
name|Directory
name|d1
init|=
name|newDirectory
argument_list|()
decl_stmt|;
name|RandomIndexWriter
name|w
init|=
operator|new
name|RandomIndexWriter
argument_list|(
name|random
argument_list|()
argument_list|,
name|d1
argument_list|)
decl_stmt|;
name|Document
name|doc
init|=
operator|new
name|Document
argument_list|()
decl_stmt|;
name|doc
operator|.
name|add
argument_list|(
name|newStringField
argument_list|(
literal|"id"
argument_list|,
literal|"1"
argument_list|,
name|Field
operator|.
name|Store
operator|.
name|YES
argument_list|)
argument_list|)
expr_stmt|;
name|doc
operator|.
name|add
argument_list|(
operator|new
name|NumericDocValuesField
argument_list|(
literal|"dv"
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|w
operator|.
name|addDocument
argument_list|(
name|doc
argument_list|)
expr_stmt|;
name|IndexReader
name|r1
init|=
name|w
operator|.
name|getReader
argument_list|()
decl_stmt|;
name|w
operator|.
name|close
argument_list|()
expr_stmt|;
name|Directory
name|d2
init|=
name|newDirectory
argument_list|()
decl_stmt|;
name|w
operator|=
operator|new
name|RandomIndexWriter
argument_list|(
name|random
argument_list|()
argument_list|,
name|d2
argument_list|)
expr_stmt|;
name|doc
operator|=
operator|new
name|Document
argument_list|()
expr_stmt|;
name|doc
operator|.
name|add
argument_list|(
name|newStringField
argument_list|(
literal|"id"
argument_list|,
literal|"2"
argument_list|,
name|Field
operator|.
name|Store
operator|.
name|YES
argument_list|)
argument_list|)
expr_stmt|;
name|doc
operator|.
name|add
argument_list|(
operator|new
name|NumericDocValuesField
argument_list|(
literal|"dv"
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|w
operator|.
name|addDocument
argument_list|(
name|doc
argument_list|)
expr_stmt|;
name|IndexReader
name|r2
init|=
name|w
operator|.
name|getReader
argument_list|()
decl_stmt|;
name|w
operator|.
name|close
argument_list|()
expr_stmt|;
name|Directory
name|d3
init|=
name|newDirectory
argument_list|()
decl_stmt|;
name|w
operator|=
operator|new
name|RandomIndexWriter
argument_list|(
name|random
argument_list|()
argument_list|,
name|d3
argument_list|)
expr_stmt|;
name|w
operator|.
name|addIndexes
argument_list|(
name|SlowCompositeReaderWrapper
operator|.
name|wrap
argument_list|(
name|r1
argument_list|)
argument_list|,
name|SlowCompositeReaderWrapper
operator|.
name|wrap
argument_list|(
name|r2
argument_list|)
argument_list|)
expr_stmt|;
name|r1
operator|.
name|close
argument_list|()
expr_stmt|;
name|d1
operator|.
name|close
argument_list|()
expr_stmt|;
name|r2
operator|.
name|close
argument_list|()
expr_stmt|;
name|d2
operator|.
name|close
argument_list|()
expr_stmt|;
name|w
operator|.
name|forceMerge
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|DirectoryReader
name|r3
init|=
name|w
operator|.
name|getReader
argument_list|()
decl_stmt|;
name|w
operator|.
name|close
argument_list|()
expr_stmt|;
name|AtomicReader
name|sr
init|=
name|getOnlySegmentReader
argument_list|(
name|r3
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|2
argument_list|,
name|sr
operator|.
name|numDocs
argument_list|()
argument_list|)
expr_stmt|;
name|NumericDocValues
name|docValues
init|=
name|sr
operator|.
name|getNumericDocValues
argument_list|(
literal|"dv"
argument_list|)
decl_stmt|;
name|assertNotNull
argument_list|(
name|docValues
argument_list|)
expr_stmt|;
name|r3
operator|.
name|close
argument_list|()
expr_stmt|;
name|d3
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
DECL|method|testAddIndexesRandom
specifier|public
name|void
name|testAddIndexesRandom
parameter_list|()
throws|throws
name|IOException
block|{
comment|//nocommit convert
comment|/*     int valuesPerIndex = 10;     List<Type> values = Arrays.asList(Type.values());     Collections.shuffle(values, random());     Type first = values.get(0);     Type second = values.get(1);     // index first index     Directory d_1 = newDirectory();     IndexWriter w_1 = new IndexWriter(d_1, writerConfig(random().nextBoolean()));     indexValues(w_1, valuesPerIndex, first, values, false, 7);     w_1.commit();     assertEquals(valuesPerIndex, w_1.maxDoc());     _TestUtil.checkIndex(d_1);      // index second index     Directory d_2 = newDirectory();     IndexWriter w_2 = new IndexWriter(d_2, writerConfig(random().nextBoolean()));     indexValues(w_2, valuesPerIndex, second, values, false, 7);     w_2.commit();     assertEquals(valuesPerIndex, w_2.maxDoc());     _TestUtil.checkIndex(d_2);      Directory target = newDirectory();     IndexWriter w = new IndexWriter(target, writerConfig(random().nextBoolean()));     DirectoryReader r_1 = DirectoryReader.open(w_1, true);     DirectoryReader r_2 = DirectoryReader.open(w_2, true);     if (random().nextBoolean()) {       w.addIndexes(d_1, d_2);     } else {       w.addIndexes(r_1, r_2);     }     w.forceMerge(1, true);     w.commit();          _TestUtil.checkIndex(target);     assertEquals(valuesPerIndex * 2, w.maxDoc());      // check values          DirectoryReader merged = DirectoryReader.open(w, true);     Source source_1 = getSource(getDocValues(r_1, first.name()));     Source source_2 = getSource(getDocValues(r_2, second.name()));     Source source_1_merged = getSource(getDocValues(merged, first.name()));     Source source_2_merged = getSource(getDocValues(merged, second         .name()));     for (int i = 0; i< r_1.maxDoc(); i++) {       switch (first) {       case BYTES_FIXED_DEREF:       case BYTES_FIXED_STRAIGHT:       case BYTES_VAR_DEREF:       case BYTES_VAR_STRAIGHT:       case BYTES_FIXED_SORTED:       case BYTES_VAR_SORTED:         assertEquals(source_1.getBytes(i, new BytesRef()),             source_1_merged.getBytes(i, new BytesRef()));         break;       case FIXED_INTS_16:       case FIXED_INTS_32:       case FIXED_INTS_64:       case FIXED_INTS_8:       case VAR_INTS:         assertEquals(source_1.getInt(i), source_1_merged.getInt(i));         break;       case FLOAT_32:       case FLOAT_64:         assertEquals(source_1.getFloat(i), source_1_merged.getFloat(i), 0.0d);         break;       default:         fail("unkonwn " + first);       }     }      for (int i = r_1.maxDoc(); i< merged.maxDoc(); i++) {       switch (second) {       case BYTES_FIXED_DEREF:       case BYTES_FIXED_STRAIGHT:       case BYTES_VAR_DEREF:       case BYTES_VAR_STRAIGHT:       case BYTES_FIXED_SORTED:       case BYTES_VAR_SORTED:         assertEquals(source_2.getBytes(i - r_1.maxDoc(), new BytesRef()),             source_2_merged.getBytes(i, new BytesRef()));         break;       case FIXED_INTS_16:       case FIXED_INTS_32:       case FIXED_INTS_64:       case FIXED_INTS_8:       case VAR_INTS:         assertEquals(source_2.getInt(i - r_1.maxDoc()),             source_2_merged.getInt(i));         break;       case FLOAT_32:       case FLOAT_64:         assertEquals(source_2.getFloat(i - r_1.maxDoc()),             source_2_merged.getFloat(i), 0.0d);         break;       default:         fail("unkonwn " + first);       }     }     // close resources     r_1.close();     r_2.close();     merged.close();     w_1.close(true);     w_2.close(true);     w.close(true);     d_1.close();     d_2.close();     target.close();     */
block|}
DECL|method|writerConfig
specifier|private
name|IndexWriterConfig
name|writerConfig
parameter_list|(
name|boolean
name|useCompoundFile
parameter_list|)
block|{
specifier|final
name|IndexWriterConfig
name|cfg
init|=
name|newIndexWriterConfig
argument_list|(
name|TEST_VERSION_CURRENT
argument_list|,
operator|new
name|MockAnalyzer
argument_list|(
name|random
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|cfg
operator|.
name|setMergePolicy
argument_list|(
name|newLogMergePolicy
argument_list|(
name|random
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|LogMergePolicy
name|policy
init|=
operator|new
name|LogDocMergePolicy
argument_list|()
decl_stmt|;
name|cfg
operator|.
name|setMergePolicy
argument_list|(
name|policy
argument_list|)
expr_stmt|;
name|policy
operator|.
name|setUseCompoundFile
argument_list|(
name|useCompoundFile
argument_list|)
expr_stmt|;
return|return
name|cfg
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"fallthrough"
argument_list|)
DECL|method|runTestNumerics
specifier|public
name|void
name|runTestNumerics
parameter_list|(
name|IndexWriterConfig
name|cfg
parameter_list|,
name|boolean
name|withDeletions
parameter_list|)
throws|throws
name|IOException
block|{
comment|//nocommit convert
comment|/*     Directory d = newDirectory();     IndexWriter w = new IndexWriter(d, cfg);     final int numValues = 50 + atLeast(10);     final List<Type> numVariantList = new ArrayList<Type>(NUMERICS);      // run in random order to test if fill works correctly during merges     Collections.shuffle(numVariantList, random());     for (Type val : numVariantList) {       FixedBitSet deleted = indexValues(w, numValues, val, numVariantList,           withDeletions, 7);       List<Closeable> closeables = new ArrayList<Closeable>();       DirectoryReader r = DirectoryReader.open(w, true);       final int numRemainingValues = numValues - deleted.cardinality();       final int base = r.numDocs() - numRemainingValues;       // for FIXED_INTS_8 we use value mod 128 - to enable testing in        // one go we simply use numValues as the mod for all other INT types       int mod = numValues;       switch (val) {       case FIXED_INTS_8:         mod = 128;       case FIXED_INTS_16:       case FIXED_INTS_32:       case FIXED_INTS_64:       case VAR_INTS: {         DocValues intsReader = getDocValues(r, val.name());         assertNotNull(intsReader);          Source ints = getSource(intsReader);          for (int i = 0; i< base; i++) {           long value = ints.getInt(i);           assertEquals("index " + i, 0, value);         }          int expected = 0;         for (int i = base; i< r.numDocs(); i++, expected++) {           while (deleted.get(expected)) {             expected++;           }           assertEquals(val + " mod: " + mod + " index: " +  i, expected%mod, ints.getInt(i));         }       }         break;       case FLOAT_32:       case FLOAT_64: {         DocValues floatReader = getDocValues(r, val.name());         assertNotNull(floatReader);         Source floats = getSource(floatReader);         for (int i = 0; i< base; i++) {           double value = floats.getFloat(i);           assertEquals(val + " failed for doc: " + i + " base: " + base,               0.0d, value, 0.0d);         }         int expected = 0;         for (int i = base; i< r.numDocs(); i++, expected++) {           while (deleted.get(expected)) {             expected++;           }           assertEquals("index " + i, 2.0 * expected, floats.getFloat(i),               0.00001);         }       }         break;       default:         fail("unexpected value " + val);       }        closeables.add(r);       for (Closeable toClose : closeables) {         toClose.close();       }     }     w.close();     d.close();     */
block|}
DECL|method|runTestIndexBytes
specifier|public
name|void
name|runTestIndexBytes
parameter_list|(
name|IndexWriterConfig
name|cfg
parameter_list|,
name|boolean
name|withDeletions
parameter_list|)
throws|throws
name|IOException
block|{
comment|/* nocommit convert     final Directory d = newDirectory();     IndexWriter w = new IndexWriter(d, cfg);     final List<Type> byteVariantList = new ArrayList<Type>(BYTES);     // run in random order to test if fill works correctly during merges     Collections.shuffle(byteVariantList, random());     final int numValues = 50 + atLeast(10);     for (Type byteIndexValue : byteVariantList) {       List<Closeable> closeables = new ArrayList<Closeable>();       final int bytesSize = 1 + atLeast(50);       FixedBitSet deleted = indexValues(w, numValues, byteIndexValue,           byteVariantList, withDeletions, bytesSize);       final DirectoryReader r = DirectoryReader.open(w, withDeletions);       assertEquals(0, r.numDeletedDocs());       final int numRemainingValues = numValues - deleted.cardinality();       final int base = r.numDocs() - numRemainingValues;       DocValues bytesReader = getDocValues(r, byteIndexValue.name());       assertNotNull("field " + byteIndexValue.name()           + " returned null reader - maybe merged failed", bytesReader);       Source bytes = getSource(bytesReader);       byte upto = 0;        // test the filled up slots for correctness       for (int i = 0; i< base; i++) {          BytesRef br = bytes.getBytes(i, new BytesRef());         String msg = " field: " + byteIndexValue.name() + " at index: " + i             + " base: " + base + " numDocs:" + r.numDocs();         switch (byteIndexValue) {         case BYTES_VAR_STRAIGHT:         case BYTES_FIXED_STRAIGHT:         case BYTES_FIXED_DEREF:         case BYTES_FIXED_SORTED:           // fixed straight returns bytesref with zero bytes all of fixed           // length           assertNotNull("expected none null - " + msg, br);           if (br.length != 0) {             assertEquals("expected zero bytes of length " + bytesSize + " - "                 + msg + br.utf8ToString(), bytesSize, br.length);             for (int j = 0; j< br.length; j++) {               assertEquals("Byte at index " + j + " doesn't match - " + msg, 0,                   br.bytes[br.offset + j]);             }           }           break;         default:           assertNotNull("expected none null - " + msg, br);           assertEquals(byteIndexValue + "", 0, br.length);           // make sure we advance at least until base         }       }        // test the actual doc values added in this iteration       assertEquals(base + numRemainingValues, r.numDocs());       int v = 0;       for (int i = base; i< r.numDocs(); i++) {         String msg = " field: " + byteIndexValue.name() + " at index: " + i             + " base: " + base + " numDocs:" + r.numDocs() + " bytesSize: "             + bytesSize + " src: " + bytes;         while (withDeletions&& deleted.get(v++)) {           upto += bytesSize;         }         BytesRef br = bytes.getBytes(i, new BytesRef());         assertTrue(msg, br.length> 0);         for (int j = 0; j< br.length; j++, upto++) {           if (!(br.bytes.length> br.offset + j))             br = bytes.getBytes(i, new BytesRef());           assertTrue("BytesRef index exceeded [" + msg + "] offset: "               + br.offset + " length: " + br.length + " index: "               + (br.offset + j), br.bytes.length> br.offset + j);           assertEquals("SourceRef Byte at index " + j + " doesn't match - "               + msg, upto, br.bytes[br.offset + j]);         }       }        // clean up       closeables.add(r);       for (Closeable toClose : closeables) {         toClose.close();       }     }      w.close();     d.close();     */
block|}
DECL|method|testGetArrayNumerics
specifier|public
name|void
name|testGetArrayNumerics
parameter_list|()
throws|throws
name|IOException
block|{
comment|/* nocommit conver     Directory d = newDirectory();     IndexWriterConfig cfg = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));     IndexWriter w = new IndexWriter(d, cfg);     final int numValues = 50 + atLeast(10);     final List<Type> numVariantList = new ArrayList<Type>(NUMERICS);     Collections.shuffle(numVariantList, random());     for (Type val : numVariantList) {       indexValues(w, numValues, val, numVariantList,           false, 7);       DirectoryReader r = DirectoryReader.open(w, true);       DocValues docValues = getDocValues(r, val.name());       assertNotNull(docValues);       // make sure we don't get a direct source since they don't support getArray()       Source source = docValues.getSource();       switch (source.getType()) {       case FIXED_INTS_8:       {         assertTrue(source.hasArray());         byte[] values = (byte[]) source.getArray();         for (int i = 0; i< numValues; i++) {           assertEquals((long)values[i], source.getInt(i));         }       }       break;       case FIXED_INTS_16:       {         assertTrue(source.hasArray());         short[] values = (short[]) source.getArray();         for (int i = 0; i< numValues; i++) {           assertEquals((long)values[i], source.getInt(i));         }       }       break;       case FIXED_INTS_32:       {         assertTrue(source.hasArray());         int[] values = (int[]) source.getArray();         for (int i = 0; i< numValues; i++) {           assertEquals((long)values[i], source.getInt(i));         }       }       break;       case FIXED_INTS_64:       {         assertTrue(source.hasArray());         long[] values = (long[]) source.getArray();         for (int i = 0; i< numValues; i++) {           assertEquals(values[i], source.getInt(i));         }       }       break;       case VAR_INTS:         assertFalse(source.hasArray());         break;       case FLOAT_32:       {         assertTrue(source.hasArray());         float[] values = (float[]) source.getArray();         for (int i = 0; i< numValues; i++) {           assertEquals((double)values[i], source.getFloat(i), 0.0d);         }       }       break;       case FLOAT_64:       {         assertTrue(source.hasArray());         double[] values = (double[]) source.getArray();         for (int i = 0; i< numValues; i++) {           assertEquals(values[i], source.getFloat(i), 0.0d);         }       }         break;       default:         fail("unexpected value " + source.getType());       }       r.close();     }     w.close();     d.close();     */
block|}
DECL|method|testGetArrayBytes
specifier|public
name|void
name|testGetArrayBytes
parameter_list|()
throws|throws
name|IOException
block|{
comment|/* nocommit convert     Directory d = newDirectory();     IndexWriterConfig cfg = newIndexWriterConfig(TEST_VERSION_CURRENT,         new MockAnalyzer(random()));     IndexWriter w = new IndexWriter(d, cfg);     final int numValues = 50 + atLeast(10);     // only single byte fixed straight supports getArray()     indexValues(w, numValues, Type.BYTES_FIXED_STRAIGHT, null, false, 1);     DirectoryReader r = DirectoryReader.open(w, true);     DocValues docValues = getDocValues(r, Type.BYTES_FIXED_STRAIGHT.name());     assertNotNull(docValues);     // make sure we don't get a direct source since they don't support     // getArray()     Source source = docValues.getSource();      switch (source.getType()) {     case BYTES_FIXED_STRAIGHT: {       BytesRef ref = new BytesRef();       if (source.hasArray()) {         byte[] values = (byte[]) source.getArray();         for (int i = 0; i< numValues; i++) {           source.getBytes(i, ref);           assertEquals(1, ref.length);           assertEquals(values[i], ref.bytes[ref.offset]);         }       }     }       break;     default:       fail("unexpected value " + source.getType());     }     r.close();     w.close();     d.close();     */
block|}
comment|/* Nocommit convert all this    private static EnumSet<Type> BYTES = EnumSet.of(Type.BYTES_FIXED_DEREF,       Type.BYTES_FIXED_STRAIGHT, Type.BYTES_VAR_DEREF,       Type.BYTES_VAR_STRAIGHT, Type.BYTES_FIXED_SORTED, Type.BYTES_VAR_SORTED);    private static EnumSet<Type> NUMERICS = EnumSet.of(Type.VAR_INTS,       Type.FIXED_INTS_16, Type.FIXED_INTS_32,       Type.FIXED_INTS_64,        Type.FIXED_INTS_8,       Type.FLOAT_32,       Type.FLOAT_64);    private FixedBitSet indexValues(IndexWriter w, int numValues, Type valueType,       List<Type> valueVarList, boolean withDeletions, int bytesSize)       throws IOException {     final boolean isNumeric = NUMERICS.contains(valueType);     FixedBitSet deleted = new FixedBitSet(numValues);     Document doc = new Document();     final Field valField;     if (isNumeric) {       switch (valueType) {       case VAR_INTS:         valField = new PackedLongDocValuesField(valueType.name(), (long) 0);         break;       case FIXED_INTS_16:         valField = new ShortDocValuesField(valueType.name(), (short) 0);         break;       case FIXED_INTS_32:         valField = new IntDocValuesField(valueType.name(), 0);         break;       case FIXED_INTS_64:         valField = new LongDocValuesField(valueType.name(), (long) 0);         break;       case FIXED_INTS_8:         valField = new ByteDocValuesField(valueType.name(), (byte) 0);         break;       case FLOAT_32:         valField = new FloatDocValuesField(valueType.name(), (float) 0);         break;       case FLOAT_64:         valField = new DoubleDocValuesField(valueType.name(), (double) 0);         break;       default:         valField = null;         fail("unhandled case");       }     } else {       switch (valueType) {       case BYTES_FIXED_STRAIGHT:         valField = new StraightBytesDocValuesField(valueType.name(), new BytesRef(), true);         break;       case BYTES_VAR_STRAIGHT:         valField = new StraightBytesDocValuesField(valueType.name(), new BytesRef(), false);         break;       case BYTES_FIXED_DEREF:         valField = new DerefBytesDocValuesField(valueType.name(), new BytesRef(), true);         break;       case BYTES_VAR_DEREF:         valField = new DerefBytesDocValuesField(valueType.name(), new BytesRef(), false);         break;       case BYTES_FIXED_SORTED:         valField = new SortedBytesDocValuesField(valueType.name(), new BytesRef(), true);         break;       case BYTES_VAR_SORTED:         valField = new SortedBytesDocValuesField(valueType.name(), new BytesRef(), false);         break;       default:         valField = null;         fail("unhandled case");       }     }     doc.add(valField);     final BytesRef bytesRef = new BytesRef();      final String idBase = valueType.name() + "_";     final byte[] b = new byte[bytesSize];     if (bytesRef != null) {       bytesRef.bytes = b;       bytesRef.length = b.length;       bytesRef.offset = 0;     }     byte upto = 0;     for (int i = 0; i< numValues; i++) {       if (isNumeric) {         switch (valueType) {         case VAR_INTS:           valField.setLongValue((long)i);           break;         case FIXED_INTS_16:           valField.setShortValue((short)i);           break;         case FIXED_INTS_32:           valField.setIntValue(i);           break;         case FIXED_INTS_64:           valField.setLongValue((long)i);           break;         case FIXED_INTS_8:           valField.setByteValue((byte)(0xFF& (i % 128)));           break;         case FLOAT_32:           valField.setFloatValue(2.0f * i);           break;         case FLOAT_64:           valField.setDoubleValue(2.0d * i);           break;         default:           fail("unexpected value " + valueType);         }       } else {         for (int j = 0; j< b.length; j++) {           b[j] = upto++;         }         if (bytesRef != null) {           valField.setBytesValue(bytesRef);         }       }       doc.removeFields("id");       doc.add(new StringField("id", idBase + i, Field.Store.YES));       w.addDocument(doc);        if (i % 7 == 0) {         if (withDeletions&& random().nextBoolean()) {           Type val = valueVarList.get(random().nextInt(1 + valueVarList               .indexOf(valueType)));           final int randInt = val == valueType ? random().nextInt(1 + i) : random()               .nextInt(numValues);           w.deleteDocuments(new Term("id", val.name() + "_" + randInt));           if (val == valueType) {             deleted.set(randInt);           }         }         if (random().nextInt(10) == 0) {           w.commit();         }       }     }     w.commit();      // TODO test multi seg with deletions     if (withDeletions || random().nextBoolean()) {       w.forceMerge(1, true);     }     return deleted;   }*/
DECL|method|testMultiValuedDocValuesField
specifier|public
name|void
name|testMultiValuedDocValuesField
parameter_list|()
throws|throws
name|Exception
block|{
name|Directory
name|d
init|=
name|newDirectory
argument_list|()
decl_stmt|;
name|RandomIndexWriter
name|w
init|=
operator|new
name|RandomIndexWriter
argument_list|(
name|random
argument_list|()
argument_list|,
name|d
argument_list|)
decl_stmt|;
name|Document
name|doc
init|=
operator|new
name|Document
argument_list|()
decl_stmt|;
name|Field
name|f
init|=
operator|new
name|NumericDocValuesField
argument_list|(
literal|"field"
argument_list|,
literal|17
argument_list|)
decl_stmt|;
comment|// Index doc values are single-valued so we should not
comment|// be able to add same field more than once:
name|doc
operator|.
name|add
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|doc
operator|.
name|add
argument_list|(
name|f
argument_list|)
expr_stmt|;
try|try
block|{
name|w
operator|.
name|addDocument
argument_list|(
name|doc
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"didn't hit expected exception"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|iae
parameter_list|)
block|{
comment|// expected
block|}
name|doc
operator|=
operator|new
name|Document
argument_list|()
expr_stmt|;
name|doc
operator|.
name|add
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|w
operator|.
name|addDocument
argument_list|(
name|doc
argument_list|)
expr_stmt|;
name|w
operator|.
name|forceMerge
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|DirectoryReader
name|r
init|=
name|w
operator|.
name|getReader
argument_list|()
decl_stmt|;
name|w
operator|.
name|close
argument_list|()
expr_stmt|;
name|assertEquals
argument_list|(
literal|17
argument_list|,
name|FieldCache
operator|.
name|DEFAULT
operator|.
name|getInts
argument_list|(
name|getOnlySegmentReader
argument_list|(
name|r
argument_list|)
argument_list|,
literal|"field"
argument_list|,
literal|false
argument_list|)
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|r
operator|.
name|close
argument_list|()
expr_stmt|;
name|d
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
DECL|method|testDifferentTypedDocValuesField
specifier|public
name|void
name|testDifferentTypedDocValuesField
parameter_list|()
throws|throws
name|Exception
block|{
name|Directory
name|d
init|=
name|newDirectory
argument_list|()
decl_stmt|;
name|RandomIndexWriter
name|w
init|=
operator|new
name|RandomIndexWriter
argument_list|(
name|random
argument_list|()
argument_list|,
name|d
argument_list|)
decl_stmt|;
name|Document
name|doc
init|=
operator|new
name|Document
argument_list|()
decl_stmt|;
comment|// Index doc values are single-valued so we should not
comment|// be able to add same field more than once:
name|Field
name|f
decl_stmt|;
name|doc
operator|.
name|add
argument_list|(
name|f
operator|=
operator|new
name|NumericDocValuesField
argument_list|(
literal|"field"
argument_list|,
literal|17
argument_list|)
argument_list|)
expr_stmt|;
name|doc
operator|.
name|add
argument_list|(
operator|new
name|BinaryDocValuesField
argument_list|(
literal|"field"
argument_list|,
operator|new
name|BytesRef
argument_list|(
literal|"blah"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
try|try
block|{
name|w
operator|.
name|addDocument
argument_list|(
name|doc
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"didn't hit expected exception"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|iae
parameter_list|)
block|{
comment|// expected
block|}
name|doc
operator|=
operator|new
name|Document
argument_list|()
expr_stmt|;
name|doc
operator|.
name|add
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|w
operator|.
name|addDocument
argument_list|(
name|doc
argument_list|)
expr_stmt|;
name|w
operator|.
name|forceMerge
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|DirectoryReader
name|r
init|=
name|w
operator|.
name|getReader
argument_list|()
decl_stmt|;
name|w
operator|.
name|close
argument_list|()
expr_stmt|;
name|assertEquals
argument_list|(
literal|17
argument_list|,
name|FieldCache
operator|.
name|DEFAULT
operator|.
name|getInts
argument_list|(
name|getOnlySegmentReader
argument_list|(
name|r
argument_list|)
argument_list|,
literal|"field"
argument_list|,
literal|false
argument_list|)
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|r
operator|.
name|close
argument_list|()
expr_stmt|;
name|d
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
DECL|method|testDifferentTypedDocValuesField2
specifier|public
name|void
name|testDifferentTypedDocValuesField2
parameter_list|()
throws|throws
name|Exception
block|{
name|Directory
name|d
init|=
name|newDirectory
argument_list|()
decl_stmt|;
name|RandomIndexWriter
name|w
init|=
operator|new
name|RandomIndexWriter
argument_list|(
name|random
argument_list|()
argument_list|,
name|d
argument_list|)
decl_stmt|;
name|Document
name|doc
init|=
operator|new
name|Document
argument_list|()
decl_stmt|;
comment|// Index doc values are single-valued so we should not
comment|// be able to add same field more than once:
name|Field
name|f
init|=
operator|new
name|NumericDocValuesField
argument_list|(
literal|"field"
argument_list|,
literal|17
argument_list|)
decl_stmt|;
name|doc
operator|.
name|add
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|doc
operator|.
name|add
argument_list|(
operator|new
name|SortedDocValuesField
argument_list|(
literal|"field"
argument_list|,
operator|new
name|BytesRef
argument_list|(
literal|"hello"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
try|try
block|{
name|w
operator|.
name|addDocument
argument_list|(
name|doc
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"didn't hit expected exception"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|iae
parameter_list|)
block|{
comment|// expected
block|}
name|doc
operator|=
operator|new
name|Document
argument_list|()
expr_stmt|;
name|doc
operator|.
name|add
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|w
operator|.
name|addDocument
argument_list|(
name|doc
argument_list|)
expr_stmt|;
name|w
operator|.
name|forceMerge
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|DirectoryReader
name|r
init|=
name|w
operator|.
name|getReader
argument_list|()
decl_stmt|;
name|assertEquals
argument_list|(
literal|17
argument_list|,
name|getOnlySegmentReader
argument_list|(
name|r
argument_list|)
operator|.
name|getNumericDocValues
argument_list|(
literal|"field"
argument_list|)
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|r
operator|.
name|close
argument_list|()
expr_stmt|;
name|w
operator|.
name|close
argument_list|()
expr_stmt|;
name|d
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
DECL|method|testSortedBytes
specifier|public
name|void
name|testSortedBytes
parameter_list|()
throws|throws
name|IOException
block|{
name|DocValuesType
name|type
init|=
name|DocValuesType
operator|.
name|SORTED
decl_stmt|;
specifier|final
name|Directory
name|d
init|=
name|newDirectory
argument_list|()
decl_stmt|;
name|IndexWriterConfig
name|cfg
init|=
name|newIndexWriterConfig
argument_list|(
name|TEST_VERSION_CURRENT
argument_list|,
operator|new
name|MockAnalyzer
argument_list|(
name|random
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|IndexWriter
name|w
init|=
operator|new
name|IndexWriter
argument_list|(
name|d
argument_list|,
name|cfg
argument_list|)
decl_stmt|;
name|int
name|numDocs
init|=
name|atLeast
argument_list|(
literal|100
argument_list|)
decl_stmt|;
name|BytesRefHash
name|hash
init|=
operator|new
name|BytesRefHash
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|docToString
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|int
name|len
init|=
literal|1
operator|+
name|random
argument_list|()
operator|.
name|nextInt
argument_list|(
literal|50
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numDocs
condition|;
name|i
operator|++
control|)
block|{
name|Document
name|doc
init|=
operator|new
name|Document
argument_list|()
decl_stmt|;
name|doc
operator|.
name|add
argument_list|(
name|newTextField
argument_list|(
literal|"id"
argument_list|,
literal|""
operator|+
name|i
argument_list|,
name|Field
operator|.
name|Store
operator|.
name|YES
argument_list|)
argument_list|)
expr_stmt|;
name|String
name|string
init|=
name|_TestUtil
operator|.
name|randomRealisticUnicodeString
argument_list|(
name|random
argument_list|()
argument_list|,
literal|1
argument_list|,
name|len
argument_list|)
decl_stmt|;
name|BytesRef
name|br
init|=
operator|new
name|BytesRef
argument_list|(
name|string
argument_list|)
decl_stmt|;
name|doc
operator|.
name|add
argument_list|(
operator|new
name|SortedDocValuesField
argument_list|(
literal|"field"
argument_list|,
name|br
argument_list|)
argument_list|)
expr_stmt|;
name|hash
operator|.
name|add
argument_list|(
name|br
argument_list|)
expr_stmt|;
name|docToString
operator|.
name|put
argument_list|(
literal|""
operator|+
name|i
argument_list|,
name|string
argument_list|)
expr_stmt|;
name|w
operator|.
name|addDocument
argument_list|(
name|doc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rarely
argument_list|()
condition|)
block|{
name|w
operator|.
name|commit
argument_list|()
expr_stmt|;
block|}
name|int
name|numDocsNoValue
init|=
name|atLeast
argument_list|(
literal|10
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numDocsNoValue
condition|;
name|i
operator|++
control|)
block|{
name|Document
name|doc
init|=
operator|new
name|Document
argument_list|()
decl_stmt|;
name|doc
operator|.
name|add
argument_list|(
name|newTextField
argument_list|(
literal|"id"
argument_list|,
literal|"noValue"
argument_list|,
name|Field
operator|.
name|Store
operator|.
name|YES
argument_list|)
argument_list|)
expr_stmt|;
name|w
operator|.
name|addDocument
argument_list|(
name|doc
argument_list|)
expr_stmt|;
block|}
name|BytesRef
name|bytesRef
init|=
operator|new
name|BytesRef
argument_list|()
decl_stmt|;
name|hash
operator|.
name|add
argument_list|(
name|bytesRef
argument_list|)
expr_stmt|;
comment|// add empty value for the gaps
if|if
condition|(
name|rarely
argument_list|()
condition|)
block|{
name|w
operator|.
name|commit
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numDocs
condition|;
name|i
operator|++
control|)
block|{
name|Document
name|doc
init|=
operator|new
name|Document
argument_list|()
decl_stmt|;
name|String
name|id
init|=
literal|""
operator|+
name|i
operator|+
name|numDocs
decl_stmt|;
name|doc
operator|.
name|add
argument_list|(
name|newTextField
argument_list|(
literal|"id"
argument_list|,
name|id
argument_list|,
name|Field
operator|.
name|Store
operator|.
name|YES
argument_list|)
argument_list|)
expr_stmt|;
name|String
name|string
init|=
name|_TestUtil
operator|.
name|randomRealisticUnicodeString
argument_list|(
name|random
argument_list|()
argument_list|,
literal|1
argument_list|,
name|len
argument_list|)
decl_stmt|;
name|BytesRef
name|br
init|=
operator|new
name|BytesRef
argument_list|(
name|string
argument_list|)
decl_stmt|;
name|hash
operator|.
name|add
argument_list|(
name|br
argument_list|)
expr_stmt|;
name|docToString
operator|.
name|put
argument_list|(
name|id
argument_list|,
name|string
argument_list|)
expr_stmt|;
name|doc
operator|.
name|add
argument_list|(
operator|new
name|SortedDocValuesField
argument_list|(
literal|"field"
argument_list|,
name|br
argument_list|)
argument_list|)
expr_stmt|;
name|w
operator|.
name|addDocument
argument_list|(
name|doc
argument_list|)
expr_stmt|;
block|}
name|w
operator|.
name|commit
argument_list|()
expr_stmt|;
name|IndexReader
name|reader
init|=
name|w
operator|.
name|getReader
argument_list|()
decl_stmt|;
name|SortedDocValues
name|docValues
init|=
name|MultiDocValues
operator|.
name|getSortedValues
argument_list|(
name|reader
argument_list|,
literal|"field"
argument_list|)
decl_stmt|;
name|int
index|[]
name|sort
init|=
name|hash
operator|.
name|sort
argument_list|(
name|BytesRef
operator|.
name|getUTF8SortedAsUnicodeComparator
argument_list|()
argument_list|)
decl_stmt|;
name|BytesRef
name|expected
init|=
operator|new
name|BytesRef
argument_list|()
decl_stmt|;
name|BytesRef
name|actual
init|=
operator|new
name|BytesRef
argument_list|()
decl_stmt|;
name|assertEquals
argument_list|(
name|hash
operator|.
name|size
argument_list|()
argument_list|,
name|docValues
operator|.
name|getValueCount
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|hash
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|hash
operator|.
name|get
argument_list|(
name|sort
index|[
name|i
index|]
argument_list|,
name|expected
argument_list|)
expr_stmt|;
name|docValues
operator|.
name|lookupOrd
argument_list|(
name|i
argument_list|,
name|actual
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|expected
operator|.
name|utf8ToString
argument_list|()
argument_list|,
name|actual
operator|.
name|utf8ToString
argument_list|()
argument_list|)
expr_stmt|;
name|int
name|ord
init|=
name|docValues
operator|.
name|lookupTerm
argument_list|(
name|expected
argument_list|,
name|actual
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|i
argument_list|,
name|ord
argument_list|)
expr_stmt|;
block|}
name|AtomicReader
name|slowR
init|=
name|SlowCompositeReaderWrapper
operator|.
name|wrap
argument_list|(
name|reader
argument_list|)
decl_stmt|;
name|Set
argument_list|<
name|Entry
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|>
name|entrySet
init|=
name|docToString
operator|.
name|entrySet
argument_list|()
decl_stmt|;
for|for
control|(
name|Entry
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|entry
range|:
name|entrySet
control|)
block|{
name|int
name|docId
init|=
name|docId
argument_list|(
name|slowR
argument_list|,
operator|new
name|Term
argument_list|(
literal|"id"
argument_list|,
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|expected
operator|=
operator|new
name|BytesRef
argument_list|(
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
name|docValues
operator|.
name|get
argument_list|(
name|docId
argument_list|,
name|actual
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|expected
argument_list|,
name|actual
argument_list|)
expr_stmt|;
block|}
name|reader
operator|.
name|close
argument_list|()
expr_stmt|;
name|w
operator|.
name|close
argument_list|()
expr_stmt|;
name|d
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
DECL|method|docId
specifier|public
name|int
name|docId
parameter_list|(
name|AtomicReader
name|reader
parameter_list|,
name|Term
name|term
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|docFreq
init|=
name|reader
operator|.
name|docFreq
argument_list|(
name|term
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|docFreq
argument_list|)
expr_stmt|;
name|DocsEnum
name|termDocsEnum
init|=
name|reader
operator|.
name|termDocsEnum
argument_list|(
name|term
argument_list|)
decl_stmt|;
name|int
name|nextDoc
init|=
name|termDocsEnum
operator|.
name|nextDoc
argument_list|()
decl_stmt|;
name|assertEquals
argument_list|(
name|DocIdSetIterator
operator|.
name|NO_MORE_DOCS
argument_list|,
name|termDocsEnum
operator|.
name|nextDoc
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|nextDoc
return|;
block|}
DECL|method|testWithThreads
specifier|public
name|void
name|testWithThreads
parameter_list|()
throws|throws
name|Exception
block|{
name|Random
name|random
init|=
name|random
argument_list|()
decl_stmt|;
specifier|final
name|int
name|NUM_DOCS
init|=
name|atLeast
argument_list|(
literal|100
argument_list|)
decl_stmt|;
specifier|final
name|Directory
name|dir
init|=
name|newDirectory
argument_list|()
decl_stmt|;
specifier|final
name|RandomIndexWriter
name|writer
init|=
operator|new
name|RandomIndexWriter
argument_list|(
name|random
argument_list|,
name|dir
argument_list|)
decl_stmt|;
specifier|final
name|boolean
name|allowDups
init|=
name|random
operator|.
name|nextBoolean
argument_list|()
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|seen
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"TEST: NUM_DOCS="
operator|+
name|NUM_DOCS
operator|+
literal|" allowDups="
operator|+
name|allowDups
argument_list|)
expr_stmt|;
block|}
name|int
name|numDocs
init|=
literal|0
decl_stmt|;
specifier|final
name|List
argument_list|<
name|BytesRef
argument_list|>
name|docValues
init|=
operator|new
name|ArrayList
argument_list|<
name|BytesRef
argument_list|>
argument_list|()
decl_stmt|;
comment|// TODO: deletions
while|while
condition|(
name|numDocs
operator|<
name|NUM_DOCS
condition|)
block|{
specifier|final
name|String
name|s
decl_stmt|;
if|if
condition|(
name|random
operator|.
name|nextBoolean
argument_list|()
condition|)
block|{
name|s
operator|=
name|_TestUtil
operator|.
name|randomSimpleString
argument_list|(
name|random
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|s
operator|=
name|_TestUtil
operator|.
name|randomUnicodeString
argument_list|(
name|random
argument_list|)
expr_stmt|;
block|}
specifier|final
name|BytesRef
name|br
init|=
operator|new
name|BytesRef
argument_list|(
name|s
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|allowDups
condition|)
block|{
if|if
condition|(
name|seen
operator|.
name|contains
argument_list|(
name|s
argument_list|)
condition|)
block|{
continue|continue;
block|}
name|seen
operator|.
name|add
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"  "
operator|+
name|numDocs
operator|+
literal|": s="
operator|+
name|s
argument_list|)
expr_stmt|;
block|}
specifier|final
name|Document
name|doc
init|=
operator|new
name|Document
argument_list|()
decl_stmt|;
name|doc
operator|.
name|add
argument_list|(
operator|new
name|SortedDocValuesField
argument_list|(
literal|"stringdv"
argument_list|,
name|br
argument_list|)
argument_list|)
expr_stmt|;
name|doc
operator|.
name|add
argument_list|(
operator|new
name|NumericDocValuesField
argument_list|(
literal|"id"
argument_list|,
name|numDocs
argument_list|)
argument_list|)
expr_stmt|;
name|docValues
operator|.
name|add
argument_list|(
name|br
argument_list|)
expr_stmt|;
name|writer
operator|.
name|addDocument
argument_list|(
name|doc
argument_list|)
expr_stmt|;
name|numDocs
operator|++
expr_stmt|;
if|if
condition|(
name|random
operator|.
name|nextInt
argument_list|(
literal|40
argument_list|)
operator|==
literal|17
condition|)
block|{
comment|// force flush
name|writer
operator|.
name|getReader
argument_list|()
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
name|writer
operator|.
name|forceMerge
argument_list|(
literal|1
argument_list|)
expr_stmt|;
specifier|final
name|DirectoryReader
name|r
init|=
name|writer
operator|.
name|getReader
argument_list|()
decl_stmt|;
name|writer
operator|.
name|close
argument_list|()
expr_stmt|;
specifier|final
name|AtomicReader
name|sr
init|=
name|getOnlySegmentReader
argument_list|(
name|r
argument_list|)
decl_stmt|;
specifier|final
name|long
name|END_TIME
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|+
operator|(
name|TEST_NIGHTLY
condition|?
literal|30
else|:
literal|1
operator|)
decl_stmt|;
specifier|final
name|NumericDocValues
name|docIDToID
init|=
name|numeric
argument_list|(
name|sr
argument_list|,
literal|"id"
argument_list|)
decl_stmt|;
specifier|final
name|int
name|NUM_THREADS
init|=
name|_TestUtil
operator|.
name|nextInt
argument_list|(
name|random
argument_list|()
argument_list|,
literal|1
argument_list|,
literal|10
argument_list|)
decl_stmt|;
name|Thread
index|[]
name|threads
init|=
operator|new
name|Thread
index|[
name|NUM_THREADS
index|]
decl_stmt|;
for|for
control|(
name|int
name|thread
init|=
literal|0
init|;
name|thread
operator|<
name|NUM_THREADS
condition|;
name|thread
operator|++
control|)
block|{
name|threads
index|[
name|thread
index|]
operator|=
operator|new
name|Thread
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
name|Random
name|random
init|=
name|random
argument_list|()
decl_stmt|;
specifier|final
name|SortedDocValues
name|stringDVDirect
decl_stmt|;
try|try
block|{
name|stringDVDirect
operator|=
name|sr
operator|.
name|getSortedDocValues
argument_list|(
literal|"stringdv"
argument_list|)
expr_stmt|;
name|assertNotNull
argument_list|(
name|stringDVDirect
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|ioe
argument_list|)
throw|;
block|}
while|while
condition|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|<
name|END_TIME
condition|)
block|{
specifier|final
name|SortedDocValues
name|source
decl_stmt|;
name|source
operator|=
name|stringDVDirect
expr_stmt|;
specifier|final
name|BytesRef
name|scratch
init|=
operator|new
name|BytesRef
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|iter
init|=
literal|0
init|;
name|iter
operator|<
literal|100
condition|;
name|iter
operator|++
control|)
block|{
specifier|final
name|int
name|docID
init|=
name|random
operator|.
name|nextInt
argument_list|(
name|sr
operator|.
name|maxDoc
argument_list|()
argument_list|)
decl_stmt|;
name|source
operator|.
name|get
argument_list|(
name|docID
argument_list|,
name|scratch
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|docValues
operator|.
name|get
argument_list|(
operator|(
name|int
operator|)
name|docIDToID
operator|.
name|get
argument_list|(
name|docID
argument_list|)
argument_list|)
argument_list|,
name|scratch
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
expr_stmt|;
name|threads
index|[
name|thread
index|]
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|Thread
name|thread
range|:
name|threads
control|)
block|{
name|thread
operator|.
name|join
argument_list|()
expr_stmt|;
block|}
name|r
operator|.
name|close
argument_list|()
expr_stmt|;
name|dir
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
comment|// LUCENE-3870
DECL|method|testLengthPrefixAcrossTwoPages
specifier|public
name|void
name|testLengthPrefixAcrossTwoPages
parameter_list|()
throws|throws
name|Exception
block|{
name|Directory
name|d
init|=
name|newDirectory
argument_list|()
decl_stmt|;
name|IndexWriter
name|w
init|=
operator|new
name|IndexWriter
argument_list|(
name|d
argument_list|,
operator|new
name|IndexWriterConfig
argument_list|(
name|TEST_VERSION_CURRENT
argument_list|,
operator|new
name|MockAnalyzer
argument_list|(
name|random
argument_list|()
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|Document
name|doc
init|=
operator|new
name|Document
argument_list|()
decl_stmt|;
name|byte
index|[]
name|bytes
init|=
operator|new
name|byte
index|[
literal|32764
index|]
decl_stmt|;
name|BytesRef
name|b
init|=
operator|new
name|BytesRef
argument_list|()
decl_stmt|;
name|b
operator|.
name|bytes
operator|=
name|bytes
expr_stmt|;
name|b
operator|.
name|length
operator|=
name|bytes
operator|.
name|length
expr_stmt|;
name|doc
operator|.
name|add
argument_list|(
operator|new
name|SortedDocValuesField
argument_list|(
literal|"field"
argument_list|,
name|b
argument_list|)
argument_list|)
expr_stmt|;
name|w
operator|.
name|addDocument
argument_list|(
name|doc
argument_list|)
expr_stmt|;
name|bytes
index|[
literal|0
index|]
operator|=
literal|1
expr_stmt|;
name|w
operator|.
name|addDocument
argument_list|(
name|doc
argument_list|)
expr_stmt|;
name|w
operator|.
name|forceMerge
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|DirectoryReader
name|r
init|=
name|w
operator|.
name|getReader
argument_list|()
decl_stmt|;
name|BinaryDocValues
name|s
init|=
name|FieldCache
operator|.
name|DEFAULT
operator|.
name|getTerms
argument_list|(
name|getOnlySegmentReader
argument_list|(
name|r
argument_list|)
argument_list|,
literal|"field"
argument_list|)
decl_stmt|;
name|BytesRef
name|bytes1
init|=
operator|new
name|BytesRef
argument_list|()
decl_stmt|;
name|s
operator|.
name|get
argument_list|(
literal|0
argument_list|,
name|bytes1
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|bytes
operator|.
name|length
argument_list|,
name|bytes1
operator|.
name|length
argument_list|)
expr_stmt|;
name|bytes
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|assertEquals
argument_list|(
name|b
argument_list|,
name|bytes1
argument_list|)
expr_stmt|;
name|s
operator|.
name|get
argument_list|(
literal|1
argument_list|,
name|bytes1
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|bytes
operator|.
name|length
argument_list|,
name|bytes1
operator|.
name|length
argument_list|)
expr_stmt|;
name|bytes
index|[
literal|0
index|]
operator|=
literal|1
expr_stmt|;
name|assertEquals
argument_list|(
name|b
argument_list|,
name|bytes1
argument_list|)
expr_stmt|;
name|r
operator|.
name|close
argument_list|()
expr_stmt|;
name|w
operator|.
name|close
argument_list|()
expr_stmt|;
name|d
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
DECL|method|testDocValuesUnstored
specifier|public
name|void
name|testDocValuesUnstored
parameter_list|()
throws|throws
name|IOException
block|{
name|Directory
name|dir
init|=
name|newDirectory
argument_list|()
decl_stmt|;
name|IndexWriterConfig
name|iwconfig
init|=
name|newIndexWriterConfig
argument_list|(
name|TEST_VERSION_CURRENT
argument_list|,
operator|new
name|MockAnalyzer
argument_list|(
name|random
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|iwconfig
operator|.
name|setMergePolicy
argument_list|(
name|newLogMergePolicy
argument_list|()
argument_list|)
expr_stmt|;
name|IndexWriter
name|writer
init|=
operator|new
name|IndexWriter
argument_list|(
name|dir
argument_list|,
name|iwconfig
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|50
condition|;
name|i
operator|++
control|)
block|{
name|Document
name|doc
init|=
operator|new
name|Document
argument_list|()
decl_stmt|;
name|doc
operator|.
name|add
argument_list|(
operator|new
name|NumericDocValuesField
argument_list|(
literal|"dv"
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|doc
operator|.
name|add
argument_list|(
operator|new
name|TextField
argument_list|(
literal|"docId"
argument_list|,
literal|""
operator|+
name|i
argument_list|,
name|Field
operator|.
name|Store
operator|.
name|YES
argument_list|)
argument_list|)
expr_stmt|;
name|writer
operator|.
name|addDocument
argument_list|(
name|doc
argument_list|)
expr_stmt|;
block|}
name|DirectoryReader
name|r
init|=
name|writer
operator|.
name|getReader
argument_list|()
decl_stmt|;
name|SlowCompositeReaderWrapper
name|slow
init|=
operator|new
name|SlowCompositeReaderWrapper
argument_list|(
name|r
argument_list|)
decl_stmt|;
name|FieldInfos
name|fi
init|=
name|slow
operator|.
name|getFieldInfos
argument_list|()
decl_stmt|;
name|FieldInfo
name|dvInfo
init|=
name|fi
operator|.
name|fieldInfo
argument_list|(
literal|"dv"
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|dvInfo
operator|.
name|hasDocValues
argument_list|()
argument_list|)
expr_stmt|;
name|NumericDocValues
name|dv
init|=
name|slow
operator|.
name|getNumericDocValues
argument_list|(
literal|"dv"
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|50
condition|;
name|i
operator|++
control|)
block|{
name|assertEquals
argument_list|(
name|i
argument_list|,
name|dv
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|StoredDocument
name|d
init|=
name|slow
operator|.
name|document
argument_list|(
name|i
argument_list|)
decl_stmt|;
comment|// cannot use d.get("dv") due to another bug!
name|assertNull
argument_list|(
name|d
operator|.
name|getField
argument_list|(
literal|"dv"
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|Integer
operator|.
name|toString
argument_list|(
name|i
argument_list|)
argument_list|,
name|d
operator|.
name|get
argument_list|(
literal|"docId"
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|slow
operator|.
name|close
argument_list|()
expr_stmt|;
name|writer
operator|.
name|close
argument_list|()
expr_stmt|;
name|dir
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
comment|// Same field in one document as different types:
DECL|method|testMixedTypesSameDocument
specifier|public
name|void
name|testMixedTypesSameDocument
parameter_list|()
throws|throws
name|Exception
block|{
name|Directory
name|dir
init|=
name|newDirectory
argument_list|()
decl_stmt|;
name|IndexWriter
name|w
init|=
operator|new
name|IndexWriter
argument_list|(
name|dir
argument_list|,
name|newIndexWriterConfig
argument_list|(
name|TEST_VERSION_CURRENT
argument_list|,
operator|new
name|MockAnalyzer
argument_list|(
name|random
argument_list|()
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|Document
name|doc
init|=
operator|new
name|Document
argument_list|()
decl_stmt|;
name|doc
operator|.
name|add
argument_list|(
operator|new
name|NumericDocValuesField
argument_list|(
literal|"foo"
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|doc
operator|.
name|add
argument_list|(
operator|new
name|SortedDocValuesField
argument_list|(
literal|"foo"
argument_list|,
operator|new
name|BytesRef
argument_list|(
literal|"hello"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
try|try
block|{
name|w
operator|.
name|addDocument
argument_list|(
name|doc
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|iae
parameter_list|)
block|{
comment|// expected
block|}
name|w
operator|.
name|close
argument_list|()
expr_stmt|;
name|dir
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
comment|// Two documents with same field as different types:
DECL|method|testMixedTypesDifferentDocuments
specifier|public
name|void
name|testMixedTypesDifferentDocuments
parameter_list|()
throws|throws
name|Exception
block|{
name|Directory
name|dir
init|=
name|newDirectory
argument_list|()
decl_stmt|;
name|IndexWriter
name|w
init|=
operator|new
name|IndexWriter
argument_list|(
name|dir
argument_list|,
name|newIndexWriterConfig
argument_list|(
name|TEST_VERSION_CURRENT
argument_list|,
operator|new
name|MockAnalyzer
argument_list|(
name|random
argument_list|()
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|Document
name|doc
init|=
operator|new
name|Document
argument_list|()
decl_stmt|;
name|doc
operator|.
name|add
argument_list|(
operator|new
name|NumericDocValuesField
argument_list|(
literal|"foo"
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|w
operator|.
name|addDocument
argument_list|(
name|doc
argument_list|)
expr_stmt|;
name|doc
operator|=
operator|new
name|Document
argument_list|()
expr_stmt|;
name|doc
operator|.
name|add
argument_list|(
operator|new
name|SortedDocValuesField
argument_list|(
literal|"foo"
argument_list|,
operator|new
name|BytesRef
argument_list|(
literal|"hello"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
try|try
block|{
name|w
operator|.
name|addDocument
argument_list|(
name|doc
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|iae
parameter_list|)
block|{
comment|// expected
block|}
name|w
operator|.
name|close
argument_list|()
expr_stmt|;
name|dir
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
comment|// Two documents across segments
DECL|method|testMixedTypesDifferentSegments
specifier|public
name|void
name|testMixedTypesDifferentSegments
parameter_list|()
throws|throws
name|Exception
block|{
name|Directory
name|dir
init|=
name|newDirectory
argument_list|()
decl_stmt|;
name|IndexWriter
name|w
init|=
operator|new
name|IndexWriter
argument_list|(
name|dir
argument_list|,
name|newIndexWriterConfig
argument_list|(
name|TEST_VERSION_CURRENT
argument_list|,
operator|new
name|MockAnalyzer
argument_list|(
name|random
argument_list|()
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|Document
name|doc
init|=
operator|new
name|Document
argument_list|()
decl_stmt|;
name|doc
operator|.
name|add
argument_list|(
operator|new
name|NumericDocValuesField
argument_list|(
literal|"foo"
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|w
operator|.
name|addDocument
argument_list|(
name|doc
argument_list|)
expr_stmt|;
name|w
operator|.
name|commit
argument_list|()
expr_stmt|;
name|doc
operator|=
operator|new
name|Document
argument_list|()
expr_stmt|;
name|doc
operator|.
name|add
argument_list|(
operator|new
name|SortedDocValuesField
argument_list|(
literal|"foo"
argument_list|,
operator|new
name|BytesRef
argument_list|(
literal|"hello"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
try|try
block|{
name|w
operator|.
name|addDocument
argument_list|(
name|doc
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|iae
parameter_list|)
block|{
comment|// expected
block|}
name|w
operator|.
name|close
argument_list|()
expr_stmt|;
name|dir
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
comment|// Add inconsistent document after deleteAll
DECL|method|testMixedTypesAfterDeleteAll
specifier|public
name|void
name|testMixedTypesAfterDeleteAll
parameter_list|()
throws|throws
name|Exception
block|{
name|Directory
name|dir
init|=
name|newDirectory
argument_list|()
decl_stmt|;
name|IndexWriter
name|w
init|=
operator|new
name|IndexWriter
argument_list|(
name|dir
argument_list|,
name|newIndexWriterConfig
argument_list|(
name|TEST_VERSION_CURRENT
argument_list|,
operator|new
name|MockAnalyzer
argument_list|(
name|random
argument_list|()
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|Document
name|doc
init|=
operator|new
name|Document
argument_list|()
decl_stmt|;
name|doc
operator|.
name|add
argument_list|(
operator|new
name|NumericDocValuesField
argument_list|(
literal|"foo"
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|w
operator|.
name|addDocument
argument_list|(
name|doc
argument_list|)
expr_stmt|;
name|w
operator|.
name|deleteAll
argument_list|()
expr_stmt|;
name|doc
operator|=
operator|new
name|Document
argument_list|()
expr_stmt|;
name|doc
operator|.
name|add
argument_list|(
operator|new
name|SortedDocValuesField
argument_list|(
literal|"foo"
argument_list|,
operator|new
name|BytesRef
argument_list|(
literal|"hello"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|w
operator|.
name|addDocument
argument_list|(
name|doc
argument_list|)
expr_stmt|;
name|w
operator|.
name|close
argument_list|()
expr_stmt|;
name|dir
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
comment|// Add inconsistent document after reopening IW w/ create
DECL|method|testMixedTypesAfterReopenCreate
specifier|public
name|void
name|testMixedTypesAfterReopenCreate
parameter_list|()
throws|throws
name|Exception
block|{
name|Directory
name|dir
init|=
name|newDirectory
argument_list|()
decl_stmt|;
name|IndexWriter
name|w
init|=
operator|new
name|IndexWriter
argument_list|(
name|dir
argument_list|,
name|newIndexWriterConfig
argument_list|(
name|TEST_VERSION_CURRENT
argument_list|,
operator|new
name|MockAnalyzer
argument_list|(
name|random
argument_list|()
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|Document
name|doc
init|=
operator|new
name|Document
argument_list|()
decl_stmt|;
name|doc
operator|.
name|add
argument_list|(
operator|new
name|NumericDocValuesField
argument_list|(
literal|"foo"
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|w
operator|.
name|addDocument
argument_list|(
name|doc
argument_list|)
expr_stmt|;
name|w
operator|.
name|close
argument_list|()
expr_stmt|;
name|IndexWriterConfig
name|iwc
init|=
name|newIndexWriterConfig
argument_list|(
name|TEST_VERSION_CURRENT
argument_list|,
operator|new
name|MockAnalyzer
argument_list|(
name|random
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|iwc
operator|.
name|setOpenMode
argument_list|(
name|IndexWriterConfig
operator|.
name|OpenMode
operator|.
name|CREATE
argument_list|)
expr_stmt|;
name|w
operator|=
operator|new
name|IndexWriter
argument_list|(
name|dir
argument_list|,
name|iwc
argument_list|)
expr_stmt|;
name|doc
operator|=
operator|new
name|Document
argument_list|()
expr_stmt|;
name|doc
operator|.
name|add
argument_list|(
operator|new
name|SortedDocValuesField
argument_list|(
literal|"foo"
argument_list|,
operator|new
name|BytesRef
argument_list|(
literal|"hello"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|w
operator|.
name|addDocument
argument_list|(
name|doc
argument_list|)
expr_stmt|;
name|w
operator|.
name|close
argument_list|()
expr_stmt|;
name|dir
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
comment|// Two documents with same field as different types, added
comment|// from separate threads:
DECL|method|testMixedTypesDifferentThreads
specifier|public
name|void
name|testMixedTypesDifferentThreads
parameter_list|()
throws|throws
name|Exception
block|{
name|Directory
name|dir
init|=
name|newDirectory
argument_list|()
decl_stmt|;
specifier|final
name|IndexWriter
name|w
init|=
operator|new
name|IndexWriter
argument_list|(
name|dir
argument_list|,
name|newIndexWriterConfig
argument_list|(
name|TEST_VERSION_CURRENT
argument_list|,
operator|new
name|MockAnalyzer
argument_list|(
name|random
argument_list|()
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|CountDownLatch
name|startingGun
init|=
operator|new
name|CountDownLatch
argument_list|(
literal|1
argument_list|)
decl_stmt|;
specifier|final
name|AtomicBoolean
name|hitExc
init|=
operator|new
name|AtomicBoolean
argument_list|()
decl_stmt|;
name|Thread
index|[]
name|threads
init|=
operator|new
name|Thread
index|[
literal|3
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
block|{
name|Field
name|field
decl_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|field
operator|=
operator|new
name|SortedDocValuesField
argument_list|(
literal|"foo"
argument_list|,
operator|new
name|BytesRef
argument_list|(
literal|"hello"
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|==
literal|1
condition|)
block|{
name|field
operator|=
operator|new
name|NumericDocValuesField
argument_list|(
literal|"foo"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|field
operator|=
operator|new
name|BinaryDocValuesField
argument_list|(
literal|"foo"
argument_list|,
operator|new
name|BytesRef
argument_list|(
literal|"bazz"
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|final
name|Document
name|doc
init|=
operator|new
name|Document
argument_list|()
decl_stmt|;
name|doc
operator|.
name|add
argument_list|(
name|field
argument_list|)
expr_stmt|;
name|threads
index|[
name|i
index|]
operator|=
operator|new
name|Thread
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
try|try
block|{
name|startingGun
operator|.
name|await
argument_list|()
expr_stmt|;
name|w
operator|.
name|addDocument
argument_list|(
name|doc
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|iae
parameter_list|)
block|{
comment|// expected
name|hitExc
operator|.
name|set
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
block|}
expr_stmt|;
name|threads
index|[
name|i
index|]
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
name|startingGun
operator|.
name|countDown
argument_list|()
expr_stmt|;
for|for
control|(
name|Thread
name|t
range|:
name|threads
control|)
block|{
name|t
operator|.
name|join
argument_list|()
expr_stmt|;
block|}
name|assertTrue
argument_list|(
name|hitExc
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
name|w
operator|.
name|close
argument_list|()
expr_stmt|;
name|dir
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
comment|// Adding documents via addIndexes
DECL|method|testMixedTypesViaAddIndexes
specifier|public
name|void
name|testMixedTypesViaAddIndexes
parameter_list|()
throws|throws
name|Exception
block|{
name|Directory
name|dir
init|=
name|newDirectory
argument_list|()
decl_stmt|;
name|IndexWriter
name|w
init|=
operator|new
name|IndexWriter
argument_list|(
name|dir
argument_list|,
name|newIndexWriterConfig
argument_list|(
name|TEST_VERSION_CURRENT
argument_list|,
operator|new
name|MockAnalyzer
argument_list|(
name|random
argument_list|()
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|Document
name|doc
init|=
operator|new
name|Document
argument_list|()
decl_stmt|;
name|doc
operator|.
name|add
argument_list|(
operator|new
name|NumericDocValuesField
argument_list|(
literal|"foo"
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|w
operator|.
name|addDocument
argument_list|(
name|doc
argument_list|)
expr_stmt|;
comment|// Make 2nd index w/ inconsistent field
name|Directory
name|dir2
init|=
name|newDirectory
argument_list|()
decl_stmt|;
name|IndexWriter
name|w2
init|=
operator|new
name|IndexWriter
argument_list|(
name|dir2
argument_list|,
name|newIndexWriterConfig
argument_list|(
name|TEST_VERSION_CURRENT
argument_list|,
operator|new
name|MockAnalyzer
argument_list|(
name|random
argument_list|()
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|doc
operator|=
operator|new
name|Document
argument_list|()
expr_stmt|;
name|doc
operator|.
name|add
argument_list|(
operator|new
name|SortedDocValuesField
argument_list|(
literal|"foo"
argument_list|,
operator|new
name|BytesRef
argument_list|(
literal|"hello"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|w2
operator|.
name|addDocument
argument_list|(
name|doc
argument_list|)
expr_stmt|;
name|w2
operator|.
name|close
argument_list|()
expr_stmt|;
try|try
block|{
name|w
operator|.
name|addIndexes
argument_list|(
operator|new
name|Directory
index|[]
block|{
name|dir2
block|}
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|iae
parameter_list|)
block|{
comment|// expected
block|}
name|IndexReader
name|r
init|=
name|DirectoryReader
operator|.
name|open
argument_list|(
name|dir2
argument_list|)
decl_stmt|;
try|try
block|{
name|w
operator|.
name|addIndexes
argument_list|(
operator|new
name|IndexReader
index|[]
block|{
name|r
block|}
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|iae
parameter_list|)
block|{
comment|// expected
block|}
name|r
operator|.
name|close
argument_list|()
expr_stmt|;
name|dir2
operator|.
name|close
argument_list|()
expr_stmt|;
name|w
operator|.
name|close
argument_list|()
expr_stmt|;
name|dir
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
DECL|method|numeric
specifier|public
name|NumericDocValues
name|numeric
parameter_list|(
name|AtomicReader
name|reader
parameter_list|,
name|String
name|field
parameter_list|)
throws|throws
name|IOException
block|{
name|NumericDocValues
name|docValues
init|=
name|reader
operator|.
name|getNumericDocValues
argument_list|(
name|field
argument_list|)
decl_stmt|;
if|if
condition|(
name|random
argument_list|()
operator|.
name|nextBoolean
argument_list|()
condition|)
block|{
return|return
name|docValues
return|;
block|}
return|return
name|docValues
return|;
block|}
DECL|method|numeric
specifier|public
name|NumericDocValues
name|numeric
parameter_list|(
name|DirectoryReader
name|reader
parameter_list|,
name|String
name|field
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|numeric
argument_list|(
name|getOnlySegmentReader
argument_list|(
name|reader
argument_list|)
argument_list|,
name|field
argument_list|)
return|;
block|}
DECL|method|binary
specifier|public
name|BinaryDocValues
name|binary
parameter_list|(
name|DirectoryReader
name|reader
parameter_list|,
name|String
name|field
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|binary
argument_list|(
name|getOnlySegmentReader
argument_list|(
name|reader
argument_list|)
argument_list|,
name|field
argument_list|)
return|;
block|}
DECL|method|sorted
specifier|public
name|SortedDocValues
name|sorted
parameter_list|(
name|DirectoryReader
name|reader
parameter_list|,
name|String
name|field
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|sorted
argument_list|(
name|getOnlySegmentReader
argument_list|(
name|reader
argument_list|)
argument_list|,
name|field
argument_list|)
return|;
block|}
DECL|method|binary
specifier|public
name|BinaryDocValues
name|binary
parameter_list|(
name|AtomicReader
name|reader
parameter_list|,
name|String
name|field
parameter_list|)
throws|throws
name|IOException
block|{
name|BinaryDocValues
name|docValues
init|=
name|reader
operator|.
name|getBinaryDocValues
argument_list|(
name|field
argument_list|)
decl_stmt|;
if|if
condition|(
name|random
argument_list|()
operator|.
name|nextBoolean
argument_list|()
condition|)
block|{
return|return
name|docValues
return|;
block|}
return|return
name|docValues
return|;
block|}
DECL|method|sorted
specifier|public
name|SortedDocValues
name|sorted
parameter_list|(
name|AtomicReader
name|reader
parameter_list|,
name|String
name|field
parameter_list|)
throws|throws
name|IOException
block|{
name|SortedDocValues
name|docValues
init|=
name|reader
operator|.
name|getSortedDocValues
argument_list|(
name|field
argument_list|)
decl_stmt|;
if|if
condition|(
name|random
argument_list|()
operator|.
name|nextBoolean
argument_list|()
condition|)
block|{
return|return
name|docValues
return|;
block|}
return|return
name|docValues
return|;
block|}
block|}
end_class
end_unit
