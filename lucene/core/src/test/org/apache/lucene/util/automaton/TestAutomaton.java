begin_unit
begin_package
DECL|package|org.apache.lucene.util.automaton
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|automaton
package|;
end_package
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|BytesRef
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|BytesRefBuilder
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|IntsRef
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|IntsRefBuilder
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|LuceneTestCase
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|TestUtil
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|UnicodeUtil
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|automaton
operator|.
name|AutomatonTestUtil
operator|.
name|RandomAcceptedStrings
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|fst
operator|.
name|Util
import|;
end_import
begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|automaton
operator|.
name|Operations
operator|.
name|DEFAULT_MAX_DETERMINIZED_STATES
import|;
end_import
begin_class
DECL|class|TestAutomaton
specifier|public
class|class
name|TestAutomaton
extends|extends
name|LuceneTestCase
block|{
DECL|method|testBasic
specifier|public
name|void
name|testBasic
parameter_list|()
throws|throws
name|Exception
block|{
name|Automaton
name|a
init|=
operator|new
name|Automaton
argument_list|()
decl_stmt|;
name|int
name|start
init|=
name|a
operator|.
name|createState
argument_list|()
decl_stmt|;
name|int
name|x
init|=
name|a
operator|.
name|createState
argument_list|()
decl_stmt|;
name|int
name|y
init|=
name|a
operator|.
name|createState
argument_list|()
decl_stmt|;
name|int
name|end
init|=
name|a
operator|.
name|createState
argument_list|()
decl_stmt|;
name|a
operator|.
name|setAccept
argument_list|(
name|end
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|a
operator|.
name|addTransition
argument_list|(
name|start
argument_list|,
name|x
argument_list|,
literal|'a'
argument_list|,
literal|'a'
argument_list|)
expr_stmt|;
name|a
operator|.
name|addTransition
argument_list|(
name|start
argument_list|,
name|end
argument_list|,
literal|'d'
argument_list|,
literal|'d'
argument_list|)
expr_stmt|;
name|a
operator|.
name|addTransition
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
literal|'b'
argument_list|,
literal|'b'
argument_list|)
expr_stmt|;
name|a
operator|.
name|addTransition
argument_list|(
name|y
argument_list|,
name|end
argument_list|,
literal|'c'
argument_list|,
literal|'c'
argument_list|)
expr_stmt|;
name|a
operator|.
name|finishState
argument_list|()
expr_stmt|;
block|}
DECL|method|testReduceBasic
specifier|public
name|void
name|testReduceBasic
parameter_list|()
throws|throws
name|Exception
block|{
name|Automaton
name|a
init|=
operator|new
name|Automaton
argument_list|()
decl_stmt|;
name|int
name|start
init|=
name|a
operator|.
name|createState
argument_list|()
decl_stmt|;
name|int
name|end
init|=
name|a
operator|.
name|createState
argument_list|()
decl_stmt|;
name|a
operator|.
name|setAccept
argument_list|(
name|end
argument_list|,
literal|true
argument_list|)
expr_stmt|;
comment|// Should collapse to a-b:
name|a
operator|.
name|addTransition
argument_list|(
name|start
argument_list|,
name|end
argument_list|,
literal|'a'
argument_list|,
literal|'a'
argument_list|)
expr_stmt|;
name|a
operator|.
name|addTransition
argument_list|(
name|start
argument_list|,
name|end
argument_list|,
literal|'b'
argument_list|,
literal|'b'
argument_list|)
expr_stmt|;
name|a
operator|.
name|addTransition
argument_list|(
name|start
argument_list|,
name|end
argument_list|,
literal|'m'
argument_list|,
literal|'m'
argument_list|)
expr_stmt|;
comment|// Should collapse to x-y:
name|a
operator|.
name|addTransition
argument_list|(
name|start
argument_list|,
name|end
argument_list|,
literal|'x'
argument_list|,
literal|'x'
argument_list|)
expr_stmt|;
name|a
operator|.
name|addTransition
argument_list|(
name|start
argument_list|,
name|end
argument_list|,
literal|'y'
argument_list|,
literal|'y'
argument_list|)
expr_stmt|;
name|a
operator|.
name|finishState
argument_list|()
expr_stmt|;
name|assertEquals
argument_list|(
literal|3
argument_list|,
name|a
operator|.
name|getNumTransitions
argument_list|(
name|start
argument_list|)
argument_list|)
expr_stmt|;
name|Transition
name|scratch
init|=
operator|new
name|Transition
argument_list|()
decl_stmt|;
name|a
operator|.
name|initTransition
argument_list|(
name|start
argument_list|,
name|scratch
argument_list|)
expr_stmt|;
name|a
operator|.
name|getNextTransition
argument_list|(
name|scratch
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|'a'
argument_list|,
name|scratch
operator|.
name|min
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|'b'
argument_list|,
name|scratch
operator|.
name|max
argument_list|)
expr_stmt|;
name|a
operator|.
name|getNextTransition
argument_list|(
name|scratch
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|'m'
argument_list|,
name|scratch
operator|.
name|min
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|'m'
argument_list|,
name|scratch
operator|.
name|max
argument_list|)
expr_stmt|;
name|a
operator|.
name|getNextTransition
argument_list|(
name|scratch
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|'x'
argument_list|,
name|scratch
operator|.
name|min
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|'y'
argument_list|,
name|scratch
operator|.
name|max
argument_list|)
expr_stmt|;
block|}
DECL|method|testSameLanguage
specifier|public
name|void
name|testSameLanguage
parameter_list|()
throws|throws
name|Exception
block|{
name|Automaton
name|a1
init|=
name|Automata
operator|.
name|makeString
argument_list|(
literal|"foobar"
argument_list|)
decl_stmt|;
name|Automaton
name|a2
init|=
name|Operations
operator|.
name|removeDeadStates
argument_list|(
name|Operations
operator|.
name|concatenate
argument_list|(
name|Automata
operator|.
name|makeString
argument_list|(
literal|"foo"
argument_list|)
argument_list|,
name|Automata
operator|.
name|makeString
argument_list|(
literal|"bar"
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|Operations
operator|.
name|sameLanguage
argument_list|(
name|a1
argument_list|,
name|a2
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|testCommonPrefix
specifier|public
name|void
name|testCommonPrefix
parameter_list|()
throws|throws
name|Exception
block|{
name|Automaton
name|a
init|=
name|Operations
operator|.
name|concatenate
argument_list|(
name|Automata
operator|.
name|makeString
argument_list|(
literal|"foobar"
argument_list|)
argument_list|,
name|Automata
operator|.
name|makeAnyString
argument_list|()
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|"foobar"
argument_list|,
name|Operations
operator|.
name|getCommonPrefix
argument_list|(
name|a
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|testConcatenate1
specifier|public
name|void
name|testConcatenate1
parameter_list|()
throws|throws
name|Exception
block|{
name|Automaton
name|a
init|=
name|Operations
operator|.
name|concatenate
argument_list|(
name|Automata
operator|.
name|makeString
argument_list|(
literal|"m"
argument_list|)
argument_list|,
name|Automata
operator|.
name|makeAnyString
argument_list|()
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|Operations
operator|.
name|run
argument_list|(
name|a
argument_list|,
literal|"m"
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|Operations
operator|.
name|run
argument_list|(
name|a
argument_list|,
literal|"me"
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|Operations
operator|.
name|run
argument_list|(
name|a
argument_list|,
literal|"me too"
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|testConcatenate2
specifier|public
name|void
name|testConcatenate2
parameter_list|()
throws|throws
name|Exception
block|{
name|Automaton
name|a
init|=
name|Operations
operator|.
name|concatenate
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|Automata
operator|.
name|makeString
argument_list|(
literal|"m"
argument_list|)
argument_list|,
name|Automata
operator|.
name|makeAnyString
argument_list|()
argument_list|,
name|Automata
operator|.
name|makeString
argument_list|(
literal|"n"
argument_list|)
argument_list|,
name|Automata
operator|.
name|makeAnyString
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|a
operator|=
name|Operations
operator|.
name|determinize
argument_list|(
name|a
argument_list|,
name|DEFAULT_MAX_DETERMINIZED_STATES
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|Operations
operator|.
name|run
argument_list|(
name|a
argument_list|,
literal|"mn"
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|Operations
operator|.
name|run
argument_list|(
name|a
argument_list|,
literal|"mone"
argument_list|)
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|Operations
operator|.
name|run
argument_list|(
name|a
argument_list|,
literal|"m"
argument_list|)
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|Operations
operator|.
name|isFinite
argument_list|(
name|a
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|testUnion1
specifier|public
name|void
name|testUnion1
parameter_list|()
throws|throws
name|Exception
block|{
name|Automaton
name|a
init|=
name|Operations
operator|.
name|union
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|Automata
operator|.
name|makeString
argument_list|(
literal|"foobar"
argument_list|)
argument_list|,
name|Automata
operator|.
name|makeString
argument_list|(
literal|"barbaz"
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|a
operator|=
name|Operations
operator|.
name|determinize
argument_list|(
name|a
argument_list|,
name|DEFAULT_MAX_DETERMINIZED_STATES
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|Operations
operator|.
name|run
argument_list|(
name|a
argument_list|,
literal|"foobar"
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|Operations
operator|.
name|run
argument_list|(
name|a
argument_list|,
literal|"barbaz"
argument_list|)
argument_list|)
expr_stmt|;
name|assertMatches
argument_list|(
name|a
argument_list|,
literal|"foobar"
argument_list|,
literal|"barbaz"
argument_list|)
expr_stmt|;
block|}
DECL|method|testUnion2
specifier|public
name|void
name|testUnion2
parameter_list|()
throws|throws
name|Exception
block|{
name|Automaton
name|a
init|=
name|Operations
operator|.
name|union
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|Automata
operator|.
name|makeString
argument_list|(
literal|"foobar"
argument_list|)
argument_list|,
name|Automata
operator|.
name|makeString
argument_list|(
literal|""
argument_list|)
argument_list|,
name|Automata
operator|.
name|makeString
argument_list|(
literal|"barbaz"
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|a
operator|=
name|Operations
operator|.
name|determinize
argument_list|(
name|a
argument_list|,
name|DEFAULT_MAX_DETERMINIZED_STATES
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|Operations
operator|.
name|run
argument_list|(
name|a
argument_list|,
literal|"foobar"
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|Operations
operator|.
name|run
argument_list|(
name|a
argument_list|,
literal|"barbaz"
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|Operations
operator|.
name|run
argument_list|(
name|a
argument_list|,
literal|""
argument_list|)
argument_list|)
expr_stmt|;
name|assertMatches
argument_list|(
name|a
argument_list|,
literal|""
argument_list|,
literal|"foobar"
argument_list|,
literal|"barbaz"
argument_list|)
expr_stmt|;
block|}
DECL|method|testMinimizeSimple
specifier|public
name|void
name|testMinimizeSimple
parameter_list|()
throws|throws
name|Exception
block|{
name|Automaton
name|a
init|=
name|Automata
operator|.
name|makeString
argument_list|(
literal|"foobar"
argument_list|)
decl_stmt|;
name|Automaton
name|aMin
init|=
name|MinimizationOperations
operator|.
name|minimize
argument_list|(
name|a
argument_list|,
name|DEFAULT_MAX_DETERMINIZED_STATES
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|Operations
operator|.
name|sameLanguage
argument_list|(
name|a
argument_list|,
name|aMin
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|testMinimize2
specifier|public
name|void
name|testMinimize2
parameter_list|()
throws|throws
name|Exception
block|{
name|Automaton
name|a
init|=
name|Operations
operator|.
name|union
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|Automata
operator|.
name|makeString
argument_list|(
literal|"foobar"
argument_list|)
argument_list|,
name|Automata
operator|.
name|makeString
argument_list|(
literal|"boobar"
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|Automaton
name|aMin
init|=
name|MinimizationOperations
operator|.
name|minimize
argument_list|(
name|a
argument_list|,
name|DEFAULT_MAX_DETERMINIZED_STATES
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|Operations
operator|.
name|sameLanguage
argument_list|(
name|Operations
operator|.
name|determinize
argument_list|(
name|Operations
operator|.
name|removeDeadStates
argument_list|(
name|a
argument_list|)
argument_list|,
name|DEFAULT_MAX_DETERMINIZED_STATES
argument_list|)
argument_list|,
name|aMin
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|testReverse
specifier|public
name|void
name|testReverse
parameter_list|()
throws|throws
name|Exception
block|{
name|Automaton
name|a
init|=
name|Automata
operator|.
name|makeString
argument_list|(
literal|"foobar"
argument_list|)
decl_stmt|;
name|Automaton
name|ra
init|=
name|Operations
operator|.
name|reverse
argument_list|(
name|a
argument_list|)
decl_stmt|;
name|Automaton
name|a2
init|=
name|Operations
operator|.
name|determinize
argument_list|(
name|Operations
operator|.
name|reverse
argument_list|(
name|ra
argument_list|)
argument_list|,
name|DEFAULT_MAX_DETERMINIZED_STATES
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|Operations
operator|.
name|sameLanguage
argument_list|(
name|a
argument_list|,
name|a2
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|testOptional
specifier|public
name|void
name|testOptional
parameter_list|()
throws|throws
name|Exception
block|{
name|Automaton
name|a
init|=
name|Automata
operator|.
name|makeString
argument_list|(
literal|"foobar"
argument_list|)
decl_stmt|;
name|Automaton
name|a2
init|=
name|Operations
operator|.
name|optional
argument_list|(
name|a
argument_list|)
decl_stmt|;
name|a2
operator|=
name|Operations
operator|.
name|determinize
argument_list|(
name|a2
argument_list|,
name|DEFAULT_MAX_DETERMINIZED_STATES
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|Operations
operator|.
name|run
argument_list|(
name|a
argument_list|,
literal|"foobar"
argument_list|)
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|Operations
operator|.
name|run
argument_list|(
name|a
argument_list|,
literal|""
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|Operations
operator|.
name|run
argument_list|(
name|a2
argument_list|,
literal|"foobar"
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|Operations
operator|.
name|run
argument_list|(
name|a2
argument_list|,
literal|""
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|testRepeatAny
specifier|public
name|void
name|testRepeatAny
parameter_list|()
throws|throws
name|Exception
block|{
name|Automaton
name|a
init|=
name|Automata
operator|.
name|makeString
argument_list|(
literal|"zee"
argument_list|)
decl_stmt|;
name|Automaton
name|a2
init|=
name|Operations
operator|.
name|determinize
argument_list|(
name|Operations
operator|.
name|repeat
argument_list|(
name|a
argument_list|)
argument_list|,
name|DEFAULT_MAX_DETERMINIZED_STATES
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|Operations
operator|.
name|run
argument_list|(
name|a2
argument_list|,
literal|""
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|Operations
operator|.
name|run
argument_list|(
name|a2
argument_list|,
literal|"zee"
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|Operations
operator|.
name|run
argument_list|(
name|a2
argument_list|,
literal|"zeezee"
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|Operations
operator|.
name|run
argument_list|(
name|a2
argument_list|,
literal|"zeezeezee"
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|testRepeatMin
specifier|public
name|void
name|testRepeatMin
parameter_list|()
throws|throws
name|Exception
block|{
name|Automaton
name|a
init|=
name|Automata
operator|.
name|makeString
argument_list|(
literal|"zee"
argument_list|)
decl_stmt|;
name|Automaton
name|a2
init|=
name|Operations
operator|.
name|determinize
argument_list|(
name|Operations
operator|.
name|repeat
argument_list|(
name|a
argument_list|,
literal|2
argument_list|)
argument_list|,
name|DEFAULT_MAX_DETERMINIZED_STATES
argument_list|)
decl_stmt|;
name|assertFalse
argument_list|(
name|Operations
operator|.
name|run
argument_list|(
name|a2
argument_list|,
literal|""
argument_list|)
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|Operations
operator|.
name|run
argument_list|(
name|a2
argument_list|,
literal|"zee"
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|Operations
operator|.
name|run
argument_list|(
name|a2
argument_list|,
literal|"zeezee"
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|Operations
operator|.
name|run
argument_list|(
name|a2
argument_list|,
literal|"zeezeezee"
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|testRepeatMinMax1
specifier|public
name|void
name|testRepeatMinMax1
parameter_list|()
throws|throws
name|Exception
block|{
name|Automaton
name|a
init|=
name|Automata
operator|.
name|makeString
argument_list|(
literal|"zee"
argument_list|)
decl_stmt|;
name|Automaton
name|a2
init|=
name|Operations
operator|.
name|determinize
argument_list|(
name|Operations
operator|.
name|repeat
argument_list|(
name|a
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|)
argument_list|,
name|DEFAULT_MAX_DETERMINIZED_STATES
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|Operations
operator|.
name|run
argument_list|(
name|a2
argument_list|,
literal|""
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|Operations
operator|.
name|run
argument_list|(
name|a2
argument_list|,
literal|"zee"
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|Operations
operator|.
name|run
argument_list|(
name|a2
argument_list|,
literal|"zeezee"
argument_list|)
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|Operations
operator|.
name|run
argument_list|(
name|a2
argument_list|,
literal|"zeezeezee"
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|testRepeatMinMax2
specifier|public
name|void
name|testRepeatMinMax2
parameter_list|()
throws|throws
name|Exception
block|{
name|Automaton
name|a
init|=
name|Automata
operator|.
name|makeString
argument_list|(
literal|"zee"
argument_list|)
decl_stmt|;
name|Automaton
name|a2
init|=
name|Operations
operator|.
name|determinize
argument_list|(
name|Operations
operator|.
name|repeat
argument_list|(
name|a
argument_list|,
literal|2
argument_list|,
literal|4
argument_list|)
argument_list|,
name|DEFAULT_MAX_DETERMINIZED_STATES
argument_list|)
decl_stmt|;
name|assertFalse
argument_list|(
name|Operations
operator|.
name|run
argument_list|(
name|a2
argument_list|,
literal|""
argument_list|)
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|Operations
operator|.
name|run
argument_list|(
name|a2
argument_list|,
literal|"zee"
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|Operations
operator|.
name|run
argument_list|(
name|a2
argument_list|,
literal|"zeezee"
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|Operations
operator|.
name|run
argument_list|(
name|a2
argument_list|,
literal|"zeezeezee"
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|Operations
operator|.
name|run
argument_list|(
name|a2
argument_list|,
literal|"zeezeezeezee"
argument_list|)
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|Operations
operator|.
name|run
argument_list|(
name|a2
argument_list|,
literal|"zeezeezeezeezee"
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|testComplement
specifier|public
name|void
name|testComplement
parameter_list|()
throws|throws
name|Exception
block|{
name|Automaton
name|a
init|=
name|Automata
operator|.
name|makeString
argument_list|(
literal|"zee"
argument_list|)
decl_stmt|;
name|Automaton
name|a2
init|=
name|Operations
operator|.
name|determinize
argument_list|(
name|Operations
operator|.
name|complement
argument_list|(
name|a
argument_list|,
name|DEFAULT_MAX_DETERMINIZED_STATES
argument_list|)
argument_list|,
name|DEFAULT_MAX_DETERMINIZED_STATES
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|Operations
operator|.
name|run
argument_list|(
name|a2
argument_list|,
literal|""
argument_list|)
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|Operations
operator|.
name|run
argument_list|(
name|a2
argument_list|,
literal|"zee"
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|Operations
operator|.
name|run
argument_list|(
name|a2
argument_list|,
literal|"zeezee"
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|Operations
operator|.
name|run
argument_list|(
name|a2
argument_list|,
literal|"zeezeezee"
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|testInterval
specifier|public
name|void
name|testInterval
parameter_list|()
throws|throws
name|Exception
block|{
name|Automaton
name|a
init|=
name|Operations
operator|.
name|determinize
argument_list|(
name|Automata
operator|.
name|makeInterval
argument_list|(
literal|17
argument_list|,
literal|100
argument_list|,
literal|3
argument_list|)
argument_list|,
name|DEFAULT_MAX_DETERMINIZED_STATES
argument_list|)
decl_stmt|;
name|assertFalse
argument_list|(
name|Operations
operator|.
name|run
argument_list|(
name|a
argument_list|,
literal|""
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|Operations
operator|.
name|run
argument_list|(
name|a
argument_list|,
literal|"017"
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|Operations
operator|.
name|run
argument_list|(
name|a
argument_list|,
literal|"100"
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|Operations
operator|.
name|run
argument_list|(
name|a
argument_list|,
literal|"073"
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|testCommonSuffix
specifier|public
name|void
name|testCommonSuffix
parameter_list|()
throws|throws
name|Exception
block|{
name|Automaton
name|a
init|=
operator|new
name|Automaton
argument_list|()
decl_stmt|;
name|int
name|init
init|=
name|a
operator|.
name|createState
argument_list|()
decl_stmt|;
name|int
name|fini
init|=
name|a
operator|.
name|createState
argument_list|()
decl_stmt|;
name|a
operator|.
name|setAccept
argument_list|(
name|init
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|a
operator|.
name|setAccept
argument_list|(
name|fini
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|a
operator|.
name|addTransition
argument_list|(
name|init
argument_list|,
name|fini
argument_list|,
literal|'m'
argument_list|)
expr_stmt|;
name|a
operator|.
name|addTransition
argument_list|(
name|fini
argument_list|,
name|fini
argument_list|,
literal|'m'
argument_list|)
expr_stmt|;
name|a
operator|.
name|finishState
argument_list|()
expr_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|Operations
operator|.
name|getCommonSuffixBytesRef
argument_list|(
name|a
argument_list|,
name|DEFAULT_MAX_DETERMINIZED_STATES
argument_list|)
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
DECL|method|testReverseRandom1
specifier|public
name|void
name|testReverseRandom1
parameter_list|()
throws|throws
name|Exception
block|{
name|int
name|ITERS
init|=
name|atLeast
argument_list|(
literal|100
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ITERS
condition|;
name|i
operator|++
control|)
block|{
name|Automaton
name|a
init|=
name|AutomatonTestUtil
operator|.
name|randomAutomaton
argument_list|(
name|random
argument_list|()
argument_list|)
decl_stmt|;
name|Automaton
name|ra
init|=
name|Operations
operator|.
name|reverse
argument_list|(
name|a
argument_list|)
decl_stmt|;
name|Automaton
name|rra
init|=
name|Operations
operator|.
name|reverse
argument_list|(
name|ra
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|Operations
operator|.
name|sameLanguage
argument_list|(
name|Operations
operator|.
name|determinize
argument_list|(
name|Operations
operator|.
name|removeDeadStates
argument_list|(
name|a
argument_list|)
argument_list|,
name|DEFAULT_MAX_DETERMINIZED_STATES
argument_list|)
argument_list|,
name|Operations
operator|.
name|determinize
argument_list|(
name|Operations
operator|.
name|removeDeadStates
argument_list|(
name|rra
argument_list|)
argument_list|,
name|DEFAULT_MAX_DETERMINIZED_STATES
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|testReverseRandom2
specifier|public
name|void
name|testReverseRandom2
parameter_list|()
throws|throws
name|Exception
block|{
name|int
name|ITERS
init|=
name|atLeast
argument_list|(
literal|100
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|iter
init|=
literal|0
init|;
name|iter
operator|<
name|ITERS
condition|;
name|iter
operator|++
control|)
block|{
comment|//System.out.println("TEST: iter=" + iter);
name|Automaton
name|a
init|=
name|AutomatonTestUtil
operator|.
name|randomAutomaton
argument_list|(
name|random
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|random
argument_list|()
operator|.
name|nextBoolean
argument_list|()
condition|)
block|{
name|a
operator|=
name|Operations
operator|.
name|removeDeadStates
argument_list|(
name|a
argument_list|)
expr_stmt|;
block|}
name|Automaton
name|ra
init|=
name|Operations
operator|.
name|reverse
argument_list|(
name|a
argument_list|)
decl_stmt|;
name|Automaton
name|rda
init|=
name|Operations
operator|.
name|determinize
argument_list|(
name|ra
argument_list|,
name|DEFAULT_MAX_DETERMINIZED_STATES
argument_list|)
decl_stmt|;
if|if
condition|(
name|Operations
operator|.
name|isEmpty
argument_list|(
name|a
argument_list|)
condition|)
block|{
name|assertTrue
argument_list|(
name|Operations
operator|.
name|isEmpty
argument_list|(
name|rda
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|RandomAcceptedStrings
name|ras
init|=
operator|new
name|RandomAcceptedStrings
argument_list|(
name|a
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|iter2
init|=
literal|0
init|;
name|iter2
operator|<
literal|20
condition|;
name|iter2
operator|++
control|)
block|{
comment|// Find string accepted by original automaton
name|int
index|[]
name|s
init|=
name|ras
operator|.
name|getRandomAcceptedString
argument_list|(
name|random
argument_list|()
argument_list|)
decl_stmt|;
comment|// Reverse it
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|s
operator|.
name|length
operator|/
literal|2
condition|;
name|j
operator|++
control|)
block|{
name|int
name|x
init|=
name|s
index|[
name|j
index|]
decl_stmt|;
name|s
index|[
name|j
index|]
operator|=
name|s
index|[
name|s
operator|.
name|length
operator|-
name|j
operator|-
literal|1
index|]
expr_stmt|;
name|s
index|[
name|s
operator|.
name|length
operator|-
name|j
operator|-
literal|1
index|]
operator|=
name|x
expr_stmt|;
block|}
comment|//System.out.println("TEST:   iter2=" + iter2 + " s=" + Arrays.toString(s));
comment|// Make sure reversed automaton accepts it
name|assertTrue
argument_list|(
name|Operations
operator|.
name|run
argument_list|(
name|rda
argument_list|,
operator|new
name|IntsRef
argument_list|(
name|s
argument_list|,
literal|0
argument_list|,
name|s
operator|.
name|length
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|testAnyStringEmptyString
specifier|public
name|void
name|testAnyStringEmptyString
parameter_list|()
throws|throws
name|Exception
block|{
name|Automaton
name|a
init|=
name|Operations
operator|.
name|determinize
argument_list|(
name|Automata
operator|.
name|makeAnyString
argument_list|()
argument_list|,
name|DEFAULT_MAX_DETERMINIZED_STATES
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|Operations
operator|.
name|run
argument_list|(
name|a
argument_list|,
literal|""
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|testBasicIsEmpty
specifier|public
name|void
name|testBasicIsEmpty
parameter_list|()
throws|throws
name|Exception
block|{
name|Automaton
name|a
init|=
operator|new
name|Automaton
argument_list|()
decl_stmt|;
name|a
operator|.
name|createState
argument_list|()
expr_stmt|;
name|assertTrue
argument_list|(
name|Operations
operator|.
name|isEmpty
argument_list|(
name|a
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|testRemoveDeadTransitionsEmpty
specifier|public
name|void
name|testRemoveDeadTransitionsEmpty
parameter_list|()
throws|throws
name|Exception
block|{
name|Automaton
name|a
init|=
name|Automata
operator|.
name|makeEmpty
argument_list|()
decl_stmt|;
name|Automaton
name|a2
init|=
name|Operations
operator|.
name|removeDeadStates
argument_list|(
name|a
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|Operations
operator|.
name|isEmpty
argument_list|(
name|a2
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|testInvalidAddTransition
specifier|public
name|void
name|testInvalidAddTransition
parameter_list|()
throws|throws
name|Exception
block|{
name|Automaton
name|a
init|=
operator|new
name|Automaton
argument_list|()
decl_stmt|;
name|int
name|s1
init|=
name|a
operator|.
name|createState
argument_list|()
decl_stmt|;
name|int
name|s2
init|=
name|a
operator|.
name|createState
argument_list|()
decl_stmt|;
name|a
operator|.
name|addTransition
argument_list|(
name|s1
argument_list|,
name|s2
argument_list|,
literal|'a'
argument_list|)
expr_stmt|;
name|a
operator|.
name|addTransition
argument_list|(
name|s2
argument_list|,
name|s2
argument_list|,
literal|'a'
argument_list|)
expr_stmt|;
try|try
block|{
name|a
operator|.
name|addTransition
argument_list|(
name|s1
argument_list|,
name|s2
argument_list|,
literal|'b'
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"didn't hit expected exception"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalStateException
name|ise
parameter_list|)
block|{
comment|// expected
block|}
block|}
DECL|method|testBuilderRandom
specifier|public
name|void
name|testBuilderRandom
parameter_list|()
throws|throws
name|Exception
block|{
name|int
name|ITERS
init|=
name|atLeast
argument_list|(
literal|100
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|iter
init|=
literal|0
init|;
name|iter
operator|<
name|ITERS
condition|;
name|iter
operator|++
control|)
block|{
name|Automaton
name|a
init|=
name|AutomatonTestUtil
operator|.
name|randomAutomaton
argument_list|(
name|random
argument_list|()
argument_list|)
decl_stmt|;
comment|// Just get all transitions, shuffle, and build a new automaton with the same transitions:
name|List
argument_list|<
name|Transition
argument_list|>
name|allTrans
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|int
name|numStates
init|=
name|a
operator|.
name|getNumStates
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|s
init|=
literal|0
init|;
name|s
operator|<
name|numStates
condition|;
name|s
operator|++
control|)
block|{
name|int
name|count
init|=
name|a
operator|.
name|getNumTransitions
argument_list|(
name|s
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|Transition
name|t
init|=
operator|new
name|Transition
argument_list|()
decl_stmt|;
name|a
operator|.
name|getTransition
argument_list|(
name|s
argument_list|,
name|i
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|allTrans
operator|.
name|add
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
block|}
name|Automaton
operator|.
name|Builder
name|builder
init|=
operator|new
name|Automaton
operator|.
name|Builder
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numStates
condition|;
name|i
operator|++
control|)
block|{
name|int
name|s
init|=
name|builder
operator|.
name|createState
argument_list|()
decl_stmt|;
name|builder
operator|.
name|setAccept
argument_list|(
name|s
argument_list|,
name|a
operator|.
name|isAccept
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|Collections
operator|.
name|shuffle
argument_list|(
name|allTrans
argument_list|,
name|random
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|Transition
name|t
range|:
name|allTrans
control|)
block|{
name|builder
operator|.
name|addTransition
argument_list|(
name|t
operator|.
name|source
argument_list|,
name|t
operator|.
name|dest
argument_list|,
name|t
operator|.
name|min
argument_list|,
name|t
operator|.
name|max
argument_list|)
expr_stmt|;
block|}
name|assertTrue
argument_list|(
name|Operations
operator|.
name|sameLanguage
argument_list|(
name|Operations
operator|.
name|determinize
argument_list|(
name|Operations
operator|.
name|removeDeadStates
argument_list|(
name|a
argument_list|)
argument_list|,
name|DEFAULT_MAX_DETERMINIZED_STATES
argument_list|)
argument_list|,
name|Operations
operator|.
name|determinize
argument_list|(
name|Operations
operator|.
name|removeDeadStates
argument_list|(
name|builder
operator|.
name|finish
argument_list|()
argument_list|)
argument_list|,
name|DEFAULT_MAX_DETERMINIZED_STATES
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|testIsTotal
specifier|public
name|void
name|testIsTotal
parameter_list|()
throws|throws
name|Exception
block|{
name|assertFalse
argument_list|(
name|Operations
operator|.
name|isTotal
argument_list|(
operator|new
name|Automaton
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|Automaton
name|a
init|=
operator|new
name|Automaton
argument_list|()
decl_stmt|;
name|int
name|init
init|=
name|a
operator|.
name|createState
argument_list|()
decl_stmt|;
name|int
name|fini
init|=
name|a
operator|.
name|createState
argument_list|()
decl_stmt|;
name|a
operator|.
name|setAccept
argument_list|(
name|fini
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|a
operator|.
name|addTransition
argument_list|(
name|init
argument_list|,
name|fini
argument_list|,
name|Character
operator|.
name|MIN_CODE_POINT
argument_list|,
name|Character
operator|.
name|MAX_CODE_POINT
argument_list|)
expr_stmt|;
name|a
operator|.
name|finishState
argument_list|()
expr_stmt|;
name|assertFalse
argument_list|(
name|Operations
operator|.
name|isTotal
argument_list|(
name|a
argument_list|)
argument_list|)
expr_stmt|;
name|a
operator|.
name|addTransition
argument_list|(
name|fini
argument_list|,
name|fini
argument_list|,
name|Character
operator|.
name|MIN_CODE_POINT
argument_list|,
name|Character
operator|.
name|MAX_CODE_POINT
argument_list|)
expr_stmt|;
name|a
operator|.
name|finishState
argument_list|()
expr_stmt|;
name|assertFalse
argument_list|(
name|Operations
operator|.
name|isTotal
argument_list|(
name|a
argument_list|)
argument_list|)
expr_stmt|;
name|a
operator|.
name|setAccept
argument_list|(
name|init
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|Operations
operator|.
name|isTotal
argument_list|(
name|MinimizationOperations
operator|.
name|minimize
argument_list|(
name|a
argument_list|,
name|DEFAULT_MAX_DETERMINIZED_STATES
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|testMinimizeEmpty
specifier|public
name|void
name|testMinimizeEmpty
parameter_list|()
throws|throws
name|Exception
block|{
name|Automaton
name|a
init|=
operator|new
name|Automaton
argument_list|()
decl_stmt|;
name|int
name|init
init|=
name|a
operator|.
name|createState
argument_list|()
decl_stmt|;
name|int
name|fini
init|=
name|a
operator|.
name|createState
argument_list|()
decl_stmt|;
name|a
operator|.
name|addTransition
argument_list|(
name|init
argument_list|,
name|fini
argument_list|,
literal|'a'
argument_list|)
expr_stmt|;
name|a
operator|.
name|finishState
argument_list|()
expr_stmt|;
name|a
operator|=
name|MinimizationOperations
operator|.
name|minimize
argument_list|(
name|a
argument_list|,
name|DEFAULT_MAX_DETERMINIZED_STATES
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|a
operator|.
name|getNumStates
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|testMinus
specifier|public
name|void
name|testMinus
parameter_list|()
throws|throws
name|Exception
block|{
name|Automaton
name|a1
init|=
name|Automata
operator|.
name|makeString
argument_list|(
literal|"foobar"
argument_list|)
decl_stmt|;
name|Automaton
name|a2
init|=
name|Automata
operator|.
name|makeString
argument_list|(
literal|"boobar"
argument_list|)
decl_stmt|;
name|Automaton
name|a3
init|=
name|Automata
operator|.
name|makeString
argument_list|(
literal|"beebar"
argument_list|)
decl_stmt|;
name|Automaton
name|a
init|=
name|Operations
operator|.
name|union
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|a1
argument_list|,
name|a2
argument_list|,
name|a3
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|random
argument_list|()
operator|.
name|nextBoolean
argument_list|()
condition|)
block|{
name|a
operator|=
name|Operations
operator|.
name|determinize
argument_list|(
name|a
argument_list|,
name|DEFAULT_MAX_DETERMINIZED_STATES
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|random
argument_list|()
operator|.
name|nextBoolean
argument_list|()
condition|)
block|{
name|a
operator|=
name|MinimizationOperations
operator|.
name|minimize
argument_list|(
name|a
argument_list|,
name|DEFAULT_MAX_DETERMINIZED_STATES
argument_list|)
expr_stmt|;
block|}
name|assertMatches
argument_list|(
name|a
argument_list|,
literal|"foobar"
argument_list|,
literal|"beebar"
argument_list|,
literal|"boobar"
argument_list|)
expr_stmt|;
name|Automaton
name|a4
init|=
name|Operations
operator|.
name|determinize
argument_list|(
name|Operations
operator|.
name|minus
argument_list|(
name|a
argument_list|,
name|a2
argument_list|,
name|DEFAULT_MAX_DETERMINIZED_STATES
argument_list|)
argument_list|,
name|DEFAULT_MAX_DETERMINIZED_STATES
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|Operations
operator|.
name|run
argument_list|(
name|a4
argument_list|,
literal|"foobar"
argument_list|)
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|Operations
operator|.
name|run
argument_list|(
name|a4
argument_list|,
literal|"boobar"
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|Operations
operator|.
name|run
argument_list|(
name|a4
argument_list|,
literal|"beebar"
argument_list|)
argument_list|)
expr_stmt|;
name|assertMatches
argument_list|(
name|a4
argument_list|,
literal|"foobar"
argument_list|,
literal|"beebar"
argument_list|)
expr_stmt|;
name|a4
operator|=
name|Operations
operator|.
name|determinize
argument_list|(
name|Operations
operator|.
name|minus
argument_list|(
name|a4
argument_list|,
name|a1
argument_list|,
name|DEFAULT_MAX_DETERMINIZED_STATES
argument_list|)
argument_list|,
name|DEFAULT_MAX_DETERMINIZED_STATES
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|Operations
operator|.
name|run
argument_list|(
name|a4
argument_list|,
literal|"foobar"
argument_list|)
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|Operations
operator|.
name|run
argument_list|(
name|a4
argument_list|,
literal|"boobar"
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|Operations
operator|.
name|run
argument_list|(
name|a4
argument_list|,
literal|"beebar"
argument_list|)
argument_list|)
expr_stmt|;
name|assertMatches
argument_list|(
name|a4
argument_list|,
literal|"beebar"
argument_list|)
expr_stmt|;
name|a4
operator|=
name|Operations
operator|.
name|determinize
argument_list|(
name|Operations
operator|.
name|minus
argument_list|(
name|a4
argument_list|,
name|a3
argument_list|,
name|DEFAULT_MAX_DETERMINIZED_STATES
argument_list|)
argument_list|,
name|DEFAULT_MAX_DETERMINIZED_STATES
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|Operations
operator|.
name|run
argument_list|(
name|a4
argument_list|,
literal|"foobar"
argument_list|)
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|Operations
operator|.
name|run
argument_list|(
name|a4
argument_list|,
literal|"boobar"
argument_list|)
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|Operations
operator|.
name|run
argument_list|(
name|a4
argument_list|,
literal|"beebar"
argument_list|)
argument_list|)
expr_stmt|;
name|assertMatches
argument_list|(
name|a4
argument_list|)
expr_stmt|;
block|}
DECL|method|testOneInterval
specifier|public
name|void
name|testOneInterval
parameter_list|()
throws|throws
name|Exception
block|{
name|Automaton
name|a
init|=
name|Automata
operator|.
name|makeInterval
argument_list|(
literal|999
argument_list|,
literal|1032
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|a
operator|=
name|Operations
operator|.
name|determinize
argument_list|(
name|a
argument_list|,
name|DEFAULT_MAX_DETERMINIZED_STATES
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|Operations
operator|.
name|run
argument_list|(
name|a
argument_list|,
literal|"0999"
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|Operations
operator|.
name|run
argument_list|(
name|a
argument_list|,
literal|"00999"
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|Operations
operator|.
name|run
argument_list|(
name|a
argument_list|,
literal|"000999"
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|testAnotherInterval
specifier|public
name|void
name|testAnotherInterval
parameter_list|()
throws|throws
name|Exception
block|{
name|Automaton
name|a
init|=
name|Automata
operator|.
name|makeInterval
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|a
operator|=
name|Operations
operator|.
name|determinize
argument_list|(
name|a
argument_list|,
name|DEFAULT_MAX_DETERMINIZED_STATES
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|Operations
operator|.
name|run
argument_list|(
name|a
argument_list|,
literal|"01"
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|testIntervalRandom
specifier|public
name|void
name|testIntervalRandom
parameter_list|()
throws|throws
name|Exception
block|{
name|int
name|ITERS
init|=
name|atLeast
argument_list|(
literal|100
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|iter
init|=
literal|0
init|;
name|iter
operator|<
name|ITERS
condition|;
name|iter
operator|++
control|)
block|{
name|int
name|min
init|=
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|random
argument_list|()
argument_list|,
literal|0
argument_list|,
literal|100000
argument_list|)
decl_stmt|;
name|int
name|max
init|=
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|random
argument_list|()
argument_list|,
name|min
argument_list|,
name|min
operator|+
literal|100000
argument_list|)
decl_stmt|;
name|int
name|digits
decl_stmt|;
if|if
condition|(
name|random
argument_list|()
operator|.
name|nextBoolean
argument_list|()
condition|)
block|{
name|digits
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|String
name|s
init|=
name|Integer
operator|.
name|toString
argument_list|(
name|max
argument_list|)
decl_stmt|;
name|digits
operator|=
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|random
argument_list|()
argument_list|,
name|s
operator|.
name|length
argument_list|()
argument_list|,
literal|2
operator|*
name|s
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|StringBuilder
name|b
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|digits
condition|;
name|i
operator|++
control|)
block|{
name|b
operator|.
name|append
argument_list|(
literal|'0'
argument_list|)
expr_stmt|;
block|}
name|String
name|prefix
init|=
name|b
operator|.
name|toString
argument_list|()
decl_stmt|;
name|Automaton
name|a
init|=
name|Operations
operator|.
name|determinize
argument_list|(
name|Automata
operator|.
name|makeInterval
argument_list|(
name|min
argument_list|,
name|max
argument_list|,
name|digits
argument_list|)
argument_list|,
name|DEFAULT_MAX_DETERMINIZED_STATES
argument_list|)
decl_stmt|;
if|if
condition|(
name|random
argument_list|()
operator|.
name|nextBoolean
argument_list|()
condition|)
block|{
name|a
operator|=
name|MinimizationOperations
operator|.
name|minimize
argument_list|(
name|a
argument_list|,
name|DEFAULT_MAX_DETERMINIZED_STATES
argument_list|)
expr_stmt|;
block|}
name|String
name|mins
init|=
name|Integer
operator|.
name|toString
argument_list|(
name|min
argument_list|)
decl_stmt|;
name|String
name|maxs
init|=
name|Integer
operator|.
name|toString
argument_list|(
name|max
argument_list|)
decl_stmt|;
if|if
condition|(
name|digits
operator|>
literal|0
condition|)
block|{
name|mins
operator|=
name|prefix
operator|.
name|substring
argument_list|(
name|mins
operator|.
name|length
argument_list|()
argument_list|)
operator|+
name|mins
expr_stmt|;
name|maxs
operator|=
name|prefix
operator|.
name|substring
argument_list|(
name|maxs
operator|.
name|length
argument_list|()
argument_list|)
operator|+
name|maxs
expr_stmt|;
block|}
name|assertTrue
argument_list|(
name|Operations
operator|.
name|run
argument_list|(
name|a
argument_list|,
name|mins
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|Operations
operator|.
name|run
argument_list|(
name|a
argument_list|,
name|maxs
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|iter2
init|=
literal|0
init|;
name|iter2
operator|<
literal|100
condition|;
name|iter2
operator|++
control|)
block|{
name|int
name|x
init|=
name|random
argument_list|()
operator|.
name|nextInt
argument_list|(
literal|2
operator|*
name|max
argument_list|)
decl_stmt|;
name|boolean
name|expected
init|=
name|x
operator|>=
name|min
operator|&&
name|x
operator|<=
name|max
decl_stmt|;
name|String
name|sx
init|=
name|Integer
operator|.
name|toString
argument_list|(
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|sx
operator|.
name|length
argument_list|()
operator|<
name|digits
condition|)
block|{
comment|// Left-fill with 0s
name|sx
operator|=
name|b
operator|.
name|substring
argument_list|(
name|sx
operator|.
name|length
argument_list|()
argument_list|)
operator|+
name|sx
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|digits
operator|==
literal|0
condition|)
block|{
comment|// Left-fill with random number of 0s:
name|int
name|numZeros
init|=
name|random
argument_list|()
operator|.
name|nextInt
argument_list|(
literal|10
argument_list|)
decl_stmt|;
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numZeros
condition|;
name|i
operator|++
control|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|'0'
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
name|sx
argument_list|)
expr_stmt|;
name|sx
operator|=
name|sb
operator|.
name|toString
argument_list|()
expr_stmt|;
block|}
name|assertEquals
argument_list|(
name|expected
argument_list|,
name|Operations
operator|.
name|run
argument_list|(
name|a
argument_list|,
name|sx
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|assertMatches
specifier|private
name|void
name|assertMatches
parameter_list|(
name|Automaton
name|a
parameter_list|,
name|String
modifier|...
name|strings
parameter_list|)
block|{
name|Set
argument_list|<
name|IntsRef
argument_list|>
name|expected
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|s
range|:
name|strings
control|)
block|{
name|IntsRefBuilder
name|ints
init|=
operator|new
name|IntsRefBuilder
argument_list|()
decl_stmt|;
name|expected
operator|.
name|add
argument_list|(
name|Util
operator|.
name|toUTF32
argument_list|(
name|s
argument_list|,
name|ints
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|assertEquals
argument_list|(
name|expected
argument_list|,
name|Operations
operator|.
name|getFiniteStrings
argument_list|(
name|Operations
operator|.
name|determinize
argument_list|(
name|a
argument_list|,
name|DEFAULT_MAX_DETERMINIZED_STATES
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|testConcatenatePreservesDet
specifier|public
name|void
name|testConcatenatePreservesDet
parameter_list|()
throws|throws
name|Exception
block|{
name|Automaton
name|a1
init|=
name|Automata
operator|.
name|makeString
argument_list|(
literal|"foobar"
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|a1
operator|.
name|isDeterministic
argument_list|()
argument_list|)
expr_stmt|;
name|Automaton
name|a2
init|=
name|Automata
operator|.
name|makeString
argument_list|(
literal|"baz"
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|a2
operator|.
name|isDeterministic
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
operator|(
name|Operations
operator|.
name|concatenate
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|a1
argument_list|,
name|a2
argument_list|)
argument_list|)
operator|.
name|isDeterministic
argument_list|()
operator|)
argument_list|)
expr_stmt|;
block|}
DECL|method|testRemoveDeadStates
specifier|public
name|void
name|testRemoveDeadStates
parameter_list|()
throws|throws
name|Exception
block|{
name|Automaton
name|a
init|=
name|Operations
operator|.
name|concatenate
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|Automata
operator|.
name|makeString
argument_list|(
literal|"x"
argument_list|)
argument_list|,
name|Automata
operator|.
name|makeString
argument_list|(
literal|"y"
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|4
argument_list|,
name|a
operator|.
name|getNumStates
argument_list|()
argument_list|)
expr_stmt|;
name|a
operator|=
name|Operations
operator|.
name|removeDeadStates
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|3
argument_list|,
name|a
operator|.
name|getNumStates
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|testRemoveDeadStatesEmpty1
specifier|public
name|void
name|testRemoveDeadStatesEmpty1
parameter_list|()
throws|throws
name|Exception
block|{
name|Automaton
name|a
init|=
operator|new
name|Automaton
argument_list|()
decl_stmt|;
name|a
operator|.
name|finishState
argument_list|()
expr_stmt|;
name|assertTrue
argument_list|(
name|Operations
operator|.
name|isEmpty
argument_list|(
name|a
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|Operations
operator|.
name|isEmpty
argument_list|(
name|Operations
operator|.
name|removeDeadStates
argument_list|(
name|a
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|testRemoveDeadStatesEmpty2
specifier|public
name|void
name|testRemoveDeadStatesEmpty2
parameter_list|()
throws|throws
name|Exception
block|{
name|Automaton
name|a
init|=
operator|new
name|Automaton
argument_list|()
decl_stmt|;
name|a
operator|.
name|finishState
argument_list|()
expr_stmt|;
name|assertTrue
argument_list|(
name|Operations
operator|.
name|isEmpty
argument_list|(
name|a
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|Operations
operator|.
name|isEmpty
argument_list|(
name|Operations
operator|.
name|removeDeadStates
argument_list|(
name|a
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|testRemoveDeadStatesEmpty3
specifier|public
name|void
name|testRemoveDeadStatesEmpty3
parameter_list|()
throws|throws
name|Exception
block|{
name|Automaton
name|a
init|=
operator|new
name|Automaton
argument_list|()
decl_stmt|;
name|int
name|init
init|=
name|a
operator|.
name|createState
argument_list|()
decl_stmt|;
name|int
name|fini
init|=
name|a
operator|.
name|createState
argument_list|()
decl_stmt|;
name|a
operator|.
name|addTransition
argument_list|(
name|init
argument_list|,
name|fini
argument_list|,
literal|'a'
argument_list|)
expr_stmt|;
name|Automaton
name|a2
init|=
name|Operations
operator|.
name|removeDeadStates
argument_list|(
name|a
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|a2
operator|.
name|getNumStates
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|testConcatEmpty
specifier|public
name|void
name|testConcatEmpty
parameter_list|()
throws|throws
name|Exception
block|{
comment|// If you concat empty automaton to anything the result should still be empty:
name|Automaton
name|a
init|=
name|Operations
operator|.
name|concatenate
argument_list|(
name|Automata
operator|.
name|makeEmpty
argument_list|()
argument_list|,
name|Automata
operator|.
name|makeString
argument_list|(
literal|"foo"
argument_list|)
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
operator|new
name|HashSet
argument_list|<
name|IntsRef
argument_list|>
argument_list|()
argument_list|,
name|Operations
operator|.
name|getFiniteStrings
argument_list|(
name|a
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|a
operator|=
name|Operations
operator|.
name|concatenate
argument_list|(
name|Automata
operator|.
name|makeString
argument_list|(
literal|"foo"
argument_list|)
argument_list|,
name|Automata
operator|.
name|makeEmpty
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
operator|new
name|HashSet
argument_list|<
name|IntsRef
argument_list|>
argument_list|()
argument_list|,
name|Operations
operator|.
name|getFiniteStrings
argument_list|(
name|a
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|testSeemsNonEmptyButIsNot1
specifier|public
name|void
name|testSeemsNonEmptyButIsNot1
parameter_list|()
throws|throws
name|Exception
block|{
name|Automaton
name|a
init|=
operator|new
name|Automaton
argument_list|()
decl_stmt|;
comment|// Init state has a transition but doesn't lead to accept
name|int
name|init
init|=
name|a
operator|.
name|createState
argument_list|()
decl_stmt|;
name|int
name|s
init|=
name|a
operator|.
name|createState
argument_list|()
decl_stmt|;
name|a
operator|.
name|addTransition
argument_list|(
name|init
argument_list|,
name|s
argument_list|,
literal|'a'
argument_list|)
expr_stmt|;
name|a
operator|.
name|finishState
argument_list|()
expr_stmt|;
name|assertTrue
argument_list|(
name|Operations
operator|.
name|isEmpty
argument_list|(
name|a
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|testSeemsNonEmptyButIsNot2
specifier|public
name|void
name|testSeemsNonEmptyButIsNot2
parameter_list|()
throws|throws
name|Exception
block|{
name|Automaton
name|a
init|=
operator|new
name|Automaton
argument_list|()
decl_stmt|;
name|int
name|init
init|=
name|a
operator|.
name|createState
argument_list|()
decl_stmt|;
name|int
name|s
init|=
name|a
operator|.
name|createState
argument_list|()
decl_stmt|;
name|a
operator|.
name|addTransition
argument_list|(
name|init
argument_list|,
name|s
argument_list|,
literal|'a'
argument_list|)
expr_stmt|;
comment|// An orphan'd accept state
name|s
operator|=
name|a
operator|.
name|createState
argument_list|()
expr_stmt|;
name|a
operator|.
name|setAccept
argument_list|(
name|s
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|a
operator|.
name|finishState
argument_list|()
expr_stmt|;
name|assertTrue
argument_list|(
name|Operations
operator|.
name|isEmpty
argument_list|(
name|a
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|testSameLanguage1
specifier|public
name|void
name|testSameLanguage1
parameter_list|()
throws|throws
name|Exception
block|{
name|Automaton
name|a
init|=
name|Automata
operator|.
name|makeEmptyString
argument_list|()
decl_stmt|;
name|Automaton
name|a2
init|=
name|Automata
operator|.
name|makeEmptyString
argument_list|()
decl_stmt|;
name|int
name|state
init|=
name|a2
operator|.
name|createState
argument_list|()
decl_stmt|;
name|a2
operator|.
name|addTransition
argument_list|(
literal|0
argument_list|,
name|state
argument_list|,
literal|'a'
argument_list|)
expr_stmt|;
name|a2
operator|.
name|finishState
argument_list|()
expr_stmt|;
name|assertTrue
argument_list|(
name|Operations
operator|.
name|sameLanguage
argument_list|(
name|Operations
operator|.
name|removeDeadStates
argument_list|(
name|a
argument_list|)
argument_list|,
name|Operations
operator|.
name|removeDeadStates
argument_list|(
name|a2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|randomNoOp
specifier|private
name|Automaton
name|randomNoOp
parameter_list|(
name|Automaton
name|a
parameter_list|)
block|{
switch|switch
condition|(
name|random
argument_list|()
operator|.
name|nextInt
argument_list|(
literal|7
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"  randomNoOp: determinize"
argument_list|)
expr_stmt|;
block|}
return|return
name|Operations
operator|.
name|determinize
argument_list|(
name|a
argument_list|,
name|Integer
operator|.
name|MAX_VALUE
argument_list|)
return|;
case|case
literal|1
case|:
if|if
condition|(
name|a
operator|.
name|getNumStates
argument_list|()
operator|<
literal|100
condition|)
block|{
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"  randomNoOp: minimize"
argument_list|)
expr_stmt|;
block|}
return|return
name|MinimizationOperations
operator|.
name|minimize
argument_list|(
name|a
argument_list|,
name|DEFAULT_MAX_DETERMINIZED_STATES
argument_list|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"  randomNoOp: skip op=minimize: too many states ("
operator|+
name|a
operator|.
name|getNumStates
argument_list|()
operator|+
literal|")"
argument_list|)
expr_stmt|;
block|}
return|return
name|a
return|;
block|}
case|case
literal|2
case|:
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"  randomNoOp: removeDeadStates"
argument_list|)
expr_stmt|;
block|}
return|return
name|Operations
operator|.
name|removeDeadStates
argument_list|(
name|a
argument_list|)
return|;
case|case
literal|3
case|:
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"  randomNoOp: reverse reverse"
argument_list|)
expr_stmt|;
block|}
name|a
operator|=
name|Operations
operator|.
name|reverse
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|a
operator|=
name|randomNoOp
argument_list|(
name|a
argument_list|)
expr_stmt|;
return|return
name|Operations
operator|.
name|reverse
argument_list|(
name|a
argument_list|)
return|;
case|case
literal|4
case|:
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"  randomNoOp: concat empty string"
argument_list|)
expr_stmt|;
block|}
return|return
name|Operations
operator|.
name|concatenate
argument_list|(
name|a
argument_list|,
name|Automata
operator|.
name|makeEmptyString
argument_list|()
argument_list|)
return|;
case|case
literal|5
case|:
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"  randomNoOp: union empty automaton"
argument_list|)
expr_stmt|;
block|}
return|return
name|Operations
operator|.
name|union
argument_list|(
name|a
argument_list|,
name|Automata
operator|.
name|makeEmpty
argument_list|()
argument_list|)
return|;
case|case
literal|6
case|:
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"  randomNoOp: do nothing!"
argument_list|)
expr_stmt|;
block|}
return|return
name|a
return|;
block|}
assert|assert
literal|false
assert|;
return|return
literal|null
return|;
block|}
DECL|method|unionTerms
specifier|private
name|Automaton
name|unionTerms
parameter_list|(
name|Collection
argument_list|<
name|BytesRef
argument_list|>
name|terms
parameter_list|)
block|{
name|Automaton
name|a
decl_stmt|;
if|if
condition|(
name|random
argument_list|()
operator|.
name|nextBoolean
argument_list|()
condition|)
block|{
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"TEST: unionTerms: use union"
argument_list|)
expr_stmt|;
block|}
name|List
argument_list|<
name|Automaton
argument_list|>
name|as
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|BytesRef
name|term
range|:
name|terms
control|)
block|{
name|as
operator|.
name|add
argument_list|(
name|Automata
operator|.
name|makeString
argument_list|(
name|term
operator|.
name|utf8ToString
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|a
operator|=
name|Operations
operator|.
name|union
argument_list|(
name|as
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"TEST: unionTerms: use makeStringUnion"
argument_list|)
expr_stmt|;
block|}
name|List
argument_list|<
name|BytesRef
argument_list|>
name|termsList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|terms
argument_list|)
decl_stmt|;
name|Collections
operator|.
name|sort
argument_list|(
name|termsList
argument_list|)
expr_stmt|;
name|a
operator|=
name|Automata
operator|.
name|makeStringUnion
argument_list|(
name|termsList
argument_list|)
expr_stmt|;
block|}
return|return
name|randomNoOp
argument_list|(
name|a
argument_list|)
return|;
block|}
DECL|method|getRandomString
specifier|private
name|String
name|getRandomString
parameter_list|()
block|{
comment|//return TestUtil.randomSimpleString(random());
return|return
name|TestUtil
operator|.
name|randomRealisticUnicodeString
argument_list|(
name|random
argument_list|()
argument_list|)
return|;
block|}
DECL|method|testRandomFinite
specifier|public
name|void
name|testRandomFinite
parameter_list|()
throws|throws
name|Exception
block|{
name|int
name|numTerms
init|=
name|atLeast
argument_list|(
literal|10
argument_list|)
decl_stmt|;
name|int
name|iters
init|=
name|atLeast
argument_list|(
literal|100
argument_list|)
decl_stmt|;
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"TEST: numTerms="
operator|+
name|numTerms
operator|+
literal|" iters="
operator|+
name|iters
argument_list|)
expr_stmt|;
block|}
name|Set
argument_list|<
name|BytesRef
argument_list|>
name|terms
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
while|while
condition|(
name|terms
operator|.
name|size
argument_list|()
operator|<
name|numTerms
condition|)
block|{
name|terms
operator|.
name|add
argument_list|(
operator|new
name|BytesRef
argument_list|(
name|getRandomString
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|Automaton
name|a
init|=
name|unionTerms
argument_list|(
name|terms
argument_list|)
decl_stmt|;
name|assertSame
argument_list|(
name|terms
argument_list|,
name|a
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|iter
init|=
literal|0
init|;
name|iter
operator|<
name|iters
condition|;
name|iter
operator|++
control|)
block|{
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"TEST: iter="
operator|+
name|iter
operator|+
literal|" numTerms="
operator|+
name|terms
operator|.
name|size
argument_list|()
operator|+
literal|" a.numStates="
operator|+
name|a
operator|.
name|getNumStates
argument_list|()
argument_list|)
expr_stmt|;
comment|/*         System.out.println("  terms:");         for(BytesRef term : terms) {           System.out.println("    " + term);         }         */
block|}
switch|switch
condition|(
name|random
argument_list|()
operator|.
name|nextInt
argument_list|(
literal|15
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
comment|// concatenate prefix
block|{
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"  op=concat prefix"
argument_list|)
expr_stmt|;
block|}
name|Set
argument_list|<
name|BytesRef
argument_list|>
name|newTerms
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
name|BytesRef
name|prefix
init|=
operator|new
name|BytesRef
argument_list|(
name|getRandomString
argument_list|()
argument_list|)
decl_stmt|;
name|BytesRefBuilder
name|newTerm
init|=
operator|new
name|BytesRefBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|BytesRef
name|term
range|:
name|terms
control|)
block|{
name|newTerm
operator|.
name|copyBytes
argument_list|(
name|prefix
argument_list|)
expr_stmt|;
name|newTerm
operator|.
name|append
argument_list|(
name|term
argument_list|)
expr_stmt|;
name|newTerms
operator|.
name|add
argument_list|(
name|newTerm
operator|.
name|toBytesRef
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|terms
operator|=
name|newTerms
expr_stmt|;
name|boolean
name|wasDeterministic1
init|=
name|a
operator|.
name|isDeterministic
argument_list|()
decl_stmt|;
name|a
operator|=
name|Operations
operator|.
name|concatenate
argument_list|(
name|Automata
operator|.
name|makeString
argument_list|(
name|prefix
operator|.
name|utf8ToString
argument_list|()
argument_list|)
argument_list|,
name|a
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|wasDeterministic1
argument_list|,
name|a
operator|.
name|isDeterministic
argument_list|()
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|1
case|:
comment|// concatenate suffix
block|{
name|BytesRef
name|suffix
init|=
operator|new
name|BytesRef
argument_list|(
name|getRandomString
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"  op=concat suffix "
operator|+
name|suffix
argument_list|)
expr_stmt|;
block|}
name|Set
argument_list|<
name|BytesRef
argument_list|>
name|newTerms
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
name|BytesRefBuilder
name|newTerm
init|=
operator|new
name|BytesRefBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|BytesRef
name|term
range|:
name|terms
control|)
block|{
name|newTerm
operator|.
name|copyBytes
argument_list|(
name|term
argument_list|)
expr_stmt|;
name|newTerm
operator|.
name|append
argument_list|(
name|suffix
argument_list|)
expr_stmt|;
name|newTerms
operator|.
name|add
argument_list|(
name|newTerm
operator|.
name|toBytesRef
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|terms
operator|=
name|newTerms
expr_stmt|;
name|a
operator|=
name|Operations
operator|.
name|concatenate
argument_list|(
name|a
argument_list|,
name|Automata
operator|.
name|makeString
argument_list|(
name|suffix
operator|.
name|utf8ToString
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|2
case|:
comment|// determinize
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"  op=determinize"
argument_list|)
expr_stmt|;
block|}
name|a
operator|=
name|Operations
operator|.
name|determinize
argument_list|(
name|a
argument_list|,
name|Integer
operator|.
name|MAX_VALUE
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|a
operator|.
name|isDeterministic
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
if|if
condition|(
name|a
operator|.
name|getNumStates
argument_list|()
operator|<
literal|100
condition|)
block|{
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"  op=minimize"
argument_list|)
expr_stmt|;
block|}
comment|// minimize
name|a
operator|=
name|MinimizationOperations
operator|.
name|minimize
argument_list|(
name|a
argument_list|,
name|DEFAULT_MAX_DETERMINIZED_STATES
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"  skip op=minimize: too many states ("
operator|+
name|a
operator|.
name|getNumStates
argument_list|()
operator|+
literal|")"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|4
case|:
comment|// union
block|{
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"  op=union"
argument_list|)
expr_stmt|;
block|}
name|Set
argument_list|<
name|BytesRef
argument_list|>
name|newTerms
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
name|int
name|numNewTerms
init|=
name|random
argument_list|()
operator|.
name|nextInt
argument_list|(
literal|5
argument_list|)
decl_stmt|;
while|while
condition|(
name|newTerms
operator|.
name|size
argument_list|()
operator|<
name|numNewTerms
condition|)
block|{
name|newTerms
operator|.
name|add
argument_list|(
operator|new
name|BytesRef
argument_list|(
name|getRandomString
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|terms
operator|.
name|addAll
argument_list|(
name|newTerms
argument_list|)
expr_stmt|;
name|Automaton
name|newA
init|=
name|unionTerms
argument_list|(
name|newTerms
argument_list|)
decl_stmt|;
name|a
operator|=
name|Operations
operator|.
name|union
argument_list|(
name|a
argument_list|,
name|newA
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|5
case|:
comment|// optional
block|{
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"  op=optional"
argument_list|)
expr_stmt|;
block|}
name|a
operator|=
name|Operations
operator|.
name|optional
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|terms
operator|.
name|add
argument_list|(
operator|new
name|BytesRef
argument_list|()
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|6
case|:
comment|// minus finite
block|{
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"  op=minus finite"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|terms
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|RandomAcceptedStrings
name|rasl
init|=
operator|new
name|RandomAcceptedStrings
argument_list|(
name|Operations
operator|.
name|removeDeadStates
argument_list|(
name|a
argument_list|)
argument_list|)
decl_stmt|;
name|Set
argument_list|<
name|BytesRef
argument_list|>
name|toRemove
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
name|int
name|numToRemove
init|=
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|random
argument_list|()
argument_list|,
literal|1
argument_list|,
operator|(
name|terms
operator|.
name|size
argument_list|()
operator|+
literal|1
operator|)
operator|/
literal|2
argument_list|)
decl_stmt|;
while|while
condition|(
name|toRemove
operator|.
name|size
argument_list|()
operator|<
name|numToRemove
condition|)
block|{
name|int
index|[]
name|ints
init|=
name|rasl
operator|.
name|getRandomAcceptedString
argument_list|(
name|random
argument_list|()
argument_list|)
decl_stmt|;
name|BytesRef
name|term
init|=
operator|new
name|BytesRef
argument_list|(
name|UnicodeUtil
operator|.
name|newString
argument_list|(
name|ints
argument_list|,
literal|0
argument_list|,
name|ints
operator|.
name|length
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|toRemove
operator|.
name|contains
argument_list|(
name|term
argument_list|)
operator|==
literal|false
condition|)
block|{
name|toRemove
operator|.
name|add
argument_list|(
name|term
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|BytesRef
name|term
range|:
name|toRemove
control|)
block|{
name|boolean
name|removed
init|=
name|terms
operator|.
name|remove
argument_list|(
name|term
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|removed
argument_list|)
expr_stmt|;
block|}
name|Automaton
name|a2
init|=
name|unionTerms
argument_list|(
name|toRemove
argument_list|)
decl_stmt|;
name|a
operator|=
name|Operations
operator|.
name|minus
argument_list|(
name|a
argument_list|,
name|a2
argument_list|,
name|DEFAULT_MAX_DETERMINIZED_STATES
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|7
case|:
block|{
comment|// minus infinite
name|List
argument_list|<
name|Automaton
argument_list|>
name|as
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|int
name|count
init|=
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|random
argument_list|()
argument_list|,
literal|1
argument_list|,
literal|5
argument_list|)
decl_stmt|;
name|Set
argument_list|<
name|Integer
argument_list|>
name|prefixes
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
while|while
condition|(
name|prefixes
operator|.
name|size
argument_list|()
operator|<
name|count
condition|)
block|{
comment|// prefix is a leading ascii byte; we remove<prefix>* from a
name|int
name|prefix
init|=
name|random
argument_list|()
operator|.
name|nextInt
argument_list|(
literal|128
argument_list|)
decl_stmt|;
name|prefixes
operator|.
name|add
argument_list|(
name|prefix
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"  op=minus infinite prefixes="
operator|+
name|prefixes
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|prefix
range|:
name|prefixes
control|)
block|{
comment|// prefix is a leading ascii byte; we remove<prefix>* from a
name|Automaton
name|a2
init|=
operator|new
name|Automaton
argument_list|()
decl_stmt|;
name|int
name|init
init|=
name|a2
operator|.
name|createState
argument_list|()
decl_stmt|;
name|int
name|state
init|=
name|a2
operator|.
name|createState
argument_list|()
decl_stmt|;
name|a2
operator|.
name|addTransition
argument_list|(
name|init
argument_list|,
name|state
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
name|a2
operator|.
name|setAccept
argument_list|(
name|state
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|a2
operator|.
name|addTransition
argument_list|(
name|state
argument_list|,
name|state
argument_list|,
name|Character
operator|.
name|MIN_CODE_POINT
argument_list|,
name|Character
operator|.
name|MAX_CODE_POINT
argument_list|)
expr_stmt|;
name|a2
operator|.
name|finishState
argument_list|()
expr_stmt|;
name|as
operator|.
name|add
argument_list|(
name|a2
argument_list|)
expr_stmt|;
name|Iterator
argument_list|<
name|BytesRef
argument_list|>
name|it
init|=
name|terms
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|BytesRef
name|term
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|term
operator|.
name|length
operator|>
literal|0
operator|&&
operator|(
name|term
operator|.
name|bytes
index|[
name|term
operator|.
name|offset
index|]
operator|&
literal|0xFF
operator|)
operator|==
name|prefix
condition|)
block|{
name|it
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
block|}
block|}
name|Automaton
name|a2
init|=
name|randomNoOp
argument_list|(
name|Operations
operator|.
name|union
argument_list|(
name|as
argument_list|)
argument_list|)
decl_stmt|;
name|a
operator|=
name|Operations
operator|.
name|minus
argument_list|(
name|a
argument_list|,
name|a2
argument_list|,
name|DEFAULT_MAX_DETERMINIZED_STATES
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|8
case|:
block|{
name|int
name|count
init|=
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|random
argument_list|()
argument_list|,
literal|10
argument_list|,
literal|20
argument_list|)
decl_stmt|;
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"  op=intersect infinite count="
operator|+
name|count
argument_list|)
expr_stmt|;
block|}
comment|// intersect infinite
name|List
argument_list|<
name|Automaton
argument_list|>
name|as
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|Integer
argument_list|>
name|prefixes
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
while|while
condition|(
name|prefixes
operator|.
name|size
argument_list|()
operator|<
name|count
condition|)
block|{
name|int
name|prefix
init|=
name|random
argument_list|()
operator|.
name|nextInt
argument_list|(
literal|128
argument_list|)
decl_stmt|;
name|prefixes
operator|.
name|add
argument_list|(
name|prefix
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"  prefixes="
operator|+
name|prefixes
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|prefix
range|:
name|prefixes
control|)
block|{
comment|// prefix is a leading ascii byte; we retain<prefix>* in a
name|Automaton
name|a2
init|=
operator|new
name|Automaton
argument_list|()
decl_stmt|;
name|int
name|init
init|=
name|a2
operator|.
name|createState
argument_list|()
decl_stmt|;
name|int
name|state
init|=
name|a2
operator|.
name|createState
argument_list|()
decl_stmt|;
name|a2
operator|.
name|addTransition
argument_list|(
name|init
argument_list|,
name|state
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
name|a2
operator|.
name|setAccept
argument_list|(
name|state
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|a2
operator|.
name|addTransition
argument_list|(
name|state
argument_list|,
name|state
argument_list|,
name|Character
operator|.
name|MIN_CODE_POINT
argument_list|,
name|Character
operator|.
name|MAX_CODE_POINT
argument_list|)
expr_stmt|;
name|a2
operator|.
name|finishState
argument_list|()
expr_stmt|;
name|as
operator|.
name|add
argument_list|(
name|a2
argument_list|)
expr_stmt|;
name|prefixes
operator|.
name|add
argument_list|(
name|prefix
argument_list|)
expr_stmt|;
block|}
name|Automaton
name|a2
init|=
name|Operations
operator|.
name|union
argument_list|(
name|as
argument_list|)
decl_stmt|;
if|if
condition|(
name|random
argument_list|()
operator|.
name|nextBoolean
argument_list|()
condition|)
block|{
name|a2
operator|=
name|Operations
operator|.
name|determinize
argument_list|(
name|a2
argument_list|,
name|DEFAULT_MAX_DETERMINIZED_STATES
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|random
argument_list|()
operator|.
name|nextBoolean
argument_list|()
condition|)
block|{
name|a2
operator|=
name|MinimizationOperations
operator|.
name|minimize
argument_list|(
name|a2
argument_list|,
name|DEFAULT_MAX_DETERMINIZED_STATES
argument_list|)
expr_stmt|;
block|}
name|a
operator|=
name|Operations
operator|.
name|intersection
argument_list|(
name|a
argument_list|,
name|a2
argument_list|)
expr_stmt|;
name|Iterator
argument_list|<
name|BytesRef
argument_list|>
name|it
init|=
name|terms
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|BytesRef
name|term
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|term
operator|.
name|length
operator|==
literal|0
operator|||
name|prefixes
operator|.
name|contains
argument_list|(
name|term
operator|.
name|bytes
index|[
name|term
operator|.
name|offset
index|]
operator|&
literal|0xff
argument_list|)
operator|==
literal|false
condition|)
block|{
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"  drop term="
operator|+
name|term
argument_list|)
expr_stmt|;
block|}
name|it
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"  keep term="
operator|+
name|term
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
break|break;
case|case
literal|9
case|:
comment|// reverse
block|{
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"  op=reverse"
argument_list|)
expr_stmt|;
block|}
name|a
operator|=
name|Operations
operator|.
name|reverse
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|Set
argument_list|<
name|BytesRef
argument_list|>
name|newTerms
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|BytesRef
name|term
range|:
name|terms
control|)
block|{
name|newTerms
operator|.
name|add
argument_list|(
operator|new
name|BytesRef
argument_list|(
operator|new
name|StringBuilder
argument_list|(
name|term
operator|.
name|utf8ToString
argument_list|()
argument_list|)
operator|.
name|reverse
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|terms
operator|=
name|newTerms
expr_stmt|;
block|}
break|break;
case|case
literal|10
case|:
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"  op=randomNoOp"
argument_list|)
expr_stmt|;
block|}
name|a
operator|=
name|randomNoOp
argument_list|(
name|a
argument_list|)
expr_stmt|;
break|break;
case|case
literal|11
case|:
comment|// interval
block|{
name|int
name|min
init|=
name|random
argument_list|()
operator|.
name|nextInt
argument_list|(
literal|1000
argument_list|)
decl_stmt|;
name|int
name|max
init|=
name|min
operator|+
name|random
argument_list|()
operator|.
name|nextInt
argument_list|(
literal|50
argument_list|)
decl_stmt|;
comment|// digits must be non-zero else we make cycle
name|int
name|digits
init|=
name|Integer
operator|.
name|toString
argument_list|(
name|max
argument_list|)
operator|.
name|length
argument_list|()
decl_stmt|;
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"  op=union interval min="
operator|+
name|min
operator|+
literal|" max="
operator|+
name|max
operator|+
literal|" digits="
operator|+
name|digits
argument_list|)
expr_stmt|;
block|}
name|a
operator|=
name|Operations
operator|.
name|union
argument_list|(
name|a
argument_list|,
name|Automata
operator|.
name|makeInterval
argument_list|(
name|min
argument_list|,
name|max
argument_list|,
name|digits
argument_list|)
argument_list|)
expr_stmt|;
name|StringBuilder
name|b
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|digits
condition|;
name|i
operator|++
control|)
block|{
name|b
operator|.
name|append
argument_list|(
literal|'0'
argument_list|)
expr_stmt|;
block|}
name|String
name|prefix
init|=
name|b
operator|.
name|toString
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|min
init|;
name|i
operator|<=
name|max
condition|;
name|i
operator|++
control|)
block|{
name|String
name|s
init|=
name|Integer
operator|.
name|toString
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|s
operator|.
name|length
argument_list|()
operator|<
name|digits
condition|)
block|{
comment|// Left-fill with 0s
name|s
operator|=
name|prefix
operator|.
name|substring
argument_list|(
name|s
operator|.
name|length
argument_list|()
argument_list|)
operator|+
name|s
expr_stmt|;
block|}
name|terms
operator|.
name|add
argument_list|(
operator|new
name|BytesRef
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|12
case|:
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"  op=remove the empty string"
argument_list|)
expr_stmt|;
block|}
name|a
operator|=
name|Operations
operator|.
name|minus
argument_list|(
name|a
argument_list|,
name|Automata
operator|.
name|makeEmptyString
argument_list|()
argument_list|,
name|DEFAULT_MAX_DETERMINIZED_STATES
argument_list|)
expr_stmt|;
name|terms
operator|.
name|remove
argument_list|(
operator|new
name|BytesRef
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
literal|13
case|:
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"  op=add the empty string"
argument_list|)
expr_stmt|;
block|}
name|a
operator|=
name|Operations
operator|.
name|union
argument_list|(
name|a
argument_list|,
name|Automata
operator|.
name|makeEmptyString
argument_list|()
argument_list|)
expr_stmt|;
name|terms
operator|.
name|add
argument_list|(
operator|new
name|BytesRef
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
literal|14
case|:
comment|// Safety in case we are really unlucky w/ the dice:
if|if
condition|(
name|terms
operator|.
name|size
argument_list|()
operator|<=
name|numTerms
operator|*
literal|3
condition|)
block|{
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"  op=concat finite automaton"
argument_list|)
expr_stmt|;
block|}
name|int
name|count
init|=
name|random
argument_list|()
operator|.
name|nextBoolean
argument_list|()
condition|?
literal|2
else|:
literal|3
decl_stmt|;
name|Set
argument_list|<
name|BytesRef
argument_list|>
name|addTerms
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
while|while
condition|(
name|addTerms
operator|.
name|size
argument_list|()
operator|<
name|count
condition|)
block|{
name|addTerms
operator|.
name|add
argument_list|(
operator|new
name|BytesRef
argument_list|(
name|getRandomString
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|VERBOSE
condition|)
block|{
for|for
control|(
name|BytesRef
name|term
range|:
name|addTerms
control|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"    term="
operator|+
name|term
argument_list|)
expr_stmt|;
block|}
block|}
name|Automaton
name|a2
init|=
name|unionTerms
argument_list|(
name|addTerms
argument_list|)
decl_stmt|;
name|Set
argument_list|<
name|BytesRef
argument_list|>
name|newTerms
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
if|if
condition|(
name|random
argument_list|()
operator|.
name|nextBoolean
argument_list|()
condition|)
block|{
comment|// suffix
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"  do suffix"
argument_list|)
expr_stmt|;
block|}
name|a
operator|=
name|Operations
operator|.
name|concatenate
argument_list|(
name|a
argument_list|,
name|randomNoOp
argument_list|(
name|a2
argument_list|)
argument_list|)
expr_stmt|;
name|BytesRefBuilder
name|newTerm
init|=
operator|new
name|BytesRefBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|BytesRef
name|term
range|:
name|terms
control|)
block|{
for|for
control|(
name|BytesRef
name|suffix
range|:
name|addTerms
control|)
block|{
name|newTerm
operator|.
name|copyBytes
argument_list|(
name|term
argument_list|)
expr_stmt|;
name|newTerm
operator|.
name|append
argument_list|(
name|suffix
argument_list|)
expr_stmt|;
name|newTerms
operator|.
name|add
argument_list|(
name|newTerm
operator|.
name|toBytesRef
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|// prefix
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"  do prefix"
argument_list|)
expr_stmt|;
block|}
name|a
operator|=
name|Operations
operator|.
name|concatenate
argument_list|(
name|randomNoOp
argument_list|(
name|a2
argument_list|)
argument_list|,
name|a
argument_list|)
expr_stmt|;
name|BytesRefBuilder
name|newTerm
init|=
operator|new
name|BytesRefBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|BytesRef
name|term
range|:
name|terms
control|)
block|{
for|for
control|(
name|BytesRef
name|prefix
range|:
name|addTerms
control|)
block|{
name|newTerm
operator|.
name|copyBytes
argument_list|(
name|prefix
argument_list|)
expr_stmt|;
name|newTerm
operator|.
name|append
argument_list|(
name|term
argument_list|)
expr_stmt|;
name|newTerms
operator|.
name|add
argument_list|(
name|newTerm
operator|.
name|toBytesRef
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|terms
operator|=
name|newTerms
expr_stmt|;
block|}
break|break;
default|default:
throw|throw
operator|new
name|AssertionError
argument_list|()
throw|;
block|}
name|assertSame
argument_list|(
name|terms
argument_list|,
name|a
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|AutomatonTestUtil
operator|.
name|isDeterministicSlow
argument_list|(
name|a
argument_list|)
argument_list|,
name|a
operator|.
name|isDeterministic
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|assertSame
argument_list|(
name|terms
argument_list|,
name|a
argument_list|)
expr_stmt|;
block|}
DECL|method|assertSame
specifier|private
name|void
name|assertSame
parameter_list|(
name|Collection
argument_list|<
name|BytesRef
argument_list|>
name|terms
parameter_list|,
name|Automaton
name|a
parameter_list|)
block|{
try|try
block|{
name|assertTrue
argument_list|(
name|Operations
operator|.
name|isFinite
argument_list|(
name|a
argument_list|)
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|Operations
operator|.
name|isTotal
argument_list|(
name|a
argument_list|)
argument_list|)
expr_stmt|;
name|Automaton
name|detA
init|=
name|Operations
operator|.
name|determinize
argument_list|(
name|a
argument_list|,
name|DEFAULT_MAX_DETERMINIZED_STATES
argument_list|)
decl_stmt|;
comment|// Make sure all terms are accepted:
name|IntsRefBuilder
name|scratch
init|=
operator|new
name|IntsRefBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|BytesRef
name|term
range|:
name|terms
control|)
block|{
name|Util
operator|.
name|toIntsRef
argument_list|(
name|term
argument_list|,
name|scratch
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"failed to accept term="
operator|+
name|term
operator|.
name|utf8ToString
argument_list|()
argument_list|,
name|Operations
operator|.
name|run
argument_list|(
name|detA
argument_list|,
name|term
operator|.
name|utf8ToString
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// Use getFiniteStrings:
name|Set
argument_list|<
name|IntsRef
argument_list|>
name|expected
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|BytesRef
name|term
range|:
name|terms
control|)
block|{
name|IntsRefBuilder
name|intsRef
init|=
operator|new
name|IntsRefBuilder
argument_list|()
decl_stmt|;
name|Util
operator|.
name|toUTF32
argument_list|(
name|term
operator|.
name|utf8ToString
argument_list|()
argument_list|,
name|intsRef
argument_list|)
expr_stmt|;
name|expected
operator|.
name|add
argument_list|(
name|intsRef
operator|.
name|toIntsRef
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|Set
argument_list|<
name|IntsRef
argument_list|>
name|actual
init|=
name|Operations
operator|.
name|getFiniteStrings
argument_list|(
name|a
argument_list|,
operator|-
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|expected
operator|.
name|equals
argument_list|(
name|actual
argument_list|)
operator|==
literal|false
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"FAILED:"
argument_list|)
expr_stmt|;
for|for
control|(
name|IntsRef
name|term
range|:
name|expected
control|)
block|{
if|if
condition|(
name|actual
operator|.
name|contains
argument_list|(
name|term
argument_list|)
operator|==
literal|false
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"  term="
operator|+
name|term
operator|+
literal|" should be accepted but isn't"
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|IntsRef
name|term
range|:
name|actual
control|)
block|{
if|if
condition|(
name|expected
operator|.
name|contains
argument_list|(
name|term
argument_list|)
operator|==
literal|false
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"  term="
operator|+
name|term
operator|+
literal|" is accepted but should not be"
argument_list|)
expr_stmt|;
block|}
block|}
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"mismatch"
argument_list|)
throw|;
block|}
comment|// Use sameLanguage:
name|Automaton
name|a2
init|=
name|Operations
operator|.
name|removeDeadStates
argument_list|(
name|Operations
operator|.
name|determinize
argument_list|(
name|unionTerms
argument_list|(
name|terms
argument_list|)
argument_list|,
name|Integer
operator|.
name|MAX_VALUE
argument_list|)
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|Operations
operator|.
name|sameLanguage
argument_list|(
name|a2
argument_list|,
name|Operations
operator|.
name|removeDeadStates
argument_list|(
name|Operations
operator|.
name|determinize
argument_list|(
name|a
argument_list|,
name|Integer
operator|.
name|MAX_VALUE
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|// Do same check, in UTF8 space
name|Automaton
name|utf8
init|=
name|randomNoOp
argument_list|(
operator|new
name|UTF32ToUTF8
argument_list|()
operator|.
name|convert
argument_list|(
name|a
argument_list|)
argument_list|)
decl_stmt|;
name|Set
argument_list|<
name|IntsRef
argument_list|>
name|expected2
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|BytesRef
name|term
range|:
name|terms
control|)
block|{
name|IntsRefBuilder
name|intsRef
init|=
operator|new
name|IntsRefBuilder
argument_list|()
decl_stmt|;
name|Util
operator|.
name|toIntsRef
argument_list|(
name|term
argument_list|,
name|intsRef
argument_list|)
expr_stmt|;
name|expected2
operator|.
name|add
argument_list|(
name|intsRef
operator|.
name|toIntsRef
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|assertEquals
argument_list|(
name|expected2
argument_list|,
name|Operations
operator|.
name|getFiniteStrings
argument_list|(
name|utf8
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|AssertionError
name|ae
parameter_list|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"TEST: FAILED: not same"
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"  terms (count="
operator|+
name|terms
operator|.
name|size
argument_list|()
operator|+
literal|"):"
argument_list|)
expr_stmt|;
for|for
control|(
name|BytesRef
name|term
range|:
name|terms
control|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"    "
operator|+
name|term
argument_list|)
expr_stmt|;
block|}
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"  automaton:"
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
name|a
operator|.
name|toDot
argument_list|()
argument_list|)
expr_stmt|;
comment|//a.writeDot("fail");
throw|throw
name|ae
throw|;
block|}
block|}
block|}
end_class
end_unit
