begin_unit
begin_package
DECL|package|org.apache.lucene.util
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
package|;
end_package
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStream
import|;
end_import
begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|charset
operator|.
name|StandardCharsets
import|;
end_import
begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|FileStore
import|;
end_import
begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|FileSystem
import|;
end_import
begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|Files
import|;
end_import
begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|LinkOption
import|;
end_import
begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|Path
import|;
end_import
begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|attribute
operator|.
name|FileAttributeView
import|;
end_import
begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|attribute
operator|.
name|FileStoreAttributeView
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|mockfile
operator|.
name|FilterFileSystem
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|mockfile
operator|.
name|FilterFileSystemProvider
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|mockfile
operator|.
name|FilterPath
import|;
end_import
begin_comment
comment|/** Simple test methods for IOUtils */
end_comment
begin_class
DECL|class|TestIOUtils
specifier|public
class|class
name|TestIOUtils
extends|extends
name|LuceneTestCase
block|{
DECL|method|testDeleteFileIgnoringExceptions
specifier|public
name|void
name|testDeleteFileIgnoringExceptions
parameter_list|()
throws|throws
name|Exception
block|{
name|Path
name|dir
init|=
name|createTempDir
argument_list|()
decl_stmt|;
name|Path
name|file1
init|=
name|dir
operator|.
name|resolve
argument_list|(
literal|"file1"
argument_list|)
decl_stmt|;
name|Files
operator|.
name|createFile
argument_list|(
name|file1
argument_list|)
expr_stmt|;
name|IOUtils
operator|.
name|deleteFilesIgnoringExceptions
argument_list|(
name|file1
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|Files
operator|.
name|exists
argument_list|(
name|file1
argument_list|)
argument_list|)
expr_stmt|;
comment|// actually deletes
block|}
DECL|method|testDontDeleteFileIgnoringExceptions
specifier|public
name|void
name|testDontDeleteFileIgnoringExceptions
parameter_list|()
throws|throws
name|Exception
block|{
name|Path
name|dir
init|=
name|createTempDir
argument_list|()
decl_stmt|;
name|Path
name|file1
init|=
name|dir
operator|.
name|resolve
argument_list|(
literal|"file1"
argument_list|)
decl_stmt|;
name|IOUtils
operator|.
name|deleteFilesIgnoringExceptions
argument_list|(
name|file1
argument_list|)
expr_stmt|;
comment|// no exception
block|}
DECL|method|testDeleteTwoFilesIgnoringExceptions
specifier|public
name|void
name|testDeleteTwoFilesIgnoringExceptions
parameter_list|()
throws|throws
name|Exception
block|{
name|Path
name|dir
init|=
name|createTempDir
argument_list|()
decl_stmt|;
name|Path
name|file1
init|=
name|dir
operator|.
name|resolve
argument_list|(
literal|"file1"
argument_list|)
decl_stmt|;
name|Path
name|file2
init|=
name|dir
operator|.
name|resolve
argument_list|(
literal|"file2"
argument_list|)
decl_stmt|;
comment|// only create file2
name|Files
operator|.
name|createFile
argument_list|(
name|file2
argument_list|)
expr_stmt|;
name|IOUtils
operator|.
name|deleteFilesIgnoringExceptions
argument_list|(
name|file1
argument_list|,
name|file2
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|Files
operator|.
name|exists
argument_list|(
name|file2
argument_list|)
argument_list|)
expr_stmt|;
comment|// no exception
comment|// actually deletes file2
block|}
DECL|method|testDeleteFileIfExists
specifier|public
name|void
name|testDeleteFileIfExists
parameter_list|()
throws|throws
name|Exception
block|{
name|Path
name|dir
init|=
name|createTempDir
argument_list|()
decl_stmt|;
name|Path
name|file1
init|=
name|dir
operator|.
name|resolve
argument_list|(
literal|"file1"
argument_list|)
decl_stmt|;
name|Files
operator|.
name|createFile
argument_list|(
name|file1
argument_list|)
expr_stmt|;
name|IOUtils
operator|.
name|deleteFilesIfExist
argument_list|(
name|file1
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|Files
operator|.
name|exists
argument_list|(
name|file1
argument_list|)
argument_list|)
expr_stmt|;
comment|// actually deletes
block|}
DECL|method|testDontDeleteDoesntExist
specifier|public
name|void
name|testDontDeleteDoesntExist
parameter_list|()
throws|throws
name|Exception
block|{
name|Path
name|dir
init|=
name|createTempDir
argument_list|()
decl_stmt|;
name|Path
name|file1
init|=
name|dir
operator|.
name|resolve
argument_list|(
literal|"file1"
argument_list|)
decl_stmt|;
name|IOUtils
operator|.
name|deleteFilesIfExist
argument_list|(
name|file1
argument_list|)
expr_stmt|;
comment|// no exception
block|}
DECL|method|testDeleteTwoFilesIfExist
specifier|public
name|void
name|testDeleteTwoFilesIfExist
parameter_list|()
throws|throws
name|Exception
block|{
name|Path
name|dir
init|=
name|createTempDir
argument_list|()
decl_stmt|;
name|Path
name|file1
init|=
name|dir
operator|.
name|resolve
argument_list|(
literal|"file1"
argument_list|)
decl_stmt|;
name|Path
name|file2
init|=
name|dir
operator|.
name|resolve
argument_list|(
literal|"file2"
argument_list|)
decl_stmt|;
comment|// only create file2
name|Files
operator|.
name|createFile
argument_list|(
name|file2
argument_list|)
expr_stmt|;
name|IOUtils
operator|.
name|deleteFilesIfExist
argument_list|(
name|file1
argument_list|,
name|file2
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|Files
operator|.
name|exists
argument_list|(
name|file2
argument_list|)
argument_list|)
expr_stmt|;
comment|// no exception
comment|// actually deletes file2
block|}
DECL|method|testSpinsBasics
specifier|public
name|void
name|testSpinsBasics
parameter_list|()
throws|throws
name|Exception
block|{
name|Path
name|dir
init|=
name|createTempDir
argument_list|()
decl_stmt|;
comment|// no exception, directory exists
name|IOUtils
operator|.
name|spins
argument_list|(
name|dir
argument_list|)
expr_stmt|;
name|Path
name|file
init|=
name|dir
operator|.
name|resolve
argument_list|(
literal|"exists"
argument_list|)
decl_stmt|;
name|Files
operator|.
name|createFile
argument_list|(
name|file
argument_list|)
expr_stmt|;
comment|// no exception, file exists
name|IOUtils
operator|.
name|spins
argument_list|(
name|file
argument_list|)
expr_stmt|;
comment|// exception: file doesn't exist
name|Path
name|fake
init|=
name|dir
operator|.
name|resolve
argument_list|(
literal|"nonexistent"
argument_list|)
decl_stmt|;
try|try
block|{
name|IOUtils
operator|.
name|spins
argument_list|(
name|fake
argument_list|)
expr_stmt|;
name|fail
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|expected
parameter_list|)
block|{
comment|// ok
block|}
block|}
comment|// fake up a filestore to test some underlying methods
DECL|class|MockFileStore
specifier|static
class|class
name|MockFileStore
extends|extends
name|FileStore
block|{
DECL|field|description
specifier|final
name|String
name|description
decl_stmt|;
DECL|field|type
specifier|final
name|String
name|type
decl_stmt|;
DECL|field|name
specifier|final
name|String
name|name
decl_stmt|;
DECL|method|MockFileStore
name|MockFileStore
parameter_list|(
name|String
name|description
parameter_list|,
name|String
name|type
parameter_list|,
name|String
name|name
parameter_list|)
block|{
name|this
operator|.
name|description
operator|=
name|description
expr_stmt|;
name|this
operator|.
name|type
operator|=
name|type
expr_stmt|;
name|this
operator|.
name|name
operator|=
name|name
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|type
specifier|public
name|String
name|type
parameter_list|()
block|{
return|return
name|type
return|;
block|}
annotation|@
name|Override
DECL|method|name
specifier|public
name|String
name|name
parameter_list|()
block|{
return|return
name|name
return|;
block|}
annotation|@
name|Override
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|description
return|;
block|}
comment|// TODO: we can enable mocking of these when we need them later:
annotation|@
name|Override
DECL|method|isReadOnly
specifier|public
name|boolean
name|isReadOnly
parameter_list|()
block|{
return|return
literal|false
return|;
block|}
annotation|@
name|Override
DECL|method|getTotalSpace
specifier|public
name|long
name|getTotalSpace
parameter_list|()
throws|throws
name|IOException
block|{
return|return
literal|1000
return|;
block|}
annotation|@
name|Override
DECL|method|getUsableSpace
specifier|public
name|long
name|getUsableSpace
parameter_list|()
throws|throws
name|IOException
block|{
return|return
literal|800
return|;
block|}
annotation|@
name|Override
DECL|method|getUnallocatedSpace
specifier|public
name|long
name|getUnallocatedSpace
parameter_list|()
throws|throws
name|IOException
block|{
return|return
literal|1000
return|;
block|}
annotation|@
name|Override
DECL|method|supportsFileAttributeView
specifier|public
name|boolean
name|supportsFileAttributeView
parameter_list|(
name|Class
argument_list|<
name|?
extends|extends
name|FileAttributeView
argument_list|>
name|type
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
annotation|@
name|Override
DECL|method|supportsFileAttributeView
specifier|public
name|boolean
name|supportsFileAttributeView
parameter_list|(
name|String
name|name
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
annotation|@
name|Override
DECL|method|getFileStoreAttributeView
specifier|public
parameter_list|<
name|V
extends|extends
name|FileStoreAttributeView
parameter_list|>
name|V
name|getFileStoreAttributeView
parameter_list|(
name|Class
argument_list|<
name|V
argument_list|>
name|type
parameter_list|)
block|{
return|return
literal|null
return|;
block|}
annotation|@
name|Override
DECL|method|getAttribute
specifier|public
name|Object
name|getAttribute
parameter_list|(
name|String
name|attribute
parameter_list|)
throws|throws
name|IOException
block|{
return|return
literal|null
return|;
block|}
block|}
DECL|method|testGetMountPoint
specifier|public
name|void
name|testGetMountPoint
parameter_list|()
throws|throws
name|Exception
block|{
name|assertEquals
argument_list|(
literal|"/"
argument_list|,
name|IOUtils
operator|.
name|getMountPoint
argument_list|(
operator|new
name|MockFileStore
argument_list|(
literal|"/ (/dev/sda1)"
argument_list|,
literal|"ext4"
argument_list|,
literal|"/dev/sda1"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"/test/ space(((trash)))/"
argument_list|,
name|IOUtils
operator|.
name|getMountPoint
argument_list|(
operator|new
name|MockFileStore
argument_list|(
literal|"/test/ space(((trash)))/ (/dev/sda1)"
argument_list|,
literal|"ext3"
argument_list|,
literal|"/dev/sda1"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"/"
argument_list|,
name|IOUtils
operator|.
name|getMountPoint
argument_list|(
operator|new
name|MockFileStore
argument_list|(
literal|"/ (notreal)"
argument_list|,
literal|"ext2"
argument_list|,
literal|"notreal"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/** mock linux that takes mappings of test files, to their associated filesystems.    *  it will chroot /dev and /sys requests to root, so you can mock those too.    *<p>    *  It is hacky by definition, so don't try putting it around a complex chain or anything.    */
DECL|class|MockLinuxFileSystemProvider
specifier|static
class|class
name|MockLinuxFileSystemProvider
extends|extends
name|FilterFileSystemProvider
block|{
DECL|field|filesToStore
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|FileStore
argument_list|>
name|filesToStore
decl_stmt|;
DECL|field|root
specifier|final
name|Path
name|root
decl_stmt|;
DECL|method|MockLinuxFileSystemProvider
specifier|public
name|MockLinuxFileSystemProvider
parameter_list|(
name|FileSystem
name|delegateInstance
parameter_list|,
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|FileStore
argument_list|>
name|filesToStore
parameter_list|,
name|Path
name|root
parameter_list|)
block|{
name|super
argument_list|(
literal|"mocklinux://"
argument_list|,
name|delegateInstance
argument_list|)
expr_stmt|;
specifier|final
name|Collection
argument_list|<
name|FileStore
argument_list|>
name|allStores
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|(
name|filesToStore
operator|.
name|values
argument_list|()
argument_list|)
decl_stmt|;
name|this
operator|.
name|fileSystem
operator|=
operator|new
name|FilterFileSystem
argument_list|(
name|this
argument_list|,
name|delegateInstance
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|Iterable
argument_list|<
name|FileStore
argument_list|>
name|getFileStores
parameter_list|()
block|{
return|return
name|allStores
return|;
block|}
annotation|@
name|Override
specifier|public
name|Path
name|getPath
parameter_list|(
name|String
name|first
parameter_list|,
name|String
modifier|...
name|more
parameter_list|)
block|{
return|return
operator|new
name|MockLinuxPath
argument_list|(
name|delegateInstance
operator|.
name|getPath
argument_list|(
name|first
argument_list|,
name|more
argument_list|)
argument_list|,
name|this
argument_list|)
return|;
block|}
block|}
expr_stmt|;
name|this
operator|.
name|filesToStore
operator|=
name|filesToStore
expr_stmt|;
name|this
operator|.
name|root
operator|=
operator|new
name|MockLinuxPath
argument_list|(
name|root
argument_list|,
name|this
operator|.
name|fileSystem
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|getFileStore
specifier|public
name|FileStore
name|getFileStore
parameter_list|(
name|Path
name|path
parameter_list|)
throws|throws
name|IOException
block|{
name|FileStore
name|ret
init|=
name|filesToStore
operator|.
name|get
argument_list|(
name|path
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|ret
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"this mock doesnt know wtf to do with: "
operator|+
name|path
argument_list|)
throw|;
block|}
comment|// act like the linux fs provider here, return a crazy rootfs one
if|if
condition|(
name|ret
operator|.
name|toString
argument_list|()
operator|.
name|startsWith
argument_list|(
name|root
operator|+
literal|" ("
argument_list|)
condition|)
block|{
return|return
operator|new
name|MockFileStore
argument_list|(
name|root
operator|+
literal|" (rootfs)"
argument_list|,
literal|"rootfs"
argument_list|,
literal|"rootfs"
argument_list|)
return|;
block|}
return|return
name|ret
return|;
block|}
DECL|method|maybeChroot
name|Path
name|maybeChroot
parameter_list|(
name|Path
name|path
parameter_list|)
block|{
if|if
condition|(
name|path
operator|.
name|toAbsolutePath
argument_list|()
operator|.
name|startsWith
argument_list|(
literal|"/sys"
argument_list|)
operator|||
name|path
operator|.
name|toAbsolutePath
argument_list|()
operator|.
name|startsWith
argument_list|(
literal|"/dev"
argument_list|)
condition|)
block|{
comment|// map to our chrooted location;
return|return
name|path
operator|.
name|getRoot
argument_list|()
operator|.
name|resolve
argument_list|(
name|root
argument_list|)
operator|.
name|resolve
argument_list|(
name|path
operator|.
name|toString
argument_list|()
operator|.
name|substring
argument_list|(
literal|1
argument_list|)
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|path
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|toDelegate
specifier|protected
name|Path
name|toDelegate
parameter_list|(
name|Path
name|path
parameter_list|)
block|{
return|return
name|super
operator|.
name|toDelegate
argument_list|(
name|maybeChroot
argument_list|(
name|path
argument_list|)
argument_list|)
return|;
block|}
DECL|class|MockLinuxPath
class|class
name|MockLinuxPath
extends|extends
name|FilterPath
block|{
DECL|method|MockLinuxPath
name|MockLinuxPath
parameter_list|(
name|Path
name|delegate
parameter_list|,
name|FileSystem
name|fileSystem
parameter_list|)
block|{
name|super
argument_list|(
name|delegate
argument_list|,
name|fileSystem
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|toRealPath
specifier|public
name|Path
name|toRealPath
parameter_list|(
name|LinkOption
modifier|...
name|options
parameter_list|)
throws|throws
name|IOException
block|{
name|Path
name|p
init|=
name|maybeChroot
argument_list|(
name|this
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
operator|==
name|this
condition|)
block|{
return|return
name|super
operator|.
name|toRealPath
argument_list|(
name|options
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|p
operator|.
name|toRealPath
argument_list|(
name|options
argument_list|)
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|wrap
specifier|protected
name|Path
name|wrap
parameter_list|(
name|Path
name|other
parameter_list|)
block|{
return|return
operator|new
name|MockLinuxPath
argument_list|(
name|other
argument_list|,
name|fileSystem
argument_list|)
return|;
block|}
block|}
block|}
DECL|method|testGetFileStore
specifier|public
name|void
name|testGetFileStore
parameter_list|()
throws|throws
name|Exception
block|{
name|Path
name|dir
init|=
name|createTempDir
argument_list|()
decl_stmt|;
name|dir
operator|=
name|FilterPath
operator|.
name|unwrap
argument_list|(
name|dir
argument_list|)
operator|.
name|toRealPath
argument_list|()
expr_stmt|;
comment|// now we can create some fake mount points:
name|FileStore
name|root
init|=
operator|new
name|MockFileStore
argument_list|(
name|dir
operator|.
name|toString
argument_list|()
operator|+
literal|" (/dev/sda1)"
argument_list|,
literal|"ntfs"
argument_list|,
literal|"/dev/sda1"
argument_list|)
decl_stmt|;
name|FileStore
name|usr
init|=
operator|new
name|MockFileStore
argument_list|(
name|dir
operator|.
name|resolve
argument_list|(
literal|"usr"
argument_list|)
operator|.
name|toString
argument_list|()
operator|+
literal|" (/dev/sda2)"
argument_list|,
literal|"xfs"
argument_list|,
literal|"/dev/sda2"
argument_list|)
decl_stmt|;
comment|// associate some preset files to these
name|Map
argument_list|<
name|String
argument_list|,
name|FileStore
argument_list|>
name|mappings
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|mappings
operator|.
name|put
argument_list|(
name|dir
operator|.
name|toString
argument_list|()
argument_list|,
name|root
argument_list|)
expr_stmt|;
name|mappings
operator|.
name|put
argument_list|(
name|dir
operator|.
name|resolve
argument_list|(
literal|"foo.txt"
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|,
name|root
argument_list|)
expr_stmt|;
name|mappings
operator|.
name|put
argument_list|(
name|dir
operator|.
name|resolve
argument_list|(
literal|"usr"
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|,
name|usr
argument_list|)
expr_stmt|;
name|mappings
operator|.
name|put
argument_list|(
name|dir
operator|.
name|resolve
argument_list|(
literal|"usr/bar.txt"
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|,
name|usr
argument_list|)
expr_stmt|;
name|FileSystem
name|mockLinux
init|=
operator|new
name|MockLinuxFileSystemProvider
argument_list|(
name|dir
operator|.
name|getFileSystem
argument_list|()
argument_list|,
name|mappings
argument_list|,
name|dir
argument_list|)
operator|.
name|getFileSystem
argument_list|(
literal|null
argument_list|)
decl_stmt|;
name|Path
name|mockPath
init|=
name|mockLinux
operator|.
name|getPath
argument_list|(
name|dir
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
comment|// sanity check our mock:
name|assertSame
argument_list|(
name|usr
argument_list|,
name|Files
operator|.
name|getFileStore
argument_list|(
name|mockPath
operator|.
name|resolve
argument_list|(
literal|"usr"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|assertSame
argument_list|(
name|usr
argument_list|,
name|Files
operator|.
name|getFileStore
argument_list|(
name|mockPath
operator|.
name|resolve
argument_list|(
literal|"usr/bar.txt"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|// for root filesystem we get a crappy one
name|assertNotSame
argument_list|(
name|root
argument_list|,
name|Files
operator|.
name|getFileStore
argument_list|(
name|mockPath
argument_list|)
argument_list|)
expr_stmt|;
name|assertNotSame
argument_list|(
name|usr
argument_list|,
name|Files
operator|.
name|getFileStore
argument_list|(
name|mockPath
argument_list|)
argument_list|)
expr_stmt|;
name|assertNotSame
argument_list|(
name|root
argument_list|,
name|Files
operator|.
name|getFileStore
argument_list|(
name|mockPath
operator|.
name|resolve
argument_list|(
literal|"foo.txt"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|assertNotSame
argument_list|(
name|usr
argument_list|,
name|Files
operator|.
name|getFileStore
argument_list|(
name|mockPath
operator|.
name|resolve
argument_list|(
literal|"foo.txt"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|// now test our method:
name|assertSame
argument_list|(
name|usr
argument_list|,
name|IOUtils
operator|.
name|getFileStore
argument_list|(
name|mockPath
operator|.
name|resolve
argument_list|(
literal|"usr"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|assertSame
argument_list|(
name|usr
argument_list|,
name|IOUtils
operator|.
name|getFileStore
argument_list|(
name|mockPath
operator|.
name|resolve
argument_list|(
literal|"usr/bar.txt"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|assertSame
argument_list|(
name|root
argument_list|,
name|IOUtils
operator|.
name|getFileStore
argument_list|(
name|mockPath
argument_list|)
argument_list|)
expr_stmt|;
name|assertSame
argument_list|(
name|root
argument_list|,
name|IOUtils
operator|.
name|getFileStore
argument_list|(
name|mockPath
operator|.
name|resolve
argument_list|(
literal|"foo.txt"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|testTmpfsDoesntSpin
specifier|public
name|void
name|testTmpfsDoesntSpin
parameter_list|()
throws|throws
name|Exception
block|{
name|Path
name|dir
init|=
name|createTempDir
argument_list|()
decl_stmt|;
name|dir
operator|=
name|FilterPath
operator|.
name|unwrap
argument_list|(
name|dir
argument_list|)
operator|.
name|toRealPath
argument_list|()
expr_stmt|;
comment|// fake tmpfs
name|FileStore
name|root
init|=
operator|new
name|MockFileStore
argument_list|(
name|dir
operator|.
name|toString
argument_list|()
operator|+
literal|" (/dev/sda1)"
argument_list|,
literal|"tmpfs"
argument_list|,
literal|"/dev/sda1"
argument_list|)
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|FileStore
argument_list|>
name|mappings
init|=
name|Collections
operator|.
name|singletonMap
argument_list|(
name|dir
operator|.
name|toString
argument_list|()
argument_list|,
name|root
argument_list|)
decl_stmt|;
name|FileSystem
name|mockLinux
init|=
operator|new
name|MockLinuxFileSystemProvider
argument_list|(
name|dir
operator|.
name|getFileSystem
argument_list|()
argument_list|,
name|mappings
argument_list|,
name|dir
argument_list|)
operator|.
name|getFileSystem
argument_list|(
literal|null
argument_list|)
decl_stmt|;
name|Path
name|mockPath
init|=
name|mockLinux
operator|.
name|getPath
argument_list|(
name|dir
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
name|assertFalse
argument_list|(
name|IOUtils
operator|.
name|spinsLinux
argument_list|(
name|mockPath
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|testNfsSpins
specifier|public
name|void
name|testNfsSpins
parameter_list|()
throws|throws
name|Exception
block|{
name|Path
name|dir
init|=
name|createTempDir
argument_list|()
decl_stmt|;
name|dir
operator|=
name|FilterPath
operator|.
name|unwrap
argument_list|(
name|dir
argument_list|)
operator|.
name|toRealPath
argument_list|()
expr_stmt|;
comment|// fake nfs
name|FileStore
name|root
init|=
operator|new
name|MockFileStore
argument_list|(
name|dir
operator|.
name|toString
argument_list|()
operator|+
literal|" (somenfsserver:/some/mount)"
argument_list|,
literal|"nfs"
argument_list|,
literal|"somenfsserver:/some/mount"
argument_list|)
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|FileStore
argument_list|>
name|mappings
init|=
name|Collections
operator|.
name|singletonMap
argument_list|(
name|dir
operator|.
name|toString
argument_list|()
argument_list|,
name|root
argument_list|)
decl_stmt|;
name|FileSystem
name|mockLinux
init|=
operator|new
name|MockLinuxFileSystemProvider
argument_list|(
name|dir
operator|.
name|getFileSystem
argument_list|()
argument_list|,
name|mappings
argument_list|,
name|dir
argument_list|)
operator|.
name|getFileSystem
argument_list|(
literal|null
argument_list|)
decl_stmt|;
name|Path
name|mockPath
init|=
name|mockLinux
operator|.
name|getPath
argument_list|(
name|dir
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|IOUtils
operator|.
name|spinsLinux
argument_list|(
name|mockPath
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|testSSD
specifier|public
name|void
name|testSSD
parameter_list|()
throws|throws
name|Exception
block|{
name|assumeFalse
argument_list|(
literal|"windows is not supported"
argument_list|,
name|Constants
operator|.
name|WINDOWS
argument_list|)
expr_stmt|;
name|Path
name|dir
init|=
name|createTempDir
argument_list|()
decl_stmt|;
name|dir
operator|=
name|FilterPath
operator|.
name|unwrap
argument_list|(
name|dir
argument_list|)
operator|.
name|toRealPath
argument_list|()
expr_stmt|;
comment|// fake ssd
name|FileStore
name|root
init|=
operator|new
name|MockFileStore
argument_list|(
name|dir
operator|.
name|toString
argument_list|()
operator|+
literal|" (/dev/zzz1)"
argument_list|,
literal|"btrfs"
argument_list|,
literal|"/dev/zzz1"
argument_list|)
decl_stmt|;
comment|// make a fake /dev/zzz1 for it
name|Path
name|devdir
init|=
name|dir
operator|.
name|resolve
argument_list|(
literal|"dev"
argument_list|)
decl_stmt|;
name|Files
operator|.
name|createDirectories
argument_list|(
name|devdir
argument_list|)
expr_stmt|;
name|Files
operator|.
name|createFile
argument_list|(
name|devdir
operator|.
name|resolve
argument_list|(
literal|"zzz1"
argument_list|)
argument_list|)
expr_stmt|;
comment|// make a fake /sys/block/zzz/queue/rotational file for it
name|Path
name|sysdir
init|=
name|dir
operator|.
name|resolve
argument_list|(
literal|"sys"
argument_list|)
operator|.
name|resolve
argument_list|(
literal|"block"
argument_list|)
operator|.
name|resolve
argument_list|(
literal|"zzz"
argument_list|)
operator|.
name|resolve
argument_list|(
literal|"queue"
argument_list|)
decl_stmt|;
name|Files
operator|.
name|createDirectories
argument_list|(
name|sysdir
argument_list|)
expr_stmt|;
try|try
init|(
name|OutputStream
name|o
init|=
name|Files
operator|.
name|newOutputStream
argument_list|(
name|sysdir
operator|.
name|resolve
argument_list|(
literal|"rotational"
argument_list|)
argument_list|)
init|)
block|{
name|o
operator|.
name|write
argument_list|(
literal|"0\n"
operator|.
name|getBytes
argument_list|(
name|StandardCharsets
operator|.
name|US_ASCII
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|Map
argument_list|<
name|String
argument_list|,
name|FileStore
argument_list|>
name|mappings
init|=
name|Collections
operator|.
name|singletonMap
argument_list|(
name|dir
operator|.
name|toString
argument_list|()
argument_list|,
name|root
argument_list|)
decl_stmt|;
name|FileSystem
name|mockLinux
init|=
operator|new
name|MockLinuxFileSystemProvider
argument_list|(
name|dir
operator|.
name|getFileSystem
argument_list|()
argument_list|,
name|mappings
argument_list|,
name|dir
argument_list|)
operator|.
name|getFileSystem
argument_list|(
literal|null
argument_list|)
decl_stmt|;
name|Path
name|mockPath
init|=
name|mockLinux
operator|.
name|getPath
argument_list|(
name|dir
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
name|assertFalse
argument_list|(
name|IOUtils
operator|.
name|spinsLinux
argument_list|(
name|mockPath
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|testRotatingPlatters
specifier|public
name|void
name|testRotatingPlatters
parameter_list|()
throws|throws
name|Exception
block|{
name|assumeFalse
argument_list|(
literal|"windows is not supported"
argument_list|,
name|Constants
operator|.
name|WINDOWS
argument_list|)
expr_stmt|;
name|Path
name|dir
init|=
name|createTempDir
argument_list|()
decl_stmt|;
name|dir
operator|=
name|FilterPath
operator|.
name|unwrap
argument_list|(
name|dir
argument_list|)
operator|.
name|toRealPath
argument_list|()
expr_stmt|;
comment|// fake ssd
name|FileStore
name|root
init|=
operator|new
name|MockFileStore
argument_list|(
name|dir
operator|.
name|toString
argument_list|()
operator|+
literal|" (/dev/zzz1)"
argument_list|,
literal|"reiser4"
argument_list|,
literal|"/dev/zzz1"
argument_list|)
decl_stmt|;
comment|// make a fake /dev/zzz1 for it
name|Path
name|devdir
init|=
name|dir
operator|.
name|resolve
argument_list|(
literal|"dev"
argument_list|)
decl_stmt|;
name|Files
operator|.
name|createDirectories
argument_list|(
name|devdir
argument_list|)
expr_stmt|;
name|Files
operator|.
name|createFile
argument_list|(
name|devdir
operator|.
name|resolve
argument_list|(
literal|"zzz1"
argument_list|)
argument_list|)
expr_stmt|;
comment|// make a fake /sys/block/zzz/queue/rotational file for it
name|Path
name|sysdir
init|=
name|dir
operator|.
name|resolve
argument_list|(
literal|"sys"
argument_list|)
operator|.
name|resolve
argument_list|(
literal|"block"
argument_list|)
operator|.
name|resolve
argument_list|(
literal|"zzz"
argument_list|)
operator|.
name|resolve
argument_list|(
literal|"queue"
argument_list|)
decl_stmt|;
name|Files
operator|.
name|createDirectories
argument_list|(
name|sysdir
argument_list|)
expr_stmt|;
try|try
init|(
name|OutputStream
name|o
init|=
name|Files
operator|.
name|newOutputStream
argument_list|(
name|sysdir
operator|.
name|resolve
argument_list|(
literal|"rotational"
argument_list|)
argument_list|)
init|)
block|{
name|o
operator|.
name|write
argument_list|(
literal|"1\n"
operator|.
name|getBytes
argument_list|(
name|StandardCharsets
operator|.
name|US_ASCII
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|Map
argument_list|<
name|String
argument_list|,
name|FileStore
argument_list|>
name|mappings
init|=
name|Collections
operator|.
name|singletonMap
argument_list|(
name|dir
operator|.
name|toString
argument_list|()
argument_list|,
name|root
argument_list|)
decl_stmt|;
name|FileSystem
name|mockLinux
init|=
operator|new
name|MockLinuxFileSystemProvider
argument_list|(
name|dir
operator|.
name|getFileSystem
argument_list|()
argument_list|,
name|mappings
argument_list|,
name|dir
argument_list|)
operator|.
name|getFileSystem
argument_list|(
literal|null
argument_list|)
decl_stmt|;
name|Path
name|mockPath
init|=
name|mockLinux
operator|.
name|getPath
argument_list|(
name|dir
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|IOUtils
operator|.
name|spinsLinux
argument_list|(
name|mockPath
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|testManyPartitions
specifier|public
name|void
name|testManyPartitions
parameter_list|()
throws|throws
name|Exception
block|{
name|assumeFalse
argument_list|(
literal|"windows is not supported"
argument_list|,
name|Constants
operator|.
name|WINDOWS
argument_list|)
expr_stmt|;
name|Path
name|dir
init|=
name|createTempDir
argument_list|()
decl_stmt|;
name|dir
operator|=
name|FilterPath
operator|.
name|unwrap
argument_list|(
name|dir
argument_list|)
operator|.
name|toRealPath
argument_list|()
expr_stmt|;
comment|// fake ssd
name|FileStore
name|root
init|=
operator|new
name|MockFileStore
argument_list|(
name|dir
operator|.
name|toString
argument_list|()
operator|+
literal|" (/dev/zzz12)"
argument_list|,
literal|"zfs"
argument_list|,
literal|"/dev/zzz12"
argument_list|)
decl_stmt|;
comment|// make a fake /dev/zzz11 for it
name|Path
name|devdir
init|=
name|dir
operator|.
name|resolve
argument_list|(
literal|"dev"
argument_list|)
decl_stmt|;
name|Files
operator|.
name|createDirectories
argument_list|(
name|devdir
argument_list|)
expr_stmt|;
name|Files
operator|.
name|createFile
argument_list|(
name|devdir
operator|.
name|resolve
argument_list|(
literal|"zzz12"
argument_list|)
argument_list|)
expr_stmt|;
comment|// make a fake /sys/block/zzz/queue/rotational file for it
name|Path
name|sysdir
init|=
name|dir
operator|.
name|resolve
argument_list|(
literal|"sys"
argument_list|)
operator|.
name|resolve
argument_list|(
literal|"block"
argument_list|)
operator|.
name|resolve
argument_list|(
literal|"zzz"
argument_list|)
operator|.
name|resolve
argument_list|(
literal|"queue"
argument_list|)
decl_stmt|;
name|Files
operator|.
name|createDirectories
argument_list|(
name|sysdir
argument_list|)
expr_stmt|;
try|try
init|(
name|OutputStream
name|o
init|=
name|Files
operator|.
name|newOutputStream
argument_list|(
name|sysdir
operator|.
name|resolve
argument_list|(
literal|"rotational"
argument_list|)
argument_list|)
init|)
block|{
name|o
operator|.
name|write
argument_list|(
literal|"0\n"
operator|.
name|getBytes
argument_list|(
name|StandardCharsets
operator|.
name|US_ASCII
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|Map
argument_list|<
name|String
argument_list|,
name|FileStore
argument_list|>
name|mappings
init|=
name|Collections
operator|.
name|singletonMap
argument_list|(
name|dir
operator|.
name|toString
argument_list|()
argument_list|,
name|root
argument_list|)
decl_stmt|;
name|FileSystem
name|mockLinux
init|=
operator|new
name|MockLinuxFileSystemProvider
argument_list|(
name|dir
operator|.
name|getFileSystem
argument_list|()
argument_list|,
name|mappings
argument_list|,
name|dir
argument_list|)
operator|.
name|getFileSystem
argument_list|(
literal|null
argument_list|)
decl_stmt|;
name|Path
name|mockPath
init|=
name|mockLinux
operator|.
name|getPath
argument_list|(
name|dir
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
name|assertFalse
argument_list|(
name|IOUtils
operator|.
name|spinsLinux
argument_list|(
name|mockPath
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_class
end_unit
