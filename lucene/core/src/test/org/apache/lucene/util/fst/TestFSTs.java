begin_unit
begin_package
DECL|package|org.apache.lucene.util.fst
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|fst
package|;
end_package
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|BufferedReader
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileInputStream
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileOutputStream
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStreamReader
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStreamWriter
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|StringWriter
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Writer
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|*
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|MockAnalyzer
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|codecs
operator|.
name|Codec
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|codecs
operator|.
name|lucene40
operator|.
name|Lucene40PostingsFormat
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|document
operator|.
name|Document
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|document
operator|.
name|Field
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|document
operator|.
name|StringField
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|IndexReader
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|IndexWriter
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|IndexWriterConfig
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|MultiFields
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|RandomIndexWriter
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|Term
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|Terms
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|TermsEnum
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|IndexSearcher
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|TermQuery
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|Directory
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|FSDirectory
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|IOContext
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|IndexInput
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|IndexOutput
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|MockDirectoryWrapper
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|BytesRef
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|IntsRef
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|LineFileDocs
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|LuceneTestCase
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|LuceneTestCase
operator|.
name|UseNoMemoryExpensiveCodec
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|UnicodeUtil
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|_TestUtil
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|fst
operator|.
name|FST
operator|.
name|Arc
import|;
end_import
begin_class
annotation|@
name|UseNoMemoryExpensiveCodec
DECL|class|TestFSTs
specifier|public
class|class
name|TestFSTs
extends|extends
name|LuceneTestCase
block|{
DECL|field|dir
specifier|private
name|MockDirectoryWrapper
name|dir
decl_stmt|;
annotation|@
name|Override
DECL|method|setUp
specifier|public
name|void
name|setUp
parameter_list|()
throws|throws
name|Exception
block|{
name|super
operator|.
name|setUp
argument_list|()
expr_stmt|;
name|dir
operator|=
name|newDirectory
argument_list|()
expr_stmt|;
name|dir
operator|.
name|setPreventDoubleWrite
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|tearDown
specifier|public
name|void
name|tearDown
parameter_list|()
throws|throws
name|Exception
block|{
comment|// can be null if we force simpletext (funky, some kind of bug in test runner maybe)
if|if
condition|(
name|dir
operator|!=
literal|null
condition|)
name|dir
operator|.
name|close
argument_list|()
expr_stmt|;
name|super
operator|.
name|tearDown
argument_list|()
expr_stmt|;
block|}
DECL|method|toBytesRef
specifier|private
specifier|static
name|BytesRef
name|toBytesRef
parameter_list|(
name|IntsRef
name|ir
parameter_list|)
block|{
name|BytesRef
name|br
init|=
operator|new
name|BytesRef
argument_list|(
name|ir
operator|.
name|length
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ir
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|int
name|x
init|=
name|ir
operator|.
name|ints
index|[
name|ir
operator|.
name|offset
operator|+
name|i
index|]
decl_stmt|;
assert|assert
name|x
operator|>=
literal|0
operator|&&
name|x
operator|<=
literal|255
assert|;
name|br
operator|.
name|bytes
index|[
name|i
index|]
operator|=
operator|(
name|byte
operator|)
name|x
expr_stmt|;
block|}
name|br
operator|.
name|length
operator|=
name|ir
operator|.
name|length
expr_stmt|;
return|return
name|br
return|;
block|}
DECL|method|toIntsRef
specifier|static
name|IntsRef
name|toIntsRef
parameter_list|(
name|String
name|s
parameter_list|,
name|int
name|inputMode
parameter_list|)
block|{
return|return
name|toIntsRef
argument_list|(
name|s
argument_list|,
name|inputMode
argument_list|,
operator|new
name|IntsRef
argument_list|(
literal|10
argument_list|)
argument_list|)
return|;
block|}
DECL|method|toIntsRef
specifier|static
name|IntsRef
name|toIntsRef
parameter_list|(
name|String
name|s
parameter_list|,
name|int
name|inputMode
parameter_list|,
name|IntsRef
name|ir
parameter_list|)
block|{
if|if
condition|(
name|inputMode
operator|==
literal|0
condition|)
block|{
comment|// utf8
return|return
name|toIntsRef
argument_list|(
operator|new
name|BytesRef
argument_list|(
name|s
argument_list|)
argument_list|,
name|ir
argument_list|)
return|;
block|}
else|else
block|{
comment|// utf32
return|return
name|toIntsRefUTF32
argument_list|(
name|s
argument_list|,
name|ir
argument_list|)
return|;
block|}
block|}
DECL|method|toIntsRefUTF32
specifier|static
name|IntsRef
name|toIntsRefUTF32
parameter_list|(
name|String
name|s
parameter_list|,
name|IntsRef
name|ir
parameter_list|)
block|{
specifier|final
name|int
name|charLength
init|=
name|s
operator|.
name|length
argument_list|()
decl_stmt|;
name|int
name|charIdx
init|=
literal|0
decl_stmt|;
name|int
name|intIdx
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|charIdx
operator|<
name|charLength
condition|)
block|{
if|if
condition|(
name|intIdx
operator|==
name|ir
operator|.
name|ints
operator|.
name|length
condition|)
block|{
name|ir
operator|.
name|grow
argument_list|(
name|intIdx
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
specifier|final
name|int
name|utf32
init|=
name|s
operator|.
name|codePointAt
argument_list|(
name|charIdx
argument_list|)
decl_stmt|;
name|ir
operator|.
name|ints
index|[
name|intIdx
index|]
operator|=
name|utf32
expr_stmt|;
name|charIdx
operator|+=
name|Character
operator|.
name|charCount
argument_list|(
name|utf32
argument_list|)
expr_stmt|;
name|intIdx
operator|++
expr_stmt|;
block|}
name|ir
operator|.
name|length
operator|=
name|intIdx
expr_stmt|;
return|return
name|ir
return|;
block|}
DECL|method|toIntsRef
specifier|static
name|IntsRef
name|toIntsRef
parameter_list|(
name|BytesRef
name|br
parameter_list|,
name|IntsRef
name|ir
parameter_list|)
block|{
if|if
condition|(
name|br
operator|.
name|length
operator|>
name|ir
operator|.
name|ints
operator|.
name|length
condition|)
block|{
name|ir
operator|.
name|grow
argument_list|(
name|br
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|br
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|ir
operator|.
name|ints
index|[
name|i
index|]
operator|=
name|br
operator|.
name|bytes
index|[
name|br
operator|.
name|offset
operator|+
name|i
index|]
operator|&
literal|0xFF
expr_stmt|;
block|}
name|ir
operator|.
name|length
operator|=
name|br
operator|.
name|length
expr_stmt|;
return|return
name|ir
return|;
block|}
DECL|method|testBasicFSA
specifier|public
name|void
name|testBasicFSA
parameter_list|()
throws|throws
name|IOException
block|{
name|String
index|[]
name|strings
init|=
operator|new
name|String
index|[]
block|{
literal|"station"
block|,
literal|"commotion"
block|,
literal|"elation"
block|,
literal|"elastic"
block|,
literal|"plastic"
block|,
literal|"stop"
block|,
literal|"ftop"
block|,
literal|"ftation"
block|,
literal|"stat"
block|}
decl_stmt|;
name|String
index|[]
name|strings2
init|=
operator|new
name|String
index|[]
block|{
literal|"station"
block|,
literal|"commotion"
block|,
literal|"elation"
block|,
literal|"elastic"
block|,
literal|"plastic"
block|,
literal|"stop"
block|,
literal|"ftop"
block|,
literal|"ftation"
block|}
decl_stmt|;
name|IntsRef
index|[]
name|terms
init|=
operator|new
name|IntsRef
index|[
name|strings
operator|.
name|length
index|]
decl_stmt|;
name|IntsRef
index|[]
name|terms2
init|=
operator|new
name|IntsRef
index|[
name|strings2
operator|.
name|length
index|]
decl_stmt|;
for|for
control|(
name|int
name|inputMode
init|=
literal|0
init|;
name|inputMode
operator|<
literal|2
condition|;
name|inputMode
operator|++
control|)
block|{
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"TEST: inputMode="
operator|+
name|inputModeToString
argument_list|(
name|inputMode
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|idx
init|=
literal|0
init|;
name|idx
operator|<
name|strings
operator|.
name|length
condition|;
name|idx
operator|++
control|)
block|{
name|terms
index|[
name|idx
index|]
operator|=
name|toIntsRef
argument_list|(
name|strings
index|[
name|idx
index|]
argument_list|,
name|inputMode
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|idx
init|=
literal|0
init|;
name|idx
operator|<
name|strings2
operator|.
name|length
condition|;
name|idx
operator|++
control|)
block|{
name|terms2
index|[
name|idx
index|]
operator|=
name|toIntsRef
argument_list|(
name|strings2
index|[
name|idx
index|]
argument_list|,
name|inputMode
argument_list|)
expr_stmt|;
block|}
name|Arrays
operator|.
name|sort
argument_list|(
name|terms2
argument_list|)
expr_stmt|;
name|doTest
argument_list|(
name|inputMode
argument_list|,
name|terms
argument_list|)
expr_stmt|;
comment|// Test pre-determined FST sizes to make sure we haven't lost minimality (at least on this trivial set of terms):
comment|// FSA
block|{
specifier|final
name|Outputs
argument_list|<
name|Object
argument_list|>
name|outputs
init|=
name|NoOutputs
operator|.
name|getSingleton
argument_list|()
decl_stmt|;
specifier|final
name|Object
name|NO_OUTPUT
init|=
name|outputs
operator|.
name|getNoOutput
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|FSTTester
operator|.
name|InputOutput
argument_list|<
name|Object
argument_list|>
argument_list|>
name|pairs
init|=
operator|new
name|ArrayList
argument_list|<
name|FSTTester
operator|.
name|InputOutput
argument_list|<
name|Object
argument_list|>
argument_list|>
argument_list|(
name|terms2
operator|.
name|length
argument_list|)
decl_stmt|;
for|for
control|(
name|IntsRef
name|term
range|:
name|terms2
control|)
block|{
name|pairs
operator|.
name|add
argument_list|(
operator|new
name|FSTTester
operator|.
name|InputOutput
argument_list|<
name|Object
argument_list|>
argument_list|(
name|term
argument_list|,
name|NO_OUTPUT
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|FST
argument_list|<
name|Object
argument_list|>
name|fst
init|=
operator|new
name|FSTTester
argument_list|<
name|Object
argument_list|>
argument_list|(
name|random
argument_list|,
name|dir
argument_list|,
name|inputMode
argument_list|,
name|pairs
argument_list|,
name|outputs
argument_list|,
literal|false
argument_list|)
operator|.
name|doTest
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|assertNotNull
argument_list|(
name|fst
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|22
argument_list|,
name|fst
operator|.
name|getNodeCount
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|27
argument_list|,
name|fst
operator|.
name|getArcCount
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// FST ord pos int
block|{
specifier|final
name|PositiveIntOutputs
name|outputs
init|=
name|PositiveIntOutputs
operator|.
name|getSingleton
argument_list|(
literal|true
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|FSTTester
operator|.
name|InputOutput
argument_list|<
name|Long
argument_list|>
argument_list|>
name|pairs
init|=
operator|new
name|ArrayList
argument_list|<
name|FSTTester
operator|.
name|InputOutput
argument_list|<
name|Long
argument_list|>
argument_list|>
argument_list|(
name|terms2
operator|.
name|length
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|idx
init|=
literal|0
init|;
name|idx
operator|<
name|terms2
operator|.
name|length
condition|;
name|idx
operator|++
control|)
block|{
name|pairs
operator|.
name|add
argument_list|(
operator|new
name|FSTTester
operator|.
name|InputOutput
argument_list|<
name|Long
argument_list|>
argument_list|(
name|terms2
index|[
name|idx
index|]
argument_list|,
operator|(
name|long
operator|)
name|idx
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|final
name|FST
argument_list|<
name|Long
argument_list|>
name|fst
init|=
operator|new
name|FSTTester
argument_list|<
name|Long
argument_list|>
argument_list|(
name|random
argument_list|,
name|dir
argument_list|,
name|inputMode
argument_list|,
name|pairs
argument_list|,
name|outputs
argument_list|,
literal|true
argument_list|)
operator|.
name|doTest
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|assertNotNull
argument_list|(
name|fst
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|22
argument_list|,
name|fst
operator|.
name|getNodeCount
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|27
argument_list|,
name|fst
operator|.
name|getArcCount
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// FST byte sequence ord
block|{
specifier|final
name|ByteSequenceOutputs
name|outputs
init|=
name|ByteSequenceOutputs
operator|.
name|getSingleton
argument_list|()
decl_stmt|;
specifier|final
name|BytesRef
name|NO_OUTPUT
init|=
name|outputs
operator|.
name|getNoOutput
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|FSTTester
operator|.
name|InputOutput
argument_list|<
name|BytesRef
argument_list|>
argument_list|>
name|pairs
init|=
operator|new
name|ArrayList
argument_list|<
name|FSTTester
operator|.
name|InputOutput
argument_list|<
name|BytesRef
argument_list|>
argument_list|>
argument_list|(
name|terms2
operator|.
name|length
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|idx
init|=
literal|0
init|;
name|idx
operator|<
name|terms2
operator|.
name|length
condition|;
name|idx
operator|++
control|)
block|{
specifier|final
name|BytesRef
name|output
init|=
name|random
operator|.
name|nextInt
argument_list|(
literal|30
argument_list|)
operator|==
literal|17
condition|?
name|NO_OUTPUT
else|:
operator|new
name|BytesRef
argument_list|(
name|Integer
operator|.
name|toString
argument_list|(
name|idx
argument_list|)
argument_list|)
decl_stmt|;
name|pairs
operator|.
name|add
argument_list|(
operator|new
name|FSTTester
operator|.
name|InputOutput
argument_list|<
name|BytesRef
argument_list|>
argument_list|(
name|terms2
index|[
name|idx
index|]
argument_list|,
name|output
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|final
name|FST
argument_list|<
name|BytesRef
argument_list|>
name|fst
init|=
operator|new
name|FSTTester
argument_list|<
name|BytesRef
argument_list|>
argument_list|(
name|random
argument_list|,
name|dir
argument_list|,
name|inputMode
argument_list|,
name|pairs
argument_list|,
name|outputs
argument_list|,
literal|false
argument_list|)
operator|.
name|doTest
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|assertNotNull
argument_list|(
name|fst
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|24
argument_list|,
name|fst
operator|.
name|getNodeCount
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|30
argument_list|,
name|fst
operator|.
name|getArcCount
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|simpleRandomString
specifier|private
specifier|static
name|String
name|simpleRandomString
parameter_list|(
name|Random
name|r
parameter_list|)
block|{
specifier|final
name|int
name|end
init|=
name|r
operator|.
name|nextInt
argument_list|(
literal|10
argument_list|)
decl_stmt|;
if|if
condition|(
name|end
operator|==
literal|0
condition|)
block|{
comment|// allow 0 length
return|return
literal|""
return|;
block|}
specifier|final
name|char
index|[]
name|buffer
init|=
operator|new
name|char
index|[
name|end
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|end
condition|;
name|i
operator|++
control|)
block|{
name|buffer
index|[
name|i
index|]
operator|=
operator|(
name|char
operator|)
name|_TestUtil
operator|.
name|nextInt
argument_list|(
name|r
argument_list|,
literal|97
argument_list|,
literal|102
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|String
argument_list|(
name|buffer
argument_list|,
literal|0
argument_list|,
name|end
argument_list|)
return|;
block|}
comment|// given set of terms, test the different outputs for them
DECL|method|doTest
specifier|private
name|void
name|doTest
parameter_list|(
name|int
name|inputMode
parameter_list|,
name|IntsRef
index|[]
name|terms
parameter_list|)
throws|throws
name|IOException
block|{
name|Arrays
operator|.
name|sort
argument_list|(
name|terms
argument_list|)
expr_stmt|;
comment|// NoOutputs (simple FSA)
block|{
specifier|final
name|Outputs
argument_list|<
name|Object
argument_list|>
name|outputs
init|=
name|NoOutputs
operator|.
name|getSingleton
argument_list|()
decl_stmt|;
specifier|final
name|Object
name|NO_OUTPUT
init|=
name|outputs
operator|.
name|getNoOutput
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|FSTTester
operator|.
name|InputOutput
argument_list|<
name|Object
argument_list|>
argument_list|>
name|pairs
init|=
operator|new
name|ArrayList
argument_list|<
name|FSTTester
operator|.
name|InputOutput
argument_list|<
name|Object
argument_list|>
argument_list|>
argument_list|(
name|terms
operator|.
name|length
argument_list|)
decl_stmt|;
for|for
control|(
name|IntsRef
name|term
range|:
name|terms
control|)
block|{
name|pairs
operator|.
name|add
argument_list|(
operator|new
name|FSTTester
operator|.
name|InputOutput
argument_list|<
name|Object
argument_list|>
argument_list|(
name|term
argument_list|,
name|NO_OUTPUT
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|new
name|FSTTester
argument_list|<
name|Object
argument_list|>
argument_list|(
name|random
argument_list|,
name|dir
argument_list|,
name|inputMode
argument_list|,
name|pairs
argument_list|,
name|outputs
argument_list|,
literal|false
argument_list|)
operator|.
name|doTest
argument_list|()
expr_stmt|;
block|}
comment|// PositiveIntOutput (ord)
block|{
specifier|final
name|PositiveIntOutputs
name|outputs
init|=
name|PositiveIntOutputs
operator|.
name|getSingleton
argument_list|(
literal|true
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|FSTTester
operator|.
name|InputOutput
argument_list|<
name|Long
argument_list|>
argument_list|>
name|pairs
init|=
operator|new
name|ArrayList
argument_list|<
name|FSTTester
operator|.
name|InputOutput
argument_list|<
name|Long
argument_list|>
argument_list|>
argument_list|(
name|terms
operator|.
name|length
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|idx
init|=
literal|0
init|;
name|idx
operator|<
name|terms
operator|.
name|length
condition|;
name|idx
operator|++
control|)
block|{
name|pairs
operator|.
name|add
argument_list|(
operator|new
name|FSTTester
operator|.
name|InputOutput
argument_list|<
name|Long
argument_list|>
argument_list|(
name|terms
index|[
name|idx
index|]
argument_list|,
operator|(
name|long
operator|)
name|idx
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|new
name|FSTTester
argument_list|<
name|Long
argument_list|>
argument_list|(
name|random
argument_list|,
name|dir
argument_list|,
name|inputMode
argument_list|,
name|pairs
argument_list|,
name|outputs
argument_list|,
literal|true
argument_list|)
operator|.
name|doTest
argument_list|()
expr_stmt|;
block|}
comment|// PositiveIntOutput (random monotonically increasing positive number)
block|{
specifier|final
name|boolean
name|doShare
init|=
name|random
operator|.
name|nextBoolean
argument_list|()
decl_stmt|;
specifier|final
name|PositiveIntOutputs
name|outputs
init|=
name|PositiveIntOutputs
operator|.
name|getSingleton
argument_list|(
name|doShare
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|FSTTester
operator|.
name|InputOutput
argument_list|<
name|Long
argument_list|>
argument_list|>
name|pairs
init|=
operator|new
name|ArrayList
argument_list|<
name|FSTTester
operator|.
name|InputOutput
argument_list|<
name|Long
argument_list|>
argument_list|>
argument_list|(
name|terms
operator|.
name|length
argument_list|)
decl_stmt|;
name|long
name|lastOutput
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|idx
init|=
literal|0
init|;
name|idx
operator|<
name|terms
operator|.
name|length
condition|;
name|idx
operator|++
control|)
block|{
specifier|final
name|long
name|value
init|=
name|lastOutput
operator|+
name|_TestUtil
operator|.
name|nextInt
argument_list|(
name|random
argument_list|,
literal|1
argument_list|,
literal|1000
argument_list|)
decl_stmt|;
name|lastOutput
operator|=
name|value
expr_stmt|;
name|pairs
operator|.
name|add
argument_list|(
operator|new
name|FSTTester
operator|.
name|InputOutput
argument_list|<
name|Long
argument_list|>
argument_list|(
name|terms
index|[
name|idx
index|]
argument_list|,
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|new
name|FSTTester
argument_list|<
name|Long
argument_list|>
argument_list|(
name|random
argument_list|,
name|dir
argument_list|,
name|inputMode
argument_list|,
name|pairs
argument_list|,
name|outputs
argument_list|,
name|doShare
argument_list|)
operator|.
name|doTest
argument_list|()
expr_stmt|;
block|}
comment|// PositiveIntOutput (random positive number)
block|{
specifier|final
name|PositiveIntOutputs
name|outputs
init|=
name|PositiveIntOutputs
operator|.
name|getSingleton
argument_list|(
name|random
operator|.
name|nextBoolean
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|FSTTester
operator|.
name|InputOutput
argument_list|<
name|Long
argument_list|>
argument_list|>
name|pairs
init|=
operator|new
name|ArrayList
argument_list|<
name|FSTTester
operator|.
name|InputOutput
argument_list|<
name|Long
argument_list|>
argument_list|>
argument_list|(
name|terms
operator|.
name|length
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|idx
init|=
literal|0
init|;
name|idx
operator|<
name|terms
operator|.
name|length
condition|;
name|idx
operator|++
control|)
block|{
name|pairs
operator|.
name|add
argument_list|(
operator|new
name|FSTTester
operator|.
name|InputOutput
argument_list|<
name|Long
argument_list|>
argument_list|(
name|terms
index|[
name|idx
index|]
argument_list|,
name|random
operator|.
name|nextLong
argument_list|()
operator|&
name|Long
operator|.
name|MAX_VALUE
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|new
name|FSTTester
argument_list|<
name|Long
argument_list|>
argument_list|(
name|random
argument_list|,
name|dir
argument_list|,
name|inputMode
argument_list|,
name|pairs
argument_list|,
name|outputs
argument_list|,
literal|false
argument_list|)
operator|.
name|doTest
argument_list|()
expr_stmt|;
block|}
comment|// Pair<ord, (random monotonically increasing positive number>
block|{
specifier|final
name|PositiveIntOutputs
name|o1
init|=
name|PositiveIntOutputs
operator|.
name|getSingleton
argument_list|(
name|random
operator|.
name|nextBoolean
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|PositiveIntOutputs
name|o2
init|=
name|PositiveIntOutputs
operator|.
name|getSingleton
argument_list|(
name|random
operator|.
name|nextBoolean
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|PairOutputs
argument_list|<
name|Long
argument_list|,
name|Long
argument_list|>
name|outputs
init|=
operator|new
name|PairOutputs
argument_list|<
name|Long
argument_list|,
name|Long
argument_list|>
argument_list|(
name|o1
argument_list|,
name|o2
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|FSTTester
operator|.
name|InputOutput
argument_list|<
name|PairOutputs
operator|.
name|Pair
argument_list|<
name|Long
argument_list|,
name|Long
argument_list|>
argument_list|>
argument_list|>
name|pairs
init|=
operator|new
name|ArrayList
argument_list|<
name|FSTTester
operator|.
name|InputOutput
argument_list|<
name|PairOutputs
operator|.
name|Pair
argument_list|<
name|Long
argument_list|,
name|Long
argument_list|>
argument_list|>
argument_list|>
argument_list|(
name|terms
operator|.
name|length
argument_list|)
decl_stmt|;
name|long
name|lastOutput
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|idx
init|=
literal|0
init|;
name|idx
operator|<
name|terms
operator|.
name|length
condition|;
name|idx
operator|++
control|)
block|{
specifier|final
name|long
name|value
init|=
name|lastOutput
operator|+
name|_TestUtil
operator|.
name|nextInt
argument_list|(
name|random
argument_list|,
literal|1
argument_list|,
literal|1000
argument_list|)
decl_stmt|;
name|lastOutput
operator|=
name|value
expr_stmt|;
name|pairs
operator|.
name|add
argument_list|(
operator|new
name|FSTTester
operator|.
name|InputOutput
argument_list|<
name|PairOutputs
operator|.
name|Pair
argument_list|<
name|Long
argument_list|,
name|Long
argument_list|>
argument_list|>
argument_list|(
name|terms
index|[
name|idx
index|]
argument_list|,
name|outputs
operator|.
name|newPair
argument_list|(
operator|(
name|long
operator|)
name|idx
argument_list|,
name|value
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|new
name|FSTTester
argument_list|<
name|PairOutputs
operator|.
name|Pair
argument_list|<
name|Long
argument_list|,
name|Long
argument_list|>
argument_list|>
argument_list|(
name|random
argument_list|,
name|dir
argument_list|,
name|inputMode
argument_list|,
name|pairs
argument_list|,
name|outputs
argument_list|,
literal|false
argument_list|)
operator|.
name|doTest
argument_list|()
expr_stmt|;
block|}
comment|// Sequence-of-bytes
block|{
specifier|final
name|ByteSequenceOutputs
name|outputs
init|=
name|ByteSequenceOutputs
operator|.
name|getSingleton
argument_list|()
decl_stmt|;
specifier|final
name|BytesRef
name|NO_OUTPUT
init|=
name|outputs
operator|.
name|getNoOutput
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|FSTTester
operator|.
name|InputOutput
argument_list|<
name|BytesRef
argument_list|>
argument_list|>
name|pairs
init|=
operator|new
name|ArrayList
argument_list|<
name|FSTTester
operator|.
name|InputOutput
argument_list|<
name|BytesRef
argument_list|>
argument_list|>
argument_list|(
name|terms
operator|.
name|length
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|idx
init|=
literal|0
init|;
name|idx
operator|<
name|terms
operator|.
name|length
condition|;
name|idx
operator|++
control|)
block|{
specifier|final
name|BytesRef
name|output
init|=
name|random
operator|.
name|nextInt
argument_list|(
literal|30
argument_list|)
operator|==
literal|17
condition|?
name|NO_OUTPUT
else|:
operator|new
name|BytesRef
argument_list|(
name|Integer
operator|.
name|toString
argument_list|(
name|idx
argument_list|)
argument_list|)
decl_stmt|;
name|pairs
operator|.
name|add
argument_list|(
operator|new
name|FSTTester
operator|.
name|InputOutput
argument_list|<
name|BytesRef
argument_list|>
argument_list|(
name|terms
index|[
name|idx
index|]
argument_list|,
name|output
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|new
name|FSTTester
argument_list|<
name|BytesRef
argument_list|>
argument_list|(
name|random
argument_list|,
name|dir
argument_list|,
name|inputMode
argument_list|,
name|pairs
argument_list|,
name|outputs
argument_list|,
literal|false
argument_list|)
operator|.
name|doTest
argument_list|()
expr_stmt|;
block|}
comment|// Sequence-of-ints
block|{
specifier|final
name|IntSequenceOutputs
name|outputs
init|=
name|IntSequenceOutputs
operator|.
name|getSingleton
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|FSTTester
operator|.
name|InputOutput
argument_list|<
name|IntsRef
argument_list|>
argument_list|>
name|pairs
init|=
operator|new
name|ArrayList
argument_list|<
name|FSTTester
operator|.
name|InputOutput
argument_list|<
name|IntsRef
argument_list|>
argument_list|>
argument_list|(
name|terms
operator|.
name|length
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|idx
init|=
literal|0
init|;
name|idx
operator|<
name|terms
operator|.
name|length
condition|;
name|idx
operator|++
control|)
block|{
specifier|final
name|String
name|s
init|=
name|Integer
operator|.
name|toString
argument_list|(
name|idx
argument_list|)
decl_stmt|;
specifier|final
name|IntsRef
name|output
init|=
operator|new
name|IntsRef
argument_list|(
name|s
operator|.
name|length
argument_list|()
argument_list|)
decl_stmt|;
name|output
operator|.
name|length
operator|=
name|s
operator|.
name|length
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|idx2
init|=
literal|0
init|;
name|idx2
operator|<
name|output
operator|.
name|length
condition|;
name|idx2
operator|++
control|)
block|{
name|output
operator|.
name|ints
index|[
name|idx2
index|]
operator|=
name|s
operator|.
name|charAt
argument_list|(
name|idx2
argument_list|)
expr_stmt|;
block|}
name|pairs
operator|.
name|add
argument_list|(
operator|new
name|FSTTester
operator|.
name|InputOutput
argument_list|<
name|IntsRef
argument_list|>
argument_list|(
name|terms
index|[
name|idx
index|]
argument_list|,
name|output
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|new
name|FSTTester
argument_list|<
name|IntsRef
argument_list|>
argument_list|(
name|random
argument_list|,
name|dir
argument_list|,
name|inputMode
argument_list|,
name|pairs
argument_list|,
name|outputs
argument_list|,
literal|false
argument_list|)
operator|.
name|doTest
argument_list|()
expr_stmt|;
block|}
comment|// Up to two positive ints, shared, generally but not
comment|// monotonically increasing
block|{
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"TEST: now test UpToTwoPositiveIntOutputs"
argument_list|)
expr_stmt|;
block|}
specifier|final
name|UpToTwoPositiveIntOutputs
name|outputs
init|=
name|UpToTwoPositiveIntOutputs
operator|.
name|getSingleton
argument_list|(
literal|true
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|FSTTester
operator|.
name|InputOutput
argument_list|<
name|Object
argument_list|>
argument_list|>
name|pairs
init|=
operator|new
name|ArrayList
argument_list|<
name|FSTTester
operator|.
name|InputOutput
argument_list|<
name|Object
argument_list|>
argument_list|>
argument_list|(
name|terms
operator|.
name|length
argument_list|)
decl_stmt|;
name|long
name|lastOutput
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|idx
init|=
literal|0
init|;
name|idx
operator|<
name|terms
operator|.
name|length
condition|;
name|idx
operator|++
control|)
block|{
comment|// Sometimes go backwards
name|long
name|value
init|=
name|lastOutput
operator|+
name|_TestUtil
operator|.
name|nextInt
argument_list|(
name|random
argument_list|,
operator|-
literal|100
argument_list|,
literal|1000
argument_list|)
decl_stmt|;
while|while
condition|(
name|value
operator|<
literal|0
condition|)
block|{
name|value
operator|=
name|lastOutput
operator|+
name|_TestUtil
operator|.
name|nextInt
argument_list|(
name|random
argument_list|,
operator|-
literal|100
argument_list|,
literal|1000
argument_list|)
expr_stmt|;
block|}
specifier|final
name|Object
name|output
decl_stmt|;
if|if
condition|(
name|random
operator|.
name|nextInt
argument_list|(
literal|5
argument_list|)
operator|==
literal|3
condition|)
block|{
name|long
name|value2
init|=
name|lastOutput
operator|+
name|_TestUtil
operator|.
name|nextInt
argument_list|(
name|random
argument_list|,
operator|-
literal|100
argument_list|,
literal|1000
argument_list|)
decl_stmt|;
while|while
condition|(
name|value2
operator|<
literal|0
condition|)
block|{
name|value2
operator|=
name|lastOutput
operator|+
name|_TestUtil
operator|.
name|nextInt
argument_list|(
name|random
argument_list|,
operator|-
literal|100
argument_list|,
literal|1000
argument_list|)
expr_stmt|;
block|}
name|output
operator|=
name|outputs
operator|.
name|get
argument_list|(
name|value
argument_list|,
name|value2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|output
operator|=
name|outputs
operator|.
name|get
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
name|pairs
operator|.
name|add
argument_list|(
operator|new
name|FSTTester
operator|.
name|InputOutput
argument_list|<
name|Object
argument_list|>
argument_list|(
name|terms
index|[
name|idx
index|]
argument_list|,
name|output
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|new
name|FSTTester
argument_list|<
name|Object
argument_list|>
argument_list|(
name|random
argument_list|,
name|dir
argument_list|,
name|inputMode
argument_list|,
name|pairs
argument_list|,
name|outputs
argument_list|,
literal|false
argument_list|)
operator|.
name|doTest
argument_list|()
expr_stmt|;
block|}
block|}
DECL|class|FSTTester
specifier|private
specifier|static
class|class
name|FSTTester
parameter_list|<
name|T
parameter_list|>
block|{
DECL|field|random
specifier|final
name|Random
name|random
decl_stmt|;
DECL|field|pairs
specifier|final
name|List
argument_list|<
name|InputOutput
argument_list|<
name|T
argument_list|>
argument_list|>
name|pairs
decl_stmt|;
DECL|field|inputMode
specifier|final
name|int
name|inputMode
decl_stmt|;
DECL|field|outputs
specifier|final
name|Outputs
argument_list|<
name|T
argument_list|>
name|outputs
decl_stmt|;
DECL|field|dir
specifier|final
name|Directory
name|dir
decl_stmt|;
DECL|field|doReverseLookup
specifier|final
name|boolean
name|doReverseLookup
decl_stmt|;
DECL|method|FSTTester
specifier|public
name|FSTTester
parameter_list|(
name|Random
name|random
parameter_list|,
name|Directory
name|dir
parameter_list|,
name|int
name|inputMode
parameter_list|,
name|List
argument_list|<
name|InputOutput
argument_list|<
name|T
argument_list|>
argument_list|>
name|pairs
parameter_list|,
name|Outputs
argument_list|<
name|T
argument_list|>
name|outputs
parameter_list|,
name|boolean
name|doReverseLookup
parameter_list|)
block|{
name|this
operator|.
name|random
operator|=
name|random
expr_stmt|;
name|this
operator|.
name|dir
operator|=
name|dir
expr_stmt|;
name|this
operator|.
name|inputMode
operator|=
name|inputMode
expr_stmt|;
name|this
operator|.
name|pairs
operator|=
name|pairs
expr_stmt|;
name|this
operator|.
name|outputs
operator|=
name|outputs
expr_stmt|;
name|this
operator|.
name|doReverseLookup
operator|=
name|doReverseLookup
expr_stmt|;
block|}
DECL|class|InputOutput
specifier|private
specifier|static
class|class
name|InputOutput
parameter_list|<
name|T
parameter_list|>
implements|implements
name|Comparable
argument_list|<
name|InputOutput
argument_list|<
name|T
argument_list|>
argument_list|>
block|{
DECL|field|input
specifier|public
specifier|final
name|IntsRef
name|input
decl_stmt|;
DECL|field|output
specifier|public
specifier|final
name|T
name|output
decl_stmt|;
DECL|method|InputOutput
specifier|public
name|InputOutput
parameter_list|(
name|IntsRef
name|input
parameter_list|,
name|T
name|output
parameter_list|)
block|{
name|this
operator|.
name|input
operator|=
name|input
expr_stmt|;
name|this
operator|.
name|output
operator|=
name|output
expr_stmt|;
block|}
DECL|method|compareTo
specifier|public
name|int
name|compareTo
parameter_list|(
name|InputOutput
argument_list|<
name|T
argument_list|>
name|other
parameter_list|)
block|{
if|if
condition|(
name|other
operator|instanceof
name|InputOutput
condition|)
block|{
return|return
name|input
operator|.
name|compareTo
argument_list|(
operator|(
name|other
operator|)
operator|.
name|input
argument_list|)
return|;
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|()
throw|;
block|}
block|}
block|}
DECL|method|doTest
specifier|public
name|void
name|doTest
parameter_list|()
throws|throws
name|IOException
block|{
comment|// no pruning
name|doTest
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|outputs
operator|instanceof
name|UpToTwoPositiveIntOutputs
operator|)
condition|)
block|{
comment|// simple pruning
name|doTest
argument_list|(
name|_TestUtil
operator|.
name|nextInt
argument_list|(
name|random
argument_list|,
literal|1
argument_list|,
literal|1
operator|+
name|pairs
operator|.
name|size
argument_list|()
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|true
argument_list|)
expr_stmt|;
comment|// leafy pruning
name|doTest
argument_list|(
literal|0
argument_list|,
name|_TestUtil
operator|.
name|nextInt
argument_list|(
name|random
argument_list|,
literal|1
argument_list|,
literal|1
operator|+
name|pairs
operator|.
name|size
argument_list|()
argument_list|)
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
comment|// runs the term, returning the output, or null if term
comment|// isn't accepted.  if prefixLength is non-null it must be
comment|// length 1 int array; prefixLength[0] is set to the length
comment|// of the term prefix that matches
DECL|method|run
specifier|private
name|T
name|run
parameter_list|(
name|FST
argument_list|<
name|T
argument_list|>
name|fst
parameter_list|,
name|IntsRef
name|term
parameter_list|,
name|int
index|[]
name|prefixLength
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|prefixLength
operator|==
literal|null
operator|||
name|prefixLength
operator|.
name|length
operator|==
literal|1
assert|;
specifier|final
name|FST
operator|.
name|Arc
argument_list|<
name|T
argument_list|>
name|arc
init|=
name|fst
operator|.
name|getFirstArc
argument_list|(
operator|new
name|FST
operator|.
name|Arc
argument_list|<
name|T
argument_list|>
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|T
name|NO_OUTPUT
init|=
name|fst
operator|.
name|outputs
operator|.
name|getNoOutput
argument_list|()
decl_stmt|;
name|T
name|output
init|=
name|NO_OUTPUT
decl_stmt|;
specifier|final
name|FST
operator|.
name|BytesReader
name|fstReader
init|=
name|fst
operator|.
name|getBytesReader
argument_list|(
literal|0
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<=
name|term
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|int
name|label
decl_stmt|;
if|if
condition|(
name|i
operator|==
name|term
operator|.
name|length
condition|)
block|{
name|label
operator|=
name|FST
operator|.
name|END_LABEL
expr_stmt|;
block|}
else|else
block|{
name|label
operator|=
name|term
operator|.
name|ints
index|[
name|term
operator|.
name|offset
operator|+
name|i
index|]
expr_stmt|;
block|}
comment|// System.out.println("   loop i=" + i + " label=" + label + " output=" + fst.outputs.outputToString(output) + " curArc: target=" + arc.target + " isFinal?=" + arc.isFinal());
if|if
condition|(
name|fst
operator|.
name|findTargetArc
argument_list|(
name|label
argument_list|,
name|arc
argument_list|,
name|arc
argument_list|,
name|fstReader
argument_list|)
operator|==
literal|null
condition|)
block|{
comment|// System.out.println("    not found");
if|if
condition|(
name|prefixLength
operator|!=
literal|null
condition|)
block|{
name|prefixLength
index|[
literal|0
index|]
operator|=
name|i
expr_stmt|;
return|return
name|output
return|;
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
name|output
operator|=
name|fst
operator|.
name|outputs
operator|.
name|add
argument_list|(
name|output
argument_list|,
name|arc
operator|.
name|output
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|prefixLength
operator|!=
literal|null
condition|)
block|{
name|prefixLength
index|[
literal|0
index|]
operator|=
name|term
operator|.
name|length
expr_stmt|;
block|}
return|return
name|output
return|;
block|}
DECL|method|randomAcceptedWord
specifier|private
name|T
name|randomAcceptedWord
parameter_list|(
name|FST
argument_list|<
name|T
argument_list|>
name|fst
parameter_list|,
name|IntsRef
name|in
parameter_list|)
throws|throws
name|IOException
block|{
name|FST
operator|.
name|Arc
argument_list|<
name|T
argument_list|>
name|arc
init|=
name|fst
operator|.
name|getFirstArc
argument_list|(
operator|new
name|FST
operator|.
name|Arc
argument_list|<
name|T
argument_list|>
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|FST
operator|.
name|Arc
argument_list|<
name|T
argument_list|>
argument_list|>
name|arcs
init|=
operator|new
name|ArrayList
argument_list|<
name|FST
operator|.
name|Arc
argument_list|<
name|T
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
name|in
operator|.
name|length
operator|=
literal|0
expr_stmt|;
name|in
operator|.
name|offset
operator|=
literal|0
expr_stmt|;
specifier|final
name|T
name|NO_OUTPUT
init|=
name|fst
operator|.
name|outputs
operator|.
name|getNoOutput
argument_list|()
decl_stmt|;
name|T
name|output
init|=
name|NO_OUTPUT
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
comment|// read all arcs:
name|fst
operator|.
name|readFirstTargetArc
argument_list|(
name|arc
argument_list|,
name|arc
argument_list|)
expr_stmt|;
name|arcs
operator|.
name|add
argument_list|(
operator|new
name|FST
operator|.
name|Arc
argument_list|<
name|T
argument_list|>
argument_list|()
operator|.
name|copyFrom
argument_list|(
name|arc
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|arc
operator|.
name|isLast
argument_list|()
condition|)
block|{
name|fst
operator|.
name|readNextArc
argument_list|(
name|arc
argument_list|)
expr_stmt|;
name|arcs
operator|.
name|add
argument_list|(
operator|new
name|FST
operator|.
name|Arc
argument_list|<
name|T
argument_list|>
argument_list|()
operator|.
name|copyFrom
argument_list|(
name|arc
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// pick one
name|arc
operator|=
name|arcs
operator|.
name|get
argument_list|(
name|random
operator|.
name|nextInt
argument_list|(
name|arcs
operator|.
name|size
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|arcs
operator|.
name|clear
argument_list|()
expr_stmt|;
comment|// accumulate output
name|output
operator|=
name|fst
operator|.
name|outputs
operator|.
name|add
argument_list|(
name|output
argument_list|,
name|arc
operator|.
name|output
argument_list|)
expr_stmt|;
comment|// append label
if|if
condition|(
name|arc
operator|.
name|label
operator|==
name|FST
operator|.
name|END_LABEL
condition|)
block|{
break|break;
block|}
if|if
condition|(
name|in
operator|.
name|ints
operator|.
name|length
operator|==
name|in
operator|.
name|length
condition|)
block|{
name|in
operator|.
name|grow
argument_list|(
literal|1
operator|+
name|in
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
name|in
operator|.
name|ints
index|[
name|in
operator|.
name|length
operator|++
index|]
operator|=
name|arc
operator|.
name|label
expr_stmt|;
block|}
return|return
name|output
return|;
block|}
DECL|method|doTest
name|FST
argument_list|<
name|T
argument_list|>
name|doTest
parameter_list|(
name|int
name|prune1
parameter_list|,
name|int
name|prune2
parameter_list|,
name|boolean
name|allowRandomSuffixSharing
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"\nTEST: prune1="
operator|+
name|prune1
operator|+
literal|" prune2="
operator|+
name|prune2
argument_list|)
expr_stmt|;
block|}
specifier|final
name|boolean
name|willRewrite
init|=
name|random
operator|.
name|nextBoolean
argument_list|()
decl_stmt|;
specifier|final
name|Builder
argument_list|<
name|T
argument_list|>
name|builder
init|=
operator|new
name|Builder
argument_list|<
name|T
argument_list|>
argument_list|(
name|inputMode
operator|==
literal|0
condition|?
name|FST
operator|.
name|INPUT_TYPE
operator|.
name|BYTE1
else|:
name|FST
operator|.
name|INPUT_TYPE
operator|.
name|BYTE4
argument_list|,
name|prune1
argument_list|,
name|prune2
argument_list|,
name|prune1
operator|==
literal|0
operator|&&
name|prune2
operator|==
literal|0
argument_list|,
name|allowRandomSuffixSharing
condition|?
name|random
operator|.
name|nextBoolean
argument_list|()
else|:
literal|true
argument_list|,
name|allowRandomSuffixSharing
condition|?
name|_TestUtil
operator|.
name|nextInt
argument_list|(
name|random
argument_list|,
literal|1
argument_list|,
literal|10
argument_list|)
else|:
name|Integer
operator|.
name|MAX_VALUE
argument_list|,
name|outputs
argument_list|,
literal|null
argument_list|,
name|willRewrite
argument_list|)
decl_stmt|;
for|for
control|(
name|InputOutput
argument_list|<
name|T
argument_list|>
name|pair
range|:
name|pairs
control|)
block|{
if|if
condition|(
name|pair
operator|.
name|output
operator|instanceof
name|UpToTwoPositiveIntOutputs
operator|.
name|TwoLongs
condition|)
block|{
specifier|final
name|UpToTwoPositiveIntOutputs
name|_outputs
init|=
operator|(
name|UpToTwoPositiveIntOutputs
operator|)
name|outputs
decl_stmt|;
specifier|final
name|UpToTwoPositiveIntOutputs
operator|.
name|TwoLongs
name|twoLongs
init|=
operator|(
name|UpToTwoPositiveIntOutputs
operator|.
name|TwoLongs
operator|)
name|pair
operator|.
name|output
decl_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|final
name|Builder
argument_list|<
name|Object
argument_list|>
name|builderObject
init|=
operator|(
name|Builder
argument_list|<
name|Object
argument_list|>
operator|)
name|builder
decl_stmt|;
name|builderObject
operator|.
name|add
argument_list|(
name|pair
operator|.
name|input
argument_list|,
name|_outputs
operator|.
name|get
argument_list|(
name|twoLongs
operator|.
name|first
argument_list|)
argument_list|)
expr_stmt|;
name|builderObject
operator|.
name|add
argument_list|(
name|pair
operator|.
name|input
argument_list|,
name|_outputs
operator|.
name|get
argument_list|(
name|twoLongs
operator|.
name|second
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|builder
operator|.
name|add
argument_list|(
name|pair
operator|.
name|input
argument_list|,
name|pair
operator|.
name|output
argument_list|)
expr_stmt|;
block|}
block|}
name|FST
argument_list|<
name|T
argument_list|>
name|fst
init|=
name|builder
operator|.
name|finish
argument_list|()
decl_stmt|;
if|if
condition|(
name|random
operator|.
name|nextBoolean
argument_list|()
operator|&&
name|fst
operator|!=
literal|null
operator|&&
operator|!
name|willRewrite
condition|)
block|{
name|TestFSTs
name|t
init|=
operator|new
name|TestFSTs
argument_list|()
decl_stmt|;
name|IOContext
name|context
init|=
name|t
operator|.
name|newIOContext
argument_list|(
name|random
argument_list|)
decl_stmt|;
name|IndexOutput
name|out
init|=
name|dir
operator|.
name|createOutput
argument_list|(
literal|"fst.bin"
argument_list|,
name|context
argument_list|)
decl_stmt|;
name|fst
operator|.
name|save
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|out
operator|.
name|close
argument_list|()
expr_stmt|;
name|IndexInput
name|in
init|=
name|dir
operator|.
name|openInput
argument_list|(
literal|"fst.bin"
argument_list|,
name|context
argument_list|)
decl_stmt|;
try|try
block|{
name|fst
operator|=
operator|new
name|FST
argument_list|<
name|T
argument_list|>
argument_list|(
name|in
argument_list|,
name|outputs
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|in
operator|.
name|close
argument_list|()
expr_stmt|;
name|dir
operator|.
name|deleteFile
argument_list|(
literal|"fst.bin"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|VERBOSE
operator|&&
name|pairs
operator|.
name|size
argument_list|()
operator|<=
literal|20
operator|&&
name|fst
operator|!=
literal|null
condition|)
block|{
name|Writer
name|w
init|=
operator|new
name|OutputStreamWriter
argument_list|(
operator|new
name|FileOutputStream
argument_list|(
literal|"out.dot"
argument_list|)
argument_list|,
literal|"UTF-8"
argument_list|)
decl_stmt|;
name|Util
operator|.
name|toDot
argument_list|(
name|fst
argument_list|,
name|w
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|w
operator|.
name|close
argument_list|()
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"SAVED out.dot"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|VERBOSE
condition|)
block|{
if|if
condition|(
name|fst
operator|==
literal|null
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"  fst has 0 nodes (fully pruned)"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"  fst has "
operator|+
name|fst
operator|.
name|getNodeCount
argument_list|()
operator|+
literal|" nodes and "
operator|+
name|fst
operator|.
name|getArcCount
argument_list|()
operator|+
literal|" arcs"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|prune1
operator|==
literal|0
operator|&&
name|prune2
operator|==
literal|0
condition|)
block|{
name|verifyUnPruned
argument_list|(
name|inputMode
argument_list|,
name|fst
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|verifyPruned
argument_list|(
name|inputMode
argument_list|,
name|fst
argument_list|,
name|prune1
argument_list|,
name|prune2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|willRewrite
operator|&&
name|fst
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"TEST: now rewrite"
argument_list|)
expr_stmt|;
block|}
specifier|final
name|FST
argument_list|<
name|T
argument_list|>
name|packed
init|=
name|fst
operator|.
name|pack
argument_list|(
name|_TestUtil
operator|.
name|nextInt
argument_list|(
name|random
argument_list|,
literal|1
argument_list|,
literal|10
argument_list|)
argument_list|,
name|_TestUtil
operator|.
name|nextInt
argument_list|(
name|random
argument_list|,
literal|0
argument_list|,
literal|10000000
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"TEST: now verify packed FST"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|prune1
operator|==
literal|0
operator|&&
name|prune2
operator|==
literal|0
condition|)
block|{
name|verifyUnPruned
argument_list|(
name|inputMode
argument_list|,
name|packed
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|verifyPruned
argument_list|(
name|inputMode
argument_list|,
name|packed
argument_list|,
name|prune1
argument_list|,
name|prune2
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|fst
return|;
block|}
comment|// FST is complete
DECL|method|verifyUnPruned
specifier|private
name|void
name|verifyUnPruned
parameter_list|(
name|int
name|inputMode
parameter_list|,
name|FST
argument_list|<
name|T
argument_list|>
name|fst
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|FST
argument_list|<
name|Long
argument_list|>
name|fstLong
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|Long
argument_list|>
name|validOutputs
decl_stmt|;
name|long
name|minLong
init|=
name|Long
operator|.
name|MAX_VALUE
decl_stmt|;
name|long
name|maxLong
init|=
name|Long
operator|.
name|MIN_VALUE
decl_stmt|;
if|if
condition|(
name|doReverseLookup
condition|)
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|FST
argument_list|<
name|Long
argument_list|>
name|fstLong0
init|=
operator|(
name|FST
argument_list|<
name|Long
argument_list|>
operator|)
name|fst
decl_stmt|;
name|fstLong
operator|=
name|fstLong0
expr_stmt|;
name|validOutputs
operator|=
operator|new
name|HashSet
argument_list|<
name|Long
argument_list|>
argument_list|()
expr_stmt|;
for|for
control|(
name|InputOutput
argument_list|<
name|T
argument_list|>
name|pair
range|:
name|pairs
control|)
block|{
name|Long
name|output
init|=
operator|(
name|Long
operator|)
name|pair
operator|.
name|output
decl_stmt|;
name|maxLong
operator|=
name|Math
operator|.
name|max
argument_list|(
name|maxLong
argument_list|,
name|output
argument_list|)
expr_stmt|;
name|minLong
operator|=
name|Math
operator|.
name|min
argument_list|(
name|minLong
argument_list|,
name|output
argument_list|)
expr_stmt|;
name|validOutputs
operator|.
name|add
argument_list|(
name|output
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|fstLong
operator|=
literal|null
expr_stmt|;
name|validOutputs
operator|=
literal|null
expr_stmt|;
block|}
if|if
condition|(
name|pairs
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
name|assertNull
argument_list|(
name|fst
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"TEST: now verify "
operator|+
name|pairs
operator|.
name|size
argument_list|()
operator|+
literal|" terms"
argument_list|)
expr_stmt|;
for|for
control|(
name|InputOutput
argument_list|<
name|T
argument_list|>
name|pair
range|:
name|pairs
control|)
block|{
name|assertNotNull
argument_list|(
name|pair
argument_list|)
expr_stmt|;
name|assertNotNull
argument_list|(
name|pair
operator|.
name|input
argument_list|)
expr_stmt|;
name|assertNotNull
argument_list|(
name|pair
operator|.
name|output
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"  "
operator|+
name|inputToString
argument_list|(
name|inputMode
argument_list|,
name|pair
operator|.
name|input
argument_list|)
operator|+
literal|": "
operator|+
name|outputs
operator|.
name|outputToString
argument_list|(
name|pair
operator|.
name|output
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|assertNotNull
argument_list|(
name|fst
argument_list|)
expr_stmt|;
comment|// visit valid pairs in order -- make sure all words
comment|// are accepted, and FSTEnum's next() steps through
comment|// them correctly
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"TEST: check valid terms/next()"
argument_list|)
expr_stmt|;
block|}
block|{
name|IntsRefFSTEnum
argument_list|<
name|T
argument_list|>
name|fstEnum
init|=
operator|new
name|IntsRefFSTEnum
argument_list|<
name|T
argument_list|>
argument_list|(
name|fst
argument_list|)
decl_stmt|;
for|for
control|(
name|InputOutput
argument_list|<
name|T
argument_list|>
name|pair
range|:
name|pairs
control|)
block|{
name|IntsRef
name|term
init|=
name|pair
operator|.
name|input
decl_stmt|;
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"TEST: check term="
operator|+
name|inputToString
argument_list|(
name|inputMode
argument_list|,
name|term
argument_list|)
operator|+
literal|" output="
operator|+
name|fst
operator|.
name|outputs
operator|.
name|outputToString
argument_list|(
name|pair
operator|.
name|output
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|Object
name|output
init|=
name|run
argument_list|(
name|fst
argument_list|,
name|term
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|assertNotNull
argument_list|(
literal|"term "
operator|+
name|inputToString
argument_list|(
name|inputMode
argument_list|,
name|term
argument_list|)
operator|+
literal|" is not accepted"
argument_list|,
name|output
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|pair
operator|.
name|output
argument_list|,
name|output
argument_list|)
expr_stmt|;
comment|// verify enum's next
name|IntsRefFSTEnum
operator|.
name|InputOutput
argument_list|<
name|T
argument_list|>
name|t
init|=
name|fstEnum
operator|.
name|next
argument_list|()
decl_stmt|;
name|assertNotNull
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"expected input="
operator|+
name|inputToString
argument_list|(
name|inputMode
argument_list|,
name|term
argument_list|)
operator|+
literal|" but fstEnum returned "
operator|+
name|inputToString
argument_list|(
name|inputMode
argument_list|,
name|t
operator|.
name|input
argument_list|)
argument_list|,
name|term
argument_list|,
name|t
operator|.
name|input
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|pair
operator|.
name|output
argument_list|,
name|t
operator|.
name|output
argument_list|)
expr_stmt|;
block|}
name|assertNull
argument_list|(
name|fstEnum
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
block|}
specifier|final
name|Map
argument_list|<
name|IntsRef
argument_list|,
name|T
argument_list|>
name|termsMap
init|=
operator|new
name|HashMap
argument_list|<
name|IntsRef
argument_list|,
name|T
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|InputOutput
argument_list|<
name|T
argument_list|>
name|pair
range|:
name|pairs
control|)
block|{
name|termsMap
operator|.
name|put
argument_list|(
name|pair
operator|.
name|input
argument_list|,
name|pair
operator|.
name|output
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|doReverseLookup
operator|&&
name|maxLong
operator|>
name|minLong
condition|)
block|{
comment|// Do random lookups so we test null (output doesn't
comment|// exist) case:
name|assertNull
argument_list|(
name|Util
operator|.
name|getByOutput
argument_list|(
name|fstLong
argument_list|,
name|minLong
operator|-
literal|7
argument_list|)
argument_list|)
expr_stmt|;
name|assertNull
argument_list|(
name|Util
operator|.
name|getByOutput
argument_list|(
name|fstLong
argument_list|,
name|maxLong
operator|+
literal|7
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|int
name|num
init|=
name|atLeast
argument_list|(
literal|100
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|iter
init|=
literal|0
init|;
name|iter
operator|<
name|num
condition|;
name|iter
operator|++
control|)
block|{
name|Long
name|v
init|=
name|minLong
operator|+
name|random
operator|.
name|nextLong
argument_list|()
operator|%
operator|(
name|maxLong
operator|-
name|minLong
operator|)
decl_stmt|;
name|IntsRef
name|input
init|=
name|Util
operator|.
name|getByOutput
argument_list|(
name|fstLong
argument_list|,
name|v
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|validOutputs
operator|.
name|contains
argument_list|(
name|v
argument_list|)
operator|||
name|input
operator|==
literal|null
argument_list|)
expr_stmt|;
block|}
block|}
comment|// find random matching word and make sure it's valid
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"TEST: verify random accepted terms"
argument_list|)
expr_stmt|;
block|}
specifier|final
name|IntsRef
name|scratch
init|=
operator|new
name|IntsRef
argument_list|(
literal|10
argument_list|)
decl_stmt|;
name|int
name|num
init|=
name|atLeast
argument_list|(
literal|500
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|iter
init|=
literal|0
init|;
name|iter
operator|<
name|num
condition|;
name|iter
operator|++
control|)
block|{
name|T
name|output
init|=
name|randomAcceptedWord
argument_list|(
name|fst
argument_list|,
name|scratch
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
literal|"accepted word "
operator|+
name|inputToString
argument_list|(
name|inputMode
argument_list|,
name|scratch
argument_list|)
operator|+
literal|" is not valid"
argument_list|,
name|termsMap
operator|.
name|containsKey
argument_list|(
name|scratch
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|termsMap
operator|.
name|get
argument_list|(
name|scratch
argument_list|)
argument_list|,
name|output
argument_list|)
expr_stmt|;
if|if
condition|(
name|doReverseLookup
condition|)
block|{
comment|//System.out.println("lookup output=" + output + " outs=" + fst.outputs);
name|IntsRef
name|input
init|=
name|Util
operator|.
name|getByOutput
argument_list|(
name|fstLong
argument_list|,
operator|(
name|Long
operator|)
name|output
argument_list|)
decl_stmt|;
name|assertNotNull
argument_list|(
name|input
argument_list|)
expr_stmt|;
comment|//System.out.println("  got " + Util.toBytesRef(input, new BytesRef()).utf8ToString());
name|assertEquals
argument_list|(
name|scratch
argument_list|,
name|input
argument_list|)
expr_stmt|;
block|}
block|}
comment|// test IntsRefFSTEnum.seek:
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"TEST: verify seek"
argument_list|)
expr_stmt|;
block|}
name|IntsRefFSTEnum
argument_list|<
name|T
argument_list|>
name|fstEnum
init|=
operator|new
name|IntsRefFSTEnum
argument_list|<
name|T
argument_list|>
argument_list|(
name|fst
argument_list|)
decl_stmt|;
name|num
operator|=
name|atLeast
argument_list|(
literal|100
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|iter
init|=
literal|0
init|;
name|iter
operator|<
name|num
condition|;
name|iter
operator|++
control|)
block|{
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"  iter="
operator|+
name|iter
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|random
operator|.
name|nextBoolean
argument_list|()
condition|)
block|{
comment|// seek to term that doesn't exist:
while|while
condition|(
literal|true
condition|)
block|{
specifier|final
name|IntsRef
name|term
init|=
name|toIntsRef
argument_list|(
name|getRandomString
argument_list|()
argument_list|,
name|inputMode
argument_list|)
decl_stmt|;
name|int
name|pos
init|=
name|Collections
operator|.
name|binarySearch
argument_list|(
name|pairs
argument_list|,
operator|new
name|InputOutput
argument_list|<
name|T
argument_list|>
argument_list|(
name|term
argument_list|,
literal|null
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|pos
operator|<
literal|0
condition|)
block|{
name|pos
operator|=
operator|-
operator|(
name|pos
operator|+
literal|1
operator|)
expr_stmt|;
comment|// ok doesn't exist
comment|//System.out.println("  seek " + inputToString(inputMode, term));
specifier|final
name|IntsRefFSTEnum
operator|.
name|InputOutput
argument_list|<
name|T
argument_list|>
name|seekResult
decl_stmt|;
if|if
condition|(
name|random
operator|.
name|nextInt
argument_list|(
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"  do non-exist seekExact term="
operator|+
name|inputToString
argument_list|(
name|inputMode
argument_list|,
name|term
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|seekResult
operator|=
name|fstEnum
operator|.
name|seekExact
argument_list|(
name|term
argument_list|)
expr_stmt|;
name|pos
operator|=
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|random
operator|.
name|nextBoolean
argument_list|()
condition|)
block|{
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"  do non-exist seekFloor term="
operator|+
name|inputToString
argument_list|(
name|inputMode
argument_list|,
name|term
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|seekResult
operator|=
name|fstEnum
operator|.
name|seekFloor
argument_list|(
name|term
argument_list|)
expr_stmt|;
name|pos
operator|--
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"  do non-exist seekCeil term="
operator|+
name|inputToString
argument_list|(
name|inputMode
argument_list|,
name|term
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|seekResult
operator|=
name|fstEnum
operator|.
name|seekCeil
argument_list|(
name|term
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pos
operator|!=
operator|-
literal|1
operator|&&
name|pos
operator|<
name|pairs
operator|.
name|size
argument_list|()
condition|)
block|{
comment|//System.out.println("    got " + inputToString(inputMode,seekResult.input) + " output=" + fst.outputs.outputToString(seekResult.output));
name|assertNotNull
argument_list|(
literal|"got null but expected term="
operator|+
name|inputToString
argument_list|(
name|inputMode
argument_list|,
name|pairs
operator|.
name|get
argument_list|(
name|pos
argument_list|)
operator|.
name|input
argument_list|)
argument_list|,
name|seekResult
argument_list|)
expr_stmt|;
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"    got "
operator|+
name|inputToString
argument_list|(
name|inputMode
argument_list|,
name|seekResult
operator|.
name|input
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|assertEquals
argument_list|(
literal|"expected "
operator|+
name|inputToString
argument_list|(
name|inputMode
argument_list|,
name|pairs
operator|.
name|get
argument_list|(
name|pos
argument_list|)
operator|.
name|input
argument_list|)
operator|+
literal|" but got "
operator|+
name|inputToString
argument_list|(
name|inputMode
argument_list|,
name|seekResult
operator|.
name|input
argument_list|)
argument_list|,
name|pairs
operator|.
name|get
argument_list|(
name|pos
argument_list|)
operator|.
name|input
argument_list|,
name|seekResult
operator|.
name|input
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|pairs
operator|.
name|get
argument_list|(
name|pos
argument_list|)
operator|.
name|output
argument_list|,
name|seekResult
operator|.
name|output
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// seeked before start or beyond end
comment|//System.out.println("seek=" + seekTerm);
name|assertNull
argument_list|(
literal|"expected null but got "
operator|+
operator|(
name|seekResult
operator|==
literal|null
condition|?
literal|"null"
else|:
name|inputToString
argument_list|(
name|inputMode
argument_list|,
name|seekResult
operator|.
name|input
argument_list|)
operator|)
argument_list|,
name|seekResult
argument_list|)
expr_stmt|;
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"    got null"
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
block|}
block|}
block|}
else|else
block|{
comment|// seek to term that does exist:
name|InputOutput
argument_list|<
name|T
argument_list|>
name|pair
init|=
name|pairs
operator|.
name|get
argument_list|(
name|random
operator|.
name|nextInt
argument_list|(
name|pairs
operator|.
name|size
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|IntsRefFSTEnum
operator|.
name|InputOutput
argument_list|<
name|T
argument_list|>
name|seekResult
decl_stmt|;
if|if
condition|(
name|random
operator|.
name|nextInt
argument_list|(
literal|3
argument_list|)
operator|==
literal|2
condition|)
block|{
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"  do exists seekExact term="
operator|+
name|inputToString
argument_list|(
name|inputMode
argument_list|,
name|pair
operator|.
name|input
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|seekResult
operator|=
name|fstEnum
operator|.
name|seekExact
argument_list|(
name|pair
operator|.
name|input
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|random
operator|.
name|nextBoolean
argument_list|()
condition|)
block|{
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"  do exists seekFloor "
operator|+
name|inputToString
argument_list|(
name|inputMode
argument_list|,
name|pair
operator|.
name|input
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|seekResult
operator|=
name|fstEnum
operator|.
name|seekFloor
argument_list|(
name|pair
operator|.
name|input
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"  do exists seekCeil "
operator|+
name|inputToString
argument_list|(
name|inputMode
argument_list|,
name|pair
operator|.
name|input
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|seekResult
operator|=
name|fstEnum
operator|.
name|seekCeil
argument_list|(
name|pair
operator|.
name|input
argument_list|)
expr_stmt|;
block|}
name|assertNotNull
argument_list|(
name|seekResult
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"got "
operator|+
name|inputToString
argument_list|(
name|inputMode
argument_list|,
name|seekResult
operator|.
name|input
argument_list|)
operator|+
literal|" but expected "
operator|+
name|inputToString
argument_list|(
name|inputMode
argument_list|,
name|pair
operator|.
name|input
argument_list|)
argument_list|,
name|pair
operator|.
name|input
argument_list|,
name|seekResult
operator|.
name|input
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|pair
operator|.
name|output
argument_list|,
name|seekResult
operator|.
name|output
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"TEST: mixed next/seek"
argument_list|)
expr_stmt|;
block|}
comment|// test mixed next/seek
name|num
operator|=
name|atLeast
argument_list|(
literal|100
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|iter
init|=
literal|0
init|;
name|iter
operator|<
name|num
condition|;
name|iter
operator|++
control|)
block|{
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"TEST: iter "
operator|+
name|iter
argument_list|)
expr_stmt|;
block|}
comment|// reset:
name|fstEnum
operator|=
operator|new
name|IntsRefFSTEnum
argument_list|<
name|T
argument_list|>
argument_list|(
name|fst
argument_list|)
expr_stmt|;
name|int
name|upto
init|=
operator|-
literal|1
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|boolean
name|isDone
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|upto
operator|==
name|pairs
operator|.
name|size
argument_list|()
operator|-
literal|1
operator|||
name|random
operator|.
name|nextBoolean
argument_list|()
condition|)
block|{
comment|// next
name|upto
operator|++
expr_stmt|;
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"  do next"
argument_list|)
expr_stmt|;
block|}
name|isDone
operator|=
name|fstEnum
operator|.
name|next
argument_list|()
operator|==
literal|null
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|upto
operator|!=
operator|-
literal|1
operator|&&
name|upto
operator|<
literal|0.75
operator|*
name|pairs
operator|.
name|size
argument_list|()
operator|&&
name|random
operator|.
name|nextBoolean
argument_list|()
condition|)
block|{
name|int
name|attempt
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
name|attempt
operator|<
literal|10
condition|;
name|attempt
operator|++
control|)
block|{
name|IntsRef
name|term
init|=
name|toIntsRef
argument_list|(
name|getRandomString
argument_list|()
argument_list|,
name|inputMode
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|termsMap
operator|.
name|containsKey
argument_list|(
name|term
argument_list|)
operator|&&
name|term
operator|.
name|compareTo
argument_list|(
name|pairs
operator|.
name|get
argument_list|(
name|upto
argument_list|)
operator|.
name|input
argument_list|)
operator|>
literal|0
condition|)
block|{
name|int
name|pos
init|=
name|Collections
operator|.
name|binarySearch
argument_list|(
name|pairs
argument_list|,
operator|new
name|InputOutput
argument_list|<
name|T
argument_list|>
argument_list|(
name|term
argument_list|,
literal|null
argument_list|)
argument_list|)
decl_stmt|;
assert|assert
name|pos
operator|<
literal|0
assert|;
name|upto
operator|=
operator|-
operator|(
name|pos
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|random
operator|.
name|nextBoolean
argument_list|()
condition|)
block|{
name|upto
operator|--
expr_stmt|;
name|assertTrue
argument_list|(
name|upto
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"  do non-exist seekFloor("
operator|+
name|inputToString
argument_list|(
name|inputMode
argument_list|,
name|term
argument_list|)
operator|+
literal|")"
argument_list|)
expr_stmt|;
block|}
name|isDone
operator|=
name|fstEnum
operator|.
name|seekFloor
argument_list|(
name|term
argument_list|)
operator|==
literal|null
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"  do non-exist seekCeil("
operator|+
name|inputToString
argument_list|(
name|inputMode
argument_list|,
name|term
argument_list|)
operator|+
literal|")"
argument_list|)
expr_stmt|;
block|}
name|isDone
operator|=
name|fstEnum
operator|.
name|seekCeil
argument_list|(
name|term
argument_list|)
operator|==
literal|null
expr_stmt|;
block|}
break|break;
block|}
block|}
if|if
condition|(
name|attempt
operator|==
literal|10
condition|)
block|{
continue|continue;
block|}
block|}
else|else
block|{
specifier|final
name|int
name|inc
init|=
name|random
operator|.
name|nextInt
argument_list|(
name|pairs
operator|.
name|size
argument_list|()
operator|-
name|upto
operator|-
literal|1
argument_list|)
decl_stmt|;
name|upto
operator|+=
name|inc
expr_stmt|;
if|if
condition|(
name|upto
operator|==
operator|-
literal|1
condition|)
block|{
name|upto
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|random
operator|.
name|nextBoolean
argument_list|()
condition|)
block|{
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"  do seekCeil("
operator|+
name|inputToString
argument_list|(
name|inputMode
argument_list|,
name|pairs
operator|.
name|get
argument_list|(
name|upto
argument_list|)
operator|.
name|input
argument_list|)
operator|+
literal|")"
argument_list|)
expr_stmt|;
block|}
name|isDone
operator|=
name|fstEnum
operator|.
name|seekCeil
argument_list|(
name|pairs
operator|.
name|get
argument_list|(
name|upto
argument_list|)
operator|.
name|input
argument_list|)
operator|==
literal|null
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"  do seekFloor("
operator|+
name|inputToString
argument_list|(
name|inputMode
argument_list|,
name|pairs
operator|.
name|get
argument_list|(
name|upto
argument_list|)
operator|.
name|input
argument_list|)
operator|+
literal|")"
argument_list|)
expr_stmt|;
block|}
name|isDone
operator|=
name|fstEnum
operator|.
name|seekFloor
argument_list|(
name|pairs
operator|.
name|get
argument_list|(
name|upto
argument_list|)
operator|.
name|input
argument_list|)
operator|==
literal|null
expr_stmt|;
block|}
block|}
if|if
condition|(
name|VERBOSE
condition|)
block|{
if|if
condition|(
operator|!
name|isDone
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"    got "
operator|+
name|inputToString
argument_list|(
name|inputMode
argument_list|,
name|fstEnum
operator|.
name|current
argument_list|()
operator|.
name|input
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"    got null"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|upto
operator|==
name|pairs
operator|.
name|size
argument_list|()
condition|)
block|{
name|assertTrue
argument_list|(
name|isDone
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
block|{
name|assertFalse
argument_list|(
name|isDone
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|pairs
operator|.
name|get
argument_list|(
name|upto
argument_list|)
operator|.
name|input
argument_list|,
name|fstEnum
operator|.
name|current
argument_list|()
operator|.
name|input
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|pairs
operator|.
name|get
argument_list|(
name|upto
argument_list|)
operator|.
name|output
argument_list|,
name|fstEnum
operator|.
name|current
argument_list|()
operator|.
name|output
argument_list|)
expr_stmt|;
comment|/*             if (upto< pairs.size()-1) {               int tryCount = 0;               while(tryCount< 10) {                 final IntsRef t = toIntsRef(getRandomString(), inputMode);                 if (pairs.get(upto).input.compareTo(t)< 0) {                   final boolean expected = t.compareTo(pairs.get(upto+1).input)< 0;                   if (VERBOSE) {                     System.out.println("TEST: call beforeNext(" + inputToString(inputMode, t) + "); current=" + inputToString(inputMode, pairs.get(upto).input) + " next=" + inputToString(inputMode, pairs.get(upto+1).input) + " expected=" + expected);                   }                   assertEquals(expected, fstEnum.beforeNext(t));                   break;                 }                 tryCount++;               }             }             */
block|}
block|}
block|}
block|}
DECL|class|CountMinOutput
specifier|private
specifier|static
class|class
name|CountMinOutput
parameter_list|<
name|T
parameter_list|>
block|{
DECL|field|count
name|int
name|count
decl_stmt|;
DECL|field|output
name|T
name|output
decl_stmt|;
DECL|field|finalOutput
name|T
name|finalOutput
decl_stmt|;
DECL|field|isLeaf
name|boolean
name|isLeaf
init|=
literal|true
decl_stmt|;
DECL|field|isFinal
name|boolean
name|isFinal
decl_stmt|;
block|}
comment|// FST is pruned
DECL|method|verifyPruned
specifier|private
name|void
name|verifyPruned
parameter_list|(
name|int
name|inputMode
parameter_list|,
name|FST
argument_list|<
name|T
argument_list|>
name|fst
parameter_list|,
name|int
name|prune1
parameter_list|,
name|int
name|prune2
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"TEST: now verify pruned "
operator|+
name|pairs
operator|.
name|size
argument_list|()
operator|+
literal|" terms; outputs="
operator|+
name|outputs
argument_list|)
expr_stmt|;
for|for
control|(
name|InputOutput
argument_list|<
name|T
argument_list|>
name|pair
range|:
name|pairs
control|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"  "
operator|+
name|inputToString
argument_list|(
name|inputMode
argument_list|,
name|pair
operator|.
name|input
argument_list|)
operator|+
literal|": "
operator|+
name|outputs
operator|.
name|outputToString
argument_list|(
name|pair
operator|.
name|output
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|// To validate the FST, we brute-force compute all prefixes
comment|// in the terms, matched to their "common" outputs, prune that
comment|// set according to the prune thresholds, then assert the FST
comment|// matches that same set.
comment|// NOTE: Crazy RAM intensive!!
comment|//System.out.println("TEST: tally prefixes");
comment|// build all prefixes
specifier|final
name|Map
argument_list|<
name|IntsRef
argument_list|,
name|CountMinOutput
argument_list|<
name|T
argument_list|>
argument_list|>
name|prefixes
init|=
operator|new
name|HashMap
argument_list|<
name|IntsRef
argument_list|,
name|CountMinOutput
argument_list|<
name|T
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
specifier|final
name|IntsRef
name|scratch
init|=
operator|new
name|IntsRef
argument_list|(
literal|10
argument_list|)
decl_stmt|;
for|for
control|(
name|InputOutput
argument_list|<
name|T
argument_list|>
name|pair
range|:
name|pairs
control|)
block|{
name|scratch
operator|.
name|copyInts
argument_list|(
name|pair
operator|.
name|input
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|idx
init|=
literal|0
init|;
name|idx
operator|<=
name|pair
operator|.
name|input
operator|.
name|length
condition|;
name|idx
operator|++
control|)
block|{
name|scratch
operator|.
name|length
operator|=
name|idx
expr_stmt|;
name|CountMinOutput
argument_list|<
name|T
argument_list|>
name|cmo
init|=
name|prefixes
operator|.
name|get
argument_list|(
name|scratch
argument_list|)
decl_stmt|;
if|if
condition|(
name|cmo
operator|==
literal|null
condition|)
block|{
name|cmo
operator|=
operator|new
name|CountMinOutput
argument_list|<
name|T
argument_list|>
argument_list|()
expr_stmt|;
name|cmo
operator|.
name|count
operator|=
literal|1
expr_stmt|;
name|cmo
operator|.
name|output
operator|=
name|pair
operator|.
name|output
expr_stmt|;
name|prefixes
operator|.
name|put
argument_list|(
name|IntsRef
operator|.
name|deepCopyOf
argument_list|(
name|scratch
argument_list|)
argument_list|,
name|cmo
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cmo
operator|.
name|count
operator|++
expr_stmt|;
name|T
name|output1
init|=
name|cmo
operator|.
name|output
decl_stmt|;
if|if
condition|(
name|output1
operator|.
name|equals
argument_list|(
name|outputs
operator|.
name|getNoOutput
argument_list|()
argument_list|)
condition|)
block|{
name|output1
operator|=
name|outputs
operator|.
name|getNoOutput
argument_list|()
expr_stmt|;
block|}
name|T
name|output2
init|=
name|pair
operator|.
name|output
decl_stmt|;
if|if
condition|(
name|output2
operator|.
name|equals
argument_list|(
name|outputs
operator|.
name|getNoOutput
argument_list|()
argument_list|)
condition|)
block|{
name|output2
operator|=
name|outputs
operator|.
name|getNoOutput
argument_list|()
expr_stmt|;
block|}
name|cmo
operator|.
name|output
operator|=
name|outputs
operator|.
name|common
argument_list|(
name|output1
argument_list|,
name|output2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|idx
operator|==
name|pair
operator|.
name|input
operator|.
name|length
condition|)
block|{
name|cmo
operator|.
name|isFinal
operator|=
literal|true
expr_stmt|;
name|cmo
operator|.
name|finalOutput
operator|=
name|cmo
operator|.
name|output
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"TEST: now prune"
argument_list|)
expr_stmt|;
block|}
comment|// prune 'em
specifier|final
name|Iterator
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|IntsRef
argument_list|,
name|CountMinOutput
argument_list|<
name|T
argument_list|>
argument_list|>
argument_list|>
name|it
init|=
name|prefixes
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Map
operator|.
name|Entry
argument_list|<
name|IntsRef
argument_list|,
name|CountMinOutput
argument_list|<
name|T
argument_list|>
argument_list|>
name|ent
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
specifier|final
name|IntsRef
name|prefix
init|=
name|ent
operator|.
name|getKey
argument_list|()
decl_stmt|;
specifier|final
name|CountMinOutput
argument_list|<
name|T
argument_list|>
name|cmo
init|=
name|ent
operator|.
name|getValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"  term prefix="
operator|+
name|inputToString
argument_list|(
name|inputMode
argument_list|,
name|prefix
argument_list|,
literal|false
argument_list|)
operator|+
literal|" count="
operator|+
name|cmo
operator|.
name|count
operator|+
literal|" isLeaf="
operator|+
name|cmo
operator|.
name|isLeaf
operator|+
literal|" output="
operator|+
name|outputs
operator|.
name|outputToString
argument_list|(
name|cmo
operator|.
name|output
argument_list|)
operator|+
literal|" isFinal="
operator|+
name|cmo
operator|.
name|isFinal
argument_list|)
expr_stmt|;
block|}
specifier|final
name|boolean
name|keep
decl_stmt|;
if|if
condition|(
name|prune1
operator|>
literal|0
condition|)
block|{
name|keep
operator|=
name|cmo
operator|.
name|count
operator|>=
name|prune1
expr_stmt|;
block|}
else|else
block|{
assert|assert
name|prune2
operator|>
literal|0
assert|;
if|if
condition|(
name|prune2
operator|>
literal|1
operator|&&
name|cmo
operator|.
name|count
operator|>=
name|prune2
condition|)
block|{
name|keep
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|prefix
operator|.
name|length
operator|>
literal|0
condition|)
block|{
comment|// consult our parent
name|scratch
operator|.
name|length
operator|=
name|prefix
operator|.
name|length
operator|-
literal|1
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|prefix
operator|.
name|ints
argument_list|,
name|prefix
operator|.
name|offset
argument_list|,
name|scratch
operator|.
name|ints
argument_list|,
literal|0
argument_list|,
name|scratch
operator|.
name|length
argument_list|)
expr_stmt|;
specifier|final
name|CountMinOutput
argument_list|<
name|T
argument_list|>
name|cmo2
init|=
name|prefixes
operator|.
name|get
argument_list|(
name|scratch
argument_list|)
decl_stmt|;
comment|//System.out.println("    parent count = " + (cmo2 == null ? -1 : cmo2.count));
name|keep
operator|=
name|cmo2
operator|!=
literal|null
operator|&&
operator|(
operator|(
name|prune2
operator|>
literal|1
operator|&&
name|cmo2
operator|.
name|count
operator|>=
name|prune2
operator|)
operator|||
operator|(
name|prune2
operator|==
literal|1
operator|&&
operator|(
name|cmo2
operator|.
name|count
operator|>=
literal|2
operator|||
name|prefix
operator|.
name|length
operator|<=
literal|1
operator|)
operator|)
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cmo
operator|.
name|count
operator|>=
name|prune2
condition|)
block|{
name|keep
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|keep
operator|=
literal|false
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|keep
condition|)
block|{
name|it
operator|.
name|remove
argument_list|()
expr_stmt|;
comment|//System.out.println("    remove");
block|}
else|else
block|{
comment|// clear isLeaf for all ancestors
comment|//System.out.println("    keep");
name|scratch
operator|.
name|copyInts
argument_list|(
name|prefix
argument_list|)
expr_stmt|;
name|scratch
operator|.
name|length
operator|--
expr_stmt|;
while|while
condition|(
name|scratch
operator|.
name|length
operator|>=
literal|0
condition|)
block|{
specifier|final
name|CountMinOutput
argument_list|<
name|T
argument_list|>
name|cmo2
init|=
name|prefixes
operator|.
name|get
argument_list|(
name|scratch
argument_list|)
decl_stmt|;
if|if
condition|(
name|cmo2
operator|!=
literal|null
condition|)
block|{
comment|//System.out.println("    clear isLeaf " + inputToString(inputMode, scratch));
name|cmo2
operator|.
name|isLeaf
operator|=
literal|false
expr_stmt|;
block|}
name|scratch
operator|.
name|length
operator|--
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"TEST: after prune"
argument_list|)
expr_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|IntsRef
argument_list|,
name|CountMinOutput
argument_list|<
name|T
argument_list|>
argument_list|>
name|ent
range|:
name|prefixes
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"  "
operator|+
name|inputToString
argument_list|(
name|inputMode
argument_list|,
name|ent
operator|.
name|getKey
argument_list|()
argument_list|,
literal|false
argument_list|)
operator|+
literal|": isLeaf="
operator|+
name|ent
operator|.
name|getValue
argument_list|()
operator|.
name|isLeaf
operator|+
literal|" isFinal="
operator|+
name|ent
operator|.
name|getValue
argument_list|()
operator|.
name|isFinal
argument_list|)
expr_stmt|;
if|if
condition|(
name|ent
operator|.
name|getValue
argument_list|()
operator|.
name|isFinal
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"    finalOutput="
operator|+
name|outputs
operator|.
name|outputToString
argument_list|(
name|ent
operator|.
name|getValue
argument_list|()
operator|.
name|finalOutput
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|prefixes
operator|.
name|size
argument_list|()
operator|<=
literal|1
condition|)
block|{
name|assertNull
argument_list|(
name|fst
argument_list|)
expr_stmt|;
return|return;
block|}
name|assertNotNull
argument_list|(
name|fst
argument_list|)
expr_stmt|;
comment|// make sure FST only enums valid prefixes
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"TEST: check pruned enum"
argument_list|)
expr_stmt|;
block|}
name|IntsRefFSTEnum
argument_list|<
name|T
argument_list|>
name|fstEnum
init|=
operator|new
name|IntsRefFSTEnum
argument_list|<
name|T
argument_list|>
argument_list|(
name|fst
argument_list|)
decl_stmt|;
name|IntsRefFSTEnum
operator|.
name|InputOutput
argument_list|<
name|T
argument_list|>
name|current
decl_stmt|;
while|while
condition|(
operator|(
name|current
operator|=
name|fstEnum
operator|.
name|next
argument_list|()
operator|)
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"  fstEnum.next prefix="
operator|+
name|inputToString
argument_list|(
name|inputMode
argument_list|,
name|current
operator|.
name|input
argument_list|,
literal|false
argument_list|)
operator|+
literal|" output="
operator|+
name|outputs
operator|.
name|outputToString
argument_list|(
name|current
operator|.
name|output
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|final
name|CountMinOutput
name|cmo
init|=
name|prefixes
operator|.
name|get
argument_list|(
name|current
operator|.
name|input
argument_list|)
decl_stmt|;
name|assertNotNull
argument_list|(
name|cmo
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|cmo
operator|.
name|isLeaf
operator|||
name|cmo
operator|.
name|isFinal
argument_list|)
expr_stmt|;
comment|//if (cmo.isFinal&& !cmo.isLeaf) {
if|if
condition|(
name|cmo
operator|.
name|isFinal
condition|)
block|{
name|assertEquals
argument_list|(
name|cmo
operator|.
name|finalOutput
argument_list|,
name|current
operator|.
name|output
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|assertEquals
argument_list|(
name|cmo
operator|.
name|output
argument_list|,
name|current
operator|.
name|output
argument_list|)
expr_stmt|;
block|}
block|}
comment|// make sure all non-pruned prefixes are present in the FST
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"TEST: verify all prefixes"
argument_list|)
expr_stmt|;
block|}
specifier|final
name|int
index|[]
name|stopNode
init|=
operator|new
name|int
index|[
literal|1
index|]
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|IntsRef
argument_list|,
name|CountMinOutput
argument_list|<
name|T
argument_list|>
argument_list|>
name|ent
range|:
name|prefixes
operator|.
name|entrySet
argument_list|()
control|)
block|{
if|if
condition|(
name|ent
operator|.
name|getKey
argument_list|()
operator|.
name|length
operator|>
literal|0
condition|)
block|{
specifier|final
name|CountMinOutput
argument_list|<
name|T
argument_list|>
name|cmo
init|=
name|ent
operator|.
name|getValue
argument_list|()
decl_stmt|;
specifier|final
name|T
name|output
init|=
name|run
argument_list|(
name|fst
argument_list|,
name|ent
operator|.
name|getKey
argument_list|()
argument_list|,
name|stopNode
argument_list|)
decl_stmt|;
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"TEST: verify prefix="
operator|+
name|inputToString
argument_list|(
name|inputMode
argument_list|,
name|ent
operator|.
name|getKey
argument_list|()
argument_list|,
literal|false
argument_list|)
operator|+
literal|" output="
operator|+
name|outputs
operator|.
name|outputToString
argument_list|(
name|cmo
operator|.
name|output
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// if (cmo.isFinal&& !cmo.isLeaf) {
if|if
condition|(
name|cmo
operator|.
name|isFinal
condition|)
block|{
name|assertEquals
argument_list|(
name|cmo
operator|.
name|finalOutput
argument_list|,
name|output
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|assertEquals
argument_list|(
name|cmo
operator|.
name|output
argument_list|,
name|output
argument_list|)
expr_stmt|;
block|}
name|assertEquals
argument_list|(
name|ent
operator|.
name|getKey
argument_list|()
operator|.
name|length
argument_list|,
name|stopNode
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
DECL|method|testRandomWords
specifier|public
name|void
name|testRandomWords
parameter_list|()
throws|throws
name|IOException
block|{
name|testRandomWords
argument_list|(
literal|1000
argument_list|,
name|atLeast
argument_list|(
literal|2
argument_list|)
argument_list|)
expr_stmt|;
comment|//testRandomWords(100, 1);
block|}
DECL|method|inputModeToString
name|String
name|inputModeToString
parameter_list|(
name|int
name|mode
parameter_list|)
block|{
if|if
condition|(
name|mode
operator|==
literal|0
condition|)
block|{
return|return
literal|"utf8"
return|;
block|}
else|else
block|{
return|return
literal|"utf32"
return|;
block|}
block|}
DECL|method|testRandomWords
specifier|private
name|void
name|testRandomWords
parameter_list|(
name|int
name|maxNumWords
parameter_list|,
name|int
name|numIter
parameter_list|)
throws|throws
name|IOException
block|{
for|for
control|(
name|int
name|iter
init|=
literal|0
init|;
name|iter
operator|<
name|numIter
condition|;
name|iter
operator|++
control|)
block|{
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"\nTEST: iter "
operator|+
name|iter
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|inputMode
init|=
literal|0
init|;
name|inputMode
operator|<
literal|2
condition|;
name|inputMode
operator|++
control|)
block|{
specifier|final
name|int
name|numWords
init|=
name|random
operator|.
name|nextInt
argument_list|(
name|maxNumWords
operator|+
literal|1
argument_list|)
decl_stmt|;
name|Set
argument_list|<
name|IntsRef
argument_list|>
name|termsSet
init|=
operator|new
name|HashSet
argument_list|<
name|IntsRef
argument_list|>
argument_list|()
decl_stmt|;
name|IntsRef
index|[]
name|terms
init|=
operator|new
name|IntsRef
index|[
name|numWords
index|]
decl_stmt|;
while|while
condition|(
name|termsSet
operator|.
name|size
argument_list|()
operator|<
name|numWords
condition|)
block|{
specifier|final
name|String
name|term
init|=
name|getRandomString
argument_list|()
decl_stmt|;
name|termsSet
operator|.
name|add
argument_list|(
name|toIntsRef
argument_list|(
name|term
argument_list|,
name|inputMode
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|doTest
argument_list|(
name|inputMode
argument_list|,
name|termsSet
operator|.
name|toArray
argument_list|(
operator|new
name|IntsRef
index|[
name|termsSet
operator|.
name|size
argument_list|()
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|getRandomString
specifier|static
name|String
name|getRandomString
parameter_list|()
block|{
specifier|final
name|String
name|term
decl_stmt|;
if|if
condition|(
name|random
operator|.
name|nextBoolean
argument_list|()
condition|)
block|{
name|term
operator|=
name|_TestUtil
operator|.
name|randomRealisticUnicodeString
argument_list|(
name|random
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// we want to mix in limited-alphabet symbols so
comment|// we get more sharing of the nodes given how few
comment|// terms we are testing...
name|term
operator|=
name|simpleRandomString
argument_list|(
name|random
argument_list|)
expr_stmt|;
block|}
return|return
name|term
return|;
block|}
annotation|@
name|Nightly
DECL|method|testBigSet
specifier|public
name|void
name|testBigSet
parameter_list|()
throws|throws
name|IOException
block|{
name|testRandomWords
argument_list|(
name|_TestUtil
operator|.
name|nextInt
argument_list|(
name|random
argument_list|,
literal|50000
argument_list|,
literal|60000
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
DECL|method|inputToString
specifier|static
name|String
name|inputToString
parameter_list|(
name|int
name|inputMode
parameter_list|,
name|IntsRef
name|term
parameter_list|)
block|{
return|return
name|inputToString
argument_list|(
name|inputMode
argument_list|,
name|term
argument_list|,
literal|true
argument_list|)
return|;
block|}
DECL|method|inputToString
specifier|private
specifier|static
name|String
name|inputToString
parameter_list|(
name|int
name|inputMode
parameter_list|,
name|IntsRef
name|term
parameter_list|,
name|boolean
name|isValidUnicode
parameter_list|)
block|{
if|if
condition|(
operator|!
name|isValidUnicode
condition|)
block|{
return|return
name|term
operator|.
name|toString
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|inputMode
operator|==
literal|0
condition|)
block|{
comment|// utf8
return|return
name|toBytesRef
argument_list|(
name|term
argument_list|)
operator|.
name|utf8ToString
argument_list|()
operator|+
literal|" "
operator|+
name|term
return|;
block|}
else|else
block|{
comment|// utf32
return|return
name|UnicodeUtil
operator|.
name|newString
argument_list|(
name|term
operator|.
name|ints
argument_list|,
name|term
operator|.
name|offset
argument_list|,
name|term
operator|.
name|length
argument_list|)
operator|+
literal|" "
operator|+
name|term
return|;
block|}
block|}
comment|// Build FST for all unique terms in the test line docs
comment|// file, up until a time limit
DECL|method|testRealTerms
specifier|public
name|void
name|testRealTerms
parameter_list|()
throws|throws
name|Exception
block|{
comment|// TODO: is this necessary? we use the annotation...
specifier|final
name|String
name|defaultFormat
init|=
name|_TestUtil
operator|.
name|getPostingsFormat
argument_list|(
literal|"abracadabra"
argument_list|)
decl_stmt|;
if|if
condition|(
name|defaultFormat
operator|.
name|equals
argument_list|(
literal|"SimpleText"
argument_list|)
operator|||
name|defaultFormat
operator|.
name|equals
argument_list|(
literal|"Memory"
argument_list|)
condition|)
block|{
comment|// no
name|Codec
operator|.
name|setDefault
argument_list|(
name|_TestUtil
operator|.
name|alwaysPostingsFormat
argument_list|(
operator|new
name|Lucene40PostingsFormat
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|final
name|LineFileDocs
name|docs
init|=
operator|new
name|LineFileDocs
argument_list|(
name|random
argument_list|)
decl_stmt|;
specifier|final
name|int
name|RUN_TIME_MSEC
init|=
name|atLeast
argument_list|(
literal|500
argument_list|)
decl_stmt|;
specifier|final
name|IndexWriterConfig
name|conf
init|=
name|newIndexWriterConfig
argument_list|(
name|TEST_VERSION_CURRENT
argument_list|,
operator|new
name|MockAnalyzer
argument_list|(
name|random
argument_list|)
argument_list|)
operator|.
name|setMaxBufferedDocs
argument_list|(
operator|-
literal|1
argument_list|)
operator|.
name|setRAMBufferSizeMB
argument_list|(
literal|64
argument_list|)
decl_stmt|;
specifier|final
name|File
name|tempDir
init|=
name|_TestUtil
operator|.
name|getTempDir
argument_list|(
literal|"fstlines"
argument_list|)
decl_stmt|;
specifier|final
name|MockDirectoryWrapper
name|dir
init|=
name|newFSDirectory
argument_list|(
name|tempDir
argument_list|)
decl_stmt|;
specifier|final
name|IndexWriter
name|writer
init|=
operator|new
name|IndexWriter
argument_list|(
name|dir
argument_list|,
name|conf
argument_list|)
decl_stmt|;
specifier|final
name|long
name|stopTime
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|+
name|RUN_TIME_MSEC
decl_stmt|;
name|Document
name|doc
decl_stmt|;
name|int
name|docCount
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|(
name|doc
operator|=
name|docs
operator|.
name|nextDoc
argument_list|()
operator|)
operator|!=
literal|null
operator|&&
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|<
name|stopTime
condition|)
block|{
name|writer
operator|.
name|addDocument
argument_list|(
name|doc
argument_list|)
expr_stmt|;
name|docCount
operator|++
expr_stmt|;
block|}
name|IndexReader
name|r
init|=
name|IndexReader
operator|.
name|open
argument_list|(
name|writer
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|writer
operator|.
name|close
argument_list|()
expr_stmt|;
specifier|final
name|PositiveIntOutputs
name|outputs
init|=
name|PositiveIntOutputs
operator|.
name|getSingleton
argument_list|(
name|random
operator|.
name|nextBoolean
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|boolean
name|doRewrite
init|=
name|random
operator|.
name|nextBoolean
argument_list|()
decl_stmt|;
name|Builder
argument_list|<
name|Long
argument_list|>
name|builder
init|=
operator|new
name|Builder
argument_list|<
name|Long
argument_list|>
argument_list|(
name|FST
operator|.
name|INPUT_TYPE
operator|.
name|BYTE1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|true
argument_list|,
literal|true
argument_list|,
name|Integer
operator|.
name|MAX_VALUE
argument_list|,
name|outputs
argument_list|,
literal|null
argument_list|,
name|doRewrite
argument_list|)
decl_stmt|;
name|boolean
name|storeOrd
init|=
name|random
operator|.
name|nextBoolean
argument_list|()
decl_stmt|;
if|if
condition|(
name|VERBOSE
condition|)
block|{
if|if
condition|(
name|storeOrd
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"FST stores ord"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"FST stores docFreq"
argument_list|)
expr_stmt|;
block|}
block|}
name|Terms
name|terms
init|=
name|MultiFields
operator|.
name|getTerms
argument_list|(
name|r
argument_list|,
literal|"body"
argument_list|)
decl_stmt|;
if|if
condition|(
name|terms
operator|!=
literal|null
condition|)
block|{
specifier|final
name|IntsRef
name|scratchIntsRef
init|=
operator|new
name|IntsRef
argument_list|()
decl_stmt|;
specifier|final
name|TermsEnum
name|termsEnum
init|=
name|terms
operator|.
name|iterator
argument_list|(
literal|null
argument_list|)
decl_stmt|;
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"TEST: got termsEnum="
operator|+
name|termsEnum
argument_list|)
expr_stmt|;
block|}
name|BytesRef
name|term
decl_stmt|;
name|int
name|ord
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|(
name|term
operator|=
name|termsEnum
operator|.
name|next
argument_list|()
operator|)
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|ord
operator|==
literal|0
condition|)
block|{
try|try
block|{
name|termsEnum
operator|.
name|ord
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedOperationException
name|uoe
parameter_list|)
block|{
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"TEST: codec doesn't support ord; FST stores docFreq"
argument_list|)
expr_stmt|;
block|}
name|storeOrd
operator|=
literal|false
expr_stmt|;
block|}
block|}
specifier|final
name|int
name|output
decl_stmt|;
if|if
condition|(
name|storeOrd
condition|)
block|{
name|output
operator|=
name|ord
expr_stmt|;
block|}
else|else
block|{
name|output
operator|=
name|termsEnum
operator|.
name|docFreq
argument_list|()
expr_stmt|;
block|}
name|builder
operator|.
name|add
argument_list|(
name|Util
operator|.
name|toIntsRef
argument_list|(
name|term
argument_list|,
name|scratchIntsRef
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|output
argument_list|)
expr_stmt|;
name|ord
operator|++
expr_stmt|;
if|if
condition|(
name|VERBOSE
operator|&&
name|ord
operator|%
literal|100000
operator|==
literal|0
operator|&&
name|LuceneTestCase
operator|.
name|TEST_NIGHTLY
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
name|ord
operator|+
literal|" terms..."
argument_list|)
expr_stmt|;
block|}
block|}
name|FST
argument_list|<
name|Long
argument_list|>
name|fst
init|=
name|builder
operator|.
name|finish
argument_list|()
decl_stmt|;
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"FST: "
operator|+
name|docCount
operator|+
literal|" docs; "
operator|+
name|ord
operator|+
literal|" terms; "
operator|+
name|fst
operator|.
name|getNodeCount
argument_list|()
operator|+
literal|" nodes; "
operator|+
name|fst
operator|.
name|getArcCount
argument_list|()
operator|+
literal|" arcs;"
operator|+
literal|" "
operator|+
name|fst
operator|.
name|sizeInBytes
argument_list|()
operator|+
literal|" bytes"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ord
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|int
name|rewriteIter
init|=
literal|0
init|;
name|rewriteIter
operator|<
literal|2
condition|;
name|rewriteIter
operator|++
control|)
block|{
if|if
condition|(
name|rewriteIter
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|doRewrite
condition|)
block|{
comment|// Verify again, with packed FST:
name|fst
operator|=
name|fst
operator|.
name|pack
argument_list|(
name|_TestUtil
operator|.
name|nextInt
argument_list|(
name|random
argument_list|,
literal|1
argument_list|,
literal|10
argument_list|)
argument_list|,
name|_TestUtil
operator|.
name|nextInt
argument_list|(
name|random
argument_list|,
literal|0
argument_list|,
literal|10000000
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
break|break;
block|}
block|}
comment|// Now confirm BytesRefFSTEnum and TermsEnum act the
comment|// same:
specifier|final
name|BytesRefFSTEnum
argument_list|<
name|Long
argument_list|>
name|fstEnum
init|=
operator|new
name|BytesRefFSTEnum
argument_list|<
name|Long
argument_list|>
argument_list|(
name|fst
argument_list|)
decl_stmt|;
name|int
name|num
init|=
name|atLeast
argument_list|(
literal|1000
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|iter
init|=
literal|0
init|;
name|iter
operator|<
name|num
condition|;
name|iter
operator|++
control|)
block|{
specifier|final
name|BytesRef
name|randomTerm
init|=
operator|new
name|BytesRef
argument_list|(
name|getRandomString
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"TEST: seek non-exist "
operator|+
name|randomTerm
operator|.
name|utf8ToString
argument_list|()
operator|+
literal|" "
operator|+
name|randomTerm
argument_list|)
expr_stmt|;
block|}
specifier|final
name|TermsEnum
operator|.
name|SeekStatus
name|seekResult
init|=
name|termsEnum
operator|.
name|seekCeil
argument_list|(
name|randomTerm
argument_list|)
decl_stmt|;
specifier|final
name|BytesRefFSTEnum
operator|.
name|InputOutput
name|fstSeekResult
init|=
name|fstEnum
operator|.
name|seekCeil
argument_list|(
name|randomTerm
argument_list|)
decl_stmt|;
if|if
condition|(
name|seekResult
operator|==
name|TermsEnum
operator|.
name|SeekStatus
operator|.
name|END
condition|)
block|{
name|assertNull
argument_list|(
literal|"got "
operator|+
operator|(
name|fstSeekResult
operator|==
literal|null
condition|?
literal|"null"
else|:
name|fstSeekResult
operator|.
name|input
operator|.
name|utf8ToString
argument_list|()
operator|)
operator|+
literal|" but expected null"
argument_list|,
name|fstSeekResult
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|assertSame
argument_list|(
name|termsEnum
argument_list|,
name|fstEnum
argument_list|,
name|storeOrd
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|nextIter
init|=
literal|0
init|;
name|nextIter
operator|<
literal|10
condition|;
name|nextIter
operator|++
control|)
block|{
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"TEST: next"
argument_list|)
expr_stmt|;
if|if
condition|(
name|storeOrd
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"  ord="
operator|+
name|termsEnum
operator|.
name|ord
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|termsEnum
operator|.
name|next
argument_list|()
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"  term="
operator|+
name|termsEnum
operator|.
name|term
argument_list|()
operator|.
name|utf8ToString
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|assertNotNull
argument_list|(
name|fstEnum
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
name|assertSame
argument_list|(
name|termsEnum
argument_list|,
name|fstEnum
argument_list|,
name|storeOrd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"  end!"
argument_list|)
expr_stmt|;
block|}
name|BytesRefFSTEnum
operator|.
name|InputOutput
argument_list|<
name|Long
argument_list|>
name|nextResult
init|=
name|fstEnum
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|nextResult
operator|!=
literal|null
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"expected null but got: input="
operator|+
name|nextResult
operator|.
name|input
operator|.
name|utf8ToString
argument_list|()
operator|+
literal|" output="
operator|+
name|outputs
operator|.
name|outputToString
argument_list|(
name|nextResult
operator|.
name|output
argument_list|)
argument_list|)
expr_stmt|;
name|fail
argument_list|()
expr_stmt|;
block|}
break|break;
block|}
block|}
block|}
block|}
block|}
block|}
block|}
name|r
operator|.
name|close
argument_list|()
expr_stmt|;
name|dir
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
DECL|method|assertSame
specifier|private
name|void
name|assertSame
parameter_list|(
name|TermsEnum
name|termsEnum
parameter_list|,
name|BytesRefFSTEnum
name|fstEnum
parameter_list|,
name|boolean
name|storeOrd
parameter_list|)
throws|throws
name|Exception
block|{
if|if
condition|(
name|termsEnum
operator|.
name|term
argument_list|()
operator|==
literal|null
condition|)
block|{
name|assertNull
argument_list|(
name|fstEnum
operator|.
name|current
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|assertNotNull
argument_list|(
name|fstEnum
operator|.
name|current
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|termsEnum
operator|.
name|term
argument_list|()
operator|.
name|utf8ToString
argument_list|()
operator|+
literal|" != "
operator|+
name|fstEnum
operator|.
name|current
argument_list|()
operator|.
name|input
operator|.
name|utf8ToString
argument_list|()
argument_list|,
name|termsEnum
operator|.
name|term
argument_list|()
argument_list|,
name|fstEnum
operator|.
name|current
argument_list|()
operator|.
name|input
argument_list|)
expr_stmt|;
if|if
condition|(
name|storeOrd
condition|)
block|{
comment|// fst stored the ord
name|assertEquals
argument_list|(
literal|"term="
operator|+
name|termsEnum
operator|.
name|term
argument_list|()
operator|.
name|utf8ToString
argument_list|()
operator|+
literal|" "
operator|+
name|termsEnum
operator|.
name|term
argument_list|()
argument_list|,
name|termsEnum
operator|.
name|ord
argument_list|()
argument_list|,
operator|(
operator|(
name|Long
operator|)
name|fstEnum
operator|.
name|current
argument_list|()
operator|.
name|output
operator|)
operator|.
name|longValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// fst stored the docFreq
name|assertEquals
argument_list|(
literal|"term="
operator|+
name|termsEnum
operator|.
name|term
argument_list|()
operator|.
name|utf8ToString
argument_list|()
operator|+
literal|" "
operator|+
name|termsEnum
operator|.
name|term
argument_list|()
argument_list|,
name|termsEnum
operator|.
name|docFreq
argument_list|()
argument_list|,
call|(
name|int
call|)
argument_list|(
operator|(
operator|(
name|Long
operator|)
name|fstEnum
operator|.
name|current
argument_list|()
operator|.
name|output
operator|)
operator|.
name|longValue
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|class|VisitTerms
specifier|private
specifier|static
specifier|abstract
class|class
name|VisitTerms
parameter_list|<
name|T
parameter_list|>
block|{
DECL|field|dirOut
specifier|private
specifier|final
name|String
name|dirOut
decl_stmt|;
DECL|field|wordsFileIn
specifier|private
specifier|final
name|String
name|wordsFileIn
decl_stmt|;
DECL|field|inputMode
specifier|private
name|int
name|inputMode
decl_stmt|;
DECL|field|outputs
specifier|private
specifier|final
name|Outputs
argument_list|<
name|T
argument_list|>
name|outputs
decl_stmt|;
DECL|field|builder
specifier|private
specifier|final
name|Builder
argument_list|<
name|T
argument_list|>
name|builder
decl_stmt|;
DECL|field|doPack
specifier|private
specifier|final
name|boolean
name|doPack
decl_stmt|;
DECL|method|VisitTerms
specifier|public
name|VisitTerms
parameter_list|(
name|String
name|dirOut
parameter_list|,
name|String
name|wordsFileIn
parameter_list|,
name|int
name|inputMode
parameter_list|,
name|int
name|prune
parameter_list|,
name|Outputs
argument_list|<
name|T
argument_list|>
name|outputs
parameter_list|,
name|boolean
name|doPack
parameter_list|,
name|boolean
name|noArcArrays
parameter_list|)
block|{
name|this
operator|.
name|dirOut
operator|=
name|dirOut
expr_stmt|;
name|this
operator|.
name|wordsFileIn
operator|=
name|wordsFileIn
expr_stmt|;
name|this
operator|.
name|inputMode
operator|=
name|inputMode
expr_stmt|;
name|this
operator|.
name|outputs
operator|=
name|outputs
expr_stmt|;
name|this
operator|.
name|doPack
operator|=
name|doPack
expr_stmt|;
name|builder
operator|=
operator|new
name|Builder
argument_list|<
name|T
argument_list|>
argument_list|(
name|inputMode
operator|==
literal|0
condition|?
name|FST
operator|.
name|INPUT_TYPE
operator|.
name|BYTE1
else|:
name|FST
operator|.
name|INPUT_TYPE
operator|.
name|BYTE4
argument_list|,
literal|0
argument_list|,
name|prune
argument_list|,
name|prune
operator|==
literal|0
argument_list|,
literal|true
argument_list|,
name|Integer
operator|.
name|MAX_VALUE
argument_list|,
name|outputs
argument_list|,
literal|null
argument_list|,
name|doPack
argument_list|)
expr_stmt|;
name|builder
operator|.
name|setAllowArrayArcs
argument_list|(
operator|!
name|noArcArrays
argument_list|)
expr_stmt|;
block|}
DECL|method|getOutput
specifier|protected
specifier|abstract
name|T
name|getOutput
parameter_list|(
name|IntsRef
name|input
parameter_list|,
name|int
name|ord
parameter_list|)
throws|throws
name|IOException
function_decl|;
DECL|method|run
specifier|public
name|void
name|run
parameter_list|(
name|int
name|limit
parameter_list|,
name|boolean
name|verify
parameter_list|,
name|boolean
name|verifyByOutput
parameter_list|)
throws|throws
name|IOException
block|{
name|BufferedReader
name|is
init|=
operator|new
name|BufferedReader
argument_list|(
operator|new
name|InputStreamReader
argument_list|(
operator|new
name|FileInputStream
argument_list|(
name|wordsFileIn
argument_list|)
argument_list|,
literal|"UTF-8"
argument_list|)
argument_list|,
literal|65536
argument_list|)
decl_stmt|;
try|try
block|{
specifier|final
name|IntsRef
name|intsRef
init|=
operator|new
name|IntsRef
argument_list|(
literal|10
argument_list|)
decl_stmt|;
name|long
name|tStart
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
name|int
name|ord
init|=
literal|0
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|String
name|w
init|=
name|is
operator|.
name|readLine
argument_list|()
decl_stmt|;
if|if
condition|(
name|w
operator|==
literal|null
condition|)
block|{
break|break;
block|}
name|toIntsRef
argument_list|(
name|w
argument_list|,
name|inputMode
argument_list|,
name|intsRef
argument_list|)
expr_stmt|;
name|builder
operator|.
name|add
argument_list|(
name|intsRef
argument_list|,
name|getOutput
argument_list|(
name|intsRef
argument_list|,
name|ord
argument_list|)
argument_list|)
expr_stmt|;
name|ord
operator|++
expr_stmt|;
if|if
condition|(
name|ord
operator|%
literal|500000
operator|==
literal|0
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
name|String
operator|.
name|format
argument_list|(
name|Locale
operator|.
name|ENGLISH
argument_list|,
literal|"%6.2fs: %9d..."
argument_list|,
operator|(
operator|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|-
name|tStart
operator|)
operator|/
literal|1000.0
operator|)
argument_list|,
name|ord
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ord
operator|>=
name|limit
condition|)
block|{
break|break;
block|}
block|}
assert|assert
name|builder
operator|.
name|getTermCount
argument_list|()
operator|==
name|ord
assert|;
name|FST
argument_list|<
name|T
argument_list|>
name|fst
init|=
name|builder
operator|.
name|finish
argument_list|()
decl_stmt|;
if|if
condition|(
name|fst
operator|==
literal|null
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"FST was fully pruned!"
argument_list|)
expr_stmt|;
name|System
operator|.
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dirOut
operator|==
literal|null
condition|)
block|{
return|return;
block|}
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
name|ord
operator|+
literal|" terms; "
operator|+
name|fst
operator|.
name|getNodeCount
argument_list|()
operator|+
literal|" nodes; "
operator|+
name|fst
operator|.
name|getArcCount
argument_list|()
operator|+
literal|" arcs; "
operator|+
name|fst
operator|.
name|getArcWithOutputCount
argument_list|()
operator|+
literal|" arcs w/ output; tot size "
operator|+
name|fst
operator|.
name|sizeInBytes
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|fst
operator|.
name|getNodeCount
argument_list|()
operator|<
literal|100
condition|)
block|{
name|Writer
name|w
init|=
operator|new
name|OutputStreamWriter
argument_list|(
operator|new
name|FileOutputStream
argument_list|(
literal|"out.dot"
argument_list|)
argument_list|,
literal|"UTF-8"
argument_list|)
decl_stmt|;
name|Util
operator|.
name|toDot
argument_list|(
name|fst
argument_list|,
name|w
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|w
operator|.
name|close
argument_list|()
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Wrote FST to out.dot"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|doPack
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Pack..."
argument_list|)
expr_stmt|;
name|fst
operator|=
name|fst
operator|.
name|pack
argument_list|(
literal|4
argument_list|,
literal|100000000
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"New size "
operator|+
name|fst
operator|.
name|sizeInBytes
argument_list|()
operator|+
literal|" bytes"
argument_list|)
expr_stmt|;
block|}
name|Directory
name|dir
init|=
name|FSDirectory
operator|.
name|open
argument_list|(
operator|new
name|File
argument_list|(
name|dirOut
argument_list|)
argument_list|)
decl_stmt|;
name|IndexOutput
name|out
init|=
name|dir
operator|.
name|createOutput
argument_list|(
literal|"fst.bin"
argument_list|,
name|IOContext
operator|.
name|DEFAULT
argument_list|)
decl_stmt|;
name|fst
operator|.
name|save
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|out
operator|.
name|close
argument_list|()
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Saved FST to fst.bin."
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|verify
condition|)
block|{
return|return;
block|}
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"\nNow verify..."
argument_list|)
expr_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
for|for
control|(
name|int
name|iter
init|=
literal|0
init|;
name|iter
operator|<
literal|2
condition|;
name|iter
operator|++
control|)
block|{
name|is
operator|.
name|close
argument_list|()
expr_stmt|;
name|is
operator|=
operator|new
name|BufferedReader
argument_list|(
operator|new
name|InputStreamReader
argument_list|(
operator|new
name|FileInputStream
argument_list|(
name|wordsFileIn
argument_list|)
argument_list|,
literal|"UTF-8"
argument_list|)
argument_list|,
literal|65536
argument_list|)
expr_stmt|;
name|ord
operator|=
literal|0
expr_stmt|;
name|tStart
operator|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
expr_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|String
name|w
init|=
name|is
operator|.
name|readLine
argument_list|()
decl_stmt|;
if|if
condition|(
name|w
operator|==
literal|null
condition|)
block|{
break|break;
block|}
name|toIntsRef
argument_list|(
name|w
argument_list|,
name|inputMode
argument_list|,
name|intsRef
argument_list|)
expr_stmt|;
if|if
condition|(
name|iter
operator|==
literal|0
condition|)
block|{
name|T
name|expected
init|=
name|getOutput
argument_list|(
name|intsRef
argument_list|,
name|ord
argument_list|)
decl_stmt|;
name|T
name|actual
init|=
name|Util
operator|.
name|get
argument_list|(
name|fst
argument_list|,
name|intsRef
argument_list|)
decl_stmt|;
if|if
condition|(
name|actual
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"unexpected null output on input="
operator|+
name|w
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|actual
operator|.
name|equals
argument_list|(
name|expected
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"wrong output (got "
operator|+
name|outputs
operator|.
name|outputToString
argument_list|(
name|actual
argument_list|)
operator|+
literal|" but expected "
operator|+
name|outputs
operator|.
name|outputToString
argument_list|(
name|expected
argument_list|)
operator|+
literal|") on input="
operator|+
name|w
argument_list|)
throw|;
block|}
block|}
else|else
block|{
comment|// Get by output
specifier|final
name|Long
name|output
init|=
operator|(
name|Long
operator|)
name|getOutput
argument_list|(
name|intsRef
argument_list|,
name|ord
argument_list|)
decl_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|final
name|IntsRef
name|actual
init|=
name|Util
operator|.
name|getByOutput
argument_list|(
operator|(
name|FST
argument_list|<
name|Long
argument_list|>
operator|)
name|fst
argument_list|,
name|output
operator|.
name|longValue
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|actual
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"unexpected null input from output="
operator|+
name|output
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|actual
operator|.
name|equals
argument_list|(
name|intsRef
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"wrong input (got "
operator|+
name|actual
operator|+
literal|" but expected "
operator|+
name|intsRef
operator|+
literal|" from output="
operator|+
name|output
argument_list|)
throw|;
block|}
block|}
name|ord
operator|++
expr_stmt|;
if|if
condition|(
name|ord
operator|%
literal|500000
operator|==
literal|0
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
operator|(
operator|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|-
name|tStart
operator|)
operator|/
literal|1000.0
operator|)
operator|+
literal|"s: "
operator|+
name|ord
operator|+
literal|"..."
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ord
operator|>=
name|limit
condition|)
block|{
break|break;
block|}
block|}
name|double
name|totSec
init|=
operator|(
operator|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|-
name|tStart
operator|)
operator|/
literal|1000.0
operator|)
decl_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Verify "
operator|+
operator|(
name|iter
operator|==
literal|1
condition|?
literal|"(by output) "
else|:
literal|""
operator|)
operator|+
literal|"took "
operator|+
name|totSec
operator|+
literal|" sec + ("
operator|+
call|(
name|int
call|)
argument_list|(
operator|(
name|totSec
operator|*
literal|1000000000
operator|/
name|ord
operator|)
argument_list|)
operator|+
literal|" nsec per lookup)"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|verifyByOutput
condition|)
block|{
break|break;
block|}
block|}
comment|// NOTE: comment out to profile lookup...
break|break;
block|}
block|}
finally|finally
block|{
name|is
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|// java -cp build/classes/test:build/classes/test-framework:build/classes/java:lib/junit-4.7.jar org.apache.lucene.util.fst.TestFSTs /x/tmp/allTerms3.txt out
DECL|method|main
specifier|public
specifier|static
name|void
name|main
parameter_list|(
name|String
index|[]
name|args
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|prune
init|=
literal|0
decl_stmt|;
name|int
name|limit
init|=
name|Integer
operator|.
name|MAX_VALUE
decl_stmt|;
name|int
name|inputMode
init|=
literal|0
decl_stmt|;
comment|// utf8
name|boolean
name|storeOrds
init|=
literal|false
decl_stmt|;
name|boolean
name|storeDocFreqs
init|=
literal|false
decl_stmt|;
name|boolean
name|verify
init|=
literal|true
decl_stmt|;
name|boolean
name|doPack
init|=
literal|false
decl_stmt|;
name|boolean
name|noArcArrays
init|=
literal|false
decl_stmt|;
name|String
name|wordsFileIn
init|=
literal|null
decl_stmt|;
name|String
name|dirOut
init|=
literal|null
decl_stmt|;
name|int
name|idx
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|idx
operator|<
name|args
operator|.
name|length
condition|)
block|{
if|if
condition|(
name|args
index|[
name|idx
index|]
operator|.
name|equals
argument_list|(
literal|"-prune"
argument_list|)
condition|)
block|{
name|prune
operator|=
name|Integer
operator|.
name|valueOf
argument_list|(
name|args
index|[
literal|1
operator|+
name|idx
index|]
argument_list|)
expr_stmt|;
name|idx
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|args
index|[
name|idx
index|]
operator|.
name|equals
argument_list|(
literal|"-limit"
argument_list|)
condition|)
block|{
name|limit
operator|=
name|Integer
operator|.
name|valueOf
argument_list|(
name|args
index|[
literal|1
operator|+
name|idx
index|]
argument_list|)
expr_stmt|;
name|idx
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|args
index|[
name|idx
index|]
operator|.
name|equals
argument_list|(
literal|"-utf8"
argument_list|)
condition|)
block|{
name|inputMode
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|args
index|[
name|idx
index|]
operator|.
name|equals
argument_list|(
literal|"-utf32"
argument_list|)
condition|)
block|{
name|inputMode
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|args
index|[
name|idx
index|]
operator|.
name|equals
argument_list|(
literal|"-docFreq"
argument_list|)
condition|)
block|{
name|storeDocFreqs
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|args
index|[
name|idx
index|]
operator|.
name|equals
argument_list|(
literal|"-noArcArrays"
argument_list|)
condition|)
block|{
name|noArcArrays
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|args
index|[
name|idx
index|]
operator|.
name|equals
argument_list|(
literal|"-ords"
argument_list|)
condition|)
block|{
name|storeOrds
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|args
index|[
name|idx
index|]
operator|.
name|equals
argument_list|(
literal|"-noverify"
argument_list|)
condition|)
block|{
name|verify
operator|=
literal|false
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|args
index|[
name|idx
index|]
operator|.
name|equals
argument_list|(
literal|"-pack"
argument_list|)
condition|)
block|{
name|doPack
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|args
index|[
name|idx
index|]
operator|.
name|startsWith
argument_list|(
literal|"-"
argument_list|)
condition|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"Unrecognized option: "
operator|+
name|args
index|[
name|idx
index|]
argument_list|)
expr_stmt|;
name|System
operator|.
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|wordsFileIn
operator|==
literal|null
condition|)
block|{
name|wordsFileIn
operator|=
name|args
index|[
name|idx
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dirOut
operator|==
literal|null
condition|)
block|{
name|dirOut
operator|=
name|args
index|[
name|idx
index|]
expr_stmt|;
block|}
else|else
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"Too many arguments, expected: input [output]"
argument_list|)
expr_stmt|;
name|System
operator|.
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|idx
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|wordsFileIn
operator|==
literal|null
condition|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"No input file."
argument_list|)
expr_stmt|;
name|System
operator|.
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|// ord benefits from share, docFreqs don't:
if|if
condition|(
name|storeOrds
operator|&&
name|storeDocFreqs
condition|)
block|{
comment|// Store both ord& docFreq:
specifier|final
name|PositiveIntOutputs
name|o1
init|=
name|PositiveIntOutputs
operator|.
name|getSingleton
argument_list|(
literal|true
argument_list|)
decl_stmt|;
specifier|final
name|PositiveIntOutputs
name|o2
init|=
name|PositiveIntOutputs
operator|.
name|getSingleton
argument_list|(
literal|false
argument_list|)
decl_stmt|;
specifier|final
name|PairOutputs
argument_list|<
name|Long
argument_list|,
name|Long
argument_list|>
name|outputs
init|=
operator|new
name|PairOutputs
argument_list|<
name|Long
argument_list|,
name|Long
argument_list|>
argument_list|(
name|o1
argument_list|,
name|o2
argument_list|)
decl_stmt|;
operator|new
name|VisitTerms
argument_list|<
name|PairOutputs
operator|.
name|Pair
argument_list|<
name|Long
argument_list|,
name|Long
argument_list|>
argument_list|>
argument_list|(
name|dirOut
argument_list|,
name|wordsFileIn
argument_list|,
name|inputMode
argument_list|,
name|prune
argument_list|,
name|outputs
argument_list|,
name|doPack
argument_list|,
name|noArcArrays
argument_list|)
block|{
name|Random
name|rand
decl_stmt|;
annotation|@
name|Override
specifier|public
name|PairOutputs
operator|.
name|Pair
argument_list|<
name|Long
argument_list|,
name|Long
argument_list|>
name|getOutput
parameter_list|(
name|IntsRef
name|input
parameter_list|,
name|int
name|ord
parameter_list|)
block|{
if|if
condition|(
name|ord
operator|==
literal|0
condition|)
block|{
name|rand
operator|=
operator|new
name|Random
argument_list|(
literal|17
argument_list|)
expr_stmt|;
block|}
return|return
name|outputs
operator|.
name|newPair
argument_list|(
operator|(
name|long
operator|)
name|ord
argument_list|,
operator|(
name|long
operator|)
name|_TestUtil
operator|.
name|nextInt
argument_list|(
name|rand
argument_list|,
literal|1
argument_list|,
literal|5000
argument_list|)
argument_list|)
return|;
block|}
block|}
operator|.
name|run
argument_list|(
name|limit
argument_list|,
name|verify
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|storeOrds
condition|)
block|{
comment|// Store only ords
specifier|final
name|PositiveIntOutputs
name|outputs
init|=
name|PositiveIntOutputs
operator|.
name|getSingleton
argument_list|(
literal|true
argument_list|)
decl_stmt|;
operator|new
name|VisitTerms
argument_list|<
name|Long
argument_list|>
argument_list|(
name|dirOut
argument_list|,
name|wordsFileIn
argument_list|,
name|inputMode
argument_list|,
name|prune
argument_list|,
name|outputs
argument_list|,
name|doPack
argument_list|,
name|noArcArrays
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|Long
name|getOutput
parameter_list|(
name|IntsRef
name|input
parameter_list|,
name|int
name|ord
parameter_list|)
block|{
return|return
operator|(
name|long
operator|)
name|ord
return|;
block|}
block|}
operator|.
name|run
argument_list|(
name|limit
argument_list|,
name|verify
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|storeDocFreqs
condition|)
block|{
comment|// Store only docFreq
specifier|final
name|PositiveIntOutputs
name|outputs
init|=
name|PositiveIntOutputs
operator|.
name|getSingleton
argument_list|(
literal|false
argument_list|)
decl_stmt|;
operator|new
name|VisitTerms
argument_list|<
name|Long
argument_list|>
argument_list|(
name|dirOut
argument_list|,
name|wordsFileIn
argument_list|,
name|inputMode
argument_list|,
name|prune
argument_list|,
name|outputs
argument_list|,
name|doPack
argument_list|,
name|noArcArrays
argument_list|)
block|{
name|Random
name|rand
decl_stmt|;
annotation|@
name|Override
specifier|public
name|Long
name|getOutput
parameter_list|(
name|IntsRef
name|input
parameter_list|,
name|int
name|ord
parameter_list|)
block|{
if|if
condition|(
name|ord
operator|==
literal|0
condition|)
block|{
name|rand
operator|=
operator|new
name|Random
argument_list|(
literal|17
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|long
operator|)
name|_TestUtil
operator|.
name|nextInt
argument_list|(
name|rand
argument_list|,
literal|1
argument_list|,
literal|5000
argument_list|)
return|;
block|}
block|}
operator|.
name|run
argument_list|(
name|limit
argument_list|,
name|verify
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Store nothing
specifier|final
name|NoOutputs
name|outputs
init|=
name|NoOutputs
operator|.
name|getSingleton
argument_list|()
decl_stmt|;
specifier|final
name|Object
name|NO_OUTPUT
init|=
name|outputs
operator|.
name|getNoOutput
argument_list|()
decl_stmt|;
operator|new
name|VisitTerms
argument_list|<
name|Object
argument_list|>
argument_list|(
name|dirOut
argument_list|,
name|wordsFileIn
argument_list|,
name|inputMode
argument_list|,
name|prune
argument_list|,
name|outputs
argument_list|,
name|doPack
argument_list|,
name|noArcArrays
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|Object
name|getOutput
parameter_list|(
name|IntsRef
name|input
parameter_list|,
name|int
name|ord
parameter_list|)
block|{
return|return
name|NO_OUTPUT
return|;
block|}
block|}
operator|.
name|run
argument_list|(
name|limit
argument_list|,
name|verify
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|testSingleString
specifier|public
name|void
name|testSingleString
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|Outputs
argument_list|<
name|Object
argument_list|>
name|outputs
init|=
name|NoOutputs
operator|.
name|getSingleton
argument_list|()
decl_stmt|;
specifier|final
name|Builder
argument_list|<
name|Object
argument_list|>
name|b
init|=
operator|new
name|Builder
argument_list|<
name|Object
argument_list|>
argument_list|(
name|FST
operator|.
name|INPUT_TYPE
operator|.
name|BYTE1
argument_list|,
name|outputs
argument_list|)
decl_stmt|;
name|b
operator|.
name|add
argument_list|(
name|Util
operator|.
name|toIntsRef
argument_list|(
operator|new
name|BytesRef
argument_list|(
literal|"foobar"
argument_list|)
argument_list|,
operator|new
name|IntsRef
argument_list|()
argument_list|)
argument_list|,
name|outputs
operator|.
name|getNoOutput
argument_list|()
argument_list|)
expr_stmt|;
specifier|final
name|BytesRefFSTEnum
argument_list|<
name|Object
argument_list|>
name|fstEnum
init|=
operator|new
name|BytesRefFSTEnum
argument_list|<
name|Object
argument_list|>
argument_list|(
name|b
operator|.
name|finish
argument_list|()
argument_list|)
decl_stmt|;
name|assertNull
argument_list|(
name|fstEnum
operator|.
name|seekFloor
argument_list|(
operator|new
name|BytesRef
argument_list|(
literal|"foo"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|assertNull
argument_list|(
name|fstEnum
operator|.
name|seekCeil
argument_list|(
operator|new
name|BytesRef
argument_list|(
literal|"foobaz"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/*   public void testTrivial() throws Exception {      // Get outputs -- passing true means FST will share     // (delta code) the outputs.  This should result in     // smaller FST if the outputs grow monotonically.  But     // if numbers are "random", false should give smaller     // final size:     final NoOutputs outputs = NoOutputs.getSingleton();      String[] strings = new String[] {"station", "commotion", "elation", "elastic", "plastic", "stop", "ftop", "ftation", "stat"};      final Builder<Object> builder = new Builder<Object>(FST.INPUT_TYPE.BYTE1,                                                         0, 0,                                                         true,                                                         true,                                                         Integer.MAX_VALUE,                                                         outputs,                                                         null,                                                         true);     Arrays.sort(strings);     final IntsRef scratch = new IntsRef();     for(String s : strings) {       builder.add(Util.toIntsRef(new BytesRef(s), scratch), outputs.getNoOutput());     }     final FST<Object> fst = builder.finish();     System.out.println("DOT before rewrite");     Writer w = new OutputStreamWriter(new FileOutputStream("/mnt/scratch/before.dot"));     Util.toDot(fst, w, false, false);     w.close();      final FST<Object> rewrite = new FST<Object>(fst, 1, 100);      System.out.println("DOT after rewrite");     w = new OutputStreamWriter(new FileOutputStream("/mnt/scratch/after.dot"));     Util.toDot(rewrite, w, false, false);     w.close();   }   */
DECL|method|testSimple
specifier|public
name|void
name|testSimple
parameter_list|()
throws|throws
name|Exception
block|{
comment|// Get outputs -- passing true means FST will share
comment|// (delta code) the outputs.  This should result in
comment|// smaller FST if the outputs grow monotonically.  But
comment|// if numbers are "random", false should give smaller
comment|// final size:
specifier|final
name|PositiveIntOutputs
name|outputs
init|=
name|PositiveIntOutputs
operator|.
name|getSingleton
argument_list|(
literal|true
argument_list|)
decl_stmt|;
comment|// Build an FST mapping BytesRef -> Long
specifier|final
name|Builder
argument_list|<
name|Long
argument_list|>
name|builder
init|=
operator|new
name|Builder
argument_list|<
name|Long
argument_list|>
argument_list|(
name|FST
operator|.
name|INPUT_TYPE
operator|.
name|BYTE1
argument_list|,
name|outputs
argument_list|)
decl_stmt|;
specifier|final
name|BytesRef
name|a
init|=
operator|new
name|BytesRef
argument_list|(
literal|"a"
argument_list|)
decl_stmt|;
specifier|final
name|BytesRef
name|b
init|=
operator|new
name|BytesRef
argument_list|(
literal|"b"
argument_list|)
decl_stmt|;
specifier|final
name|BytesRef
name|c
init|=
operator|new
name|BytesRef
argument_list|(
literal|"c"
argument_list|)
decl_stmt|;
name|builder
operator|.
name|add
argument_list|(
name|Util
operator|.
name|toIntsRef
argument_list|(
name|a
argument_list|,
operator|new
name|IntsRef
argument_list|()
argument_list|)
argument_list|,
literal|17L
argument_list|)
expr_stmt|;
name|builder
operator|.
name|add
argument_list|(
name|Util
operator|.
name|toIntsRef
argument_list|(
name|b
argument_list|,
operator|new
name|IntsRef
argument_list|()
argument_list|)
argument_list|,
literal|42L
argument_list|)
expr_stmt|;
name|builder
operator|.
name|add
argument_list|(
name|Util
operator|.
name|toIntsRef
argument_list|(
name|c
argument_list|,
operator|new
name|IntsRef
argument_list|()
argument_list|)
argument_list|,
literal|13824324872317238L
argument_list|)
expr_stmt|;
specifier|final
name|FST
argument_list|<
name|Long
argument_list|>
name|fst
init|=
name|builder
operator|.
name|finish
argument_list|()
decl_stmt|;
name|assertEquals
argument_list|(
literal|13824324872317238L
argument_list|,
operator|(
name|long
operator|)
name|Util
operator|.
name|get
argument_list|(
name|fst
argument_list|,
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|42
argument_list|,
operator|(
name|long
operator|)
name|Util
operator|.
name|get
argument_list|(
name|fst
argument_list|,
name|b
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|17
argument_list|,
operator|(
name|long
operator|)
name|Util
operator|.
name|get
argument_list|(
name|fst
argument_list|,
name|a
argument_list|)
argument_list|)
expr_stmt|;
name|BytesRefFSTEnum
argument_list|<
name|Long
argument_list|>
name|fstEnum
init|=
operator|new
name|BytesRefFSTEnum
argument_list|<
name|Long
argument_list|>
argument_list|(
name|fst
argument_list|)
decl_stmt|;
name|BytesRefFSTEnum
operator|.
name|InputOutput
argument_list|<
name|Long
argument_list|>
name|seekResult
decl_stmt|;
name|seekResult
operator|=
name|fstEnum
operator|.
name|seekFloor
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|assertNotNull
argument_list|(
name|seekResult
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|17
argument_list|,
operator|(
name|long
operator|)
name|seekResult
operator|.
name|output
argument_list|)
expr_stmt|;
comment|// goes to a
name|seekResult
operator|=
name|fstEnum
operator|.
name|seekFloor
argument_list|(
operator|new
name|BytesRef
argument_list|(
literal|"aa"
argument_list|)
argument_list|)
expr_stmt|;
name|assertNotNull
argument_list|(
name|seekResult
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|17
argument_list|,
operator|(
name|long
operator|)
name|seekResult
operator|.
name|output
argument_list|)
expr_stmt|;
comment|// goes to b
name|seekResult
operator|=
name|fstEnum
operator|.
name|seekCeil
argument_list|(
operator|new
name|BytesRef
argument_list|(
literal|"aa"
argument_list|)
argument_list|)
expr_stmt|;
name|assertNotNull
argument_list|(
name|seekResult
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|b
argument_list|,
name|seekResult
operator|.
name|input
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|42
argument_list|,
operator|(
name|long
operator|)
name|seekResult
operator|.
name|output
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|Util
operator|.
name|toIntsRef
argument_list|(
operator|new
name|BytesRef
argument_list|(
literal|"c"
argument_list|)
argument_list|,
operator|new
name|IntsRef
argument_list|()
argument_list|)
argument_list|,
name|Util
operator|.
name|getByOutput
argument_list|(
name|fst
argument_list|,
literal|13824324872317238L
argument_list|)
argument_list|)
expr_stmt|;
name|assertNull
argument_list|(
name|Util
operator|.
name|getByOutput
argument_list|(
name|fst
argument_list|,
literal|47
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|Util
operator|.
name|toIntsRef
argument_list|(
operator|new
name|BytesRef
argument_list|(
literal|"b"
argument_list|)
argument_list|,
operator|new
name|IntsRef
argument_list|()
argument_list|)
argument_list|,
name|Util
operator|.
name|getByOutput
argument_list|(
name|fst
argument_list|,
literal|42
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|Util
operator|.
name|toIntsRef
argument_list|(
operator|new
name|BytesRef
argument_list|(
literal|"a"
argument_list|)
argument_list|,
operator|new
name|IntsRef
argument_list|()
argument_list|)
argument_list|,
name|Util
operator|.
name|getByOutput
argument_list|(
name|fst
argument_list|,
literal|17
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|testPrimaryKeys
specifier|public
name|void
name|testPrimaryKeys
parameter_list|()
throws|throws
name|Exception
block|{
name|Directory
name|dir
init|=
name|newDirectory
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|cycle
init|=
literal|0
init|;
name|cycle
operator|<
literal|2
condition|;
name|cycle
operator|++
control|)
block|{
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"TEST: cycle="
operator|+
name|cycle
argument_list|)
expr_stmt|;
block|}
name|RandomIndexWriter
name|w
init|=
operator|new
name|RandomIndexWriter
argument_list|(
name|random
argument_list|,
name|dir
argument_list|,
name|newIndexWriterConfig
argument_list|(
name|TEST_VERSION_CURRENT
argument_list|,
operator|new
name|MockAnalyzer
argument_list|(
name|random
argument_list|)
argument_list|)
operator|.
name|setOpenMode
argument_list|(
name|IndexWriterConfig
operator|.
name|OpenMode
operator|.
name|CREATE
argument_list|)
argument_list|)
decl_stmt|;
name|Document
name|doc
init|=
operator|new
name|Document
argument_list|()
decl_stmt|;
name|Field
name|idField
init|=
name|newField
argument_list|(
literal|"id"
argument_list|,
literal|""
argument_list|,
name|StringField
operator|.
name|TYPE_UNSTORED
argument_list|)
decl_stmt|;
name|doc
operator|.
name|add
argument_list|(
name|idField
argument_list|)
expr_stmt|;
specifier|final
name|int
name|NUM_IDS
init|=
name|atLeast
argument_list|(
literal|200
argument_list|)
decl_stmt|;
comment|//final int NUM_IDS = (int) (377 * (1.0+random.nextDouble()));
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"TEST: NUM_IDS="
operator|+
name|NUM_IDS
argument_list|)
expr_stmt|;
block|}
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|allIDs
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|id
init|=
literal|0
init|;
name|id
operator|<
name|NUM_IDS
condition|;
name|id
operator|++
control|)
block|{
name|String
name|idString
decl_stmt|;
if|if
condition|(
name|cycle
operator|==
literal|0
condition|)
block|{
comment|// PKs are assigned sequentially
name|idString
operator|=
name|String
operator|.
name|format
argument_list|(
literal|"%07d"
argument_list|,
name|id
argument_list|)
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
literal|true
condition|)
block|{
specifier|final
name|String
name|s
init|=
name|Long
operator|.
name|toString
argument_list|(
name|random
operator|.
name|nextLong
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|allIDs
operator|.
name|contains
argument_list|(
name|s
argument_list|)
condition|)
block|{
name|idString
operator|=
name|s
expr_stmt|;
break|break;
block|}
block|}
block|}
name|allIDs
operator|.
name|add
argument_list|(
name|idString
argument_list|)
expr_stmt|;
name|idField
operator|.
name|setValue
argument_list|(
name|idString
argument_list|)
expr_stmt|;
name|w
operator|.
name|addDocument
argument_list|(
name|doc
argument_list|)
expr_stmt|;
block|}
comment|//w.forceMerge(1);
comment|// turn writer into reader:
specifier|final
name|IndexReader
name|r
init|=
name|w
operator|.
name|getReader
argument_list|()
decl_stmt|;
specifier|final
name|IndexSearcher
name|s
init|=
operator|new
name|IndexSearcher
argument_list|(
name|r
argument_list|)
decl_stmt|;
name|w
operator|.
name|close
argument_list|()
expr_stmt|;
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|allIDsList
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|(
name|allIDs
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|sortedAllIDsList
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|(
name|allIDsList
argument_list|)
decl_stmt|;
name|Collections
operator|.
name|sort
argument_list|(
name|sortedAllIDsList
argument_list|)
expr_stmt|;
comment|// Sprinkle in some non-existent PKs:
name|Set
argument_list|<
name|String
argument_list|>
name|outOfBounds
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|idx
init|=
literal|0
init|;
name|idx
operator|<
name|NUM_IDS
operator|/
literal|10
condition|;
name|idx
operator|++
control|)
block|{
name|String
name|idString
decl_stmt|;
if|if
condition|(
name|cycle
operator|==
literal|0
condition|)
block|{
name|idString
operator|=
name|String
operator|.
name|format
argument_list|(
literal|"%07d"
argument_list|,
operator|(
name|NUM_IDS
operator|+
name|idx
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
literal|true
condition|)
block|{
name|idString
operator|=
name|Long
operator|.
name|toString
argument_list|(
name|random
operator|.
name|nextLong
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|allIDs
operator|.
name|contains
argument_list|(
name|idString
argument_list|)
condition|)
block|{
break|break;
block|}
block|}
block|}
name|outOfBounds
operator|.
name|add
argument_list|(
name|idString
argument_list|)
expr_stmt|;
name|allIDsList
operator|.
name|add
argument_list|(
name|idString
argument_list|)
expr_stmt|;
block|}
comment|// Verify w/ TermQuery
for|for
control|(
name|int
name|iter
init|=
literal|0
init|;
name|iter
operator|<
literal|2
operator|*
name|NUM_IDS
condition|;
name|iter
operator|++
control|)
block|{
specifier|final
name|String
name|id
init|=
name|allIDsList
operator|.
name|get
argument_list|(
name|random
operator|.
name|nextInt
argument_list|(
name|allIDsList
operator|.
name|size
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|boolean
name|exists
init|=
operator|!
name|outOfBounds
operator|.
name|contains
argument_list|(
name|id
argument_list|)
decl_stmt|;
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"TEST: TermQuery "
operator|+
operator|(
name|exists
condition|?
literal|""
else|:
literal|"non-exist "
operator|)
operator|+
literal|" id="
operator|+
name|id
argument_list|)
expr_stmt|;
block|}
name|assertEquals
argument_list|(
operator|(
name|exists
condition|?
literal|""
else|:
literal|"non-exist "
operator|)
operator|+
literal|"id="
operator|+
name|id
argument_list|,
name|exists
condition|?
literal|1
else|:
literal|0
argument_list|,
name|s
operator|.
name|search
argument_list|(
operator|new
name|TermQuery
argument_list|(
operator|new
name|Term
argument_list|(
literal|"id"
argument_list|,
name|id
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|.
name|totalHits
argument_list|)
expr_stmt|;
block|}
comment|// Verify w/ MultiTermsEnum
specifier|final
name|TermsEnum
name|termsEnum
init|=
name|MultiFields
operator|.
name|getTerms
argument_list|(
name|r
argument_list|,
literal|"id"
argument_list|)
operator|.
name|iterator
argument_list|(
literal|null
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|iter
init|=
literal|0
init|;
name|iter
operator|<
literal|2
operator|*
name|NUM_IDS
condition|;
name|iter
operator|++
control|)
block|{
specifier|final
name|String
name|id
decl_stmt|;
specifier|final
name|String
name|nextID
decl_stmt|;
specifier|final
name|boolean
name|exists
decl_stmt|;
if|if
condition|(
name|random
operator|.
name|nextBoolean
argument_list|()
condition|)
block|{
name|id
operator|=
name|allIDsList
operator|.
name|get
argument_list|(
name|random
operator|.
name|nextInt
argument_list|(
name|allIDsList
operator|.
name|size
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|exists
operator|=
operator|!
name|outOfBounds
operator|.
name|contains
argument_list|(
name|id
argument_list|)
expr_stmt|;
name|nextID
operator|=
literal|null
expr_stmt|;
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"TEST: exactOnly "
operator|+
operator|(
name|exists
condition|?
literal|""
else|:
literal|"non-exist "
operator|)
operator|+
literal|"id="
operator|+
name|id
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// Pick ID between two IDs:
name|exists
operator|=
literal|false
expr_stmt|;
specifier|final
name|int
name|idv
init|=
name|random
operator|.
name|nextInt
argument_list|(
name|NUM_IDS
operator|-
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|cycle
operator|==
literal|0
condition|)
block|{
name|id
operator|=
name|String
operator|.
name|format
argument_list|(
literal|"%07da"
argument_list|,
name|idv
argument_list|)
expr_stmt|;
name|nextID
operator|=
name|String
operator|.
name|format
argument_list|(
literal|"%07d"
argument_list|,
name|idv
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|id
operator|=
name|sortedAllIDsList
operator|.
name|get
argument_list|(
name|idv
argument_list|)
operator|+
literal|"a"
expr_stmt|;
name|nextID
operator|=
name|sortedAllIDsList
operator|.
name|get
argument_list|(
name|idv
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"TEST: not exactOnly id="
operator|+
name|id
operator|+
literal|" nextID="
operator|+
name|nextID
argument_list|)
expr_stmt|;
block|}
block|}
specifier|final
name|boolean
name|useCache
init|=
name|random
operator|.
name|nextBoolean
argument_list|()
decl_stmt|;
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"  useCache="
operator|+
name|useCache
argument_list|)
expr_stmt|;
block|}
specifier|final
name|TermsEnum
operator|.
name|SeekStatus
name|status
decl_stmt|;
if|if
condition|(
name|nextID
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|termsEnum
operator|.
name|seekExact
argument_list|(
operator|new
name|BytesRef
argument_list|(
name|id
argument_list|)
argument_list|,
name|useCache
argument_list|)
condition|)
block|{
name|status
operator|=
name|TermsEnum
operator|.
name|SeekStatus
operator|.
name|FOUND
expr_stmt|;
block|}
else|else
block|{
name|status
operator|=
name|TermsEnum
operator|.
name|SeekStatus
operator|.
name|NOT_FOUND
expr_stmt|;
block|}
block|}
else|else
block|{
name|status
operator|=
name|termsEnum
operator|.
name|seekCeil
argument_list|(
operator|new
name|BytesRef
argument_list|(
name|id
argument_list|)
argument_list|,
name|useCache
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nextID
operator|!=
literal|null
condition|)
block|{
name|assertEquals
argument_list|(
name|TermsEnum
operator|.
name|SeekStatus
operator|.
name|NOT_FOUND
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"expected="
operator|+
name|nextID
operator|+
literal|" actual="
operator|+
name|termsEnum
operator|.
name|term
argument_list|()
operator|.
name|utf8ToString
argument_list|()
argument_list|,
operator|new
name|BytesRef
argument_list|(
name|nextID
argument_list|)
argument_list|,
name|termsEnum
operator|.
name|term
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|exists
condition|)
block|{
name|assertTrue
argument_list|(
name|status
operator|==
name|TermsEnum
operator|.
name|SeekStatus
operator|.
name|NOT_FOUND
operator|||
name|status
operator|==
name|TermsEnum
operator|.
name|SeekStatus
operator|.
name|END
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|assertEquals
argument_list|(
name|TermsEnum
operator|.
name|SeekStatus
operator|.
name|FOUND
argument_list|,
name|status
argument_list|)
expr_stmt|;
block|}
block|}
name|r
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
name|dir
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
DECL|method|testRandomTermLookup
specifier|public
name|void
name|testRandomTermLookup
parameter_list|()
throws|throws
name|Exception
block|{
name|Directory
name|dir
init|=
name|newDirectory
argument_list|()
decl_stmt|;
name|RandomIndexWriter
name|w
init|=
operator|new
name|RandomIndexWriter
argument_list|(
name|random
argument_list|,
name|dir
argument_list|,
name|newIndexWriterConfig
argument_list|(
name|TEST_VERSION_CURRENT
argument_list|,
operator|new
name|MockAnalyzer
argument_list|(
name|random
argument_list|)
argument_list|)
operator|.
name|setOpenMode
argument_list|(
name|IndexWriterConfig
operator|.
name|OpenMode
operator|.
name|CREATE
argument_list|)
argument_list|)
decl_stmt|;
name|Document
name|doc
init|=
operator|new
name|Document
argument_list|()
decl_stmt|;
name|Field
name|f
init|=
name|newField
argument_list|(
literal|"field"
argument_list|,
literal|""
argument_list|,
name|StringField
operator|.
name|TYPE_UNSTORED
argument_list|)
decl_stmt|;
name|doc
operator|.
name|add
argument_list|(
name|f
argument_list|)
expr_stmt|;
specifier|final
name|int
name|NUM_TERMS
init|=
call|(
name|int
call|)
argument_list|(
literal|1000
operator|*
name|RANDOM_MULTIPLIER
operator|*
operator|(
literal|1
operator|+
name|random
operator|.
name|nextDouble
argument_list|()
operator|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"TEST: NUM_TERMS="
operator|+
name|NUM_TERMS
argument_list|)
expr_stmt|;
block|}
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|allTerms
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
while|while
condition|(
name|allTerms
operator|.
name|size
argument_list|()
operator|<
name|NUM_TERMS
condition|)
block|{
name|allTerms
operator|.
name|add
argument_list|(
name|simpleRandomString
argument_list|(
name|random
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|String
name|term
range|:
name|allTerms
control|)
block|{
name|f
operator|.
name|setValue
argument_list|(
name|term
argument_list|)
expr_stmt|;
name|w
operator|.
name|addDocument
argument_list|(
name|doc
argument_list|)
expr_stmt|;
block|}
comment|// turn writer into reader:
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"TEST: get reader"
argument_list|)
expr_stmt|;
block|}
name|IndexReader
name|r
init|=
name|w
operator|.
name|getReader
argument_list|()
decl_stmt|;
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"TEST: got reader="
operator|+
name|r
argument_list|)
expr_stmt|;
block|}
name|IndexSearcher
name|s
init|=
operator|new
name|IndexSearcher
argument_list|(
name|r
argument_list|)
decl_stmt|;
name|w
operator|.
name|close
argument_list|()
expr_stmt|;
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|allTermsList
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|(
name|allTerms
argument_list|)
decl_stmt|;
name|Collections
operator|.
name|shuffle
argument_list|(
name|allTermsList
argument_list|,
name|random
argument_list|)
expr_stmt|;
comment|// verify exact lookup
for|for
control|(
name|String
name|term
range|:
name|allTermsList
control|)
block|{
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"TEST: term="
operator|+
name|term
argument_list|)
expr_stmt|;
block|}
name|assertEquals
argument_list|(
literal|"term="
operator|+
name|term
argument_list|,
literal|1
argument_list|,
name|s
operator|.
name|search
argument_list|(
operator|new
name|TermQuery
argument_list|(
operator|new
name|Term
argument_list|(
literal|"field"
argument_list|,
name|term
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|.
name|totalHits
argument_list|)
expr_stmt|;
block|}
name|r
operator|.
name|close
argument_list|()
expr_stmt|;
name|dir
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
comment|/**    * Test state expansion (array format) on close-to-root states. Creates    * synthetic input that has one expanded state on each level.    *     * @see "https://issues.apache.org/jira/browse/LUCENE-2933"     */
DECL|method|testExpandedCloseToRoot
specifier|public
name|void
name|testExpandedCloseToRoot
parameter_list|()
throws|throws
name|Exception
block|{
class|class
name|SyntheticData
block|{
name|FST
argument_list|<
name|Object
argument_list|>
name|compile
parameter_list|(
name|String
index|[]
name|lines
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|NoOutputs
name|outputs
init|=
name|NoOutputs
operator|.
name|getSingleton
argument_list|()
decl_stmt|;
specifier|final
name|Object
name|nothing
init|=
name|outputs
operator|.
name|getNoOutput
argument_list|()
decl_stmt|;
specifier|final
name|Builder
argument_list|<
name|Object
argument_list|>
name|b
init|=
operator|new
name|Builder
argument_list|<
name|Object
argument_list|>
argument_list|(
name|FST
operator|.
name|INPUT_TYPE
operator|.
name|BYTE1
argument_list|,
name|outputs
argument_list|)
decl_stmt|;
name|int
name|line
init|=
literal|0
decl_stmt|;
specifier|final
name|BytesRef
name|term
init|=
operator|new
name|BytesRef
argument_list|()
decl_stmt|;
specifier|final
name|IntsRef
name|scratchIntsRef
init|=
operator|new
name|IntsRef
argument_list|()
decl_stmt|;
while|while
condition|(
name|line
operator|<
name|lines
operator|.
name|length
condition|)
block|{
name|String
name|w
init|=
name|lines
index|[
name|line
operator|++
index|]
decl_stmt|;
if|if
condition|(
name|w
operator|==
literal|null
condition|)
block|{
break|break;
block|}
name|term
operator|.
name|copyChars
argument_list|(
name|w
argument_list|)
expr_stmt|;
name|b
operator|.
name|add
argument_list|(
name|Util
operator|.
name|toIntsRef
argument_list|(
name|term
argument_list|,
name|scratchIntsRef
argument_list|)
argument_list|,
name|nothing
argument_list|)
expr_stmt|;
block|}
return|return
name|b
operator|.
name|finish
argument_list|()
return|;
block|}
name|void
name|generate
parameter_list|(
name|ArrayList
argument_list|<
name|String
argument_list|>
name|out
parameter_list|,
name|StringBuilder
name|b
parameter_list|,
name|char
name|from
parameter_list|,
name|char
name|to
parameter_list|,
name|int
name|depth
parameter_list|)
block|{
if|if
condition|(
name|depth
operator|==
literal|0
operator|||
name|from
operator|==
name|to
condition|)
block|{
name|String
name|seq
init|=
name|b
operator|.
name|toString
argument_list|()
operator|+
literal|"_"
operator|+
name|out
operator|.
name|size
argument_list|()
operator|+
literal|"_end"
decl_stmt|;
name|out
operator|.
name|add
argument_list|(
name|seq
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|char
name|c
init|=
name|from
init|;
name|c
operator|<=
name|to
condition|;
name|c
operator|++
control|)
block|{
name|b
operator|.
name|append
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|generate
argument_list|(
name|out
argument_list|,
name|b
argument_list|,
name|from
argument_list|,
name|c
operator|==
name|to
condition|?
name|to
else|:
name|from
argument_list|,
name|depth
operator|-
literal|1
argument_list|)
expr_stmt|;
name|b
operator|.
name|deleteCharAt
argument_list|(
name|b
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|public
name|int
name|verifyStateAndBelow
parameter_list|(
name|FST
argument_list|<
name|Object
argument_list|>
name|fst
parameter_list|,
name|Arc
argument_list|<
name|Object
argument_list|>
name|arc
parameter_list|,
name|int
name|depth
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|fst
operator|.
name|targetHasArcs
argument_list|(
name|arc
argument_list|)
condition|)
block|{
name|int
name|childCount
init|=
literal|0
decl_stmt|;
for|for
control|(
name|arc
operator|=
name|fst
operator|.
name|readFirstTargetArc
argument_list|(
name|arc
argument_list|,
name|arc
argument_list|)
init|;
condition|;
name|arc
operator|=
name|fst
operator|.
name|readNextArc
argument_list|(
name|arc
argument_list|)
operator|,
name|childCount
operator|++
control|)
block|{
name|boolean
name|expanded
init|=
name|fst
operator|.
name|isExpandedTarget
argument_list|(
name|arc
argument_list|)
decl_stmt|;
name|int
name|children
init|=
name|verifyStateAndBelow
argument_list|(
name|fst
argument_list|,
operator|new
name|FST
operator|.
name|Arc
argument_list|<
name|Object
argument_list|>
argument_list|()
operator|.
name|copyFrom
argument_list|(
name|arc
argument_list|)
argument_list|,
name|depth
operator|+
literal|1
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|expanded
argument_list|,
operator|(
name|depth
operator|<=
name|FST
operator|.
name|FIXED_ARRAY_SHALLOW_DISTANCE
operator|&&
name|children
operator|>=
name|FST
operator|.
name|FIXED_ARRAY_NUM_ARCS_SHALLOW
operator|)
operator|||
name|children
operator|>=
name|FST
operator|.
name|FIXED_ARRAY_NUM_ARCS_DEEP
argument_list|)
expr_stmt|;
if|if
condition|(
name|arc
operator|.
name|isLast
argument_list|()
condition|)
break|break;
block|}
return|return
name|childCount
return|;
block|}
return|return
literal|0
return|;
block|}
block|}
comment|// Sanity check.
name|assertTrue
argument_list|(
name|FST
operator|.
name|FIXED_ARRAY_NUM_ARCS_SHALLOW
operator|<
name|FST
operator|.
name|FIXED_ARRAY_NUM_ARCS_DEEP
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|FST
operator|.
name|FIXED_ARRAY_SHALLOW_DISTANCE
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|SyntheticData
name|s
init|=
operator|new
name|SyntheticData
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|String
argument_list|>
name|out
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|StringBuilder
name|b
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|s
operator|.
name|generate
argument_list|(
name|out
argument_list|,
name|b
argument_list|,
literal|'a'
argument_list|,
literal|'i'
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|String
index|[]
name|input
init|=
name|out
operator|.
name|toArray
argument_list|(
operator|new
name|String
index|[
name|out
operator|.
name|size
argument_list|()
index|]
argument_list|)
decl_stmt|;
name|Arrays
operator|.
name|sort
argument_list|(
name|input
argument_list|)
expr_stmt|;
name|FST
argument_list|<
name|Object
argument_list|>
name|fst
init|=
name|s
operator|.
name|compile
argument_list|(
name|input
argument_list|)
decl_stmt|;
name|FST
operator|.
name|Arc
argument_list|<
name|Object
argument_list|>
name|arc
init|=
name|fst
operator|.
name|getFirstArc
argument_list|(
operator|new
name|FST
operator|.
name|Arc
argument_list|<
name|Object
argument_list|>
argument_list|()
argument_list|)
decl_stmt|;
name|s
operator|.
name|verifyStateAndBelow
argument_list|(
name|fst
argument_list|,
name|arc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
DECL|method|testFinalOutputOnEndState
specifier|public
name|void
name|testFinalOutputOnEndState
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|PositiveIntOutputs
name|outputs
init|=
name|PositiveIntOutputs
operator|.
name|getSingleton
argument_list|(
literal|true
argument_list|)
decl_stmt|;
specifier|final
name|Builder
argument_list|<
name|Long
argument_list|>
name|builder
init|=
operator|new
name|Builder
argument_list|<
name|Long
argument_list|>
argument_list|(
name|FST
operator|.
name|INPUT_TYPE
operator|.
name|BYTE4
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|true
argument_list|,
literal|true
argument_list|,
name|Integer
operator|.
name|MAX_VALUE
argument_list|,
name|outputs
argument_list|,
literal|null
argument_list|,
name|random
operator|.
name|nextBoolean
argument_list|()
argument_list|)
decl_stmt|;
name|builder
operator|.
name|add
argument_list|(
name|Util
operator|.
name|toUTF32
argument_list|(
literal|"stat"
argument_list|,
operator|new
name|IntsRef
argument_list|()
argument_list|)
argument_list|,
literal|17L
argument_list|)
expr_stmt|;
name|builder
operator|.
name|add
argument_list|(
name|Util
operator|.
name|toUTF32
argument_list|(
literal|"station"
argument_list|,
operator|new
name|IntsRef
argument_list|()
argument_list|)
argument_list|,
literal|10L
argument_list|)
expr_stmt|;
specifier|final
name|FST
argument_list|<
name|Long
argument_list|>
name|fst
init|=
name|builder
operator|.
name|finish
argument_list|()
decl_stmt|;
comment|//Writer w = new OutputStreamWriter(new FileOutputStream("/x/tmp3/out.dot"));
name|StringWriter
name|w
init|=
operator|new
name|StringWriter
argument_list|()
decl_stmt|;
name|Util
operator|.
name|toDot
argument_list|(
name|fst
argument_list|,
name|w
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|w
operator|.
name|close
argument_list|()
expr_stmt|;
comment|//System.out.println(w.toString());
name|assertTrue
argument_list|(
name|w
operator|.
name|toString
argument_list|()
operator|.
name|indexOf
argument_list|(
literal|"label=\"t/[7]\""
argument_list|)
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
DECL|method|testInternalFinalState
specifier|public
name|void
name|testInternalFinalState
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|PositiveIntOutputs
name|outputs
init|=
name|PositiveIntOutputs
operator|.
name|getSingleton
argument_list|(
literal|true
argument_list|)
decl_stmt|;
specifier|final
name|boolean
name|willRewrite
init|=
name|random
operator|.
name|nextBoolean
argument_list|()
decl_stmt|;
specifier|final
name|Builder
argument_list|<
name|Long
argument_list|>
name|builder
init|=
operator|new
name|Builder
argument_list|<
name|Long
argument_list|>
argument_list|(
name|FST
operator|.
name|INPUT_TYPE
operator|.
name|BYTE1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|true
argument_list|,
literal|true
argument_list|,
name|Integer
operator|.
name|MAX_VALUE
argument_list|,
name|outputs
argument_list|,
literal|null
argument_list|,
name|willRewrite
argument_list|)
decl_stmt|;
name|builder
operator|.
name|add
argument_list|(
name|Util
operator|.
name|toIntsRef
argument_list|(
operator|new
name|BytesRef
argument_list|(
literal|"stat"
argument_list|)
argument_list|,
operator|new
name|IntsRef
argument_list|()
argument_list|)
argument_list|,
name|outputs
operator|.
name|getNoOutput
argument_list|()
argument_list|)
expr_stmt|;
name|builder
operator|.
name|add
argument_list|(
name|Util
operator|.
name|toIntsRef
argument_list|(
operator|new
name|BytesRef
argument_list|(
literal|"station"
argument_list|)
argument_list|,
operator|new
name|IntsRef
argument_list|()
argument_list|)
argument_list|,
name|outputs
operator|.
name|getNoOutput
argument_list|()
argument_list|)
expr_stmt|;
specifier|final
name|FST
argument_list|<
name|Long
argument_list|>
name|fst
init|=
name|builder
operator|.
name|finish
argument_list|()
decl_stmt|;
name|StringWriter
name|w
init|=
operator|new
name|StringWriter
argument_list|()
decl_stmt|;
comment|//Writer w = new OutputStreamWriter(new FileOutputStream("/x/tmp/out.dot"));
name|Util
operator|.
name|toDot
argument_list|(
name|fst
argument_list|,
name|w
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|w
operator|.
name|close
argument_list|()
expr_stmt|;
comment|//System.out.println(w.toString());
specifier|final
name|String
name|expected
decl_stmt|;
if|if
condition|(
name|willRewrite
condition|)
block|{
name|expected
operator|=
literal|"4 -> 3 [label=\"t\" style=\"bold\""
expr_stmt|;
block|}
else|else
block|{
name|expected
operator|=
literal|"8 -> 6 [label=\"t\" style=\"bold\""
expr_stmt|;
block|}
name|assertTrue
argument_list|(
name|w
operator|.
name|toString
argument_list|()
operator|.
name|indexOf
argument_list|(
name|expected
argument_list|)
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|// Make sure raw FST can differentiate between final vs
comment|// non-final end nodes
DECL|method|testNonFinalStopNode
specifier|public
name|void
name|testNonFinalStopNode
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|PositiveIntOutputs
name|outputs
init|=
name|PositiveIntOutputs
operator|.
name|getSingleton
argument_list|(
literal|true
argument_list|)
decl_stmt|;
specifier|final
name|Long
name|nothing
init|=
name|outputs
operator|.
name|getNoOutput
argument_list|()
decl_stmt|;
specifier|final
name|Builder
argument_list|<
name|Long
argument_list|>
name|b
init|=
operator|new
name|Builder
argument_list|<
name|Long
argument_list|>
argument_list|(
name|FST
operator|.
name|INPUT_TYPE
operator|.
name|BYTE1
argument_list|,
name|outputs
argument_list|)
decl_stmt|;
specifier|final
name|FST
argument_list|<
name|Long
argument_list|>
name|fst
init|=
operator|new
name|FST
argument_list|<
name|Long
argument_list|>
argument_list|(
name|FST
operator|.
name|INPUT_TYPE
operator|.
name|BYTE1
argument_list|,
name|outputs
argument_list|,
literal|false
argument_list|)
decl_stmt|;
specifier|final
name|Builder
operator|.
name|UnCompiledNode
argument_list|<
name|Long
argument_list|>
name|rootNode
init|=
operator|new
name|Builder
operator|.
name|UnCompiledNode
argument_list|<
name|Long
argument_list|>
argument_list|(
name|b
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|// Add final stop node
block|{
specifier|final
name|Builder
operator|.
name|UnCompiledNode
argument_list|<
name|Long
argument_list|>
name|node
init|=
operator|new
name|Builder
operator|.
name|UnCompiledNode
argument_list|<
name|Long
argument_list|>
argument_list|(
name|b
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|node
operator|.
name|isFinal
operator|=
literal|true
expr_stmt|;
name|rootNode
operator|.
name|addArc
argument_list|(
literal|'a'
argument_list|,
name|node
argument_list|)
expr_stmt|;
specifier|final
name|Builder
operator|.
name|CompiledNode
name|frozen
init|=
operator|new
name|Builder
operator|.
name|CompiledNode
argument_list|()
decl_stmt|;
name|frozen
operator|.
name|node
operator|=
name|fst
operator|.
name|addNode
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|rootNode
operator|.
name|arcs
index|[
literal|0
index|]
operator|.
name|nextFinalOutput
operator|=
literal|17L
expr_stmt|;
name|rootNode
operator|.
name|arcs
index|[
literal|0
index|]
operator|.
name|isFinal
operator|=
literal|true
expr_stmt|;
name|rootNode
operator|.
name|arcs
index|[
literal|0
index|]
operator|.
name|output
operator|=
name|nothing
expr_stmt|;
name|rootNode
operator|.
name|arcs
index|[
literal|0
index|]
operator|.
name|target
operator|=
name|frozen
expr_stmt|;
block|}
comment|// Add non-final stop node
block|{
specifier|final
name|Builder
operator|.
name|UnCompiledNode
argument_list|<
name|Long
argument_list|>
name|node
init|=
operator|new
name|Builder
operator|.
name|UnCompiledNode
argument_list|<
name|Long
argument_list|>
argument_list|(
name|b
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rootNode
operator|.
name|addArc
argument_list|(
literal|'b'
argument_list|,
name|node
argument_list|)
expr_stmt|;
specifier|final
name|Builder
operator|.
name|CompiledNode
name|frozen
init|=
operator|new
name|Builder
operator|.
name|CompiledNode
argument_list|()
decl_stmt|;
name|frozen
operator|.
name|node
operator|=
name|fst
operator|.
name|addNode
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|rootNode
operator|.
name|arcs
index|[
literal|1
index|]
operator|.
name|nextFinalOutput
operator|=
name|nothing
expr_stmt|;
name|rootNode
operator|.
name|arcs
index|[
literal|1
index|]
operator|.
name|output
operator|=
literal|42L
expr_stmt|;
name|rootNode
operator|.
name|arcs
index|[
literal|1
index|]
operator|.
name|target
operator|=
name|frozen
expr_stmt|;
block|}
name|fst
operator|.
name|finish
argument_list|(
name|fst
operator|.
name|addNode
argument_list|(
name|rootNode
argument_list|)
argument_list|)
expr_stmt|;
name|StringWriter
name|w
init|=
operator|new
name|StringWriter
argument_list|()
decl_stmt|;
comment|//Writer w = new OutputStreamWriter(new FileOutputStream("/x/tmp3/out.dot"));
name|Util
operator|.
name|toDot
argument_list|(
name|fst
argument_list|,
name|w
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|w
operator|.
name|close
argument_list|()
expr_stmt|;
name|checkStopNodes
argument_list|(
name|fst
argument_list|,
name|outputs
argument_list|)
expr_stmt|;
comment|// Make sure it still works after save/load:
name|Directory
name|dir
init|=
name|newDirectory
argument_list|()
decl_stmt|;
name|IndexOutput
name|out
init|=
name|dir
operator|.
name|createOutput
argument_list|(
literal|"fst"
argument_list|,
name|IOContext
operator|.
name|DEFAULT
argument_list|)
decl_stmt|;
name|fst
operator|.
name|save
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|out
operator|.
name|close
argument_list|()
expr_stmt|;
name|IndexInput
name|in
init|=
name|dir
operator|.
name|openInput
argument_list|(
literal|"fst"
argument_list|,
name|IOContext
operator|.
name|DEFAULT
argument_list|)
decl_stmt|;
specifier|final
name|FST
argument_list|<
name|Long
argument_list|>
name|fst2
init|=
operator|new
name|FST
argument_list|<
name|Long
argument_list|>
argument_list|(
name|in
argument_list|,
name|outputs
argument_list|)
decl_stmt|;
name|checkStopNodes
argument_list|(
name|fst2
argument_list|,
name|outputs
argument_list|)
expr_stmt|;
name|in
operator|.
name|close
argument_list|()
expr_stmt|;
name|dir
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
DECL|method|checkStopNodes
specifier|private
name|void
name|checkStopNodes
parameter_list|(
name|FST
argument_list|<
name|Long
argument_list|>
name|fst
parameter_list|,
name|PositiveIntOutputs
name|outputs
parameter_list|)
throws|throws
name|Exception
block|{
specifier|final
name|Long
name|nothing
init|=
name|outputs
operator|.
name|getNoOutput
argument_list|()
decl_stmt|;
name|FST
operator|.
name|Arc
argument_list|<
name|Long
argument_list|>
name|startArc
init|=
name|fst
operator|.
name|getFirstArc
argument_list|(
operator|new
name|FST
operator|.
name|Arc
argument_list|<
name|Long
argument_list|>
argument_list|()
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|nothing
argument_list|,
name|startArc
operator|.
name|output
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|nothing
argument_list|,
name|startArc
operator|.
name|nextFinalOutput
argument_list|)
expr_stmt|;
name|FST
operator|.
name|Arc
argument_list|<
name|Long
argument_list|>
name|arc
init|=
name|fst
operator|.
name|readFirstTargetArc
argument_list|(
name|startArc
argument_list|,
operator|new
name|FST
operator|.
name|Arc
argument_list|<
name|Long
argument_list|>
argument_list|()
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|'a'
argument_list|,
name|arc
operator|.
name|label
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|17
argument_list|,
name|arc
operator|.
name|nextFinalOutput
operator|.
name|longValue
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|arc
operator|.
name|isFinal
argument_list|()
argument_list|)
expr_stmt|;
name|arc
operator|=
name|fst
operator|.
name|readNextArc
argument_list|(
name|arc
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|'b'
argument_list|,
name|arc
operator|.
name|label
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|arc
operator|.
name|isFinal
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|42
argument_list|,
name|arc
operator|.
name|output
operator|.
name|longValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|testLargeOutputsOnArrayArcs
specifier|public
name|void
name|testLargeOutputsOnArrayArcs
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|ByteSequenceOutputs
name|outputs
init|=
name|ByteSequenceOutputs
operator|.
name|getSingleton
argument_list|()
decl_stmt|;
specifier|final
name|Builder
argument_list|<
name|BytesRef
argument_list|>
name|builder
init|=
operator|new
name|Builder
argument_list|<
name|BytesRef
argument_list|>
argument_list|(
name|FST
operator|.
name|INPUT_TYPE
operator|.
name|BYTE1
argument_list|,
name|outputs
argument_list|)
decl_stmt|;
specifier|final
name|byte
index|[]
name|bytes
init|=
operator|new
name|byte
index|[
literal|300
index|]
decl_stmt|;
specifier|final
name|IntsRef
name|input
init|=
operator|new
name|IntsRef
argument_list|()
decl_stmt|;
name|input
operator|.
name|grow
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|input
operator|.
name|length
operator|=
literal|1
expr_stmt|;
specifier|final
name|BytesRef
name|output
init|=
operator|new
name|BytesRef
argument_list|(
name|bytes
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|arc
init|=
literal|0
init|;
name|arc
operator|<
literal|6
condition|;
name|arc
operator|++
control|)
block|{
name|input
operator|.
name|ints
index|[
literal|0
index|]
operator|=
name|arc
expr_stmt|;
name|output
operator|.
name|bytes
index|[
literal|0
index|]
operator|=
operator|(
name|byte
operator|)
name|arc
expr_stmt|;
name|builder
operator|.
name|add
argument_list|(
name|input
argument_list|,
name|BytesRef
operator|.
name|deepCopyOf
argument_list|(
name|output
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|final
name|FST
argument_list|<
name|BytesRef
argument_list|>
name|fst
init|=
name|builder
operator|.
name|finish
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|arc
init|=
literal|0
init|;
name|arc
operator|<
literal|6
condition|;
name|arc
operator|++
control|)
block|{
name|input
operator|.
name|ints
index|[
literal|0
index|]
operator|=
name|arc
expr_stmt|;
specifier|final
name|BytesRef
name|result
init|=
name|Util
operator|.
name|get
argument_list|(
name|fst
argument_list|,
name|input
argument_list|)
decl_stmt|;
name|assertNotNull
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|300
argument_list|,
name|result
operator|.
name|length
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|result
operator|.
name|bytes
index|[
name|result
operator|.
name|offset
index|]
argument_list|,
name|arc
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|byteIDX
init|=
literal|1
init|;
name|byteIDX
operator|<
name|result
operator|.
name|length
condition|;
name|byteIDX
operator|++
control|)
block|{
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|result
operator|.
name|bytes
index|[
name|result
operator|.
name|offset
operator|+
name|byteIDX
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_class
end_unit
