begin_unit
begin_package
DECL|package|org.apache.lucene.util.fst
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|fst
package|;
end_package
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|BufferedReader
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|StringWriter
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Writer
import|;
end_import
begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|charset
operator|.
name|StandardCharsets
import|;
end_import
begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|Files
import|;
end_import
begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|Path
import|;
end_import
begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|Paths
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Locale
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Random
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeMap
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeSet
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicInteger
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|MockAnalyzer
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|document
operator|.
name|Document
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|document
operator|.
name|Field
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|DirectoryReader
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|IndexReader
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|IndexWriter
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|IndexWriterConfig
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|MultiFields
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|RandomIndexWriter
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|Term
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|Terms
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|TermsEnum
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|IndexSearcher
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|TermQuery
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|Directory
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|FSDirectory
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|IOContext
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|IndexInput
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|IndexOutput
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|MockDirectoryWrapper
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|BytesRef
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|BytesRefBuilder
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|IntsRef
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|IntsRefBuilder
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|LineFileDocs
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|LuceneTestCase
operator|.
name|Slow
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|LuceneTestCase
operator|.
name|SuppressCodecs
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|LuceneTestCase
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|TestUtil
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|automaton
operator|.
name|CompiledAutomaton
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|automaton
operator|.
name|Automaton
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|automaton
operator|.
name|RegExp
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|fst
operator|.
name|BytesRefFSTEnum
operator|.
name|InputOutput
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|fst
operator|.
name|FST
operator|.
name|Arc
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|fst
operator|.
name|FST
operator|.
name|BytesReader
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|fst
operator|.
name|PairOutputs
operator|.
name|Pair
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|fst
operator|.
name|Util
operator|.
name|Result
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|packed
operator|.
name|PackedInts
import|;
end_import
begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|fst
operator|.
name|FSTTester
operator|.
name|getRandomString
import|;
end_import
begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|fst
operator|.
name|FSTTester
operator|.
name|simpleRandomString
import|;
end_import
begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|fst
operator|.
name|FSTTester
operator|.
name|toIntsRef
import|;
end_import
begin_class
annotation|@
name|SuppressCodecs
argument_list|(
block|{
literal|"SimpleText"
block|,
literal|"Memory"
block|,
literal|"Direct"
block|}
argument_list|)
annotation|@
name|Slow
DECL|class|TestFSTs
specifier|public
class|class
name|TestFSTs
extends|extends
name|LuceneTestCase
block|{
DECL|field|dir
specifier|private
name|MockDirectoryWrapper
name|dir
decl_stmt|;
annotation|@
name|Override
DECL|method|setUp
specifier|public
name|void
name|setUp
parameter_list|()
throws|throws
name|Exception
block|{
name|super
operator|.
name|setUp
argument_list|()
expr_stmt|;
name|dir
operator|=
name|newMockDirectory
argument_list|()
expr_stmt|;
name|dir
operator|.
name|setPreventDoubleWrite
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|dir
operator|.
name|setEnableVirusScanner
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|tearDown
specifier|public
name|void
name|tearDown
parameter_list|()
throws|throws
name|Exception
block|{
comment|// can be null if we force simpletext (funky, some kind of bug in test runner maybe)
if|if
condition|(
name|dir
operator|!=
literal|null
condition|)
name|dir
operator|.
name|close
argument_list|()
expr_stmt|;
name|super
operator|.
name|tearDown
argument_list|()
expr_stmt|;
block|}
DECL|method|testBasicFSA
specifier|public
name|void
name|testBasicFSA
parameter_list|()
throws|throws
name|IOException
block|{
name|String
index|[]
name|strings
init|=
operator|new
name|String
index|[]
block|{
literal|"station"
block|,
literal|"commotion"
block|,
literal|"elation"
block|,
literal|"elastic"
block|,
literal|"plastic"
block|,
literal|"stop"
block|,
literal|"ftop"
block|,
literal|"ftation"
block|,
literal|"stat"
block|}
decl_stmt|;
name|String
index|[]
name|strings2
init|=
operator|new
name|String
index|[]
block|{
literal|"station"
block|,
literal|"commotion"
block|,
literal|"elation"
block|,
literal|"elastic"
block|,
literal|"plastic"
block|,
literal|"stop"
block|,
literal|"ftop"
block|,
literal|"ftation"
block|}
decl_stmt|;
name|IntsRef
index|[]
name|terms
init|=
operator|new
name|IntsRef
index|[
name|strings
operator|.
name|length
index|]
decl_stmt|;
name|IntsRef
index|[]
name|terms2
init|=
operator|new
name|IntsRef
index|[
name|strings2
operator|.
name|length
index|]
decl_stmt|;
for|for
control|(
name|int
name|inputMode
init|=
literal|0
init|;
name|inputMode
operator|<
literal|2
condition|;
name|inputMode
operator|++
control|)
block|{
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"TEST: inputMode="
operator|+
name|inputModeToString
argument_list|(
name|inputMode
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|idx
init|=
literal|0
init|;
name|idx
operator|<
name|strings
operator|.
name|length
condition|;
name|idx
operator|++
control|)
block|{
name|terms
index|[
name|idx
index|]
operator|=
name|toIntsRef
argument_list|(
name|strings
index|[
name|idx
index|]
argument_list|,
name|inputMode
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|idx
init|=
literal|0
init|;
name|idx
operator|<
name|strings2
operator|.
name|length
condition|;
name|idx
operator|++
control|)
block|{
name|terms2
index|[
name|idx
index|]
operator|=
name|toIntsRef
argument_list|(
name|strings2
index|[
name|idx
index|]
argument_list|,
name|inputMode
argument_list|)
expr_stmt|;
block|}
name|Arrays
operator|.
name|sort
argument_list|(
name|terms2
argument_list|)
expr_stmt|;
name|doTest
argument_list|(
name|inputMode
argument_list|,
name|terms
argument_list|)
expr_stmt|;
comment|// Test pre-determined FST sizes to make sure we haven't lost minimality (at least on this trivial set of terms):
comment|// FSA
block|{
specifier|final
name|Outputs
argument_list|<
name|Object
argument_list|>
name|outputs
init|=
name|NoOutputs
operator|.
name|getSingleton
argument_list|()
decl_stmt|;
specifier|final
name|Object
name|NO_OUTPUT
init|=
name|outputs
operator|.
name|getNoOutput
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|FSTTester
operator|.
name|InputOutput
argument_list|<
name|Object
argument_list|>
argument_list|>
name|pairs
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|terms2
operator|.
name|length
argument_list|)
decl_stmt|;
for|for
control|(
name|IntsRef
name|term
range|:
name|terms2
control|)
block|{
name|pairs
operator|.
name|add
argument_list|(
operator|new
name|FSTTester
operator|.
name|InputOutput
argument_list|<>
argument_list|(
name|term
argument_list|,
name|NO_OUTPUT
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|FST
argument_list|<
name|Object
argument_list|>
name|fst
init|=
operator|new
name|FSTTester
argument_list|<>
argument_list|(
name|random
argument_list|()
argument_list|,
name|dir
argument_list|,
name|inputMode
argument_list|,
name|pairs
argument_list|,
name|outputs
argument_list|,
literal|false
argument_list|)
operator|.
name|doTest
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|assertNotNull
argument_list|(
name|fst
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|22
argument_list|,
name|fst
operator|.
name|getNodeCount
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|27
argument_list|,
name|fst
operator|.
name|getArcCount
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// FST ord pos int
block|{
specifier|final
name|PositiveIntOutputs
name|outputs
init|=
name|PositiveIntOutputs
operator|.
name|getSingleton
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|FSTTester
operator|.
name|InputOutput
argument_list|<
name|Long
argument_list|>
argument_list|>
name|pairs
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|terms2
operator|.
name|length
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|idx
init|=
literal|0
init|;
name|idx
operator|<
name|terms2
operator|.
name|length
condition|;
name|idx
operator|++
control|)
block|{
name|pairs
operator|.
name|add
argument_list|(
operator|new
name|FSTTester
operator|.
name|InputOutput
argument_list|<>
argument_list|(
name|terms2
index|[
name|idx
index|]
argument_list|,
operator|(
name|long
operator|)
name|idx
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|final
name|FST
argument_list|<
name|Long
argument_list|>
name|fst
init|=
operator|new
name|FSTTester
argument_list|<>
argument_list|(
name|random
argument_list|()
argument_list|,
name|dir
argument_list|,
name|inputMode
argument_list|,
name|pairs
argument_list|,
name|outputs
argument_list|,
literal|true
argument_list|)
operator|.
name|doTest
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|assertNotNull
argument_list|(
name|fst
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|22
argument_list|,
name|fst
operator|.
name|getNodeCount
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|27
argument_list|,
name|fst
operator|.
name|getArcCount
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// FST byte sequence ord
block|{
specifier|final
name|ByteSequenceOutputs
name|outputs
init|=
name|ByteSequenceOutputs
operator|.
name|getSingleton
argument_list|()
decl_stmt|;
specifier|final
name|BytesRef
name|NO_OUTPUT
init|=
name|outputs
operator|.
name|getNoOutput
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|FSTTester
operator|.
name|InputOutput
argument_list|<
name|BytesRef
argument_list|>
argument_list|>
name|pairs
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|terms2
operator|.
name|length
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|idx
init|=
literal|0
init|;
name|idx
operator|<
name|terms2
operator|.
name|length
condition|;
name|idx
operator|++
control|)
block|{
specifier|final
name|BytesRef
name|output
init|=
name|random
argument_list|()
operator|.
name|nextInt
argument_list|(
literal|30
argument_list|)
operator|==
literal|17
condition|?
name|NO_OUTPUT
else|:
operator|new
name|BytesRef
argument_list|(
name|Integer
operator|.
name|toString
argument_list|(
name|idx
argument_list|)
argument_list|)
decl_stmt|;
name|pairs
operator|.
name|add
argument_list|(
operator|new
name|FSTTester
operator|.
name|InputOutput
argument_list|<>
argument_list|(
name|terms2
index|[
name|idx
index|]
argument_list|,
name|output
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|final
name|FST
argument_list|<
name|BytesRef
argument_list|>
name|fst
init|=
operator|new
name|FSTTester
argument_list|<>
argument_list|(
name|random
argument_list|()
argument_list|,
name|dir
argument_list|,
name|inputMode
argument_list|,
name|pairs
argument_list|,
name|outputs
argument_list|,
literal|false
argument_list|)
operator|.
name|doTest
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|assertNotNull
argument_list|(
name|fst
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|24
argument_list|,
name|fst
operator|.
name|getNodeCount
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|30
argument_list|,
name|fst
operator|.
name|getArcCount
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// given set of terms, test the different outputs for them
DECL|method|doTest
specifier|private
name|void
name|doTest
parameter_list|(
name|int
name|inputMode
parameter_list|,
name|IntsRef
index|[]
name|terms
parameter_list|)
throws|throws
name|IOException
block|{
name|Arrays
operator|.
name|sort
argument_list|(
name|terms
argument_list|)
expr_stmt|;
comment|// NoOutputs (simple FSA)
block|{
specifier|final
name|Outputs
argument_list|<
name|Object
argument_list|>
name|outputs
init|=
name|NoOutputs
operator|.
name|getSingleton
argument_list|()
decl_stmt|;
specifier|final
name|Object
name|NO_OUTPUT
init|=
name|outputs
operator|.
name|getNoOutput
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|FSTTester
operator|.
name|InputOutput
argument_list|<
name|Object
argument_list|>
argument_list|>
name|pairs
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|terms
operator|.
name|length
argument_list|)
decl_stmt|;
for|for
control|(
name|IntsRef
name|term
range|:
name|terms
control|)
block|{
name|pairs
operator|.
name|add
argument_list|(
operator|new
name|FSTTester
operator|.
name|InputOutput
argument_list|<>
argument_list|(
name|term
argument_list|,
name|NO_OUTPUT
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|new
name|FSTTester
argument_list|<>
argument_list|(
name|random
argument_list|()
argument_list|,
name|dir
argument_list|,
name|inputMode
argument_list|,
name|pairs
argument_list|,
name|outputs
argument_list|,
literal|false
argument_list|)
operator|.
name|doTest
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
comment|// PositiveIntOutput (ord)
block|{
specifier|final
name|PositiveIntOutputs
name|outputs
init|=
name|PositiveIntOutputs
operator|.
name|getSingleton
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|FSTTester
operator|.
name|InputOutput
argument_list|<
name|Long
argument_list|>
argument_list|>
name|pairs
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|terms
operator|.
name|length
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|idx
init|=
literal|0
init|;
name|idx
operator|<
name|terms
operator|.
name|length
condition|;
name|idx
operator|++
control|)
block|{
name|pairs
operator|.
name|add
argument_list|(
operator|new
name|FSTTester
operator|.
name|InputOutput
argument_list|<>
argument_list|(
name|terms
index|[
name|idx
index|]
argument_list|,
operator|(
name|long
operator|)
name|idx
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|new
name|FSTTester
argument_list|<>
argument_list|(
name|random
argument_list|()
argument_list|,
name|dir
argument_list|,
name|inputMode
argument_list|,
name|pairs
argument_list|,
name|outputs
argument_list|,
literal|true
argument_list|)
operator|.
name|doTest
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
comment|// PositiveIntOutput (random monotonically increasing positive number)
block|{
specifier|final
name|PositiveIntOutputs
name|outputs
init|=
name|PositiveIntOutputs
operator|.
name|getSingleton
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|FSTTester
operator|.
name|InputOutput
argument_list|<
name|Long
argument_list|>
argument_list|>
name|pairs
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|terms
operator|.
name|length
argument_list|)
decl_stmt|;
name|long
name|lastOutput
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|idx
init|=
literal|0
init|;
name|idx
operator|<
name|terms
operator|.
name|length
condition|;
name|idx
operator|++
control|)
block|{
specifier|final
name|long
name|value
init|=
name|lastOutput
operator|+
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|random
argument_list|()
argument_list|,
literal|1
argument_list|,
literal|1000
argument_list|)
decl_stmt|;
name|lastOutput
operator|=
name|value
expr_stmt|;
name|pairs
operator|.
name|add
argument_list|(
operator|new
name|FSTTester
operator|.
name|InputOutput
argument_list|<>
argument_list|(
name|terms
index|[
name|idx
index|]
argument_list|,
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|new
name|FSTTester
argument_list|<>
argument_list|(
name|random
argument_list|()
argument_list|,
name|dir
argument_list|,
name|inputMode
argument_list|,
name|pairs
argument_list|,
name|outputs
argument_list|,
literal|true
argument_list|)
operator|.
name|doTest
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
comment|// PositiveIntOutput (random positive number)
block|{
specifier|final
name|PositiveIntOutputs
name|outputs
init|=
name|PositiveIntOutputs
operator|.
name|getSingleton
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|FSTTester
operator|.
name|InputOutput
argument_list|<
name|Long
argument_list|>
argument_list|>
name|pairs
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|terms
operator|.
name|length
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|idx
init|=
literal|0
init|;
name|idx
operator|<
name|terms
operator|.
name|length
condition|;
name|idx
operator|++
control|)
block|{
name|pairs
operator|.
name|add
argument_list|(
operator|new
name|FSTTester
operator|.
name|InputOutput
argument_list|<>
argument_list|(
name|terms
index|[
name|idx
index|]
argument_list|,
name|TestUtil
operator|.
name|nextLong
argument_list|(
name|random
argument_list|()
argument_list|,
literal|0
argument_list|,
name|Long
operator|.
name|MAX_VALUE
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|new
name|FSTTester
argument_list|<>
argument_list|(
name|random
argument_list|()
argument_list|,
name|dir
argument_list|,
name|inputMode
argument_list|,
name|pairs
argument_list|,
name|outputs
argument_list|,
literal|false
argument_list|)
operator|.
name|doTest
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
comment|// Pair<ord, (random monotonically increasing positive number>
block|{
specifier|final
name|PositiveIntOutputs
name|o1
init|=
name|PositiveIntOutputs
operator|.
name|getSingleton
argument_list|()
decl_stmt|;
specifier|final
name|PositiveIntOutputs
name|o2
init|=
name|PositiveIntOutputs
operator|.
name|getSingleton
argument_list|()
decl_stmt|;
specifier|final
name|PairOutputs
argument_list|<
name|Long
argument_list|,
name|Long
argument_list|>
name|outputs
init|=
operator|new
name|PairOutputs
argument_list|<>
argument_list|(
name|o1
argument_list|,
name|o2
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|FSTTester
operator|.
name|InputOutput
argument_list|<
name|PairOutputs
operator|.
name|Pair
argument_list|<
name|Long
argument_list|,
name|Long
argument_list|>
argument_list|>
argument_list|>
name|pairs
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|terms
operator|.
name|length
argument_list|)
decl_stmt|;
name|long
name|lastOutput
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|idx
init|=
literal|0
init|;
name|idx
operator|<
name|terms
operator|.
name|length
condition|;
name|idx
operator|++
control|)
block|{
specifier|final
name|long
name|value
init|=
name|lastOutput
operator|+
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|random
argument_list|()
argument_list|,
literal|1
argument_list|,
literal|1000
argument_list|)
decl_stmt|;
name|lastOutput
operator|=
name|value
expr_stmt|;
name|pairs
operator|.
name|add
argument_list|(
operator|new
name|FSTTester
operator|.
name|InputOutput
argument_list|<>
argument_list|(
name|terms
index|[
name|idx
index|]
argument_list|,
name|outputs
operator|.
name|newPair
argument_list|(
operator|(
name|long
operator|)
name|idx
argument_list|,
name|value
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|new
name|FSTTester
argument_list|<>
argument_list|(
name|random
argument_list|()
argument_list|,
name|dir
argument_list|,
name|inputMode
argument_list|,
name|pairs
argument_list|,
name|outputs
argument_list|,
literal|false
argument_list|)
operator|.
name|doTest
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
comment|// Sequence-of-bytes
block|{
specifier|final
name|ByteSequenceOutputs
name|outputs
init|=
name|ByteSequenceOutputs
operator|.
name|getSingleton
argument_list|()
decl_stmt|;
specifier|final
name|BytesRef
name|NO_OUTPUT
init|=
name|outputs
operator|.
name|getNoOutput
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|FSTTester
operator|.
name|InputOutput
argument_list|<
name|BytesRef
argument_list|>
argument_list|>
name|pairs
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|terms
operator|.
name|length
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|idx
init|=
literal|0
init|;
name|idx
operator|<
name|terms
operator|.
name|length
condition|;
name|idx
operator|++
control|)
block|{
specifier|final
name|BytesRef
name|output
init|=
name|random
argument_list|()
operator|.
name|nextInt
argument_list|(
literal|30
argument_list|)
operator|==
literal|17
condition|?
name|NO_OUTPUT
else|:
operator|new
name|BytesRef
argument_list|(
name|Integer
operator|.
name|toString
argument_list|(
name|idx
argument_list|)
argument_list|)
decl_stmt|;
name|pairs
operator|.
name|add
argument_list|(
operator|new
name|FSTTester
operator|.
name|InputOutput
argument_list|<>
argument_list|(
name|terms
index|[
name|idx
index|]
argument_list|,
name|output
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|new
name|FSTTester
argument_list|<>
argument_list|(
name|random
argument_list|()
argument_list|,
name|dir
argument_list|,
name|inputMode
argument_list|,
name|pairs
argument_list|,
name|outputs
argument_list|,
literal|false
argument_list|)
operator|.
name|doTest
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
comment|// Sequence-of-ints
block|{
specifier|final
name|IntSequenceOutputs
name|outputs
init|=
name|IntSequenceOutputs
operator|.
name|getSingleton
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|FSTTester
operator|.
name|InputOutput
argument_list|<
name|IntsRef
argument_list|>
argument_list|>
name|pairs
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|terms
operator|.
name|length
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|idx
init|=
literal|0
init|;
name|idx
operator|<
name|terms
operator|.
name|length
condition|;
name|idx
operator|++
control|)
block|{
specifier|final
name|String
name|s
init|=
name|Integer
operator|.
name|toString
argument_list|(
name|idx
argument_list|)
decl_stmt|;
specifier|final
name|IntsRef
name|output
init|=
operator|new
name|IntsRef
argument_list|(
name|s
operator|.
name|length
argument_list|()
argument_list|)
decl_stmt|;
name|output
operator|.
name|length
operator|=
name|s
operator|.
name|length
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|idx2
init|=
literal|0
init|;
name|idx2
operator|<
name|output
operator|.
name|length
condition|;
name|idx2
operator|++
control|)
block|{
name|output
operator|.
name|ints
index|[
name|idx2
index|]
operator|=
name|s
operator|.
name|charAt
argument_list|(
name|idx2
argument_list|)
expr_stmt|;
block|}
name|pairs
operator|.
name|add
argument_list|(
operator|new
name|FSTTester
operator|.
name|InputOutput
argument_list|<>
argument_list|(
name|terms
index|[
name|idx
index|]
argument_list|,
name|output
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|new
name|FSTTester
argument_list|<>
argument_list|(
name|random
argument_list|()
argument_list|,
name|dir
argument_list|,
name|inputMode
argument_list|,
name|pairs
argument_list|,
name|outputs
argument_list|,
literal|false
argument_list|)
operator|.
name|doTest
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|testRandomWords
specifier|public
name|void
name|testRandomWords
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|TEST_NIGHTLY
condition|)
block|{
name|testRandomWords
argument_list|(
literal|1000
argument_list|,
name|atLeast
argument_list|(
literal|2
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|testRandomWords
argument_list|(
literal|100
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|inputModeToString
name|String
name|inputModeToString
parameter_list|(
name|int
name|mode
parameter_list|)
block|{
if|if
condition|(
name|mode
operator|==
literal|0
condition|)
block|{
return|return
literal|"utf8"
return|;
block|}
else|else
block|{
return|return
literal|"utf32"
return|;
block|}
block|}
DECL|method|testRandomWords
specifier|private
name|void
name|testRandomWords
parameter_list|(
name|int
name|maxNumWords
parameter_list|,
name|int
name|numIter
parameter_list|)
throws|throws
name|IOException
block|{
name|Random
name|random
init|=
operator|new
name|Random
argument_list|(
name|random
argument_list|()
operator|.
name|nextLong
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|iter
init|=
literal|0
init|;
name|iter
operator|<
name|numIter
condition|;
name|iter
operator|++
control|)
block|{
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"\nTEST: iter "
operator|+
name|iter
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|inputMode
init|=
literal|0
init|;
name|inputMode
operator|<
literal|2
condition|;
name|inputMode
operator|++
control|)
block|{
specifier|final
name|int
name|numWords
init|=
name|random
operator|.
name|nextInt
argument_list|(
name|maxNumWords
operator|+
literal|1
argument_list|)
decl_stmt|;
name|Set
argument_list|<
name|IntsRef
argument_list|>
name|termsSet
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
name|IntsRef
index|[]
name|terms
init|=
operator|new
name|IntsRef
index|[
name|numWords
index|]
decl_stmt|;
while|while
condition|(
name|termsSet
operator|.
name|size
argument_list|()
operator|<
name|numWords
condition|)
block|{
specifier|final
name|String
name|term
init|=
name|getRandomString
argument_list|(
name|random
argument_list|)
decl_stmt|;
name|termsSet
operator|.
name|add
argument_list|(
name|toIntsRef
argument_list|(
name|term
argument_list|,
name|inputMode
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|doTest
argument_list|(
name|inputMode
argument_list|,
name|termsSet
operator|.
name|toArray
argument_list|(
operator|new
name|IntsRef
index|[
name|termsSet
operator|.
name|size
argument_list|()
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|Nightly
DECL|method|testBigSet
specifier|public
name|void
name|testBigSet
parameter_list|()
throws|throws
name|IOException
block|{
name|testRandomWords
argument_list|(
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|random
argument_list|()
argument_list|,
literal|50000
argument_list|,
literal|60000
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|// Build FST for all unique terms in the test line docs
comment|// file, up until a doc limit
DECL|method|testRealTerms
specifier|public
name|void
name|testRealTerms
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|LineFileDocs
name|docs
init|=
operator|new
name|LineFileDocs
argument_list|(
name|random
argument_list|()
argument_list|,
literal|true
argument_list|)
decl_stmt|;
specifier|final
name|int
name|numDocs
init|=
name|TEST_NIGHTLY
condition|?
name|atLeast
argument_list|(
literal|1000
argument_list|)
else|:
name|atLeast
argument_list|(
literal|100
argument_list|)
decl_stmt|;
name|MockAnalyzer
name|analyzer
init|=
operator|new
name|MockAnalyzer
argument_list|(
name|random
argument_list|()
argument_list|)
decl_stmt|;
name|analyzer
operator|.
name|setMaxTokenLength
argument_list|(
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|random
argument_list|()
argument_list|,
literal|1
argument_list|,
name|IndexWriter
operator|.
name|MAX_TERM_LENGTH
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|IndexWriterConfig
name|conf
init|=
name|newIndexWriterConfig
argument_list|(
name|analyzer
argument_list|)
operator|.
name|setMaxBufferedDocs
argument_list|(
operator|-
literal|1
argument_list|)
operator|.
name|setRAMBufferSizeMB
argument_list|(
literal|64
argument_list|)
decl_stmt|;
specifier|final
name|Path
name|tempDir
init|=
name|createTempDir
argument_list|(
literal|"fstlines"
argument_list|)
decl_stmt|;
specifier|final
name|Directory
name|dir
init|=
name|newFSDirectory
argument_list|(
name|tempDir
argument_list|)
decl_stmt|;
specifier|final
name|IndexWriter
name|writer
init|=
operator|new
name|IndexWriter
argument_list|(
name|dir
argument_list|,
name|conf
argument_list|)
decl_stmt|;
name|Document
name|doc
decl_stmt|;
name|int
name|docCount
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|(
name|doc
operator|=
name|docs
operator|.
name|nextDoc
argument_list|()
operator|)
operator|!=
literal|null
operator|&&
name|docCount
operator|<
name|numDocs
condition|)
block|{
name|writer
operator|.
name|addDocument
argument_list|(
name|doc
argument_list|)
expr_stmt|;
name|docCount
operator|++
expr_stmt|;
block|}
name|IndexReader
name|r
init|=
name|DirectoryReader
operator|.
name|open
argument_list|(
name|writer
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|writer
operator|.
name|close
argument_list|()
expr_stmt|;
specifier|final
name|PositiveIntOutputs
name|outputs
init|=
name|PositiveIntOutputs
operator|.
name|getSingleton
argument_list|()
decl_stmt|;
specifier|final
name|boolean
name|doRewrite
init|=
name|random
argument_list|()
operator|.
name|nextBoolean
argument_list|()
decl_stmt|;
name|Builder
argument_list|<
name|Long
argument_list|>
name|builder
init|=
operator|new
name|Builder
argument_list|<>
argument_list|(
name|FST
operator|.
name|INPUT_TYPE
operator|.
name|BYTE1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|true
argument_list|,
literal|true
argument_list|,
name|Integer
operator|.
name|MAX_VALUE
argument_list|,
name|outputs
argument_list|,
name|doRewrite
argument_list|,
name|PackedInts
operator|.
name|DEFAULT
argument_list|,
literal|true
argument_list|,
literal|15
argument_list|)
decl_stmt|;
name|boolean
name|storeOrd
init|=
name|random
argument_list|()
operator|.
name|nextBoolean
argument_list|()
decl_stmt|;
if|if
condition|(
name|VERBOSE
condition|)
block|{
if|if
condition|(
name|storeOrd
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"FST stores ord"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"FST stores docFreq"
argument_list|)
expr_stmt|;
block|}
block|}
name|Terms
name|terms
init|=
name|MultiFields
operator|.
name|getTerms
argument_list|(
name|r
argument_list|,
literal|"body"
argument_list|)
decl_stmt|;
if|if
condition|(
name|terms
operator|!=
literal|null
condition|)
block|{
specifier|final
name|IntsRefBuilder
name|scratchIntsRef
init|=
operator|new
name|IntsRefBuilder
argument_list|()
decl_stmt|;
specifier|final
name|TermsEnum
name|termsEnum
init|=
name|terms
operator|.
name|iterator
argument_list|()
decl_stmt|;
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"TEST: got termsEnum="
operator|+
name|termsEnum
argument_list|)
expr_stmt|;
block|}
name|BytesRef
name|term
decl_stmt|;
name|int
name|ord
init|=
literal|0
decl_stmt|;
name|Automaton
name|automaton
init|=
operator|new
name|RegExp
argument_list|(
literal|".*"
argument_list|,
name|RegExp
operator|.
name|NONE
argument_list|)
operator|.
name|toAutomaton
argument_list|()
decl_stmt|;
specifier|final
name|TermsEnum
name|termsEnum2
init|=
name|terms
operator|.
name|intersect
argument_list|(
operator|new
name|CompiledAutomaton
argument_list|(
name|automaton
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|)
argument_list|,
literal|null
argument_list|)
decl_stmt|;
while|while
condition|(
operator|(
name|term
operator|=
name|termsEnum
operator|.
name|next
argument_list|()
operator|)
operator|!=
literal|null
condition|)
block|{
name|BytesRef
name|term2
init|=
name|termsEnum2
operator|.
name|next
argument_list|()
decl_stmt|;
name|assertNotNull
argument_list|(
name|term2
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|term
argument_list|,
name|term2
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|termsEnum
operator|.
name|docFreq
argument_list|()
argument_list|,
name|termsEnum2
operator|.
name|docFreq
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|termsEnum
operator|.
name|totalTermFreq
argument_list|()
argument_list|,
name|termsEnum2
operator|.
name|totalTermFreq
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|ord
operator|==
literal|0
condition|)
block|{
try|try
block|{
name|termsEnum
operator|.
name|ord
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedOperationException
name|uoe
parameter_list|)
block|{
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"TEST: codec doesn't support ord; FST stores docFreq"
argument_list|)
expr_stmt|;
block|}
name|storeOrd
operator|=
literal|false
expr_stmt|;
block|}
block|}
specifier|final
name|int
name|output
decl_stmt|;
if|if
condition|(
name|storeOrd
condition|)
block|{
name|output
operator|=
name|ord
expr_stmt|;
block|}
else|else
block|{
name|output
operator|=
name|termsEnum
operator|.
name|docFreq
argument_list|()
expr_stmt|;
block|}
name|builder
operator|.
name|add
argument_list|(
name|Util
operator|.
name|toIntsRef
argument_list|(
name|term
argument_list|,
name|scratchIntsRef
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|output
argument_list|)
expr_stmt|;
name|ord
operator|++
expr_stmt|;
if|if
condition|(
name|VERBOSE
operator|&&
name|ord
operator|%
literal|100000
operator|==
literal|0
operator|&&
name|LuceneTestCase
operator|.
name|TEST_NIGHTLY
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
name|ord
operator|+
literal|" terms..."
argument_list|)
expr_stmt|;
block|}
block|}
name|FST
argument_list|<
name|Long
argument_list|>
name|fst
init|=
name|builder
operator|.
name|finish
argument_list|()
decl_stmt|;
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"FST: "
operator|+
name|docCount
operator|+
literal|" docs; "
operator|+
name|ord
operator|+
literal|" terms; "
operator|+
name|fst
operator|.
name|getNodeCount
argument_list|()
operator|+
literal|" nodes; "
operator|+
name|fst
operator|.
name|getArcCount
argument_list|()
operator|+
literal|" arcs;"
operator|+
literal|" "
operator|+
name|fst
operator|.
name|ramBytesUsed
argument_list|()
operator|+
literal|" bytes"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ord
operator|>
literal|0
condition|)
block|{
specifier|final
name|Random
name|random
init|=
operator|new
name|Random
argument_list|(
name|random
argument_list|()
operator|.
name|nextLong
argument_list|()
argument_list|)
decl_stmt|;
comment|// Now confirm BytesRefFSTEnum and TermsEnum act the
comment|// same:
specifier|final
name|BytesRefFSTEnum
argument_list|<
name|Long
argument_list|>
name|fstEnum
init|=
operator|new
name|BytesRefFSTEnum
argument_list|<>
argument_list|(
name|fst
argument_list|)
decl_stmt|;
name|int
name|num
init|=
name|atLeast
argument_list|(
literal|1000
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|iter
init|=
literal|0
init|;
name|iter
operator|<
name|num
condition|;
name|iter
operator|++
control|)
block|{
specifier|final
name|BytesRef
name|randomTerm
init|=
operator|new
name|BytesRef
argument_list|(
name|getRandomString
argument_list|(
name|random
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"TEST: seek non-exist "
operator|+
name|randomTerm
operator|.
name|utf8ToString
argument_list|()
operator|+
literal|" "
operator|+
name|randomTerm
argument_list|)
expr_stmt|;
block|}
specifier|final
name|TermsEnum
operator|.
name|SeekStatus
name|seekResult
init|=
name|termsEnum
operator|.
name|seekCeil
argument_list|(
name|randomTerm
argument_list|)
decl_stmt|;
specifier|final
name|InputOutput
argument_list|<
name|Long
argument_list|>
name|fstSeekResult
init|=
name|fstEnum
operator|.
name|seekCeil
argument_list|(
name|randomTerm
argument_list|)
decl_stmt|;
if|if
condition|(
name|seekResult
operator|==
name|TermsEnum
operator|.
name|SeekStatus
operator|.
name|END
condition|)
block|{
name|assertNull
argument_list|(
literal|"got "
operator|+
operator|(
name|fstSeekResult
operator|==
literal|null
condition|?
literal|"null"
else|:
name|fstSeekResult
operator|.
name|input
operator|.
name|utf8ToString
argument_list|()
operator|)
operator|+
literal|" but expected null"
argument_list|,
name|fstSeekResult
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|assertSame
argument_list|(
name|termsEnum
argument_list|,
name|fstEnum
argument_list|,
name|storeOrd
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|nextIter
init|=
literal|0
init|;
name|nextIter
operator|<
literal|10
condition|;
name|nextIter
operator|++
control|)
block|{
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"TEST: next"
argument_list|)
expr_stmt|;
if|if
condition|(
name|storeOrd
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"  ord="
operator|+
name|termsEnum
operator|.
name|ord
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|termsEnum
operator|.
name|next
argument_list|()
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"  term="
operator|+
name|termsEnum
operator|.
name|term
argument_list|()
operator|.
name|utf8ToString
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|assertNotNull
argument_list|(
name|fstEnum
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
name|assertSame
argument_list|(
name|termsEnum
argument_list|,
name|fstEnum
argument_list|,
name|storeOrd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"  end!"
argument_list|)
expr_stmt|;
block|}
name|BytesRefFSTEnum
operator|.
name|InputOutput
argument_list|<
name|Long
argument_list|>
name|nextResult
init|=
name|fstEnum
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|nextResult
operator|!=
literal|null
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"expected null but got: input="
operator|+
name|nextResult
operator|.
name|input
operator|.
name|utf8ToString
argument_list|()
operator|+
literal|" output="
operator|+
name|outputs
operator|.
name|outputToString
argument_list|(
name|nextResult
operator|.
name|output
argument_list|)
argument_list|)
expr_stmt|;
name|fail
argument_list|()
expr_stmt|;
block|}
break|break;
block|}
block|}
block|}
block|}
block|}
block|}
name|r
operator|.
name|close
argument_list|()
expr_stmt|;
name|dir
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
DECL|method|assertSame
specifier|private
name|void
name|assertSame
parameter_list|(
name|TermsEnum
name|termsEnum
parameter_list|,
name|BytesRefFSTEnum
argument_list|<
name|?
argument_list|>
name|fstEnum
parameter_list|,
name|boolean
name|storeOrd
parameter_list|)
throws|throws
name|Exception
block|{
if|if
condition|(
name|termsEnum
operator|.
name|term
argument_list|()
operator|==
literal|null
condition|)
block|{
name|assertNull
argument_list|(
name|fstEnum
operator|.
name|current
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|assertNotNull
argument_list|(
name|fstEnum
operator|.
name|current
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|termsEnum
operator|.
name|term
argument_list|()
operator|.
name|utf8ToString
argument_list|()
operator|+
literal|" != "
operator|+
name|fstEnum
operator|.
name|current
argument_list|()
operator|.
name|input
operator|.
name|utf8ToString
argument_list|()
argument_list|,
name|termsEnum
operator|.
name|term
argument_list|()
argument_list|,
name|fstEnum
operator|.
name|current
argument_list|()
operator|.
name|input
argument_list|)
expr_stmt|;
if|if
condition|(
name|storeOrd
condition|)
block|{
comment|// fst stored the ord
name|assertEquals
argument_list|(
literal|"term="
operator|+
name|termsEnum
operator|.
name|term
argument_list|()
operator|.
name|utf8ToString
argument_list|()
operator|+
literal|" "
operator|+
name|termsEnum
operator|.
name|term
argument_list|()
argument_list|,
name|termsEnum
operator|.
name|ord
argument_list|()
argument_list|,
operator|(
operator|(
name|Long
operator|)
name|fstEnum
operator|.
name|current
argument_list|()
operator|.
name|output
operator|)
operator|.
name|longValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// fst stored the docFreq
name|assertEquals
argument_list|(
literal|"term="
operator|+
name|termsEnum
operator|.
name|term
argument_list|()
operator|.
name|utf8ToString
argument_list|()
operator|+
literal|" "
operator|+
name|termsEnum
operator|.
name|term
argument_list|()
argument_list|,
name|termsEnum
operator|.
name|docFreq
argument_list|()
argument_list|,
call|(
name|int
call|)
argument_list|(
operator|(
operator|(
name|Long
operator|)
name|fstEnum
operator|.
name|current
argument_list|()
operator|.
name|output
operator|)
operator|.
name|longValue
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|class|VisitTerms
specifier|private
specifier|static
specifier|abstract
class|class
name|VisitTerms
parameter_list|<
name|T
parameter_list|>
block|{
DECL|field|dirOut
specifier|private
specifier|final
name|Path
name|dirOut
decl_stmt|;
DECL|field|wordsFileIn
specifier|private
specifier|final
name|Path
name|wordsFileIn
decl_stmt|;
DECL|field|inputMode
specifier|private
name|int
name|inputMode
decl_stmt|;
DECL|field|outputs
specifier|private
specifier|final
name|Outputs
argument_list|<
name|T
argument_list|>
name|outputs
decl_stmt|;
DECL|field|builder
specifier|private
specifier|final
name|Builder
argument_list|<
name|T
argument_list|>
name|builder
decl_stmt|;
DECL|field|doPack
specifier|private
specifier|final
name|boolean
name|doPack
decl_stmt|;
DECL|method|VisitTerms
specifier|public
name|VisitTerms
parameter_list|(
name|Path
name|dirOut
parameter_list|,
name|Path
name|wordsFileIn
parameter_list|,
name|int
name|inputMode
parameter_list|,
name|int
name|prune
parameter_list|,
name|Outputs
argument_list|<
name|T
argument_list|>
name|outputs
parameter_list|,
name|boolean
name|doPack
parameter_list|,
name|boolean
name|noArcArrays
parameter_list|)
block|{
name|this
operator|.
name|dirOut
operator|=
name|dirOut
expr_stmt|;
name|this
operator|.
name|wordsFileIn
operator|=
name|wordsFileIn
expr_stmt|;
name|this
operator|.
name|inputMode
operator|=
name|inputMode
expr_stmt|;
name|this
operator|.
name|outputs
operator|=
name|outputs
expr_stmt|;
name|this
operator|.
name|doPack
operator|=
name|doPack
expr_stmt|;
name|builder
operator|=
operator|new
name|Builder
argument_list|<>
argument_list|(
name|inputMode
operator|==
literal|0
condition|?
name|FST
operator|.
name|INPUT_TYPE
operator|.
name|BYTE1
else|:
name|FST
operator|.
name|INPUT_TYPE
operator|.
name|BYTE4
argument_list|,
literal|0
argument_list|,
name|prune
argument_list|,
name|prune
operator|==
literal|0
argument_list|,
literal|true
argument_list|,
name|Integer
operator|.
name|MAX_VALUE
argument_list|,
name|outputs
argument_list|,
name|doPack
argument_list|,
name|PackedInts
operator|.
name|DEFAULT
argument_list|,
operator|!
name|noArcArrays
argument_list|,
literal|15
argument_list|)
expr_stmt|;
block|}
DECL|method|getOutput
specifier|protected
specifier|abstract
name|T
name|getOutput
parameter_list|(
name|IntsRef
name|input
parameter_list|,
name|int
name|ord
parameter_list|)
throws|throws
name|IOException
function_decl|;
DECL|method|run
specifier|public
name|void
name|run
parameter_list|(
name|int
name|limit
parameter_list|,
name|boolean
name|verify
parameter_list|,
name|boolean
name|verifyByOutput
parameter_list|)
throws|throws
name|IOException
block|{
name|BufferedReader
name|is
init|=
name|Files
operator|.
name|newBufferedReader
argument_list|(
name|wordsFileIn
argument_list|,
name|StandardCharsets
operator|.
name|UTF_8
argument_list|)
decl_stmt|;
try|try
block|{
specifier|final
name|IntsRefBuilder
name|intsRef
init|=
operator|new
name|IntsRefBuilder
argument_list|()
decl_stmt|;
name|long
name|tStart
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
name|int
name|ord
init|=
literal|0
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|String
name|w
init|=
name|is
operator|.
name|readLine
argument_list|()
decl_stmt|;
if|if
condition|(
name|w
operator|==
literal|null
condition|)
block|{
break|break;
block|}
name|toIntsRef
argument_list|(
name|w
argument_list|,
name|inputMode
argument_list|,
name|intsRef
argument_list|)
expr_stmt|;
name|builder
operator|.
name|add
argument_list|(
name|intsRef
operator|.
name|get
argument_list|()
argument_list|,
name|getOutput
argument_list|(
name|intsRef
operator|.
name|get
argument_list|()
argument_list|,
name|ord
argument_list|)
argument_list|)
expr_stmt|;
name|ord
operator|++
expr_stmt|;
if|if
condition|(
name|ord
operator|%
literal|500000
operator|==
literal|0
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
name|String
operator|.
name|format
argument_list|(
name|Locale
operator|.
name|ROOT
argument_list|,
literal|"%6.2fs: %9d..."
argument_list|,
operator|(
operator|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|-
name|tStart
operator|)
operator|/
literal|1000.0
operator|)
argument_list|,
name|ord
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ord
operator|>=
name|limit
condition|)
block|{
break|break;
block|}
block|}
name|long
name|tMid
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
operator|(
operator|(
name|tMid
operator|-
name|tStart
operator|)
operator|/
literal|1000.0
operator|)
operator|+
literal|" sec to add all terms"
argument_list|)
expr_stmt|;
assert|assert
name|builder
operator|.
name|getTermCount
argument_list|()
operator|==
name|ord
assert|;
name|FST
argument_list|<
name|T
argument_list|>
name|fst
init|=
name|builder
operator|.
name|finish
argument_list|()
decl_stmt|;
name|long
name|tEnd
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
operator|(
operator|(
name|tEnd
operator|-
name|tMid
operator|)
operator|/
literal|1000.0
operator|)
operator|+
literal|" sec to finish/pack"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fst
operator|==
literal|null
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"FST was fully pruned!"
argument_list|)
expr_stmt|;
name|System
operator|.
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dirOut
operator|==
literal|null
condition|)
block|{
return|return;
block|}
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
name|ord
operator|+
literal|" terms; "
operator|+
name|fst
operator|.
name|getNodeCount
argument_list|()
operator|+
literal|" nodes; "
operator|+
name|fst
operator|.
name|getArcCount
argument_list|()
operator|+
literal|" arcs; "
operator|+
name|fst
operator|.
name|getArcWithOutputCount
argument_list|()
operator|+
literal|" arcs w/ output; tot size "
operator|+
name|fst
operator|.
name|ramBytesUsed
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|fst
operator|.
name|getNodeCount
argument_list|()
operator|<
literal|100
condition|)
block|{
name|Writer
name|w
init|=
name|Files
operator|.
name|newBufferedWriter
argument_list|(
name|Paths
operator|.
name|get
argument_list|(
literal|"out.dot"
argument_list|)
argument_list|,
name|StandardCharsets
operator|.
name|UTF_8
argument_list|)
decl_stmt|;
name|Util
operator|.
name|toDot
argument_list|(
name|fst
argument_list|,
name|w
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|w
operator|.
name|close
argument_list|()
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Wrote FST to out.dot"
argument_list|)
expr_stmt|;
block|}
name|Directory
name|dir
init|=
name|FSDirectory
operator|.
name|open
argument_list|(
name|dirOut
argument_list|)
decl_stmt|;
name|IndexOutput
name|out
init|=
name|dir
operator|.
name|createOutput
argument_list|(
literal|"fst.bin"
argument_list|,
name|IOContext
operator|.
name|DEFAULT
argument_list|)
decl_stmt|;
name|fst
operator|.
name|save
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|out
operator|.
name|close
argument_list|()
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Saved FST to fst.bin."
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|verify
condition|)
block|{
return|return;
block|}
comment|/*         IndexInput in = dir.openInput("fst.bin", IOContext.DEFAULT);         fst = new FST<T>(in, outputs);         in.close();         */
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"\nNow verify..."
argument_list|)
expr_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
for|for
control|(
name|int
name|iter
init|=
literal|0
init|;
name|iter
operator|<
literal|2
condition|;
name|iter
operator|++
control|)
block|{
name|is
operator|.
name|close
argument_list|()
expr_stmt|;
name|is
operator|=
name|Files
operator|.
name|newBufferedReader
argument_list|(
name|wordsFileIn
argument_list|,
name|StandardCharsets
operator|.
name|UTF_8
argument_list|)
expr_stmt|;
name|ord
operator|=
literal|0
expr_stmt|;
name|tStart
operator|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
expr_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|String
name|w
init|=
name|is
operator|.
name|readLine
argument_list|()
decl_stmt|;
if|if
condition|(
name|w
operator|==
literal|null
condition|)
block|{
break|break;
block|}
name|toIntsRef
argument_list|(
name|w
argument_list|,
name|inputMode
argument_list|,
name|intsRef
argument_list|)
expr_stmt|;
if|if
condition|(
name|iter
operator|==
literal|0
condition|)
block|{
name|T
name|expected
init|=
name|getOutput
argument_list|(
name|intsRef
operator|.
name|get
argument_list|()
argument_list|,
name|ord
argument_list|)
decl_stmt|;
name|T
name|actual
init|=
name|Util
operator|.
name|get
argument_list|(
name|fst
argument_list|,
name|intsRef
operator|.
name|get
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|actual
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"unexpected null output on input="
operator|+
name|w
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|actual
operator|.
name|equals
argument_list|(
name|expected
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"wrong output (got "
operator|+
name|outputs
operator|.
name|outputToString
argument_list|(
name|actual
argument_list|)
operator|+
literal|" but expected "
operator|+
name|outputs
operator|.
name|outputToString
argument_list|(
name|expected
argument_list|)
operator|+
literal|") on input="
operator|+
name|w
argument_list|)
throw|;
block|}
block|}
else|else
block|{
comment|// Get by output
specifier|final
name|Long
name|output
init|=
operator|(
name|Long
operator|)
name|getOutput
argument_list|(
name|intsRef
operator|.
name|get
argument_list|()
argument_list|,
name|ord
argument_list|)
decl_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|final
name|IntsRef
name|actual
init|=
name|Util
operator|.
name|getByOutput
argument_list|(
operator|(
name|FST
argument_list|<
name|Long
argument_list|>
operator|)
name|fst
argument_list|,
name|output
operator|.
name|longValue
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|actual
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"unexpected null input from output="
operator|+
name|output
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|actual
operator|.
name|equals
argument_list|(
name|intsRef
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"wrong input (got "
operator|+
name|actual
operator|+
literal|" but expected "
operator|+
name|intsRef
operator|+
literal|" from output="
operator|+
name|output
argument_list|)
throw|;
block|}
block|}
name|ord
operator|++
expr_stmt|;
if|if
condition|(
name|ord
operator|%
literal|500000
operator|==
literal|0
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
operator|(
operator|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|-
name|tStart
operator|)
operator|/
literal|1000.0
operator|)
operator|+
literal|"s: "
operator|+
name|ord
operator|+
literal|"..."
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ord
operator|>=
name|limit
condition|)
block|{
break|break;
block|}
block|}
name|double
name|totSec
init|=
operator|(
operator|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|-
name|tStart
operator|)
operator|/
literal|1000.0
operator|)
decl_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Verify "
operator|+
operator|(
name|iter
operator|==
literal|1
condition|?
literal|"(by output) "
else|:
literal|""
operator|)
operator|+
literal|"took "
operator|+
name|totSec
operator|+
literal|" sec + ("
operator|+
call|(
name|int
call|)
argument_list|(
operator|(
name|totSec
operator|*
literal|1000000000
operator|/
name|ord
operator|)
argument_list|)
operator|+
literal|" nsec per lookup)"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|verifyByOutput
condition|)
block|{
break|break;
block|}
block|}
comment|// NOTE: comment out to profile lookup...
break|break;
block|}
block|}
finally|finally
block|{
name|is
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|// TODO: try experiment: reverse terms before
comment|// compressing -- how much smaller?
comment|// TODO: can FST be used to index all internal substrings,
comment|// mapping to term?
comment|// java -cp ../build/codecs/classes/java:../test-framework/lib/randomizedtesting-runner-*.jar:../build/core/classes/test:../build/core/classes/test-framework:../build/core/classes/java:../build/test-framework/classes/java:../test-framework/lib/junit-4.10.jar org.apache.lucene.util.fst.TestFSTs /xold/tmp/allTerms3.txt out
DECL|method|main
specifier|public
specifier|static
name|void
name|main
parameter_list|(
name|String
index|[]
name|args
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|prune
init|=
literal|0
decl_stmt|;
name|int
name|limit
init|=
name|Integer
operator|.
name|MAX_VALUE
decl_stmt|;
name|int
name|inputMode
init|=
literal|0
decl_stmt|;
comment|// utf8
name|boolean
name|storeOrds
init|=
literal|false
decl_stmt|;
name|boolean
name|storeDocFreqs
init|=
literal|false
decl_stmt|;
name|boolean
name|verify
init|=
literal|true
decl_stmt|;
name|boolean
name|doPack
init|=
literal|false
decl_stmt|;
name|boolean
name|noArcArrays
init|=
literal|false
decl_stmt|;
name|Path
name|wordsFileIn
init|=
literal|null
decl_stmt|;
name|Path
name|dirOut
init|=
literal|null
decl_stmt|;
name|int
name|idx
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|idx
operator|<
name|args
operator|.
name|length
condition|)
block|{
if|if
condition|(
name|args
index|[
name|idx
index|]
operator|.
name|equals
argument_list|(
literal|"-prune"
argument_list|)
condition|)
block|{
name|prune
operator|=
name|Integer
operator|.
name|valueOf
argument_list|(
name|args
index|[
literal|1
operator|+
name|idx
index|]
argument_list|)
expr_stmt|;
name|idx
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|args
index|[
name|idx
index|]
operator|.
name|equals
argument_list|(
literal|"-limit"
argument_list|)
condition|)
block|{
name|limit
operator|=
name|Integer
operator|.
name|valueOf
argument_list|(
name|args
index|[
literal|1
operator|+
name|idx
index|]
argument_list|)
expr_stmt|;
name|idx
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|args
index|[
name|idx
index|]
operator|.
name|equals
argument_list|(
literal|"-utf8"
argument_list|)
condition|)
block|{
name|inputMode
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|args
index|[
name|idx
index|]
operator|.
name|equals
argument_list|(
literal|"-utf32"
argument_list|)
condition|)
block|{
name|inputMode
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|args
index|[
name|idx
index|]
operator|.
name|equals
argument_list|(
literal|"-docFreq"
argument_list|)
condition|)
block|{
name|storeDocFreqs
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|args
index|[
name|idx
index|]
operator|.
name|equals
argument_list|(
literal|"-noArcArrays"
argument_list|)
condition|)
block|{
name|noArcArrays
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|args
index|[
name|idx
index|]
operator|.
name|equals
argument_list|(
literal|"-ords"
argument_list|)
condition|)
block|{
name|storeOrds
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|args
index|[
name|idx
index|]
operator|.
name|equals
argument_list|(
literal|"-noverify"
argument_list|)
condition|)
block|{
name|verify
operator|=
literal|false
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|args
index|[
name|idx
index|]
operator|.
name|equals
argument_list|(
literal|"-pack"
argument_list|)
condition|)
block|{
name|doPack
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|args
index|[
name|idx
index|]
operator|.
name|startsWith
argument_list|(
literal|"-"
argument_list|)
condition|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"Unrecognized option: "
operator|+
name|args
index|[
name|idx
index|]
argument_list|)
expr_stmt|;
name|System
operator|.
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|wordsFileIn
operator|==
literal|null
condition|)
block|{
name|wordsFileIn
operator|=
name|Paths
operator|.
name|get
argument_list|(
name|args
index|[
name|idx
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dirOut
operator|==
literal|null
condition|)
block|{
name|dirOut
operator|=
name|Paths
operator|.
name|get
argument_list|(
name|args
index|[
name|idx
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"Too many arguments, expected: input [output]"
argument_list|)
expr_stmt|;
name|System
operator|.
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|idx
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|wordsFileIn
operator|==
literal|null
condition|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"No input file."
argument_list|)
expr_stmt|;
name|System
operator|.
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|// ord benefits from share, docFreqs don't:
if|if
condition|(
name|storeOrds
operator|&&
name|storeDocFreqs
condition|)
block|{
comment|// Store both ord& docFreq:
specifier|final
name|PositiveIntOutputs
name|o1
init|=
name|PositiveIntOutputs
operator|.
name|getSingleton
argument_list|()
decl_stmt|;
specifier|final
name|PositiveIntOutputs
name|o2
init|=
name|PositiveIntOutputs
operator|.
name|getSingleton
argument_list|()
decl_stmt|;
specifier|final
name|PairOutputs
argument_list|<
name|Long
argument_list|,
name|Long
argument_list|>
name|outputs
init|=
operator|new
name|PairOutputs
argument_list|<>
argument_list|(
name|o1
argument_list|,
name|o2
argument_list|)
decl_stmt|;
operator|new
name|VisitTerms
argument_list|<
name|PairOutputs
operator|.
name|Pair
argument_list|<
name|Long
argument_list|,
name|Long
argument_list|>
argument_list|>
argument_list|(
name|dirOut
argument_list|,
name|wordsFileIn
argument_list|,
name|inputMode
argument_list|,
name|prune
argument_list|,
name|outputs
argument_list|,
name|doPack
argument_list|,
name|noArcArrays
argument_list|)
block|{
name|Random
name|rand
decl_stmt|;
annotation|@
name|Override
specifier|public
name|PairOutputs
operator|.
name|Pair
argument_list|<
name|Long
argument_list|,
name|Long
argument_list|>
name|getOutput
parameter_list|(
name|IntsRef
name|input
parameter_list|,
name|int
name|ord
parameter_list|)
block|{
if|if
condition|(
name|ord
operator|==
literal|0
condition|)
block|{
name|rand
operator|=
operator|new
name|Random
argument_list|(
literal|17
argument_list|)
expr_stmt|;
block|}
return|return
name|outputs
operator|.
name|newPair
argument_list|(
operator|(
name|long
operator|)
name|ord
argument_list|,
operator|(
name|long
operator|)
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|rand
argument_list|,
literal|1
argument_list|,
literal|5000
argument_list|)
argument_list|)
return|;
block|}
block|}
operator|.
name|run
argument_list|(
name|limit
argument_list|,
name|verify
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|storeOrds
condition|)
block|{
comment|// Store only ords
specifier|final
name|PositiveIntOutputs
name|outputs
init|=
name|PositiveIntOutputs
operator|.
name|getSingleton
argument_list|()
decl_stmt|;
operator|new
name|VisitTerms
argument_list|<
name|Long
argument_list|>
argument_list|(
name|dirOut
argument_list|,
name|wordsFileIn
argument_list|,
name|inputMode
argument_list|,
name|prune
argument_list|,
name|outputs
argument_list|,
name|doPack
argument_list|,
name|noArcArrays
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|Long
name|getOutput
parameter_list|(
name|IntsRef
name|input
parameter_list|,
name|int
name|ord
parameter_list|)
block|{
return|return
operator|(
name|long
operator|)
name|ord
return|;
block|}
block|}
operator|.
name|run
argument_list|(
name|limit
argument_list|,
name|verify
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|storeDocFreqs
condition|)
block|{
comment|// Store only docFreq
specifier|final
name|PositiveIntOutputs
name|outputs
init|=
name|PositiveIntOutputs
operator|.
name|getSingleton
argument_list|()
decl_stmt|;
operator|new
name|VisitTerms
argument_list|<
name|Long
argument_list|>
argument_list|(
name|dirOut
argument_list|,
name|wordsFileIn
argument_list|,
name|inputMode
argument_list|,
name|prune
argument_list|,
name|outputs
argument_list|,
name|doPack
argument_list|,
name|noArcArrays
argument_list|)
block|{
name|Random
name|rand
decl_stmt|;
annotation|@
name|Override
specifier|public
name|Long
name|getOutput
parameter_list|(
name|IntsRef
name|input
parameter_list|,
name|int
name|ord
parameter_list|)
block|{
if|if
condition|(
name|ord
operator|==
literal|0
condition|)
block|{
name|rand
operator|=
operator|new
name|Random
argument_list|(
literal|17
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|long
operator|)
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|rand
argument_list|,
literal|1
argument_list|,
literal|5000
argument_list|)
return|;
block|}
block|}
operator|.
name|run
argument_list|(
name|limit
argument_list|,
name|verify
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Store nothing
specifier|final
name|NoOutputs
name|outputs
init|=
name|NoOutputs
operator|.
name|getSingleton
argument_list|()
decl_stmt|;
specifier|final
name|Object
name|NO_OUTPUT
init|=
name|outputs
operator|.
name|getNoOutput
argument_list|()
decl_stmt|;
operator|new
name|VisitTerms
argument_list|<
name|Object
argument_list|>
argument_list|(
name|dirOut
argument_list|,
name|wordsFileIn
argument_list|,
name|inputMode
argument_list|,
name|prune
argument_list|,
name|outputs
argument_list|,
name|doPack
argument_list|,
name|noArcArrays
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|Object
name|getOutput
parameter_list|(
name|IntsRef
name|input
parameter_list|,
name|int
name|ord
parameter_list|)
block|{
return|return
name|NO_OUTPUT
return|;
block|}
block|}
operator|.
name|run
argument_list|(
name|limit
argument_list|,
name|verify
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|testSingleString
specifier|public
name|void
name|testSingleString
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|Outputs
argument_list|<
name|Object
argument_list|>
name|outputs
init|=
name|NoOutputs
operator|.
name|getSingleton
argument_list|()
decl_stmt|;
specifier|final
name|Builder
argument_list|<
name|Object
argument_list|>
name|b
init|=
operator|new
name|Builder
argument_list|<>
argument_list|(
name|FST
operator|.
name|INPUT_TYPE
operator|.
name|BYTE1
argument_list|,
name|outputs
argument_list|)
decl_stmt|;
name|b
operator|.
name|add
argument_list|(
name|Util
operator|.
name|toIntsRef
argument_list|(
operator|new
name|BytesRef
argument_list|(
literal|"foobar"
argument_list|)
argument_list|,
operator|new
name|IntsRefBuilder
argument_list|()
argument_list|)
argument_list|,
name|outputs
operator|.
name|getNoOutput
argument_list|()
argument_list|)
expr_stmt|;
specifier|final
name|BytesRefFSTEnum
argument_list|<
name|Object
argument_list|>
name|fstEnum
init|=
operator|new
name|BytesRefFSTEnum
argument_list|<>
argument_list|(
name|b
operator|.
name|finish
argument_list|()
argument_list|)
decl_stmt|;
name|assertNull
argument_list|(
name|fstEnum
operator|.
name|seekFloor
argument_list|(
operator|new
name|BytesRef
argument_list|(
literal|"foo"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|assertNull
argument_list|(
name|fstEnum
operator|.
name|seekCeil
argument_list|(
operator|new
name|BytesRef
argument_list|(
literal|"foobaz"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|testDuplicateFSAString
specifier|public
name|void
name|testDuplicateFSAString
parameter_list|()
throws|throws
name|Exception
block|{
name|String
name|str
init|=
literal|"foobar"
decl_stmt|;
specifier|final
name|Outputs
argument_list|<
name|Object
argument_list|>
name|outputs
init|=
name|NoOutputs
operator|.
name|getSingleton
argument_list|()
decl_stmt|;
specifier|final
name|Builder
argument_list|<
name|Object
argument_list|>
name|b
init|=
operator|new
name|Builder
argument_list|<>
argument_list|(
name|FST
operator|.
name|INPUT_TYPE
operator|.
name|BYTE1
argument_list|,
name|outputs
argument_list|)
decl_stmt|;
name|IntsRefBuilder
name|ints
init|=
operator|new
name|IntsRefBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|10
condition|;
name|i
operator|++
control|)
block|{
name|b
operator|.
name|add
argument_list|(
name|Util
operator|.
name|toIntsRef
argument_list|(
operator|new
name|BytesRef
argument_list|(
name|str
argument_list|)
argument_list|,
name|ints
argument_list|)
argument_list|,
name|outputs
operator|.
name|getNoOutput
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|FST
argument_list|<
name|Object
argument_list|>
name|fst
init|=
name|b
operator|.
name|finish
argument_list|()
decl_stmt|;
comment|// count the input paths
name|int
name|count
init|=
literal|0
decl_stmt|;
specifier|final
name|BytesRefFSTEnum
argument_list|<
name|Object
argument_list|>
name|fstEnum
init|=
operator|new
name|BytesRefFSTEnum
argument_list|<>
argument_list|(
name|fst
argument_list|)
decl_stmt|;
while|while
condition|(
name|fstEnum
operator|.
name|next
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|count
operator|++
expr_stmt|;
block|}
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|assertNotNull
argument_list|(
name|Util
operator|.
name|get
argument_list|(
name|fst
argument_list|,
operator|new
name|BytesRef
argument_list|(
name|str
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|assertNull
argument_list|(
name|Util
operator|.
name|get
argument_list|(
name|fst
argument_list|,
operator|new
name|BytesRef
argument_list|(
literal|"foobaz"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/*   public void testTrivial() throws Exception {      // Get outputs -- passing true means FST will share     // (delta code) the outputs.  This should result in     // smaller FST if the outputs grow monotonically.  But     // if numbers are "random", false should give smaller     // final size:     final NoOutputs outputs = NoOutputs.getSingleton();      String[] strings = new String[] {"station", "commotion", "elation", "elastic", "plastic", "stop", "ftop", "ftation", "stat"};      final Builder<Object> builder = new Builder<Object>(FST.INPUT_TYPE.BYTE1,                                                         0, 0,                                                         true,                                                         true,                                                         Integer.MAX_VALUE,                                                         outputs,                                                         null,                                                         true);     Arrays.sort(strings);     final IntsRef scratch = new IntsRef();     for(String s : strings) {       builder.add(Util.toIntsRef(new BytesRef(s), scratch), outputs.getNoOutput());     }     final FST<Object> fst = builder.finish();     System.out.println("DOT before rewrite");     Writer w = new OutputStreamWriter(new FileOutputStream("/mnt/scratch/before.dot"));     Util.toDot(fst, w, false, false);     w.close();      final FST<Object> rewrite = new FST<Object>(fst, 1, 100);      System.out.println("DOT after rewrite");     w = new OutputStreamWriter(new FileOutputStream("/mnt/scratch/after.dot"));     Util.toDot(rewrite, w, false, false);     w.close();   }   */
DECL|method|testSimple
specifier|public
name|void
name|testSimple
parameter_list|()
throws|throws
name|Exception
block|{
comment|// Get outputs -- passing true means FST will share
comment|// (delta code) the outputs.  This should result in
comment|// smaller FST if the outputs grow monotonically.  But
comment|// if numbers are "random", false should give smaller
comment|// final size:
specifier|final
name|PositiveIntOutputs
name|outputs
init|=
name|PositiveIntOutputs
operator|.
name|getSingleton
argument_list|()
decl_stmt|;
comment|// Build an FST mapping BytesRef -> Long
specifier|final
name|Builder
argument_list|<
name|Long
argument_list|>
name|builder
init|=
operator|new
name|Builder
argument_list|<>
argument_list|(
name|FST
operator|.
name|INPUT_TYPE
operator|.
name|BYTE1
argument_list|,
name|outputs
argument_list|)
decl_stmt|;
specifier|final
name|BytesRef
name|a
init|=
operator|new
name|BytesRef
argument_list|(
literal|"a"
argument_list|)
decl_stmt|;
specifier|final
name|BytesRef
name|b
init|=
operator|new
name|BytesRef
argument_list|(
literal|"b"
argument_list|)
decl_stmt|;
specifier|final
name|BytesRef
name|c
init|=
operator|new
name|BytesRef
argument_list|(
literal|"c"
argument_list|)
decl_stmt|;
name|builder
operator|.
name|add
argument_list|(
name|Util
operator|.
name|toIntsRef
argument_list|(
name|a
argument_list|,
operator|new
name|IntsRefBuilder
argument_list|()
argument_list|)
argument_list|,
literal|17L
argument_list|)
expr_stmt|;
name|builder
operator|.
name|add
argument_list|(
name|Util
operator|.
name|toIntsRef
argument_list|(
name|b
argument_list|,
operator|new
name|IntsRefBuilder
argument_list|()
argument_list|)
argument_list|,
literal|42L
argument_list|)
expr_stmt|;
name|builder
operator|.
name|add
argument_list|(
name|Util
operator|.
name|toIntsRef
argument_list|(
name|c
argument_list|,
operator|new
name|IntsRefBuilder
argument_list|()
argument_list|)
argument_list|,
literal|13824324872317238L
argument_list|)
expr_stmt|;
specifier|final
name|FST
argument_list|<
name|Long
argument_list|>
name|fst
init|=
name|builder
operator|.
name|finish
argument_list|()
decl_stmt|;
name|assertEquals
argument_list|(
literal|13824324872317238L
argument_list|,
operator|(
name|long
operator|)
name|Util
operator|.
name|get
argument_list|(
name|fst
argument_list|,
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|42
argument_list|,
operator|(
name|long
operator|)
name|Util
operator|.
name|get
argument_list|(
name|fst
argument_list|,
name|b
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|17
argument_list|,
operator|(
name|long
operator|)
name|Util
operator|.
name|get
argument_list|(
name|fst
argument_list|,
name|a
argument_list|)
argument_list|)
expr_stmt|;
name|BytesRefFSTEnum
argument_list|<
name|Long
argument_list|>
name|fstEnum
init|=
operator|new
name|BytesRefFSTEnum
argument_list|<>
argument_list|(
name|fst
argument_list|)
decl_stmt|;
name|BytesRefFSTEnum
operator|.
name|InputOutput
argument_list|<
name|Long
argument_list|>
name|seekResult
decl_stmt|;
name|seekResult
operator|=
name|fstEnum
operator|.
name|seekFloor
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|assertNotNull
argument_list|(
name|seekResult
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|17
argument_list|,
operator|(
name|long
operator|)
name|seekResult
operator|.
name|output
argument_list|)
expr_stmt|;
comment|// goes to a
name|seekResult
operator|=
name|fstEnum
operator|.
name|seekFloor
argument_list|(
operator|new
name|BytesRef
argument_list|(
literal|"aa"
argument_list|)
argument_list|)
expr_stmt|;
name|assertNotNull
argument_list|(
name|seekResult
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|17
argument_list|,
operator|(
name|long
operator|)
name|seekResult
operator|.
name|output
argument_list|)
expr_stmt|;
comment|// goes to b
name|seekResult
operator|=
name|fstEnum
operator|.
name|seekCeil
argument_list|(
operator|new
name|BytesRef
argument_list|(
literal|"aa"
argument_list|)
argument_list|)
expr_stmt|;
name|assertNotNull
argument_list|(
name|seekResult
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|b
argument_list|,
name|seekResult
operator|.
name|input
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|42
argument_list|,
operator|(
name|long
operator|)
name|seekResult
operator|.
name|output
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|Util
operator|.
name|toIntsRef
argument_list|(
operator|new
name|BytesRef
argument_list|(
literal|"c"
argument_list|)
argument_list|,
operator|new
name|IntsRefBuilder
argument_list|()
argument_list|)
argument_list|,
name|Util
operator|.
name|getByOutput
argument_list|(
name|fst
argument_list|,
literal|13824324872317238L
argument_list|)
argument_list|)
expr_stmt|;
name|assertNull
argument_list|(
name|Util
operator|.
name|getByOutput
argument_list|(
name|fst
argument_list|,
literal|47
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|Util
operator|.
name|toIntsRef
argument_list|(
operator|new
name|BytesRef
argument_list|(
literal|"b"
argument_list|)
argument_list|,
operator|new
name|IntsRefBuilder
argument_list|()
argument_list|)
argument_list|,
name|Util
operator|.
name|getByOutput
argument_list|(
name|fst
argument_list|,
literal|42
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|Util
operator|.
name|toIntsRef
argument_list|(
operator|new
name|BytesRef
argument_list|(
literal|"a"
argument_list|)
argument_list|,
operator|new
name|IntsRefBuilder
argument_list|()
argument_list|)
argument_list|,
name|Util
operator|.
name|getByOutput
argument_list|(
name|fst
argument_list|,
literal|17
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|testPrimaryKeys
specifier|public
name|void
name|testPrimaryKeys
parameter_list|()
throws|throws
name|Exception
block|{
name|Directory
name|dir
init|=
name|newDirectory
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|cycle
init|=
literal|0
init|;
name|cycle
operator|<
literal|2
condition|;
name|cycle
operator|++
control|)
block|{
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"TEST: cycle="
operator|+
name|cycle
argument_list|)
expr_stmt|;
block|}
name|RandomIndexWriter
name|w
init|=
operator|new
name|RandomIndexWriter
argument_list|(
name|random
argument_list|()
argument_list|,
name|dir
argument_list|,
name|newIndexWriterConfig
argument_list|(
operator|new
name|MockAnalyzer
argument_list|(
name|random
argument_list|()
argument_list|)
argument_list|)
operator|.
name|setOpenMode
argument_list|(
name|IndexWriterConfig
operator|.
name|OpenMode
operator|.
name|CREATE
argument_list|)
argument_list|)
decl_stmt|;
name|Document
name|doc
init|=
operator|new
name|Document
argument_list|()
decl_stmt|;
name|Field
name|idField
init|=
name|newStringField
argument_list|(
literal|"id"
argument_list|,
literal|""
argument_list|,
name|Field
operator|.
name|Store
operator|.
name|NO
argument_list|)
decl_stmt|;
name|doc
operator|.
name|add
argument_list|(
name|idField
argument_list|)
expr_stmt|;
specifier|final
name|int
name|NUM_IDS
init|=
name|atLeast
argument_list|(
literal|200
argument_list|)
decl_stmt|;
comment|//final int NUM_IDS = (int) (377 * (1.0+random.nextDouble()));
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"TEST: NUM_IDS="
operator|+
name|NUM_IDS
argument_list|)
expr_stmt|;
block|}
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|allIDs
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|id
init|=
literal|0
init|;
name|id
operator|<
name|NUM_IDS
condition|;
name|id
operator|++
control|)
block|{
name|String
name|idString
decl_stmt|;
if|if
condition|(
name|cycle
operator|==
literal|0
condition|)
block|{
comment|// PKs are assigned sequentially
name|idString
operator|=
name|String
operator|.
name|format
argument_list|(
name|Locale
operator|.
name|ROOT
argument_list|,
literal|"%07d"
argument_list|,
name|id
argument_list|)
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
literal|true
condition|)
block|{
specifier|final
name|String
name|s
init|=
name|Long
operator|.
name|toString
argument_list|(
name|random
argument_list|()
operator|.
name|nextLong
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|allIDs
operator|.
name|contains
argument_list|(
name|s
argument_list|)
condition|)
block|{
name|idString
operator|=
name|s
expr_stmt|;
break|break;
block|}
block|}
block|}
name|allIDs
operator|.
name|add
argument_list|(
name|idString
argument_list|)
expr_stmt|;
name|idField
operator|.
name|setStringValue
argument_list|(
name|idString
argument_list|)
expr_stmt|;
name|w
operator|.
name|addDocument
argument_list|(
name|doc
argument_list|)
expr_stmt|;
block|}
comment|//w.forceMerge(1);
comment|// turn writer into reader:
specifier|final
name|IndexReader
name|r
init|=
name|w
operator|.
name|getReader
argument_list|()
decl_stmt|;
specifier|final
name|IndexSearcher
name|s
init|=
name|newSearcher
argument_list|(
name|r
argument_list|)
decl_stmt|;
name|w
operator|.
name|close
argument_list|()
expr_stmt|;
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|allIDsList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|allIDs
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|sortedAllIDsList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|allIDsList
argument_list|)
decl_stmt|;
name|Collections
operator|.
name|sort
argument_list|(
name|sortedAllIDsList
argument_list|)
expr_stmt|;
comment|// Sprinkle in some non-existent PKs:
name|Set
argument_list|<
name|String
argument_list|>
name|outOfBounds
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|idx
init|=
literal|0
init|;
name|idx
operator|<
name|NUM_IDS
operator|/
literal|10
condition|;
name|idx
operator|++
control|)
block|{
name|String
name|idString
decl_stmt|;
if|if
condition|(
name|cycle
operator|==
literal|0
condition|)
block|{
name|idString
operator|=
name|String
operator|.
name|format
argument_list|(
name|Locale
operator|.
name|ROOT
argument_list|,
literal|"%07d"
argument_list|,
operator|(
name|NUM_IDS
operator|+
name|idx
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
literal|true
condition|)
block|{
name|idString
operator|=
name|Long
operator|.
name|toString
argument_list|(
name|random
argument_list|()
operator|.
name|nextLong
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|allIDs
operator|.
name|contains
argument_list|(
name|idString
argument_list|)
condition|)
block|{
break|break;
block|}
block|}
block|}
name|outOfBounds
operator|.
name|add
argument_list|(
name|idString
argument_list|)
expr_stmt|;
name|allIDsList
operator|.
name|add
argument_list|(
name|idString
argument_list|)
expr_stmt|;
block|}
comment|// Verify w/ TermQuery
for|for
control|(
name|int
name|iter
init|=
literal|0
init|;
name|iter
operator|<
literal|2
operator|*
name|NUM_IDS
condition|;
name|iter
operator|++
control|)
block|{
specifier|final
name|String
name|id
init|=
name|allIDsList
operator|.
name|get
argument_list|(
name|random
argument_list|()
operator|.
name|nextInt
argument_list|(
name|allIDsList
operator|.
name|size
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|boolean
name|exists
init|=
operator|!
name|outOfBounds
operator|.
name|contains
argument_list|(
name|id
argument_list|)
decl_stmt|;
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"TEST: TermQuery "
operator|+
operator|(
name|exists
condition|?
literal|""
else|:
literal|"non-exist "
operator|)
operator|+
literal|" id="
operator|+
name|id
argument_list|)
expr_stmt|;
block|}
name|assertEquals
argument_list|(
operator|(
name|exists
condition|?
literal|""
else|:
literal|"non-exist "
operator|)
operator|+
literal|"id="
operator|+
name|id
argument_list|,
name|exists
condition|?
literal|1
else|:
literal|0
argument_list|,
name|s
operator|.
name|search
argument_list|(
operator|new
name|TermQuery
argument_list|(
operator|new
name|Term
argument_list|(
literal|"id"
argument_list|,
name|id
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|.
name|totalHits
argument_list|)
expr_stmt|;
block|}
comment|// Verify w/ MultiTermsEnum
specifier|final
name|TermsEnum
name|termsEnum
init|=
name|MultiFields
operator|.
name|getTerms
argument_list|(
name|r
argument_list|,
literal|"id"
argument_list|)
operator|.
name|iterator
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|iter
init|=
literal|0
init|;
name|iter
operator|<
literal|2
operator|*
name|NUM_IDS
condition|;
name|iter
operator|++
control|)
block|{
specifier|final
name|String
name|id
decl_stmt|;
specifier|final
name|String
name|nextID
decl_stmt|;
specifier|final
name|boolean
name|exists
decl_stmt|;
if|if
condition|(
name|random
argument_list|()
operator|.
name|nextBoolean
argument_list|()
condition|)
block|{
name|id
operator|=
name|allIDsList
operator|.
name|get
argument_list|(
name|random
argument_list|()
operator|.
name|nextInt
argument_list|(
name|allIDsList
operator|.
name|size
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|exists
operator|=
operator|!
name|outOfBounds
operator|.
name|contains
argument_list|(
name|id
argument_list|)
expr_stmt|;
name|nextID
operator|=
literal|null
expr_stmt|;
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"TEST: exactOnly "
operator|+
operator|(
name|exists
condition|?
literal|""
else|:
literal|"non-exist "
operator|)
operator|+
literal|"id="
operator|+
name|id
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// Pick ID between two IDs:
name|exists
operator|=
literal|false
expr_stmt|;
specifier|final
name|int
name|idv
init|=
name|random
argument_list|()
operator|.
name|nextInt
argument_list|(
name|NUM_IDS
operator|-
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|cycle
operator|==
literal|0
condition|)
block|{
name|id
operator|=
name|String
operator|.
name|format
argument_list|(
name|Locale
operator|.
name|ROOT
argument_list|,
literal|"%07da"
argument_list|,
name|idv
argument_list|)
expr_stmt|;
name|nextID
operator|=
name|String
operator|.
name|format
argument_list|(
name|Locale
operator|.
name|ROOT
argument_list|,
literal|"%07d"
argument_list|,
name|idv
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|id
operator|=
name|sortedAllIDsList
operator|.
name|get
argument_list|(
name|idv
argument_list|)
operator|+
literal|"a"
expr_stmt|;
name|nextID
operator|=
name|sortedAllIDsList
operator|.
name|get
argument_list|(
name|idv
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"TEST: not exactOnly id="
operator|+
name|id
operator|+
literal|" nextID="
operator|+
name|nextID
argument_list|)
expr_stmt|;
block|}
block|}
specifier|final
name|TermsEnum
operator|.
name|SeekStatus
name|status
decl_stmt|;
if|if
condition|(
name|nextID
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|termsEnum
operator|.
name|seekExact
argument_list|(
operator|new
name|BytesRef
argument_list|(
name|id
argument_list|)
argument_list|)
condition|)
block|{
name|status
operator|=
name|TermsEnum
operator|.
name|SeekStatus
operator|.
name|FOUND
expr_stmt|;
block|}
else|else
block|{
name|status
operator|=
name|TermsEnum
operator|.
name|SeekStatus
operator|.
name|NOT_FOUND
expr_stmt|;
block|}
block|}
else|else
block|{
name|status
operator|=
name|termsEnum
operator|.
name|seekCeil
argument_list|(
operator|new
name|BytesRef
argument_list|(
name|id
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nextID
operator|!=
literal|null
condition|)
block|{
name|assertEquals
argument_list|(
name|TermsEnum
operator|.
name|SeekStatus
operator|.
name|NOT_FOUND
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"expected="
operator|+
name|nextID
operator|+
literal|" actual="
operator|+
name|termsEnum
operator|.
name|term
argument_list|()
operator|.
name|utf8ToString
argument_list|()
argument_list|,
operator|new
name|BytesRef
argument_list|(
name|nextID
argument_list|)
argument_list|,
name|termsEnum
operator|.
name|term
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|exists
condition|)
block|{
name|assertTrue
argument_list|(
name|status
operator|==
name|TermsEnum
operator|.
name|SeekStatus
operator|.
name|NOT_FOUND
operator|||
name|status
operator|==
name|TermsEnum
operator|.
name|SeekStatus
operator|.
name|END
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|assertEquals
argument_list|(
name|TermsEnum
operator|.
name|SeekStatus
operator|.
name|FOUND
argument_list|,
name|status
argument_list|)
expr_stmt|;
block|}
block|}
name|r
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
name|dir
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
DECL|method|testRandomTermLookup
specifier|public
name|void
name|testRandomTermLookup
parameter_list|()
throws|throws
name|Exception
block|{
name|Directory
name|dir
init|=
name|newDirectory
argument_list|()
decl_stmt|;
name|RandomIndexWriter
name|w
init|=
operator|new
name|RandomIndexWriter
argument_list|(
name|random
argument_list|()
argument_list|,
name|dir
argument_list|,
name|newIndexWriterConfig
argument_list|(
operator|new
name|MockAnalyzer
argument_list|(
name|random
argument_list|()
argument_list|)
argument_list|)
operator|.
name|setOpenMode
argument_list|(
name|IndexWriterConfig
operator|.
name|OpenMode
operator|.
name|CREATE
argument_list|)
argument_list|)
decl_stmt|;
name|Document
name|doc
init|=
operator|new
name|Document
argument_list|()
decl_stmt|;
name|Field
name|f
init|=
name|newStringField
argument_list|(
literal|"field"
argument_list|,
literal|""
argument_list|,
name|Field
operator|.
name|Store
operator|.
name|NO
argument_list|)
decl_stmt|;
name|doc
operator|.
name|add
argument_list|(
name|f
argument_list|)
expr_stmt|;
specifier|final
name|int
name|NUM_TERMS
init|=
call|(
name|int
call|)
argument_list|(
literal|1000
operator|*
name|RANDOM_MULTIPLIER
operator|*
operator|(
literal|1
operator|+
name|random
argument_list|()
operator|.
name|nextDouble
argument_list|()
operator|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"TEST: NUM_TERMS="
operator|+
name|NUM_TERMS
argument_list|)
expr_stmt|;
block|}
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|allTerms
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
while|while
condition|(
name|allTerms
operator|.
name|size
argument_list|()
operator|<
name|NUM_TERMS
condition|)
block|{
name|allTerms
operator|.
name|add
argument_list|(
name|simpleRandomString
argument_list|(
name|random
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|String
name|term
range|:
name|allTerms
control|)
block|{
name|f
operator|.
name|setStringValue
argument_list|(
name|term
argument_list|)
expr_stmt|;
name|w
operator|.
name|addDocument
argument_list|(
name|doc
argument_list|)
expr_stmt|;
block|}
comment|// turn writer into reader:
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"TEST: get reader"
argument_list|)
expr_stmt|;
block|}
name|IndexReader
name|r
init|=
name|w
operator|.
name|getReader
argument_list|()
decl_stmt|;
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"TEST: got reader="
operator|+
name|r
argument_list|)
expr_stmt|;
block|}
name|IndexSearcher
name|s
init|=
name|newSearcher
argument_list|(
name|r
argument_list|)
decl_stmt|;
name|w
operator|.
name|close
argument_list|()
expr_stmt|;
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|allTermsList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|allTerms
argument_list|)
decl_stmt|;
name|Collections
operator|.
name|shuffle
argument_list|(
name|allTermsList
argument_list|,
name|random
argument_list|()
argument_list|)
expr_stmt|;
comment|// verify exact lookup
for|for
control|(
name|String
name|term
range|:
name|allTermsList
control|)
block|{
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"TEST: term="
operator|+
name|term
argument_list|)
expr_stmt|;
block|}
name|assertEquals
argument_list|(
literal|"term="
operator|+
name|term
argument_list|,
literal|1
argument_list|,
name|s
operator|.
name|search
argument_list|(
operator|new
name|TermQuery
argument_list|(
operator|new
name|Term
argument_list|(
literal|"field"
argument_list|,
name|term
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|.
name|totalHits
argument_list|)
expr_stmt|;
block|}
name|r
operator|.
name|close
argument_list|()
expr_stmt|;
name|dir
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
comment|/**    * Test state expansion (array format) on close-to-root states. Creates    * synthetic input that has one expanded state on each level.    *    * @see<a href="https://issues.apache.org/jira/browse/LUCENE-2933">LUCENE-2933</a>    */
DECL|method|testExpandedCloseToRoot
specifier|public
name|void
name|testExpandedCloseToRoot
parameter_list|()
throws|throws
name|Exception
block|{
class|class
name|SyntheticData
block|{
name|FST
argument_list|<
name|Object
argument_list|>
name|compile
parameter_list|(
name|String
index|[]
name|lines
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|NoOutputs
name|outputs
init|=
name|NoOutputs
operator|.
name|getSingleton
argument_list|()
decl_stmt|;
specifier|final
name|Object
name|nothing
init|=
name|outputs
operator|.
name|getNoOutput
argument_list|()
decl_stmt|;
specifier|final
name|Builder
argument_list|<
name|Object
argument_list|>
name|b
init|=
operator|new
name|Builder
argument_list|<>
argument_list|(
name|FST
operator|.
name|INPUT_TYPE
operator|.
name|BYTE1
argument_list|,
name|outputs
argument_list|)
decl_stmt|;
name|int
name|line
init|=
literal|0
decl_stmt|;
specifier|final
name|BytesRefBuilder
name|term
init|=
operator|new
name|BytesRefBuilder
argument_list|()
decl_stmt|;
specifier|final
name|IntsRefBuilder
name|scratchIntsRef
init|=
operator|new
name|IntsRefBuilder
argument_list|()
decl_stmt|;
while|while
condition|(
name|line
operator|<
name|lines
operator|.
name|length
condition|)
block|{
name|String
name|w
init|=
name|lines
index|[
name|line
operator|++
index|]
decl_stmt|;
if|if
condition|(
name|w
operator|==
literal|null
condition|)
block|{
break|break;
block|}
name|term
operator|.
name|copyChars
argument_list|(
name|w
argument_list|)
expr_stmt|;
name|b
operator|.
name|add
argument_list|(
name|Util
operator|.
name|toIntsRef
argument_list|(
name|term
operator|.
name|get
argument_list|()
argument_list|,
name|scratchIntsRef
argument_list|)
argument_list|,
name|nothing
argument_list|)
expr_stmt|;
block|}
return|return
name|b
operator|.
name|finish
argument_list|()
return|;
block|}
name|void
name|generate
parameter_list|(
name|ArrayList
argument_list|<
name|String
argument_list|>
name|out
parameter_list|,
name|StringBuilder
name|b
parameter_list|,
name|char
name|from
parameter_list|,
name|char
name|to
parameter_list|,
name|int
name|depth
parameter_list|)
block|{
if|if
condition|(
name|depth
operator|==
literal|0
operator|||
name|from
operator|==
name|to
condition|)
block|{
name|String
name|seq
init|=
name|b
operator|.
name|toString
argument_list|()
operator|+
literal|"_"
operator|+
name|out
operator|.
name|size
argument_list|()
operator|+
literal|"_end"
decl_stmt|;
name|out
operator|.
name|add
argument_list|(
name|seq
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|char
name|c
init|=
name|from
init|;
name|c
operator|<=
name|to
condition|;
name|c
operator|++
control|)
block|{
name|b
operator|.
name|append
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|generate
argument_list|(
name|out
argument_list|,
name|b
argument_list|,
name|from
argument_list|,
name|c
operator|==
name|to
condition|?
name|to
else|:
name|from
argument_list|,
name|depth
operator|-
literal|1
argument_list|)
expr_stmt|;
name|b
operator|.
name|deleteCharAt
argument_list|(
name|b
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|public
name|int
name|verifyStateAndBelow
parameter_list|(
name|FST
argument_list|<
name|Object
argument_list|>
name|fst
parameter_list|,
name|Arc
argument_list|<
name|Object
argument_list|>
name|arc
parameter_list|,
name|int
name|depth
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|FST
operator|.
name|targetHasArcs
argument_list|(
name|arc
argument_list|)
condition|)
block|{
name|int
name|childCount
init|=
literal|0
decl_stmt|;
name|BytesReader
name|fstReader
init|=
name|fst
operator|.
name|getBytesReader
argument_list|()
decl_stmt|;
for|for
control|(
name|arc
operator|=
name|fst
operator|.
name|readFirstTargetArc
argument_list|(
name|arc
argument_list|,
name|arc
argument_list|,
name|fstReader
argument_list|)
init|;
condition|;
name|arc
operator|=
name|fst
operator|.
name|readNextArc
argument_list|(
name|arc
argument_list|,
name|fstReader
argument_list|)
operator|,
name|childCount
operator|++
control|)
block|{
name|boolean
name|expanded
init|=
name|fst
operator|.
name|isExpandedTarget
argument_list|(
name|arc
argument_list|,
name|fstReader
argument_list|)
decl_stmt|;
name|int
name|children
init|=
name|verifyStateAndBelow
argument_list|(
name|fst
argument_list|,
operator|new
name|FST
operator|.
name|Arc
argument_list|<>
argument_list|()
operator|.
name|copyFrom
argument_list|(
name|arc
argument_list|)
argument_list|,
name|depth
operator|+
literal|1
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|expanded
argument_list|,
operator|(
name|depth
operator|<=
name|FST
operator|.
name|FIXED_ARRAY_SHALLOW_DISTANCE
operator|&&
name|children
operator|>=
name|FST
operator|.
name|FIXED_ARRAY_NUM_ARCS_SHALLOW
operator|)
operator|||
name|children
operator|>=
name|FST
operator|.
name|FIXED_ARRAY_NUM_ARCS_DEEP
argument_list|)
expr_stmt|;
if|if
condition|(
name|arc
operator|.
name|isLast
argument_list|()
condition|)
break|break;
block|}
return|return
name|childCount
return|;
block|}
return|return
literal|0
return|;
block|}
block|}
comment|// Sanity check.
name|assertTrue
argument_list|(
name|FST
operator|.
name|FIXED_ARRAY_NUM_ARCS_SHALLOW
operator|<
name|FST
operator|.
name|FIXED_ARRAY_NUM_ARCS_DEEP
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|FST
operator|.
name|FIXED_ARRAY_SHALLOW_DISTANCE
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|SyntheticData
name|s
init|=
operator|new
name|SyntheticData
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|String
argument_list|>
name|out
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|StringBuilder
name|b
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|s
operator|.
name|generate
argument_list|(
name|out
argument_list|,
name|b
argument_list|,
literal|'a'
argument_list|,
literal|'i'
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|String
index|[]
name|input
init|=
name|out
operator|.
name|toArray
argument_list|(
operator|new
name|String
index|[
name|out
operator|.
name|size
argument_list|()
index|]
argument_list|)
decl_stmt|;
name|Arrays
operator|.
name|sort
argument_list|(
name|input
argument_list|)
expr_stmt|;
name|FST
argument_list|<
name|Object
argument_list|>
name|fst
init|=
name|s
operator|.
name|compile
argument_list|(
name|input
argument_list|)
decl_stmt|;
name|FST
operator|.
name|Arc
argument_list|<
name|Object
argument_list|>
name|arc
init|=
name|fst
operator|.
name|getFirstArc
argument_list|(
operator|new
name|FST
operator|.
name|Arc
argument_list|<>
argument_list|()
argument_list|)
decl_stmt|;
name|s
operator|.
name|verifyStateAndBelow
argument_list|(
name|fst
argument_list|,
name|arc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
DECL|method|testFinalOutputOnEndState
specifier|public
name|void
name|testFinalOutputOnEndState
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|PositiveIntOutputs
name|outputs
init|=
name|PositiveIntOutputs
operator|.
name|getSingleton
argument_list|()
decl_stmt|;
specifier|final
name|Builder
argument_list|<
name|Long
argument_list|>
name|builder
init|=
operator|new
name|Builder
argument_list|<>
argument_list|(
name|FST
operator|.
name|INPUT_TYPE
operator|.
name|BYTE4
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|true
argument_list|,
literal|true
argument_list|,
name|Integer
operator|.
name|MAX_VALUE
argument_list|,
name|outputs
argument_list|,
name|random
argument_list|()
operator|.
name|nextBoolean
argument_list|()
argument_list|,
name|PackedInts
operator|.
name|DEFAULT
argument_list|,
literal|true
argument_list|,
literal|15
argument_list|)
decl_stmt|;
name|builder
operator|.
name|add
argument_list|(
name|Util
operator|.
name|toUTF32
argument_list|(
literal|"stat"
argument_list|,
operator|new
name|IntsRefBuilder
argument_list|()
argument_list|)
argument_list|,
literal|17L
argument_list|)
expr_stmt|;
name|builder
operator|.
name|add
argument_list|(
name|Util
operator|.
name|toUTF32
argument_list|(
literal|"station"
argument_list|,
operator|new
name|IntsRefBuilder
argument_list|()
argument_list|)
argument_list|,
literal|10L
argument_list|)
expr_stmt|;
specifier|final
name|FST
argument_list|<
name|Long
argument_list|>
name|fst
init|=
name|builder
operator|.
name|finish
argument_list|()
decl_stmt|;
comment|//Writer w = new OutputStreamWriter(new FileOutputStream("/x/tmp3/out.dot"));
name|StringWriter
name|w
init|=
operator|new
name|StringWriter
argument_list|()
decl_stmt|;
name|Util
operator|.
name|toDot
argument_list|(
name|fst
argument_list|,
name|w
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|w
operator|.
name|close
argument_list|()
expr_stmt|;
comment|//System.out.println(w.toString());
name|assertTrue
argument_list|(
name|w
operator|.
name|toString
argument_list|()
operator|.
name|indexOf
argument_list|(
literal|"label=\"t/[7]\""
argument_list|)
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
DECL|method|testInternalFinalState
specifier|public
name|void
name|testInternalFinalState
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|PositiveIntOutputs
name|outputs
init|=
name|PositiveIntOutputs
operator|.
name|getSingleton
argument_list|()
decl_stmt|;
specifier|final
name|boolean
name|willRewrite
init|=
name|random
argument_list|()
operator|.
name|nextBoolean
argument_list|()
decl_stmt|;
specifier|final
name|Builder
argument_list|<
name|Long
argument_list|>
name|builder
init|=
operator|new
name|Builder
argument_list|<>
argument_list|(
name|FST
operator|.
name|INPUT_TYPE
operator|.
name|BYTE1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|true
argument_list|,
literal|true
argument_list|,
name|Integer
operator|.
name|MAX_VALUE
argument_list|,
name|outputs
argument_list|,
name|willRewrite
argument_list|,
name|PackedInts
operator|.
name|DEFAULT
argument_list|,
literal|true
argument_list|,
literal|15
argument_list|)
decl_stmt|;
name|builder
operator|.
name|add
argument_list|(
name|Util
operator|.
name|toIntsRef
argument_list|(
operator|new
name|BytesRef
argument_list|(
literal|"stat"
argument_list|)
argument_list|,
operator|new
name|IntsRefBuilder
argument_list|()
argument_list|)
argument_list|,
name|outputs
operator|.
name|getNoOutput
argument_list|()
argument_list|)
expr_stmt|;
name|builder
operator|.
name|add
argument_list|(
name|Util
operator|.
name|toIntsRef
argument_list|(
operator|new
name|BytesRef
argument_list|(
literal|"station"
argument_list|)
argument_list|,
operator|new
name|IntsRefBuilder
argument_list|()
argument_list|)
argument_list|,
name|outputs
operator|.
name|getNoOutput
argument_list|()
argument_list|)
expr_stmt|;
specifier|final
name|FST
argument_list|<
name|Long
argument_list|>
name|fst
init|=
name|builder
operator|.
name|finish
argument_list|()
decl_stmt|;
name|StringWriter
name|w
init|=
operator|new
name|StringWriter
argument_list|()
decl_stmt|;
comment|//Writer w = new OutputStreamWriter(new FileOutputStream("/x/tmp/out.dot"));
name|Util
operator|.
name|toDot
argument_list|(
name|fst
argument_list|,
name|w
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|w
operator|.
name|close
argument_list|()
expr_stmt|;
comment|//System.out.println(w.toString());
comment|// check for accept state at label t
name|assertTrue
argument_list|(
name|w
operator|.
name|toString
argument_list|()
operator|.
name|indexOf
argument_list|(
literal|"[label=\"t\" style=\"bold\""
argument_list|)
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|// check for accept state at label n
name|assertTrue
argument_list|(
name|w
operator|.
name|toString
argument_list|()
operator|.
name|indexOf
argument_list|(
literal|"[label=\"n\" style=\"bold\""
argument_list|)
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|// Make sure raw FST can differentiate between final vs
comment|// non-final end nodes
DECL|method|testNonFinalStopNode
specifier|public
name|void
name|testNonFinalStopNode
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|PositiveIntOutputs
name|outputs
init|=
name|PositiveIntOutputs
operator|.
name|getSingleton
argument_list|()
decl_stmt|;
specifier|final
name|Long
name|nothing
init|=
name|outputs
operator|.
name|getNoOutput
argument_list|()
decl_stmt|;
specifier|final
name|Builder
argument_list|<
name|Long
argument_list|>
name|b
init|=
operator|new
name|Builder
argument_list|<>
argument_list|(
name|FST
operator|.
name|INPUT_TYPE
operator|.
name|BYTE1
argument_list|,
name|outputs
argument_list|)
decl_stmt|;
specifier|final
name|FST
argument_list|<
name|Long
argument_list|>
name|fst
init|=
operator|new
name|FST
argument_list|<>
argument_list|(
name|FST
operator|.
name|INPUT_TYPE
operator|.
name|BYTE1
argument_list|,
name|outputs
argument_list|,
literal|false
argument_list|,
name|PackedInts
operator|.
name|COMPACT
argument_list|,
literal|true
argument_list|,
literal|15
argument_list|)
decl_stmt|;
specifier|final
name|Builder
operator|.
name|UnCompiledNode
argument_list|<
name|Long
argument_list|>
name|rootNode
init|=
operator|new
name|Builder
operator|.
name|UnCompiledNode
argument_list|<>
argument_list|(
name|b
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|// Add final stop node
block|{
specifier|final
name|Builder
operator|.
name|UnCompiledNode
argument_list|<
name|Long
argument_list|>
name|node
init|=
operator|new
name|Builder
operator|.
name|UnCompiledNode
argument_list|<>
argument_list|(
name|b
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|node
operator|.
name|isFinal
operator|=
literal|true
expr_stmt|;
name|rootNode
operator|.
name|addArc
argument_list|(
literal|'a'
argument_list|,
name|node
argument_list|)
expr_stmt|;
specifier|final
name|Builder
operator|.
name|CompiledNode
name|frozen
init|=
operator|new
name|Builder
operator|.
name|CompiledNode
argument_list|()
decl_stmt|;
name|frozen
operator|.
name|node
operator|=
name|fst
operator|.
name|addNode
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|rootNode
operator|.
name|arcs
index|[
literal|0
index|]
operator|.
name|nextFinalOutput
operator|=
literal|17L
expr_stmt|;
name|rootNode
operator|.
name|arcs
index|[
literal|0
index|]
operator|.
name|isFinal
operator|=
literal|true
expr_stmt|;
name|rootNode
operator|.
name|arcs
index|[
literal|0
index|]
operator|.
name|output
operator|=
name|nothing
expr_stmt|;
name|rootNode
operator|.
name|arcs
index|[
literal|0
index|]
operator|.
name|target
operator|=
name|frozen
expr_stmt|;
block|}
comment|// Add non-final stop node
block|{
specifier|final
name|Builder
operator|.
name|UnCompiledNode
argument_list|<
name|Long
argument_list|>
name|node
init|=
operator|new
name|Builder
operator|.
name|UnCompiledNode
argument_list|<>
argument_list|(
name|b
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rootNode
operator|.
name|addArc
argument_list|(
literal|'b'
argument_list|,
name|node
argument_list|)
expr_stmt|;
specifier|final
name|Builder
operator|.
name|CompiledNode
name|frozen
init|=
operator|new
name|Builder
operator|.
name|CompiledNode
argument_list|()
decl_stmt|;
name|frozen
operator|.
name|node
operator|=
name|fst
operator|.
name|addNode
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|rootNode
operator|.
name|arcs
index|[
literal|1
index|]
operator|.
name|nextFinalOutput
operator|=
name|nothing
expr_stmt|;
name|rootNode
operator|.
name|arcs
index|[
literal|1
index|]
operator|.
name|output
operator|=
literal|42L
expr_stmt|;
name|rootNode
operator|.
name|arcs
index|[
literal|1
index|]
operator|.
name|target
operator|=
name|frozen
expr_stmt|;
block|}
name|fst
operator|.
name|finish
argument_list|(
name|fst
operator|.
name|addNode
argument_list|(
name|rootNode
argument_list|)
argument_list|)
expr_stmt|;
name|StringWriter
name|w
init|=
operator|new
name|StringWriter
argument_list|()
decl_stmt|;
comment|//Writer w = new OutputStreamWriter(new FileOutputStream("/x/tmp3/out.dot"));
name|Util
operator|.
name|toDot
argument_list|(
name|fst
argument_list|,
name|w
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|w
operator|.
name|close
argument_list|()
expr_stmt|;
name|checkStopNodes
argument_list|(
name|fst
argument_list|,
name|outputs
argument_list|)
expr_stmt|;
comment|// Make sure it still works after save/load:
name|Directory
name|dir
init|=
name|newDirectory
argument_list|()
decl_stmt|;
name|IndexOutput
name|out
init|=
name|dir
operator|.
name|createOutput
argument_list|(
literal|"fst"
argument_list|,
name|IOContext
operator|.
name|DEFAULT
argument_list|)
decl_stmt|;
name|fst
operator|.
name|save
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|out
operator|.
name|close
argument_list|()
expr_stmt|;
name|IndexInput
name|in
init|=
name|dir
operator|.
name|openInput
argument_list|(
literal|"fst"
argument_list|,
name|IOContext
operator|.
name|DEFAULT
argument_list|)
decl_stmt|;
specifier|final
name|FST
argument_list|<
name|Long
argument_list|>
name|fst2
init|=
operator|new
name|FST
argument_list|<>
argument_list|(
name|in
argument_list|,
name|outputs
argument_list|)
decl_stmt|;
name|checkStopNodes
argument_list|(
name|fst2
argument_list|,
name|outputs
argument_list|)
expr_stmt|;
name|in
operator|.
name|close
argument_list|()
expr_stmt|;
name|dir
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
DECL|method|checkStopNodes
specifier|private
name|void
name|checkStopNodes
parameter_list|(
name|FST
argument_list|<
name|Long
argument_list|>
name|fst
parameter_list|,
name|PositiveIntOutputs
name|outputs
parameter_list|)
throws|throws
name|Exception
block|{
specifier|final
name|Long
name|nothing
init|=
name|outputs
operator|.
name|getNoOutput
argument_list|()
decl_stmt|;
name|FST
operator|.
name|Arc
argument_list|<
name|Long
argument_list|>
name|startArc
init|=
name|fst
operator|.
name|getFirstArc
argument_list|(
operator|new
name|FST
operator|.
name|Arc
argument_list|<
name|Long
argument_list|>
argument_list|()
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|nothing
argument_list|,
name|startArc
operator|.
name|output
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|nothing
argument_list|,
name|startArc
operator|.
name|nextFinalOutput
argument_list|)
expr_stmt|;
name|FST
operator|.
name|Arc
argument_list|<
name|Long
argument_list|>
name|arc
init|=
name|fst
operator|.
name|readFirstTargetArc
argument_list|(
name|startArc
argument_list|,
operator|new
name|FST
operator|.
name|Arc
argument_list|<
name|Long
argument_list|>
argument_list|()
argument_list|,
name|fst
operator|.
name|getBytesReader
argument_list|()
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|'a'
argument_list|,
name|arc
operator|.
name|label
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|17
argument_list|,
name|arc
operator|.
name|nextFinalOutput
operator|.
name|longValue
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|arc
operator|.
name|isFinal
argument_list|()
argument_list|)
expr_stmt|;
name|arc
operator|=
name|fst
operator|.
name|readNextArc
argument_list|(
name|arc
argument_list|,
name|fst
operator|.
name|getBytesReader
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|'b'
argument_list|,
name|arc
operator|.
name|label
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|arc
operator|.
name|isFinal
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|42
argument_list|,
name|arc
operator|.
name|output
operator|.
name|longValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|field|minLongComparator
specifier|static
specifier|final
name|Comparator
argument_list|<
name|Long
argument_list|>
name|minLongComparator
init|=
operator|new
name|Comparator
argument_list|<
name|Long
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|int
name|compare
parameter_list|(
name|Long
name|left
parameter_list|,
name|Long
name|right
parameter_list|)
block|{
return|return
name|left
operator|.
name|compareTo
argument_list|(
name|right
argument_list|)
return|;
block|}
block|}
decl_stmt|;
DECL|method|testShortestPaths
specifier|public
name|void
name|testShortestPaths
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|PositiveIntOutputs
name|outputs
init|=
name|PositiveIntOutputs
operator|.
name|getSingleton
argument_list|()
decl_stmt|;
specifier|final
name|Builder
argument_list|<
name|Long
argument_list|>
name|builder
init|=
operator|new
name|Builder
argument_list|<>
argument_list|(
name|FST
operator|.
name|INPUT_TYPE
operator|.
name|BYTE1
argument_list|,
name|outputs
argument_list|)
decl_stmt|;
specifier|final
name|IntsRefBuilder
name|scratch
init|=
operator|new
name|IntsRefBuilder
argument_list|()
decl_stmt|;
name|builder
operator|.
name|add
argument_list|(
name|Util
operator|.
name|toIntsRef
argument_list|(
operator|new
name|BytesRef
argument_list|(
literal|"aab"
argument_list|)
argument_list|,
name|scratch
argument_list|)
argument_list|,
literal|22L
argument_list|)
expr_stmt|;
name|builder
operator|.
name|add
argument_list|(
name|Util
operator|.
name|toIntsRef
argument_list|(
operator|new
name|BytesRef
argument_list|(
literal|"aac"
argument_list|)
argument_list|,
name|scratch
argument_list|)
argument_list|,
literal|7L
argument_list|)
expr_stmt|;
name|builder
operator|.
name|add
argument_list|(
name|Util
operator|.
name|toIntsRef
argument_list|(
operator|new
name|BytesRef
argument_list|(
literal|"ax"
argument_list|)
argument_list|,
name|scratch
argument_list|)
argument_list|,
literal|17L
argument_list|)
expr_stmt|;
specifier|final
name|FST
argument_list|<
name|Long
argument_list|>
name|fst
init|=
name|builder
operator|.
name|finish
argument_list|()
decl_stmt|;
comment|//Writer w = new OutputStreamWriter(new FileOutputStream("out.dot"));
comment|//Util.toDot(fst, w, false, false);
comment|//w.close();
name|Util
operator|.
name|TopResults
argument_list|<
name|Long
argument_list|>
name|res
init|=
name|Util
operator|.
name|shortestPaths
argument_list|(
name|fst
argument_list|,
name|fst
operator|.
name|getFirstArc
argument_list|(
operator|new
name|FST
operator|.
name|Arc
argument_list|<
name|Long
argument_list|>
argument_list|()
argument_list|)
argument_list|,
name|outputs
operator|.
name|getNoOutput
argument_list|()
argument_list|,
name|minLongComparator
argument_list|,
literal|3
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|res
operator|.
name|isComplete
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|3
argument_list|,
name|res
operator|.
name|topN
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|Util
operator|.
name|toIntsRef
argument_list|(
operator|new
name|BytesRef
argument_list|(
literal|"aac"
argument_list|)
argument_list|,
name|scratch
argument_list|)
argument_list|,
name|res
operator|.
name|topN
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|input
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|7L
argument_list|,
name|res
operator|.
name|topN
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|output
operator|.
name|longValue
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|Util
operator|.
name|toIntsRef
argument_list|(
operator|new
name|BytesRef
argument_list|(
literal|"ax"
argument_list|)
argument_list|,
name|scratch
argument_list|)
argument_list|,
name|res
operator|.
name|topN
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|.
name|input
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|17L
argument_list|,
name|res
operator|.
name|topN
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|.
name|output
operator|.
name|longValue
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|Util
operator|.
name|toIntsRef
argument_list|(
operator|new
name|BytesRef
argument_list|(
literal|"aab"
argument_list|)
argument_list|,
name|scratch
argument_list|)
argument_list|,
name|res
operator|.
name|topN
operator|.
name|get
argument_list|(
literal|2
argument_list|)
operator|.
name|input
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|22L
argument_list|,
name|res
operator|.
name|topN
operator|.
name|get
argument_list|(
literal|2
argument_list|)
operator|.
name|output
operator|.
name|longValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|testRejectNoLimits
specifier|public
name|void
name|testRejectNoLimits
parameter_list|()
throws|throws
name|IOException
block|{
specifier|final
name|PositiveIntOutputs
name|outputs
init|=
name|PositiveIntOutputs
operator|.
name|getSingleton
argument_list|()
decl_stmt|;
specifier|final
name|Builder
argument_list|<
name|Long
argument_list|>
name|builder
init|=
operator|new
name|Builder
argument_list|<
name|Long
argument_list|>
argument_list|(
name|FST
operator|.
name|INPUT_TYPE
operator|.
name|BYTE1
argument_list|,
name|outputs
argument_list|)
decl_stmt|;
specifier|final
name|IntsRefBuilder
name|scratch
init|=
operator|new
name|IntsRefBuilder
argument_list|()
decl_stmt|;
name|builder
operator|.
name|add
argument_list|(
name|Util
operator|.
name|toIntsRef
argument_list|(
operator|new
name|BytesRef
argument_list|(
literal|"aab"
argument_list|)
argument_list|,
name|scratch
argument_list|)
argument_list|,
literal|22L
argument_list|)
expr_stmt|;
name|builder
operator|.
name|add
argument_list|(
name|Util
operator|.
name|toIntsRef
argument_list|(
operator|new
name|BytesRef
argument_list|(
literal|"aac"
argument_list|)
argument_list|,
name|scratch
argument_list|)
argument_list|,
literal|7L
argument_list|)
expr_stmt|;
name|builder
operator|.
name|add
argument_list|(
name|Util
operator|.
name|toIntsRef
argument_list|(
operator|new
name|BytesRef
argument_list|(
literal|"adcd"
argument_list|)
argument_list|,
name|scratch
argument_list|)
argument_list|,
literal|17L
argument_list|)
expr_stmt|;
name|builder
operator|.
name|add
argument_list|(
name|Util
operator|.
name|toIntsRef
argument_list|(
operator|new
name|BytesRef
argument_list|(
literal|"adcde"
argument_list|)
argument_list|,
name|scratch
argument_list|)
argument_list|,
literal|17L
argument_list|)
expr_stmt|;
name|builder
operator|.
name|add
argument_list|(
name|Util
operator|.
name|toIntsRef
argument_list|(
operator|new
name|BytesRef
argument_list|(
literal|"ax"
argument_list|)
argument_list|,
name|scratch
argument_list|)
argument_list|,
literal|17L
argument_list|)
expr_stmt|;
specifier|final
name|FST
argument_list|<
name|Long
argument_list|>
name|fst
init|=
name|builder
operator|.
name|finish
argument_list|()
decl_stmt|;
specifier|final
name|AtomicInteger
name|rejectCount
init|=
operator|new
name|AtomicInteger
argument_list|()
decl_stmt|;
name|Util
operator|.
name|TopNSearcher
argument_list|<
name|Long
argument_list|>
name|searcher
init|=
operator|new
name|Util
operator|.
name|TopNSearcher
argument_list|<
name|Long
argument_list|>
argument_list|(
name|fst
argument_list|,
literal|2
argument_list|,
literal|6
argument_list|,
name|minLongComparator
argument_list|)
block|{
annotation|@
name|Override
specifier|protected
name|boolean
name|acceptResult
parameter_list|(
name|IntsRef
name|input
parameter_list|,
name|Long
name|output
parameter_list|)
block|{
name|boolean
name|accept
init|=
name|output
operator|.
name|intValue
argument_list|()
operator|==
literal|7
decl_stmt|;
if|if
condition|(
operator|!
name|accept
condition|)
block|{
name|rejectCount
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
block|}
return|return
name|accept
return|;
block|}
block|}
decl_stmt|;
name|searcher
operator|.
name|addStartPaths
argument_list|(
name|fst
operator|.
name|getFirstArc
argument_list|(
operator|new
name|FST
operator|.
name|Arc
argument_list|<
name|Long
argument_list|>
argument_list|()
argument_list|)
argument_list|,
name|outputs
operator|.
name|getNoOutput
argument_list|()
argument_list|,
literal|true
argument_list|,
operator|new
name|IntsRefBuilder
argument_list|()
argument_list|)
expr_stmt|;
name|Util
operator|.
name|TopResults
argument_list|<
name|Long
argument_list|>
name|res
init|=
name|searcher
operator|.
name|search
argument_list|()
decl_stmt|;
name|assertEquals
argument_list|(
name|rejectCount
operator|.
name|get
argument_list|()
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|res
operator|.
name|isComplete
argument_list|)
expr_stmt|;
comment|// rejected(4) + topN(2)<= maxQueueSize(6)
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|res
operator|.
name|topN
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|Util
operator|.
name|toIntsRef
argument_list|(
operator|new
name|BytesRef
argument_list|(
literal|"aac"
argument_list|)
argument_list|,
name|scratch
argument_list|)
argument_list|,
name|res
operator|.
name|topN
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|input
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|7L
argument_list|,
name|res
operator|.
name|topN
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|output
operator|.
name|longValue
argument_list|()
argument_list|)
expr_stmt|;
name|rejectCount
operator|.
name|set
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|searcher
operator|=
operator|new
name|Util
operator|.
name|TopNSearcher
argument_list|<
name|Long
argument_list|>
argument_list|(
name|fst
argument_list|,
literal|2
argument_list|,
literal|5
argument_list|,
name|minLongComparator
argument_list|)
block|{
annotation|@
name|Override
specifier|protected
name|boolean
name|acceptResult
parameter_list|(
name|IntsRef
name|input
parameter_list|,
name|Long
name|output
parameter_list|)
block|{
name|boolean
name|accept
init|=
name|output
operator|.
name|intValue
argument_list|()
operator|==
literal|7
decl_stmt|;
if|if
condition|(
operator|!
name|accept
condition|)
block|{
name|rejectCount
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
block|}
return|return
name|accept
return|;
block|}
block|}
expr_stmt|;
name|searcher
operator|.
name|addStartPaths
argument_list|(
name|fst
operator|.
name|getFirstArc
argument_list|(
operator|new
name|FST
operator|.
name|Arc
argument_list|<
name|Long
argument_list|>
argument_list|()
argument_list|)
argument_list|,
name|outputs
operator|.
name|getNoOutput
argument_list|()
argument_list|,
literal|true
argument_list|,
operator|new
name|IntsRefBuilder
argument_list|()
argument_list|)
expr_stmt|;
name|res
operator|=
name|searcher
operator|.
name|search
argument_list|()
expr_stmt|;
name|assertEquals
argument_list|(
name|rejectCount
operator|.
name|get
argument_list|()
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|res
operator|.
name|isComplete
argument_list|)
expr_stmt|;
comment|// rejected(4) + topN(2)> maxQueueSize(5)
block|}
comment|// compares just the weight side of the pair
DECL|field|minPairWeightComparator
specifier|static
specifier|final
name|Comparator
argument_list|<
name|Pair
argument_list|<
name|Long
argument_list|,
name|Long
argument_list|>
argument_list|>
name|minPairWeightComparator
init|=
operator|new
name|Comparator
argument_list|<
name|Pair
argument_list|<
name|Long
argument_list|,
name|Long
argument_list|>
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|int
name|compare
parameter_list|(
name|Pair
argument_list|<
name|Long
argument_list|,
name|Long
argument_list|>
name|left
parameter_list|,
name|Pair
argument_list|<
name|Long
argument_list|,
name|Long
argument_list|>
name|right
parameter_list|)
block|{
return|return
name|left
operator|.
name|output1
operator|.
name|compareTo
argument_list|(
name|right
operator|.
name|output1
argument_list|)
return|;
block|}
block|}
decl_stmt|;
comment|/** like testShortestPaths, but uses pairoutputs so we have both a weight and an output */
DECL|method|testShortestPathsWFST
specifier|public
name|void
name|testShortestPathsWFST
parameter_list|()
throws|throws
name|Exception
block|{
name|PairOutputs
argument_list|<
name|Long
argument_list|,
name|Long
argument_list|>
name|outputs
init|=
operator|new
name|PairOutputs
argument_list|<>
argument_list|(
name|PositiveIntOutputs
operator|.
name|getSingleton
argument_list|()
argument_list|,
comment|// weight
name|PositiveIntOutputs
operator|.
name|getSingleton
argument_list|()
comment|// output
argument_list|)
decl_stmt|;
specifier|final
name|Builder
argument_list|<
name|Pair
argument_list|<
name|Long
argument_list|,
name|Long
argument_list|>
argument_list|>
name|builder
init|=
operator|new
name|Builder
argument_list|<>
argument_list|(
name|FST
operator|.
name|INPUT_TYPE
operator|.
name|BYTE1
argument_list|,
name|outputs
argument_list|)
decl_stmt|;
specifier|final
name|IntsRefBuilder
name|scratch
init|=
operator|new
name|IntsRefBuilder
argument_list|()
decl_stmt|;
name|builder
operator|.
name|add
argument_list|(
name|Util
operator|.
name|toIntsRef
argument_list|(
operator|new
name|BytesRef
argument_list|(
literal|"aab"
argument_list|)
argument_list|,
name|scratch
argument_list|)
argument_list|,
name|outputs
operator|.
name|newPair
argument_list|(
literal|22L
argument_list|,
literal|57L
argument_list|)
argument_list|)
expr_stmt|;
name|builder
operator|.
name|add
argument_list|(
name|Util
operator|.
name|toIntsRef
argument_list|(
operator|new
name|BytesRef
argument_list|(
literal|"aac"
argument_list|)
argument_list|,
name|scratch
argument_list|)
argument_list|,
name|outputs
operator|.
name|newPair
argument_list|(
literal|7L
argument_list|,
literal|36L
argument_list|)
argument_list|)
expr_stmt|;
name|builder
operator|.
name|add
argument_list|(
name|Util
operator|.
name|toIntsRef
argument_list|(
operator|new
name|BytesRef
argument_list|(
literal|"ax"
argument_list|)
argument_list|,
name|scratch
argument_list|)
argument_list|,
name|outputs
operator|.
name|newPair
argument_list|(
literal|17L
argument_list|,
literal|85L
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|FST
argument_list|<
name|Pair
argument_list|<
name|Long
argument_list|,
name|Long
argument_list|>
argument_list|>
name|fst
init|=
name|builder
operator|.
name|finish
argument_list|()
decl_stmt|;
comment|//Writer w = new OutputStreamWriter(new FileOutputStream("out.dot"));
comment|//Util.toDot(fst, w, false, false);
comment|//w.close();
name|Util
operator|.
name|TopResults
argument_list|<
name|Pair
argument_list|<
name|Long
argument_list|,
name|Long
argument_list|>
argument_list|>
name|res
init|=
name|Util
operator|.
name|shortestPaths
argument_list|(
name|fst
argument_list|,
name|fst
operator|.
name|getFirstArc
argument_list|(
operator|new
name|FST
operator|.
name|Arc
argument_list|<
name|Pair
argument_list|<
name|Long
argument_list|,
name|Long
argument_list|>
argument_list|>
argument_list|()
argument_list|)
argument_list|,
name|outputs
operator|.
name|getNoOutput
argument_list|()
argument_list|,
name|minPairWeightComparator
argument_list|,
literal|3
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|res
operator|.
name|isComplete
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|3
argument_list|,
name|res
operator|.
name|topN
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|Util
operator|.
name|toIntsRef
argument_list|(
operator|new
name|BytesRef
argument_list|(
literal|"aac"
argument_list|)
argument_list|,
name|scratch
argument_list|)
argument_list|,
name|res
operator|.
name|topN
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|input
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|7L
argument_list|,
name|res
operator|.
name|topN
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|output
operator|.
name|output1
operator|.
name|longValue
argument_list|()
argument_list|)
expr_stmt|;
comment|// weight
name|assertEquals
argument_list|(
literal|36L
argument_list|,
name|res
operator|.
name|topN
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|output
operator|.
name|output2
operator|.
name|longValue
argument_list|()
argument_list|)
expr_stmt|;
comment|// output
name|assertEquals
argument_list|(
name|Util
operator|.
name|toIntsRef
argument_list|(
operator|new
name|BytesRef
argument_list|(
literal|"ax"
argument_list|)
argument_list|,
name|scratch
argument_list|)
argument_list|,
name|res
operator|.
name|topN
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|.
name|input
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|17L
argument_list|,
name|res
operator|.
name|topN
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|.
name|output
operator|.
name|output1
operator|.
name|longValue
argument_list|()
argument_list|)
expr_stmt|;
comment|// weight
name|assertEquals
argument_list|(
literal|85L
argument_list|,
name|res
operator|.
name|topN
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|.
name|output
operator|.
name|output2
operator|.
name|longValue
argument_list|()
argument_list|)
expr_stmt|;
comment|// output
name|assertEquals
argument_list|(
name|Util
operator|.
name|toIntsRef
argument_list|(
operator|new
name|BytesRef
argument_list|(
literal|"aab"
argument_list|)
argument_list|,
name|scratch
argument_list|)
argument_list|,
name|res
operator|.
name|topN
operator|.
name|get
argument_list|(
literal|2
argument_list|)
operator|.
name|input
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|22L
argument_list|,
name|res
operator|.
name|topN
operator|.
name|get
argument_list|(
literal|2
argument_list|)
operator|.
name|output
operator|.
name|output1
operator|.
name|longValue
argument_list|()
argument_list|)
expr_stmt|;
comment|// weight
name|assertEquals
argument_list|(
literal|57L
argument_list|,
name|res
operator|.
name|topN
operator|.
name|get
argument_list|(
literal|2
argument_list|)
operator|.
name|output
operator|.
name|output2
operator|.
name|longValue
argument_list|()
argument_list|)
expr_stmt|;
comment|// output
block|}
DECL|method|testShortestPathsRandom
specifier|public
name|void
name|testShortestPathsRandom
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|Random
name|random
init|=
name|random
argument_list|()
decl_stmt|;
name|int
name|numWords
init|=
name|atLeast
argument_list|(
literal|1000
argument_list|)
decl_stmt|;
specifier|final
name|TreeMap
argument_list|<
name|String
argument_list|,
name|Long
argument_list|>
name|slowCompletor
init|=
operator|new
name|TreeMap
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|TreeSet
argument_list|<
name|String
argument_list|>
name|allPrefixes
init|=
operator|new
name|TreeSet
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|PositiveIntOutputs
name|outputs
init|=
name|PositiveIntOutputs
operator|.
name|getSingleton
argument_list|()
decl_stmt|;
specifier|final
name|Builder
argument_list|<
name|Long
argument_list|>
name|builder
init|=
operator|new
name|Builder
argument_list|<>
argument_list|(
name|FST
operator|.
name|INPUT_TYPE
operator|.
name|BYTE1
argument_list|,
name|outputs
argument_list|)
decl_stmt|;
specifier|final
name|IntsRefBuilder
name|scratch
init|=
operator|new
name|IntsRefBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numWords
condition|;
name|i
operator|++
control|)
block|{
name|String
name|s
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|s
operator|=
name|TestUtil
operator|.
name|randomSimpleString
argument_list|(
name|random
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|slowCompletor
operator|.
name|containsKey
argument_list|(
name|s
argument_list|)
condition|)
block|{
break|break;
block|}
block|}
for|for
control|(
name|int
name|j
init|=
literal|1
init|;
name|j
operator|<
name|s
operator|.
name|length
argument_list|()
condition|;
name|j
operator|++
control|)
block|{
name|allPrefixes
operator|.
name|add
argument_list|(
name|s
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|j
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|int
name|weight
init|=
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|random
argument_list|,
literal|1
argument_list|,
literal|100
argument_list|)
decl_stmt|;
comment|// weights 1..100
name|slowCompletor
operator|.
name|put
argument_list|(
name|s
argument_list|,
operator|(
name|long
operator|)
name|weight
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|Long
argument_list|>
name|e
range|:
name|slowCompletor
operator|.
name|entrySet
argument_list|()
control|)
block|{
comment|//System.out.println("add: " + e);
name|builder
operator|.
name|add
argument_list|(
name|Util
operator|.
name|toIntsRef
argument_list|(
operator|new
name|BytesRef
argument_list|(
name|e
operator|.
name|getKey
argument_list|()
argument_list|)
argument_list|,
name|scratch
argument_list|)
argument_list|,
name|e
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
specifier|final
name|FST
argument_list|<
name|Long
argument_list|>
name|fst
init|=
name|builder
operator|.
name|finish
argument_list|()
decl_stmt|;
comment|//System.out.println("SAVE out.dot");
comment|//Writer w = new OutputStreamWriter(new FileOutputStream("out.dot"));
comment|//Util.toDot(fst, w, false, false);
comment|//w.close();
name|BytesReader
name|reader
init|=
name|fst
operator|.
name|getBytesReader
argument_list|()
decl_stmt|;
comment|//System.out.println("testing: " + allPrefixes.size() + " prefixes");
for|for
control|(
name|String
name|prefix
range|:
name|allPrefixes
control|)
block|{
comment|// 1. run prefix against fst, then complete by value
comment|//System.out.println("TEST: " + prefix);
name|long
name|prefixOutput
init|=
literal|0
decl_stmt|;
name|FST
operator|.
name|Arc
argument_list|<
name|Long
argument_list|>
name|arc
init|=
name|fst
operator|.
name|getFirstArc
argument_list|(
operator|new
name|FST
operator|.
name|Arc
argument_list|<
name|Long
argument_list|>
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|idx
init|=
literal|0
init|;
name|idx
operator|<
name|prefix
operator|.
name|length
argument_list|()
condition|;
name|idx
operator|++
control|)
block|{
if|if
condition|(
name|fst
operator|.
name|findTargetArc
argument_list|(
operator|(
name|int
operator|)
name|prefix
operator|.
name|charAt
argument_list|(
name|idx
argument_list|)
argument_list|,
name|arc
argument_list|,
name|arc
argument_list|,
name|reader
argument_list|)
operator|==
literal|null
condition|)
block|{
name|fail
argument_list|()
expr_stmt|;
block|}
name|prefixOutput
operator|+=
name|arc
operator|.
name|output
expr_stmt|;
block|}
specifier|final
name|int
name|topN
init|=
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|random
argument_list|,
literal|1
argument_list|,
literal|10
argument_list|)
decl_stmt|;
name|Util
operator|.
name|TopResults
argument_list|<
name|Long
argument_list|>
name|r
init|=
name|Util
operator|.
name|shortestPaths
argument_list|(
name|fst
argument_list|,
name|arc
argument_list|,
name|fst
operator|.
name|outputs
operator|.
name|getNoOutput
argument_list|()
argument_list|,
name|minLongComparator
argument_list|,
name|topN
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|r
operator|.
name|isComplete
argument_list|)
expr_stmt|;
comment|// 2. go thru whole treemap (slowCompletor) and check it's actually the best suggestion
specifier|final
name|List
argument_list|<
name|Result
argument_list|<
name|Long
argument_list|>
argument_list|>
name|matches
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
comment|// TODO: could be faster... but it's slowCompletor for a reason
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|Long
argument_list|>
name|e
range|:
name|slowCompletor
operator|.
name|entrySet
argument_list|()
control|)
block|{
if|if
condition|(
name|e
operator|.
name|getKey
argument_list|()
operator|.
name|startsWith
argument_list|(
name|prefix
argument_list|)
condition|)
block|{
comment|//System.out.println("  consider " + e.getKey());
name|matches
operator|.
name|add
argument_list|(
operator|new
name|Result
argument_list|<>
argument_list|(
name|Util
operator|.
name|toIntsRef
argument_list|(
operator|new
name|BytesRef
argument_list|(
name|e
operator|.
name|getKey
argument_list|()
operator|.
name|substring
argument_list|(
name|prefix
operator|.
name|length
argument_list|()
argument_list|)
argument_list|)
argument_list|,
operator|new
name|IntsRefBuilder
argument_list|()
argument_list|)
argument_list|,
name|e
operator|.
name|getValue
argument_list|()
operator|-
name|prefixOutput
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|assertTrue
argument_list|(
name|matches
operator|.
name|size
argument_list|()
operator|>
literal|0
argument_list|)
expr_stmt|;
name|Collections
operator|.
name|sort
argument_list|(
name|matches
argument_list|,
operator|new
name|TieBreakByInputComparator
argument_list|<>
argument_list|(
name|minLongComparator
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|matches
operator|.
name|size
argument_list|()
operator|>
name|topN
condition|)
block|{
name|matches
operator|.
name|subList
argument_list|(
name|topN
argument_list|,
name|matches
operator|.
name|size
argument_list|()
argument_list|)
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
name|assertEquals
argument_list|(
name|matches
operator|.
name|size
argument_list|()
argument_list|,
name|r
operator|.
name|topN
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|hit
init|=
literal|0
init|;
name|hit
operator|<
name|r
operator|.
name|topN
operator|.
name|size
argument_list|()
condition|;
name|hit
operator|++
control|)
block|{
comment|//System.out.println("  check hit " + hit);
name|assertEquals
argument_list|(
name|matches
operator|.
name|get
argument_list|(
name|hit
argument_list|)
operator|.
name|input
argument_list|,
name|r
operator|.
name|topN
operator|.
name|get
argument_list|(
name|hit
argument_list|)
operator|.
name|input
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|matches
operator|.
name|get
argument_list|(
name|hit
argument_list|)
operator|.
name|output
argument_list|,
name|r
operator|.
name|topN
operator|.
name|get
argument_list|(
name|hit
argument_list|)
operator|.
name|output
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|class|TieBreakByInputComparator
specifier|private
specifier|static
class|class
name|TieBreakByInputComparator
parameter_list|<
name|T
parameter_list|>
implements|implements
name|Comparator
argument_list|<
name|Result
argument_list|<
name|T
argument_list|>
argument_list|>
block|{
DECL|field|comparator
specifier|private
specifier|final
name|Comparator
argument_list|<
name|T
argument_list|>
name|comparator
decl_stmt|;
DECL|method|TieBreakByInputComparator
specifier|public
name|TieBreakByInputComparator
parameter_list|(
name|Comparator
argument_list|<
name|T
argument_list|>
name|comparator
parameter_list|)
block|{
name|this
operator|.
name|comparator
operator|=
name|comparator
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|compare
specifier|public
name|int
name|compare
parameter_list|(
name|Result
argument_list|<
name|T
argument_list|>
name|a
parameter_list|,
name|Result
argument_list|<
name|T
argument_list|>
name|b
parameter_list|)
block|{
name|int
name|cmp
init|=
name|comparator
operator|.
name|compare
argument_list|(
name|a
operator|.
name|output
argument_list|,
name|b
operator|.
name|output
argument_list|)
decl_stmt|;
if|if
condition|(
name|cmp
operator|==
literal|0
condition|)
block|{
return|return
name|a
operator|.
name|input
operator|.
name|compareTo
argument_list|(
name|b
operator|.
name|input
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|cmp
return|;
block|}
block|}
block|}
comment|// used by slowcompletor
DECL|class|TwoLongs
class|class
name|TwoLongs
block|{
DECL|field|a
name|long
name|a
decl_stmt|;
DECL|field|b
name|long
name|b
decl_stmt|;
DECL|method|TwoLongs
name|TwoLongs
parameter_list|(
name|long
name|a
parameter_list|,
name|long
name|b
parameter_list|)
block|{
name|this
operator|.
name|a
operator|=
name|a
expr_stmt|;
name|this
operator|.
name|b
operator|=
name|b
expr_stmt|;
block|}
block|}
comment|/** like testShortestPathsRandom, but uses pairoutputs so we have both a weight and an output */
DECL|method|testShortestPathsWFSTRandom
specifier|public
name|void
name|testShortestPathsWFSTRandom
parameter_list|()
throws|throws
name|Exception
block|{
name|int
name|numWords
init|=
name|atLeast
argument_list|(
literal|1000
argument_list|)
decl_stmt|;
specifier|final
name|TreeMap
argument_list|<
name|String
argument_list|,
name|TwoLongs
argument_list|>
name|slowCompletor
init|=
operator|new
name|TreeMap
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|TreeSet
argument_list|<
name|String
argument_list|>
name|allPrefixes
init|=
operator|new
name|TreeSet
argument_list|<>
argument_list|()
decl_stmt|;
name|PairOutputs
argument_list|<
name|Long
argument_list|,
name|Long
argument_list|>
name|outputs
init|=
operator|new
name|PairOutputs
argument_list|<>
argument_list|(
name|PositiveIntOutputs
operator|.
name|getSingleton
argument_list|()
argument_list|,
comment|// weight
name|PositiveIntOutputs
operator|.
name|getSingleton
argument_list|()
comment|// output
argument_list|)
decl_stmt|;
specifier|final
name|Builder
argument_list|<
name|Pair
argument_list|<
name|Long
argument_list|,
name|Long
argument_list|>
argument_list|>
name|builder
init|=
operator|new
name|Builder
argument_list|<>
argument_list|(
name|FST
operator|.
name|INPUT_TYPE
operator|.
name|BYTE1
argument_list|,
name|outputs
argument_list|)
decl_stmt|;
specifier|final
name|IntsRefBuilder
name|scratch
init|=
operator|new
name|IntsRefBuilder
argument_list|()
decl_stmt|;
name|Random
name|random
init|=
name|random
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numWords
condition|;
name|i
operator|++
control|)
block|{
name|String
name|s
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|s
operator|=
name|TestUtil
operator|.
name|randomSimpleString
argument_list|(
name|random
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|slowCompletor
operator|.
name|containsKey
argument_list|(
name|s
argument_list|)
condition|)
block|{
break|break;
block|}
block|}
for|for
control|(
name|int
name|j
init|=
literal|1
init|;
name|j
operator|<
name|s
operator|.
name|length
argument_list|()
condition|;
name|j
operator|++
control|)
block|{
name|allPrefixes
operator|.
name|add
argument_list|(
name|s
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|j
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|int
name|weight
init|=
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|random
argument_list|,
literal|1
argument_list|,
literal|100
argument_list|)
decl_stmt|;
comment|// weights 1..100
name|int
name|output
init|=
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|random
argument_list|,
literal|0
argument_list|,
literal|500
argument_list|)
decl_stmt|;
comment|// outputs 0..500
name|slowCompletor
operator|.
name|put
argument_list|(
name|s
argument_list|,
operator|new
name|TwoLongs
argument_list|(
name|weight
argument_list|,
name|output
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|TwoLongs
argument_list|>
name|e
range|:
name|slowCompletor
operator|.
name|entrySet
argument_list|()
control|)
block|{
comment|//System.out.println("add: " + e);
name|long
name|weight
init|=
name|e
operator|.
name|getValue
argument_list|()
operator|.
name|a
decl_stmt|;
name|long
name|output
init|=
name|e
operator|.
name|getValue
argument_list|()
operator|.
name|b
decl_stmt|;
name|builder
operator|.
name|add
argument_list|(
name|Util
operator|.
name|toIntsRef
argument_list|(
operator|new
name|BytesRef
argument_list|(
name|e
operator|.
name|getKey
argument_list|()
argument_list|)
argument_list|,
name|scratch
argument_list|)
argument_list|,
name|outputs
operator|.
name|newPair
argument_list|(
name|weight
argument_list|,
name|output
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|final
name|FST
argument_list|<
name|Pair
argument_list|<
name|Long
argument_list|,
name|Long
argument_list|>
argument_list|>
name|fst
init|=
name|builder
operator|.
name|finish
argument_list|()
decl_stmt|;
comment|//System.out.println("SAVE out.dot");
comment|//Writer w = new OutputStreamWriter(new FileOutputStream("out.dot"));
comment|//Util.toDot(fst, w, false, false);
comment|//w.close();
name|BytesReader
name|reader
init|=
name|fst
operator|.
name|getBytesReader
argument_list|()
decl_stmt|;
comment|//System.out.println("testing: " + allPrefixes.size() + " prefixes");
for|for
control|(
name|String
name|prefix
range|:
name|allPrefixes
control|)
block|{
comment|// 1. run prefix against fst, then complete by value
comment|//System.out.println("TEST: " + prefix);
name|Pair
argument_list|<
name|Long
argument_list|,
name|Long
argument_list|>
name|prefixOutput
init|=
name|outputs
operator|.
name|getNoOutput
argument_list|()
decl_stmt|;
name|FST
operator|.
name|Arc
argument_list|<
name|Pair
argument_list|<
name|Long
argument_list|,
name|Long
argument_list|>
argument_list|>
name|arc
init|=
name|fst
operator|.
name|getFirstArc
argument_list|(
operator|new
name|FST
operator|.
name|Arc
argument_list|<
name|Pair
argument_list|<
name|Long
argument_list|,
name|Long
argument_list|>
argument_list|>
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|idx
init|=
literal|0
init|;
name|idx
operator|<
name|prefix
operator|.
name|length
argument_list|()
condition|;
name|idx
operator|++
control|)
block|{
if|if
condition|(
name|fst
operator|.
name|findTargetArc
argument_list|(
operator|(
name|int
operator|)
name|prefix
operator|.
name|charAt
argument_list|(
name|idx
argument_list|)
argument_list|,
name|arc
argument_list|,
name|arc
argument_list|,
name|reader
argument_list|)
operator|==
literal|null
condition|)
block|{
name|fail
argument_list|()
expr_stmt|;
block|}
name|prefixOutput
operator|=
name|outputs
operator|.
name|add
argument_list|(
name|prefixOutput
argument_list|,
name|arc
operator|.
name|output
argument_list|)
expr_stmt|;
block|}
specifier|final
name|int
name|topN
init|=
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|random
argument_list|,
literal|1
argument_list|,
literal|10
argument_list|)
decl_stmt|;
name|Util
operator|.
name|TopResults
argument_list|<
name|Pair
argument_list|<
name|Long
argument_list|,
name|Long
argument_list|>
argument_list|>
name|r
init|=
name|Util
operator|.
name|shortestPaths
argument_list|(
name|fst
argument_list|,
name|arc
argument_list|,
name|fst
operator|.
name|outputs
operator|.
name|getNoOutput
argument_list|()
argument_list|,
name|minPairWeightComparator
argument_list|,
name|topN
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|r
operator|.
name|isComplete
argument_list|)
expr_stmt|;
comment|// 2. go thru whole treemap (slowCompletor) and check it's actually the best suggestion
specifier|final
name|List
argument_list|<
name|Result
argument_list|<
name|Pair
argument_list|<
name|Long
argument_list|,
name|Long
argument_list|>
argument_list|>
argument_list|>
name|matches
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
comment|// TODO: could be faster... but it's slowCompletor for a reason
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|TwoLongs
argument_list|>
name|e
range|:
name|slowCompletor
operator|.
name|entrySet
argument_list|()
control|)
block|{
if|if
condition|(
name|e
operator|.
name|getKey
argument_list|()
operator|.
name|startsWith
argument_list|(
name|prefix
argument_list|)
condition|)
block|{
comment|//System.out.println("  consider " + e.getKey());
name|matches
operator|.
name|add
argument_list|(
operator|new
name|Result
argument_list|<>
argument_list|(
name|Util
operator|.
name|toIntsRef
argument_list|(
operator|new
name|BytesRef
argument_list|(
name|e
operator|.
name|getKey
argument_list|()
operator|.
name|substring
argument_list|(
name|prefix
operator|.
name|length
argument_list|()
argument_list|)
argument_list|)
argument_list|,
operator|new
name|IntsRefBuilder
argument_list|()
argument_list|)
argument_list|,
name|outputs
operator|.
name|newPair
argument_list|(
name|e
operator|.
name|getValue
argument_list|()
operator|.
name|a
operator|-
name|prefixOutput
operator|.
name|output1
argument_list|,
name|e
operator|.
name|getValue
argument_list|()
operator|.
name|b
operator|-
name|prefixOutput
operator|.
name|output2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|assertTrue
argument_list|(
name|matches
operator|.
name|size
argument_list|()
operator|>
literal|0
argument_list|)
expr_stmt|;
name|Collections
operator|.
name|sort
argument_list|(
name|matches
argument_list|,
operator|new
name|TieBreakByInputComparator
argument_list|<>
argument_list|(
name|minPairWeightComparator
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|matches
operator|.
name|size
argument_list|()
operator|>
name|topN
condition|)
block|{
name|matches
operator|.
name|subList
argument_list|(
name|topN
argument_list|,
name|matches
operator|.
name|size
argument_list|()
argument_list|)
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
name|assertEquals
argument_list|(
name|matches
operator|.
name|size
argument_list|()
argument_list|,
name|r
operator|.
name|topN
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|hit
init|=
literal|0
init|;
name|hit
operator|<
name|r
operator|.
name|topN
operator|.
name|size
argument_list|()
condition|;
name|hit
operator|++
control|)
block|{
comment|//System.out.println("  check hit " + hit);
name|assertEquals
argument_list|(
name|matches
operator|.
name|get
argument_list|(
name|hit
argument_list|)
operator|.
name|input
argument_list|,
name|r
operator|.
name|topN
operator|.
name|get
argument_list|(
name|hit
argument_list|)
operator|.
name|input
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|matches
operator|.
name|get
argument_list|(
name|hit
argument_list|)
operator|.
name|output
argument_list|,
name|r
operator|.
name|topN
operator|.
name|get
argument_list|(
name|hit
argument_list|)
operator|.
name|output
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|testLargeOutputsOnArrayArcs
specifier|public
name|void
name|testLargeOutputsOnArrayArcs
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|ByteSequenceOutputs
name|outputs
init|=
name|ByteSequenceOutputs
operator|.
name|getSingleton
argument_list|()
decl_stmt|;
specifier|final
name|Builder
argument_list|<
name|BytesRef
argument_list|>
name|builder
init|=
operator|new
name|Builder
argument_list|<>
argument_list|(
name|FST
operator|.
name|INPUT_TYPE
operator|.
name|BYTE1
argument_list|,
name|outputs
argument_list|)
decl_stmt|;
specifier|final
name|byte
index|[]
name|bytes
init|=
operator|new
name|byte
index|[
literal|300
index|]
decl_stmt|;
specifier|final
name|IntsRefBuilder
name|input
init|=
operator|new
name|IntsRefBuilder
argument_list|()
decl_stmt|;
name|input
operator|.
name|append
argument_list|(
literal|0
argument_list|)
expr_stmt|;
specifier|final
name|BytesRef
name|output
init|=
operator|new
name|BytesRef
argument_list|(
name|bytes
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|arc
init|=
literal|0
init|;
name|arc
operator|<
literal|6
condition|;
name|arc
operator|++
control|)
block|{
name|input
operator|.
name|setIntAt
argument_list|(
literal|0
argument_list|,
name|arc
argument_list|)
expr_stmt|;
name|output
operator|.
name|bytes
index|[
literal|0
index|]
operator|=
operator|(
name|byte
operator|)
name|arc
expr_stmt|;
name|builder
operator|.
name|add
argument_list|(
name|input
operator|.
name|get
argument_list|()
argument_list|,
name|BytesRef
operator|.
name|deepCopyOf
argument_list|(
name|output
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|final
name|FST
argument_list|<
name|BytesRef
argument_list|>
name|fst
init|=
name|builder
operator|.
name|finish
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|arc
init|=
literal|0
init|;
name|arc
operator|<
literal|6
condition|;
name|arc
operator|++
control|)
block|{
name|input
operator|.
name|setIntAt
argument_list|(
literal|0
argument_list|,
name|arc
argument_list|)
expr_stmt|;
specifier|final
name|BytesRef
name|result
init|=
name|Util
operator|.
name|get
argument_list|(
name|fst
argument_list|,
name|input
operator|.
name|get
argument_list|()
argument_list|)
decl_stmt|;
name|assertNotNull
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|300
argument_list|,
name|result
operator|.
name|length
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|result
operator|.
name|bytes
index|[
name|result
operator|.
name|offset
index|]
argument_list|,
name|arc
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|byteIDX
init|=
literal|1
init|;
name|byteIDX
operator|<
name|result
operator|.
name|length
condition|;
name|byteIDX
operator|++
control|)
block|{
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|result
operator|.
name|bytes
index|[
name|result
operator|.
name|offset
operator|+
name|byteIDX
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|testIllegallyModifyRootArc
specifier|public
name|void
name|testIllegallyModifyRootArc
parameter_list|()
throws|throws
name|Exception
block|{
name|assumeTrue
argument_list|(
literal|"test relies on assertions"
argument_list|,
name|assertsAreEnabled
argument_list|)
expr_stmt|;
name|Set
argument_list|<
name|BytesRef
argument_list|>
name|terms
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|100
condition|;
name|i
operator|++
control|)
block|{
name|String
name|prefix
init|=
name|Character
operator|.
name|toString
argument_list|(
call|(
name|char
call|)
argument_list|(
literal|'a'
operator|+
name|i
argument_list|)
argument_list|)
decl_stmt|;
name|terms
operator|.
name|add
argument_list|(
operator|new
name|BytesRef
argument_list|(
name|prefix
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|prefix
operator|.
name|equals
argument_list|(
literal|"m"
argument_list|)
operator|==
literal|false
condition|)
block|{
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
literal|20
condition|;
name|j
operator|++
control|)
block|{
comment|// Make a big enough FST that the root cache will be created:
name|String
name|suffix
init|=
name|TestUtil
operator|.
name|randomRealisticUnicodeString
argument_list|(
name|random
argument_list|()
argument_list|,
literal|10
argument_list|,
literal|20
argument_list|)
decl_stmt|;
name|terms
operator|.
name|add
argument_list|(
operator|new
name|BytesRef
argument_list|(
name|prefix
operator|+
name|suffix
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|List
argument_list|<
name|BytesRef
argument_list|>
name|termsList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|terms
argument_list|)
decl_stmt|;
name|Collections
operator|.
name|sort
argument_list|(
name|termsList
argument_list|)
expr_stmt|;
name|ByteSequenceOutputs
name|outputs
init|=
name|ByteSequenceOutputs
operator|.
name|getSingleton
argument_list|()
decl_stmt|;
name|Builder
argument_list|<
name|BytesRef
argument_list|>
name|builder
init|=
operator|new
name|Builder
argument_list|<>
argument_list|(
name|FST
operator|.
name|INPUT_TYPE
operator|.
name|BYTE1
argument_list|,
name|outputs
argument_list|)
decl_stmt|;
name|IntsRefBuilder
name|input
init|=
operator|new
name|IntsRefBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|BytesRef
name|term
range|:
name|termsList
control|)
block|{
name|Util
operator|.
name|toIntsRef
argument_list|(
name|term
argument_list|,
name|input
argument_list|)
expr_stmt|;
name|builder
operator|.
name|add
argument_list|(
name|input
operator|.
name|get
argument_list|()
argument_list|,
name|term
argument_list|)
expr_stmt|;
block|}
name|FST
argument_list|<
name|BytesRef
argument_list|>
name|fst
init|=
name|builder
operator|.
name|finish
argument_list|()
decl_stmt|;
name|Arc
argument_list|<
name|BytesRef
argument_list|>
name|arc
init|=
operator|new
name|FST
operator|.
name|Arc
argument_list|<>
argument_list|()
decl_stmt|;
name|fst
operator|.
name|getFirstArc
argument_list|(
name|arc
argument_list|)
expr_stmt|;
name|FST
operator|.
name|BytesReader
name|reader
init|=
name|fst
operator|.
name|getBytesReader
argument_list|()
decl_stmt|;
name|arc
operator|=
name|fst
operator|.
name|findTargetArc
argument_list|(
operator|(
name|int
operator|)
literal|'m'
argument_list|,
name|arc
argument_list|,
name|arc
argument_list|,
name|reader
argument_list|)
expr_stmt|;
name|assertNotNull
argument_list|(
name|arc
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
operator|new
name|BytesRef
argument_list|(
literal|"m"
argument_list|)
argument_list|,
name|arc
operator|.
name|output
argument_list|)
expr_stmt|;
comment|// NOTE: illegal:
name|arc
operator|.
name|output
operator|.
name|length
operator|=
literal|0
expr_stmt|;
name|fst
operator|.
name|getFirstArc
argument_list|(
name|arc
argument_list|)
expr_stmt|;
try|try
block|{
name|arc
operator|=
name|fst
operator|.
name|findTargetArc
argument_list|(
operator|(
name|int
operator|)
literal|'m'
argument_list|,
name|arc
argument_list|,
name|arc
argument_list|,
name|reader
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|AssertionError
name|ae
parameter_list|)
block|{
comment|// expected
block|}
block|}
block|}
end_class
end_unit
