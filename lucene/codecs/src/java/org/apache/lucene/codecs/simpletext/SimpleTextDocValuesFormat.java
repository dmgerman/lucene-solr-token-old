begin_unit
begin_package
DECL|package|org.apache.lucene.codecs.simpletext
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|codecs
operator|.
name|simpletext
package|;
end_package
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|codecs
operator|.
name|DocValuesConsumer
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|codecs
operator|.
name|DocValuesProducer
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|codecs
operator|.
name|DocValuesFormat
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|SegmentReadState
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|SegmentWriteState
import|;
end_import
begin_comment
comment|/**  * plain text doc values format.  *<p>  *<b>FOR RECREATIONAL USE ONLY</b>  *<p>  * the .dat file contains the data.  *  for numbers this is a "fixed-width" file, for example a single byte range:  *<pre>  *  field myField  *    type NUMERIC  *    minvalue 0  *    pattern 000  *  005  *  T  *  234  *  T  *  123  *  T  *  ...  *</pre>  *  so a document's value (delta encoded from minvalue) can be retrieved by   *  seeking to startOffset + (1+pattern.length()+2)*docid. The extra 1 is the newline.   *  The extra 2 is another newline and 'T' or 'F': true if the value is real, false if missing.  *    *  for bytes this is also a "fixed-width" file, for example:  *<pre>  *  field myField  *    type BINARY  *    maxlength 6  *    pattern 0  *  length 6  *  foobar[space][space]  *  T  *  length 3  *  baz[space][space][space][space][space]  *  T  *  ...  *</pre>  *  so a doc's value can be retrieved by seeking to startOffset + (9+pattern.length+maxlength+2)*doc  *  the extra 9 is 2 newlines, plus "length " itself.  *  the extra 2 is another newline and 'T' or 'F': true if the value is real, false if missing.  *    *  for sorted bytes this is a fixed-width file, for example:  *<pre>  *  field myField  *    type SORTED  *    numvalues 10  *    maxLength 8  *    pattern 0  *    ordpattern 00  *  length 6  *  foobar[space][space]  *  length 3  *  baz[space][space][space][space][space]  *  ...  *  03  *  06  *  01  *  10  *  ...  *</pre>  *  so the "ord section" begins at startOffset + (9+pattern.length+maxlength)*numValues.  *  a document's ord can be retrieved by seeking to "ord section" + (1+ordpattern.length())*docid  *  an ord's value can be retrieved by seeking to startOffset + (9+pattern.length+maxlength)*ord  *    *  for sorted set this is a fixed-width file very similar to the SORTED case, for example:  *<pre>  *  field myField  *    type SORTED_SET  *    numvalues 10  *    maxLength 8  *    pattern 0  *    ordpattern XXXXX  *  length 6  *  foobar[space][space]  *  length 3  *  baz[space][space][space][space][space]  *  ...  *  0,3,5     *  1,2  *    *  10  *  ...  *</pre>  *  so the "ord section" begins at startOffset + (9+pattern.length+maxlength)*numValues.  *  a document's ord list can be retrieved by seeking to "ord section" + (1+ordpattern.length())*docid  *  this is a comma-separated list, and its padded with spaces to be fixed width. so trim() and split() it.  *  and beware the empty string!  *  an ord's value can be retrieved by seeking to startOffset + (9+pattern.length+maxlength)*ord  *    *  for sorted numerics, its encoded (not very creatively) as a comma-separated list of strings the same as binary.  *  beware the empty string!  *     *  the reader can just scan this file when it opens, skipping over the data blocks  *  and saving the offset/etc for each field.   *  @lucene.experimental  */
end_comment
begin_class
DECL|class|SimpleTextDocValuesFormat
specifier|public
class|class
name|SimpleTextDocValuesFormat
extends|extends
name|DocValuesFormat
block|{
DECL|method|SimpleTextDocValuesFormat
specifier|public
name|SimpleTextDocValuesFormat
parameter_list|()
block|{
name|super
argument_list|(
literal|"SimpleText"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|fieldsConsumer
specifier|public
name|DocValuesConsumer
name|fieldsConsumer
parameter_list|(
name|SegmentWriteState
name|state
parameter_list|)
throws|throws
name|IOException
block|{
return|return
operator|new
name|SimpleTextDocValuesWriter
argument_list|(
name|state
argument_list|,
literal|"dat"
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|fieldsProducer
specifier|public
name|DocValuesProducer
name|fieldsProducer
parameter_list|(
name|SegmentReadState
name|state
parameter_list|)
throws|throws
name|IOException
block|{
return|return
operator|new
name|SimpleTextDocValuesReader
argument_list|(
name|state
argument_list|,
literal|"dat"
argument_list|)
return|;
block|}
block|}
end_class
end_unit
