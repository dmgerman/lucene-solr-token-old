begin_unit
begin_package
DECL|package|org.apache.lucene.codecs.pulsing
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|codecs
operator|.
name|pulsing
package|;
end_package
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|IdentityHashMap
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeMap
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|codecs
operator|.
name|BlockTermState
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|codecs
operator|.
name|CodecUtil
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|codecs
operator|.
name|PostingsReaderBase
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|DocsAndPositionsEnum
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|DocsEnum
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|IndexFileNames
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|FieldInfo
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|FieldInfo
operator|.
name|IndexOptions
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|SegmentReadState
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|TermState
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|ByteArrayDataInput
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|DataInput
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|IndexInput
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|ArrayUtil
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|Attribute
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|AttributeImpl
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|AttributeSource
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|Bits
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|BytesRef
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|IOUtils
import|;
end_import
begin_comment
comment|/** Concrete class that reads the current doc/freq/skip  *  postings format   *  @lucene.experimental */
end_comment
begin_comment
comment|// TODO: -- should we switch "hasProx" higher up?  and
end_comment
begin_comment
comment|// create two separate docs readers, one that also reads
end_comment
begin_comment
comment|// prox and one that doesn't?
end_comment
begin_class
DECL|class|PulsingPostingsReader
specifier|public
class|class
name|PulsingPostingsReader
extends|extends
name|PostingsReaderBase
block|{
comment|// Fallback reader for non-pulsed terms:
DECL|field|wrappedPostingsReader
specifier|final
name|PostingsReaderBase
name|wrappedPostingsReader
decl_stmt|;
DECL|field|segmentState
specifier|final
name|SegmentReadState
name|segmentState
decl_stmt|;
DECL|field|maxPositions
name|int
name|maxPositions
decl_stmt|;
DECL|field|version
name|int
name|version
decl_stmt|;
DECL|field|fields
name|TreeMap
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|fields
decl_stmt|;
DECL|method|PulsingPostingsReader
specifier|public
name|PulsingPostingsReader
parameter_list|(
name|SegmentReadState
name|state
parameter_list|,
name|PostingsReaderBase
name|wrappedPostingsReader
parameter_list|)
block|{
name|this
operator|.
name|wrappedPostingsReader
operator|=
name|wrappedPostingsReader
expr_stmt|;
name|this
operator|.
name|segmentState
operator|=
name|state
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|init
specifier|public
name|void
name|init
parameter_list|(
name|IndexInput
name|termsIn
parameter_list|)
throws|throws
name|IOException
block|{
name|version
operator|=
name|CodecUtil
operator|.
name|checkHeader
argument_list|(
name|termsIn
argument_list|,
name|PulsingPostingsWriter
operator|.
name|CODEC
argument_list|,
name|PulsingPostingsWriter
operator|.
name|VERSION_START
argument_list|,
name|PulsingPostingsWriter
operator|.
name|VERSION_CURRENT
argument_list|)
expr_stmt|;
name|maxPositions
operator|=
name|termsIn
operator|.
name|readVInt
argument_list|()
expr_stmt|;
name|wrappedPostingsReader
operator|.
name|init
argument_list|(
name|termsIn
argument_list|)
expr_stmt|;
if|if
condition|(
name|wrappedPostingsReader
operator|instanceof
name|PulsingPostingsReader
operator|||
name|version
operator|<
name|PulsingPostingsWriter
operator|.
name|VERSION_META_ARRAY
condition|)
block|{
name|fields
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
name|fields
operator|=
operator|new
name|TreeMap
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
argument_list|()
expr_stmt|;
name|String
name|summaryFileName
init|=
name|IndexFileNames
operator|.
name|segmentFileName
argument_list|(
name|segmentState
operator|.
name|segmentInfo
operator|.
name|name
argument_list|,
name|segmentState
operator|.
name|segmentSuffix
argument_list|,
name|PulsingPostingsWriter
operator|.
name|SUMMARY_EXTENSION
argument_list|)
decl_stmt|;
name|IndexInput
name|in
init|=
literal|null
decl_stmt|;
try|try
block|{
name|in
operator|=
name|segmentState
operator|.
name|directory
operator|.
name|openInput
argument_list|(
name|summaryFileName
argument_list|,
name|segmentState
operator|.
name|context
argument_list|)
expr_stmt|;
name|CodecUtil
operator|.
name|checkHeader
argument_list|(
name|in
argument_list|,
name|PulsingPostingsWriter
operator|.
name|CODEC
argument_list|,
name|version
argument_list|,
name|PulsingPostingsWriter
operator|.
name|VERSION_CURRENT
argument_list|)
expr_stmt|;
name|int
name|numField
init|=
name|in
operator|.
name|readVInt
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numField
condition|;
name|i
operator|++
control|)
block|{
name|int
name|fieldNum
init|=
name|in
operator|.
name|readVInt
argument_list|()
decl_stmt|;
name|int
name|longsSize
init|=
name|in
operator|.
name|readVInt
argument_list|()
decl_stmt|;
name|fields
operator|.
name|put
argument_list|(
name|fieldNum
argument_list|,
name|longsSize
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|IOUtils
operator|.
name|closeWhileHandlingException
argument_list|(
name|in
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|class|PulsingTermState
specifier|private
specifier|static
class|class
name|PulsingTermState
extends|extends
name|BlockTermState
block|{
DECL|field|absolute
specifier|private
name|boolean
name|absolute
init|=
literal|false
decl_stmt|;
DECL|field|longs
specifier|private
name|long
index|[]
name|longs
decl_stmt|;
DECL|field|postings
specifier|private
name|byte
index|[]
name|postings
decl_stmt|;
DECL|field|postingsSize
specifier|private
name|int
name|postingsSize
decl_stmt|;
comment|// -1 if this term was not inlined
DECL|field|wrappedTermState
specifier|private
name|BlockTermState
name|wrappedTermState
decl_stmt|;
annotation|@
name|Override
DECL|method|clone
specifier|public
name|PulsingTermState
name|clone
parameter_list|()
block|{
name|PulsingTermState
name|clone
decl_stmt|;
name|clone
operator|=
operator|(
name|PulsingTermState
operator|)
name|super
operator|.
name|clone
argument_list|()
expr_stmt|;
if|if
condition|(
name|postingsSize
operator|!=
operator|-
literal|1
condition|)
block|{
name|clone
operator|.
name|postings
operator|=
operator|new
name|byte
index|[
name|postingsSize
index|]
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|postings
argument_list|,
literal|0
argument_list|,
name|clone
operator|.
name|postings
argument_list|,
literal|0
argument_list|,
name|postingsSize
argument_list|)
expr_stmt|;
block|}
else|else
block|{
assert|assert
name|wrappedTermState
operator|!=
literal|null
assert|;
name|clone
operator|.
name|wrappedTermState
operator|=
operator|(
name|BlockTermState
operator|)
name|wrappedTermState
operator|.
name|clone
argument_list|()
expr_stmt|;
name|clone
operator|.
name|absolute
operator|=
name|absolute
expr_stmt|;
if|if
condition|(
name|longs
operator|!=
literal|null
condition|)
block|{
name|clone
operator|.
name|longs
operator|=
operator|new
name|long
index|[
name|longs
operator|.
name|length
index|]
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|longs
argument_list|,
literal|0
argument_list|,
name|clone
operator|.
name|longs
argument_list|,
literal|0
argument_list|,
name|longs
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|clone
return|;
block|}
annotation|@
name|Override
DECL|method|copyFrom
specifier|public
name|void
name|copyFrom
parameter_list|(
name|TermState
name|_other
parameter_list|)
block|{
name|super
operator|.
name|copyFrom
argument_list|(
name|_other
argument_list|)
expr_stmt|;
name|PulsingTermState
name|other
init|=
operator|(
name|PulsingTermState
operator|)
name|_other
decl_stmt|;
name|postingsSize
operator|=
name|other
operator|.
name|postingsSize
expr_stmt|;
if|if
condition|(
name|other
operator|.
name|postingsSize
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|postings
operator|==
literal|null
operator|||
name|postings
operator|.
name|length
operator|<
name|other
operator|.
name|postingsSize
condition|)
block|{
name|postings
operator|=
operator|new
name|byte
index|[
name|ArrayUtil
operator|.
name|oversize
argument_list|(
name|other
operator|.
name|postingsSize
argument_list|,
literal|1
argument_list|)
index|]
expr_stmt|;
block|}
name|System
operator|.
name|arraycopy
argument_list|(
name|other
operator|.
name|postings
argument_list|,
literal|0
argument_list|,
name|postings
argument_list|,
literal|0
argument_list|,
name|other
operator|.
name|postingsSize
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|wrappedTermState
operator|.
name|copyFrom
argument_list|(
name|other
operator|.
name|wrappedTermState
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
if|if
condition|(
name|postingsSize
operator|==
operator|-
literal|1
condition|)
block|{
return|return
literal|"PulsingTermState: not inlined: wrapped="
operator|+
name|wrappedTermState
return|;
block|}
else|else
block|{
return|return
literal|"PulsingTermState: inlined size="
operator|+
name|postingsSize
operator|+
literal|" "
operator|+
name|super
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
block|}
annotation|@
name|Override
DECL|method|newTermState
specifier|public
name|BlockTermState
name|newTermState
parameter_list|()
throws|throws
name|IOException
block|{
name|PulsingTermState
name|state
init|=
operator|new
name|PulsingTermState
argument_list|()
decl_stmt|;
name|state
operator|.
name|wrappedTermState
operator|=
name|wrappedPostingsReader
operator|.
name|newTermState
argument_list|()
expr_stmt|;
return|return
name|state
return|;
block|}
annotation|@
name|Override
DECL|method|decodeTerm
specifier|public
name|void
name|decodeTerm
parameter_list|(
name|long
index|[]
name|empty
parameter_list|,
name|DataInput
name|in
parameter_list|,
name|FieldInfo
name|fieldInfo
parameter_list|,
name|BlockTermState
name|_termState
parameter_list|,
name|boolean
name|absolute
parameter_list|)
throws|throws
name|IOException
block|{
comment|//System.out.println("PR nextTerm");
name|PulsingTermState
name|termState
init|=
operator|(
name|PulsingTermState
operator|)
name|_termState
decl_stmt|;
assert|assert
name|empty
operator|.
name|length
operator|==
literal|0
assert|;
name|termState
operator|.
name|absolute
operator|=
name|termState
operator|.
name|absolute
operator|||
name|absolute
expr_stmt|;
comment|// if we have positions, its total TF, otherwise its computed based on docFreq.
name|long
name|count
init|=
name|fieldInfo
operator|.
name|getIndexOptions
argument_list|()
operator|.
name|compareTo
argument_list|(
name|IndexOptions
operator|.
name|DOCS_AND_FREQS_AND_POSITIONS
argument_list|)
operator|>=
literal|0
condition|?
name|termState
operator|.
name|totalTermFreq
else|:
name|termState
operator|.
name|docFreq
decl_stmt|;
comment|//System.out.println("  count=" + count + " threshold=" + maxPositions);
if|if
condition|(
name|count
operator|<=
name|maxPositions
condition|)
block|{
comment|// Inlined into terms dict -- just read the byte[] blob in,
comment|// but don't decode it now (we only decode when a DocsEnum
comment|// or D&PEnum is pulled):
name|termState
operator|.
name|postingsSize
operator|=
name|in
operator|.
name|readVInt
argument_list|()
expr_stmt|;
if|if
condition|(
name|termState
operator|.
name|postings
operator|==
literal|null
operator|||
name|termState
operator|.
name|postings
operator|.
name|length
operator|<
name|termState
operator|.
name|postingsSize
condition|)
block|{
name|termState
operator|.
name|postings
operator|=
operator|new
name|byte
index|[
name|ArrayUtil
operator|.
name|oversize
argument_list|(
name|termState
operator|.
name|postingsSize
argument_list|,
literal|1
argument_list|)
index|]
expr_stmt|;
block|}
comment|// TODO: sort of silly to copy from one big byte[]
comment|// (the blob holding all inlined terms' blobs for
comment|// current term block) into another byte[] (just the
comment|// blob for this term)...
name|in
operator|.
name|readBytes
argument_list|(
name|termState
operator|.
name|postings
argument_list|,
literal|0
argument_list|,
name|termState
operator|.
name|postingsSize
argument_list|)
expr_stmt|;
comment|//System.out.println("  inlined bytes=" + termState.postingsSize);
name|termState
operator|.
name|absolute
operator|=
name|termState
operator|.
name|absolute
operator|||
name|absolute
expr_stmt|;
block|}
else|else
block|{
comment|//System.out.println("  not inlined");
specifier|final
name|int
name|longsSize
init|=
name|fields
operator|==
literal|null
condition|?
literal|0
else|:
name|fields
operator|.
name|get
argument_list|(
name|fieldInfo
operator|.
name|number
argument_list|)
decl_stmt|;
if|if
condition|(
name|termState
operator|.
name|longs
operator|==
literal|null
condition|)
block|{
name|termState
operator|.
name|longs
operator|=
operator|new
name|long
index|[
name|longsSize
index|]
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|longsSize
condition|;
name|i
operator|++
control|)
block|{
name|termState
operator|.
name|longs
index|[
name|i
index|]
operator|=
name|in
operator|.
name|readVLong
argument_list|()
expr_stmt|;
block|}
name|termState
operator|.
name|postingsSize
operator|=
operator|-
literal|1
expr_stmt|;
name|termState
operator|.
name|wrappedTermState
operator|.
name|docFreq
operator|=
name|termState
operator|.
name|docFreq
expr_stmt|;
name|termState
operator|.
name|wrappedTermState
operator|.
name|totalTermFreq
operator|=
name|termState
operator|.
name|totalTermFreq
expr_stmt|;
name|wrappedPostingsReader
operator|.
name|decodeTerm
argument_list|(
name|termState
operator|.
name|longs
argument_list|,
name|in
argument_list|,
name|fieldInfo
argument_list|,
name|termState
operator|.
name|wrappedTermState
argument_list|,
name|termState
operator|.
name|absolute
argument_list|)
expr_stmt|;
name|termState
operator|.
name|absolute
operator|=
literal|false
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|docs
specifier|public
name|DocsEnum
name|docs
parameter_list|(
name|FieldInfo
name|field
parameter_list|,
name|BlockTermState
name|_termState
parameter_list|,
name|Bits
name|liveDocs
parameter_list|,
name|DocsEnum
name|reuse
parameter_list|,
name|int
name|flags
parameter_list|)
throws|throws
name|IOException
block|{
name|PulsingTermState
name|termState
init|=
operator|(
name|PulsingTermState
operator|)
name|_termState
decl_stmt|;
if|if
condition|(
name|termState
operator|.
name|postingsSize
operator|!=
operator|-
literal|1
condition|)
block|{
name|PulsingDocsEnum
name|postings
decl_stmt|;
if|if
condition|(
name|reuse
operator|instanceof
name|PulsingDocsEnum
condition|)
block|{
name|postings
operator|=
operator|(
name|PulsingDocsEnum
operator|)
name|reuse
expr_stmt|;
if|if
condition|(
operator|!
name|postings
operator|.
name|canReuse
argument_list|(
name|field
argument_list|)
condition|)
block|{
name|postings
operator|=
operator|new
name|PulsingDocsEnum
argument_list|(
name|field
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// the 'reuse' is actually the wrapped enum
name|PulsingDocsEnum
name|previous
init|=
operator|(
name|PulsingDocsEnum
operator|)
name|getOther
argument_list|(
name|reuse
argument_list|)
decl_stmt|;
if|if
condition|(
name|previous
operator|!=
literal|null
operator|&&
name|previous
operator|.
name|canReuse
argument_list|(
name|field
argument_list|)
condition|)
block|{
name|postings
operator|=
name|previous
expr_stmt|;
block|}
else|else
block|{
name|postings
operator|=
operator|new
name|PulsingDocsEnum
argument_list|(
name|field
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|reuse
operator|!=
name|postings
condition|)
block|{
name|setOther
argument_list|(
name|postings
argument_list|,
name|reuse
argument_list|)
expr_stmt|;
comment|// postings.other = reuse
block|}
return|return
name|postings
operator|.
name|reset
argument_list|(
name|liveDocs
argument_list|,
name|termState
argument_list|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|reuse
operator|instanceof
name|PulsingDocsEnum
condition|)
block|{
name|DocsEnum
name|wrapped
init|=
name|wrappedPostingsReader
operator|.
name|docs
argument_list|(
name|field
argument_list|,
name|termState
operator|.
name|wrappedTermState
argument_list|,
name|liveDocs
argument_list|,
name|getOther
argument_list|(
name|reuse
argument_list|)
argument_list|,
name|flags
argument_list|)
decl_stmt|;
name|setOther
argument_list|(
name|wrapped
argument_list|,
name|reuse
argument_list|)
expr_stmt|;
comment|// wrapped.other = reuse
return|return
name|wrapped
return|;
block|}
else|else
block|{
return|return
name|wrappedPostingsReader
operator|.
name|docs
argument_list|(
name|field
argument_list|,
name|termState
operator|.
name|wrappedTermState
argument_list|,
name|liveDocs
argument_list|,
name|reuse
argument_list|,
name|flags
argument_list|)
return|;
block|}
block|}
block|}
annotation|@
name|Override
DECL|method|docsAndPositions
specifier|public
name|DocsAndPositionsEnum
name|docsAndPositions
parameter_list|(
name|FieldInfo
name|field
parameter_list|,
name|BlockTermState
name|_termState
parameter_list|,
name|Bits
name|liveDocs
parameter_list|,
name|DocsAndPositionsEnum
name|reuse
parameter_list|,
name|int
name|flags
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|PulsingTermState
name|termState
init|=
operator|(
name|PulsingTermState
operator|)
name|_termState
decl_stmt|;
if|if
condition|(
name|termState
operator|.
name|postingsSize
operator|!=
operator|-
literal|1
condition|)
block|{
name|PulsingDocsAndPositionsEnum
name|postings
decl_stmt|;
if|if
condition|(
name|reuse
operator|instanceof
name|PulsingDocsAndPositionsEnum
condition|)
block|{
name|postings
operator|=
operator|(
name|PulsingDocsAndPositionsEnum
operator|)
name|reuse
expr_stmt|;
if|if
condition|(
operator|!
name|postings
operator|.
name|canReuse
argument_list|(
name|field
argument_list|)
condition|)
block|{
name|postings
operator|=
operator|new
name|PulsingDocsAndPositionsEnum
argument_list|(
name|field
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// the 'reuse' is actually the wrapped enum
name|PulsingDocsAndPositionsEnum
name|previous
init|=
operator|(
name|PulsingDocsAndPositionsEnum
operator|)
name|getOther
argument_list|(
name|reuse
argument_list|)
decl_stmt|;
if|if
condition|(
name|previous
operator|!=
literal|null
operator|&&
name|previous
operator|.
name|canReuse
argument_list|(
name|field
argument_list|)
condition|)
block|{
name|postings
operator|=
name|previous
expr_stmt|;
block|}
else|else
block|{
name|postings
operator|=
operator|new
name|PulsingDocsAndPositionsEnum
argument_list|(
name|field
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|reuse
operator|!=
name|postings
condition|)
block|{
name|setOther
argument_list|(
name|postings
argument_list|,
name|reuse
argument_list|)
expr_stmt|;
comment|// postings.other = reuse
block|}
return|return
name|postings
operator|.
name|reset
argument_list|(
name|liveDocs
argument_list|,
name|termState
argument_list|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|reuse
operator|instanceof
name|PulsingDocsAndPositionsEnum
condition|)
block|{
name|DocsAndPositionsEnum
name|wrapped
init|=
name|wrappedPostingsReader
operator|.
name|docsAndPositions
argument_list|(
name|field
argument_list|,
name|termState
operator|.
name|wrappedTermState
argument_list|,
name|liveDocs
argument_list|,
operator|(
name|DocsAndPositionsEnum
operator|)
name|getOther
argument_list|(
name|reuse
argument_list|)
argument_list|,
name|flags
argument_list|)
decl_stmt|;
name|setOther
argument_list|(
name|wrapped
argument_list|,
name|reuse
argument_list|)
expr_stmt|;
comment|// wrapped.other = reuse
return|return
name|wrapped
return|;
block|}
else|else
block|{
return|return
name|wrappedPostingsReader
operator|.
name|docsAndPositions
argument_list|(
name|field
argument_list|,
name|termState
operator|.
name|wrappedTermState
argument_list|,
name|liveDocs
argument_list|,
name|reuse
argument_list|,
name|flags
argument_list|)
return|;
block|}
block|}
block|}
DECL|class|PulsingDocsEnum
specifier|private
specifier|static
class|class
name|PulsingDocsEnum
extends|extends
name|DocsEnum
block|{
DECL|field|postingsBytes
specifier|private
name|byte
index|[]
name|postingsBytes
decl_stmt|;
DECL|field|postings
specifier|private
specifier|final
name|ByteArrayDataInput
name|postings
init|=
operator|new
name|ByteArrayDataInput
argument_list|()
decl_stmt|;
DECL|field|indexOptions
specifier|private
specifier|final
name|IndexOptions
name|indexOptions
decl_stmt|;
DECL|field|storePayloads
specifier|private
specifier|final
name|boolean
name|storePayloads
decl_stmt|;
DECL|field|storeOffsets
specifier|private
specifier|final
name|boolean
name|storeOffsets
decl_stmt|;
DECL|field|liveDocs
specifier|private
name|Bits
name|liveDocs
decl_stmt|;
DECL|field|docID
specifier|private
name|int
name|docID
init|=
operator|-
literal|1
decl_stmt|;
DECL|field|accum
specifier|private
name|int
name|accum
decl_stmt|;
DECL|field|freq
specifier|private
name|int
name|freq
decl_stmt|;
DECL|field|payloadLength
specifier|private
name|int
name|payloadLength
decl_stmt|;
DECL|field|cost
specifier|private
name|int
name|cost
decl_stmt|;
DECL|method|PulsingDocsEnum
specifier|public
name|PulsingDocsEnum
parameter_list|(
name|FieldInfo
name|fieldInfo
parameter_list|)
block|{
name|indexOptions
operator|=
name|fieldInfo
operator|.
name|getIndexOptions
argument_list|()
expr_stmt|;
name|storePayloads
operator|=
name|fieldInfo
operator|.
name|hasPayloads
argument_list|()
expr_stmt|;
name|storeOffsets
operator|=
name|indexOptions
operator|.
name|compareTo
argument_list|(
name|IndexOptions
operator|.
name|DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS
argument_list|)
operator|>=
literal|0
expr_stmt|;
block|}
DECL|method|reset
specifier|public
name|PulsingDocsEnum
name|reset
parameter_list|(
name|Bits
name|liveDocs
parameter_list|,
name|PulsingTermState
name|termState
parameter_list|)
block|{
comment|//System.out.println("PR docsEnum termState=" + termState + " docFreq=" + termState.docFreq);
assert|assert
name|termState
operator|.
name|postingsSize
operator|!=
operator|-
literal|1
assert|;
comment|// Must make a copy of termState's byte[] so that if
comment|// app does TermsEnum.next(), this DocsEnum is not affected
if|if
condition|(
name|postingsBytes
operator|==
literal|null
condition|)
block|{
name|postingsBytes
operator|=
operator|new
name|byte
index|[
name|termState
operator|.
name|postingsSize
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|postingsBytes
operator|.
name|length
operator|<
name|termState
operator|.
name|postingsSize
condition|)
block|{
name|postingsBytes
operator|=
name|ArrayUtil
operator|.
name|grow
argument_list|(
name|postingsBytes
argument_list|,
name|termState
operator|.
name|postingsSize
argument_list|)
expr_stmt|;
block|}
name|System
operator|.
name|arraycopy
argument_list|(
name|termState
operator|.
name|postings
argument_list|,
literal|0
argument_list|,
name|postingsBytes
argument_list|,
literal|0
argument_list|,
name|termState
operator|.
name|postingsSize
argument_list|)
expr_stmt|;
name|postings
operator|.
name|reset
argument_list|(
name|postingsBytes
argument_list|,
literal|0
argument_list|,
name|termState
operator|.
name|postingsSize
argument_list|)
expr_stmt|;
name|docID
operator|=
operator|-
literal|1
expr_stmt|;
name|accum
operator|=
literal|0
expr_stmt|;
name|freq
operator|=
literal|1
expr_stmt|;
name|cost
operator|=
name|termState
operator|.
name|docFreq
expr_stmt|;
name|payloadLength
operator|=
literal|0
expr_stmt|;
name|this
operator|.
name|liveDocs
operator|=
name|liveDocs
expr_stmt|;
return|return
name|this
return|;
block|}
DECL|method|canReuse
name|boolean
name|canReuse
parameter_list|(
name|FieldInfo
name|fieldInfo
parameter_list|)
block|{
return|return
name|indexOptions
operator|==
name|fieldInfo
operator|.
name|getIndexOptions
argument_list|()
operator|&&
name|storePayloads
operator|==
name|fieldInfo
operator|.
name|hasPayloads
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|nextDoc
specifier|public
name|int
name|nextDoc
parameter_list|()
throws|throws
name|IOException
block|{
comment|//System.out.println("PR nextDoc this= "+ this);
while|while
condition|(
literal|true
condition|)
block|{
if|if
condition|(
name|postings
operator|.
name|eof
argument_list|()
condition|)
block|{
comment|//System.out.println("PR   END");
return|return
name|docID
operator|=
name|NO_MORE_DOCS
return|;
block|}
specifier|final
name|int
name|code
init|=
name|postings
operator|.
name|readVInt
argument_list|()
decl_stmt|;
comment|//System.out.println("  read code=" + code);
if|if
condition|(
name|indexOptions
operator|==
name|IndexOptions
operator|.
name|DOCS_ONLY
condition|)
block|{
name|accum
operator|+=
name|code
expr_stmt|;
block|}
else|else
block|{
name|accum
operator|+=
name|code
operator|>>>
literal|1
expr_stmt|;
comment|// shift off low bit
if|if
condition|(
operator|(
name|code
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
block|{
comment|// if low bit is set
name|freq
operator|=
literal|1
expr_stmt|;
comment|// freq is one
block|}
else|else
block|{
name|freq
operator|=
name|postings
operator|.
name|readVInt
argument_list|()
expr_stmt|;
comment|// else read freq
block|}
if|if
condition|(
name|indexOptions
operator|.
name|compareTo
argument_list|(
name|IndexOptions
operator|.
name|DOCS_AND_FREQS_AND_POSITIONS
argument_list|)
operator|>=
literal|0
condition|)
block|{
comment|// Skip positions
if|if
condition|(
name|storePayloads
condition|)
block|{
for|for
control|(
name|int
name|pos
init|=
literal|0
init|;
name|pos
operator|<
name|freq
condition|;
name|pos
operator|++
control|)
block|{
specifier|final
name|int
name|posCode
init|=
name|postings
operator|.
name|readVInt
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|posCode
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
block|{
name|payloadLength
operator|=
name|postings
operator|.
name|readVInt
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|storeOffsets
operator|&&
operator|(
name|postings
operator|.
name|readVInt
argument_list|()
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
block|{
comment|// new offset length
name|postings
operator|.
name|readVInt
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|payloadLength
operator|!=
literal|0
condition|)
block|{
name|postings
operator|.
name|skipBytes
argument_list|(
name|payloadLength
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
for|for
control|(
name|int
name|pos
init|=
literal|0
init|;
name|pos
operator|<
name|freq
condition|;
name|pos
operator|++
control|)
block|{
comment|// TODO: skipVInt
name|postings
operator|.
name|readVInt
argument_list|()
expr_stmt|;
if|if
condition|(
name|storeOffsets
operator|&&
operator|(
name|postings
operator|.
name|readVInt
argument_list|()
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
block|{
comment|// new offset length
name|postings
operator|.
name|readVInt
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
if|if
condition|(
name|liveDocs
operator|==
literal|null
operator|||
name|liveDocs
operator|.
name|get
argument_list|(
name|accum
argument_list|)
condition|)
block|{
return|return
operator|(
name|docID
operator|=
name|accum
operator|)
return|;
block|}
block|}
block|}
annotation|@
name|Override
DECL|method|freq
specifier|public
name|int
name|freq
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|freq
return|;
block|}
annotation|@
name|Override
DECL|method|docID
specifier|public
name|int
name|docID
parameter_list|()
block|{
return|return
name|docID
return|;
block|}
annotation|@
name|Override
DECL|method|advance
specifier|public
name|int
name|advance
parameter_list|(
name|int
name|target
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|docID
operator|=
name|slowAdvance
argument_list|(
name|target
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|cost
specifier|public
name|long
name|cost
parameter_list|()
block|{
return|return
name|cost
return|;
block|}
block|}
DECL|class|PulsingDocsAndPositionsEnum
specifier|private
specifier|static
class|class
name|PulsingDocsAndPositionsEnum
extends|extends
name|DocsAndPositionsEnum
block|{
DECL|field|postingsBytes
specifier|private
name|byte
index|[]
name|postingsBytes
decl_stmt|;
DECL|field|postings
specifier|private
specifier|final
name|ByteArrayDataInput
name|postings
init|=
operator|new
name|ByteArrayDataInput
argument_list|()
decl_stmt|;
DECL|field|storePayloads
specifier|private
specifier|final
name|boolean
name|storePayloads
decl_stmt|;
DECL|field|storeOffsets
specifier|private
specifier|final
name|boolean
name|storeOffsets
decl_stmt|;
comment|// note: we could actually reuse across different options, if we passed this to reset()
comment|// and re-init'ed storeOffsets accordingly (made it non-final)
DECL|field|indexOptions
specifier|private
specifier|final
name|IndexOptions
name|indexOptions
decl_stmt|;
DECL|field|liveDocs
specifier|private
name|Bits
name|liveDocs
decl_stmt|;
DECL|field|docID
specifier|private
name|int
name|docID
init|=
operator|-
literal|1
decl_stmt|;
DECL|field|accum
specifier|private
name|int
name|accum
decl_stmt|;
DECL|field|freq
specifier|private
name|int
name|freq
decl_stmt|;
DECL|field|posPending
specifier|private
name|int
name|posPending
decl_stmt|;
DECL|field|position
specifier|private
name|int
name|position
decl_stmt|;
DECL|field|payloadLength
specifier|private
name|int
name|payloadLength
decl_stmt|;
DECL|field|payload
specifier|private
name|BytesRef
name|payload
decl_stmt|;
DECL|field|startOffset
specifier|private
name|int
name|startOffset
decl_stmt|;
DECL|field|offsetLength
specifier|private
name|int
name|offsetLength
decl_stmt|;
DECL|field|payloadRetrieved
specifier|private
name|boolean
name|payloadRetrieved
decl_stmt|;
DECL|field|cost
specifier|private
name|int
name|cost
decl_stmt|;
DECL|method|PulsingDocsAndPositionsEnum
specifier|public
name|PulsingDocsAndPositionsEnum
parameter_list|(
name|FieldInfo
name|fieldInfo
parameter_list|)
block|{
name|indexOptions
operator|=
name|fieldInfo
operator|.
name|getIndexOptions
argument_list|()
expr_stmt|;
name|storePayloads
operator|=
name|fieldInfo
operator|.
name|hasPayloads
argument_list|()
expr_stmt|;
name|storeOffsets
operator|=
name|indexOptions
operator|.
name|compareTo
argument_list|(
name|IndexOptions
operator|.
name|DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS
argument_list|)
operator|>=
literal|0
expr_stmt|;
block|}
DECL|method|canReuse
name|boolean
name|canReuse
parameter_list|(
name|FieldInfo
name|fieldInfo
parameter_list|)
block|{
return|return
name|indexOptions
operator|==
name|fieldInfo
operator|.
name|getIndexOptions
argument_list|()
operator|&&
name|storePayloads
operator|==
name|fieldInfo
operator|.
name|hasPayloads
argument_list|()
return|;
block|}
DECL|method|reset
specifier|public
name|PulsingDocsAndPositionsEnum
name|reset
parameter_list|(
name|Bits
name|liveDocs
parameter_list|,
name|PulsingTermState
name|termState
parameter_list|)
block|{
assert|assert
name|termState
operator|.
name|postingsSize
operator|!=
operator|-
literal|1
assert|;
if|if
condition|(
name|postingsBytes
operator|==
literal|null
condition|)
block|{
name|postingsBytes
operator|=
operator|new
name|byte
index|[
name|termState
operator|.
name|postingsSize
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|postingsBytes
operator|.
name|length
operator|<
name|termState
operator|.
name|postingsSize
condition|)
block|{
name|postingsBytes
operator|=
name|ArrayUtil
operator|.
name|grow
argument_list|(
name|postingsBytes
argument_list|,
name|termState
operator|.
name|postingsSize
argument_list|)
expr_stmt|;
block|}
name|System
operator|.
name|arraycopy
argument_list|(
name|termState
operator|.
name|postings
argument_list|,
literal|0
argument_list|,
name|postingsBytes
argument_list|,
literal|0
argument_list|,
name|termState
operator|.
name|postingsSize
argument_list|)
expr_stmt|;
name|postings
operator|.
name|reset
argument_list|(
name|postingsBytes
argument_list|,
literal|0
argument_list|,
name|termState
operator|.
name|postingsSize
argument_list|)
expr_stmt|;
name|this
operator|.
name|liveDocs
operator|=
name|liveDocs
expr_stmt|;
name|payloadLength
operator|=
literal|0
expr_stmt|;
name|posPending
operator|=
literal|0
expr_stmt|;
name|docID
operator|=
operator|-
literal|1
expr_stmt|;
name|accum
operator|=
literal|0
expr_stmt|;
name|cost
operator|=
name|termState
operator|.
name|docFreq
expr_stmt|;
name|startOffset
operator|=
name|storeOffsets
condition|?
literal|0
else|:
operator|-
literal|1
expr_stmt|;
comment|// always return -1 if no offsets are stored
name|offsetLength
operator|=
literal|0
expr_stmt|;
comment|//System.out.println("PR d&p reset storesPayloads=" + storePayloads + " bytes=" + bytes.length + " this=" + this);
return|return
name|this
return|;
block|}
annotation|@
name|Override
DECL|method|nextDoc
specifier|public
name|int
name|nextDoc
parameter_list|()
throws|throws
name|IOException
block|{
comment|//System.out.println("PR d&p nextDoc this=" + this);
while|while
condition|(
literal|true
condition|)
block|{
comment|//System.out.println("  cycle skip posPending=" + posPending);
name|skipPositions
argument_list|()
expr_stmt|;
if|if
condition|(
name|postings
operator|.
name|eof
argument_list|()
condition|)
block|{
comment|//System.out.println("PR   END");
return|return
name|docID
operator|=
name|NO_MORE_DOCS
return|;
block|}
specifier|final
name|int
name|code
init|=
name|postings
operator|.
name|readVInt
argument_list|()
decl_stmt|;
name|accum
operator|+=
name|code
operator|>>>
literal|1
expr_stmt|;
comment|// shift off low bit
if|if
condition|(
operator|(
name|code
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
block|{
comment|// if low bit is set
name|freq
operator|=
literal|1
expr_stmt|;
comment|// freq is one
block|}
else|else
block|{
name|freq
operator|=
name|postings
operator|.
name|readVInt
argument_list|()
expr_stmt|;
comment|// else read freq
block|}
name|posPending
operator|=
name|freq
expr_stmt|;
name|startOffset
operator|=
name|storeOffsets
condition|?
literal|0
else|:
operator|-
literal|1
expr_stmt|;
comment|// always return -1 if no offsets are stored
if|if
condition|(
name|liveDocs
operator|==
literal|null
operator|||
name|liveDocs
operator|.
name|get
argument_list|(
name|accum
argument_list|)
condition|)
block|{
comment|//System.out.println("  return docID=" + docID + " freq=" + freq);
name|position
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|docID
operator|=
name|accum
operator|)
return|;
block|}
block|}
block|}
annotation|@
name|Override
DECL|method|freq
specifier|public
name|int
name|freq
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|freq
return|;
block|}
annotation|@
name|Override
DECL|method|docID
specifier|public
name|int
name|docID
parameter_list|()
block|{
return|return
name|docID
return|;
block|}
annotation|@
name|Override
DECL|method|advance
specifier|public
name|int
name|advance
parameter_list|(
name|int
name|target
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|docID
operator|=
name|slowAdvance
argument_list|(
name|target
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|nextPosition
specifier|public
name|int
name|nextPosition
parameter_list|()
throws|throws
name|IOException
block|{
comment|//System.out.println("PR d&p nextPosition posPending=" + posPending + " vs freq=" + freq);
assert|assert
name|posPending
operator|>
literal|0
assert|;
name|posPending
operator|--
expr_stmt|;
if|if
condition|(
name|storePayloads
condition|)
block|{
if|if
condition|(
operator|!
name|payloadRetrieved
condition|)
block|{
comment|//System.out.println("PR     skip payload=" + payloadLength);
name|postings
operator|.
name|skipBytes
argument_list|(
name|payloadLength
argument_list|)
expr_stmt|;
block|}
specifier|final
name|int
name|code
init|=
name|postings
operator|.
name|readVInt
argument_list|()
decl_stmt|;
comment|//System.out.println("PR     code=" + code);
if|if
condition|(
operator|(
name|code
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
block|{
name|payloadLength
operator|=
name|postings
operator|.
name|readVInt
argument_list|()
expr_stmt|;
comment|//System.out.println("PR     new payload len=" + payloadLength);
block|}
name|position
operator|+=
name|code
operator|>>>
literal|1
expr_stmt|;
name|payloadRetrieved
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
name|position
operator|+=
name|postings
operator|.
name|readVInt
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|storeOffsets
condition|)
block|{
name|int
name|offsetCode
init|=
name|postings
operator|.
name|readVInt
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|offsetCode
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
block|{
comment|// new offset length
name|offsetLength
operator|=
name|postings
operator|.
name|readVInt
argument_list|()
expr_stmt|;
block|}
name|startOffset
operator|+=
name|offsetCode
operator|>>>
literal|1
expr_stmt|;
block|}
comment|//System.out.println("PR d&p nextPos return pos=" + position + " this=" + this);
return|return
name|position
return|;
block|}
annotation|@
name|Override
DECL|method|startOffset
specifier|public
name|int
name|startOffset
parameter_list|()
block|{
return|return
name|startOffset
return|;
block|}
annotation|@
name|Override
DECL|method|endOffset
specifier|public
name|int
name|endOffset
parameter_list|()
block|{
return|return
name|startOffset
operator|+
name|offsetLength
return|;
block|}
DECL|method|skipPositions
specifier|private
name|void
name|skipPositions
parameter_list|()
throws|throws
name|IOException
block|{
while|while
condition|(
name|posPending
operator|!=
literal|0
condition|)
block|{
name|nextPosition
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|storePayloads
operator|&&
operator|!
name|payloadRetrieved
condition|)
block|{
comment|//System.out.println("  skip payload len=" + payloadLength);
name|postings
operator|.
name|skipBytes
argument_list|(
name|payloadLength
argument_list|)
expr_stmt|;
name|payloadRetrieved
operator|=
literal|true
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|getPayload
specifier|public
name|BytesRef
name|getPayload
parameter_list|()
throws|throws
name|IOException
block|{
comment|//System.out.println("PR  getPayload payloadLength=" + payloadLength + " this=" + this);
if|if
condition|(
name|payloadRetrieved
condition|)
block|{
return|return
name|payload
return|;
block|}
elseif|else
if|if
condition|(
name|storePayloads
operator|&&
name|payloadLength
operator|>
literal|0
condition|)
block|{
name|payloadRetrieved
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|payload
operator|==
literal|null
condition|)
block|{
name|payload
operator|=
operator|new
name|BytesRef
argument_list|(
name|payloadLength
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|payload
operator|.
name|grow
argument_list|(
name|payloadLength
argument_list|)
expr_stmt|;
block|}
name|postings
operator|.
name|readBytes
argument_list|(
name|payload
operator|.
name|bytes
argument_list|,
literal|0
argument_list|,
name|payloadLength
argument_list|)
expr_stmt|;
name|payload
operator|.
name|length
operator|=
name|payloadLength
expr_stmt|;
return|return
name|payload
return|;
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|cost
specifier|public
name|long
name|cost
parameter_list|()
block|{
return|return
name|cost
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|close
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
name|wrappedPostingsReader
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
comment|/** for a docsenum, gets the 'other' reused enum.    * Example: Pulsing(Standard).    * when doing a term range query you are switching back and forth    * between Pulsing and Standard    *     * The way the reuse works is that Pulsing.other = Standard and    * Standard.other = Pulsing.    */
DECL|method|getOther
specifier|private
name|DocsEnum
name|getOther
parameter_list|(
name|DocsEnum
name|de
parameter_list|)
block|{
if|if
condition|(
name|de
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
else|else
block|{
specifier|final
name|AttributeSource
name|atts
init|=
name|de
operator|.
name|attributes
argument_list|()
decl_stmt|;
return|return
name|atts
operator|.
name|addAttribute
argument_list|(
name|PulsingEnumAttribute
operator|.
name|class
argument_list|)
operator|.
name|enums
argument_list|()
operator|.
name|get
argument_list|(
name|this
argument_list|)
return|;
block|}
block|}
comment|/**     * for a docsenum, sets the 'other' reused enum.    * see getOther for an example.    */
DECL|method|setOther
specifier|private
name|DocsEnum
name|setOther
parameter_list|(
name|DocsEnum
name|de
parameter_list|,
name|DocsEnum
name|other
parameter_list|)
block|{
specifier|final
name|AttributeSource
name|atts
init|=
name|de
operator|.
name|attributes
argument_list|()
decl_stmt|;
return|return
name|atts
operator|.
name|addAttribute
argument_list|(
name|PulsingEnumAttribute
operator|.
name|class
argument_list|)
operator|.
name|enums
argument_list|()
operator|.
name|put
argument_list|(
name|this
argument_list|,
name|other
argument_list|)
return|;
block|}
comment|/**     * A per-docsenum attribute that stores additional reuse information    * so that pulsing enums can keep a reference to their wrapped enums,    * and vice versa. this way we can always reuse.    *     * @lucene.internal */
DECL|interface|PulsingEnumAttribute
specifier|public
specifier|static
interface|interface
name|PulsingEnumAttribute
extends|extends
name|Attribute
block|{
DECL|method|enums
specifier|public
name|Map
argument_list|<
name|PulsingPostingsReader
argument_list|,
name|DocsEnum
argument_list|>
name|enums
parameter_list|()
function_decl|;
block|}
comment|/**     * Implementation of {@link PulsingEnumAttribute} for reuse of    * wrapped postings readers underneath pulsing.    *     * @lucene.internal */
DECL|class|PulsingEnumAttributeImpl
specifier|public
specifier|static
specifier|final
class|class
name|PulsingEnumAttributeImpl
extends|extends
name|AttributeImpl
implements|implements
name|PulsingEnumAttribute
block|{
comment|// we could store 'other', but what if someone 'chained' multiple postings readers,
comment|// this could cause problems?
comment|// TODO: we should consider nuking this map and just making it so if you do this,
comment|// you don't reuse? and maybe pulsingPostingsReader should throw an exc if it wraps
comment|// another pulsing, because this is just stupid and wasteful.
comment|// we still have to be careful in case someone does Pulsing(Stomping(Pulsing(...
DECL|field|enums
specifier|private
specifier|final
name|Map
argument_list|<
name|PulsingPostingsReader
argument_list|,
name|DocsEnum
argument_list|>
name|enums
init|=
operator|new
name|IdentityHashMap
argument_list|<
name|PulsingPostingsReader
argument_list|,
name|DocsEnum
argument_list|>
argument_list|()
decl_stmt|;
annotation|@
name|Override
DECL|method|enums
specifier|public
name|Map
argument_list|<
name|PulsingPostingsReader
argument_list|,
name|DocsEnum
argument_list|>
name|enums
parameter_list|()
block|{
return|return
name|enums
return|;
block|}
annotation|@
name|Override
DECL|method|clear
specifier|public
name|void
name|clear
parameter_list|()
block|{
comment|// our state is per-docsenum, so this makes no sense.
comment|// its best not to clear, in case a wrapped enum has a per-doc attribute or something
comment|// and is calling clearAttributes(), so they don't nuke the reuse information!
block|}
annotation|@
name|Override
DECL|method|copyTo
specifier|public
name|void
name|copyTo
parameter_list|(
name|AttributeImpl
name|target
parameter_list|)
block|{
comment|// this makes no sense for us, because our state is per-docsenum.
comment|// we don't want to copy any stuff over to another docsenum ever!
block|}
block|}
annotation|@
name|Override
DECL|method|ramBytesUsed
specifier|public
name|long
name|ramBytesUsed
parameter_list|()
block|{
return|return
operator|(
operator|(
name|wrappedPostingsReader
operator|!=
literal|null
operator|)
condition|?
name|wrappedPostingsReader
operator|.
name|ramBytesUsed
argument_list|()
else|:
literal|0
operator|)
return|;
block|}
block|}
end_class
end_unit
