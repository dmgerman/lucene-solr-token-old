begin_unit
begin_package
DECL|package|org.apache.lucene.codecs.blocktreeords
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|codecs
operator|.
name|blocktreeords
package|;
end_package
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_comment
comment|//import java.io.*;
end_comment
begin_comment
comment|//import java.nio.charset.StandardCharsets;
end_comment
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|PrintStream
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|codecs
operator|.
name|BlockTermState
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|codecs
operator|.
name|blocktreeords
operator|.
name|FSTOrdsOutputs
operator|.
name|Output
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|DocsAndPositionsEnum
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|DocsEnum
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|FieldInfo
operator|.
name|IndexOptions
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|TermState
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|TermsEnum
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|ByteArrayDataInput
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|IndexInput
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|ArrayUtil
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|Bits
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|BytesRef
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|BytesRefBuilder
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|IntsRef
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|IntsRefBuilder
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|RamUsageEstimator
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|fst
operator|.
name|FST
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|fst
operator|.
name|Util
import|;
end_import
begin_comment
comment|/** Iterates through terms in this field. */
end_comment
begin_class
DECL|class|OrdsSegmentTermsEnum
specifier|public
specifier|final
class|class
name|OrdsSegmentTermsEnum
extends|extends
name|TermsEnum
block|{
comment|// Lazy init:
DECL|field|in
name|IndexInput
name|in
decl_stmt|;
comment|// static boolean DEBUG = true;
DECL|field|stack
specifier|private
name|OrdsSegmentTermsEnumFrame
index|[]
name|stack
decl_stmt|;
DECL|field|staticFrame
specifier|private
specifier|final
name|OrdsSegmentTermsEnumFrame
name|staticFrame
decl_stmt|;
DECL|field|currentFrame
name|OrdsSegmentTermsEnumFrame
name|currentFrame
decl_stmt|;
DECL|field|termExists
name|boolean
name|termExists
decl_stmt|;
DECL|field|fr
specifier|final
name|OrdsFieldReader
name|fr
decl_stmt|;
DECL|field|targetBeforeCurrentLength
specifier|private
name|int
name|targetBeforeCurrentLength
decl_stmt|;
DECL|field|scratchReader
specifier|private
specifier|final
name|ByteArrayDataInput
name|scratchReader
init|=
operator|new
name|ByteArrayDataInput
argument_list|()
decl_stmt|;
comment|// What prefix of the current term was present in the index:
DECL|field|validIndexPrefix
specifier|private
name|int
name|validIndexPrefix
decl_stmt|;
comment|// assert only:
DECL|field|eof
specifier|private
name|boolean
name|eof
decl_stmt|;
DECL|field|term
specifier|final
name|BytesRefBuilder
name|term
init|=
operator|new
name|BytesRefBuilder
argument_list|()
decl_stmt|;
DECL|field|fstReader
specifier|private
specifier|final
name|FST
operator|.
name|BytesReader
name|fstReader
decl_stmt|;
DECL|field|arcs
annotation|@
name|SuppressWarnings
argument_list|(
block|{
literal|"rawtypes"
block|,
literal|"unchecked"
block|}
argument_list|)
specifier|private
name|FST
operator|.
name|Arc
argument_list|<
name|Output
argument_list|>
index|[]
name|arcs
init|=
operator|new
name|FST
operator|.
name|Arc
index|[
literal|1
index|]
decl_stmt|;
DECL|field|positioned
name|boolean
name|positioned
decl_stmt|;
DECL|method|OrdsSegmentTermsEnum
name|OrdsSegmentTermsEnum
parameter_list|(
name|OrdsFieldReader
name|fr
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|fr
operator|=
name|fr
expr_stmt|;
comment|//if (DEBUG) System.out.println("BTTR.init seg=" + segment);
name|stack
operator|=
operator|new
name|OrdsSegmentTermsEnumFrame
index|[
literal|0
index|]
expr_stmt|;
comment|// Used to hold seek by TermState, or cached seek
name|staticFrame
operator|=
operator|new
name|OrdsSegmentTermsEnumFrame
argument_list|(
name|this
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|fr
operator|.
name|index
operator|==
literal|null
condition|)
block|{
name|fstReader
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
name|fstReader
operator|=
name|fr
operator|.
name|index
operator|.
name|getBytesReader
argument_list|()
expr_stmt|;
block|}
comment|// Init w/ root block; don't use index since it may
comment|// not (and need not) have been loaded
for|for
control|(
name|int
name|arcIdx
init|=
literal|0
init|;
name|arcIdx
operator|<
name|arcs
operator|.
name|length
condition|;
name|arcIdx
operator|++
control|)
block|{
name|arcs
index|[
name|arcIdx
index|]
operator|=
operator|new
name|FST
operator|.
name|Arc
argument_list|<>
argument_list|()
expr_stmt|;
block|}
name|currentFrame
operator|=
name|staticFrame
expr_stmt|;
specifier|final
name|FST
operator|.
name|Arc
argument_list|<
name|Output
argument_list|>
name|arc
decl_stmt|;
if|if
condition|(
name|fr
operator|.
name|index
operator|!=
literal|null
condition|)
block|{
name|arc
operator|=
name|fr
operator|.
name|index
operator|.
name|getFirstArc
argument_list|(
name|arcs
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|// Empty string prefix must have an output in the index!
assert|assert
name|arc
operator|.
name|isFinal
argument_list|()
assert|;
block|}
else|else
block|{
name|arc
operator|=
literal|null
expr_stmt|;
block|}
comment|//currentFrame = pushFrame(arc, rootCode, 0);
comment|//currentFrame.loadBlock();
name|validIndexPrefix
operator|=
literal|0
expr_stmt|;
comment|// if (DEBUG) {
comment|//   System.out.println("init frame state " + currentFrame.ord);
comment|//   printSeekState();
comment|// }
comment|//System.out.println();
comment|// computeBlockStats().print(System.out);
block|}
comment|// Not private to avoid synthetic access$NNN methods
DECL|method|initIndexInput
name|void
name|initIndexInput
parameter_list|()
block|{
if|if
condition|(
name|this
operator|.
name|in
operator|==
literal|null
condition|)
block|{
name|this
operator|.
name|in
operator|=
name|fr
operator|.
name|parent
operator|.
name|in
operator|.
name|clone
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|getFrame
specifier|private
name|OrdsSegmentTermsEnumFrame
name|getFrame
parameter_list|(
name|int
name|ord
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|ord
operator|>=
name|stack
operator|.
name|length
condition|)
block|{
specifier|final
name|OrdsSegmentTermsEnumFrame
index|[]
name|next
init|=
operator|new
name|OrdsSegmentTermsEnumFrame
index|[
name|ArrayUtil
operator|.
name|oversize
argument_list|(
literal|1
operator|+
name|ord
argument_list|,
name|RamUsageEstimator
operator|.
name|NUM_BYTES_OBJECT_REF
argument_list|)
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|stack
argument_list|,
literal|0
argument_list|,
name|next
argument_list|,
literal|0
argument_list|,
name|stack
operator|.
name|length
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|stackOrd
init|=
name|stack
operator|.
name|length
init|;
name|stackOrd
operator|<
name|next
operator|.
name|length
condition|;
name|stackOrd
operator|++
control|)
block|{
name|next
index|[
name|stackOrd
index|]
operator|=
operator|new
name|OrdsSegmentTermsEnumFrame
argument_list|(
name|this
argument_list|,
name|stackOrd
argument_list|)
expr_stmt|;
block|}
name|stack
operator|=
name|next
expr_stmt|;
block|}
assert|assert
name|stack
index|[
name|ord
index|]
operator|.
name|ord
operator|==
name|ord
assert|;
return|return
name|stack
index|[
name|ord
index|]
return|;
block|}
DECL|method|getArc
specifier|private
name|FST
operator|.
name|Arc
argument_list|<
name|Output
argument_list|>
name|getArc
parameter_list|(
name|int
name|ord
parameter_list|)
block|{
if|if
condition|(
name|ord
operator|>=
name|arcs
operator|.
name|length
condition|)
block|{
annotation|@
name|SuppressWarnings
argument_list|(
block|{
literal|"rawtypes"
block|,
literal|"unchecked"
block|}
argument_list|)
specifier|final
name|FST
operator|.
name|Arc
argument_list|<
name|Output
argument_list|>
index|[]
name|next
init|=
operator|new
name|FST
operator|.
name|Arc
index|[
name|ArrayUtil
operator|.
name|oversize
argument_list|(
literal|1
operator|+
name|ord
argument_list|,
name|RamUsageEstimator
operator|.
name|NUM_BYTES_OBJECT_REF
argument_list|)
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|arcs
argument_list|,
literal|0
argument_list|,
name|next
argument_list|,
literal|0
argument_list|,
name|arcs
operator|.
name|length
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|arcOrd
init|=
name|arcs
operator|.
name|length
init|;
name|arcOrd
operator|<
name|next
operator|.
name|length
condition|;
name|arcOrd
operator|++
control|)
block|{
name|next
index|[
name|arcOrd
index|]
operator|=
operator|new
name|FST
operator|.
name|Arc
argument_list|<>
argument_list|()
expr_stmt|;
block|}
name|arcs
operator|=
name|next
expr_stmt|;
block|}
return|return
name|arcs
index|[
name|ord
index|]
return|;
block|}
comment|// Pushes a frame we seek'd to
DECL|method|pushFrame
name|OrdsSegmentTermsEnumFrame
name|pushFrame
parameter_list|(
name|FST
operator|.
name|Arc
argument_list|<
name|Output
argument_list|>
name|arc
parameter_list|,
name|Output
name|frameData
parameter_list|,
name|int
name|length
parameter_list|)
throws|throws
name|IOException
block|{
name|scratchReader
operator|.
name|reset
argument_list|(
name|frameData
operator|.
name|bytes
operator|.
name|bytes
argument_list|,
name|frameData
operator|.
name|bytes
operator|.
name|offset
argument_list|,
name|frameData
operator|.
name|bytes
operator|.
name|length
argument_list|)
expr_stmt|;
specifier|final
name|long
name|code
init|=
name|scratchReader
operator|.
name|readVLong
argument_list|()
decl_stmt|;
specifier|final
name|long
name|fpSeek
init|=
name|code
operator|>>>
name|OrdsBlockTreeTermsWriter
operator|.
name|OUTPUT_FLAGS_NUM_BITS
decl_stmt|;
comment|// System.out.println("    fpSeek=" + fpSeek);
specifier|final
name|OrdsSegmentTermsEnumFrame
name|f
init|=
name|getFrame
argument_list|(
literal|1
operator|+
name|currentFrame
operator|.
name|ord
argument_list|)
decl_stmt|;
name|f
operator|.
name|hasTerms
operator|=
operator|(
name|code
operator|&
name|OrdsBlockTreeTermsWriter
operator|.
name|OUTPUT_FLAG_HAS_TERMS
operator|)
operator|!=
literal|0
expr_stmt|;
name|f
operator|.
name|hasTermsOrig
operator|=
name|f
operator|.
name|hasTerms
expr_stmt|;
name|f
operator|.
name|isFloor
operator|=
operator|(
name|code
operator|&
name|OrdsBlockTreeTermsWriter
operator|.
name|OUTPUT_FLAG_IS_FLOOR
operator|)
operator|!=
literal|0
expr_stmt|;
comment|// Must setFloorData before pushFrame in case pushFrame tries to rewind:
if|if
condition|(
name|f
operator|.
name|isFloor
condition|)
block|{
name|f
operator|.
name|termOrdOrig
operator|=
name|frameData
operator|.
name|startOrd
expr_stmt|;
name|f
operator|.
name|setFloorData
argument_list|(
name|scratchReader
argument_list|,
name|frameData
operator|.
name|bytes
argument_list|)
expr_stmt|;
block|}
name|pushFrame
argument_list|(
name|arc
argument_list|,
name|fpSeek
argument_list|,
name|length
argument_list|,
name|frameData
operator|.
name|startOrd
argument_list|)
expr_stmt|;
return|return
name|f
return|;
block|}
comment|// Pushes next'd frame or seek'd frame; we later
comment|// lazy-load the frame only when needed
DECL|method|pushFrame
name|OrdsSegmentTermsEnumFrame
name|pushFrame
parameter_list|(
name|FST
operator|.
name|Arc
argument_list|<
name|Output
argument_list|>
name|arc
parameter_list|,
name|long
name|fp
parameter_list|,
name|int
name|length
parameter_list|,
name|long
name|termOrd
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|OrdsSegmentTermsEnumFrame
name|f
init|=
name|getFrame
argument_list|(
literal|1
operator|+
name|currentFrame
operator|.
name|ord
argument_list|)
decl_stmt|;
name|f
operator|.
name|arc
operator|=
name|arc
expr_stmt|;
comment|// System.out.println("pushFrame termOrd= " + termOrd + " fpOrig=" + f.fpOrig + " fp=" + fp + " nextEnt=" + f.nextEnt);
if|if
condition|(
name|f
operator|.
name|fpOrig
operator|==
name|fp
operator|&&
name|f
operator|.
name|nextEnt
operator|!=
operator|-
literal|1
condition|)
block|{
comment|//if (DEBUG) System.out.println("      push reused frame ord=" + f.ord + " fp=" + f.fp + " isFloor?=" + f.isFloor + " hasTerms=" + f.hasTerms + " pref=" + term + " nextEnt=" + f.nextEnt + " targetBeforeCurrentLength=" + targetBeforeCurrentLength + " term.length=" + term.length + " vs prefix=" + f.prefix);
if|if
condition|(
name|f
operator|.
name|prefix
operator|>
name|targetBeforeCurrentLength
condition|)
block|{
comment|// System.out.println("        do rewind!");
name|f
operator|.
name|rewind
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|// if (DEBUG) {
comment|// System.out.println("        skip rewind!");
comment|// }
block|}
assert|assert
name|length
operator|==
name|f
operator|.
name|prefix
assert|;
assert|assert
name|termOrd
operator|==
name|f
operator|.
name|termOrdOrig
assert|;
block|}
else|else
block|{
name|f
operator|.
name|nextEnt
operator|=
operator|-
literal|1
expr_stmt|;
name|f
operator|.
name|prefix
operator|=
name|length
expr_stmt|;
name|f
operator|.
name|state
operator|.
name|termBlockOrd
operator|=
literal|0
expr_stmt|;
name|f
operator|.
name|termOrdOrig
operator|=
name|termOrd
expr_stmt|;
comment|// System.out.println("set termOrdOrig=" + termOrd);
name|f
operator|.
name|termOrd
operator|=
name|termOrd
expr_stmt|;
name|f
operator|.
name|fpOrig
operator|=
name|f
operator|.
name|fp
operator|=
name|fp
expr_stmt|;
name|f
operator|.
name|lastSubFP
operator|=
operator|-
literal|1
expr_stmt|;
comment|// if (DEBUG) {
comment|//   final int sav = term.length;
comment|//   term.length = length;
comment|//   System.out.println("      push new frame ord=" + f.ord + " fp=" + f.fp + " hasTerms=" + f.hasTerms + " isFloor=" + f.isFloor + " pref=" + brToString(term));
comment|//   term.length = sav;
comment|// }
block|}
return|return
name|f
return|;
block|}
comment|// asserts only
DECL|method|clearEOF
specifier|private
name|boolean
name|clearEOF
parameter_list|()
block|{
name|eof
operator|=
literal|false
expr_stmt|;
return|return
literal|true
return|;
block|}
comment|// asserts only
DECL|method|setEOF
specifier|private
name|boolean
name|setEOF
parameter_list|()
block|{
name|eof
operator|=
literal|true
expr_stmt|;
return|return
literal|true
return|;
block|}
comment|// for debugging
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unused"
argument_list|)
DECL|method|brToString
specifier|static
name|String
name|brToString
parameter_list|(
name|BytesRef
name|b
parameter_list|)
block|{
try|try
block|{
return|return
name|b
operator|.
name|utf8ToString
argument_list|()
operator|+
literal|" "
operator|+
name|b
return|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
comment|// If BytesRef isn't actually UTF8, or it's eg a
comment|// prefix of UTF8 that ends mid-unicode-char, we
comment|// fallback to hex:
return|return
name|b
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|seekExact
specifier|public
name|boolean
name|seekExact
parameter_list|(
specifier|final
name|BytesRef
name|target
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|fr
operator|.
name|index
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"terms index was not loaded"
argument_list|)
throw|;
block|}
name|term
operator|.
name|grow
argument_list|(
literal|1
operator|+
name|target
operator|.
name|length
argument_list|)
expr_stmt|;
assert|assert
name|clearEOF
argument_list|()
assert|;
comment|/*     if (DEBUG) {       System.out.println("\nBTTR.seekExact seg=" + fr.parent.segment + " target=" + fr.fieldInfo.name + ":" + brToString(target) + " current=" + brToString(term) + " (exists?=" + termExists + ") validIndexPrefix=" + validIndexPrefix);       printSeekState(System.out);     }     */
name|FST
operator|.
name|Arc
argument_list|<
name|Output
argument_list|>
name|arc
decl_stmt|;
name|int
name|targetUpto
decl_stmt|;
name|Output
name|output
decl_stmt|;
name|targetBeforeCurrentLength
operator|=
name|currentFrame
operator|.
name|ord
expr_stmt|;
if|if
condition|(
name|positioned
operator|&&
name|currentFrame
operator|!=
name|staticFrame
condition|)
block|{
comment|// We are already seek'd; find the common
comment|// prefix of new seek term vs current term and
comment|// re-use the corresponding seek state.  For
comment|// example, if app first seeks to foobar, then
comment|// seeks to foobaz, we can re-use the seek state
comment|// for the first 5 bytes.
comment|// if (DEBUG) {
comment|//   System.out.println("  re-use current seek state validIndexPrefix=" + validIndexPrefix);
comment|// }
name|arc
operator|=
name|arcs
index|[
literal|0
index|]
expr_stmt|;
assert|assert
name|arc
operator|.
name|isFinal
argument_list|()
assert|;
name|output
operator|=
name|arc
operator|.
name|output
expr_stmt|;
name|targetUpto
operator|=
literal|0
expr_stmt|;
name|OrdsSegmentTermsEnumFrame
name|lastFrame
init|=
name|stack
index|[
literal|0
index|]
decl_stmt|;
assert|assert
name|validIndexPrefix
operator|<=
name|term
operator|.
name|length
argument_list|()
assert|;
specifier|final
name|int
name|targetLimit
init|=
name|Math
operator|.
name|min
argument_list|(
name|target
operator|.
name|length
argument_list|,
name|validIndexPrefix
argument_list|)
decl_stmt|;
name|int
name|cmp
init|=
literal|0
decl_stmt|;
comment|// TODO: reverse vLong byte order for better FST
comment|// prefix output sharing
comment|// First compare up to valid seek frames:
while|while
condition|(
name|targetUpto
operator|<
name|targetLimit
condition|)
block|{
name|cmp
operator|=
operator|(
name|term
operator|.
name|byteAt
argument_list|(
name|targetUpto
argument_list|)
operator|&
literal|0xFF
operator|)
operator|-
operator|(
name|target
operator|.
name|bytes
index|[
name|target
operator|.
name|offset
operator|+
name|targetUpto
index|]
operator|&
literal|0xFF
operator|)
expr_stmt|;
comment|// if (DEBUG) {
comment|//    System.out.println("    cycle targetUpto=" + targetUpto + " (vs limit=" + targetLimit + ") cmp=" + cmp + " (targetLabel=" + (char) (target.bytes[target.offset + targetUpto]) + " vs termLabel=" + (char) (term.bytes[targetUpto]) + ")"   + " arc.output=" + arc.output + " output=" + output);
comment|// }
if|if
condition|(
name|cmp
operator|!=
literal|0
condition|)
block|{
break|break;
block|}
name|arc
operator|=
name|arcs
index|[
literal|1
operator|+
name|targetUpto
index|]
expr_stmt|;
assert|assert
name|arc
operator|.
name|label
operator|==
operator|(
name|target
operator|.
name|bytes
index|[
name|target
operator|.
name|offset
operator|+
name|targetUpto
index|]
operator|&
literal|0xFF
operator|)
operator|:
literal|"arc.label="
operator|+
operator|(
name|char
operator|)
name|arc
operator|.
name|label
operator|+
literal|" targetLabel="
operator|+
call|(
name|char
call|)
argument_list|(
name|target
operator|.
name|bytes
index|[
name|target
operator|.
name|offset
operator|+
name|targetUpto
index|]
operator|&
literal|0xFF
argument_list|)
assert|;
if|if
condition|(
name|arc
operator|.
name|output
operator|!=
name|OrdsBlockTreeTermsWriter
operator|.
name|NO_OUTPUT
condition|)
block|{
name|output
operator|=
name|OrdsBlockTreeTermsWriter
operator|.
name|FST_OUTPUTS
operator|.
name|add
argument_list|(
name|output
argument_list|,
name|arc
operator|.
name|output
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|arc
operator|.
name|isFinal
argument_list|()
condition|)
block|{
name|lastFrame
operator|=
name|stack
index|[
literal|1
operator|+
name|lastFrame
operator|.
name|ord
index|]
expr_stmt|;
block|}
name|targetUpto
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|cmp
operator|==
literal|0
condition|)
block|{
specifier|final
name|int
name|targetUptoMid
init|=
name|targetUpto
decl_stmt|;
comment|// Second compare the rest of the term, but
comment|// don't save arc/output/frame; we only do this
comment|// to find out if the target term is before,
comment|// equal or after the current term
specifier|final
name|int
name|targetLimit2
init|=
name|Math
operator|.
name|min
argument_list|(
name|target
operator|.
name|length
argument_list|,
name|term
operator|.
name|length
argument_list|()
argument_list|)
decl_stmt|;
while|while
condition|(
name|targetUpto
operator|<
name|targetLimit2
condition|)
block|{
name|cmp
operator|=
operator|(
name|term
operator|.
name|byteAt
argument_list|(
name|targetUpto
argument_list|)
operator|&
literal|0xFF
operator|)
operator|-
operator|(
name|target
operator|.
name|bytes
index|[
name|target
operator|.
name|offset
operator|+
name|targetUpto
index|]
operator|&
literal|0xFF
operator|)
expr_stmt|;
comment|// if (DEBUG) {
comment|//    System.out.println("    cycle2 targetUpto=" + targetUpto + " (vs limit=" + targetLimit + ") cmp=" + cmp + " (targetLabel=" + (char) (target.bytes[target.offset + targetUpto]) + " vs termLabel=" + (char) (term.bytes[targetUpto]) + ")");
comment|// }
if|if
condition|(
name|cmp
operator|!=
literal|0
condition|)
block|{
break|break;
block|}
name|targetUpto
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|cmp
operator|==
literal|0
condition|)
block|{
name|cmp
operator|=
name|term
operator|.
name|length
argument_list|()
operator|-
name|target
operator|.
name|length
expr_stmt|;
block|}
name|targetUpto
operator|=
name|targetUptoMid
expr_stmt|;
block|}
if|if
condition|(
name|cmp
operator|<
literal|0
condition|)
block|{
comment|// Common case: target term is after current
comment|// term, ie, app is seeking multiple terms
comment|// in sorted order
comment|// if (DEBUG) {
comment|//   System.out.println("  target is after current (shares prefixLen=" + targetUpto + "); frame.ord=" + lastFrame.ord);
comment|// }
name|currentFrame
operator|=
name|lastFrame
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cmp
operator|>
literal|0
condition|)
block|{
comment|// Uncommon case: target term
comment|// is before current term; this means we can
comment|// keep the currentFrame but we must rewind it
comment|// (so we scan from the start)
name|targetBeforeCurrentLength
operator|=
name|lastFrame
operator|.
name|ord
expr_stmt|;
comment|// if (DEBUG) {
comment|//   System.out.println("  target is before current (shares prefixLen=" + targetUpto + "); rewind frame ord=" + lastFrame.ord);
comment|// }
name|currentFrame
operator|=
name|lastFrame
expr_stmt|;
name|currentFrame
operator|.
name|rewind
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|// Target is exactly the same as current term
assert|assert
name|term
operator|.
name|length
argument_list|()
operator|==
name|target
operator|.
name|length
assert|;
if|if
condition|(
name|termExists
condition|)
block|{
comment|// if (DEBUG) {
comment|//   System.out.println("  target is same as current; return true");
comment|// }
return|return
literal|true
return|;
block|}
else|else
block|{
comment|// if (DEBUG) {
comment|//   System.out.println("  target is same as current but term doesn't exist");
comment|// }
block|}
comment|//validIndexPrefix = currentFrame.depth;
comment|//term.length = target.length;
comment|//return termExists;
block|}
block|}
else|else
block|{
name|targetBeforeCurrentLength
operator|=
operator|-
literal|1
expr_stmt|;
name|arc
operator|=
name|fr
operator|.
name|index
operator|.
name|getFirstArc
argument_list|(
name|arcs
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|// Empty string prefix must have an output (block) in the index!
assert|assert
name|arc
operator|.
name|isFinal
argument_list|()
assert|;
assert|assert
name|arc
operator|.
name|output
operator|!=
literal|null
assert|;
comment|// if (DEBUG) {
comment|//   System.out.println("    no seek state; push root frame");
comment|// }
name|output
operator|=
name|arc
operator|.
name|output
expr_stmt|;
name|currentFrame
operator|=
name|staticFrame
expr_stmt|;
comment|//term.length = 0;
name|targetUpto
operator|=
literal|0
expr_stmt|;
name|currentFrame
operator|=
name|pushFrame
argument_list|(
name|arc
argument_list|,
name|OrdsBlockTreeTermsWriter
operator|.
name|FST_OUTPUTS
operator|.
name|add
argument_list|(
name|output
argument_list|,
name|arc
operator|.
name|nextFinalOutput
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|positioned
operator|=
literal|true
expr_stmt|;
comment|// if (DEBUG) {
comment|//   System.out.println("  start index loop targetUpto=" + targetUpto + " output=" + output + " currentFrame.ord=" + currentFrame.ord + " targetBeforeCurrentLength=" + targetBeforeCurrentLength);
comment|// }
comment|// We are done sharing the common prefix with the incoming target and where we are currently seek'd; now continue walking the index:
while|while
condition|(
name|targetUpto
operator|<
name|target
operator|.
name|length
condition|)
block|{
specifier|final
name|int
name|targetLabel
init|=
name|target
operator|.
name|bytes
index|[
name|target
operator|.
name|offset
operator|+
name|targetUpto
index|]
operator|&
literal|0xFF
decl_stmt|;
specifier|final
name|FST
operator|.
name|Arc
argument_list|<
name|Output
argument_list|>
name|nextArc
init|=
name|fr
operator|.
name|index
operator|.
name|findTargetArc
argument_list|(
name|targetLabel
argument_list|,
name|arc
argument_list|,
name|getArc
argument_list|(
literal|1
operator|+
name|targetUpto
argument_list|)
argument_list|,
name|fstReader
argument_list|)
decl_stmt|;
if|if
condition|(
name|nextArc
operator|==
literal|null
condition|)
block|{
comment|// Index is exhausted
comment|// if (DEBUG) {
comment|//   System.out.println("    index: index exhausted label=" + ((char) targetLabel) + " " + toHex(targetLabel));
comment|// }
name|validIndexPrefix
operator|=
name|currentFrame
operator|.
name|prefix
expr_stmt|;
comment|//validIndexPrefix = targetUpto;
name|currentFrame
operator|.
name|scanToFloorFrame
argument_list|(
name|target
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|currentFrame
operator|.
name|hasTerms
condition|)
block|{
name|termExists
operator|=
literal|false
expr_stmt|;
name|term
operator|.
name|setByteAt
argument_list|(
name|targetUpto
argument_list|,
operator|(
name|byte
operator|)
name|targetLabel
argument_list|)
expr_stmt|;
name|term
operator|.
name|setLength
argument_list|(
literal|1
operator|+
name|targetUpto
argument_list|)
expr_stmt|;
comment|// if (DEBUG) {
comment|//   System.out.println("  FAST NOT_FOUND term=" + brToString(term));
comment|// }
return|return
literal|false
return|;
block|}
name|currentFrame
operator|.
name|loadBlock
argument_list|()
expr_stmt|;
specifier|final
name|SeekStatus
name|result
init|=
name|currentFrame
operator|.
name|scanToTerm
argument_list|(
name|target
argument_list|,
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|==
name|SeekStatus
operator|.
name|FOUND
condition|)
block|{
comment|// if (DEBUG) {
comment|//   System.out.println("  return FOUND term=" + term.utf8ToString() + " " + term);
comment|// }
return|return
literal|true
return|;
block|}
else|else
block|{
comment|// if (DEBUG) {
comment|//   System.out.println("  got " + result + "; return NOT_FOUND term=" + brToString(term));
comment|// }
return|return
literal|false
return|;
block|}
block|}
else|else
block|{
comment|// Follow this arc
name|arc
operator|=
name|nextArc
expr_stmt|;
name|term
operator|.
name|setByteAt
argument_list|(
name|targetUpto
argument_list|,
operator|(
name|byte
operator|)
name|targetLabel
argument_list|)
expr_stmt|;
comment|// Aggregate output as we go:
assert|assert
name|arc
operator|.
name|output
operator|!=
literal|null
assert|;
if|if
condition|(
name|arc
operator|.
name|output
operator|!=
name|OrdsBlockTreeTermsWriter
operator|.
name|NO_OUTPUT
condition|)
block|{
name|output
operator|=
name|OrdsBlockTreeTermsWriter
operator|.
name|FST_OUTPUTS
operator|.
name|add
argument_list|(
name|output
argument_list|,
name|arc
operator|.
name|output
argument_list|)
expr_stmt|;
block|}
comment|// if (DEBUG) {
comment|//   System.out.println("    index: follow label=" + toHex(target.bytes[target.offset + targetUpto]&0xff) + " arc.output=" + arc.output + " arc.nfo=" + arc.nextFinalOutput);
comment|// }
name|targetUpto
operator|++
expr_stmt|;
if|if
condition|(
name|arc
operator|.
name|isFinal
argument_list|()
condition|)
block|{
comment|//if (DEBUG) System.out.println("    arc is final!");
name|currentFrame
operator|=
name|pushFrame
argument_list|(
name|arc
argument_list|,
name|OrdsBlockTreeTermsWriter
operator|.
name|FST_OUTPUTS
operator|.
name|add
argument_list|(
name|output
argument_list|,
name|arc
operator|.
name|nextFinalOutput
argument_list|)
argument_list|,
name|targetUpto
argument_list|)
expr_stmt|;
comment|//if (DEBUG) System.out.println("    curFrame.ord=" + currentFrame.ord + " hasTerms=" + currentFrame.hasTerms);
block|}
block|}
block|}
comment|//validIndexPrefix = targetUpto;
name|validIndexPrefix
operator|=
name|currentFrame
operator|.
name|prefix
expr_stmt|;
name|currentFrame
operator|.
name|scanToFloorFrame
argument_list|(
name|target
argument_list|)
expr_stmt|;
comment|// Target term is entirely contained in the index:
if|if
condition|(
operator|!
name|currentFrame
operator|.
name|hasTerms
condition|)
block|{
name|termExists
operator|=
literal|false
expr_stmt|;
name|term
operator|.
name|setLength
argument_list|(
name|targetUpto
argument_list|)
expr_stmt|;
comment|// if (DEBUG) {
comment|//   System.out.println("  FAST NOT_FOUND term=" + brToString(term));
comment|// }
return|return
literal|false
return|;
block|}
name|currentFrame
operator|.
name|loadBlock
argument_list|()
expr_stmt|;
specifier|final
name|SeekStatus
name|result
init|=
name|currentFrame
operator|.
name|scanToTerm
argument_list|(
name|target
argument_list|,
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|==
name|SeekStatus
operator|.
name|FOUND
condition|)
block|{
comment|// if (DEBUG) {
comment|//   System.out.println("  return FOUND term=" + term.utf8ToString() + " " + term);
comment|// }
return|return
literal|true
return|;
block|}
else|else
block|{
comment|// if (DEBUG) {
comment|//   System.out.println("  got result " + result + "; return NOT_FOUND term=" + term.utf8ToString());
comment|// }
return|return
literal|false
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|seekCeil
specifier|public
name|SeekStatus
name|seekCeil
parameter_list|(
specifier|final
name|BytesRef
name|target
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|fr
operator|.
name|index
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"terms index was not loaded"
argument_list|)
throw|;
block|}
name|term
operator|.
name|grow
argument_list|(
literal|1
operator|+
name|target
operator|.
name|length
argument_list|)
expr_stmt|;
assert|assert
name|clearEOF
argument_list|()
assert|;
comment|//if (DEBUG) {
comment|//System.out.println("\nBTTR.seekCeil seg=" + segment + " target=" + fieldInfo.name + ":" + target.utf8ToString() + " " + target + " current=" + brToString(term) + " (exists?=" + termExists + ") validIndexPrefix=  " + validIndexPrefix);
comment|//printSeekState();
comment|//}
name|FST
operator|.
name|Arc
argument_list|<
name|Output
argument_list|>
name|arc
decl_stmt|;
name|int
name|targetUpto
decl_stmt|;
name|Output
name|output
decl_stmt|;
name|targetBeforeCurrentLength
operator|=
name|currentFrame
operator|.
name|ord
expr_stmt|;
if|if
condition|(
name|positioned
operator|&&
name|currentFrame
operator|!=
name|staticFrame
condition|)
block|{
comment|// We are already seek'd; find the common
comment|// prefix of new seek term vs current term and
comment|// re-use the corresponding seek state.  For
comment|// example, if app first seeks to foobar, then
comment|// seeks to foobaz, we can re-use the seek state
comment|// for the first 5 bytes.
comment|//if (DEBUG) {
comment|//System.out.println("  re-use current seek state validIndexPrefix=" + validIndexPrefix);
comment|//}
name|arc
operator|=
name|arcs
index|[
literal|0
index|]
expr_stmt|;
assert|assert
name|arc
operator|.
name|isFinal
argument_list|()
assert|;
name|output
operator|=
name|arc
operator|.
name|output
expr_stmt|;
name|targetUpto
operator|=
literal|0
expr_stmt|;
name|OrdsSegmentTermsEnumFrame
name|lastFrame
init|=
name|stack
index|[
literal|0
index|]
decl_stmt|;
assert|assert
name|validIndexPrefix
operator|<=
name|term
operator|.
name|length
argument_list|()
assert|;
specifier|final
name|int
name|targetLimit
init|=
name|Math
operator|.
name|min
argument_list|(
name|target
operator|.
name|length
argument_list|,
name|validIndexPrefix
argument_list|)
decl_stmt|;
name|int
name|cmp
init|=
literal|0
decl_stmt|;
comment|// TODO: we should write our vLong backwards (MSB
comment|// first) to get better sharing from the FST
comment|// First compare up to valid seek frames:
while|while
condition|(
name|targetUpto
operator|<
name|targetLimit
condition|)
block|{
name|cmp
operator|=
operator|(
name|term
operator|.
name|byteAt
argument_list|(
name|targetUpto
argument_list|)
operator|&
literal|0xFF
operator|)
operator|-
operator|(
name|target
operator|.
name|bytes
index|[
name|target
operator|.
name|offset
operator|+
name|targetUpto
index|]
operator|&
literal|0xFF
operator|)
expr_stmt|;
comment|//if (DEBUG) {
comment|//System.out.println("    cycle targetUpto=" + targetUpto + " (vs limit=" + targetLimit + ") cmp=" + cmp + " (targetLabel=" + (char) (target.bytes[target.offset + targetUpto]) + " vs termLabel=" + (char) (term.bytes[targetUpto]) + ")"   + " arc.output=" + arc.output + " output=" + output);
comment|//}
if|if
condition|(
name|cmp
operator|!=
literal|0
condition|)
block|{
break|break;
block|}
name|arc
operator|=
name|arcs
index|[
literal|1
operator|+
name|targetUpto
index|]
expr_stmt|;
assert|assert
name|arc
operator|.
name|label
operator|==
operator|(
name|target
operator|.
name|bytes
index|[
name|target
operator|.
name|offset
operator|+
name|targetUpto
index|]
operator|&
literal|0xFF
operator|)
operator|:
literal|"arc.label="
operator|+
operator|(
name|char
operator|)
name|arc
operator|.
name|label
operator|+
literal|" targetLabel="
operator|+
call|(
name|char
call|)
argument_list|(
name|target
operator|.
name|bytes
index|[
name|target
operator|.
name|offset
operator|+
name|targetUpto
index|]
operator|&
literal|0xFF
argument_list|)
assert|;
comment|// TODO: we could save the outputs in local
comment|// byte[][] instead of making new objs ever
comment|// seek; but, often the FST doesn't have any
comment|// shared bytes (but this could change if we
comment|// reverse vLong byte order)
if|if
condition|(
name|arc
operator|.
name|output
operator|!=
name|OrdsBlockTreeTermsWriter
operator|.
name|NO_OUTPUT
condition|)
block|{
name|output
operator|=
name|OrdsBlockTreeTermsWriter
operator|.
name|FST_OUTPUTS
operator|.
name|add
argument_list|(
name|output
argument_list|,
name|arc
operator|.
name|output
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|arc
operator|.
name|isFinal
argument_list|()
condition|)
block|{
name|lastFrame
operator|=
name|stack
index|[
literal|1
operator|+
name|lastFrame
operator|.
name|ord
index|]
expr_stmt|;
block|}
name|targetUpto
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|cmp
operator|==
literal|0
condition|)
block|{
specifier|final
name|int
name|targetUptoMid
init|=
name|targetUpto
decl_stmt|;
comment|// Second compare the rest of the term, but
comment|// don't save arc/output/frame:
specifier|final
name|int
name|targetLimit2
init|=
name|Math
operator|.
name|min
argument_list|(
name|target
operator|.
name|length
argument_list|,
name|term
operator|.
name|length
argument_list|()
argument_list|)
decl_stmt|;
while|while
condition|(
name|targetUpto
operator|<
name|targetLimit2
condition|)
block|{
name|cmp
operator|=
operator|(
name|term
operator|.
name|byteAt
argument_list|(
name|targetUpto
argument_list|)
operator|&
literal|0xFF
operator|)
operator|-
operator|(
name|target
operator|.
name|bytes
index|[
name|target
operator|.
name|offset
operator|+
name|targetUpto
index|]
operator|&
literal|0xFF
operator|)
expr_stmt|;
comment|//if (DEBUG) {
comment|//System.out.println("    cycle2 targetUpto=" + targetUpto + " (vs limit=" + targetLimit + ") cmp=" + cmp + " (targetLabel=" + (char) (target.bytes[target.offset + targetUpto]) + " vs termLabel=" + (char) (term.bytes[targetUpto]) + ")");
comment|//}
if|if
condition|(
name|cmp
operator|!=
literal|0
condition|)
block|{
break|break;
block|}
name|targetUpto
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|cmp
operator|==
literal|0
condition|)
block|{
name|cmp
operator|=
name|term
operator|.
name|length
argument_list|()
operator|-
name|target
operator|.
name|length
expr_stmt|;
block|}
name|targetUpto
operator|=
name|targetUptoMid
expr_stmt|;
block|}
if|if
condition|(
name|cmp
operator|<
literal|0
condition|)
block|{
comment|// Common case: target term is after current
comment|// term, ie, app is seeking multiple terms
comment|// in sorted order
comment|//if (DEBUG) {
comment|//System.out.println("  target is after current (shares prefixLen=" + targetUpto + "); clear frame.scanned ord=" + lastFrame.ord);
comment|//}
name|currentFrame
operator|=
name|lastFrame
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cmp
operator|>
literal|0
condition|)
block|{
comment|// Uncommon case: target term
comment|// is before current term; this means we can
comment|// keep the currentFrame but we must rewind it
comment|// (so we scan from the start)
name|targetBeforeCurrentLength
operator|=
literal|0
expr_stmt|;
comment|//if (DEBUG) {
comment|//System.out.println("  target is before current (shares prefixLen=" + targetUpto + "); rewind frame ord=" + lastFrame.ord);
comment|//}
name|currentFrame
operator|=
name|lastFrame
expr_stmt|;
name|currentFrame
operator|.
name|rewind
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|// Target is exactly the same as current term
assert|assert
name|term
operator|.
name|length
argument_list|()
operator|==
name|target
operator|.
name|length
assert|;
if|if
condition|(
name|termExists
condition|)
block|{
comment|//if (DEBUG) {
comment|//System.out.println("  target is same as current; return FOUND");
comment|//}
return|return
name|SeekStatus
operator|.
name|FOUND
return|;
block|}
else|else
block|{
comment|//if (DEBUG) {
comment|//System.out.println("  target is same as current but term doesn't exist");
comment|//}
block|}
block|}
block|}
else|else
block|{
name|targetBeforeCurrentLength
operator|=
operator|-
literal|1
expr_stmt|;
name|arc
operator|=
name|fr
operator|.
name|index
operator|.
name|getFirstArc
argument_list|(
name|arcs
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|// Empty string prefix must have an output (block) in the index!
assert|assert
name|arc
operator|.
name|isFinal
argument_list|()
assert|;
assert|assert
name|arc
operator|.
name|output
operator|!=
literal|null
assert|;
comment|//if (DEBUG) {
comment|//System.out.println("    no seek state; push root frame");
comment|//}
name|output
operator|=
name|arc
operator|.
name|output
expr_stmt|;
name|currentFrame
operator|=
name|staticFrame
expr_stmt|;
comment|//term.length = 0;
name|targetUpto
operator|=
literal|0
expr_stmt|;
name|currentFrame
operator|=
name|pushFrame
argument_list|(
name|arc
argument_list|,
name|OrdsBlockTreeTermsWriter
operator|.
name|FST_OUTPUTS
operator|.
name|add
argument_list|(
name|output
argument_list|,
name|arc
operator|.
name|nextFinalOutput
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|positioned
operator|=
literal|true
expr_stmt|;
comment|//if (DEBUG) {
comment|//System.out.println("  start index loop targetUpto=" + targetUpto + " output=" + output + " currentFrame.ord+1=" + currentFrame.ord + " targetBeforeCurrentLength=" + targetBeforeCurrentLength);
comment|//}
comment|// We are done sharing the common prefix with the incoming target and where we are currently seek'd; now continue walking the index:
while|while
condition|(
name|targetUpto
operator|<
name|target
operator|.
name|length
condition|)
block|{
specifier|final
name|int
name|targetLabel
init|=
name|target
operator|.
name|bytes
index|[
name|target
operator|.
name|offset
operator|+
name|targetUpto
index|]
operator|&
literal|0xFF
decl_stmt|;
specifier|final
name|FST
operator|.
name|Arc
argument_list|<
name|Output
argument_list|>
name|nextArc
init|=
name|fr
operator|.
name|index
operator|.
name|findTargetArc
argument_list|(
name|targetLabel
argument_list|,
name|arc
argument_list|,
name|getArc
argument_list|(
literal|1
operator|+
name|targetUpto
argument_list|)
argument_list|,
name|fstReader
argument_list|)
decl_stmt|;
if|if
condition|(
name|nextArc
operator|==
literal|null
condition|)
block|{
comment|// Index is exhausted
comment|// if (DEBUG) {
comment|//   System.out.println("    index: index exhausted label=" + ((char) targetLabel) + " " + toHex(targetLabel));
comment|// }
name|validIndexPrefix
operator|=
name|currentFrame
operator|.
name|prefix
expr_stmt|;
comment|//validIndexPrefix = targetUpto;
name|currentFrame
operator|.
name|scanToFloorFrame
argument_list|(
name|target
argument_list|)
expr_stmt|;
name|currentFrame
operator|.
name|loadBlock
argument_list|()
expr_stmt|;
specifier|final
name|SeekStatus
name|result
init|=
name|currentFrame
operator|.
name|scanToTerm
argument_list|(
name|target
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|==
name|SeekStatus
operator|.
name|END
condition|)
block|{
name|term
operator|.
name|copyBytes
argument_list|(
name|target
argument_list|)
expr_stmt|;
name|termExists
operator|=
literal|false
expr_stmt|;
if|if
condition|(
name|next
argument_list|()
operator|!=
literal|null
condition|)
block|{
comment|//if (DEBUG) {
comment|//System.out.println("  return NOT_FOUND term=" + brToString(term) + " " + term);
comment|//}
return|return
name|SeekStatus
operator|.
name|NOT_FOUND
return|;
block|}
else|else
block|{
comment|//if (DEBUG) {
comment|//System.out.println("  return END");
comment|//}
return|return
name|SeekStatus
operator|.
name|END
return|;
block|}
block|}
else|else
block|{
comment|//if (DEBUG) {
comment|//System.out.println("  return " + result + " term=" + brToString(term) + " " + term);
comment|//}
return|return
name|result
return|;
block|}
block|}
else|else
block|{
comment|// Follow this arc
name|term
operator|.
name|setByteAt
argument_list|(
name|targetUpto
argument_list|,
operator|(
name|byte
operator|)
name|targetLabel
argument_list|)
expr_stmt|;
name|arc
operator|=
name|nextArc
expr_stmt|;
comment|// Aggregate output as we go:
assert|assert
name|arc
operator|.
name|output
operator|!=
literal|null
assert|;
if|if
condition|(
name|arc
operator|.
name|output
operator|!=
name|OrdsBlockTreeTermsWriter
operator|.
name|NO_OUTPUT
condition|)
block|{
name|output
operator|=
name|OrdsBlockTreeTermsWriter
operator|.
name|FST_OUTPUTS
operator|.
name|add
argument_list|(
name|output
argument_list|,
name|arc
operator|.
name|output
argument_list|)
expr_stmt|;
block|}
comment|//if (DEBUG) {
comment|//System.out.println("    index: follow label=" + toHex(target.bytes[target.offset + targetUpto]&0xff) + " arc.output=" + arc.output + " arc.nfo=" + arc.nextFinalOutput);
comment|//}
name|targetUpto
operator|++
expr_stmt|;
if|if
condition|(
name|arc
operator|.
name|isFinal
argument_list|()
condition|)
block|{
comment|//if (DEBUG) System.out.println("    arc is final!");
name|currentFrame
operator|=
name|pushFrame
argument_list|(
name|arc
argument_list|,
name|OrdsBlockTreeTermsWriter
operator|.
name|FST_OUTPUTS
operator|.
name|add
argument_list|(
name|output
argument_list|,
name|arc
operator|.
name|nextFinalOutput
argument_list|)
argument_list|,
name|targetUpto
argument_list|)
expr_stmt|;
comment|//if (DEBUG) System.out.println("    curFrame.ord=" + currentFrame.ord + " hasTerms=" + currentFrame.hasTerms);
block|}
block|}
block|}
comment|//validIndexPrefix = targetUpto;
name|validIndexPrefix
operator|=
name|currentFrame
operator|.
name|prefix
expr_stmt|;
name|currentFrame
operator|.
name|scanToFloorFrame
argument_list|(
name|target
argument_list|)
expr_stmt|;
name|currentFrame
operator|.
name|loadBlock
argument_list|()
expr_stmt|;
specifier|final
name|SeekStatus
name|result
init|=
name|currentFrame
operator|.
name|scanToTerm
argument_list|(
name|target
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|==
name|SeekStatus
operator|.
name|END
condition|)
block|{
name|term
operator|.
name|copyBytes
argument_list|(
name|target
argument_list|)
expr_stmt|;
name|termExists
operator|=
literal|false
expr_stmt|;
if|if
condition|(
name|next
argument_list|()
operator|!=
literal|null
condition|)
block|{
comment|//if (DEBUG) {
comment|//System.out.println("  return NOT_FOUND term=" + term.utf8ToString() + " " + term);
comment|//}
return|return
name|SeekStatus
operator|.
name|NOT_FOUND
return|;
block|}
else|else
block|{
comment|//if (DEBUG) {
comment|//System.out.println("  return END");
comment|//}
return|return
name|SeekStatus
operator|.
name|END
return|;
block|}
block|}
else|else
block|{
return|return
name|result
return|;
block|}
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unused"
argument_list|)
DECL|method|printSeekState
specifier|private
name|void
name|printSeekState
parameter_list|(
name|PrintStream
name|out
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|currentFrame
operator|==
name|staticFrame
condition|)
block|{
name|out
operator|.
name|println
argument_list|(
literal|"  no prior seek"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|out
operator|.
name|println
argument_list|(
literal|"  prior seek state:"
argument_list|)
expr_stmt|;
name|int
name|ord
init|=
literal|0
decl_stmt|;
name|boolean
name|isSeekFrame
init|=
literal|true
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|OrdsSegmentTermsEnumFrame
name|f
init|=
name|getFrame
argument_list|(
name|ord
argument_list|)
decl_stmt|;
assert|assert
name|f
operator|!=
literal|null
assert|;
specifier|final
name|BytesRef
name|prefix
init|=
operator|new
name|BytesRef
argument_list|(
name|term
operator|.
name|bytes
argument_list|()
argument_list|,
literal|0
argument_list|,
name|f
operator|.
name|prefix
argument_list|)
decl_stmt|;
if|if
condition|(
name|f
operator|.
name|nextEnt
operator|==
operator|-
literal|1
condition|)
block|{
name|out
operator|.
name|println
argument_list|(
literal|"    frame "
operator|+
operator|(
name|isSeekFrame
condition|?
literal|"(seek)"
else|:
literal|"(next)"
operator|)
operator|+
literal|" ord="
operator|+
name|ord
operator|+
literal|" fp="
operator|+
name|f
operator|.
name|fp
operator|+
operator|(
name|f
operator|.
name|isFloor
condition|?
operator|(
literal|" (fpOrig="
operator|+
name|f
operator|.
name|fpOrig
operator|+
literal|")"
operator|)
else|:
literal|""
operator|)
operator|+
literal|" prefixLen="
operator|+
name|f
operator|.
name|prefix
operator|+
literal|" prefix="
operator|+
name|brToString
argument_list|(
name|prefix
argument_list|)
operator|+
operator|(
name|f
operator|.
name|nextEnt
operator|==
operator|-
literal|1
condition|?
literal|""
else|:
operator|(
literal|" (of "
operator|+
name|f
operator|.
name|entCount
operator|+
literal|")"
operator|)
operator|)
operator|+
literal|" hasTerms="
operator|+
name|f
operator|.
name|hasTerms
operator|+
literal|" isFloor="
operator|+
name|f
operator|.
name|isFloor
operator|+
literal|" code="
operator|+
operator|(
operator|(
name|f
operator|.
name|fp
operator|<<
name|OrdsBlockTreeTermsWriter
operator|.
name|OUTPUT_FLAGS_NUM_BITS
operator|)
operator|+
operator|(
name|f
operator|.
name|hasTerms
condition|?
name|OrdsBlockTreeTermsWriter
operator|.
name|OUTPUT_FLAG_HAS_TERMS
else|:
literal|0
operator|)
operator|+
operator|(
name|f
operator|.
name|isFloor
condition|?
name|OrdsBlockTreeTermsWriter
operator|.
name|OUTPUT_FLAG_IS_FLOOR
else|:
literal|0
operator|)
operator|)
operator|+
literal|" isLastInFloor="
operator|+
name|f
operator|.
name|isLastInFloor
operator|+
literal|" mdUpto="
operator|+
name|f
operator|.
name|metaDataUpto
operator|+
literal|" tbOrd="
operator|+
name|f
operator|.
name|getTermBlockOrd
argument_list|()
operator|+
literal|" termOrd="
operator|+
name|f
operator|.
name|termOrd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|out
operator|.
name|println
argument_list|(
literal|"    frame "
operator|+
operator|(
name|isSeekFrame
condition|?
literal|"(seek, loaded)"
else|:
literal|"(next, loaded)"
operator|)
operator|+
literal|" ord="
operator|+
name|ord
operator|+
literal|" fp="
operator|+
name|f
operator|.
name|fp
operator|+
operator|(
name|f
operator|.
name|isFloor
condition|?
operator|(
literal|" (fpOrig="
operator|+
name|f
operator|.
name|fpOrig
operator|+
literal|")"
operator|)
else|:
literal|""
operator|)
operator|+
literal|" prefixLen="
operator|+
name|f
operator|.
name|prefix
operator|+
literal|" prefix="
operator|+
name|brToString
argument_list|(
name|prefix
argument_list|)
operator|+
literal|" nextEnt="
operator|+
name|f
operator|.
name|nextEnt
operator|+
operator|(
name|f
operator|.
name|nextEnt
operator|==
operator|-
literal|1
condition|?
literal|""
else|:
operator|(
literal|" (of "
operator|+
name|f
operator|.
name|entCount
operator|+
literal|")"
operator|)
operator|)
operator|+
literal|" hasTerms="
operator|+
name|f
operator|.
name|hasTerms
operator|+
literal|" isFloor="
operator|+
name|f
operator|.
name|isFloor
operator|+
literal|" code="
operator|+
operator|(
operator|(
name|f
operator|.
name|fp
operator|<<
name|OrdsBlockTreeTermsWriter
operator|.
name|OUTPUT_FLAGS_NUM_BITS
operator|)
operator|+
operator|(
name|f
operator|.
name|hasTerms
condition|?
name|OrdsBlockTreeTermsWriter
operator|.
name|OUTPUT_FLAG_HAS_TERMS
else|:
literal|0
operator|)
operator|+
operator|(
name|f
operator|.
name|isFloor
condition|?
name|OrdsBlockTreeTermsWriter
operator|.
name|OUTPUT_FLAG_IS_FLOOR
else|:
literal|0
operator|)
operator|)
operator|+
literal|" lastSubFP="
operator|+
name|f
operator|.
name|lastSubFP
operator|+
literal|" isLastInFloor="
operator|+
name|f
operator|.
name|isLastInFloor
operator|+
literal|" mdUpto="
operator|+
name|f
operator|.
name|metaDataUpto
operator|+
literal|" tbOrd="
operator|+
name|f
operator|.
name|getTermBlockOrd
argument_list|()
operator|+
literal|" termOrd="
operator|+
name|f
operator|.
name|termOrd
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fr
operator|.
name|index
operator|!=
literal|null
condition|)
block|{
assert|assert
operator|!
name|isSeekFrame
operator|||
name|f
operator|.
name|arc
operator|!=
literal|null
operator|:
literal|"isSeekFrame="
operator|+
name|isSeekFrame
operator|+
literal|" f.arc="
operator|+
name|f
operator|.
name|arc
assert|;
if|if
condition|(
name|f
operator|.
name|prefix
operator|>
literal|0
operator|&&
name|isSeekFrame
operator|&&
name|f
operator|.
name|arc
operator|.
name|label
operator|!=
operator|(
name|term
operator|.
name|byteAt
argument_list|(
name|f
operator|.
name|prefix
operator|-
literal|1
argument_list|)
operator|&
literal|0xFF
operator|)
condition|)
block|{
name|out
operator|.
name|println
argument_list|(
literal|"      broken seek state: arc.label="
operator|+
operator|(
name|char
operator|)
name|f
operator|.
name|arc
operator|.
name|label
operator|+
literal|" vs term byte="
operator|+
call|(
name|char
call|)
argument_list|(
name|term
operator|.
name|byteAt
argument_list|(
name|f
operator|.
name|prefix
operator|-
literal|1
argument_list|)
operator|&
literal|0xFF
argument_list|)
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"seek state is broken"
argument_list|)
throw|;
block|}
name|Output
name|output
init|=
name|Util
operator|.
name|get
argument_list|(
name|fr
operator|.
name|index
argument_list|,
name|prefix
argument_list|)
decl_stmt|;
if|if
condition|(
name|output
operator|==
literal|null
condition|)
block|{
name|out
operator|.
name|println
argument_list|(
literal|"      broken seek state: prefix is not final in index"
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"seek state is broken"
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
name|isSeekFrame
operator|&&
operator|!
name|f
operator|.
name|isFloor
condition|)
block|{
specifier|final
name|ByteArrayDataInput
name|reader
init|=
operator|new
name|ByteArrayDataInput
argument_list|(
name|output
operator|.
name|bytes
operator|.
name|bytes
argument_list|,
name|output
operator|.
name|bytes
operator|.
name|offset
argument_list|,
name|output
operator|.
name|bytes
operator|.
name|length
argument_list|)
decl_stmt|;
specifier|final
name|long
name|codeOrig
init|=
name|reader
operator|.
name|readVLong
argument_list|()
decl_stmt|;
specifier|final
name|long
name|code
init|=
operator|(
name|f
operator|.
name|fp
operator|<<
name|OrdsBlockTreeTermsWriter
operator|.
name|OUTPUT_FLAGS_NUM_BITS
operator|)
operator||
operator|(
name|f
operator|.
name|hasTerms
condition|?
name|OrdsBlockTreeTermsWriter
operator|.
name|OUTPUT_FLAG_HAS_TERMS
else|:
literal|0
operator|)
operator||
operator|(
name|f
operator|.
name|isFloor
condition|?
name|OrdsBlockTreeTermsWriter
operator|.
name|OUTPUT_FLAG_IS_FLOOR
else|:
literal|0
operator|)
decl_stmt|;
if|if
condition|(
name|codeOrig
operator|!=
name|code
condition|)
block|{
name|out
operator|.
name|println
argument_list|(
literal|"      broken seek state: output code="
operator|+
name|codeOrig
operator|+
literal|" doesn't match frame code="
operator|+
name|code
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"seek state is broken"
argument_list|)
throw|;
block|}
block|}
block|}
if|if
condition|(
name|f
operator|==
name|currentFrame
condition|)
block|{
break|break;
block|}
if|if
condition|(
name|f
operator|.
name|prefix
operator|==
name|validIndexPrefix
condition|)
block|{
name|isSeekFrame
operator|=
literal|false
expr_stmt|;
block|}
name|ord
operator|++
expr_stmt|;
block|}
block|}
block|}
comment|/* Decodes only the term bytes of the next term.  If caller then asks for      metadata, ie docFreq, totalTermFreq or pulls a D/&PEnum, we then (lazily)      decode all metadata up to the current term. */
annotation|@
name|Override
DECL|method|next
specifier|public
name|BytesRef
name|next
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|in
operator|==
literal|null
condition|)
block|{
comment|// Fresh TermsEnum; seek to first term:
specifier|final
name|FST
operator|.
name|Arc
argument_list|<
name|Output
argument_list|>
name|arc
decl_stmt|;
if|if
condition|(
name|fr
operator|.
name|index
operator|!=
literal|null
condition|)
block|{
name|arc
operator|=
name|fr
operator|.
name|index
operator|.
name|getFirstArc
argument_list|(
name|arcs
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|// Empty string prefix must have an output in the index!
assert|assert
name|arc
operator|.
name|isFinal
argument_list|()
assert|;
block|}
else|else
block|{
name|arc
operator|=
literal|null
expr_stmt|;
block|}
name|currentFrame
operator|=
name|pushFrame
argument_list|(
name|arc
argument_list|,
name|fr
operator|.
name|rootCode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|currentFrame
operator|.
name|loadBlock
argument_list|()
expr_stmt|;
name|positioned
operator|=
literal|true
expr_stmt|;
block|}
name|targetBeforeCurrentLength
operator|=
name|currentFrame
operator|.
name|ord
expr_stmt|;
assert|assert
operator|!
name|eof
assert|;
comment|//if (DEBUG) {
comment|//System.out.println("\nBTTR.next seg=" + segment + " term=" + brToString(term) + " termExists?=" + termExists + " field=" + fieldInfo.name + " termBlockOrd=" + currentFrame.state.termBlockOrd + " validIndexPrefix=" + validIndexPrefix);
comment|//printSeekState();
comment|//}
if|if
condition|(
name|currentFrame
operator|==
name|staticFrame
operator|||
name|positioned
operator|==
literal|false
condition|)
block|{
comment|// If seek was previously called and the term was
comment|// cached, or seek(TermState) was called, usually
comment|// caller is just going to pull a D/&PEnum or get
comment|// docFreq, etc.  But, if they then call next(),
comment|// this method catches up all internal state so next()
comment|// works properly:
comment|// if (DEBUG) System.out.println("  re-seek to pending term=" + term.utf8ToString() + " " + term);
specifier|final
name|boolean
name|result
init|=
name|seekExact
argument_list|(
name|term
operator|.
name|get
argument_list|()
argument_list|)
decl_stmt|;
assert|assert
name|result
assert|;
block|}
comment|// Pop finished blocks
while|while
condition|(
name|currentFrame
operator|.
name|nextEnt
operator|==
name|currentFrame
operator|.
name|entCount
condition|)
block|{
if|if
condition|(
operator|!
name|currentFrame
operator|.
name|isLastInFloor
condition|)
block|{
name|currentFrame
operator|.
name|loadNextFloorBlock
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|//if (DEBUG) System.out.println("  pop frame");
if|if
condition|(
name|currentFrame
operator|.
name|ord
operator|==
literal|0
condition|)
block|{
comment|//if (DEBUG) System.out.println("  return null");
assert|assert
name|setEOF
argument_list|()
assert|;
name|term
operator|.
name|setLength
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|validIndexPrefix
operator|=
literal|0
expr_stmt|;
name|currentFrame
operator|.
name|rewind
argument_list|()
expr_stmt|;
name|termExists
operator|=
literal|false
expr_stmt|;
name|positioned
operator|=
literal|false
expr_stmt|;
return|return
literal|null
return|;
block|}
specifier|final
name|long
name|lastFP
init|=
name|currentFrame
operator|.
name|fpOrig
decl_stmt|;
name|currentFrame
operator|=
name|stack
index|[
name|currentFrame
operator|.
name|ord
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|currentFrame
operator|.
name|nextEnt
operator|==
operator|-
literal|1
operator|||
name|currentFrame
operator|.
name|lastSubFP
operator|!=
name|lastFP
condition|)
block|{
comment|// We popped into a frame that's not loaded
comment|// yet or not scan'd to the right entry
name|currentFrame
operator|.
name|scanToFloorFrame
argument_list|(
name|term
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
name|currentFrame
operator|.
name|loadBlock
argument_list|()
expr_stmt|;
name|currentFrame
operator|.
name|scanToSubBlock
argument_list|(
name|lastFP
argument_list|)
expr_stmt|;
block|}
comment|// Note that the seek state (last seek) has been
comment|// invalidated beyond this depth
name|validIndexPrefix
operator|=
name|Math
operator|.
name|min
argument_list|(
name|validIndexPrefix
argument_list|,
name|currentFrame
operator|.
name|prefix
argument_list|)
expr_stmt|;
comment|//if (DEBUG) {
comment|//System.out.println("  reset validIndexPrefix=" + validIndexPrefix);
comment|//}
block|}
block|}
while|while
condition|(
literal|true
condition|)
block|{
name|long
name|prevTermOrd
init|=
name|currentFrame
operator|.
name|termOrd
decl_stmt|;
if|if
condition|(
name|currentFrame
operator|.
name|next
argument_list|()
condition|)
block|{
comment|// Push to new block:
comment|//if (DEBUG) System.out.println("  push frame");
name|currentFrame
operator|=
name|pushFrame
argument_list|(
literal|null
argument_list|,
name|currentFrame
operator|.
name|lastSubFP
argument_list|,
name|term
operator|.
name|length
argument_list|()
argument_list|,
name|prevTermOrd
argument_list|)
expr_stmt|;
comment|// This is a "next" frame -- even if it's
comment|// floor'd we must pretend it isn't so we don't
comment|// try to scan to the right floor frame:
name|currentFrame
operator|.
name|isFloor
operator|=
literal|false
expr_stmt|;
comment|//currentFrame.hasTerms = true;
name|currentFrame
operator|.
name|loadBlock
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|//if (DEBUG) System.out.println("  return term=" + term.utf8ToString() + " " + term + " currentFrame.ord=" + currentFrame.ord);
name|positioned
operator|=
literal|true
expr_stmt|;
return|return
name|term
operator|.
name|get
argument_list|()
return|;
block|}
block|}
block|}
annotation|@
name|Override
DECL|method|term
specifier|public
name|BytesRef
name|term
parameter_list|()
block|{
assert|assert
operator|!
name|eof
assert|;
return|return
name|term
operator|.
name|get
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|ord
specifier|public
name|long
name|ord
parameter_list|()
block|{
assert|assert
operator|!
name|eof
assert|;
assert|assert
name|currentFrame
operator|.
name|termOrd
operator|>
literal|0
assert|;
return|return
name|currentFrame
operator|.
name|termOrd
operator|-
literal|1
return|;
block|}
annotation|@
name|Override
DECL|method|docFreq
specifier|public
name|int
name|docFreq
parameter_list|()
throws|throws
name|IOException
block|{
assert|assert
operator|!
name|eof
assert|;
comment|//if (DEBUG) System.out.println("BTR.docFreq");
name|currentFrame
operator|.
name|decodeMetaData
argument_list|()
expr_stmt|;
comment|//if (DEBUG) System.out.println("  return " + currentFrame.state.docFreq);
return|return
name|currentFrame
operator|.
name|state
operator|.
name|docFreq
return|;
block|}
annotation|@
name|Override
DECL|method|totalTermFreq
specifier|public
name|long
name|totalTermFreq
parameter_list|()
throws|throws
name|IOException
block|{
assert|assert
operator|!
name|eof
assert|;
name|currentFrame
operator|.
name|decodeMetaData
argument_list|()
expr_stmt|;
return|return
name|currentFrame
operator|.
name|state
operator|.
name|totalTermFreq
return|;
block|}
annotation|@
name|Override
DECL|method|docs
specifier|public
name|DocsEnum
name|docs
parameter_list|(
name|Bits
name|skipDocs
parameter_list|,
name|DocsEnum
name|reuse
parameter_list|,
name|int
name|flags
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
operator|!
name|eof
assert|;
comment|//if (DEBUG) {
comment|//System.out.println("BTTR.docs seg=" + segment);
comment|//}
name|currentFrame
operator|.
name|decodeMetaData
argument_list|()
expr_stmt|;
comment|//if (DEBUG) {
comment|//System.out.println("  state=" + currentFrame.state);
comment|//}
return|return
name|fr
operator|.
name|parent
operator|.
name|postingsReader
operator|.
name|docs
argument_list|(
name|fr
operator|.
name|fieldInfo
argument_list|,
name|currentFrame
operator|.
name|state
argument_list|,
name|skipDocs
argument_list|,
name|reuse
argument_list|,
name|flags
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|docsAndPositions
specifier|public
name|DocsAndPositionsEnum
name|docsAndPositions
parameter_list|(
name|Bits
name|skipDocs
parameter_list|,
name|DocsAndPositionsEnum
name|reuse
parameter_list|,
name|int
name|flags
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|fr
operator|.
name|fieldInfo
operator|.
name|getIndexOptions
argument_list|()
operator|.
name|compareTo
argument_list|(
name|IndexOptions
operator|.
name|DOCS_AND_FREQS_AND_POSITIONS
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|// Positions were not indexed:
return|return
literal|null
return|;
block|}
assert|assert
operator|!
name|eof
assert|;
name|currentFrame
operator|.
name|decodeMetaData
argument_list|()
expr_stmt|;
return|return
name|fr
operator|.
name|parent
operator|.
name|postingsReader
operator|.
name|docsAndPositions
argument_list|(
name|fr
operator|.
name|fieldInfo
argument_list|,
name|currentFrame
operator|.
name|state
argument_list|,
name|skipDocs
argument_list|,
name|reuse
argument_list|,
name|flags
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|seekExact
specifier|public
name|void
name|seekExact
parameter_list|(
name|BytesRef
name|target
parameter_list|,
name|TermState
name|otherState
parameter_list|)
block|{
comment|// if (DEBUG) {
comment|//   System.out.println("BTTR.seekExact termState seg=" + segment + " target=" + target.utf8ToString() + " " + target + " state=" + otherState);
comment|// }
assert|assert
name|clearEOF
argument_list|()
assert|;
if|if
condition|(
name|target
operator|.
name|compareTo
argument_list|(
name|term
operator|.
name|get
argument_list|()
argument_list|)
operator|!=
literal|0
operator|||
operator|!
name|termExists
condition|)
block|{
assert|assert
name|otherState
operator|!=
literal|null
operator|&&
name|otherState
operator|instanceof
name|BlockTermState
assert|;
name|BlockTermState
name|blockState
init|=
operator|(
name|BlockTermState
operator|)
name|otherState
decl_stmt|;
name|currentFrame
operator|=
name|staticFrame
expr_stmt|;
name|currentFrame
operator|.
name|state
operator|.
name|copyFrom
argument_list|(
name|otherState
argument_list|)
expr_stmt|;
name|term
operator|.
name|copyBytes
argument_list|(
name|target
argument_list|)
expr_stmt|;
name|currentFrame
operator|.
name|metaDataUpto
operator|=
name|currentFrame
operator|.
name|getTermBlockOrd
argument_list|()
expr_stmt|;
name|currentFrame
operator|.
name|termOrd
operator|=
name|blockState
operator|.
name|ord
operator|+
literal|1
expr_stmt|;
assert|assert
name|currentFrame
operator|.
name|metaDataUpto
operator|>
literal|0
assert|;
name|validIndexPrefix
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|// if (DEBUG) {
comment|//   System.out.println("  skip seek: already on target state=" + currentFrame.state);
comment|// }
block|}
name|positioned
operator|=
literal|true
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|termState
specifier|public
name|TermState
name|termState
parameter_list|()
throws|throws
name|IOException
block|{
assert|assert
operator|!
name|eof
assert|;
name|currentFrame
operator|.
name|decodeMetaData
argument_list|()
expr_stmt|;
name|BlockTermState
name|ts
init|=
operator|(
name|BlockTermState
operator|)
name|currentFrame
operator|.
name|state
operator|.
name|clone
argument_list|()
decl_stmt|;
assert|assert
name|currentFrame
operator|.
name|termOrd
operator|>
literal|0
assert|;
name|ts
operator|.
name|ord
operator|=
name|currentFrame
operator|.
name|termOrd
operator|-
literal|1
expr_stmt|;
comment|//if (DEBUG) System.out.println("BTTR.termState seg=" + segment + " state=" + ts);
return|return
name|ts
return|;
block|}
annotation|@
name|Override
DECL|method|seekExact
specifier|public
name|void
name|seekExact
parameter_list|(
name|long
name|targetOrd
parameter_list|)
throws|throws
name|IOException
block|{
comment|// System.out.println("seekExact targetOrd=" + targetOrd);
if|if
condition|(
name|targetOrd
operator|<
literal|0
operator|||
name|targetOrd
operator|>=
name|fr
operator|.
name|numTerms
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"targetOrd out of bounds (got: "
operator|+
name|targetOrd
operator|+
literal|", numTerms="
operator|+
name|fr
operator|.
name|numTerms
operator|+
literal|")"
argument_list|)
throw|;
block|}
assert|assert
name|clearEOF
argument_list|()
assert|;
comment|// First do reverse lookup in the index to find the block that holds this term:
name|InputOutput
name|io
init|=
name|getByOutput
argument_list|(
name|targetOrd
argument_list|)
decl_stmt|;
name|term
operator|.
name|grow
argument_list|(
name|io
operator|.
name|input
operator|.
name|length
argument_list|)
expr_stmt|;
name|Util
operator|.
name|toBytesRef
argument_list|(
name|io
operator|.
name|input
argument_list|,
name|term
argument_list|)
expr_stmt|;
if|if
condition|(
name|io
operator|.
name|input
operator|.
name|length
operator|==
literal|0
condition|)
block|{
name|currentFrame
operator|=
name|staticFrame
expr_stmt|;
block|}
else|else
block|{
name|currentFrame
operator|=
name|getFrame
argument_list|(
name|io
operator|.
name|input
operator|.
name|length
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|FST
operator|.
name|Arc
argument_list|<
name|Output
argument_list|>
name|arc
init|=
name|getArc
argument_list|(
name|io
operator|.
name|input
operator|.
name|length
argument_list|)
decl_stmt|;
comment|// Don't force rewind based on term length; we rewind below based on ord:
name|targetBeforeCurrentLength
operator|=
name|Integer
operator|.
name|MAX_VALUE
expr_stmt|;
name|currentFrame
operator|=
name|pushFrame
argument_list|(
name|arc
argument_list|,
name|io
operator|.
name|output
argument_list|,
name|io
operator|.
name|input
operator|.
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|currentFrame
operator|.
name|termOrd
operator|>
name|targetOrd
condition|)
block|{
comment|//System.out.println("  do rewind: " + currentFrame.termOrd);
name|currentFrame
operator|.
name|rewind
argument_list|()
expr_stmt|;
block|}
name|currentFrame
operator|.
name|scanToFloorFrame
argument_list|(
name|targetOrd
argument_list|)
expr_stmt|;
name|currentFrame
operator|.
name|loadBlock
argument_list|()
expr_stmt|;
comment|// System.out.println("  after loadBlock termOrd=" + currentFrame.termOrd + " vs " + targetOrd);
while|while
condition|(
name|currentFrame
operator|.
name|termOrd
operator|<=
name|targetOrd
condition|)
block|{
name|currentFrame
operator|.
name|next
argument_list|()
expr_stmt|;
block|}
assert|assert
name|currentFrame
operator|.
name|termOrd
operator|==
name|targetOrd
operator|+
literal|1
operator|:
literal|"currentFrame.termOrd="
operator|+
name|currentFrame
operator|.
name|termOrd
operator|+
literal|" vs ord="
operator|+
name|targetOrd
assert|;
assert|assert
name|termExists
assert|;
comment|// Leave enum fully unpositioned, because we didn't set frames for each byte leading up to current term:
name|validIndexPrefix
operator|=
literal|0
expr_stmt|;
name|positioned
operator|=
literal|false
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"OrdsSegmentTermsEnum(seg="
operator|+
name|fr
operator|.
name|parent
operator|+
literal|")"
return|;
block|}
comment|/** Holds a single input (IntsRef) + output pair. */
DECL|class|InputOutput
specifier|private
specifier|static
class|class
name|InputOutput
block|{
DECL|field|input
specifier|public
name|IntsRef
name|input
decl_stmt|;
DECL|field|output
specifier|public
name|Output
name|output
decl_stmt|;
annotation|@
name|Override
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"InputOutput(input="
operator|+
name|input
operator|+
literal|" output="
operator|+
name|output
operator|+
literal|")"
return|;
block|}
block|}
DECL|field|arc
specifier|private
specifier|final
name|FST
operator|.
name|Arc
argument_list|<
name|Output
argument_list|>
name|arc
init|=
operator|new
name|FST
operator|.
name|Arc
argument_list|<>
argument_list|()
decl_stmt|;
comment|// TODO: this is similar to Util.getByOutput ... can we refactor/share?
comment|/** Specialized getByOutput that can understand the ranges (startOrd to endOrd) we use here, not just startOrd. */
DECL|method|getByOutput
specifier|private
name|InputOutput
name|getByOutput
parameter_list|(
name|long
name|targetOrd
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|IntsRefBuilder
name|result
init|=
operator|new
name|IntsRefBuilder
argument_list|()
decl_stmt|;
name|fr
operator|.
name|index
operator|.
name|getFirstArc
argument_list|(
name|arc
argument_list|)
expr_stmt|;
name|Output
name|output
init|=
name|arc
operator|.
name|output
decl_stmt|;
name|int
name|upto
init|=
literal|0
decl_stmt|;
name|int
name|bestUpto
init|=
literal|0
decl_stmt|;
name|Output
name|bestOutput
init|=
literal|null
decl_stmt|;
comment|/*     Writer w = new OutputStreamWriter(new FileOutputStream("/tmp/out.dot"));     Util.toDot(fr.index, w, true, true);     w.close();     */
comment|// System.out.println("reverseLookup seg=" + fr.parent.segment + " output=" + targetOrd);
while|while
condition|(
literal|true
condition|)
block|{
comment|// System.out.println("  loop: output=" + output.startOrd + "-" + (Long.MAX_VALUE-output.endOrd) + " upto=" + upto + " arc=" + arc + " final?=" + arc.isFinal());
if|if
condition|(
name|arc
operator|.
name|isFinal
argument_list|()
condition|)
block|{
specifier|final
name|Output
name|finalOutput
init|=
name|OrdsBlockTreeTermsWriter
operator|.
name|FST_OUTPUTS
operator|.
name|add
argument_list|(
name|output
argument_list|,
name|arc
operator|.
name|nextFinalOutput
argument_list|)
decl_stmt|;
comment|// System.out.println("  isFinal: " + finalOutput.startOrd + "-" + (Long.MAX_VALUE-finalOutput.endOrd));
if|if
condition|(
name|targetOrd
operator|>=
name|finalOutput
operator|.
name|startOrd
operator|&&
name|targetOrd
operator|<=
name|Long
operator|.
name|MAX_VALUE
operator|-
name|finalOutput
operator|.
name|endOrd
condition|)
block|{
comment|// Only one range should match across all arc leaving this node
comment|//assert bestOutput == null;
name|bestOutput
operator|=
name|finalOutput
expr_stmt|;
name|bestUpto
operator|=
name|upto
expr_stmt|;
block|}
block|}
if|if
condition|(
name|FST
operator|.
name|targetHasArcs
argument_list|(
name|arc
argument_list|)
condition|)
block|{
comment|// System.out.println("  targetHasArcs");
name|result
operator|.
name|grow
argument_list|(
literal|1
operator|+
name|upto
argument_list|)
expr_stmt|;
name|fr
operator|.
name|index
operator|.
name|readFirstRealTargetArc
argument_list|(
name|arc
operator|.
name|target
argument_list|,
name|arc
argument_list|,
name|fstReader
argument_list|)
expr_stmt|;
if|if
condition|(
name|arc
operator|.
name|bytesPerArc
operator|!=
literal|0
condition|)
block|{
comment|// System.out.println("  array arcs");
name|int
name|low
init|=
literal|0
decl_stmt|;
name|int
name|high
init|=
name|arc
operator|.
name|numArcs
operator|-
literal|1
decl_stmt|;
name|int
name|mid
init|=
literal|0
decl_stmt|;
comment|//System.out.println("bsearch: numArcs=" + arc.numArcs + " target=" + targetOutput + " output=" + output);
name|boolean
name|found
init|=
literal|false
decl_stmt|;
while|while
condition|(
name|low
operator|<=
name|high
condition|)
block|{
name|mid
operator|=
operator|(
name|low
operator|+
name|high
operator|)
operator|>>>
literal|1
expr_stmt|;
name|fstReader
operator|.
name|setPosition
argument_list|(
name|arc
operator|.
name|posArcsStart
argument_list|)
expr_stmt|;
name|fstReader
operator|.
name|skipBytes
argument_list|(
name|arc
operator|.
name|bytesPerArc
operator|*
name|mid
argument_list|)
expr_stmt|;
specifier|final
name|byte
name|flags
init|=
name|fstReader
operator|.
name|readByte
argument_list|()
decl_stmt|;
name|fr
operator|.
name|index
operator|.
name|readLabel
argument_list|(
name|fstReader
argument_list|)
expr_stmt|;
specifier|final
name|Output
name|minArcOutput
decl_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|FST
operator|.
name|BIT_ARC_HAS_OUTPUT
operator|)
operator|!=
literal|0
condition|)
block|{
name|minArcOutput
operator|=
name|OrdsBlockTreeTermsWriter
operator|.
name|FST_OUTPUTS
operator|.
name|add
argument_list|(
name|output
argument_list|,
name|OrdsBlockTreeTermsWriter
operator|.
name|FST_OUTPUTS
operator|.
name|read
argument_list|(
name|fstReader
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|minArcOutput
operator|=
name|output
expr_stmt|;
block|}
comment|// System.out.println("  cycle mid=" + mid + " targetOrd=" + targetOrd + " output=" + minArcOutput.startOrd + "-" + (Long.MAX_VALUE-minArcOutput.endOrd));
if|if
condition|(
name|targetOrd
operator|>
name|Long
operator|.
name|MAX_VALUE
operator|-
name|minArcOutput
operator|.
name|endOrd
condition|)
block|{
name|low
operator|=
name|mid
operator|+
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|targetOrd
operator|<
name|minArcOutput
operator|.
name|startOrd
condition|)
block|{
name|high
operator|=
name|mid
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|// System.out.println("    found!!");
name|found
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|found
condition|)
block|{
comment|// Keep recursing
name|arc
operator|.
name|arcIdx
operator|=
name|mid
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|result
operator|.
name|setLength
argument_list|(
name|bestUpto
argument_list|)
expr_stmt|;
name|InputOutput
name|io
init|=
operator|new
name|InputOutput
argument_list|()
decl_stmt|;
name|io
operator|.
name|input
operator|=
name|result
operator|.
name|get
argument_list|()
expr_stmt|;
name|io
operator|.
name|output
operator|=
name|bestOutput
expr_stmt|;
comment|// System.out.println("  ret0=" + io);
return|return
name|io
return|;
block|}
name|fr
operator|.
name|index
operator|.
name|readNextRealArc
argument_list|(
name|arc
argument_list|,
name|fstReader
argument_list|)
expr_stmt|;
comment|// Recurse on this arc:
name|result
operator|.
name|setIntAt
argument_list|(
name|upto
operator|++
argument_list|,
name|arc
operator|.
name|label
argument_list|)
expr_stmt|;
name|output
operator|=
name|OrdsBlockTreeTermsWriter
operator|.
name|FST_OUTPUTS
operator|.
name|add
argument_list|(
name|output
argument_list|,
name|arc
operator|.
name|output
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// System.out.println("    non-array arc");
while|while
condition|(
literal|true
condition|)
block|{
comment|// System.out.println("    cycle label=" + arc.label + " output=" + arc.output);
comment|// This is the min output we'd hit if we follow
comment|// this arc:
specifier|final
name|Output
name|minArcOutput
init|=
name|OrdsBlockTreeTermsWriter
operator|.
name|FST_OUTPUTS
operator|.
name|add
argument_list|(
name|output
argument_list|,
name|arc
operator|.
name|output
argument_list|)
decl_stmt|;
name|long
name|endOrd
init|=
name|Long
operator|.
name|MAX_VALUE
operator|-
name|minArcOutput
operator|.
name|endOrd
decl_stmt|;
comment|// System.out.println("    endOrd=" + endOrd + " targetOrd=" + targetOrd);
if|if
condition|(
name|targetOrd
operator|>=
name|minArcOutput
operator|.
name|startOrd
operator|&&
name|targetOrd
operator|<=
name|endOrd
condition|)
block|{
comment|// Recurse on this arc:
name|output
operator|=
name|minArcOutput
expr_stmt|;
name|result
operator|.
name|setIntAt
argument_list|(
name|upto
operator|++
argument_list|,
name|arc
operator|.
name|label
argument_list|)
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|targetOrd
operator|<
name|endOrd
operator|||
name|arc
operator|.
name|isLast
argument_list|()
condition|)
block|{
name|result
operator|.
name|setLength
argument_list|(
name|bestUpto
argument_list|)
expr_stmt|;
name|InputOutput
name|io
init|=
operator|new
name|InputOutput
argument_list|()
decl_stmt|;
name|io
operator|.
name|input
operator|=
name|result
operator|.
name|get
argument_list|()
expr_stmt|;
assert|assert
name|bestOutput
operator|!=
literal|null
assert|;
name|io
operator|.
name|output
operator|=
name|bestOutput
expr_stmt|;
comment|// System.out.println("  ret2=" + io);
return|return
name|io
return|;
block|}
else|else
block|{
comment|// System.out.println("  next arc");
comment|// Read next arc in this node:
name|fr
operator|.
name|index
operator|.
name|readNextRealArc
argument_list|(
name|arc
argument_list|,
name|fstReader
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
block|{
name|result
operator|.
name|setLength
argument_list|(
name|bestUpto
argument_list|)
expr_stmt|;
name|InputOutput
name|io
init|=
operator|new
name|InputOutput
argument_list|()
decl_stmt|;
name|io
operator|.
name|input
operator|=
name|result
operator|.
name|get
argument_list|()
expr_stmt|;
name|io
operator|.
name|output
operator|=
name|bestOutput
expr_stmt|;
comment|// System.out.println("  ret3=" + io);
return|return
name|io
return|;
block|}
block|}
block|}
block|}
end_class
end_unit
