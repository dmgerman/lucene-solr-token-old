begin_unit
begin_package
DECL|package|org.apache.lucene.codecs.idversion
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|codecs
operator|.
name|idversion
package|;
end_package
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|codecs
operator|.
name|BlockTermState
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|codecs
operator|.
name|CodecUtil
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|codecs
operator|.
name|FieldsConsumer
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|codecs
operator|.
name|PostingsWriterBase
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|FieldInfo
operator|.
name|IndexOptions
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|FieldInfo
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|FieldInfos
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|Fields
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|IndexFileNames
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|SegmentWriteState
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|Terms
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|TermsEnum
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|DataOutput
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|IndexOutput
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|RAMOutputStream
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|ArrayUtil
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|BytesRef
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|FixedBitSet
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|IOUtils
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|IntsRef
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|fst
operator|.
name|Builder
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|fst
operator|.
name|ByteSequenceOutputs
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|fst
operator|.
name|BytesRefFSTEnum
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|fst
operator|.
name|FST
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|fst
operator|.
name|NoOutputs
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|fst
operator|.
name|Outputs
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|fst
operator|.
name|PairOutputs
operator|.
name|Pair
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|fst
operator|.
name|PairOutputs
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|fst
operator|.
name|PositiveIntOutputs
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|fst
operator|.
name|Util
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|packed
operator|.
name|PackedInts
import|;
end_import
begin_comment
comment|/*   TODO:        - Currently there is a one-to-one mapping of indexed       term to term block, but we could decouple the two, ie,       put more terms into the index than there are blocks.       The index would take up more RAM but then it'd be able       to avoid seeking more often and could make PK/FuzzyQ       faster if the additional indexed terms could store       the offset into the terms block.      - The blocks are not written in true depth-first       order, meaning if you just next() the file pointer will       sometimes jump backwards.  For example, block foo* will       be written before block f* because it finished before.       This could possibly hurt performance if the terms dict is       not hot, since OSs anticipate sequential file access.  We       could fix the writer to re-order the blocks as a 2nd       pass.      - Each block encodes the term suffixes packed       sequentially using a separate vInt per term, which is       1) wasteful and 2) slow (must linear scan to find a       particular suffix).  We should instead 1) make       random-access array so we can directly access the Nth       suffix, and 2) bulk-encode this array using bulk int[]       codecs; then at search time we can binary search when       we seek a particular term. */
end_comment
begin_comment
comment|/**  * Block-based terms index and dictionary writer.  *<p>  * Writes terms dict and index, block-encoding (column  * stride) each term's metadata for each set of terms  * between two index terms.  *<p>  * Files:  *<ul>  *<li><tt>.tim</tt>:<a href="#Termdictionary">Term Dictionary</a></li>  *<li><tt>.tip</tt>:<a href="#Termindex">Term Index</a></li>  *</ul>  *<p>  *<a name="Termdictionary" id="Termdictionary"></a>  *<h3>Term Dictionary</h3>  *  *<p>The .tim file contains the list of terms in each  * field along with per-term statistics (such as docfreq)  * and per-term metadata (typically pointers to the postings list  * for that term in the inverted index).  *</p>  *  *<p>The .tim is arranged in blocks: with blocks containing  * a variable number of entries (by default 25-48), where  * each entry is either a term or a reference to a  * sub-block.</p>  *  *<p>NOTE: The term dictionary can plug into different postings implementations:  * the postings writer/reader are actually responsible for encoding   * and decoding the Postings Metadata and Term Metadata sections.</p>  *  *<ul>  *<li>TermsDict (.tim) --&gt; Header,<i>PostingsHeader</i>, NodeBlock<sup>NumBlocks</sup>,  *                               FieldSummary, DirOffset, Footer</li>  *<li>NodeBlock --&gt; (OuterNode | InnerNode)</li>  *<li>OuterNode --&gt; EntryCount, SuffixLength, Byte<sup>SuffixLength</sup>, StatsLength,&lt; TermStats&gt;<sup>EntryCount</sup>, MetaLength,&lt;<i>TermMetadata</i>&gt;<sup>EntryCount</sup></li>  *<li>InnerNode --&gt; EntryCount, SuffixLength[,Sub?], Byte<sup>SuffixLength</sup>, StatsLength,&lt; TermStats ?&gt;<sup>EntryCount</sup>, MetaLength,&lt;<i>TermMetadata ?</i>&gt;<sup>EntryCount</sup></li>  *<li>TermStats --&gt; DocFreq, TotalTermFreq</li>  *<li>FieldSummary --&gt; NumFields,&lt;FieldNumber, NumTerms, RootCodeLength, Byte<sup>RootCodeLength</sup>,  *                            SumTotalTermFreq?, SumDocFreq, DocCount, LongsSize, MinTerm, MaxTerm&gt;<sup>NumFields</sup></li>  *<li>Header --&gt; {@link CodecUtil#writeHeader CodecHeader}</li>  *<li>DirOffset --&gt; {@link DataOutput#writeLong Uint64}</li>  *<li>MinTerm,MaxTerm --&gt; {@link DataOutput#writeVInt VInt} length followed by the byte[]</li>  *<li>EntryCount,SuffixLength,StatsLength,DocFreq,MetaLength,NumFields,  *        FieldNumber,RootCodeLength,DocCount,LongsSize --&gt; {@link DataOutput#writeVInt VInt}</li>  *<li>TotalTermFreq,NumTerms,SumTotalTermFreq,SumDocFreq --&gt;   *        {@link DataOutput#writeVLong VLong}</li>  *<li>Footer --&gt; {@link CodecUtil#writeFooter CodecFooter}</li>  *</ul>  *<p>Notes:</p>  *<ul>  *<li>Header is a {@link CodecUtil#writeHeader CodecHeader} storing the version information  *        for the BlockTree implementation.</li>  *<li>DirOffset is a pointer to the FieldSummary section.</li>  *<li>DocFreq is the count of documents which contain the term.</li>  *<li>TotalTermFreq is the total number of occurrences of the term. This is encoded  *        as the difference between the total number of occurrences and the DocFreq.</li>  *<li>FieldNumber is the fields number from {@link FieldInfos}. (.fnm)</li>  *<li>NumTerms is the number of unique terms for the field.</li>  *<li>RootCode points to the root block for the field.</li>  *<li>SumDocFreq is the total number of postings, the number of term-document pairs across  *        the entire field.</li>  *<li>DocCount is the number of documents that have at least one posting for this field.</li>  *<li>LongsSize records how many long values the postings writer/reader record per term  *        (e.g., to hold freq/prox/doc file offsets).  *<li>MinTerm, MaxTerm are the lowest and highest term in this field.</li>  *<li>PostingsHeader and TermMetadata are plugged into by the specific postings implementation:  *        these contain arbitrary per-file data (such as parameters or versioning information)   *        and per-term data (such as pointers to inverted files).</li>  *<li>For inner nodes of the tree, every entry will steal one bit to mark whether it points  *        to child nodes(sub-block). If so, the corresponding TermStats and TermMetaData are omitted</li>  *</ul>  *<a name="Termindex" id="Termindex"></a>  *<h3>Term Index</h3>  *<p>The .tip file contains an index into the term dictionary, so that it can be   * accessed randomly.  The index is also used to determine  * when a given term cannot exist on disk (in the .tim file), saving a disk seek.</p>  *<ul>  *<li>TermsIndex (.tip) --&gt; Header, FSTIndex<sup>NumFields</sup>  *&lt;IndexStartFP&gt;<sup>NumFields</sup>, DirOffset, Footer</li>  *<li>Header --&gt; {@link CodecUtil#writeHeader CodecHeader}</li>  *<li>DirOffset --&gt; {@link DataOutput#writeLong Uint64}</li>  *<li>IndexStartFP --&gt; {@link DataOutput#writeVLong VLong}</li>  *<!-- TODO: better describe FST output here -->  *<li>FSTIndex --&gt; {@link FST FST&lt;byte[]&gt;}</li>  *<li>Footer --&gt; {@link CodecUtil#writeFooter CodecFooter}</li>  *</ul>  *<p>Notes:</p>  *<ul>  *<li>The .tip file contains a separate FST for each  *       field.  The FST maps a term prefix to the on-disk  *       block that holds all terms starting with that  *       prefix.  Each field's IndexStartFP points to its  *       FST.</li>  *<li>DirOffset is a pointer to the start of the IndexStartFPs  *       for all fields</li>  *<li>It's possible that an on-disk block would contain  *       too many terms (more than the allowed maximum  *       (default: 48)).  When this happens, the block is  *       sub-divided into new blocks (called "floor  *       blocks"), and then the output in the FST for the  *       block's prefix encodes the leading byte of each  *       sub-block, and its file pointer.  *</ul>  *  * @see BlockTreeTermsReader  * @lucene.experimental  */
end_comment
begin_comment
comment|// nocommit fix jdocs
end_comment
begin_class
DECL|class|VersionBlockTreeTermsWriter
specifier|final
class|class
name|VersionBlockTreeTermsWriter
extends|extends
name|FieldsConsumer
block|{
DECL|field|FST_OUTPUTS
specifier|public
specifier|static
specifier|final
name|PairOutputs
argument_list|<
name|BytesRef
argument_list|,
name|Long
argument_list|>
name|FST_OUTPUTS
init|=
operator|new
name|PairOutputs
argument_list|<>
argument_list|(
name|ByteSequenceOutputs
operator|.
name|getSingleton
argument_list|()
argument_list|,
name|PositiveIntOutputs
operator|.
name|getSingleton
argument_list|()
argument_list|)
decl_stmt|;
DECL|field|NO_OUTPUT
specifier|public
specifier|static
specifier|final
name|Pair
argument_list|<
name|BytesRef
argument_list|,
name|Long
argument_list|>
name|NO_OUTPUT
init|=
name|FST_OUTPUTS
operator|.
name|getNoOutput
argument_list|()
decl_stmt|;
comment|/** Suggested default value for the {@code    *  minItemsInBlock} parameter to {@link    *  #BlockTreeTermsWriter(SegmentWriteState,PostingsWriterBase,int,int)}. */
DECL|field|DEFAULT_MIN_BLOCK_SIZE
specifier|public
specifier|final
specifier|static
name|int
name|DEFAULT_MIN_BLOCK_SIZE
init|=
literal|25
decl_stmt|;
comment|/** Suggested default value for the {@code    *  maxItemsInBlock} parameter to {@link    *  #BlockTreeTermsWriter(SegmentWriteState,PostingsWriterBase,int,int)}. */
DECL|field|DEFAULT_MAX_BLOCK_SIZE
specifier|public
specifier|final
specifier|static
name|int
name|DEFAULT_MAX_BLOCK_SIZE
init|=
literal|48
decl_stmt|;
comment|//public final static boolean DEBUG = false;
comment|//private final static boolean SAVE_DOT_FILES = false;
DECL|field|OUTPUT_FLAGS_NUM_BITS
specifier|static
specifier|final
name|int
name|OUTPUT_FLAGS_NUM_BITS
init|=
literal|2
decl_stmt|;
DECL|field|OUTPUT_FLAGS_MASK
specifier|static
specifier|final
name|int
name|OUTPUT_FLAGS_MASK
init|=
literal|0x3
decl_stmt|;
DECL|field|OUTPUT_FLAG_IS_FLOOR
specifier|static
specifier|final
name|int
name|OUTPUT_FLAG_IS_FLOOR
init|=
literal|0x1
decl_stmt|;
DECL|field|OUTPUT_FLAG_HAS_TERMS
specifier|static
specifier|final
name|int
name|OUTPUT_FLAG_HAS_TERMS
init|=
literal|0x2
decl_stmt|;
comment|/** Extension of terms file */
DECL|field|TERMS_EXTENSION
specifier|static
specifier|final
name|String
name|TERMS_EXTENSION
init|=
literal|"tiv"
decl_stmt|;
DECL|field|TERMS_CODEC_NAME
specifier|final
specifier|static
name|String
name|TERMS_CODEC_NAME
init|=
literal|"VERSION_BLOCK_TREE_TERMS_DICT"
decl_stmt|;
comment|/** Initial terms format. */
DECL|field|VERSION_START
specifier|public
specifier|static
specifier|final
name|int
name|VERSION_START
init|=
literal|0
decl_stmt|;
comment|// nocommit nuke all these old versions
comment|/** Append-only */
DECL|field|VERSION_APPEND_ONLY
specifier|public
specifier|static
specifier|final
name|int
name|VERSION_APPEND_ONLY
init|=
literal|1
decl_stmt|;
comment|/** Meta data as array */
DECL|field|VERSION_META_ARRAY
specifier|public
specifier|static
specifier|final
name|int
name|VERSION_META_ARRAY
init|=
literal|2
decl_stmt|;
comment|/** checksums */
DECL|field|VERSION_CHECKSUM
specifier|public
specifier|static
specifier|final
name|int
name|VERSION_CHECKSUM
init|=
literal|3
decl_stmt|;
comment|/** min/max term */
DECL|field|VERSION_MIN_MAX_TERMS
specifier|public
specifier|static
specifier|final
name|int
name|VERSION_MIN_MAX_TERMS
init|=
literal|4
decl_stmt|;
comment|/** Current terms format. */
DECL|field|VERSION_CURRENT
specifier|public
specifier|static
specifier|final
name|int
name|VERSION_CURRENT
init|=
name|VERSION_MIN_MAX_TERMS
decl_stmt|;
comment|/** Extension of terms index file */
DECL|field|TERMS_INDEX_EXTENSION
specifier|static
specifier|final
name|String
name|TERMS_INDEX_EXTENSION
init|=
literal|"tip"
decl_stmt|;
DECL|field|TERMS_INDEX_CODEC_NAME
specifier|final
specifier|static
name|String
name|TERMS_INDEX_CODEC_NAME
init|=
literal|"VERSION_BLOCK_TREE_TERMS_INDEX"
decl_stmt|;
DECL|field|out
specifier|private
specifier|final
name|IndexOutput
name|out
decl_stmt|;
DECL|field|indexOut
specifier|private
specifier|final
name|IndexOutput
name|indexOut
decl_stmt|;
DECL|field|maxDoc
specifier|final
name|int
name|maxDoc
decl_stmt|;
DECL|field|minItemsInBlock
specifier|final
name|int
name|minItemsInBlock
decl_stmt|;
DECL|field|maxItemsInBlock
specifier|final
name|int
name|maxItemsInBlock
decl_stmt|;
DECL|field|postingsWriter
specifier|final
name|PostingsWriterBase
name|postingsWriter
decl_stmt|;
DECL|field|fieldInfos
specifier|final
name|FieldInfos
name|fieldInfos
decl_stmt|;
DECL|class|FieldMetaData
specifier|private
specifier|static
class|class
name|FieldMetaData
block|{
DECL|field|fieldInfo
specifier|public
specifier|final
name|FieldInfo
name|fieldInfo
decl_stmt|;
DECL|field|rootCode
specifier|public
specifier|final
name|Pair
argument_list|<
name|BytesRef
argument_list|,
name|Long
argument_list|>
name|rootCode
decl_stmt|;
DECL|field|numTerms
specifier|public
specifier|final
name|long
name|numTerms
decl_stmt|;
DECL|field|indexStartFP
specifier|public
specifier|final
name|long
name|indexStartFP
decl_stmt|;
DECL|field|sumTotalTermFreq
specifier|public
specifier|final
name|long
name|sumTotalTermFreq
decl_stmt|;
DECL|field|sumDocFreq
specifier|public
specifier|final
name|long
name|sumDocFreq
decl_stmt|;
DECL|field|docCount
specifier|public
specifier|final
name|int
name|docCount
decl_stmt|;
DECL|field|longsSize
specifier|private
specifier|final
name|int
name|longsSize
decl_stmt|;
DECL|field|minTerm
specifier|public
specifier|final
name|BytesRef
name|minTerm
decl_stmt|;
DECL|field|maxTerm
specifier|public
specifier|final
name|BytesRef
name|maxTerm
decl_stmt|;
DECL|method|FieldMetaData
specifier|public
name|FieldMetaData
parameter_list|(
name|FieldInfo
name|fieldInfo
parameter_list|,
name|Pair
argument_list|<
name|BytesRef
argument_list|,
name|Long
argument_list|>
name|rootCode
parameter_list|,
name|long
name|numTerms
parameter_list|,
name|long
name|indexStartFP
parameter_list|,
name|long
name|sumTotalTermFreq
parameter_list|,
name|long
name|sumDocFreq
parameter_list|,
name|int
name|docCount
parameter_list|,
name|int
name|longsSize
parameter_list|,
name|BytesRef
name|minTerm
parameter_list|,
name|BytesRef
name|maxTerm
parameter_list|)
block|{
assert|assert
name|numTerms
operator|>
literal|0
assert|;
name|this
operator|.
name|fieldInfo
operator|=
name|fieldInfo
expr_stmt|;
assert|assert
name|rootCode
operator|!=
literal|null
operator|:
literal|"field="
operator|+
name|fieldInfo
operator|.
name|name
operator|+
literal|" numTerms="
operator|+
name|numTerms
assert|;
name|this
operator|.
name|rootCode
operator|=
name|rootCode
expr_stmt|;
name|this
operator|.
name|indexStartFP
operator|=
name|indexStartFP
expr_stmt|;
name|this
operator|.
name|numTerms
operator|=
name|numTerms
expr_stmt|;
name|this
operator|.
name|sumTotalTermFreq
operator|=
name|sumTotalTermFreq
expr_stmt|;
name|this
operator|.
name|sumDocFreq
operator|=
name|sumDocFreq
expr_stmt|;
name|this
operator|.
name|docCount
operator|=
name|docCount
expr_stmt|;
name|this
operator|.
name|longsSize
operator|=
name|longsSize
expr_stmt|;
name|this
operator|.
name|minTerm
operator|=
name|minTerm
expr_stmt|;
name|this
operator|.
name|maxTerm
operator|=
name|maxTerm
expr_stmt|;
block|}
block|}
DECL|field|fields
specifier|private
specifier|final
name|List
argument_list|<
name|FieldMetaData
argument_list|>
name|fields
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
comment|// private final String segment;
comment|/** Create a new writer.  The number of items (terms or    *  sub-blocks) per block will aim to be between    *  minItemsPerBlock and maxItemsPerBlock, though in some    *  cases the blocks may be smaller than the min. */
DECL|method|VersionBlockTreeTermsWriter
specifier|public
name|VersionBlockTreeTermsWriter
parameter_list|(
name|SegmentWriteState
name|state
parameter_list|,
name|PostingsWriterBase
name|postingsWriter
parameter_list|,
name|int
name|minItemsInBlock
parameter_list|,
name|int
name|maxItemsInBlock
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|minItemsInBlock
operator|<=
literal|1
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"minItemsInBlock must be>= 2; got "
operator|+
name|minItemsInBlock
argument_list|)
throw|;
block|}
if|if
condition|(
name|maxItemsInBlock
operator|<=
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"maxItemsInBlock must be>= 1; got "
operator|+
name|maxItemsInBlock
argument_list|)
throw|;
block|}
if|if
condition|(
name|minItemsInBlock
operator|>
name|maxItemsInBlock
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"maxItemsInBlock must be>= minItemsInBlock; got maxItemsInBlock="
operator|+
name|maxItemsInBlock
operator|+
literal|" minItemsInBlock="
operator|+
name|minItemsInBlock
argument_list|)
throw|;
block|}
if|if
condition|(
literal|2
operator|*
operator|(
name|minItemsInBlock
operator|-
literal|1
operator|)
operator|>
name|maxItemsInBlock
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"maxItemsInBlock must be at least 2*(minItemsInBlock-1); got maxItemsInBlock="
operator|+
name|maxItemsInBlock
operator|+
literal|" minItemsInBlock="
operator|+
name|minItemsInBlock
argument_list|)
throw|;
block|}
name|maxDoc
operator|=
name|state
operator|.
name|segmentInfo
operator|.
name|getDocCount
argument_list|()
expr_stmt|;
specifier|final
name|String
name|termsFileName
init|=
name|IndexFileNames
operator|.
name|segmentFileName
argument_list|(
name|state
operator|.
name|segmentInfo
operator|.
name|name
argument_list|,
name|state
operator|.
name|segmentSuffix
argument_list|,
name|TERMS_EXTENSION
argument_list|)
decl_stmt|;
name|out
operator|=
name|state
operator|.
name|directory
operator|.
name|createOutput
argument_list|(
name|termsFileName
argument_list|,
name|state
operator|.
name|context
argument_list|)
expr_stmt|;
name|boolean
name|success
init|=
literal|false
decl_stmt|;
name|IndexOutput
name|indexOut
init|=
literal|null
decl_stmt|;
try|try
block|{
name|fieldInfos
operator|=
name|state
operator|.
name|fieldInfos
expr_stmt|;
name|this
operator|.
name|minItemsInBlock
operator|=
name|minItemsInBlock
expr_stmt|;
name|this
operator|.
name|maxItemsInBlock
operator|=
name|maxItemsInBlock
expr_stmt|;
name|writeHeader
argument_list|(
name|out
argument_list|)
expr_stmt|;
comment|//DEBUG = state.segmentName.equals("_4a");
specifier|final
name|String
name|termsIndexFileName
init|=
name|IndexFileNames
operator|.
name|segmentFileName
argument_list|(
name|state
operator|.
name|segmentInfo
operator|.
name|name
argument_list|,
name|state
operator|.
name|segmentSuffix
argument_list|,
name|TERMS_INDEX_EXTENSION
argument_list|)
decl_stmt|;
name|indexOut
operator|=
name|state
operator|.
name|directory
operator|.
name|createOutput
argument_list|(
name|termsIndexFileName
argument_list|,
name|state
operator|.
name|context
argument_list|)
expr_stmt|;
name|writeIndexHeader
argument_list|(
name|indexOut
argument_list|)
expr_stmt|;
name|this
operator|.
name|postingsWriter
operator|=
name|postingsWriter
expr_stmt|;
comment|// segment = state.segmentName;
comment|// System.out.println("BTW.init seg=" + state.segmentName);
name|postingsWriter
operator|.
name|init
argument_list|(
name|out
argument_list|)
expr_stmt|;
comment|// have consumer write its format/header
name|success
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
operator|!
name|success
condition|)
block|{
name|IOUtils
operator|.
name|closeWhileHandlingException
argument_list|(
name|out
argument_list|,
name|indexOut
argument_list|)
expr_stmt|;
block|}
block|}
name|this
operator|.
name|indexOut
operator|=
name|indexOut
expr_stmt|;
block|}
comment|/** Writes the terms file header. */
DECL|method|writeHeader
specifier|private
name|void
name|writeHeader
parameter_list|(
name|IndexOutput
name|out
parameter_list|)
throws|throws
name|IOException
block|{
name|CodecUtil
operator|.
name|writeHeader
argument_list|(
name|out
argument_list|,
name|TERMS_CODEC_NAME
argument_list|,
name|VERSION_CURRENT
argument_list|)
expr_stmt|;
block|}
comment|/** Writes the index file header. */
DECL|method|writeIndexHeader
specifier|private
name|void
name|writeIndexHeader
parameter_list|(
name|IndexOutput
name|out
parameter_list|)
throws|throws
name|IOException
block|{
name|CodecUtil
operator|.
name|writeHeader
argument_list|(
name|out
argument_list|,
name|TERMS_INDEX_CODEC_NAME
argument_list|,
name|VERSION_CURRENT
argument_list|)
expr_stmt|;
block|}
comment|/** Writes the terms file trailer. */
DECL|method|writeTrailer
specifier|private
name|void
name|writeTrailer
parameter_list|(
name|IndexOutput
name|out
parameter_list|,
name|long
name|dirStart
parameter_list|)
throws|throws
name|IOException
block|{
name|out
operator|.
name|writeLong
argument_list|(
name|dirStart
argument_list|)
expr_stmt|;
block|}
comment|/** Writes the index file trailer. */
DECL|method|writeIndexTrailer
specifier|private
name|void
name|writeIndexTrailer
parameter_list|(
name|IndexOutput
name|indexOut
parameter_list|,
name|long
name|dirStart
parameter_list|)
throws|throws
name|IOException
block|{
name|indexOut
operator|.
name|writeLong
argument_list|(
name|dirStart
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|write
specifier|public
name|void
name|write
parameter_list|(
name|Fields
name|fields
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|lastField
init|=
literal|null
decl_stmt|;
for|for
control|(
name|String
name|field
range|:
name|fields
control|)
block|{
assert|assert
name|lastField
operator|==
literal|null
operator|||
name|lastField
operator|.
name|compareTo
argument_list|(
name|field
argument_list|)
operator|<
literal|0
assert|;
name|lastField
operator|=
name|field
expr_stmt|;
name|Terms
name|terms
init|=
name|fields
operator|.
name|terms
argument_list|(
name|field
argument_list|)
decl_stmt|;
if|if
condition|(
name|terms
operator|==
literal|null
condition|)
block|{
continue|continue;
block|}
name|TermsEnum
name|termsEnum
init|=
name|terms
operator|.
name|iterator
argument_list|(
literal|null
argument_list|)
decl_stmt|;
name|TermsWriter
name|termsWriter
init|=
operator|new
name|TermsWriter
argument_list|(
name|fieldInfos
operator|.
name|fieldInfo
argument_list|(
name|field
argument_list|)
argument_list|)
decl_stmt|;
name|BytesRef
name|minTerm
init|=
literal|null
decl_stmt|;
name|BytesRef
name|maxTerm
init|=
operator|new
name|BytesRef
argument_list|()
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|BytesRef
name|term
init|=
name|termsEnum
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|term
operator|==
literal|null
condition|)
block|{
break|break;
block|}
if|if
condition|(
name|minTerm
operator|==
literal|null
condition|)
block|{
name|minTerm
operator|=
name|BytesRef
operator|.
name|deepCopyOf
argument_list|(
name|term
argument_list|)
expr_stmt|;
block|}
name|maxTerm
operator|.
name|copyBytes
argument_list|(
name|term
argument_list|)
expr_stmt|;
name|termsWriter
operator|.
name|write
argument_list|(
name|term
argument_list|,
name|termsEnum
argument_list|)
expr_stmt|;
block|}
name|termsWriter
operator|.
name|finish
argument_list|(
name|minTerm
argument_list|,
name|minTerm
operator|==
literal|null
condition|?
literal|null
else|:
name|maxTerm
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|encodeOutput
specifier|static
name|long
name|encodeOutput
parameter_list|(
name|long
name|fp
parameter_list|,
name|boolean
name|hasTerms
parameter_list|,
name|boolean
name|isFloor
parameter_list|)
block|{
assert|assert
name|fp
operator|<
operator|(
literal|1L
operator|<<
literal|62
operator|)
assert|;
return|return
operator|(
name|fp
operator|<<
literal|2
operator|)
operator||
operator|(
name|hasTerms
condition|?
name|OUTPUT_FLAG_HAS_TERMS
else|:
literal|0
operator|)
operator||
operator|(
name|isFloor
condition|?
name|OUTPUT_FLAG_IS_FLOOR
else|:
literal|0
operator|)
return|;
block|}
DECL|class|PendingEntry
specifier|private
specifier|static
class|class
name|PendingEntry
block|{
DECL|field|isTerm
specifier|public
specifier|final
name|boolean
name|isTerm
decl_stmt|;
DECL|method|PendingEntry
specifier|protected
name|PendingEntry
parameter_list|(
name|boolean
name|isTerm
parameter_list|)
block|{
name|this
operator|.
name|isTerm
operator|=
name|isTerm
expr_stmt|;
block|}
block|}
DECL|class|PendingTerm
specifier|private
specifier|static
specifier|final
class|class
name|PendingTerm
extends|extends
name|PendingEntry
block|{
DECL|field|term
specifier|public
specifier|final
name|BytesRef
name|term
decl_stmt|;
comment|// stats + metadata
DECL|field|state
specifier|public
specifier|final
name|BlockTermState
name|state
decl_stmt|;
DECL|method|PendingTerm
specifier|public
name|PendingTerm
parameter_list|(
name|BytesRef
name|term
parameter_list|,
name|BlockTermState
name|state
parameter_list|)
block|{
name|super
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|this
operator|.
name|term
operator|=
name|term
expr_stmt|;
name|this
operator|.
name|state
operator|=
name|state
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|term
operator|.
name|utf8ToString
argument_list|()
return|;
block|}
block|}
DECL|class|PendingBlock
specifier|private
specifier|static
specifier|final
class|class
name|PendingBlock
extends|extends
name|PendingEntry
block|{
DECL|field|prefix
specifier|public
specifier|final
name|BytesRef
name|prefix
decl_stmt|;
DECL|field|fp
specifier|public
specifier|final
name|long
name|fp
decl_stmt|;
DECL|field|index
specifier|public
name|FST
argument_list|<
name|Pair
argument_list|<
name|BytesRef
argument_list|,
name|Long
argument_list|>
argument_list|>
name|index
decl_stmt|;
DECL|field|subIndices
specifier|public
name|List
argument_list|<
name|FST
argument_list|<
name|Pair
argument_list|<
name|BytesRef
argument_list|,
name|Long
argument_list|>
argument_list|>
argument_list|>
name|subIndices
decl_stmt|;
DECL|field|hasTerms
specifier|public
specifier|final
name|boolean
name|hasTerms
decl_stmt|;
DECL|field|isFloor
specifier|public
specifier|final
name|boolean
name|isFloor
decl_stmt|;
DECL|field|floorLeadByte
specifier|public
specifier|final
name|int
name|floorLeadByte
decl_stmt|;
DECL|field|scratchIntsRef
specifier|private
specifier|final
name|IntsRef
name|scratchIntsRef
init|=
operator|new
name|IntsRef
argument_list|()
decl_stmt|;
comment|/** Max version for all terms in this block. */
DECL|field|maxVersion
specifier|private
specifier|final
name|long
name|maxVersion
decl_stmt|;
DECL|method|PendingBlock
specifier|public
name|PendingBlock
parameter_list|(
name|BytesRef
name|prefix
parameter_list|,
name|long
name|maxVersion
parameter_list|,
name|long
name|fp
parameter_list|,
name|boolean
name|hasTerms
parameter_list|,
name|boolean
name|isFloor
parameter_list|,
name|int
name|floorLeadByte
parameter_list|,
name|List
argument_list|<
name|FST
argument_list|<
name|Pair
argument_list|<
name|BytesRef
argument_list|,
name|Long
argument_list|>
argument_list|>
argument_list|>
name|subIndices
parameter_list|)
block|{
name|super
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|this
operator|.
name|prefix
operator|=
name|prefix
expr_stmt|;
name|this
operator|.
name|maxVersion
operator|=
name|maxVersion
expr_stmt|;
name|this
operator|.
name|fp
operator|=
name|fp
expr_stmt|;
name|this
operator|.
name|hasTerms
operator|=
name|hasTerms
expr_stmt|;
name|this
operator|.
name|isFloor
operator|=
name|isFloor
expr_stmt|;
name|this
operator|.
name|floorLeadByte
operator|=
name|floorLeadByte
expr_stmt|;
name|this
operator|.
name|subIndices
operator|=
name|subIndices
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"BLOCK: "
operator|+
name|prefix
operator|.
name|utf8ToString
argument_list|()
return|;
block|}
DECL|method|compileIndex
specifier|public
name|void
name|compileIndex
parameter_list|(
name|List
argument_list|<
name|PendingBlock
argument_list|>
name|floorBlocks
parameter_list|,
name|RAMOutputStream
name|scratchBytes
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
operator|(
name|isFloor
operator|&&
name|floorBlocks
operator|!=
literal|null
operator|&&
name|floorBlocks
operator|.
name|size
argument_list|()
operator|!=
literal|0
operator|)
operator|||
operator|(
operator|!
name|isFloor
operator|&&
name|floorBlocks
operator|==
literal|null
operator|)
operator|:
literal|"isFloor="
operator|+
name|isFloor
operator|+
literal|" floorBlocks="
operator|+
name|floorBlocks
assert|;
assert|assert
name|scratchBytes
operator|.
name|getFilePointer
argument_list|()
operator|==
literal|0
assert|;
name|long
name|maxVersionIndex
init|=
name|maxVersion
decl_stmt|;
comment|// TODO: try writing the leading vLong in MSB order
comment|// (opposite of what Lucene does today), for better
comment|// outputs sharing in the FST
name|scratchBytes
operator|.
name|writeVLong
argument_list|(
name|encodeOutput
argument_list|(
name|fp
argument_list|,
name|hasTerms
argument_list|,
name|isFloor
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|isFloor
condition|)
block|{
name|scratchBytes
operator|.
name|writeVInt
argument_list|(
name|floorBlocks
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|PendingBlock
name|sub
range|:
name|floorBlocks
control|)
block|{
assert|assert
name|sub
operator|.
name|floorLeadByte
operator|!=
operator|-
literal|1
assert|;
name|maxVersionIndex
operator|=
name|Math
operator|.
name|max
argument_list|(
name|maxVersionIndex
argument_list|,
name|sub
operator|.
name|maxVersion
argument_list|)
expr_stmt|;
comment|//if (DEBUG) {
comment|//  System.out.println("    write floorLeadByte=" + Integer.toHexString(sub.floorLeadByte&0xff));
comment|//}
name|scratchBytes
operator|.
name|writeByte
argument_list|(
operator|(
name|byte
operator|)
name|sub
operator|.
name|floorLeadByte
argument_list|)
expr_stmt|;
assert|assert
name|sub
operator|.
name|fp
operator|>
name|fp
assert|;
name|scratchBytes
operator|.
name|writeVLong
argument_list|(
operator|(
name|sub
operator|.
name|fp
operator|-
name|fp
operator|)
operator|<<
literal|1
operator||
operator|(
name|sub
operator|.
name|hasTerms
condition|?
literal|1
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
specifier|final
name|Builder
argument_list|<
name|Pair
argument_list|<
name|BytesRef
argument_list|,
name|Long
argument_list|>
argument_list|>
name|indexBuilder
init|=
operator|new
name|Builder
argument_list|<>
argument_list|(
name|FST
operator|.
name|INPUT_TYPE
operator|.
name|BYTE1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|true
argument_list|,
literal|false
argument_list|,
name|Integer
operator|.
name|MAX_VALUE
argument_list|,
name|FST_OUTPUTS
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|,
name|PackedInts
operator|.
name|COMPACT
argument_list|,
literal|true
argument_list|,
literal|15
argument_list|)
decl_stmt|;
comment|//if (DEBUG) {
comment|//  System.out.println("  compile index for prefix=" + prefix);
comment|//}
comment|//indexBuilder.DEBUG = false;
specifier|final
name|byte
index|[]
name|bytes
init|=
operator|new
name|byte
index|[
operator|(
name|int
operator|)
name|scratchBytes
operator|.
name|getFilePointer
argument_list|()
index|]
decl_stmt|;
assert|assert
name|bytes
operator|.
name|length
operator|>
literal|0
assert|;
name|scratchBytes
operator|.
name|writeTo
argument_list|(
name|bytes
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|indexBuilder
operator|.
name|add
argument_list|(
name|Util
operator|.
name|toIntsRef
argument_list|(
name|prefix
argument_list|,
name|scratchIntsRef
argument_list|)
argument_list|,
name|FST_OUTPUTS
operator|.
name|newPair
argument_list|(
operator|new
name|BytesRef
argument_list|(
name|bytes
argument_list|,
literal|0
argument_list|,
name|bytes
operator|.
name|length
argument_list|)
argument_list|,
name|Long
operator|.
name|MAX_VALUE
operator|-
name|maxVersionIndex
argument_list|)
argument_list|)
expr_stmt|;
name|scratchBytes
operator|.
name|reset
argument_list|()
expr_stmt|;
comment|// Copy over index for all sub-blocks
if|if
condition|(
name|subIndices
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|FST
argument_list|<
name|Pair
argument_list|<
name|BytesRef
argument_list|,
name|Long
argument_list|>
argument_list|>
name|subIndex
range|:
name|subIndices
control|)
block|{
name|append
argument_list|(
name|indexBuilder
argument_list|,
name|subIndex
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|floorBlocks
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|PendingBlock
name|sub
range|:
name|floorBlocks
control|)
block|{
if|if
condition|(
name|sub
operator|.
name|subIndices
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|FST
argument_list|<
name|Pair
argument_list|<
name|BytesRef
argument_list|,
name|Long
argument_list|>
argument_list|>
name|subIndex
range|:
name|sub
operator|.
name|subIndices
control|)
block|{
name|append
argument_list|(
name|indexBuilder
argument_list|,
name|subIndex
argument_list|)
expr_stmt|;
block|}
block|}
name|sub
operator|.
name|subIndices
operator|=
literal|null
expr_stmt|;
block|}
block|}
name|index
operator|=
name|indexBuilder
operator|.
name|finish
argument_list|()
expr_stmt|;
name|subIndices
operator|=
literal|null
expr_stmt|;
comment|/*       Writer w = new OutputStreamWriter(new FileOutputStream("out.dot"));       Util.toDot(index, w, false, false);       System.out.println("SAVED to out.dot");       w.close();       */
block|}
comment|// TODO: maybe we could add bulk-add method to
comment|// Builder?  Takes FST and unions it w/ current
comment|// FST.
DECL|method|append
specifier|private
name|void
name|append
parameter_list|(
name|Builder
argument_list|<
name|Pair
argument_list|<
name|BytesRef
argument_list|,
name|Long
argument_list|>
argument_list|>
name|builder
parameter_list|,
name|FST
argument_list|<
name|Pair
argument_list|<
name|BytesRef
argument_list|,
name|Long
argument_list|>
argument_list|>
name|subIndex
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|BytesRefFSTEnum
argument_list|<
name|Pair
argument_list|<
name|BytesRef
argument_list|,
name|Long
argument_list|>
argument_list|>
name|subIndexEnum
init|=
operator|new
name|BytesRefFSTEnum
argument_list|<>
argument_list|(
name|subIndex
argument_list|)
decl_stmt|;
name|BytesRefFSTEnum
operator|.
name|InputOutput
argument_list|<
name|Pair
argument_list|<
name|BytesRef
argument_list|,
name|Long
argument_list|>
argument_list|>
name|indexEnt
decl_stmt|;
while|while
condition|(
operator|(
name|indexEnt
operator|=
name|subIndexEnum
operator|.
name|next
argument_list|()
operator|)
operator|!=
literal|null
condition|)
block|{
comment|//if (DEBUG) {
comment|//  System.out.println("      add sub=" + indexEnt.input + " " + indexEnt.input + " output=" + indexEnt.output);
comment|//}
name|builder
operator|.
name|add
argument_list|(
name|Util
operator|.
name|toIntsRef
argument_list|(
name|indexEnt
operator|.
name|input
argument_list|,
name|scratchIntsRef
argument_list|)
argument_list|,
name|indexEnt
operator|.
name|output
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|field|scratchBytes
specifier|final
name|RAMOutputStream
name|scratchBytes
init|=
operator|new
name|RAMOutputStream
argument_list|()
decl_stmt|;
DECL|class|TermsWriter
class|class
name|TermsWriter
block|{
DECL|field|fieldInfo
specifier|private
specifier|final
name|FieldInfo
name|fieldInfo
decl_stmt|;
DECL|field|longsSize
specifier|private
specifier|final
name|int
name|longsSize
decl_stmt|;
DECL|field|numTerms
specifier|private
name|long
name|numTerms
decl_stmt|;
DECL|field|docsSeen
specifier|final
name|FixedBitSet
name|docsSeen
decl_stmt|;
DECL|field|sumTotalTermFreq
name|long
name|sumTotalTermFreq
decl_stmt|;
DECL|field|sumDocFreq
name|long
name|sumDocFreq
decl_stmt|;
DECL|field|indexStartFP
name|long
name|indexStartFP
decl_stmt|;
comment|// Used only to partition terms into the block tree; we
comment|// don't pull an FST from this builder:
DECL|field|noOutputs
specifier|private
specifier|final
name|NoOutputs
name|noOutputs
decl_stmt|;
DECL|field|blockBuilder
specifier|private
specifier|final
name|Builder
argument_list|<
name|Object
argument_list|>
name|blockBuilder
decl_stmt|;
comment|// PendingTerm or PendingBlock:
DECL|field|pending
specifier|private
specifier|final
name|List
argument_list|<
name|PendingEntry
argument_list|>
name|pending
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
comment|// Index into pending of most recently written block
DECL|field|lastBlockIndex
specifier|private
name|int
name|lastBlockIndex
init|=
operator|-
literal|1
decl_stmt|;
comment|// Re-used when segmenting a too-large block into floor
comment|// blocks:
DECL|field|subBytes
specifier|private
name|int
index|[]
name|subBytes
init|=
operator|new
name|int
index|[
literal|10
index|]
decl_stmt|;
DECL|field|subTermCounts
specifier|private
name|int
index|[]
name|subTermCounts
init|=
operator|new
name|int
index|[
literal|10
index|]
decl_stmt|;
DECL|field|subTermCountSums
specifier|private
name|int
index|[]
name|subTermCountSums
init|=
operator|new
name|int
index|[
literal|10
index|]
decl_stmt|;
DECL|field|subSubCounts
specifier|private
name|int
index|[]
name|subSubCounts
init|=
operator|new
name|int
index|[
literal|10
index|]
decl_stmt|;
comment|// This class assigns terms to blocks "naturally", ie,
comment|// according to the number of terms under a given prefix
comment|// that we encounter:
DECL|class|FindBlocks
specifier|private
class|class
name|FindBlocks
extends|extends
name|Builder
operator|.
name|FreezeTail
argument_list|<
name|Object
argument_list|>
block|{
annotation|@
name|Override
DECL|method|freeze
specifier|public
name|void
name|freeze
parameter_list|(
specifier|final
name|Builder
operator|.
name|UnCompiledNode
argument_list|<
name|Object
argument_list|>
index|[]
name|frontier
parameter_list|,
name|int
name|prefixLenPlus1
parameter_list|,
specifier|final
name|IntsRef
name|lastInput
parameter_list|)
throws|throws
name|IOException
block|{
comment|//if (DEBUG) System.out.println("  freeze prefixLenPlus1=" + prefixLenPlus1);
for|for
control|(
name|int
name|idx
init|=
name|lastInput
operator|.
name|length
init|;
name|idx
operator|>=
name|prefixLenPlus1
condition|;
name|idx
operator|--
control|)
block|{
specifier|final
name|Builder
operator|.
name|UnCompiledNode
argument_list|<
name|Object
argument_list|>
name|node
init|=
name|frontier
index|[
name|idx
index|]
decl_stmt|;
name|long
name|totCount
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|node
operator|.
name|isFinal
condition|)
block|{
name|totCount
operator|++
expr_stmt|;
block|}
for|for
control|(
name|int
name|arcIdx
init|=
literal|0
init|;
name|arcIdx
operator|<
name|node
operator|.
name|numArcs
condition|;
name|arcIdx
operator|++
control|)
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|final
name|Builder
operator|.
name|UnCompiledNode
argument_list|<
name|Object
argument_list|>
name|target
init|=
operator|(
name|Builder
operator|.
name|UnCompiledNode
argument_list|<
name|Object
argument_list|>
operator|)
name|node
operator|.
name|arcs
index|[
name|arcIdx
index|]
operator|.
name|target
decl_stmt|;
name|totCount
operator|+=
name|target
operator|.
name|inputCount
expr_stmt|;
name|target
operator|.
name|clear
argument_list|()
expr_stmt|;
name|node
operator|.
name|arcs
index|[
name|arcIdx
index|]
operator|.
name|target
operator|=
literal|null
expr_stmt|;
block|}
name|node
operator|.
name|numArcs
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|totCount
operator|>=
name|minItemsInBlock
operator|||
name|idx
operator|==
literal|0
condition|)
block|{
comment|// We are on a prefix node that has enough
comment|// entries (terms or sub-blocks) under it to let
comment|// us write a new block or multiple blocks (main
comment|// block + follow on floor blocks):
comment|//if (DEBUG) {
comment|//  if (totCount< minItemsInBlock&& idx != 0) {
comment|//    System.out.println("  force block has terms");
comment|//  }
comment|//}
name|writeBlocks
argument_list|(
name|lastInput
argument_list|,
name|idx
argument_list|,
operator|(
name|int
operator|)
name|totCount
argument_list|)
expr_stmt|;
name|node
operator|.
name|inputCount
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|// stragglers!  carry count upwards
name|node
operator|.
name|inputCount
operator|=
name|totCount
expr_stmt|;
block|}
name|frontier
index|[
name|idx
index|]
operator|=
operator|new
name|Builder
operator|.
name|UnCompiledNode
argument_list|<>
argument_list|(
name|blockBuilder
argument_list|,
name|idx
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// Write the top count entries on the pending stack as
comment|// one or more blocks.  Returns how many blocks were
comment|// written.  If the entry count is<= maxItemsPerBlock
comment|// we just write a single block; else we break into
comment|// primary (initial) block and then one or more
comment|// following floor blocks:
DECL|method|writeBlocks
name|void
name|writeBlocks
parameter_list|(
name|IntsRef
name|prevTerm
parameter_list|,
name|int
name|prefixLength
parameter_list|,
name|int
name|count
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|prefixLength
operator|==
literal|0
operator|||
name|count
operator|<=
name|maxItemsInBlock
condition|)
block|{
comment|// Easy case: not floor block.  Eg, prefix is "foo",
comment|// and we found 30 terms/sub-blocks starting w/ that
comment|// prefix, and minItemsInBlock<= 30<=
comment|// maxItemsInBlock.
specifier|final
name|PendingBlock
name|nonFloorBlock
init|=
name|writeBlock
argument_list|(
name|prevTerm
argument_list|,
name|prefixLength
argument_list|,
name|prefixLength
argument_list|,
name|count
argument_list|,
name|count
argument_list|,
literal|0
argument_list|,
literal|false
argument_list|,
operator|-
literal|1
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|nonFloorBlock
operator|.
name|compileIndex
argument_list|(
literal|null
argument_list|,
name|scratchBytes
argument_list|)
expr_stmt|;
name|pending
operator|.
name|add
argument_list|(
name|nonFloorBlock
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Floor block case.  Eg, prefix is "foo" but we
comment|// have 100 terms/sub-blocks starting w/ that
comment|// prefix.  We segment the entries into a primary
comment|// block and following floor blocks using the first
comment|// label in the suffix to assign to floor blocks.
comment|// TODO: we could store min& max suffix start byte
comment|// in each block, to make floor blocks authoritative
comment|//if (DEBUG) {
comment|//  final BytesRef prefix = new BytesRef(prefixLength);
comment|//  for(int m=0;m<prefixLength;m++) {
comment|//    prefix.bytes[m] = (byte) prevTerm.ints[m];
comment|//  }
comment|//  prefix.length = prefixLength;
comment|//  //System.out.println("\nWBS count=" + count + " prefix=" + prefix.utf8ToString() + " " + prefix);
comment|//  System.out.println("writeBlocks: prefix=" + prefix + " " + prefix + " count=" + count + " pending.size()=" + pending.size());
comment|//}
comment|//System.out.println("\nwbs count=" + count);
specifier|final
name|int
name|savLabel
init|=
name|prevTerm
operator|.
name|ints
index|[
name|prevTerm
operator|.
name|offset
operator|+
name|prefixLength
index|]
decl_stmt|;
comment|// Count up how many items fall under
comment|// each unique label after the prefix.
comment|// TODO: this is wasteful since the builder had
comment|// already done this (partitioned these sub-terms
comment|// according to their leading prefix byte)
specifier|final
name|List
argument_list|<
name|PendingEntry
argument_list|>
name|slice
init|=
name|pending
operator|.
name|subList
argument_list|(
name|pending
operator|.
name|size
argument_list|()
operator|-
name|count
argument_list|,
name|pending
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|lastSuffixLeadLabel
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|termCount
init|=
literal|0
decl_stmt|;
name|int
name|subCount
init|=
literal|0
decl_stmt|;
name|int
name|numSubs
init|=
literal|0
decl_stmt|;
for|for
control|(
name|PendingEntry
name|ent
range|:
name|slice
control|)
block|{
comment|// First byte in the suffix of this term
specifier|final
name|int
name|suffixLeadLabel
decl_stmt|;
if|if
condition|(
name|ent
operator|.
name|isTerm
condition|)
block|{
name|PendingTerm
name|term
init|=
operator|(
name|PendingTerm
operator|)
name|ent
decl_stmt|;
if|if
condition|(
name|term
operator|.
name|term
operator|.
name|length
operator|==
name|prefixLength
condition|)
block|{
comment|// Suffix is 0, ie prefix 'foo' and term is
comment|// 'foo' so the term has empty string suffix
comment|// in this block
assert|assert
name|lastSuffixLeadLabel
operator|==
operator|-
literal|1
assert|;
assert|assert
name|numSubs
operator|==
literal|0
assert|;
name|suffixLeadLabel
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|suffixLeadLabel
operator|=
name|term
operator|.
name|term
operator|.
name|bytes
index|[
name|term
operator|.
name|term
operator|.
name|offset
operator|+
name|prefixLength
index|]
operator|&
literal|0xff
expr_stmt|;
block|}
block|}
else|else
block|{
name|PendingBlock
name|block
init|=
operator|(
name|PendingBlock
operator|)
name|ent
decl_stmt|;
assert|assert
name|block
operator|.
name|prefix
operator|.
name|length
operator|>
name|prefixLength
assert|;
name|suffixLeadLabel
operator|=
name|block
operator|.
name|prefix
operator|.
name|bytes
index|[
name|block
operator|.
name|prefix
operator|.
name|offset
operator|+
name|prefixLength
index|]
operator|&
literal|0xff
expr_stmt|;
block|}
if|if
condition|(
name|suffixLeadLabel
operator|!=
name|lastSuffixLeadLabel
operator|&&
operator|(
name|termCount
operator|+
name|subCount
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|subBytes
operator|.
name|length
operator|==
name|numSubs
condition|)
block|{
name|subBytes
operator|=
name|ArrayUtil
operator|.
name|grow
argument_list|(
name|subBytes
argument_list|)
expr_stmt|;
name|subTermCounts
operator|=
name|ArrayUtil
operator|.
name|grow
argument_list|(
name|subTermCounts
argument_list|)
expr_stmt|;
name|subSubCounts
operator|=
name|ArrayUtil
operator|.
name|grow
argument_list|(
name|subSubCounts
argument_list|)
expr_stmt|;
block|}
name|subBytes
index|[
name|numSubs
index|]
operator|=
name|lastSuffixLeadLabel
expr_stmt|;
name|lastSuffixLeadLabel
operator|=
name|suffixLeadLabel
expr_stmt|;
name|subTermCounts
index|[
name|numSubs
index|]
operator|=
name|termCount
expr_stmt|;
name|subSubCounts
index|[
name|numSubs
index|]
operator|=
name|subCount
expr_stmt|;
comment|/*             if (suffixLeadLabel == -1) {               System.out.println("  sub " + -1 + " termCount=" + termCount + " subCount=" + subCount);             } else {               System.out.println("  sub " + Integer.toHexString(suffixLeadLabel) + " termCount=" + termCount + " subCount=" + subCount);             }             */
name|termCount
operator|=
name|subCount
operator|=
literal|0
expr_stmt|;
name|numSubs
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|ent
operator|.
name|isTerm
condition|)
block|{
name|termCount
operator|++
expr_stmt|;
block|}
else|else
block|{
name|subCount
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|subBytes
operator|.
name|length
operator|==
name|numSubs
condition|)
block|{
name|subBytes
operator|=
name|ArrayUtil
operator|.
name|grow
argument_list|(
name|subBytes
argument_list|)
expr_stmt|;
name|subTermCounts
operator|=
name|ArrayUtil
operator|.
name|grow
argument_list|(
name|subTermCounts
argument_list|)
expr_stmt|;
name|subSubCounts
operator|=
name|ArrayUtil
operator|.
name|grow
argument_list|(
name|subSubCounts
argument_list|)
expr_stmt|;
block|}
name|subBytes
index|[
name|numSubs
index|]
operator|=
name|lastSuffixLeadLabel
expr_stmt|;
name|subTermCounts
index|[
name|numSubs
index|]
operator|=
name|termCount
expr_stmt|;
name|subSubCounts
index|[
name|numSubs
index|]
operator|=
name|subCount
expr_stmt|;
name|numSubs
operator|++
expr_stmt|;
comment|/*         if (lastSuffixLeadLabel == -1) {           System.out.println("  sub " + -1 + " termCount=" + termCount + " subCount=" + subCount);         } else {           System.out.println("  sub " + Integer.toHexString(lastSuffixLeadLabel) + " termCount=" + termCount + " subCount=" + subCount);         }         */
if|if
condition|(
name|subTermCountSums
operator|.
name|length
operator|<
name|numSubs
condition|)
block|{
name|subTermCountSums
operator|=
name|ArrayUtil
operator|.
name|grow
argument_list|(
name|subTermCountSums
argument_list|,
name|numSubs
argument_list|)
expr_stmt|;
block|}
comment|// Roll up (backwards) the termCounts; postings impl
comment|// needs this to know where to pull the term slice
comment|// from its pending terms stack:
name|int
name|sum
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|idx
init|=
name|numSubs
operator|-
literal|1
init|;
name|idx
operator|>=
literal|0
condition|;
name|idx
operator|--
control|)
block|{
name|sum
operator|+=
name|subTermCounts
index|[
name|idx
index|]
expr_stmt|;
name|subTermCountSums
index|[
name|idx
index|]
operator|=
name|sum
expr_stmt|;
block|}
comment|// TODO: make a better segmenter?  It'd have to
comment|// absorb the too-small end blocks backwards into
comment|// the previous blocks
comment|// Naive greedy segmentation; this is not always
comment|// best (it can produce a too-small block as the
comment|// last block):
name|int
name|pendingCount
init|=
literal|0
decl_stmt|;
name|int
name|startLabel
init|=
name|subBytes
index|[
literal|0
index|]
decl_stmt|;
name|int
name|curStart
init|=
name|count
decl_stmt|;
name|subCount
operator|=
literal|0
expr_stmt|;
specifier|final
name|List
argument_list|<
name|PendingBlock
argument_list|>
name|floorBlocks
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|PendingBlock
name|firstBlock
init|=
literal|null
decl_stmt|;
for|for
control|(
name|int
name|sub
init|=
literal|0
init|;
name|sub
operator|<
name|numSubs
condition|;
name|sub
operator|++
control|)
block|{
name|pendingCount
operator|+=
name|subTermCounts
index|[
name|sub
index|]
operator|+
name|subSubCounts
index|[
name|sub
index|]
expr_stmt|;
comment|//System.out.println("  " + (subTermCounts[sub] + subSubCounts[sub]));
name|subCount
operator|++
expr_stmt|;
comment|// Greedily make a floor block as soon as we've
comment|// crossed the min count
if|if
condition|(
name|pendingCount
operator|>=
name|minItemsInBlock
condition|)
block|{
specifier|final
name|int
name|curPrefixLength
decl_stmt|;
if|if
condition|(
name|startLabel
operator|==
operator|-
literal|1
condition|)
block|{
name|curPrefixLength
operator|=
name|prefixLength
expr_stmt|;
block|}
else|else
block|{
name|curPrefixLength
operator|=
literal|1
operator|+
name|prefixLength
expr_stmt|;
comment|// floor term:
name|prevTerm
operator|.
name|ints
index|[
name|prevTerm
operator|.
name|offset
operator|+
name|prefixLength
index|]
operator|=
name|startLabel
expr_stmt|;
block|}
comment|//System.out.println("  " + subCount + " subs");
specifier|final
name|PendingBlock
name|floorBlock
init|=
name|writeBlock
argument_list|(
name|prevTerm
argument_list|,
name|prefixLength
argument_list|,
name|curPrefixLength
argument_list|,
name|curStart
argument_list|,
name|pendingCount
argument_list|,
name|subTermCountSums
index|[
literal|1
operator|+
name|sub
index|]
argument_list|,
literal|true
argument_list|,
name|startLabel
argument_list|,
name|curStart
operator|==
name|pendingCount
argument_list|)
decl_stmt|;
if|if
condition|(
name|firstBlock
operator|==
literal|null
condition|)
block|{
name|firstBlock
operator|=
name|floorBlock
expr_stmt|;
block|}
else|else
block|{
name|floorBlocks
operator|.
name|add
argument_list|(
name|floorBlock
argument_list|)
expr_stmt|;
block|}
name|curStart
operator|-=
name|pendingCount
expr_stmt|;
comment|//System.out.println("    = " + pendingCount);
name|pendingCount
operator|=
literal|0
expr_stmt|;
assert|assert
name|minItemsInBlock
operator|==
literal|1
operator|||
name|subCount
operator|>
literal|1
operator|:
literal|"minItemsInBlock="
operator|+
name|minItemsInBlock
operator|+
literal|" subCount="
operator|+
name|subCount
operator|+
literal|" sub="
operator|+
name|sub
operator|+
literal|" of "
operator|+
name|numSubs
operator|+
literal|" subTermCount="
operator|+
name|subTermCountSums
index|[
name|sub
index|]
operator|+
literal|" subSubCount="
operator|+
name|subSubCounts
index|[
name|sub
index|]
operator|+
literal|" depth="
operator|+
name|prefixLength
assert|;
name|subCount
operator|=
literal|0
expr_stmt|;
name|startLabel
operator|=
name|subBytes
index|[
name|sub
operator|+
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|curStart
operator|==
literal|0
condition|)
block|{
break|break;
block|}
if|if
condition|(
name|curStart
operator|<=
name|maxItemsInBlock
condition|)
block|{
comment|// remainder is small enough to fit into a
comment|// block.  NOTE that this may be too small (<
comment|// minItemsInBlock); need a true segmenter
comment|// here
assert|assert
name|startLabel
operator|!=
operator|-
literal|1
assert|;
assert|assert
name|firstBlock
operator|!=
literal|null
assert|;
name|prevTerm
operator|.
name|ints
index|[
name|prevTerm
operator|.
name|offset
operator|+
name|prefixLength
index|]
operator|=
name|startLabel
expr_stmt|;
comment|//System.out.println("  final " + (numSubs-sub-1) + " subs");
comment|/*               for(sub++;sub< numSubs;sub++) {                 System.out.println("  " + (subTermCounts[sub] + subSubCounts[sub]));               }               System.out.println("    = " + curStart);               if (curStart< minItemsInBlock) {                 System.out.println("      **");               }               */
name|floorBlocks
operator|.
name|add
argument_list|(
name|writeBlock
argument_list|(
name|prevTerm
argument_list|,
name|prefixLength
argument_list|,
name|prefixLength
operator|+
literal|1
argument_list|,
name|curStart
argument_list|,
name|curStart
argument_list|,
literal|0
argument_list|,
literal|true
argument_list|,
name|startLabel
argument_list|,
literal|true
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
name|prevTerm
operator|.
name|ints
index|[
name|prevTerm
operator|.
name|offset
operator|+
name|prefixLength
index|]
operator|=
name|savLabel
expr_stmt|;
assert|assert
name|firstBlock
operator|!=
literal|null
assert|;
name|firstBlock
operator|.
name|compileIndex
argument_list|(
name|floorBlocks
argument_list|,
name|scratchBytes
argument_list|)
expr_stmt|;
name|pending
operator|.
name|add
argument_list|(
name|firstBlock
argument_list|)
expr_stmt|;
comment|//if (DEBUG) System.out.println("  done pending.size()=" + pending.size());
block|}
name|lastBlockIndex
operator|=
name|pending
operator|.
name|size
argument_list|()
operator|-
literal|1
expr_stmt|;
block|}
comment|// for debugging
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unused"
argument_list|)
DECL|method|toString
specifier|private
name|String
name|toString
parameter_list|(
name|BytesRef
name|b
parameter_list|)
block|{
try|try
block|{
return|return
name|b
operator|.
name|utf8ToString
argument_list|()
operator|+
literal|" "
operator|+
name|b
return|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
comment|// If BytesRef isn't actually UTF8, or it's eg a
comment|// prefix of UTF8 that ends mid-unicode-char, we
comment|// fallback to hex:
return|return
name|b
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
comment|// Writes all entries in the pending slice as a single
comment|// block:
DECL|method|writeBlock
specifier|private
name|PendingBlock
name|writeBlock
parameter_list|(
name|IntsRef
name|prevTerm
parameter_list|,
name|int
name|prefixLength
parameter_list|,
name|int
name|indexPrefixLength
parameter_list|,
name|int
name|startBackwards
parameter_list|,
name|int
name|length
parameter_list|,
name|int
name|futureTermCount
parameter_list|,
name|boolean
name|isFloor
parameter_list|,
name|int
name|floorLeadByte
parameter_list|,
name|boolean
name|isLastInFloor
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|length
operator|>
literal|0
assert|;
specifier|final
name|int
name|start
init|=
name|pending
operator|.
name|size
argument_list|()
operator|-
name|startBackwards
decl_stmt|;
assert|assert
name|start
operator|>=
literal|0
operator|:
literal|"pending.size()="
operator|+
name|pending
operator|.
name|size
argument_list|()
operator|+
literal|" startBackwards="
operator|+
name|startBackwards
operator|+
literal|" length="
operator|+
name|length
assert|;
specifier|final
name|List
argument_list|<
name|PendingEntry
argument_list|>
name|slice
init|=
name|pending
operator|.
name|subList
argument_list|(
name|start
argument_list|,
name|start
operator|+
name|length
argument_list|)
decl_stmt|;
specifier|final
name|long
name|startFP
init|=
name|out
operator|.
name|getFilePointer
argument_list|()
decl_stmt|;
specifier|final
name|BytesRef
name|prefix
init|=
operator|new
name|BytesRef
argument_list|(
name|indexPrefixLength
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|m
init|=
literal|0
init|;
name|m
operator|<
name|indexPrefixLength
condition|;
name|m
operator|++
control|)
block|{
name|prefix
operator|.
name|bytes
index|[
name|m
index|]
operator|=
operator|(
name|byte
operator|)
name|prevTerm
operator|.
name|ints
index|[
name|m
index|]
expr_stmt|;
block|}
name|prefix
operator|.
name|length
operator|=
name|indexPrefixLength
expr_stmt|;
comment|// Write block header:
name|out
operator|.
name|writeVInt
argument_list|(
operator|(
name|length
operator|<<
literal|1
operator|)
operator||
operator|(
name|isLastInFloor
condition|?
literal|1
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
comment|// if (DEBUG) {
comment|//   System.out.println("  writeBlock " + (isFloor ? "(floor) " : "") + "seg=" + segment + " pending.size()=" + pending.size() + " prefixLength=" + prefixLength + " indexPrefix=" + toString(prefix) + " entCount=" + length + " startFP=" + startFP + " futureTermCount=" + futureTermCount + (isFloor ? (" floorLeadByte=" + Integer.toHexString(floorLeadByte&0xff)) : "") + " isLastInFloor=" + isLastInFloor);
comment|// }
comment|// 1st pass: pack term suffix bytes into byte[] blob
comment|// TODO: cutover to bulk int codec... simple64?
specifier|final
name|boolean
name|isLeafBlock
decl_stmt|;
if|if
condition|(
name|lastBlockIndex
operator|<
name|start
condition|)
block|{
comment|// This block definitely does not contain sub-blocks:
name|isLeafBlock
operator|=
literal|true
expr_stmt|;
comment|//System.out.println("no scan true isFloor=" + isFloor);
block|}
elseif|else
if|if
condition|(
operator|!
name|isFloor
condition|)
block|{
comment|// This block definitely does contain at least one sub-block:
name|isLeafBlock
operator|=
literal|false
expr_stmt|;
comment|//System.out.println("no scan false " + lastBlockIndex + " vs start=" + start + " len=" + length);
block|}
else|else
block|{
comment|// Must scan up-front to see if there is a sub-block
name|boolean
name|v
init|=
literal|true
decl_stmt|;
comment|//System.out.println("scan " + lastBlockIndex + " vs start=" + start + " len=" + length);
for|for
control|(
name|PendingEntry
name|ent
range|:
name|slice
control|)
block|{
if|if
condition|(
operator|!
name|ent
operator|.
name|isTerm
condition|)
block|{
name|v
operator|=
literal|false
expr_stmt|;
break|break;
block|}
block|}
name|isLeafBlock
operator|=
name|v
expr_stmt|;
block|}
specifier|final
name|List
argument_list|<
name|FST
argument_list|<
name|Pair
argument_list|<
name|BytesRef
argument_list|,
name|Long
argument_list|>
argument_list|>
argument_list|>
name|subIndices
decl_stmt|;
name|int
name|termCount
decl_stmt|;
name|long
index|[]
name|longs
init|=
operator|new
name|long
index|[
name|longsSize
index|]
decl_stmt|;
name|boolean
name|absolute
init|=
literal|true
decl_stmt|;
name|long
name|maxVersionInBlock
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|isLeafBlock
condition|)
block|{
name|subIndices
operator|=
literal|null
expr_stmt|;
for|for
control|(
name|PendingEntry
name|ent
range|:
name|slice
control|)
block|{
assert|assert
name|ent
operator|.
name|isTerm
assert|;
name|PendingTerm
name|term
init|=
operator|(
name|PendingTerm
operator|)
name|ent
decl_stmt|;
name|BlockTermState
name|state
init|=
name|term
operator|.
name|state
decl_stmt|;
name|maxVersionInBlock
operator|=
name|Math
operator|.
name|max
argument_list|(
name|maxVersionInBlock
argument_list|,
operator|(
operator|(
name|IDVersionTermState
operator|)
name|state
operator|)
operator|.
name|idVersion
argument_list|)
expr_stmt|;
specifier|final
name|int
name|suffix
init|=
name|term
operator|.
name|term
operator|.
name|length
operator|-
name|prefixLength
decl_stmt|;
comment|// if (DEBUG) {
comment|//   BytesRef suffixBytes = new BytesRef(suffix);
comment|//   System.arraycopy(term.term.bytes, prefixLength, suffixBytes.bytes, 0, suffix);
comment|//   suffixBytes.length = suffix;
comment|//   System.out.println("    write term suffix=" + suffixBytes);
comment|// }
comment|// For leaf block we write suffix straight
name|suffixWriter
operator|.
name|writeVInt
argument_list|(
name|suffix
argument_list|)
expr_stmt|;
name|suffixWriter
operator|.
name|writeBytes
argument_list|(
name|term
operator|.
name|term
operator|.
name|bytes
argument_list|,
name|prefixLength
argument_list|,
name|suffix
argument_list|)
expr_stmt|;
comment|// Write term stats, to separate byte[] blob:
name|statsWriter
operator|.
name|writeVInt
argument_list|(
name|state
operator|.
name|docFreq
argument_list|)
expr_stmt|;
if|if
condition|(
name|fieldInfo
operator|.
name|getIndexOptions
argument_list|()
operator|!=
name|IndexOptions
operator|.
name|DOCS_ONLY
condition|)
block|{
assert|assert
name|state
operator|.
name|totalTermFreq
operator|>=
name|state
operator|.
name|docFreq
operator|:
name|state
operator|.
name|totalTermFreq
operator|+
literal|" vs "
operator|+
name|state
operator|.
name|docFreq
assert|;
name|statsWriter
operator|.
name|writeVLong
argument_list|(
name|state
operator|.
name|totalTermFreq
operator|-
name|state
operator|.
name|docFreq
argument_list|)
expr_stmt|;
block|}
comment|// Write term meta data
name|postingsWriter
operator|.
name|encodeTerm
argument_list|(
name|longs
argument_list|,
name|bytesWriter
argument_list|,
name|fieldInfo
argument_list|,
name|state
argument_list|,
name|absolute
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|pos
init|=
literal|0
init|;
name|pos
operator|<
name|longsSize
condition|;
name|pos
operator|++
control|)
block|{
assert|assert
name|longs
index|[
name|pos
index|]
operator|>=
literal|0
assert|;
name|metaWriter
operator|.
name|writeVLong
argument_list|(
name|longs
index|[
name|pos
index|]
argument_list|)
expr_stmt|;
block|}
name|bytesWriter
operator|.
name|writeTo
argument_list|(
name|metaWriter
argument_list|)
expr_stmt|;
name|bytesWriter
operator|.
name|reset
argument_list|()
expr_stmt|;
name|absolute
operator|=
literal|false
expr_stmt|;
block|}
name|termCount
operator|=
name|length
expr_stmt|;
block|}
else|else
block|{
name|subIndices
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
expr_stmt|;
name|termCount
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|PendingEntry
name|ent
range|:
name|slice
control|)
block|{
if|if
condition|(
name|ent
operator|.
name|isTerm
condition|)
block|{
name|PendingTerm
name|term
init|=
operator|(
name|PendingTerm
operator|)
name|ent
decl_stmt|;
name|BlockTermState
name|state
init|=
name|term
operator|.
name|state
decl_stmt|;
name|maxVersionInBlock
operator|=
name|Math
operator|.
name|max
argument_list|(
name|maxVersionInBlock
argument_list|,
operator|(
operator|(
name|IDVersionTermState
operator|)
name|state
operator|)
operator|.
name|idVersion
argument_list|)
expr_stmt|;
specifier|final
name|int
name|suffix
init|=
name|term
operator|.
name|term
operator|.
name|length
operator|-
name|prefixLength
decl_stmt|;
comment|// if (DEBUG) {
comment|//   BytesRef suffixBytes = new BytesRef(suffix);
comment|//   System.arraycopy(term.term.bytes, prefixLength, suffixBytes.bytes, 0, suffix);
comment|//   suffixBytes.length = suffix;
comment|//   System.out.println("    write term suffix=" + suffixBytes);
comment|// }
comment|// For non-leaf block we borrow 1 bit to record
comment|// if entry is term or sub-block
name|suffixWriter
operator|.
name|writeVInt
argument_list|(
name|suffix
operator|<<
literal|1
argument_list|)
expr_stmt|;
name|suffixWriter
operator|.
name|writeBytes
argument_list|(
name|term
operator|.
name|term
operator|.
name|bytes
argument_list|,
name|prefixLength
argument_list|,
name|suffix
argument_list|)
expr_stmt|;
comment|// Write term stats, to separate byte[] blob:
name|statsWriter
operator|.
name|writeVInt
argument_list|(
name|state
operator|.
name|docFreq
argument_list|)
expr_stmt|;
if|if
condition|(
name|fieldInfo
operator|.
name|getIndexOptions
argument_list|()
operator|!=
name|IndexOptions
operator|.
name|DOCS_ONLY
condition|)
block|{
assert|assert
name|state
operator|.
name|totalTermFreq
operator|>=
name|state
operator|.
name|docFreq
assert|;
name|statsWriter
operator|.
name|writeVLong
argument_list|(
name|state
operator|.
name|totalTermFreq
operator|-
name|state
operator|.
name|docFreq
argument_list|)
expr_stmt|;
block|}
comment|// TODO: now that terms dict "sees" these longs,
comment|// we can explore better column-stride encodings
comment|// to encode all long[0]s for this block at
comment|// once, all long[1]s, etc., e.g. using
comment|// Simple64.  Alternatively, we could interleave
comment|// stats + meta ... no reason to have them
comment|// separate anymore:
comment|// Write term meta data
name|postingsWriter
operator|.
name|encodeTerm
argument_list|(
name|longs
argument_list|,
name|bytesWriter
argument_list|,
name|fieldInfo
argument_list|,
name|state
argument_list|,
name|absolute
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|pos
init|=
literal|0
init|;
name|pos
operator|<
name|longsSize
condition|;
name|pos
operator|++
control|)
block|{
assert|assert
name|longs
index|[
name|pos
index|]
operator|>=
literal|0
assert|;
name|metaWriter
operator|.
name|writeVLong
argument_list|(
name|longs
index|[
name|pos
index|]
argument_list|)
expr_stmt|;
block|}
name|bytesWriter
operator|.
name|writeTo
argument_list|(
name|metaWriter
argument_list|)
expr_stmt|;
name|bytesWriter
operator|.
name|reset
argument_list|()
expr_stmt|;
name|absolute
operator|=
literal|false
expr_stmt|;
name|termCount
operator|++
expr_stmt|;
block|}
else|else
block|{
name|PendingBlock
name|block
init|=
operator|(
name|PendingBlock
operator|)
name|ent
decl_stmt|;
name|maxVersionInBlock
operator|=
name|Math
operator|.
name|max
argument_list|(
name|maxVersionInBlock
argument_list|,
name|block
operator|.
name|maxVersion
argument_list|)
expr_stmt|;
specifier|final
name|int
name|suffix
init|=
name|block
operator|.
name|prefix
operator|.
name|length
operator|-
name|prefixLength
decl_stmt|;
assert|assert
name|suffix
operator|>
literal|0
assert|;
comment|// For non-leaf block we borrow 1 bit to record
comment|// if entry is term or sub-block
name|suffixWriter
operator|.
name|writeVInt
argument_list|(
operator|(
name|suffix
operator|<<
literal|1
operator|)
operator||
literal|1
argument_list|)
expr_stmt|;
name|suffixWriter
operator|.
name|writeBytes
argument_list|(
name|block
operator|.
name|prefix
operator|.
name|bytes
argument_list|,
name|prefixLength
argument_list|,
name|suffix
argument_list|)
expr_stmt|;
assert|assert
name|block
operator|.
name|fp
operator|<
name|startFP
assert|;
comment|// if (DEBUG) {
comment|//   BytesRef suffixBytes = new BytesRef(suffix);
comment|//   System.arraycopy(block.prefix.bytes, prefixLength, suffixBytes.bytes, 0, suffix);
comment|//   suffixBytes.length = suffix;
comment|//   System.out.println("    write sub-block suffix=" + toString(suffixBytes) + " subFP=" + block.fp + " subCode=" + (startFP-block.fp) + " floor=" + block.isFloor);
comment|// }
name|suffixWriter
operator|.
name|writeVLong
argument_list|(
name|startFP
operator|-
name|block
operator|.
name|fp
argument_list|)
expr_stmt|;
name|subIndices
operator|.
name|add
argument_list|(
name|block
operator|.
name|index
argument_list|)
expr_stmt|;
block|}
block|}
assert|assert
name|subIndices
operator|.
name|size
argument_list|()
operator|!=
literal|0
assert|;
block|}
comment|// TODO: we could block-write the term suffix pointers;
comment|// this would take more space but would enable binary
comment|// search on lookup
comment|// Write suffixes byte[] blob to terms dict output:
name|out
operator|.
name|writeVInt
argument_list|(
call|(
name|int
call|)
argument_list|(
name|suffixWriter
operator|.
name|getFilePointer
argument_list|()
operator|<<
literal|1
argument_list|)
operator||
operator|(
name|isLeafBlock
condition|?
literal|1
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
name|suffixWriter
operator|.
name|writeTo
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|suffixWriter
operator|.
name|reset
argument_list|()
expr_stmt|;
comment|// Write term stats byte[] blob
name|out
operator|.
name|writeVInt
argument_list|(
operator|(
name|int
operator|)
name|statsWriter
operator|.
name|getFilePointer
argument_list|()
argument_list|)
expr_stmt|;
name|statsWriter
operator|.
name|writeTo
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|statsWriter
operator|.
name|reset
argument_list|()
expr_stmt|;
comment|// Write term meta data byte[] blob
name|out
operator|.
name|writeVInt
argument_list|(
operator|(
name|int
operator|)
name|metaWriter
operator|.
name|getFilePointer
argument_list|()
argument_list|)
expr_stmt|;
name|metaWriter
operator|.
name|writeTo
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|metaWriter
operator|.
name|reset
argument_list|()
expr_stmt|;
comment|// Remove slice replaced by block:
name|slice
operator|.
name|clear
argument_list|()
expr_stmt|;
if|if
condition|(
name|lastBlockIndex
operator|>=
name|start
condition|)
block|{
if|if
condition|(
name|lastBlockIndex
operator|<
name|start
operator|+
name|length
condition|)
block|{
name|lastBlockIndex
operator|=
name|start
expr_stmt|;
block|}
else|else
block|{
name|lastBlockIndex
operator|-=
name|length
expr_stmt|;
block|}
block|}
comment|// if (DEBUG) {
comment|//   System.out.println("      fpEnd=" + out.getFilePointer());
comment|// }
return|return
operator|new
name|PendingBlock
argument_list|(
name|prefix
argument_list|,
name|maxVersionInBlock
argument_list|,
name|startFP
argument_list|,
name|termCount
operator|!=
literal|0
argument_list|,
name|isFloor
argument_list|,
name|floorLeadByte
argument_list|,
name|subIndices
argument_list|)
return|;
block|}
DECL|method|TermsWriter
name|TermsWriter
parameter_list|(
name|FieldInfo
name|fieldInfo
parameter_list|)
block|{
name|this
operator|.
name|fieldInfo
operator|=
name|fieldInfo
expr_stmt|;
name|docsSeen
operator|=
operator|new
name|FixedBitSet
argument_list|(
name|maxDoc
argument_list|)
expr_stmt|;
name|noOutputs
operator|=
name|NoOutputs
operator|.
name|getSingleton
argument_list|()
expr_stmt|;
comment|// This Builder is just used transiently to fragment
comment|// terms into "good" blocks; we don't save the
comment|// resulting FST:
name|blockBuilder
operator|=
operator|new
name|Builder
argument_list|<>
argument_list|(
name|FST
operator|.
name|INPUT_TYPE
operator|.
name|BYTE1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|true
argument_list|,
literal|true
argument_list|,
name|Integer
operator|.
name|MAX_VALUE
argument_list|,
name|noOutputs
argument_list|,
operator|new
name|FindBlocks
argument_list|()
argument_list|,
literal|false
argument_list|,
name|PackedInts
operator|.
name|COMPACT
argument_list|,
literal|true
argument_list|,
literal|15
argument_list|)
expr_stmt|;
name|this
operator|.
name|longsSize
operator|=
name|postingsWriter
operator|.
name|setField
argument_list|(
name|fieldInfo
argument_list|)
expr_stmt|;
block|}
DECL|field|scratchIntsRef
specifier|private
specifier|final
name|IntsRef
name|scratchIntsRef
init|=
operator|new
name|IntsRef
argument_list|()
decl_stmt|;
comment|/** Writes one term's worth of postings. */
DECL|method|write
specifier|public
name|void
name|write
parameter_list|(
name|BytesRef
name|text
parameter_list|,
name|TermsEnum
name|termsEnum
parameter_list|)
throws|throws
name|IOException
block|{
name|BlockTermState
name|state
init|=
name|postingsWriter
operator|.
name|writeTerm
argument_list|(
name|text
argument_list|,
name|termsEnum
argument_list|,
name|docsSeen
argument_list|)
decl_stmt|;
if|if
condition|(
name|state
operator|!=
literal|null
condition|)
block|{
assert|assert
name|state
operator|.
name|docFreq
operator|!=
literal|0
assert|;
assert|assert
name|fieldInfo
operator|.
name|getIndexOptions
argument_list|()
operator|==
name|IndexOptions
operator|.
name|DOCS_ONLY
operator|||
name|state
operator|.
name|totalTermFreq
operator|>=
name|state
operator|.
name|docFreq
operator|:
literal|"postingsWriter="
operator|+
name|postingsWriter
assert|;
name|sumDocFreq
operator|+=
name|state
operator|.
name|docFreq
expr_stmt|;
name|sumTotalTermFreq
operator|+=
name|state
operator|.
name|totalTermFreq
expr_stmt|;
name|blockBuilder
operator|.
name|add
argument_list|(
name|Util
operator|.
name|toIntsRef
argument_list|(
name|text
argument_list|,
name|scratchIntsRef
argument_list|)
argument_list|,
name|noOutputs
operator|.
name|getNoOutput
argument_list|()
argument_list|)
expr_stmt|;
name|PendingTerm
name|term
init|=
operator|new
name|PendingTerm
argument_list|(
name|BytesRef
operator|.
name|deepCopyOf
argument_list|(
name|text
argument_list|)
argument_list|,
name|state
argument_list|)
decl_stmt|;
name|pending
operator|.
name|add
argument_list|(
name|term
argument_list|)
expr_stmt|;
name|numTerms
operator|++
expr_stmt|;
block|}
block|}
comment|// Finishes all terms in this field
DECL|method|finish
specifier|public
name|void
name|finish
parameter_list|(
name|BytesRef
name|minTerm
parameter_list|,
name|BytesRef
name|maxTerm
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|numTerms
operator|>
literal|0
condition|)
block|{
name|blockBuilder
operator|.
name|finish
argument_list|()
expr_stmt|;
comment|// We better have one final "root" block:
assert|assert
name|pending
operator|.
name|size
argument_list|()
operator|==
literal|1
operator|&&
operator|!
name|pending
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|isTerm
operator|:
literal|"pending.size()="
operator|+
name|pending
operator|.
name|size
argument_list|()
operator|+
literal|" pending="
operator|+
name|pending
assert|;
specifier|final
name|PendingBlock
name|root
init|=
operator|(
name|PendingBlock
operator|)
name|pending
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
assert|assert
name|root
operator|.
name|prefix
operator|.
name|length
operator|==
literal|0
assert|;
assert|assert
name|root
operator|.
name|index
operator|.
name|getEmptyOutput
argument_list|()
operator|!=
literal|null
assert|;
comment|// Write FST to index
name|indexStartFP
operator|=
name|indexOut
operator|.
name|getFilePointer
argument_list|()
expr_stmt|;
name|root
operator|.
name|index
operator|.
name|save
argument_list|(
name|indexOut
argument_list|)
expr_stmt|;
comment|//System.out.println("  write FST " + indexStartFP + " field=" + fieldInfo.name);
comment|// if (SAVE_DOT_FILES || DEBUG) {
comment|//   final String dotFileName = segment + "_" + fieldInfo.name + ".dot";
comment|//   Writer w = new OutputStreamWriter(new FileOutputStream(dotFileName));
comment|//   Util.toDot(root.index, w, false, false);
comment|//   System.out.println("SAVED to " + dotFileName);
comment|//   w.close();
comment|// }
name|fields
operator|.
name|add
argument_list|(
operator|new
name|FieldMetaData
argument_list|(
name|fieldInfo
argument_list|,
operator|(
operator|(
name|PendingBlock
operator|)
name|pending
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|)
operator|.
name|index
operator|.
name|getEmptyOutput
argument_list|()
argument_list|,
name|numTerms
argument_list|,
name|indexStartFP
argument_list|,
name|sumTotalTermFreq
argument_list|,
name|sumDocFreq
argument_list|,
name|docsSeen
operator|.
name|cardinality
argument_list|()
argument_list|,
name|longsSize
argument_list|,
name|minTerm
argument_list|,
name|maxTerm
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
assert|assert
name|sumTotalTermFreq
operator|==
literal|0
operator|||
name|fieldInfo
operator|.
name|getIndexOptions
argument_list|()
operator|==
name|IndexOptions
operator|.
name|DOCS_ONLY
operator|&&
name|sumTotalTermFreq
operator|==
operator|-
literal|1
assert|;
assert|assert
name|sumDocFreq
operator|==
literal|0
assert|;
assert|assert
name|docsSeen
operator|.
name|cardinality
argument_list|()
operator|==
literal|0
assert|;
block|}
block|}
DECL|field|suffixWriter
specifier|private
specifier|final
name|RAMOutputStream
name|suffixWriter
init|=
operator|new
name|RAMOutputStream
argument_list|()
decl_stmt|;
DECL|field|statsWriter
specifier|private
specifier|final
name|RAMOutputStream
name|statsWriter
init|=
operator|new
name|RAMOutputStream
argument_list|()
decl_stmt|;
DECL|field|metaWriter
specifier|private
specifier|final
name|RAMOutputStream
name|metaWriter
init|=
operator|new
name|RAMOutputStream
argument_list|()
decl_stmt|;
DECL|field|bytesWriter
specifier|private
specifier|final
name|RAMOutputStream
name|bytesWriter
init|=
operator|new
name|RAMOutputStream
argument_list|()
decl_stmt|;
block|}
annotation|@
name|Override
DECL|method|close
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
name|boolean
name|success
init|=
literal|false
decl_stmt|;
try|try
block|{
specifier|final
name|long
name|dirStart
init|=
name|out
operator|.
name|getFilePointer
argument_list|()
decl_stmt|;
specifier|final
name|long
name|indexDirStart
init|=
name|indexOut
operator|.
name|getFilePointer
argument_list|()
decl_stmt|;
name|out
operator|.
name|writeVInt
argument_list|(
name|fields
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|FieldMetaData
name|field
range|:
name|fields
control|)
block|{
comment|//System.out.println("  field " + field.fieldInfo.name + " " + field.numTerms + " terms");
name|out
operator|.
name|writeVInt
argument_list|(
name|field
operator|.
name|fieldInfo
operator|.
name|number
argument_list|)
expr_stmt|;
assert|assert
name|field
operator|.
name|numTerms
operator|>
literal|0
assert|;
name|out
operator|.
name|writeVLong
argument_list|(
name|field
operator|.
name|numTerms
argument_list|)
expr_stmt|;
name|out
operator|.
name|writeVInt
argument_list|(
name|field
operator|.
name|rootCode
operator|.
name|output1
operator|.
name|length
argument_list|)
expr_stmt|;
name|out
operator|.
name|writeBytes
argument_list|(
name|field
operator|.
name|rootCode
operator|.
name|output1
operator|.
name|bytes
argument_list|,
name|field
operator|.
name|rootCode
operator|.
name|output1
operator|.
name|offset
argument_list|,
name|field
operator|.
name|rootCode
operator|.
name|output1
operator|.
name|length
argument_list|)
expr_stmt|;
name|out
operator|.
name|writeVLong
argument_list|(
name|field
operator|.
name|rootCode
operator|.
name|output2
argument_list|)
expr_stmt|;
if|if
condition|(
name|field
operator|.
name|fieldInfo
operator|.
name|getIndexOptions
argument_list|()
operator|!=
name|IndexOptions
operator|.
name|DOCS_ONLY
condition|)
block|{
name|out
operator|.
name|writeVLong
argument_list|(
name|field
operator|.
name|sumTotalTermFreq
argument_list|)
expr_stmt|;
block|}
name|out
operator|.
name|writeVLong
argument_list|(
name|field
operator|.
name|sumDocFreq
argument_list|)
expr_stmt|;
name|out
operator|.
name|writeVInt
argument_list|(
name|field
operator|.
name|docCount
argument_list|)
expr_stmt|;
name|out
operator|.
name|writeVInt
argument_list|(
name|field
operator|.
name|longsSize
argument_list|)
expr_stmt|;
name|indexOut
operator|.
name|writeVLong
argument_list|(
name|field
operator|.
name|indexStartFP
argument_list|)
expr_stmt|;
name|writeBytesRef
argument_list|(
name|out
argument_list|,
name|field
operator|.
name|minTerm
argument_list|)
expr_stmt|;
name|writeBytesRef
argument_list|(
name|out
argument_list|,
name|field
operator|.
name|maxTerm
argument_list|)
expr_stmt|;
block|}
name|writeTrailer
argument_list|(
name|out
argument_list|,
name|dirStart
argument_list|)
expr_stmt|;
name|CodecUtil
operator|.
name|writeFooter
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|writeIndexTrailer
argument_list|(
name|indexOut
argument_list|,
name|indexDirStart
argument_list|)
expr_stmt|;
name|CodecUtil
operator|.
name|writeFooter
argument_list|(
name|indexOut
argument_list|)
expr_stmt|;
name|success
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
name|success
condition|)
block|{
name|IOUtils
operator|.
name|close
argument_list|(
name|out
argument_list|,
name|indexOut
argument_list|,
name|postingsWriter
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|IOUtils
operator|.
name|closeWhileHandlingException
argument_list|(
name|out
argument_list|,
name|indexOut
argument_list|,
name|postingsWriter
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|writeBytesRef
specifier|private
specifier|static
name|void
name|writeBytesRef
parameter_list|(
name|IndexOutput
name|out
parameter_list|,
name|BytesRef
name|bytes
parameter_list|)
throws|throws
name|IOException
block|{
name|out
operator|.
name|writeVInt
argument_list|(
name|bytes
operator|.
name|length
argument_list|)
expr_stmt|;
name|out
operator|.
name|writeBytes
argument_list|(
name|bytes
operator|.
name|bytes
argument_list|,
name|bytes
operator|.
name|offset
argument_list|,
name|bytes
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
block|}
end_class
end_unit
