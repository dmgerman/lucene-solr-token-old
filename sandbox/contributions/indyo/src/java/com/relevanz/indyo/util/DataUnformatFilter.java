begin_unit
begin_comment
comment|/*--   Copyright (C) 2000 Brett McLaughlin& Jason Hunter.  All rights reserved.   Redistribution and use in source and binary forms, with or without  modification, are permitted provided that the following conditions  are met:   1. Redistributions of source code must retain the above copyright     notice, this list of conditions, and the following disclaimer.   2. Redistributions in binary form must reproduce the above copyright     notice, this list of conditions, and the disclaimer that follows     these conditions in the documentation and/or other materials     provided with the distribution.   3. The name "JDOM" must not be used to endorse or promote products     derived from this software without prior written permission.  For     written permission, please contact license@jdom.org.   4. Products derived from this software may not be called "JDOM", nor     may "JDOM" appear in their name, without prior written permission     from the JDOM Project Management (pm@jdom.org).   In addition, we request (but do not require) that you include in the  end-user documentation provided with the redistribution and/or in the  software itself an acknowledgement equivalent to the following:      "This product includes software developed by the       JDOM Project (http://www.jdom.org/)."  Alternatively, the acknowledgment may be graphical using the logos  available at http://www.jdom.org/images/logos.   THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE  DISCLAIMED.  IN NO EVENT SHALL THE JDOM AUTHORS OR THE PROJECT  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF  USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  SUCH DAMAGE.   This software consists of voluntary contributions made by many  individuals on behalf of the JDOM Project and was originally  created by Brett McLaughlin<brett@jdom.org> and  Jason Hunter<jhunter@jdom.org>.  For more information on the  JDOM Project, please see<http://www.jdom.org/>.   */
end_comment
begin_package
DECL|package|com.relevanz.indyo.util
package|package
name|com
operator|.
name|relevanz
operator|.
name|indyo
operator|.
name|util
package|;
end_package
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Stack
import|;
end_import
begin_import
import|import
name|org
operator|.
name|xml
operator|.
name|sax
operator|.
name|Attributes
import|;
end_import
begin_import
import|import
name|org
operator|.
name|xml
operator|.
name|sax
operator|.
name|SAXException
import|;
end_import
begin_import
import|import
name|org
operator|.
name|xml
operator|.
name|sax
operator|.
name|XMLReader
import|;
end_import
begin_comment
comment|/**  * Filter for removing formatting from data- or field-oriented XML.  *  *<i>Code and comments adapted from DataWriter-0.2, written  * by David Megginson and released into the public domain,  * without warranty.</i>  *  *<p>This filter removes leading and trailing whitespace from  * field-oriented XML without mixed content. Note that this class will  * likely not yield appropriate results for document-oriented XML like  * XHTML pages, which mix character data and elements together.</p>  *  * @see DataFormatFilter  */
end_comment
begin_class
DECL|class|DataUnformatFilter
specifier|public
class|class
name|DataUnformatFilter
extends|extends
name|XMLFilterBase
block|{
comment|////////////////////////////////////////////////////////////////////
comment|// Constructors.
comment|////////////////////////////////////////////////////////////////////
comment|/**      * Create a new filter.      */
DECL|method|DataUnformatFilter
specifier|public
name|DataUnformatFilter
parameter_list|()
block|{     }
comment|/**      * Create a new filter.      *      *<p>Use the XMLReader provided as the source of events.</p>      *      * @param xmlreader The parent in the filter chain.      */
DECL|method|DataUnformatFilter
specifier|public
name|DataUnformatFilter
parameter_list|(
name|XMLReader
name|xmlreader
parameter_list|)
block|{
name|super
argument_list|(
name|xmlreader
argument_list|)
expr_stmt|;
block|}
comment|////////////////////////////////////////////////////////////////////
comment|// Public methods.
comment|////////////////////////////////////////////////////////////////////
comment|/**      * Reset the filter so that it can be reused.      *      *<p>This method is especially useful if the filter failed      * with an exception the last time through.</p>      */
DECL|method|reset
specifier|public
name|void
name|reset
parameter_list|()
block|{
name|state
operator|=
name|SEEN_NOTHING
expr_stmt|;
name|stateStack
operator|=
operator|new
name|Stack
argument_list|()
expr_stmt|;
name|whitespace
operator|=
operator|new
name|StringBuffer
argument_list|()
expr_stmt|;
block|}
comment|/**      * Filter a start document event.      *      *<p>Reset state and pass the event on for further processing.</p>      *      * @exception org.xml.sax.SAXException If a filter      *            further down the chain raises an exception.      * @see org.xml.sax.ContentHandler#startDocument      */
DECL|method|startDocument
specifier|public
name|void
name|startDocument
parameter_list|()
throws|throws
name|SAXException
block|{
name|reset
argument_list|()
expr_stmt|;
name|super
operator|.
name|startDocument
argument_list|()
expr_stmt|;
block|}
comment|/**      * Filter a start element event.      *      * @param uri The element's Namespace URI.      * @param localName The element's local name.      * @param qName The element's qualified (prefixed) name.      * @param atts The element's attribute list.      * @exception org.xml.sax.SAXException If a filter      *            further down the chain raises an exception.      * @see org.xml.sax.ContentHandler#startElement      */
DECL|method|startElement
specifier|public
name|void
name|startElement
parameter_list|(
name|String
name|uri
parameter_list|,
name|String
name|localName
parameter_list|,
name|String
name|qName
parameter_list|,
name|Attributes
name|atts
parameter_list|)
throws|throws
name|SAXException
block|{
name|clearWhitespace
argument_list|()
expr_stmt|;
name|stateStack
operator|.
name|push
argument_list|(
name|SEEN_ELEMENT
argument_list|)
expr_stmt|;
name|state
operator|=
name|SEEN_NOTHING
expr_stmt|;
name|super
operator|.
name|startElement
argument_list|(
name|uri
argument_list|,
name|localName
argument_list|,
name|qName
argument_list|,
name|atts
argument_list|)
expr_stmt|;
block|}
comment|/**      * Filter an end element event.      *      * @param uri The element's Namespace URI.      * @param localName The element's local name.      * @param qName The element's qualified (prefixed) name.      * @exception org.xml.sax.SAXException If a filter      *            further down the chain raises an exception.      * @see org.xml.sax.ContentHandler#endElement      */
DECL|method|endElement
specifier|public
name|void
name|endElement
parameter_list|(
name|String
name|uri
parameter_list|,
name|String
name|localName
parameter_list|,
name|String
name|qName
parameter_list|)
throws|throws
name|SAXException
block|{
if|if
condition|(
name|state
operator|==
name|SEEN_ELEMENT
condition|)
block|{
name|clearWhitespace
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|emitWhitespace
argument_list|()
expr_stmt|;
block|}
name|state
operator|=
name|stateStack
operator|.
name|pop
argument_list|()
expr_stmt|;
name|super
operator|.
name|endElement
argument_list|(
name|uri
argument_list|,
name|localName
argument_list|,
name|qName
argument_list|)
expr_stmt|;
block|}
comment|/**      * Filter a character data event.      *      * @param ch The characters to write.      * @param start The starting position in the array.      * @param length The number of characters to use.      * @exception org.xml.sax.SAXException If a filter      *            further down the chain raises an exception.      * @see org.xml.sax.ContentHandler#characters      */
DECL|method|characters
specifier|public
name|void
name|characters
parameter_list|(
name|char
name|ch
index|[]
parameter_list|,
name|int
name|start
parameter_list|,
name|int
name|length
parameter_list|)
throws|throws
name|SAXException
block|{
if|if
condition|(
name|state
operator|!=
name|SEEN_DATA
condition|)
block|{
comment|/* Look for non-whitespace. */
name|int
name|end
init|=
name|start
operator|+
name|length
decl_stmt|;
while|while
condition|(
name|end
operator|--
operator|>
name|start
condition|)
block|{
if|if
condition|(
operator|!
name|isXMLWhitespace
argument_list|(
name|ch
index|[
name|end
index|]
argument_list|)
condition|)
break|break;
block|}
comment|/*              * If all the characters are whitespace, save them for later.              * If we've got some data, emit any saved whitespace and update              * our state to show we've seen data.              */
if|if
condition|(
name|end
operator|<
name|start
condition|)
block|{
name|saveWhitespace
argument_list|(
name|ch
argument_list|,
name|start
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|state
operator|=
name|SEEN_DATA
expr_stmt|;
name|emitWhitespace
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* Pass on everything inside a data field. */
if|if
condition|(
name|state
operator|==
name|SEEN_DATA
condition|)
block|{
name|super
operator|.
name|characters
argument_list|(
name|ch
argument_list|,
name|start
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**       * Filter an ignorable whitespace event.       *       * @param ch The array of characters to write.       * @param start The starting position in the array.       * @param length The number of characters to write.       * @exception org.xml.sax.SAXException If a filter       *            further down the chain raises an exception.       * @see org.xml.sax.ContentHandler#ignorableWhitespace       */
DECL|method|ignorableWhitespace
specifier|public
name|void
name|ignorableWhitespace
parameter_list|(
name|char
name|ch
index|[]
parameter_list|,
name|int
name|start
parameter_list|,
name|int
name|length
parameter_list|)
throws|throws
name|SAXException
block|{
name|emitWhitespace
argument_list|()
expr_stmt|;
comment|// ignore
block|}
comment|/**      * Filter a processing instruction event.      *      * @param target The PI target.      * @param data The PI data.      * @exception org.xml.sax.SAXException If a filter      *            further down the chain raises an exception.      * @see org.xml.sax.ContentHandler#processingInstruction      */
DECL|method|processingInstruction
specifier|public
name|void
name|processingInstruction
parameter_list|(
name|String
name|target
parameter_list|,
name|String
name|data
parameter_list|)
throws|throws
name|SAXException
block|{
name|emitWhitespace
argument_list|()
expr_stmt|;
name|super
operator|.
name|processingInstruction
argument_list|(
name|target
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
comment|////////////////////////////////////////////////////////////////////
comment|// Internal methods.
comment|////////////////////////////////////////////////////////////////////
comment|/**      * Saves trailing whitespace.      */
DECL|method|saveWhitespace
specifier|protected
name|void
name|saveWhitespace
parameter_list|(
name|char
index|[]
name|ch
parameter_list|,
name|int
name|start
parameter_list|,
name|int
name|length
parameter_list|)
block|{
name|whitespace
operator|.
name|append
argument_list|(
name|ch
argument_list|,
name|start
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
comment|/**      * Passes saved whitespace down the filter chain.      */
DECL|method|emitWhitespace
specifier|protected
name|void
name|emitWhitespace
parameter_list|()
throws|throws
name|SAXException
block|{
name|char
index|[]
name|data
init|=
operator|new
name|char
index|[
name|whitespace
operator|.
name|length
argument_list|()
index|]
decl_stmt|;
if|if
condition|(
name|whitespace
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
name|whitespace
operator|.
name|getChars
argument_list|(
literal|0
argument_list|,
name|data
operator|.
name|length
argument_list|,
name|data
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|whitespace
operator|.
name|setLength
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|super
operator|.
name|characters
argument_list|(
name|data
argument_list|,
literal|0
argument_list|,
name|data
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Discards saved whitespace.      */
DECL|method|clearWhitespace
specifier|protected
name|void
name|clearWhitespace
parameter_list|()
block|{
name|whitespace
operator|.
name|setLength
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/**      * Returns<var>true</var> if character is XML whitespace.      */
DECL|method|isXMLWhitespace
specifier|private
name|boolean
name|isXMLWhitespace
parameter_list|(
name|char
name|c
parameter_list|)
block|{
return|return
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
operator|||
name|c
operator|==
literal|'\r'
operator|||
name|c
operator|==
literal|'\n'
return|;
block|}
comment|////////////////////////////////////////////////////////////////////
comment|// Constants.
comment|////////////////////////////////////////////////////////////////////
DECL|field|SEEN_NOTHING
specifier|private
specifier|static
specifier|final
name|Object
name|SEEN_NOTHING
init|=
operator|new
name|Object
argument_list|()
decl_stmt|;
DECL|field|SEEN_ELEMENT
specifier|private
specifier|static
specifier|final
name|Object
name|SEEN_ELEMENT
init|=
operator|new
name|Object
argument_list|()
decl_stmt|;
DECL|field|SEEN_DATA
specifier|private
specifier|static
specifier|final
name|Object
name|SEEN_DATA
init|=
operator|new
name|Object
argument_list|()
decl_stmt|;
comment|////////////////////////////////////////////////////////////////////
comment|// Internal state.
comment|////////////////////////////////////////////////////////////////////
DECL|field|state
specifier|private
name|Object
name|state
init|=
name|SEEN_NOTHING
decl_stmt|;
DECL|field|stateStack
specifier|private
name|Stack
name|stateStack
init|=
operator|new
name|Stack
argument_list|()
decl_stmt|;
DECL|field|whitespace
specifier|private
name|StringBuffer
name|whitespace
init|=
operator|new
name|StringBuffer
argument_list|()
decl_stmt|;
block|}
end_class
begin_comment
comment|// end of DataUnformatFilter.java
end_comment
end_unit
