begin_unit
begin_comment
comment|/*  *  @(#)HTTPResponse.java				0.3-3 06/05/2001  *  *  This file is part of the HTTPClient package  *  Copyright (C) 1996-2001 Ronald Tschalär  *  *  This library is free software; you can redistribute it and/or  *  modify it under the terms of the GNU Lesser General Public  *  License as published by the Free Software Foundation; either  *  version 2 of the License, or (at your option) any later version.  *  *  This library is distributed in the hope that it will be useful,  *  but WITHOUT ANY WARRANTY; without even the implied warranty of  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU  *  Lesser General Public License for more details.  *  *  You shou  *  d have received a copy of the GNU Lesser General Public  *  License along with this library; if not, write to the Free  *  Software Foundation, Inc., 59 Temple Place, Suite 330, Boston,  *  MA 02111-1307, USA  *  *  For questions, suggestions, bug-reports, enhancement-requests etc.  *  I may be contacted at:  *  *  ronald@innovation.ch  *  *  The HTTPClient's home page is located at:  *  *  http://www.innovation.ch/java/HTTPClient/  *  */
end_comment
begin_package
DECL|package|HTTPClient
package|package
name|HTTPClient
package|;
end_package
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InterruptedIOException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ByteArrayInputStream
import|;
end_import
begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URL
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Date
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedList
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Enumeration
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import
begin_comment
comment|/**  * This defines the http-response class returned by the requests. It's basically  * a wrapper around the Response class which first lets all the modules handle  * the response before finally giving the info to the user.  *  * @author    Ronald Tschalär  * @created   29. Dezember 2001  * @version   0.3-3 06/05/2001  * @since     0.3  */
end_comment
begin_class
DECL|class|ByteBlock
class|class
name|ByteBlock
block|{
DECL|field|block
name|byte
index|[]
name|block
decl_stmt|;
DECL|field|length
name|int
name|length
decl_stmt|;
DECL|method|ByteBlock
name|ByteBlock
parameter_list|(
name|int
name|size
parameter_list|)
block|{
name|block
operator|=
operator|new
name|byte
index|[
name|size
index|]
expr_stmt|;
block|}
block|}
end_class
begin_class
DECL|class|HTTPResponse
specifier|public
class|class
name|HTTPResponse
implements|implements
name|HTTPClientModuleConstants
block|{
comment|/**      * the list of modules      */
DECL|field|modules
specifier|private
name|HTTPClientModule
index|[]
name|modules
decl_stmt|;
comment|/**      * the timeout for reads      */
DECL|field|timeout
specifier|private
name|int
name|timeout
decl_stmt|;
comment|/**      * the request      */
DECL|field|request
specifier|private
name|Request
name|request
init|=
literal|null
decl_stmt|;
comment|/**      * the current response      */
DECL|field|response
name|Response
name|response
init|=
literal|null
decl_stmt|;
comment|/**      * the HttpOutputStream to synchronize on      */
DECL|field|out_stream
specifier|private
name|HttpOutputStream
name|out_stream
init|=
literal|null
decl_stmt|;
comment|/**      * our input stream from the stream demux      */
DECL|field|inp_stream
specifier|private
name|InputStream
name|inp_stream
decl_stmt|;
comment|/**      * the status code returned.      */
DECL|field|StatusCode
specifier|private
name|int
name|StatusCode
decl_stmt|;
comment|/**      * the reason line associated with the status code.      */
DECL|field|ReasonLine
specifier|private
name|String
name|ReasonLine
decl_stmt|;
comment|/**      * the HTTP version of the response.      */
DECL|field|Version
specifier|private
name|String
name|Version
decl_stmt|;
comment|/**      * the original URI used.      */
DECL|field|OriginalURI
specifier|private
name|URI
name|OriginalURI
init|=
literal|null
decl_stmt|;
comment|/**      * the final URI of the document.      */
DECL|field|EffectiveURI
specifier|private
name|URI
name|EffectiveURI
init|=
literal|null
decl_stmt|;
comment|/**      * any headers which were received and do not fit in the above list.      */
DECL|field|Headers
specifier|private
name|CIHashtable
name|Headers
init|=
literal|null
decl_stmt|;
comment|/**      * any trailers which were received and do not fit in the above list.      */
DECL|field|Trailers
specifier|private
name|CIHashtable
name|Trailers
init|=
literal|null
decl_stmt|;
comment|/**      * the ContentLength of the data.      */
DECL|field|ContentLength
specifier|private
name|int
name|ContentLength
init|=
operator|-
literal|1
decl_stmt|;
comment|/**      * the data (body) returned.      */
DECL|field|Data
specifier|private
name|byte
index|[]
name|Data
init|=
literal|null
decl_stmt|;
comment|/**      * signals if we have got and parsed the headers yet?      */
DECL|field|initialized
specifier|private
name|boolean
name|initialized
init|=
literal|false
decl_stmt|;
comment|/**      * signals if we have got the trailers yet?      */
DECL|field|got_trailers
specifier|private
name|boolean
name|got_trailers
init|=
literal|false
decl_stmt|;
comment|/**      * marks this response as aborted (stop() in HTTPConnection)      */
DECL|field|aborted
specifier|private
name|boolean
name|aborted
init|=
literal|false
decl_stmt|;
comment|/**      * should the request be retried by the application?      */
DECL|field|retry
specifier|private
name|boolean
name|retry
init|=
literal|false
decl_stmt|;
comment|/**      * the method used in the request      */
DECL|field|method
specifier|private
name|String
name|method
init|=
literal|null
decl_stmt|;
comment|// Constructors
comment|/**      * Creates a new HTTPResponse.      *      * @param modules        the list of modules handling this response      * @param timeout        the timeout to be used on stream read()'s      * @param orig           Description of the Parameter      * @param readIncrement  Description of the Parameter      */
DECL|method|HTTPResponse
name|HTTPResponse
parameter_list|(
name|HTTPClientModule
index|[]
name|modules
parameter_list|,
name|int
name|timeout
parameter_list|,
name|Request
name|orig
parameter_list|,
name|int
name|readIncrement
parameter_list|)
block|{
name|this
operator|.
name|modules
operator|=
name|modules
expr_stmt|;
name|this
operator|.
name|timeout
operator|=
name|timeout
expr_stmt|;
try|try
block|{
name|int
name|qp
init|=
name|orig
operator|.
name|getRequestURI
argument_list|()
operator|.
name|indexOf
argument_list|(
literal|'?'
argument_list|)
decl_stmt|;
name|this
operator|.
name|OriginalURI
operator|=
operator|new
name|URI
argument_list|(
name|orig
operator|.
name|getConnection
argument_list|()
operator|.
name|getProtocol
argument_list|()
argument_list|,
literal|null
argument_list|,
name|orig
operator|.
name|getConnection
argument_list|()
operator|.
name|getHost
argument_list|()
argument_list|,
name|orig
operator|.
name|getConnection
argument_list|()
operator|.
name|getPort
argument_list|()
argument_list|,
name|qp
operator|<
literal|0
condition|?
name|orig
operator|.
name|getRequestURI
argument_list|()
else|:
name|orig
operator|.
name|getRequestURI
argument_list|()
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|qp
argument_list|)
argument_list|,
name|qp
operator|<
literal|0
condition|?
literal|null
else|:
name|orig
operator|.
name|getRequestURI
argument_list|()
operator|.
name|substring
argument_list|(
name|qp
operator|+
literal|1
argument_list|)
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ParseException
name|pe
parameter_list|)
block|{         }
name|this
operator|.
name|method
operator|=
name|orig
operator|.
name|getMethod
argument_list|()
expr_stmt|;
name|this
operator|.
name|readIncrement
operator|=
name|readIncrement
expr_stmt|;
block|}
DECL|field|readIncrement
name|int
name|readIncrement
init|=
literal|1000
decl_stmt|;
comment|/**      * Sets the readIncrement attribute of the HTTPResponse object      *      * @param readIncrement  The new readIncrement value      */
DECL|method|setReadIncrement
specifier|public
name|void
name|setReadIncrement
parameter_list|(
name|int
name|readIncrement
parameter_list|)
block|{
name|this
operator|.
name|readIncrement
operator|=
name|readIncrement
expr_stmt|;
block|}
comment|/**      * Gets the readIncrement attribute of the HTTPResponse object      *      * @return   The readIncrement value      */
DECL|method|getReadIncrement
specifier|public
name|int
name|getReadIncrement
parameter_list|()
block|{
return|return
name|this
operator|.
name|readIncrement
return|;
block|}
comment|/**      * @param req   the request      * @param resp  the response      */
DECL|method|set
name|void
name|set
parameter_list|(
name|Request
name|req
parameter_list|,
name|Response
name|resp
parameter_list|)
block|{
name|this
operator|.
name|request
operator|=
name|req
expr_stmt|;
name|this
operator|.
name|response
operator|=
name|resp
expr_stmt|;
name|resp
operator|.
name|http_resp
operator|=
name|this
expr_stmt|;
name|resp
operator|.
name|timeout
operator|=
name|timeout
expr_stmt|;
name|this
operator|.
name|aborted
operator|=
name|resp
operator|.
name|final_resp
expr_stmt|;
block|}
comment|/**      * @param req         the request      * @param out_stream  Description of the Parameter      */
DECL|method|set
name|void
name|set
parameter_list|(
name|Request
name|req
parameter_list|,
name|HttpOutputStream
name|out_stream
parameter_list|)
block|{
name|this
operator|.
name|request
operator|=
name|req
expr_stmt|;
name|this
operator|.
name|out_stream
operator|=
name|out_stream
expr_stmt|;
block|}
comment|// Methods
comment|/**      * Give the status code for this request. These are grouped as follows:      *<UL>      *<LI> 1xx - Informational (new in HTTP/1.1)      *<LI> 2xx - Success      *<LI> 3xx - Redirection      *<LI> 4xx - Client Error      *<LI> 5xx - Server Error      *</UL>      *      *      * @return                     The statusCode value      * @exception IOException      if any exception occurs on the socket.      * @exception ModuleException  if any module encounters an exception.      */
DECL|method|getStatusCode
specifier|public
specifier|final
name|int
name|getStatusCode
parameter_list|()
throws|throws
name|IOException
throws|,
name|ModuleException
block|{
if|if
condition|(
operator|!
name|initialized
condition|)
block|{
name|handleResponse
argument_list|()
expr_stmt|;
block|}
return|return
name|StatusCode
return|;
block|}
comment|/**      * Give the reason line associated with the status code.      *      * @return                     The reasonLine value      * @exception IOException      If any exception occurs on the socket.      * @exception ModuleException  if any module encounters an exception.      */
DECL|method|getReasonLine
specifier|public
specifier|final
name|String
name|getReasonLine
parameter_list|()
throws|throws
name|IOException
throws|,
name|ModuleException
block|{
if|if
condition|(
operator|!
name|initialized
condition|)
block|{
name|handleResponse
argument_list|()
expr_stmt|;
block|}
return|return
name|ReasonLine
return|;
block|}
comment|/**      * Get the HTTP version used for the response.      *      * @return                     The version value      * @exception IOException      If any exception occurs on the socket.      * @exception ModuleException  if any module encounters an exception.      */
DECL|method|getVersion
specifier|public
specifier|final
name|String
name|getVersion
parameter_list|()
throws|throws
name|IOException
throws|,
name|ModuleException
block|{
if|if
condition|(
operator|!
name|initialized
condition|)
block|{
name|handleResponse
argument_list|()
expr_stmt|;
block|}
return|return
name|Version
return|;
block|}
comment|/**      * Get the name and type of server.      *      * @return                     The server value      * @exception IOException      If any exception occurs on the socket.      * @exception ModuleException  if any module encounters an exception.      * @deprecated                 This method is a remnant of V0.1; use<code>getHeader("Server")</code>      *      instead.      * @see                        #getHeader(java.lang.String)      */
DECL|method|getServer
specifier|public
specifier|final
name|String
name|getServer
parameter_list|()
throws|throws
name|IOException
throws|,
name|ModuleException
block|{
if|if
condition|(
operator|!
name|initialized
condition|)
block|{
name|handleResponse
argument_list|()
expr_stmt|;
block|}
return|return
name|getHeader
argument_list|(
literal|"Server"
argument_list|)
return|;
block|}
comment|/**      * Get the original URI used in the request.      *      * @return   the URI used in primary request      */
DECL|method|getOriginalURI
specifier|public
specifier|final
name|URI
name|getOriginalURI
parameter_list|()
block|{
return|return
name|OriginalURI
return|;
block|}
comment|/**      * Get the final URL of the document. This is set if the original request      * was deferred via the "moved" (301, 302, or 303) return status.      *      * @return                     the effective URL, or null if no redirection      *      occured      * @exception IOException      If any exception occurs on the socket.      * @exception ModuleException  if any module encounters an exception.      * @deprecated                 use getEffectiveURI() instead      * @see                        #getEffectiveURI      */
DECL|method|getEffectiveURL
specifier|public
specifier|final
name|URL
name|getEffectiveURL
parameter_list|()
throws|throws
name|IOException
throws|,
name|ModuleException
block|{
if|if
condition|(
operator|!
name|initialized
condition|)
block|{
name|handleResponse
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|EffectiveURI
operator|!=
literal|null
condition|)
block|{
return|return
name|EffectiveURI
operator|.
name|toURL
argument_list|()
return|;
block|}
return|return
literal|null
return|;
block|}
comment|/**      * Get the final URI of the document. If the request was redirected via the      * "moved" (301, 302, 303, or 307) return status this returns the URI used      * in the last redirection; otherwise it returns the original URI.      *      * @return                     the effective URI      * @exception IOException      If any exception occurs on the socket.      * @exception ModuleException  if any module encounters an exception.      */
DECL|method|getEffectiveURI
specifier|public
specifier|final
name|URI
name|getEffectiveURI
parameter_list|()
throws|throws
name|IOException
throws|,
name|ModuleException
block|{
if|if
condition|(
operator|!
name|initialized
condition|)
block|{
name|handleResponse
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|EffectiveURI
operator|!=
literal|null
condition|)
block|{
return|return
name|EffectiveURI
return|;
block|}
return|return
name|OriginalURI
return|;
block|}
comment|/**      * Retrieves the value for a given header.      *      * @param hdr                  the header name.      * @return                     the value for the header, or null if      *      non-existent.      * @exception IOException      If any exception occurs on the socket.      * @exception ModuleException  if any module encounters an exception.      */
DECL|method|getHeader
specifier|public
name|String
name|getHeader
parameter_list|(
name|String
name|hdr
parameter_list|)
throws|throws
name|IOException
throws|,
name|ModuleException
block|{
if|if
condition|(
operator|!
name|initialized
condition|)
block|{
name|handleResponse
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
name|String
operator|)
name|Headers
operator|.
name|get
argument_list|(
name|hdr
operator|.
name|trim
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * Retrieves the value for a given header. The value is parsed as an int.      *      * @param hdr                        the header name.      * @return                           the value for the header if the header      *      exists      * @exception NumberFormatException  if the header's value is not a number      *      or if the header does not exist.      * @exception IOException            if any exception occurs on the socket.      * @exception ModuleException        if any module encounters an exception.      */
DECL|method|getHeaderAsInt
specifier|public
name|int
name|getHeaderAsInt
parameter_list|(
name|String
name|hdr
parameter_list|)
throws|throws
name|IOException
throws|,
name|ModuleException
throws|,
name|NumberFormatException
block|{
name|String
name|val
init|=
name|getHeader
argument_list|(
name|hdr
argument_list|)
decl_stmt|;
if|if
condition|(
name|val
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NumberFormatException
argument_list|(
literal|"null"
argument_list|)
throw|;
block|}
return|return
name|Integer
operator|.
name|parseInt
argument_list|(
name|val
argument_list|)
return|;
block|}
comment|/**      * Retrieves the value for a given header. The value is parsed as a date; if      * this fails it is parsed as a long representing the number of seconds      * since 12:00 AM, Jan 1st, 1970. If this also fails an exception is thrown.      *<br>      * Note: When sending dates use Util.httpDate().      *      * @param hdr                           the header name.      * @return                              the value for the header, or null if      *      non-existent.      * @exception IllegalArgumentException  if the header's value is neither a      *      legal date nor a number.      * @exception IOException               if any exception occurs on the      *      socket.      * @exception ModuleException           if any module encounters an      *      exception.      */
DECL|method|getHeaderAsDate
specifier|public
name|Date
name|getHeaderAsDate
parameter_list|(
name|String
name|hdr
parameter_list|)
throws|throws
name|IOException
throws|,
name|IllegalArgumentException
throws|,
name|ModuleException
block|{
name|String
name|raw_date
init|=
name|getHeader
argument_list|(
name|hdr
argument_list|)
decl_stmt|;
if|if
condition|(
name|raw_date
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
comment|// asctime() format is missing an explicit GMT specifier
if|if
condition|(
name|raw_date
operator|.
name|toUpperCase
argument_list|()
operator|.
name|indexOf
argument_list|(
literal|"GMT"
argument_list|)
operator|==
operator|-
literal|1
operator|&&
name|raw_date
operator|.
name|indexOf
argument_list|(
literal|' '
argument_list|)
operator|>
literal|0
condition|)
block|{
name|raw_date
operator|+=
literal|" GMT"
expr_stmt|;
block|}
name|Date
name|date
decl_stmt|;
try|try
block|{
name|date
operator|=
name|Util
operator|.
name|parseHttpDate
argument_list|(
name|raw_date
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|iae
parameter_list|)
block|{
comment|// some servers erroneously send a number, so let's try that
name|long
name|time
decl_stmt|;
try|try
block|{
name|time
operator|=
name|Long
operator|.
name|parseLong
argument_list|(
name|raw_date
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|nfe
parameter_list|)
block|{
throw|throw
name|iae
throw|;
block|}
comment|// give up
if|if
condition|(
name|time
operator|<
literal|0
condition|)
block|{
name|time
operator|=
literal|0
expr_stmt|;
block|}
name|date
operator|=
operator|new
name|Date
argument_list|(
name|time
operator|*
literal|1000L
argument_list|)
expr_stmt|;
block|}
return|return
name|date
return|;
block|}
comment|/**      * Returns an enumeration of all the headers available via getHeader().      *      * @return                     Description of the Return Value      * @exception IOException      If any exception occurs on the socket.      * @exception ModuleException  if any module encounters an exception.      */
DECL|method|listHeaders
specifier|public
name|Enumeration
name|listHeaders
parameter_list|()
throws|throws
name|IOException
throws|,
name|ModuleException
block|{
if|if
condition|(
operator|!
name|initialized
condition|)
block|{
name|handleResponse
argument_list|()
expr_stmt|;
block|}
return|return
name|Headers
operator|.
name|keys
argument_list|()
return|;
block|}
comment|/**      * Retrieves the value for a given trailer. This should not be invoked until      * all response data has been read. If invoked before it will call<code>getData()</code>      * to force the data to be read.      *      * @param trailer              the trailer name.      * @return                     the value for the trailer, or null if      *      non-existent.      * @exception IOException      If any exception occurs on the socket.      * @exception ModuleException  if any module encounters an exception.      * @see                        #getData()      */
DECL|method|getTrailer
specifier|public
name|String
name|getTrailer
parameter_list|(
name|String
name|trailer
parameter_list|)
throws|throws
name|IOException
throws|,
name|ModuleException
block|{
if|if
condition|(
operator|!
name|got_trailers
condition|)
block|{
name|getTrailers
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
name|String
operator|)
name|Trailers
operator|.
name|get
argument_list|(
name|trailer
operator|.
name|trim
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * Retrieves the value for a given tailer. The value is parsed as an int.      *      * @param trailer                    the tailer name.      * @return                           the value for the trailer if the      *      trailer exists      * @exception NumberFormatException  if the trailer's value is not a number      *      or if the trailer does not exist.      * @exception IOException            if any exception occurs on the socket.      * @exception ModuleException        if any module encounters an exception.      */
DECL|method|getTrailerAsInt
specifier|public
name|int
name|getTrailerAsInt
parameter_list|(
name|String
name|trailer
parameter_list|)
throws|throws
name|IOException
throws|,
name|ModuleException
throws|,
name|NumberFormatException
block|{
name|String
name|val
init|=
name|getTrailer
argument_list|(
name|trailer
argument_list|)
decl_stmt|;
if|if
condition|(
name|val
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NumberFormatException
argument_list|(
literal|"null"
argument_list|)
throw|;
block|}
return|return
name|Integer
operator|.
name|parseInt
argument_list|(
name|val
argument_list|)
return|;
block|}
comment|/**      * Retrieves the value for a given trailer. The value is parsed as a date;      * if this fails it is parsed as a long representing the number of seconds      * since 12:00 AM, Jan 1st, 1970. If this also fails an      * IllegalArgumentException is thrown.<br>      * Note: When sending dates use Util.httpDate().      *      * @param trailer                       the trailer name.      * @return                              the value for the trailer, or null      *      if non-existent.      * @exception IllegalArgumentException  if the trailer's value is neither a      *      legal date nor a number.      * @exception IOException               if any exception occurs on the      *      socket.      * @exception ModuleException           if any module encounters an      *      exception.      */
DECL|method|getTrailerAsDate
specifier|public
name|Date
name|getTrailerAsDate
parameter_list|(
name|String
name|trailer
parameter_list|)
throws|throws
name|IOException
throws|,
name|IllegalArgumentException
throws|,
name|ModuleException
block|{
name|String
name|raw_date
init|=
name|getTrailer
argument_list|(
name|trailer
argument_list|)
decl_stmt|;
if|if
condition|(
name|raw_date
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
comment|// asctime() format is missing an explicit GMT specifier
if|if
condition|(
name|raw_date
operator|.
name|toUpperCase
argument_list|()
operator|.
name|indexOf
argument_list|(
literal|"GMT"
argument_list|)
operator|==
operator|-
literal|1
operator|&&
name|raw_date
operator|.
name|indexOf
argument_list|(
literal|' '
argument_list|)
operator|>
literal|0
condition|)
block|{
name|raw_date
operator|+=
literal|" GMT"
expr_stmt|;
block|}
name|Date
name|date
decl_stmt|;
try|try
block|{
name|date
operator|=
name|Util
operator|.
name|parseHttpDate
argument_list|(
name|raw_date
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|iae
parameter_list|)
block|{
comment|// some servers erroneously send a number, so let's try that
name|long
name|time
decl_stmt|;
try|try
block|{
name|time
operator|=
name|Long
operator|.
name|parseLong
argument_list|(
name|raw_date
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|nfe
parameter_list|)
block|{
throw|throw
name|iae
throw|;
block|}
comment|// give up
if|if
condition|(
name|time
operator|<
literal|0
condition|)
block|{
name|time
operator|=
literal|0
expr_stmt|;
block|}
name|date
operator|=
operator|new
name|Date
argument_list|(
name|time
operator|*
literal|1000L
argument_list|)
expr_stmt|;
block|}
return|return
name|date
return|;
block|}
comment|/**      * Returns an enumeration of all the trailers available via getTrailer().      *      * @return                     Description of the Return Value      * @exception IOException      If any exception occurs on the socket.      * @exception ModuleException  if any module encounters an exception.      */
DECL|method|listTrailers
specifier|public
name|Enumeration
name|listTrailers
parameter_list|()
throws|throws
name|IOException
throws|,
name|ModuleException
block|{
if|if
condition|(
operator|!
name|got_trailers
condition|)
block|{
name|getTrailers
argument_list|()
expr_stmt|;
block|}
return|return
name|Trailers
operator|.
name|keys
argument_list|()
return|;
block|}
comment|/**      * Reads all the response data into a byte array. Note that this method      * won't return until<em>all</em> the data has been received (so for      * instance don't invoke this method if the server is doing a server push).      * If<code>getInputStream()</code> had been previously invoked then this      * method only returns any unread data remaining on the stream and then      * closes it.<P>      *      * Note to the unwary: code like<PRE>      *     System.out.println("The data: " + resp.getData())      *</PRE> will probably not do what you want - use<PRE>      *     System.out.println("The data: " + resp.getText())      *</PRE> instead.      *      * @return                     an array containing the data (body) returned.      *      If no data was returned then it's set to a zero-length array.      * @exception IOException      If any io exception occured while reading the      *      data      * @exception ModuleException  if any module encounters an exception.      * @see                        #getInputStream()      */
DECL|method|getData
specifier|public
name|byte
index|[]
name|getData
parameter_list|()
throws|throws
name|IOException
throws|,
name|ModuleException
block|{
return|return
name|getData
argument_list|(
operator|-
literal|1
argument_list|)
return|;
block|}
DECL|method|getData
specifier|public
name|byte
index|[]
name|getData
parameter_list|(
name|int
name|max
parameter_list|)
throws|throws
name|IOException
throws|,
name|ModuleException
block|{
if|if
condition|(
operator|!
name|initialized
condition|)
block|{
name|handleResponse
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|Data
operator|==
literal|null
condition|)
block|{
try|try
block|{
name|readResponseData
argument_list|(
name|inp_stream
argument_list|,
name|max
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedIOException
name|ie
parameter_list|)
block|{
comment|// don't intercept
throw|throw
name|ie
throw|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|Log
operator|.
name|write
argument_list|(
name|Log
operator|.
name|RESP
argument_list|,
literal|"HResp: (\""
operator|+
name|method
operator|+
literal|" "
operator|+
name|OriginalURI
operator|.
name|getPathAndQuery
argument_list|()
operator|+
literal|"\")"
argument_list|)
expr_stmt|;
name|Log
operator|.
name|write
argument_list|(
name|Log
operator|.
name|RESP
argument_list|,
literal|"       "
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
try|try
block|{
name|inp_stream
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{                 }
throw|throw
name|ioe
throw|;
block|}
name|inp_stream
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
return|return
name|Data
return|;
block|}
comment|/**      * Reads all the response data into a buffer and turns it into a string      * using the appropriate character converter. Since this uses {@link      * #getData() getData()}, the caveats of that method apply here as well.      *      * @return                     the body as a String. If no data was returned      *      then an empty string is returned.      * @exception IOException      If any io exception occured while reading the      *      data, or if the content is not text      * @exception ModuleException  if any module encounters an exception.      * @exception ParseException   if an error occured trying to parse the      *      content-type header field      * @see                        #getData()      */
DECL|method|getText
specifier|public
specifier|synchronized
name|String
name|getText
parameter_list|()
throws|throws
name|IOException
throws|,
name|ModuleException
throws|,
name|ParseException
block|{
name|String
name|ct
init|=
name|getHeader
argument_list|(
literal|"Content-Type"
argument_list|)
decl_stmt|;
if|if
condition|(
name|ct
operator|==
literal|null
operator|||
operator|!
name|ct
operator|.
name|toLowerCase
argument_list|()
operator|.
name|startsWith
argument_list|(
literal|"text/"
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Content-Type `"
operator|+
name|ct
operator|+
literal|"' is not a text type"
argument_list|)
throw|;
block|}
name|String
name|charset
init|=
name|Util
operator|.
name|getParameter
argument_list|(
literal|"charset"
argument_list|,
name|ct
argument_list|)
decl_stmt|;
if|if
condition|(
name|charset
operator|==
literal|null
condition|)
block|{
name|charset
operator|=
literal|"ISO-8859-1"
expr_stmt|;
block|}
return|return
operator|new
name|String
argument_list|(
name|getData
argument_list|()
argument_list|,
name|charset
argument_list|)
return|;
block|}
comment|/**      * Gets an input stream from which the returned data can be read. Note that      * if<code>getData()</code> had been previously invoked it will actually      * return a ByteArrayInputStream created from that data.      *      * @return                     the InputStream.      * @exception IOException      If any exception occurs on the socket.      * @exception ModuleException  if any module encounters an exception.      * @see                        #getData()      */
DECL|method|getInputStream
specifier|public
specifier|synchronized
name|InputStream
name|getInputStream
parameter_list|()
throws|throws
name|IOException
throws|,
name|ModuleException
block|{
if|if
condition|(
operator|!
name|initialized
condition|)
block|{
name|handleResponse
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|Data
operator|==
literal|null
condition|)
block|{
return|return
name|inp_stream
return|;
block|}
else|else
block|{
name|getData
argument_list|()
expr_stmt|;
comment|// ensure complete data is read
return|return
operator|new
name|ByteArrayInputStream
argument_list|(
name|Data
argument_list|)
return|;
block|}
block|}
comment|/**      * Should the request be retried by the application? If the application used      * an<var>HttpOutputStream</var> in the request then various modules (such      * as the redirection and authorization modules) are not able to resend the      * request themselves. Instead, it becomes the application's responsibility.      * The application can check this flag, and if it's set, resend the exact      * same request. The modules such as the RedirectionModule or      * AuthorizationModule will then recognize the resend and fix up or redirect      * the request as required (i.e. they defer their normal action until the      * resend).<P>      *      * If the application resends the request then it<strong>must</strong> use      * the same<var>HttpOutputStream</var> instance. This is because the      * modules use this to recognize the retried request and to perform the      * necessary work on the request before it's sent.<P>      *      * Here is a skeleton example of usage:<PRE>      *     OutputStream out = new HttpOutputStream(1234);      *     do      *     {      *         rsp = con.Post("/cgi-bin/my_cgi", out);      *         out.write(...);      *         out.close();      *     } while (rsp.retryRequest());      *      *     if (rsp.getStatusCode()>= 300)      *         ...      *</PRE><P>      *      * Note that for this to ever return true, the java system property<var>      * HTTPClient.deferStreamed</var> must be set to true at the beginning of      * the application (before the HTTPConnection class is loaded). This      * prevents unwary applications from causing inadvertent memory leaks. If an      * application does set this, then it<em>must</em> resend any request whose      * response returns true here in order to prevent memory leaks (a switch to      * JDK 1.2 will allow us to use weak references and eliminate this problem).      *      * @return                     true if the request should be retried.      * @exception IOException      If any exception occurs on the socket.      * @exception ModuleException  if any module encounters an exception.      */
DECL|method|retryRequest
specifier|public
name|boolean
name|retryRequest
parameter_list|()
throws|throws
name|IOException
throws|,
name|ModuleException
block|{
if|if
condition|(
operator|!
name|initialized
condition|)
block|{
try|try
block|{
name|handleResponse
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|RetryException
name|re
parameter_list|)
block|{
name|this
operator|.
name|retry
operator|=
name|response
operator|.
name|retry
expr_stmt|;
block|}
block|}
return|return
name|retry
return|;
block|}
comment|/**      * produces a full list of headers and their values, one per line.      *      * @return   a string containing the headers      */
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
if|if
condition|(
operator|!
name|initialized
condition|)
block|{
try|try
block|{
name|handleResponse
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|e
operator|instanceof
name|InterruptedIOException
operator|)
condition|)
block|{
name|Log
operator|.
name|write
argument_list|(
name|Log
operator|.
name|RESP
argument_list|,
literal|"HResp: (\""
operator|+
name|method
operator|+
literal|" "
operator|+
name|OriginalURI
operator|.
name|getPathAndQuery
argument_list|()
operator|+
literal|"\")"
argument_list|)
expr_stmt|;
name|Log
operator|.
name|write
argument_list|(
name|Log
operator|.
name|RESP
argument_list|,
literal|"       "
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
return|return
literal|"Failed to read headers: "
operator|+
name|e
return|;
block|}
block|}
name|String
name|nl
init|=
name|System
operator|.
name|getProperty
argument_list|(
literal|"line.separator"
argument_list|,
literal|"\n"
argument_list|)
decl_stmt|;
name|StringBuffer
name|str
init|=
operator|new
name|StringBuffer
argument_list|(
name|Version
argument_list|)
decl_stmt|;
name|str
operator|.
name|append
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|str
operator|.
name|append
argument_list|(
name|StatusCode
argument_list|)
expr_stmt|;
name|str
operator|.
name|append
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|str
operator|.
name|append
argument_list|(
name|ReasonLine
argument_list|)
expr_stmt|;
name|str
operator|.
name|append
argument_list|(
name|nl
argument_list|)
expr_stmt|;
if|if
condition|(
name|EffectiveURI
operator|!=
literal|null
condition|)
block|{
name|str
operator|.
name|append
argument_list|(
literal|"Effective-URI: "
argument_list|)
expr_stmt|;
name|str
operator|.
name|append
argument_list|(
name|EffectiveURI
argument_list|)
expr_stmt|;
name|str
operator|.
name|append
argument_list|(
name|nl
argument_list|)
expr_stmt|;
block|}
name|Enumeration
name|hdr_list
init|=
name|Headers
operator|.
name|keys
argument_list|()
decl_stmt|;
while|while
condition|(
name|hdr_list
operator|.
name|hasMoreElements
argument_list|()
condition|)
block|{
name|String
name|hdr
init|=
operator|(
name|String
operator|)
name|hdr_list
operator|.
name|nextElement
argument_list|()
decl_stmt|;
name|str
operator|.
name|append
argument_list|(
name|hdr
argument_list|)
expr_stmt|;
name|str
operator|.
name|append
argument_list|(
literal|": "
argument_list|)
expr_stmt|;
name|str
operator|.
name|append
argument_list|(
name|Headers
operator|.
name|get
argument_list|(
name|hdr
argument_list|)
argument_list|)
expr_stmt|;
name|str
operator|.
name|append
argument_list|(
name|nl
argument_list|)
expr_stmt|;
block|}
return|return
name|str
operator|.
name|toString
argument_list|()
return|;
block|}
comment|// Helper Methods
comment|/**      * Gets the modules attribute of the HTTPResponse object      *      * @return   The modules value      */
DECL|method|getModules
name|HTTPClientModule
index|[]
name|getModules
parameter_list|()
block|{
return|return
name|modules
return|;
block|}
comment|/**      * Processes a Response. This is done by calling the response handler in      * each module. When all is done, the various fields of this instance are      * intialized from the last Response.      *      * @return                     true if a new request was generated. This is      *      used for internal subrequests only      * @exception IOException      if any handler throws an IOException.      * @exception ModuleException  if any module encounters an exception.      */
DECL|method|handleResponse
specifier|synchronized
name|boolean
name|handleResponse
parameter_list|()
throws|throws
name|IOException
throws|,
name|ModuleException
block|{
if|if
condition|(
name|initialized
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|/*          *  first get the response if necessary          */
if|if
condition|(
name|out_stream
operator|!=
literal|null
condition|)
block|{
name|response
operator|=
name|out_stream
operator|.
name|getResponse
argument_list|()
expr_stmt|;
name|response
operator|.
name|http_resp
operator|=
name|this
expr_stmt|;
name|out_stream
operator|=
literal|null
expr_stmt|;
block|}
comment|/*          *  go through modules and handle them          */
name|doModules
label|:
while|while
condition|(
literal|true
condition|)
block|{
name|Phase1
label|:
for|for
control|(
name|int
name|idx
init|=
literal|0
init|;
name|idx
operator|<
name|modules
operator|.
name|length
operator|&&
operator|!
name|aborted
condition|;
name|idx
operator|++
control|)
block|{
try|try
block|{
name|modules
index|[
name|idx
index|]
operator|.
name|responsePhase1Handler
argument_list|(
name|response
argument_list|,
name|request
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|RetryException
name|re
parameter_list|)
block|{
if|if
condition|(
name|re
operator|.
name|restart
condition|)
block|{
continue|continue
name|doModules
continue|;
block|}
else|else
block|{
throw|throw
name|re
throw|;
block|}
block|}
block|}
name|Phase2
label|:
for|for
control|(
name|int
name|idx
init|=
literal|0
init|;
name|idx
operator|<
name|modules
operator|.
name|length
operator|&&
operator|!
name|aborted
condition|;
name|idx
operator|++
control|)
block|{
name|int
name|sts
init|=
name|modules
index|[
name|idx
index|]
operator|.
name|responsePhase2Handler
argument_list|(
name|response
argument_list|,
name|request
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|sts
condition|)
block|{
case|case
name|RSP_CONTINUE
case|:
comment|// continue processing
break|break;
case|case
name|RSP_RESTART
case|:
comment|// restart response processing
name|idx
operator|=
operator|-
literal|1
expr_stmt|;
continue|continue
name|doModules
continue|;
case|case
name|RSP_SHORTCIRC
case|:
comment|// stop processing and return
break|break
name|doModules
break|;
case|case
name|RSP_REQUEST
case|:
comment|// go to phase 1
case|case
name|RSP_NEWCON_REQ
case|:
comment|// process the request using a new con
name|response
operator|.
name|getInputStream
argument_list|()
operator|.
name|close
argument_list|()
expr_stmt|;
if|if
condition|(
name|handle_trailers
condition|)
block|{
name|invokeTrailerHandlers
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|request
operator|.
name|internal_subrequest
condition|)
block|{
return|return
literal|true
return|;
block|}
name|request
operator|.
name|getConnection
argument_list|()
operator|.
name|handleRequest
argument_list|(
name|request
argument_list|,
name|this
argument_list|,
name|response
argument_list|,
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|initialized
condition|)
block|{
break|break
name|doModules
break|;
block|}
name|idx
operator|=
operator|-
literal|1
expr_stmt|;
continue|continue
name|doModules
continue|;
case|case
name|RSP_SEND
case|:
comment|// send the request immediately
case|case
name|RSP_NEWCON_SND
case|:
comment|// send the request using a new con
name|response
operator|.
name|getInputStream
argument_list|()
operator|.
name|close
argument_list|()
expr_stmt|;
if|if
condition|(
name|handle_trailers
condition|)
block|{
name|invokeTrailerHandlers
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|request
operator|.
name|internal_subrequest
condition|)
block|{
return|return
literal|true
return|;
block|}
name|request
operator|.
name|getConnection
argument_list|()
operator|.
name|handleRequest
argument_list|(
name|request
argument_list|,
name|this
argument_list|,
name|response
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|idx
operator|=
operator|-
literal|1
expr_stmt|;
continue|continue
name|doModules
continue|;
default|default:
comment|// not valid
throw|throw
operator|new
name|Error
argument_list|(
literal|"HTTPClient Internal Error: invalid status"
operator|+
literal|" "
operator|+
name|sts
operator|+
literal|" returned by module "
operator|+
name|modules
index|[
name|idx
index|]
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
throw|;
block|}
block|}
name|Phase3
label|:
for|for
control|(
name|int
name|idx
init|=
literal|0
init|;
name|idx
operator|<
name|modules
operator|.
name|length
operator|&&
operator|!
name|aborted
condition|;
name|idx
operator|++
control|)
block|{
name|modules
index|[
name|idx
index|]
operator|.
name|responsePhase3Handler
argument_list|(
name|response
argument_list|,
name|request
argument_list|)
expr_stmt|;
block|}
break|break
name|doModules
break|;
block|}
comment|/*          *  force a read on the response in case none of the modules did          */
name|response
operator|.
name|getStatusCode
argument_list|()
expr_stmt|;
comment|/*          *  all done, so copy data          */
if|if
condition|(
operator|!
name|request
operator|.
name|internal_subrequest
condition|)
block|{
name|init
argument_list|(
name|response
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|handle_trailers
condition|)
block|{
name|invokeTrailerHandlers
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
comment|/**      * Copies the relevant fields from Response and marks this as initialized.      *      * @param resp  the Response class to copy from      */
DECL|method|init
name|void
name|init
parameter_list|(
name|Response
name|resp
parameter_list|)
block|{
if|if
condition|(
name|initialized
condition|)
block|{
return|return;
block|}
name|this
operator|.
name|StatusCode
operator|=
name|resp
operator|.
name|StatusCode
expr_stmt|;
name|this
operator|.
name|ReasonLine
operator|=
name|resp
operator|.
name|ReasonLine
expr_stmt|;
name|this
operator|.
name|Version
operator|=
name|resp
operator|.
name|Version
expr_stmt|;
name|this
operator|.
name|EffectiveURI
operator|=
name|resp
operator|.
name|EffectiveURI
expr_stmt|;
name|this
operator|.
name|ContentLength
operator|=
name|resp
operator|.
name|ContentLength
expr_stmt|;
name|this
operator|.
name|Headers
operator|=
name|resp
operator|.
name|Headers
expr_stmt|;
name|this
operator|.
name|inp_stream
operator|=
name|resp
operator|.
name|inp_stream
expr_stmt|;
name|this
operator|.
name|Data
operator|=
name|resp
operator|.
name|Data
expr_stmt|;
name|this
operator|.
name|retry
operator|=
name|resp
operator|.
name|retry
expr_stmt|;
name|initialized
operator|=
literal|true
expr_stmt|;
block|}
DECL|field|handle_trailers
specifier|private
name|boolean
name|handle_trailers
init|=
literal|false
decl_stmt|;
DECL|field|trailers_handled
specifier|private
name|boolean
name|trailers_handled
init|=
literal|false
decl_stmt|;
comment|/**      * This is invoked by the RespInputStream when it is close()'d. It just      * invokes the trailer handler in each module.      *      * @param force                invoke the handlers even if not initialized      *      yet?      * @exception IOException      if thrown by any module      * @exception ModuleException  if thrown by any module      */
DECL|method|invokeTrailerHandlers
name|void
name|invokeTrailerHandlers
parameter_list|(
name|boolean
name|force
parameter_list|)
throws|throws
name|IOException
throws|,
name|ModuleException
block|{
if|if
condition|(
name|trailers_handled
condition|)
block|{
return|return;
block|}
if|if
condition|(
operator|!
name|force
operator|&&
operator|!
name|initialized
condition|)
block|{
name|handle_trailers
operator|=
literal|true
expr_stmt|;
return|return;
block|}
for|for
control|(
name|int
name|idx
init|=
literal|0
init|;
name|idx
operator|<
name|modules
operator|.
name|length
operator|&&
operator|!
name|aborted
condition|;
name|idx
operator|++
control|)
block|{
name|modules
index|[
name|idx
index|]
operator|.
name|trailerHandler
argument_list|(
name|response
argument_list|,
name|request
argument_list|)
expr_stmt|;
block|}
name|trailers_handled
operator|=
literal|true
expr_stmt|;
block|}
comment|/**      * Mark this request as having been aborted. It's invoked by      * HTTPConnection.stop().      */
DECL|method|markAborted
name|void
name|markAborted
parameter_list|()
block|{
name|aborted
operator|=
literal|true
expr_stmt|;
block|}
comment|/**      * Gets any trailers from the response if we haven't already done so.      *      * @exception IOException      Description of the Exception      * @exception ModuleException  Description of the Exception      */
DECL|method|getTrailers
specifier|private
specifier|synchronized
name|void
name|getTrailers
parameter_list|()
throws|throws
name|IOException
throws|,
name|ModuleException
block|{
if|if
condition|(
name|got_trailers
condition|)
block|{
return|return;
block|}
if|if
condition|(
operator|!
name|initialized
condition|)
block|{
name|handleResponse
argument_list|()
expr_stmt|;
block|}
name|response
operator|.
name|getTrailer
argument_list|(
literal|"Any"
argument_list|)
expr_stmt|;
name|Trailers
operator|=
name|response
operator|.
name|Trailers
expr_stmt|;
name|got_trailers
operator|=
literal|true
expr_stmt|;
name|invokeTrailerHandlers
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
comment|/**      * Reads the response data received. Does not return until either      * Content-Length bytes have been read or EOF is reached.      *      * @param inp              Description of the Parameter      * @exception IOException  if any read on the input stream fails      * @inp                    the input stream from which to read the data      */
DECL|method|readResponseData
specifier|private
name|void
name|readResponseData
parameter_list|(
name|InputStream
name|inp
parameter_list|,
name|int
name|max
parameter_list|)
throws|throws
name|IOException
throws|,
name|ModuleException
block|{
name|boolean
name|readUnlimited
init|=
operator|(
name|max
operator|==
operator|-
literal|1
operator|)
decl_stmt|;
if|if
condition|(
name|ContentLength
operator|==
literal|0
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|Data
operator|==
literal|null
condition|)
block|{
name|Data
operator|=
operator|new
name|byte
index|[
literal|0
index|]
expr_stmt|;
block|}
comment|// read response data
name|int
name|off
init|=
name|Data
operator|.
name|length
decl_stmt|;
try|try
block|{
comment|// check Content-length header in case CE-Module removed it
if|if
condition|(
name|getHeader
argument_list|(
literal|"Content-Length"
argument_list|)
operator|!=
literal|null
condition|)
block|{
name|int
name|rcvd
init|=
literal|0
decl_stmt|;
name|int
name|total
init|=
name|max
operator|>
literal|1
condition|?
name|Math
operator|.
name|min
argument_list|(
name|ContentLength
argument_list|,
name|max
argument_list|)
else|:
name|ContentLength
decl_stmt|;
comment|//System.out.println("Reading with max file size: " + total);
name|Data
operator|=
operator|new
name|byte
index|[
name|total
index|]
expr_stmt|;
do|do
block|{
name|off
operator|+=
name|rcvd
expr_stmt|;
name|rcvd
operator|=
name|inp
operator|.
name|read
argument_list|(
name|Data
argument_list|,
name|off
argument_list|,
name|total
operator|-
name|off
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|rcvd
operator|!=
operator|-
literal|1
operator|&&
name|off
operator|+
name|rcvd
operator|<
name|total
condition|)
do|;
comment|// if max< ContentLength (&& max> -1): lose the rest
comment|/*if(total< ContentLength)                 {                     inp.skip(ContentLength - total);                 }*/
comment|/*                  *  Don't do this!                  *  If we do, then getData() won't work after a getInputStream()                  *  because we'll never get all the expected data. Instead, let                  *  the underlying RespInputStream throw the EOF.                  *  if (rcvd == -1)	// premature EOF                  *  {                  *  throw new EOFException("Encountered premature EOF while " +                  *  "reading headers: received " + off +                  *  " bytes instead of the expected " +                  *  ContentLength + " bytes");                  *  }                  */
block|}
else|else
block|{
comment|//System.out.println("Reading with unknown file size");
name|java
operator|.
name|util
operator|.
name|LinkedList
name|blocks
init|=
operator|new
name|java
operator|.
name|util
operator|.
name|LinkedList
argument_list|()
decl_stmt|;
comment|//System.out.println("new LinkedList()");
name|int
name|total
init|=
literal|0
decl_stmt|;
name|int
name|secondBlockSize
init|=
literal|10
operator|*
literal|2000
decl_stmt|;
name|byte
index|[]
name|secondBlock
init|=
operator|new
name|byte
index|[
name|secondBlockSize
index|]
decl_stmt|;
comment|//System.out.println("new byte[" + secondBlockSize + "]");
name|int
name|offInSecondBlock
init|=
literal|0
decl_stmt|;
name|int
name|rcvd
init|=
literal|0
decl_stmt|;
do|do
block|{
name|int
name|bytesToRead
init|=
name|secondBlockSize
operator|-
name|offInSecondBlock
decl_stmt|;
if|if
condition|(
name|bytesToRead
operator|<
literal|1
condition|)
block|{
comment|// System.out.println("adding block to list...");
name|blocks
operator|.
name|addLast
argument_list|(
name|secondBlock
argument_list|)
expr_stmt|;
name|secondBlock
operator|=
operator|new
name|byte
index|[
name|secondBlockSize
index|]
expr_stmt|;
comment|//System.out.println("new byte[" + secondBlockSize + "]");
name|offInSecondBlock
operator|=
literal|0
expr_stmt|;
name|bytesToRead
operator|=
name|secondBlockSize
expr_stmt|;
block|}
name|rcvd
operator|=
name|inp
operator|.
name|read
argument_list|(
name|secondBlock
argument_list|,
name|offInSecondBlock
argument_list|,
name|bytesToRead
argument_list|)
expr_stmt|;
comment|//System.out.println("read " + rcvd);
comment|// rcvd is usually<< secondBlockSize
if|if
condition|(
name|rcvd
operator|!=
operator|-
literal|1
condition|)
block|{
name|offInSecondBlock
operator|+=
name|rcvd
expr_stmt|;
name|total
operator|+=
name|rcvd
expr_stmt|;
name|max
operator|-=
name|rcvd
expr_stmt|;
block|}
block|}
do|while
condition|(
name|rcvd
operator|!=
operator|-
literal|1
operator|&&
operator|(
name|readUnlimited
operator|||
name|max
operator|>
literal|0
operator|)
condition|)
do|;
comment|// now we have: 1 x the last block as "secondBlock" + 0...n x blocks in the list
name|Data
operator|=
operator|new
name|byte
index|[
name|total
index|]
expr_stmt|;
comment|// I can't see how to do it without this second buffer
comment|//System.out.println("new byte[" + total + "]");
name|int
name|offset
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|blocks
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|byte
index|[]
name|block
init|=
operator|(
name|byte
index|[]
operator|)
name|blocks
operator|.
name|removeFirst
argument_list|()
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|block
argument_list|,
literal|0
argument_list|,
name|Data
argument_list|,
name|offset
argument_list|,
name|block
operator|.
name|length
argument_list|)
expr_stmt|;
comment|//System.out.println("System.arraycopy(" + block.length + ")");
name|offset
operator|+=
name|block
operator|.
name|length
expr_stmt|;
block|}
if|if
condition|(
name|offInSecondBlock
operator|>
literal|0
condition|)
block|{
comment|//System.out.println("System.arraycopy(" + offInSecondBlock + ")");
name|System
operator|.
name|arraycopy
argument_list|(
name|secondBlock
argument_list|,
literal|0
argument_list|,
name|Data
argument_list|,
name|offset
argument_list|,
name|offInSecondBlock
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|Data
operator|=
name|Util
operator|.
name|resizeArray
argument_list|(
name|Data
argument_list|,
name|off
argument_list|)
expr_stmt|;
throw|throw
name|ioe
throw|;
block|}
finally|finally
block|{
try|try
block|{
name|inp
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{             }
block|}
block|}
comment|/*      * Reads the response data received. Does not return until either      * Content-Length bytes have been read or EOF is reached.      *      * @param inp                  Description of the Parameter      * @exception IOException      if any read on the input stream fails      * @exception ModuleException  Description of the Exception      * @inp                        the input stream from which to read the data      *     private void readResponseData(InputStream inp)         throws IOException, ModuleException     {         if (ContentLength == 0)         {             return;         }          if (Data == null)         {             Data = new byte[0];         }          // read response data          int off = Data.length;          LinkedList blocks = new java.util.LinkedList();          // check Content-length header in case CE-Module removed it         if (getHeader("Content-Length") != null)         {             try             {                 int rcvd = 0;                 Data = new byte[ContentLength];                  do                 {                     off += rcvd;                     rcvd = inp.read(Data, off, ContentLength - off);                 } while (rcvd != -1&& off + rcvd< ContentLength);                 /*                  *  Don't do this!                  *  If we do, then getData() won't work after a getInputStream()                  *  because we'll never get all the expected data. Instead, let                  *  the underlying RespInputStream throw the EOF.                  *  if (rcvd == -1)	// premature EOF                  *  {                  *  throw new EOFException("Encountered premature EOF while " +                  *  "reading headers: received " + off +                  *  " bytes instead of the expected " +                  *  ContentLength + " bytes");                  *  }                  *             }             catch (IOException ioe)             {                 Data = Util.resizeArray(Data, off);                 throw ioe;             }             finally             {                 try                 {                     inp.close();                 }                 catch (IOException ioe)                 {                 }             }         }         else         {             int total = 0;             int rcvd = 0;             try             {                 ByteBlock actBlock = new ByteBlock(this.readIncrement);                 // TODO: Blocks are very small (500-2000 Bytes) -> combine them                 while ((actBlock.length = inp.read(actBlock.block, 0, this.readIncrement)) != -1)                 {                     total += actBlock.length;                     // System.out.println(this.getOriginalURI().toExternalForm() + ": adding block with length " + actBlock.length + " complete: " + total);                     blocks.add(actBlock);                     actBlock = new ByteBlock(this.readIncrement);                     //off += rcvd;                     // Data = Util.resizeArray(Data, off + this.readIncrement);                 }             }             catch (IOException ioe)             {                 throw ioe;             }             finally             {                 Iterator it = blocks.iterator();                 Data = Util.resizeArray(Data, total);                  off = 0;                 while (it.hasNext())                 {                     ByteBlock act = (ByteBlock) it.next();                     //System.out.println(this.getOriginalURI().toExternalForm() + ": copied " + act.length + " -> off: " + off + ", left: " + total);                     System.arraycopy(act.block, 0, Data, off, act.length);                     off += act.length;                     total -= act.length;                 }                 try                 {                     inp.close();                 }                 catch (IOException ioe)                 {                 }             }         }     } */
comment|/**      * Gets the timeout attribute of the HTTPResponse object      *      * @return   The timeout value      */
DECL|method|getTimeout
name|int
name|getTimeout
parameter_list|()
block|{
return|return
name|timeout
return|;
block|}
block|}
end_class
end_unit
