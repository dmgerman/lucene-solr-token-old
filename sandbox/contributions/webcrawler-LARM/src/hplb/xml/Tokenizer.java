begin_unit
begin_comment
comment|/*  * $Id$  *  * Copyright 1997 Hewlett-Packard Company  *  * This file may be copied, modified and distributed only in  * accordance with the terms of the limited licence contained  * in the accompanying file LICENSE.TXT.  */
end_comment
begin_comment
comment|/*  * FIXME:  *   - use java.io.Reader and Unicode chars...  *   - recognize PIs and CDATA  *   - recognize PEs and CEs (optionally)  *   - Do NOT map element and attr names to lower (or upper) case  */
end_comment
begin_package
DECL|package|hplb.xml
package|package
name|hplb
operator|.
name|xml
package|;
end_package
begin_import
import|import
name|hplb
operator|.
name|org
operator|.
name|xml
operator|.
name|sax
operator|.
name|*
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Dictionary
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Hashtable
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|*
import|;
end_import
begin_import
import|import
name|hplb
operator|.
name|misc
operator|.
name|ByteArray
import|;
end_import
begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URL
import|;
end_import
begin_comment
comment|/**  * This is a hand-written lexical analyzer for XML/HTML Markup.  * The parser is simple, fast and quite robust.  * Element and attribute names are mapped to lower case.  * Comments are returned as (part of) PCDATA tokens.  * Markup elements within comments is not recognized as markup.  *  * @author      Anders Kristensen  */
end_comment
begin_class
DECL|class|Tokenizer
specifier|public
class|class
name|Tokenizer
implements|implements
name|hplb
operator|.
name|org
operator|.
name|xml
operator|.
name|sax
operator|.
name|Parser
block|{
comment|/** The value of boolean attributes is this string. */
DECL|field|BOOLATTR
specifier|public
specifier|static
specifier|final
name|String
name|BOOLATTR
init|=
name|Atom
operator|.
name|getAtom
argument_list|(
literal|"BOOLATTR"
argument_list|)
decl_stmt|;
comment|// FSM states:
DECL|field|ST_START
specifier|static
specifier|final
name|int
name|ST_START
init|=
literal|1
decl_stmt|;
DECL|field|ST_TAG_LT
specifier|static
specifier|final
name|int
name|ST_TAG_LT
init|=
literal|3
decl_stmt|;
DECL|field|ST_TAG_NAME
specifier|static
specifier|final
name|int
name|ST_TAG_NAME
init|=
literal|4
decl_stmt|;
DECL|field|ST_TAG_WS
specifier|static
specifier|final
name|int
name|ST_TAG_WS
init|=
literal|5
decl_stmt|;
DECL|field|ST_EMPTY_TAG_SLASH
specifier|static
specifier|final
name|int
name|ST_EMPTY_TAG_SLASH
init|=
literal|6
decl_stmt|;
DECL|field|ST_NAME
specifier|static
specifier|final
name|int
name|ST_NAME
init|=
literal|7
decl_stmt|;
DECL|field|ST_NAME_WS
specifier|static
specifier|final
name|int
name|ST_NAME_WS
init|=
literal|8
decl_stmt|;
DECL|field|ST_EQ
specifier|static
specifier|final
name|int
name|ST_EQ
init|=
literal|9
decl_stmt|;
DECL|field|ST_VALUE
specifier|static
specifier|final
name|int
name|ST_VALUE
init|=
literal|10
decl_stmt|;
DECL|field|ST_VALUE_QUOTED
specifier|static
specifier|final
name|int
name|ST_VALUE_QUOTED
init|=
literal|11
decl_stmt|;
DECL|field|ST_PCDATA
specifier|static
specifier|final
name|int
name|ST_PCDATA
init|=
literal|21
decl_stmt|;
DECL|field|ST_COMMENT
specifier|static
specifier|final
name|int
name|ST_COMMENT
init|=
literal|22
decl_stmt|;
DECL|field|dfltHandler
name|HandlerBase
name|dfltHandler
init|=
operator|new
name|HandlerBase
argument_list|()
decl_stmt|;
DECL|field|entHandler
name|EntityHandler
name|entHandler
init|=
name|dfltHandler
decl_stmt|;
DECL|field|docHandler
name|DocumentHandler
name|docHandler
init|=
name|dfltHandler
decl_stmt|;
DECL|field|errHandler
name|ErrorHandler
name|errHandler
init|=
name|dfltHandler
decl_stmt|;
DECL|field|attrs
name|SAXAttributeMap
name|attrs
init|=
operator|new
name|SAXAttributeMap
argument_list|()
decl_stmt|;
DECL|field|sysID
name|String
name|sysID
decl_stmt|;
DECL|field|noCaseElms
specifier|protected
name|Hashtable
name|noCaseElms
decl_stmt|;
DECL|field|rcgnzWS
specifier|public
name|boolean
name|rcgnzWS
init|=
literal|true
decl_stmt|;
comment|// is white space chars recognized as PCDATA
comment|// even when preceeding tags?
DECL|field|rcgnzEntities
specifier|public
name|boolean
name|rcgnzEntities
init|=
literal|true
decl_stmt|;
DECL|field|rcgnzCDATA
specifier|public
name|boolean
name|rcgnzCDATA
init|=
literal|true
decl_stmt|;
DECL|field|rcgnzComments
specifier|public
name|boolean
name|rcgnzComments
init|=
literal|true
decl_stmt|;
comment|//
DECL|field|atomize
specifier|public
name|boolean
name|atomize
init|=
literal|false
decl_stmt|;
comment|// make element and attr names atoms
DECL|field|buf
name|CharBuffer
name|buf
init|=
operator|new
name|CharBuffer
argument_list|()
decl_stmt|;
DECL|field|isStartTag
name|boolean
name|isStartTag
init|=
literal|true
decl_stmt|;
comment|/**      * Signals whether a non-empty element has any children. If not we      * must generate an artificial empty-string child [characters(buf, 0, 0)].      */
DECL|field|noChildren
name|boolean
name|noChildren
decl_stmt|;
DECL|field|tagname
name|CharBuffer
name|tagname
init|=
operator|new
name|CharBuffer
argument_list|()
decl_stmt|;
DECL|field|attrName
name|CharBuffer
name|attrName
init|=
operator|new
name|CharBuffer
argument_list|()
decl_stmt|;
DECL|field|attrValue
name|CharBuffer
name|attrValue
init|=
operator|new
name|CharBuffer
argument_list|()
decl_stmt|;
DECL|field|in
name|Reader
name|in
decl_stmt|;
DECL|field|entMngr
specifier|public
specifier|final
name|EntityManager
name|entMngr
init|=
operator|new
name|EntityManager
argument_list|(
name|this
argument_list|)
decl_stmt|;
DECL|field|state
specifier|protected
name|int
name|state
init|=
name|ST_START
decl_stmt|;
DECL|field|_line
specifier|protected
name|int
name|_line
init|=
literal|1
decl_stmt|;
DECL|field|_column
specifier|protected
name|int
name|_column
init|=
literal|0
decl_stmt|;
DECL|field|line
specifier|public
name|int
name|line
decl_stmt|;
comment|// can be used in Handler callbacks
DECL|field|column
specifier|public
name|int
name|column
decl_stmt|;
comment|// can be used in Handler callbacks
DECL|field|qchar
specifier|protected
name|int
name|qchar
decl_stmt|;
comment|//<'> or<"> when parsing quoted attr values
comment|// we recognize attribute name-value pairs for XML PI by setting
comment|// the inXMLDecl flag and going to state ST_TAG_WS
DECL|field|inXMLDecl
name|boolean
name|inXMLDecl
init|=
literal|false
decl_stmt|;
comment|// see
DECL|method|Tokenizer
specifier|public
name|Tokenizer
parameter_list|()
block|{
name|pos
argument_list|()
expr_stmt|;
block|}
DECL|method|setEntityHandler
specifier|public
name|void
name|setEntityHandler
parameter_list|(
name|EntityHandler
name|handler
parameter_list|)
block|{
name|entHandler
operator|=
name|handler
expr_stmt|;
block|}
DECL|method|setDocumentHandler
specifier|public
name|void
name|setDocumentHandler
parameter_list|(
name|DocumentHandler
name|handler
parameter_list|)
block|{
name|docHandler
operator|=
name|handler
expr_stmt|;
block|}
DECL|method|setErrorHandler
specifier|public
name|void
name|setErrorHandler
parameter_list|(
name|ErrorHandler
name|handler
parameter_list|)
block|{
name|errHandler
operator|=
name|handler
expr_stmt|;
block|}
DECL|method|parse
specifier|public
name|void
name|parse
parameter_list|(
name|String
name|publicID
parameter_list|,
name|String
name|sysID
parameter_list|)
throws|throws
name|Exception
block|{
name|this
operator|.
name|sysID
operator|=
name|sysID
expr_stmt|;
name|parse
argument_list|(
operator|new
name|URL
argument_list|(
name|sysID
argument_list|)
operator|.
name|openStream
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|parse
specifier|public
name|void
name|parse
parameter_list|(
name|InputStream
name|in
parameter_list|)
throws|throws
name|Exception
block|{
name|parse
argument_list|(
operator|new
name|InputStreamReader
argument_list|(
name|in
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|parse
specifier|public
name|void
name|parse
parameter_list|(
name|Reader
name|in
parameter_list|)
throws|throws
name|Exception
block|{
name|this
operator|.
name|in
operator|=
name|in
expr_stmt|;
name|docHandler
operator|.
name|startDocument
argument_list|()
expr_stmt|;
name|tokenize
argument_list|()
expr_stmt|;
name|docHandler
operator|.
name|endDocument
argument_list|()
expr_stmt|;
block|}
comment|// invoked to remember current position
DECL|method|pos
specifier|protected
name|void
name|pos
parameter_list|()
block|{
name|line
operator|=
name|_line
expr_stmt|;
name|column
operator|=
name|_column
expr_stmt|;
block|}
DECL|method|ignoreCase
specifier|public
name|void
name|ignoreCase
parameter_list|(
name|String
name|elementName
parameter_list|)
block|{
if|if
condition|(
name|noCaseElms
operator|==
literal|null
condition|)
name|noCaseElms
operator|=
operator|new
name|Hashtable
argument_list|()
expr_stmt|;
name|noCaseElms
operator|.
name|put
argument_list|(
name|elementName
operator|.
name|toLowerCase
argument_list|()
argument_list|,
name|elementName
argument_list|)
expr_stmt|;
block|}
DECL|method|rcgnzWS
specifier|public
name|void
name|rcgnzWS
parameter_list|(
name|boolean
name|b
parameter_list|)
block|{
name|rcgnzWS
operator|=
name|b
expr_stmt|;
block|}
comment|// invoked after doing any Handler callback - resets state
DECL|method|toStart
specifier|protected
name|void
name|toStart
parameter_list|()
block|{
name|state
operator|=
name|ST_START
expr_stmt|;
name|buf
operator|.
name|reset
argument_list|()
expr_stmt|;
name|tagname
operator|.
name|reset
argument_list|()
expr_stmt|;
name|attrName
operator|.
name|reset
argument_list|()
expr_stmt|;
name|attrValue
operator|.
name|reset
argument_list|()
expr_stmt|;
name|attrs
operator|.
name|clear
argument_list|()
expr_stmt|;
name|isStartTag
operator|=
literal|true
expr_stmt|;
comment|// until proven wrong
name|pos
argument_list|()
expr_stmt|;
block|}
DECL|method|tokenize
specifier|public
name|void
name|tokenize
parameter_list|()
throws|throws
name|Exception
block|{
name|int
name|c
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|read
argument_list|()
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|ST_START
case|:
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'<'
case|:
name|state
operator|=
name|ST_TAG_LT
expr_stmt|;
name|isStartTag
operator|=
literal|true
expr_stmt|;
comment|// until proven wrong
name|tagname
operator|.
name|reset
argument_list|()
expr_stmt|;
break|break;
case|case
literal|' '
case|:
case|case
literal|'\t'
case|:
case|case
literal|'\r'
case|:
case|case
literal|'\n'
case|:
if|if
condition|(
operator|!
name|rcgnzWS
condition|)
break|break;
comment|// else fall through
default|default:
name|state
operator|=
name|ST_PCDATA
expr_stmt|;
block|}
break|break;
case|case
name|ST_PCDATA
case|:
if|if
condition|(
name|c
operator|==
literal|'<'
condition|)
block|{
name|gotPCDATA
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|state
operator|=
name|ST_TAG_LT
expr_stmt|;
block|}
break|break;
case|case
name|ST_TAG_LT
case|:
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'/'
case|:
name|isStartTag
operator|=
literal|false
expr_stmt|;
name|state
operator|=
name|ST_TAG_NAME
expr_stmt|;
break|break;
case|case
literal|'!'
case|:
name|c
operator|=
name|read
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|==
literal|'-'
operator|&&
operator|!
name|rcgnzComments
operator|)
operator|||
operator|(
name|c
operator|==
literal|'['
operator|&&
operator|!
name|rcgnzCDATA
operator|)
condition|)
block|{
name|state
operator|=
name|ST_PCDATA
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|c
operator|==
literal|'-'
condition|)
name|state
operator|=
name|ST_COMMENT
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'['
condition|)
name|parseCDATA
argument_list|()
expr_stmt|;
else|else
block|{
comment|// FIXME: shouldn't be delivered as PCDATA
name|warning
argument_list|(
literal|"Bad markup "
operator|+
name|buf
argument_list|)
expr_stmt|;
name|state
operator|=
name|ST_PCDATA
expr_stmt|;
block|}
break|break;
case|case
literal|'?'
case|:
name|parsePI
argument_list|()
expr_stmt|;
break|break;
case|case
literal|' '
case|:
case|case
literal|'\t'
case|:
case|case
literal|'\r'
case|:
case|case
literal|'\n'
case|:
name|state
operator|=
name|ST_TAG_WS
expr_stmt|;
break|break;
default|default:
name|tagname
operator|.
name|write
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|state
operator|=
name|ST_TAG_NAME
expr_stmt|;
block|}
break|break;
case|case
name|ST_TAG_NAME
case|:
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|' '
case|:
case|case
literal|'\t'
case|:
case|case
literal|'\r'
case|:
case|case
literal|'\n'
case|:
name|state
operator|=
name|ST_TAG_WS
expr_stmt|;
break|break;
case|case
literal|'/'
case|:
name|state
operator|=
name|ST_EMPTY_TAG_SLASH
expr_stmt|;
break|break;
case|case
literal|'>'
case|:
name|gotTag
argument_list|(
literal|false
argument_list|)
expr_stmt|;
break|break;
default|default:
name|tagname
operator|.
name|write
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ST_TAG_WS
case|:
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|' '
case|:
case|case
literal|'\t'
case|:
case|case
literal|'\r'
case|:
case|case
literal|'\n'
case|:
break|break;
case|case
literal|'/'
case|:
name|state
operator|=
name|ST_EMPTY_TAG_SLASH
expr_stmt|;
break|break;
case|case
literal|'>'
case|:
name|gotTag
argument_list|(
literal|false
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
if|if
condition|(
name|inXMLDecl
condition|)
block|{
if|if
condition|(
operator|(
name|c
operator|=
name|read
argument_list|()
operator|)
operator|!=
literal|'>'
condition|)
block|{
name|errHandler
operator|.
name|warning
argument_list|(
literal|"XML PI not terminated properly"
argument_list|,
name|sysID
argument_list|,
name|_line
argument_list|,
name|_column
argument_list|)
expr_stmt|;
comment|//err_continue("XML PI not terminated properly");
block|}
comment|//handler.gotXMLDecl(attrs);  // FIXME(?)
name|toStart
argument_list|()
expr_stmt|;
break|break;
block|}
comment|// NOTE: if !inXMLDecl we fall through to default case
default|default:
if|if
condition|(
operator|!
name|isStartTag
condition|)
block|{
comment|// bit of a hack this...
name|errHandler
operator|.
name|warning
argument_list|(
literal|"Malformed tag: "
operator|+
name|buf
argument_list|,
name|sysID
argument_list|,
name|_line
argument_list|,
name|_column
argument_list|)
expr_stmt|;
comment|//err_continue("Malformed tag: "+buf);
if|if
condition|(
name|c
operator|==
literal|'<'
condition|)
block|{
name|gotPCDATA
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|state
operator|=
name|ST_TAG_LT
expr_stmt|;
block|}
else|else
block|{
comment|// we get here e.g. if there's an end tag with attributes
name|state
operator|=
name|ST_PCDATA
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// FIXME: this accepts way too many first chars for attr name
name|attrName
operator|.
name|write
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|state
operator|=
name|ST_NAME
expr_stmt|;
block|}
block|}
break|break;
case|case
name|ST_EMPTY_TAG_SLASH
case|:
if|if
condition|(
name|c
operator|==
literal|'>'
condition|)
block|{
comment|//tagtype = TAG_EMPTY;
name|gotTag
argument_list|(
literal|true
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
block|{
comment|// ERROR !? - can't throw Exception here - we go to next tag...
name|state
operator|=
name|ST_PCDATA
expr_stmt|;
block|}
break|break;
case|case
name|ST_NAME
case|:
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|' '
case|:
case|case
literal|'\t'
case|:
case|case
literal|'\r'
case|:
case|case
literal|'\n'
case|:
if|if
condition|(
name|attrName
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|state
operator|=
name|ST_NAME_WS
expr_stmt|;
block|}
break|break;
case|case
literal|'>'
case|:
if|if
condition|(
name|attrName
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
name|gotAttr
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|gotTag
argument_list|(
literal|false
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'='
case|:
name|state
operator|=
name|ST_EQ
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|isCtlOrTspecial
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|state
operator|=
name|ST_PCDATA
expr_stmt|;
block|}
else|else
block|{
name|attrName
operator|.
name|write
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|ST_NAME_WS
case|:
comment|// white-space between name and '='
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|' '
case|:
case|case
literal|'\t'
case|:
case|case
literal|'\r'
case|:
case|case
literal|'\n'
case|:
break|break;
case|case
literal|'='
case|:
name|state
operator|=
name|ST_EQ
expr_stmt|;
break|break;
case|case
literal|'>'
case|:
name|gotAttr
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|gotTag
argument_list|(
literal|false
argument_list|)
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|isNameChar
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|gotAttr
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|attrName
operator|.
name|write
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|state
operator|=
name|ST_TAG_WS
expr_stmt|;
block|}
else|else
block|{
name|state
operator|=
name|ST_PCDATA
expr_stmt|;
block|}
block|}
break|break;
case|case
name|ST_EQ
case|:
comment|// white-space between '=' and value
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|' '
case|:
case|case
literal|'\t'
case|:
case|case
literal|'\r'
case|:
case|case
literal|'\n'
case|:
break|break;
case|case
literal|'"'
case|:
name|qchar
operator|=
literal|'"'
expr_stmt|;
name|state
operator|=
name|ST_VALUE_QUOTED
expr_stmt|;
break|break;
case|case
literal|'\''
case|:
name|qchar
operator|=
literal|'\''
expr_stmt|;
name|state
operator|=
name|ST_VALUE_QUOTED
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|isCtlOrTspecial
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|state
operator|=
name|ST_PCDATA
expr_stmt|;
block|}
else|else
block|{
name|attrValue
operator|.
name|write
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|state
operator|=
name|ST_VALUE
expr_stmt|;
block|}
block|}
break|break;
case|case
name|ST_VALUE
case|:
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|' '
case|:
case|case
literal|'\t'
case|:
case|case
literal|'\r'
case|:
case|case
literal|'\n'
case|:
name|gotAttr
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|state
operator|=
name|ST_TAG_WS
expr_stmt|;
break|break;
case|case
literal|'>'
case|:
name|gotAttr
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|gotTag
argument_list|(
literal|false
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'/'
case|:
name|gotAttr
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|state
operator|=
name|ST_EMPTY_TAG_SLASH
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|isCtlOrTspecial
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|state
operator|=
name|ST_PCDATA
expr_stmt|;
block|}
else|else
block|{
name|attrValue
operator|.
name|write
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|ST_VALUE_QUOTED
case|:
if|if
condition|(
name|c
operator|==
name|qchar
condition|)
block|{
name|gotAttr
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|state
operator|=
name|ST_TAG_WS
expr_stmt|;
block|}
else|else
block|{
name|attrValue
operator|.
name|write
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ST_COMMENT
case|:
comment|// we've seen "...<!-" by now
try|try
block|{
if|if
condition|(
name|c
operator|!=
literal|'-'
condition|)
block|{
name|warning
argument_list|(
literal|"Bad comment"
argument_list|)
expr_stmt|;
name|state
operator|=
name|ST_PCDATA
expr_stmt|;
break|break;
block|}
comment|// we're within comment - read till we see "--"
while|while
condition|(
literal|true
condition|)
block|{
while|while
condition|(
name|read_ex
argument_list|()
operator|!=
literal|'-'
condition|)
empty_stmt|;
if|if
condition|(
name|read_ex
argument_list|()
operator|==
literal|'-'
condition|)
break|break;
block|}
comment|// seen "--" - gotComment() reads past next '>'
name|gotComment
argument_list|()
expr_stmt|;
comment|//while (read_ex() != '>') ;
comment|//state = ST_PCDATA;
block|}
catch|catch
parameter_list|(
name|EmptyInputStream
name|ex
parameter_list|)
block|{
name|gotPCDATA
argument_list|(
literal|false
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* TODO: catch EmptyInputStream exception only here!     } catch (EmptyInputStream ex) {         err_continue("EOF while parsing " + token[state]);     }     */
comment|// input stream ended - return rest, if any, as PCDATA
if|if
condition|(
name|buf
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|gotPCDATA
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|buf
operator|.
name|reset
argument_list|()
expr_stmt|;
block|}
block|}
comment|// counts lines and columns - used in error reporting
comment|// a line can be a single \r or \n or it can be \r\n - we handle them all
DECL|field|cc
name|int
name|cc
decl_stmt|;
comment|// last char read
DECL|method|read
specifier|public
specifier|final
name|int
name|read
parameter_list|()
throws|throws
name|IOException
block|{
name|int
name|c
init|=
name|in
operator|.
name|read
argument_list|()
decl_stmt|;
if|if
condition|(
name|c
operator|!=
operator|-
literal|1
condition|)
block|{
name|buf
operator|.
name|write
argument_list|(
name|c
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\r'
case|:
name|_line
operator|++
expr_stmt|;
name|_column
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'\n'
case|:
if|if
condition|(
name|cc
operator|!=
literal|'\r'
condition|)
name|_line
operator|++
expr_stmt|;
name|_column
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|_column
operator|++
expr_stmt|;
block|}
name|cc
operator|=
name|c
expr_stmt|;
block|}
return|return
name|c
return|;
block|}
DECL|method|read_ex
specifier|public
specifier|final
name|int
name|read_ex
parameter_list|()
throws|throws
name|IOException
throws|,
name|EmptyInputStream
block|{
name|int
name|c
init|=
name|read
argument_list|()
decl_stmt|;
if|if
condition|(
name|c
operator|==
operator|-
literal|1
condition|)
throw|throw
operator|new
name|EmptyInputStream
argument_list|()
throw|;
return|return
name|c
return|;
block|}
comment|// HTML allows<em>boolean</em> attributes - attributes without a
comment|// value, or rather an implicit value which is the same as the name.
DECL|method|gotAttr
specifier|protected
specifier|final
name|void
name|gotAttr
parameter_list|(
name|boolean
name|isBoolean
parameter_list|)
throws|throws
name|Exception
block|{
name|String
name|nm
init|=
name|attrName
operator|.
name|toString
argument_list|()
decl_stmt|;
if|if
condition|(
name|atomize
condition|)
name|nm
operator|=
name|Atom
operator|.
name|getAtom
argument_list|(
name|nm
argument_list|)
expr_stmt|;
name|String
name|val
init|=
name|isBoolean
condition|?
name|BOOLATTR
else|:
operator|(
name|rcgnzEntities
condition|?
name|entMngr
operator|.
name|entityDecode
argument_list|(
name|attrValue
argument_list|)
else|:
name|attrValue
operator|)
operator|.
name|toString
argument_list|()
decl_stmt|;
name|attrName
operator|.
name|reset
argument_list|()
expr_stmt|;
name|attrValue
operator|.
name|reset
argument_list|()
expr_stmt|;
name|attrs
operator|.
name|put
argument_list|(
name|nm
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
DECL|method|gotTag
specifier|protected
name|void
name|gotTag
parameter_list|(
name|boolean
name|isEmpty
parameter_list|)
throws|throws
name|Exception
block|{
name|String
name|nm
init|=
name|tagname
operator|.
name|toString
argument_list|()
decl_stmt|;
name|String
name|nm_lc
init|=
name|nm
operator|.
name|toLowerCase
argument_list|()
decl_stmt|;
if|if
condition|(
name|noCaseElms
operator|!=
literal|null
operator|&&
name|noCaseElms
operator|.
name|get
argument_list|(
name|nm_lc
argument_list|)
operator|!=
literal|null
condition|)
block|{
name|nm
operator|=
name|nm_lc
expr_stmt|;
name|keysToLowerCase
argument_list|(
name|attrs
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|atomize
condition|)
name|nm
operator|=
name|Atom
operator|.
name|getAtom
argument_list|(
name|nm
argument_list|)
expr_stmt|;
if|if
condition|(
name|isStartTag
condition|)
block|{
name|docHandler
operator|.
name|startElement
argument_list|(
name|nm
argument_list|,
name|attrs
argument_list|)
expr_stmt|;
comment|//handler.gotSTag(nm, isEmpty, attrs, getBuffer());
if|if
condition|(
name|isEmpty
condition|)
name|docHandler
operator|.
name|endElement
argument_list|(
name|nm
argument_list|)
expr_stmt|;
name|noChildren
operator|=
operator|!
name|isEmpty
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|noChildren
condition|)
block|{
name|docHandler
operator|.
name|characters
argument_list|(
name|buf
operator|.
name|getCharArray
argument_list|()
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|noChildren
operator|=
literal|false
expr_stmt|;
block|}
name|docHandler
operator|.
name|endElement
argument_list|(
name|nm
argument_list|)
expr_stmt|;
comment|//handler.gotETag(nm, getBuffer());
block|}
name|toStart
argument_list|()
expr_stmt|;
block|}
DECL|method|keysToLowerCase
specifier|public
specifier|final
name|void
name|keysToLowerCase
parameter_list|(
name|SAXAttributeMap
name|attrs
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|attrs
operator|.
name|n
condition|;
name|i
operator|++
control|)
block|{
name|attrs
operator|.
name|keys
index|[
name|i
index|]
operator|=
name|attrs
operator|.
name|keys
index|[
name|i
index|]
operator|.
name|toLowerCase
argument_list|()
expr_stmt|;
if|if
condition|(
name|atomize
condition|)
name|attrs
operator|.
name|keys
index|[
name|i
index|]
operator|=
name|Atom
operator|.
name|getAtom
argument_list|(
name|attrs
operator|.
name|keys
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
comment|// toomuch true iff we read a '<' of the next token
DECL|method|gotPCDATA
specifier|protected
name|void
name|gotPCDATA
parameter_list|(
name|boolean
name|toomuch
parameter_list|)
throws|throws
name|Exception
block|{
name|noChildren
operator|=
literal|false
expr_stmt|;
if|if
condition|(
name|toomuch
condition|)
block|{
name|buf
operator|.
name|setLength
argument_list|(
name|buf
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|CharBuffer
name|buf1
init|=
name|rcgnzEntities
condition|?
name|entMngr
operator|.
name|entityDecode
argument_list|(
name|buf
argument_list|)
else|:
name|buf
decl_stmt|;
name|docHandler
operator|.
name|characters
argument_list|(
name|buf1
operator|.
name|getCharArray
argument_list|()
argument_list|,
literal|0
argument_list|,
name|buf1
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
comment|//handler.gotText(getBuffer());
name|toStart
argument_list|()
expr_stmt|;
if|if
condition|(
name|toomuch
condition|)
block|{
name|buf
operator|.
name|write
argument_list|(
literal|'<'
argument_list|)
expr_stmt|;
name|column
operator|--
expr_stmt|;
block|}
block|}
comment|// XXX: should pass the comment on as docHandler.ignorable() ??
DECL|method|gotComment
specifier|protected
name|void
name|gotComment
parameter_list|()
throws|throws
name|IOException
throws|,
name|EmptyInputStream
block|{
comment|//toStart();  // so an unexpected EOF causes rest to be returned as PCDATA
while|while
condition|(
name|read_ex
argument_list|()
operator|!=
literal|'>'
condition|)
empty_stmt|;
name|toStart
argument_list|()
expr_stmt|;
block|}
comment|// Processing Instruction
DECL|method|parsePI
specifier|protected
name|void
name|parsePI
parameter_list|()
throws|throws
name|Exception
block|{
name|int
name|i
decl_stmt|;
name|String
name|target
decl_stmt|;
name|noChildren
operator|=
literal|false
expr_stmt|;
name|inXMLDecl
operator|=
literal|false
expr_stmt|;
name|i
operator|=
name|buf
operator|.
name|size
argument_list|()
expr_stmt|;
try|try
block|{
while|while
condition|(
operator|!
name|isWS
argument_list|(
name|read_ex
argument_list|()
argument_list|)
condition|)
empty_stmt|;
name|target
operator|=
name|buf
operator|.
name|toString
argument_list|()
expr_stmt|;
name|target
operator|=
name|target
operator|.
name|substring
argument_list|(
name|i
argument_list|,
name|target
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
literal|"XML"
operator|.
name|equals
argument_list|(
name|target
argument_list|)
condition|)
block|{
name|inXMLDecl
operator|=
literal|true
expr_stmt|;
name|state
operator|=
name|ST_TAG_WS
expr_stmt|;
return|return;
block|}
while|while
condition|(
name|isWS
argument_list|(
name|read_ex
argument_list|()
argument_list|)
condition|)
empty_stmt|;
name|i
operator|=
name|buf
operator|.
name|size
argument_list|()
operator|-
literal|1
expr_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
while|while
condition|(
name|read_ex
argument_list|()
operator|!=
literal|'?'
condition|)
empty_stmt|;
if|if
condition|(
name|read_ex
argument_list|()
operator|==
literal|'>'
condition|)
block|{
name|String
name|s
init|=
name|buf
operator|.
name|toString
argument_list|()
decl_stmt|;
name|docHandler
operator|.
name|processingInstruction
argument_list|(
name|Atom
operator|.
name|getAtom
argument_list|(
name|target
argument_list|)
argument_list|,
name|s
operator|.
name|substring
argument_list|(
name|i
argument_list|,
name|s
operator|.
name|length
argument_list|()
operator|-
literal|2
argument_list|)
argument_list|)
expr_stmt|;
comment|//handler.gotPI(Atom.getAtom(target),
comment|//              s.substring(i, s.length()-2));
break|break;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|EmptyInputStream
name|ex
parameter_list|)
block|{
name|gotPCDATA
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|errHandler
operator|.
name|warning
argument_list|(
literal|"EOF while parsing PI"
argument_list|,
name|sysID
argument_list|,
name|_line
argument_list|,
name|_column
argument_list|)
expr_stmt|;
comment|//err_continue("EOF while parsing PI");
block|}
name|toStart
argument_list|()
expr_stmt|;
block|}
comment|// CDATA section
comment|// XXX: should contents be amalgamated with surrounding PCDATA?
DECL|method|parseCDATA
specifier|protected
name|void
name|parseCDATA
parameter_list|()
throws|throws
name|Exception
block|{
comment|// we've seen "<![" by now
try|try
block|{
if|if
condition|(
name|read_ex
argument_list|()
operator|==
literal|'C'
operator|&&
name|read_ex
argument_list|()
operator|==
literal|'D'
operator|&&
name|read_ex
argument_list|()
operator|==
literal|'A'
operator|&&
name|read_ex
argument_list|()
operator|==
literal|'T'
operator|&&
name|read_ex
argument_list|()
operator|==
literal|'A'
operator|&&
name|read_ex
argument_list|()
operator|==
literal|'['
condition|)
block|{
name|int
name|i1
init|=
name|buf
operator|.
name|size
argument_list|()
decl_stmt|;
while|while
condition|(
name|read_ex
argument_list|()
operator|!=
literal|']'
operator|||
name|read_ex
argument_list|()
operator|!=
literal|']'
operator|||
name|read_ex
argument_list|()
operator|!=
literal|'>'
condition|)
empty_stmt|;
name|docHandler
operator|.
name|characters
argument_list|(
name|buf
operator|.
name|getCharArray
argument_list|()
argument_list|,
name|i1
argument_list|,
name|buf
operator|.
name|size
argument_list|()
operator|-
literal|3
operator|-
name|i1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|warning
argument_list|(
literal|"Bad CDATA markup"
argument_list|)
expr_stmt|;
name|state
operator|=
name|ST_PCDATA
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|EmptyInputStream
name|ex
parameter_list|)
block|{
name|warning
argument_list|(
literal|"EOF while parsing CDATA section"
argument_list|)
expr_stmt|;
name|gotPCDATA
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
name|toStart
argument_list|()
expr_stmt|;
block|}
DECL|method|isWS
specifier|public
name|boolean
name|isWS
parameter_list|(
name|int
name|c
parameter_list|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|' '
case|:
case|case
literal|'\t'
case|:
case|case
literal|'\r'
case|:
case|case
literal|'\n'
case|:
return|return
literal|true
return|;
default|default:
return|return
literal|false
return|;
block|}
block|}
comment|/**      * Returns true if c is either an ascii control character or      * a tspecial according to the HTTP specification.      */
comment|//   private static final boolean[] isCtlOrTSpecial = new boolean[]
comment|//     {
comment|//        /* 0 */     true , true , true , true , true , true , true , true , true , true , true , true , true , true ,
comment|//        /* 14 */    true , true , true , true , true , true , true , true , true , true , true , true , true , true ,
comment|//        /* 28 */    true , true , true , true , true , false, true , false, false, false, false, false, true , true ,
comment|//        /* 42 */    false, false, true , false, false, true , false, false, false, false, false, false, false, false,
comment|//        /* 56 */    false, false, true , true , true , true , true , true , true , false, false, false, false, false,
comment|//        /* 70 */    false, false, false, false, false, false, false, false, false, false, false, false, false, false,
comment|//        /* 84 */    false, false, false, false, false, false, false, true , true , true , false, false, false, false,
comment|//        /* 98 */    false, false, false, false, false, false, false, false, false, false, false, false, false, false,
comment|//        /* 112 */   false, false, false, false, false, false, false, false, false, false, false, true , false, true ,
comment|//        /* 126 */   false, true , false, false, false, false, false, false, false, false, false, false, false, false,
comment|//        /* 140 */   false, false, false, false, false, false, false, false, false, false, false, false, false, false,
comment|//        /* 154 */   false, false, false, false, false, false, false, false, false, false, false, false, false, false,
comment|//        /* 168 */   false, false, false, false, false, false, false, false, false, false, false, false, false, false,
comment|//        /* 182 */   false, false, false, false, false, false, false, false, false, false, false, false, false, false,
comment|//        /* 196 */   false, false, false, false, false, false, false, false, false, false, false, false, false, false,
comment|//        /* 210 */   false, false, false, false, false, false, false, false, false, false, false, false, false, false,
comment|//        /* 224 */   false, false, false, false, false, false, false, false, false, false, false, false, false, false,
comment|//        /* 238 */   false, false, false, false, false, false, false, false, false, false, false, false, false, false,
comment|//        /* 252 */   false, false, false, false
comment|//    };
DECL|method|isCtlOrTspecial
specifier|public
specifier|static
specifier|final
name|boolean
name|isCtlOrTspecial
parameter_list|(
name|int
name|c
parameter_list|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
comment|// control characters (0-31 and 127):
case|case
literal|0
case|:
case|case
literal|1
case|:
case|case
literal|2
case|:
case|case
literal|3
case|:
case|case
literal|4
case|:
case|case
literal|5
case|:
case|case
literal|6
case|:
case|case
literal|7
case|:
case|case
literal|8
case|:
case|case
literal|9
case|:
case|case
literal|10
case|:
case|case
literal|11
case|:
case|case
literal|12
case|:
case|case
literal|13
case|:
case|case
literal|14
case|:
case|case
literal|15
case|:
case|case
literal|16
case|:
case|case
literal|17
case|:
case|case
literal|18
case|:
case|case
literal|19
case|:
case|case
literal|20
case|:
case|case
literal|21
case|:
case|case
literal|22
case|:
case|case
literal|23
case|:
case|case
literal|24
case|:
case|case
literal|25
case|:
case|case
literal|26
case|:
case|case
literal|27
case|:
case|case
literal|28
case|:
case|case
literal|29
case|:
case|case
literal|30
case|:
case|case
literal|31
case|:
case|case
literal|127
case|:
comment|// tspecials:
case|case
literal|'('
case|:
case|case
literal|')'
case|:
case|case
literal|'<'
case|:
case|case
literal|'>'
case|:
case|case
literal|'@'
case|:
case|case
literal|','
case|:
case|case
literal|';'
case|:
case|case
literal|':'
case|:
case|case
literal|'\\'
case|:
case|case
literal|'"'
case|:
case|case
literal|'/'
case|:
case|case
literal|'['
case|:
case|case
literal|']'
case|:
case|case
literal|'?'
case|:
case|case
literal|'='
case|:
case|case
literal|'{'
case|:
case|case
literal|'}'
case|:
case|case
literal|' '
case|:
comment|// case '\t':
return|return
literal|true
return|;
default|default:
return|return
literal|false
return|;
block|}
block|}
comment|/*    public static void main(String[])     {     System.out.println("private static final boolean[] isCtlOrTSpecial = \n{");  // bzw. isNameChar         for(int i=0; i<256; i++)         {             if(i>0)                 System.out.print(", ");             if(i % 14 == 0)             {                 System.out.print("\n/* " + i + " *" + "/   ");             }             if(Tokenizer.isCtlOrTspecial(i))  // bzw. isNameChar(i)             {                 System.out.print("true ");             }             else             {                 System.out.print("false");             }           }         System.out.print("};\n\n");     }     */
comment|//    public static final boolean isCtlOrTspecial(int c)
comment|//    {
comment|//        return (c< 256 ? isCtlOrTSpecial[c] : false);
comment|//    }
comment|//
comment|//    private static final boolean[] isNameChar =
comment|//    {
comment|//        /* 0 */     false, false, false, false, false, false, false, false, false, false, false, false, false, false,
comment|//        /* 14 */    false, false, false, false, false, false, false, false, false, false, false, false, false, false,
comment|//        /* 28 */    false, false, false, false, false, false, false, false, false, false, false, false, false, false,
comment|//        /* 42 */    false, false, false, true , true , false, true , true , true , true , true , true , true , true ,
comment|//        /* 56 */    true , true , false, false, false, false, false, false, false, true , true , true , true , true ,
comment|//        /* 70 */    true , true , true , true , true , true , true , true , true , true , true , true , true , true ,
comment|//        /* 84 */    true , true , true , true , true , true , true , false, false, false, false, true , false, true ,
comment|//        /* 98 */    true , true , true , true , true , true , true , true , true , true , true , true , true , true ,
comment|//        /* 112 */   true , true , true , true , true , true , true , true , true , true , true , false, false, false,
comment|//        /* 126 */   false, false, false, false, false, false, false, false, false, false, false, false, false, false,
comment|//        /* 140 */   false, false, false, false, false, false, false, false, false, false, false, false, false, false,
comment|//        /* 154 */   false, false, false, false, false, false, false, false, false, false, false, false, false, false,
comment|//        /* 168 */   false, false, false, false, false, false, false, false, false, false, false, false, false, false,
comment|//        /* 182 */   false, false, false, false, false, false, false, false, false, false, false, false, false, false,
comment|//        /* 196 */   false, false, false, false, false, false, false, false, false, false, false, false, false, false,
comment|//        /* 210 */   false, false, false, false, false, false, false, false, false, false, false, false, false, false,
comment|//        /* 224 */   false, false, false, false, false, false, false, false, false, false, false, false, false, false,
comment|//        /* 238 */   false, false, false, false, false, false, false, false, false, false, false, false, false, false,
comment|//        /* 252 */   false, false, false, false
comment|//    };
comment|//    public static final boolean isNameChar(int c)
comment|//    {
comment|//        return (c< 256 ? isNameChar[c] : false);
comment|//    }
comment|//
comment|/*     // I don't think this is a very standard definition of what can     // go into tag and attribute names.*/
DECL|method|isNameChar
specifier|public
specifier|static
specifier|final
name|boolean
name|isNameChar
parameter_list|(
name|int
name|c
parameter_list|)
block|{
return|return
operator|(
literal|'a'
operator|<=
name|c
operator|&&
name|c
operator|<=
literal|'z'
operator|)
operator|||
operator|(
literal|'A'
operator|<=
name|c
operator|&&
name|c
operator|<=
literal|'Z'
operator|)
operator|||
operator|(
literal|'0'
operator|<=
name|c
operator|&&
name|c
operator|<=
literal|'9'
operator|)
operator|||
name|c
operator|==
literal|'.'
operator|||
name|c
operator|==
literal|'-'
operator|||
name|c
operator|==
literal|'_'
return|;
block|}
DECL|method|warning
specifier|protected
specifier|final
name|void
name|warning
parameter_list|(
name|String
name|s
parameter_list|)
throws|throws
name|Exception
block|{
name|errHandler
operator|.
name|warning
argument_list|(
name|s
argument_list|,
name|sysID
argument_list|,
name|_line
argument_list|,
name|_column
argument_list|)
expr_stmt|;
block|}
DECL|method|fatal
specifier|protected
specifier|final
name|void
name|fatal
parameter_list|(
name|String
name|s
parameter_list|)
throws|throws
name|Exception
block|{
name|errHandler
operator|.
name|fatal
argument_list|(
name|s
argument_list|,
name|sysID
argument_list|,
name|_line
argument_list|,
name|_column
argument_list|)
expr_stmt|;
block|}
block|}
end_class
begin_class
DECL|class|EmptyInputStream
class|class
name|EmptyInputStream
extends|extends
name|Exception
block|{
DECL|method|EmptyInputStream
name|EmptyInputStream
parameter_list|()
block|{}
block|}
end_class
end_unit
