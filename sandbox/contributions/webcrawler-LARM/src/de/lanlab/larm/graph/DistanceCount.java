begin_unit
begin_comment
comment|/* ====================================================================  * The Apache Software License, Version 1.1  *  * Copyright (c) 2001 The Apache Software Foundation.  All rights  * reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  *  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in  *    the documentation and/or other materials provided with the  *    distribution.  *  * 3. The end-user documentation included with the redistribution,  *    if any, must include the following acknowledgment:  *       "This product includes software developed by the  *        Apache Software Foundation (http://www.apache.org/)."  *    Alternately, this acknowledgment may appear in the software itself,  *    if and wherever such third-party acknowledgments normally appear.  *  * 4. The names "Apache" and "Apache Software Foundation" and  *    "Apache Lucene" must not be used to endorse or promote products  *    derived from this software without prior written permission. For  *    written permission, please contact apache@apache.org.  *  * 5. Products derived from this software may not be called "Apache",  *    "Apache Lucene", nor may "Apache" appear in their name, without  *    prior written permission of the Apache Software Foundation.  *  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED  * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE  * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR  * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF  * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  * ====================================================================  *  * This software consists of voluntary contributions made by many  * individuals on behalf of the Apache Software Foundation.  For more  * information on the Apache Software Foundation, please see  *<http://www.apache.org/>.  */
end_comment
begin_package
DECL|package|de.lanlab.larm.graph
package|package
name|de
operator|.
name|lanlab
operator|.
name|larm
operator|.
name|graph
package|;
end_package
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|*
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|*
import|;
end_import
begin_comment
comment|/**  * this is just a test to use some graph algorithms on the URL graph  *  * @author    Administrator  * @created   30. Januar 2002  * @version $Id$  */
end_comment
begin_class
DECL|class|Node
class|class
name|Node
implements|implements
name|Comparable
block|{
DECL|field|incoming
name|LinkedList
name|incoming
decl_stmt|;
comment|// 16 + 4 per entry
comment|//HashSet incomingNodes; // 16 + 16 per entry, 11 x 16 default size = 192
DECL|field|outgoing
name|LinkedList
name|outgoing
decl_stmt|;
comment|// 16 + 4 per entry
comment|//Object o;
comment|//HashSet outgoingNodes; // 16 + 16 per entry, 11 x 16 default size = 192
comment|//LinkedList shortestIncoming;
DECL|field|id
name|int
name|id
decl_stmt|;
comment|// 4
DECL|field|distance
name|float
name|distance
decl_stmt|;
comment|// 8
DECL|field|name
name|String
name|name
decl_stmt|;
comment|// 4 + String object
DECL|field|title
name|String
name|title
decl_stmt|;
comment|// 4 + String object
DECL|field|nodeRank
name|float
name|nodeRank
index|[]
init|=
operator|new
name|float
index|[
literal|2
index|]
decl_stmt|;
comment|// 16
comment|// 470 bytes + 2 string objects
comment|/**      * Description of the Field      */
DECL|field|sortType
specifier|public
specifier|static
name|int
name|sortType
init|=
literal|0
decl_stmt|;
comment|/**      * Description of the Method      *      * @param n  Description of the Parameter      * @return   Description of the Return Value      */
DECL|method|compareTo
specifier|public
name|int
name|compareTo
parameter_list|(
name|Object
name|n
parameter_list|)
block|{
if|if
condition|(
name|sortType
operator|<
literal|2
condition|)
block|{
name|double
name|diff
init|=
operator|(
operator|(
name|Node
operator|)
name|n
operator|)
operator|.
name|nodeRank
index|[
name|sortType
index|]
operator|-
name|nodeRank
index|[
name|sortType
index|]
decl_stmt|;
return|return
name|diff
operator|<
literal|0
condition|?
operator|-
literal|1
else|:
name|diff
operator|>
literal|0
condition|?
literal|1
else|:
literal|0
return|;
block|}
else|else
block|{
return|return
operator|(
operator|(
operator|(
name|Node
operator|)
name|n
operator|)
operator|.
name|incoming
operator|.
name|size
argument_list|()
operator|-
name|incoming
operator|.
name|size
argument_list|()
operator|)
return|;
block|}
block|}
comment|/**      * Constructor for the Node object      *      * @param id     Description of the Parameter      * @param name   Description of the Parameter      * @param title  Description of the Parameter      */
DECL|method|Node
specifier|public
name|Node
parameter_list|(
name|int
name|id
parameter_list|,
name|String
name|name
parameter_list|,
name|String
name|title
parameter_list|)
block|{
name|this
operator|.
name|id
operator|=
name|id
expr_stmt|;
name|this
operator|.
name|name
operator|=
name|name
expr_stmt|;
name|this
operator|.
name|title
operator|=
name|title
expr_stmt|;
name|this
operator|.
name|incoming
operator|=
operator|new
name|LinkedList
argument_list|()
expr_stmt|;
name|this
operator|.
name|outgoing
operator|=
operator|new
name|LinkedList
argument_list|()
expr_stmt|;
comment|//this.incomingNodes = new HashSet();
comment|//this.outgoingNodes = new HashSet();
name|this
operator|.
name|distance
operator|=
name|Float
operator|.
name|MAX_VALUE
expr_stmt|;
name|this
operator|.
name|nodeRank
index|[
literal|0
index|]
operator|=
name|this
operator|.
name|nodeRank
index|[
literal|1
index|]
operator|=
literal|1
expr_stmt|;
block|}
comment|/**      * Adds a feature to the Incoming attribute of the Node object      *      * @param incomingT  The feature to be added to the Incoming attribute      * @return           Description of the Return Value      */
DECL|method|addIncoming
specifier|public
name|boolean
name|addIncoming
parameter_list|(
name|Transition
name|incomingT
parameter_list|)
block|{
name|Integer
name|id
init|=
operator|new
name|Integer
argument_list|(
name|incomingT
operator|.
name|getFrom
argument_list|()
operator|.
name|id
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|incoming
operator|.
name|contains
argument_list|(
name|id
argument_list|)
condition|)
block|{
comment|// attn: doesn't scale well, but also saves memory
name|incoming
operator|.
name|addLast
argument_list|(
name|incomingT
argument_list|)
expr_stmt|;
comment|//incomingNodes.add(id);
return|return
literal|true
return|;
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
block|}
comment|/**      * Adds a feature to the Outgoing attribute of the Node object      *      * @param outgoingT  The feature to be added to the Outgoing attribute      * @return           Description of the Return Value      */
DECL|method|addOutgoing
specifier|public
name|boolean
name|addOutgoing
parameter_list|(
name|Transition
name|outgoingT
parameter_list|)
block|{
name|Integer
name|id
init|=
operator|new
name|Integer
argument_list|(
name|outgoingT
operator|.
name|getTo
argument_list|()
operator|.
name|id
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|outgoing
operator|.
name|contains
argument_list|(
name|id
argument_list|)
condition|)
block|{
name|outgoing
operator|.
name|addLast
argument_list|(
name|outgoingT
argument_list|)
expr_stmt|;
comment|//outgoingNodes.add(id);
return|return
literal|true
return|;
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
block|}
comment|/**      * Gets the incoming attribute of the Node object      *      * @return   The incoming value      */
DECL|method|getIncoming
specifier|public
name|LinkedList
name|getIncoming
parameter_list|()
block|{
return|return
name|incoming
return|;
block|}
comment|/**      * Gets the outgoing attribute of the Node object      *      * @return   The outgoing value      */
DECL|method|getOutgoing
specifier|public
name|LinkedList
name|getOutgoing
parameter_list|()
block|{
return|return
name|outgoing
return|;
block|}
comment|/**      * Sets the distance attribute of the Node object      *      * @param distance  The new distance value      */
DECL|method|setDistance
specifier|public
name|void
name|setDistance
parameter_list|(
name|float
name|distance
parameter_list|)
block|{
name|this
operator|.
name|distance
operator|=
name|distance
expr_stmt|;
block|}
comment|/**      * Gets the distance attribute of the Node object      *      * @return   The distance value      */
DECL|method|getDistance
specifier|public
name|float
name|getDistance
parameter_list|()
block|{
return|return
name|distance
return|;
block|}
comment|/**      * Gets the name attribute of the Node object      *      * @return   The name value      */
DECL|method|getName
specifier|public
name|String
name|getName
parameter_list|()
block|{
return|return
name|name
return|;
block|}
comment|/**      * Sets the title attribute of the Node object      *      * @param title  The new title value      */
DECL|method|setTitle
specifier|public
name|void
name|setTitle
parameter_list|(
name|String
name|title
parameter_list|)
block|{
name|this
operator|.
name|title
operator|=
name|title
expr_stmt|;
block|}
comment|/**      * Gets the title attribute of the Node object      *      * @return   The title value      */
DECL|method|getTitle
specifier|public
name|String
name|getTitle
parameter_list|()
block|{
return|return
name|title
return|;
block|}
comment|/**      * Gets the nodeRank attribute of the Node object      *      * @param idx  Description of the Parameter      * @return     The nodeRank value      */
DECL|method|getNodeRank
specifier|public
name|float
name|getNodeRank
parameter_list|(
name|int
name|idx
parameter_list|)
block|{
return|return
name|nodeRank
index|[
name|idx
index|]
return|;
block|}
comment|/**      * Sets the nodeRank attribute of the Node object      *      * @param nodeRank  The new nodeRank value      * @param idx       The new nodeRank value      */
DECL|method|setNodeRank
specifier|public
name|void
name|setNodeRank
parameter_list|(
name|float
name|nodeRank
parameter_list|,
name|int
name|idx
parameter_list|)
block|{
name|this
operator|.
name|nodeRank
index|[
name|idx
index|]
operator|=
name|nodeRank
expr_stmt|;
block|}
block|}
end_class
begin_comment
comment|/**  * Description of the Class  *  * @author    Administrator  * @created   30. Januar 2002  */
end_comment
begin_class
DECL|class|Transition
class|class
name|Transition
block|{
DECL|field|from
name|Node
name|from
decl_stmt|;
DECL|field|to
name|Node
name|to
decl_stmt|;
DECL|field|distance
name|float
name|distance
decl_stmt|;
DECL|field|linkRank
name|float
name|linkRank
index|[]
init|=
operator|new
name|float
index|[
literal|2
index|]
decl_stmt|;
DECL|field|isFrame
name|boolean
name|isFrame
decl_stmt|;
comment|/**      * Constructor for the Transition object      *      * @param from     Description of the Parameter      * @param to       Description of the Parameter      * @param isFrame  Description of the Parameter      */
DECL|method|Transition
specifier|public
name|Transition
parameter_list|(
name|Node
name|from
parameter_list|,
name|Node
name|to
parameter_list|,
name|boolean
name|isFrame
parameter_list|)
block|{
name|LinkedList
name|l
init|=
name|from
operator|.
name|getOutgoing
argument_list|()
decl_stmt|;
name|Iterator
name|i
init|=
name|l
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|i
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Transition
name|t
init|=
operator|(
name|Transition
operator|)
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|t
operator|.
name|getTo
argument_list|()
operator|==
name|to
condition|)
block|{
return|return;
comment|// schon enthalten
block|}
block|}
name|this
operator|.
name|from
operator|=
name|from
expr_stmt|;
name|this
operator|.
name|to
operator|=
name|to
expr_stmt|;
name|from
operator|.
name|addOutgoing
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|to
operator|.
name|addIncoming
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|this
operator|.
name|distance
operator|=
name|Integer
operator|.
name|MAX_VALUE
expr_stmt|;
name|this
operator|.
name|isFrame
operator|=
name|isFrame
expr_stmt|;
name|this
operator|.
name|linkRank
index|[
literal|0
index|]
operator|=
name|this
operator|.
name|linkRank
index|[
literal|1
index|]
operator|=
literal|1
expr_stmt|;
block|}
comment|/**      * Gets the to attribute of the Transition object      *      * @return   The to value      */
DECL|method|getTo
specifier|public
name|Node
name|getTo
parameter_list|()
block|{
return|return
name|to
return|;
block|}
comment|/**      * Gets the from attribute of the Transition object      *      * @return   The from value      */
DECL|method|getFrom
specifier|public
name|Node
name|getFrom
parameter_list|()
block|{
return|return
name|from
return|;
block|}
comment|/**      * Gets the distance attribute of the Transition object      *      * @return   The distance value      */
DECL|method|getDistance
specifier|public
name|float
name|getDistance
parameter_list|()
block|{
return|return
name|distance
return|;
block|}
comment|/**      * Sets the distance attribute of the Transition object      *      * @param distance  The new distance value      */
DECL|method|setDistance
specifier|public
name|void
name|setDistance
parameter_list|(
name|float
name|distance
parameter_list|)
block|{
name|this
operator|.
name|distance
operator|=
name|distance
expr_stmt|;
block|}
comment|/**      * Gets the frame attribute of the Transition object      *      * @return   The frame value      */
DECL|method|isFrame
specifier|public
name|boolean
name|isFrame
parameter_list|()
block|{
return|return
name|isFrame
return|;
block|}
comment|/**      * Gets the linkRank attribute of the Transition object      *      * @param idx  Description of the Parameter      * @return     The linkRank value      */
DECL|method|getLinkRank
specifier|public
name|float
name|getLinkRank
parameter_list|(
name|int
name|idx
parameter_list|)
block|{
return|return
name|linkRank
index|[
name|idx
index|]
return|;
block|}
comment|/**      * Sets the linkRank attribute of the Transition object      *      * @param linkRank  The new linkRank value      * @param idx       The new linkRank value      */
DECL|method|setLinkRank
specifier|public
name|void
name|setLinkRank
parameter_list|(
name|float
name|linkRank
parameter_list|,
name|int
name|idx
parameter_list|)
block|{
name|this
operator|.
name|linkRank
index|[
name|idx
index|]
operator|=
name|linkRank
expr_stmt|;
block|}
block|}
end_class
begin_comment
comment|/**  * Description of the Class  *  * @author    Administrator  * @created   30. Januar 2002  */
end_comment
begin_class
DECL|class|DistanceCount
specifier|public
class|class
name|DistanceCount
block|{
DECL|field|nodes
name|HashMap
name|nodes
init|=
operator|new
name|HashMap
argument_list|(
literal|100000
argument_list|)
decl_stmt|;
DECL|field|nodesToDo
name|LinkedList
name|nodesToDo
init|=
operator|new
name|LinkedList
argument_list|()
decl_stmt|;
DECL|field|id
specifier|static
name|int
name|id
init|=
literal|0
decl_stmt|;
comment|/**      * Gets the orCreateNode attribute of the DistanceCount object      *      * @param name   Description of the Parameter      * @param title  Description of the Parameter      * @return       The orCreateNode value      */
DECL|method|getOrCreateNode
name|Node
name|getOrCreateNode
parameter_list|(
name|String
name|name
parameter_list|,
name|String
name|title
parameter_list|)
block|{
name|Node
name|node
init|=
operator|(
name|Node
operator|)
name|nodes
operator|.
name|get
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|node
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|title
operator|!=
literal|null
condition|)
block|{
name|node
operator|.
name|setTitle
argument_list|(
name|title
argument_list|)
expr_stmt|;
block|}
return|return
name|node
return|;
block|}
else|else
block|{
name|node
operator|=
operator|new
name|Node
argument_list|(
name|id
operator|++
argument_list|,
name|name
argument_list|,
name|title
argument_list|)
expr_stmt|;
name|nodes
operator|.
name|put
argument_list|(
name|name
argument_list|,
name|node
argument_list|)
expr_stmt|;
return|return
name|node
return|;
block|}
block|}
comment|/**      * Constructor for the DistanceCount object      *      * @param filename         Description of the Parameter      * @exception IOException  Description of the Exception      */
DECL|method|DistanceCount
specifier|public
name|DistanceCount
parameter_list|(
name|String
name|filename
parameter_list|)
throws|throws
name|IOException
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"reading file..."
argument_list|)
expr_stmt|;
name|long
name|t1
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
name|BufferedReader
name|b
init|=
operator|new
name|BufferedReader
argument_list|(
operator|new
name|FileReader
argument_list|(
name|filename
argument_list|)
argument_list|)
decl_stmt|;
name|String
name|line
decl_stmt|;
name|boolean
name|firstNotFound
init|=
literal|true
decl_stmt|;
name|Node
name|firstNode
init|=
literal|null
decl_stmt|;
name|int
name|lines
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|(
name|line
operator|=
name|b
operator|.
name|readLine
argument_list|()
operator|)
operator|!=
literal|null
condition|)
block|{
name|lines
operator|++
expr_stmt|;
name|String
name|title
init|=
literal|null
decl_stmt|;
try|try
block|{
comment|//StringTokenizer st = new StringTokenizer(line, " ");
name|StringTokenizer
name|st
init|=
operator|new
name|StringTokenizer
argument_list|(
name|line
argument_list|,
literal|"\t"
argument_list|)
decl_stmt|;
name|String
name|from
init|=
name|st
operator|.
name|nextToken
argument_list|()
decl_stmt|;
if|if
condition|(
name|from
operator|.
name|endsWith
argument_list|(
literal|"/"
argument_list|)
condition|)
block|{
name|from
operator|=
name|from
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|from
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|from
operator|=
name|from
operator|.
name|toLowerCase
argument_list|()
expr_stmt|;
name|String
name|to
init|=
name|st
operator|.
name|nextToken
argument_list|()
decl_stmt|;
if|if
condition|(
name|to
operator|.
name|endsWith
argument_list|(
literal|"/"
argument_list|)
condition|)
block|{
name|to
operator|=
name|to
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|to
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|to
operator|=
name|to
operator|.
name|toLowerCase
argument_list|()
expr_stmt|;
name|boolean
name|isFrame
init|=
operator|(
name|Integer
operator|.
name|parseInt
argument_list|(
name|st
operator|.
name|nextToken
argument_list|()
argument_list|)
operator|==
literal|1
operator|)
decl_stmt|;
if|if
condition|(
name|st
operator|.
name|countTokens
argument_list|()
operator|>
literal|3
condition|)
block|{
name|title
operator|=
literal|"<untitled>"
expr_stmt|;
comment|//StringBuffer sb = new StringBuffer();
name|st
operator|.
name|nextToken
argument_list|()
expr_stmt|;
comment|// result
name|st
operator|.
name|nextToken
argument_list|()
expr_stmt|;
comment|// Mime Type
name|st
operator|.
name|nextToken
argument_list|()
expr_stmt|;
comment|// Size
comment|/*                      *  while(st.hasMoreTokens())                      *  {                      *  sb.append(st.nextToken()).append(" ");                      *  }                      */
name|title
operator|=
name|st
operator|.
name|nextToken
argument_list|()
expr_stmt|;
if|if
condition|(
name|title
operator|.
name|length
argument_list|()
operator|>
literal|2
condition|)
block|{
name|title
operator|=
name|title
operator|.
name|substring
argument_list|(
literal|1
argument_list|,
name|title
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
name|int
name|indexOfPara
init|=
name|title
operator|.
name|indexOf
argument_list|(
literal|"\""
argument_list|)
decl_stmt|;
if|if
condition|(
name|indexOfPara
operator|>
operator|-
literal|1
condition|)
block|{
name|title
operator|=
name|title
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|indexOfPara
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|Node
name|fromNode
init|=
name|getOrCreateNode
argument_list|(
name|from
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|Node
name|toNode
init|=
name|getOrCreateNode
argument_list|(
name|to
argument_list|,
name|title
argument_list|)
decl_stmt|;
name|Transition
name|t
init|=
operator|new
name|Transition
argument_list|(
name|fromNode
argument_list|,
name|toNode
argument_list|,
name|isFrame
argument_list|)
decl_stmt|;
comment|/*                  *  if(firstNotFound&& to.equals("http://127.0.0.1"))                  *  {                  *  firstNode = toNode;                  *  firstNotFound = false;                  *  }                  */
if|if
condition|(
name|lines
operator|%
literal|10000
operator|==
literal|0
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|""
operator|+
name|lines
operator|+
literal|" Lines; "
operator|+
name|nodes
operator|.
name|size
argument_list|()
operator|+
literal|" nodes"
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|NoSuchElementException
name|e
parameter_list|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Malformed line "
operator|+
name|lines
operator|+
literal|": field number doesn't match"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|e
parameter_list|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Malformed line "
operator|+
name|lines
operator|+
literal|": NumberFormat wrong"
argument_list|)
expr_stmt|;
block|}
block|}
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"finished; b"
operator|+
name|lines
operator|+
literal|" Lines; "
operator|+
name|nodes
operator|.
name|size
argument_list|()
operator|+
literal|" nodes"
argument_list|)
expr_stmt|;
name|long
name|t2
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|""
operator|+
operator|(
name|t2
operator|-
name|t1
operator|)
operator|+
literal|" ms"
argument_list|)
expr_stmt|;
comment|/*          *  if(firstNotFound)          *  {          *  System.out.println("Couldn't find start page");          *  System.exit(-1);          *  }          */
block|}
comment|/**      * Description of the Method      *      * @param firstNode  Description of the Parameter      */
DECL|method|calculateShortestDistance
specifier|public
name|void
name|calculateShortestDistance
parameter_list|(
name|Node
name|firstNode
parameter_list|)
block|{
name|clearDistances
argument_list|()
expr_stmt|;
name|firstNode
operator|.
name|setDistance
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|nodesToDo
operator|.
name|addLast
argument_list|(
name|firstNode
argument_list|)
expr_stmt|;
name|int
name|calculations
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|!
name|nodesToDo
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
name|calculations
operator|%
literal|100000
operator|==
literal|0
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Calculations: "
operator|+
name|calculations
operator|+
literal|"; nodes to go: "
operator|+
name|nodesToDo
operator|.
name|size
argument_list|()
operator|+
literal|" total Mem: "
operator|+
name|Runtime
operator|.
name|getRuntime
argument_list|()
operator|.
name|totalMemory
argument_list|()
operator|+
literal|"; free mem: "
operator|+
name|Runtime
operator|.
name|getRuntime
argument_list|()
operator|.
name|freeMemory
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|calculations
operator|++
expr_stmt|;
name|Node
name|act
init|=
operator|(
name|Node
operator|)
name|nodesToDo
operator|.
name|removeFirst
argument_list|()
decl_stmt|;
name|LinkedList
name|outTrans
init|=
name|act
operator|.
name|getOutgoing
argument_list|()
decl_stmt|;
name|float
name|distance
init|=
name|act
operator|.
name|getDistance
argument_list|()
decl_stmt|;
name|Iterator
name|i
init|=
name|outTrans
operator|.
name|iterator
argument_list|()
decl_stmt|;
comment|//distance++;
while|while
condition|(
name|i
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Transition
name|t
init|=
operator|(
name|Transition
operator|)
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
name|float
name|transDistance
init|=
name|t
operator|.
name|getDistance
argument_list|()
decl_stmt|;
comment|/*                  *  if (t.isFrame())                  *  {                  *  System.out.println("Frame from " + t.from.getName() + " to " + t.to.getName());                  *  }                  */
name|float
name|newDistance
init|=
name|distance
operator|+
operator|(
name|t
operator|.
name|isFrame
argument_list|()
condition|?
literal|0.25f
else|:
literal|1f
operator|)
decl_stmt|;
if|if
condition|(
name|transDistance
operator|>
name|newDistance
condition|)
block|{
name|t
operator|.
name|setDistance
argument_list|(
name|newDistance
argument_list|)
expr_stmt|;
name|Node
name|to
init|=
name|t
operator|.
name|getTo
argument_list|()
decl_stmt|;
if|if
condition|(
name|to
operator|.
name|distance
operator|>
name|distance
condition|)
block|{
name|to
operator|.
name|setDistance
argument_list|(
name|newDistance
argument_list|)
expr_stmt|;
name|nodesToDo
operator|.
name|addLast
argument_list|(
name|to
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/*              *  if(looksGood)              *  {              *  System.out.println("Node " + act.id + " looks good");              *  }              */
block|}
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Calculations: "
operator|+
name|calculations
argument_list|)
expr_stmt|;
block|}
comment|/**      * Description of the Method      */
DECL|method|clearDistances
specifier|public
name|void
name|clearDistances
parameter_list|()
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Clearing distance data..."
argument_list|)
expr_stmt|;
name|Iterator
name|it
init|=
name|nodes
operator|.
name|values
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|int
name|nr
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Node
name|n
init|=
operator|(
name|Node
operator|)
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
name|nr
operator|++
expr_stmt|;
name|n
operator|.
name|setDistance
argument_list|(
name|Float
operator|.
name|MAX_VALUE
argument_list|)
expr_stmt|;
block|}
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"cleared "
operator|+
name|nr
operator|+
literal|" nodes. done"
argument_list|)
expr_stmt|;
block|}
comment|/**      * Description of the Method      *      * @param nodeFrom  Description of the Parameter      * @param nodeTo    Description of the Parameter      */
DECL|method|printDistance
specifier|public
name|void
name|printDistance
parameter_list|(
name|String
name|nodeFrom
parameter_list|,
name|String
name|nodeTo
parameter_list|)
block|{
name|Node
name|firstNode
init|=
operator|(
name|Node
operator|)
name|nodes
operator|.
name|get
argument_list|(
name|nodeFrom
argument_list|)
decl_stmt|;
if|if
condition|(
name|firstNode
operator|==
literal|null
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"FROM node not found"
argument_list|)
expr_stmt|;
return|return;
block|}
name|Node
name|toNode
init|=
operator|(
name|Node
operator|)
name|nodes
operator|.
name|get
argument_list|(
name|nodeTo
argument_list|)
decl_stmt|;
if|if
condition|(
name|toNode
operator|==
literal|null
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"TO node not found"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|//System.out.println("resetting node distance...");
comment|//clearDistances();
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"calculating..."
argument_list|)
expr_stmt|;
name|calculateShortestDistance
argument_list|(
name|firstNode
argument_list|)
expr_stmt|;
comment|//t1 = System.currentTimeMillis();
comment|//System.out.println("" + (t1-t2) + " ms");
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"\nSorting..."
argument_list|)
expr_stmt|;
comment|/*          *  Collection nodeCollection = nodes.values();          *  Object[] nodeArray = nodeCollection.toArray();          *  Arrays.sort(nodeArray);          *  t2 = System.currentTimeMillis();          *  System.out.println("" + (t2-t1) + " ms");          *  int from = 0;          *  int to = 1;          */
comment|/*          *  /calculate page Rank          *  for(int i = 0; i< 1; i++)          *  {          *  from = i%2;          *  to = (i+1) % 2;          *  for(int j = 0; j<nodeArray.length; j++)          *  {          *  Node act = (Node)nodeArray[j];          *  LinkedList inc = act.getIncoming();          *  float pageRank = 0;          *  Iterator it = inc.iterator();          *  while(it.hasNext())          *  {          *  Transition t = (Transition)it.next();          *  pageRank += t.getLinkRank(from);          *  }          *  act.setNodeRank(pageRank, to);          *  LinkedList out = act.getOutgoing();          *  int size = out.size();          *  if(size> 0)          *  {          *  float linkRank = pageRank / size;          *  it = out.iterator();          *  while(it.hasNext())          *  {          *  Transition t = (Transition)it.next();          *  t.setLinkRank(linkRank, to);          *  }          *  }          *  }          *  }          */
comment|/*          *  System.out.println("\nLink Count:");          *  for(int i=0; i<10; i++)          *  {          *  Node n = ((Node)nodeArray[i]);          *  System.out.println("Node " + n.name + ": " + n.getIncoming().size() + "; pageRank: " + n.getNodeRank(to));          *  }          *  for(int i=nodeArray.length/2; i<nodeArray.length/2+10; i++)          *  {          *  Node n = ((Node)nodeArray[i]);          *  System.out.println("Node " + n.name + ": " + n.getIncoming().size() + "; pageRank: " + n.getNodeRank(to));          *  }          *  for(int i=nodeArray.length-10; i<nodeArray.length; i++)          *  {          *  Node n = ((Node)nodeArray[i]);          *  System.out.println("Node " + n.name + ": " + n.getIncoming().size() + "; pageRank: " + n.getNodeRank(to));          *  }          *  Node.sortType = to;          *  Arrays.sort(nodeArray);          *  System.out.println("\nPageRank Count:");          *  for(int i=0; i<10; i++)          *  {          *  Node n = ((Node)nodeArray[i]);          *  System.out.println("Node " + n.name + ": " + n.getIncoming().size() + "; pageRank: " + n.getNodeRank(to));          *  }          *  for(int i=nodeArray.length/2; i<nodeArray.length/2+10; i++)          *  {          *  Node n = ((Node)nodeArray[i]);          *  System.out.println("Node " + n.name + ": " + n.getIncoming().size() + "; pageRank: " + n.getNodeRank(to));          *  }          *  for(int i=nodeArray.length-10; i<nodeArray.length; i++)          *  {          *  Node n = ((Node)nodeArray[i]);          *  System.out.println("Node " + n.name + ": " + n.getIncoming().size() + "; pageRank: " + n.getNodeRank(to));          *  }          *  System.out.println("\nStats...");          *  float distanceAccumulated=0;          *  float distanceMax = 0;          *  int notCounted = 0;          *  for(int j = 0; j<nodeArray.length; j++)          *  {          *  Node n = (Node)nodeArray[j];          *  if(n.distance != Integer.MAX_VALUE)          *  {          *  distanceAccumulated += n.distance;          *  distanceMax = Math.max(distanceMax, n.distance);          *  }          *  else          *  {          *  notCounted++;          *  }          *  }          *  System.out.println("Mean Distance:          " + ((double)distanceAccumulated)/nodeArray.length);          *  System.out.println("Max Distance:           " + (distanceMax));          *  System.out.println("Not reachable nodes(?): " + notCounted);          *  System.out.println("Referer Median:         " + ((Node)(nodeArray[Math.round(nodeArray.length/2)])).incoming.size());          *  System.out.println("\nSamples:");          */
name|printShortestRoute
argument_list|(
name|toNode
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/**      * Description of the Method      */
DECL|method|printRandomRoute
specifier|public
name|void
name|printRandomRoute
parameter_list|()
block|{
name|Random
name|r
init|=
operator|new
name|java
operator|.
name|util
operator|.
name|Random
argument_list|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
argument_list|)
decl_stmt|;
name|Collection
name|nodeColl
init|=
name|nodes
operator|.
name|values
argument_list|()
decl_stmt|;
name|Object
index|[]
name|nodeArray
init|=
operator|(
name|Object
index|[]
operator|)
name|nodeColl
operator|.
name|toArray
argument_list|()
decl_stmt|;
name|int
name|rnd
init|=
call|(
name|int
call|)
argument_list|(
name|r
operator|.
name|nextDouble
argument_list|()
operator|*
name|nodeArray
operator|.
name|length
argument_list|)
decl_stmt|;
name|Node
name|from
init|=
operator|(
name|Node
operator|)
name|nodeArray
index|[
name|rnd
index|]
decl_stmt|;
name|rnd
operator|=
call|(
name|int
call|)
argument_list|(
name|r
operator|.
name|nextDouble
argument_list|()
operator|*
name|nodeArray
operator|.
name|length
argument_list|)
expr_stmt|;
name|Node
name|to
init|=
operator|(
name|Node
operator|)
name|nodeArray
index|[
name|rnd
index|]
decl_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Calculating distance..."
argument_list|)
expr_stmt|;
name|calculateShortestDistance
argument_list|(
name|from
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"printing..."
argument_list|)
expr_stmt|;
name|printShortestRoute
argument_list|(
name|to
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/**      * Description of the Method      *      * @param n          Description of the Parameter      * @param indent     Description of the Parameter      * @param linkCount  Description of the Parameter      */
DECL|method|printShortestRoute
specifier|public
name|void
name|printShortestRoute
parameter_list|(
name|Node
name|n
parameter_list|,
name|int
name|indent
parameter_list|,
name|int
name|linkCount
parameter_list|)
block|{
name|String
name|spaces
init|=
literal|"                                                            "
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|indent
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
operator|.
name|getIncoming
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
name|spaces
operator|+
literal|"<start>"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|System
operator|.
name|out
operator|.
name|print
argument_list|(
name|spaces
operator|+
literal|"+- "
operator|+
name|n
operator|.
name|name
operator|+
literal|"    ("
operator|+
operator|(
name|n
operator|.
name|getTitle
argument_list|()
operator|!=
literal|null
condition|?
name|n
operator|.
name|getTitle
argument_list|()
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|Math
operator|.
name|min
argument_list|(
name|n
operator|.
name|getTitle
argument_list|()
operator|.
name|length
argument_list|()
argument_list|,
literal|25
argument_list|)
argument_list|)
else|:
literal|""
operator|)
operator|+
literal|"\")     D:"
operator|+
name|n
operator|.
name|distance
operator|+
literal|"; L:"
operator|+
name|n
operator|.
name|getIncoming
argument_list|()
operator|.
name|size
argument_list|()
operator|+
literal|"; C:"
operator|+
name|linkCount
argument_list|)
expr_stmt|;
name|Iterator
name|it
init|=
name|n
operator|.
name|getIncoming
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|float
name|dist
init|=
name|n
operator|.
name|distance
decl_stmt|;
if|if
condition|(
name|dist
operator|>
literal|10000000
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
name|spaces
operator|+
literal|"\n--no link--"
argument_list|)
expr_stmt|;
return|return;
block|}
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Transition
name|t
init|=
operator|(
name|Transition
operator|)
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|t
operator|.
name|distance
operator|<=
name|dist
condition|)
block|{
if|if
condition|(
name|t
operator|.
name|isFrame
argument_list|()
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|" **F** ->"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|" -> "
argument_list|)
expr_stmt|;
block|}
name|printShortestRoute
argument_list|(
name|t
operator|.
name|getFrom
argument_list|()
argument_list|,
name|indent
operator|+
literal|1
argument_list|,
name|linkCount
operator|+
name|n
operator|.
name|getIncoming
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|//System.out.println("");
block|}
comment|/**      * this class reads in store.log, constructs a graph of the crawled web and      * is able to perform a breadth-first search for the shortest distance      * between two nodes<br>      * Note: this is experimental stuff. get into the source code to see how it      * works      *      * @param args  args[0] must point to the store.log file      */
DECL|method|main
specifier|public
specifier|static
name|void
name|main
parameter_list|(
name|String
index|[]
name|args
parameter_list|)
block|{
comment|// Syntax: DistanceCount<store.log>
try|try
block|{
name|DistanceCount
name|dc
init|=
operator|new
name|DistanceCount
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|boolean
name|running
init|=
literal|true
decl_stmt|;
name|BufferedReader
name|in
init|=
operator|new
name|BufferedReader
argument_list|(
operator|new
name|InputStreamReader
argument_list|(
name|System
operator|.
name|in
argument_list|)
argument_list|,
literal|400
argument_list|)
decl_stmt|;
while|while
condition|(
name|running
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|print
argument_list|(
literal|"\n\nCommand (? for help)> "
argument_list|)
expr_stmt|;
name|String
name|newL
decl_stmt|;
name|String
name|input
init|=
literal|""
decl_stmt|;
comment|//while((newL = in.readLine()) != null)
comment|//{
name|input
operator|=
name|in
operator|.
name|readLine
argument_list|()
expr_stmt|;
name|StringTokenizer
name|st
init|=
operator|new
name|StringTokenizer
argument_list|(
name|input
argument_list|,
literal|" "
argument_list|)
decl_stmt|;
name|String
name|command
decl_stmt|;
name|boolean
name|printHelp
init|=
literal|false
decl_stmt|;
if|if
condition|(
operator|!
name|st
operator|.
name|hasMoreTokens
argument_list|()
condition|)
block|{
name|printHelp
operator|=
literal|true
expr_stmt|;
name|command
operator|=
literal|"?"
expr_stmt|;
block|}
else|else
block|{
name|command
operator|=
name|st
operator|.
name|nextToken
argument_list|()
expr_stmt|;
block|}
try|try
block|{
if|if
condition|(
literal|"?"
operator|.
name|equals
argument_list|(
name|command
argument_list|)
condition|)
block|{
name|printHelp
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|"d"
operator|.
name|equals
argument_list|(
name|command
argument_list|)
condition|)
block|{
name|String
name|from
init|=
name|st
operator|.
name|nextToken
argument_list|()
decl_stmt|;
name|String
name|to
init|=
name|st
operator|.
name|nextToken
argument_list|()
decl_stmt|;
name|dc
operator|.
name|printDistance
argument_list|(
name|from
argument_list|,
name|to
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|"q"
operator|.
name|equals
argument_list|(
name|command
argument_list|)
condition|)
block|{
name|running
operator|=
literal|false
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|"r"
operator|.
name|equals
argument_list|(
name|command
argument_list|)
condition|)
block|{
name|dc
operator|.
name|printRandomRoute
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"unknown command '"
operator|+
name|command
operator|+
literal|"'"
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|java
operator|.
name|util
operator|.
name|NoSuchElementException
name|e
parameter_list|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Syntax error"
argument_list|)
expr_stmt|;
name|e
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
name|printHelp
operator|=
literal|true
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|e
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|printHelp
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"\nSyntax\n"
operator|+
literal|"?   print this help message\n"
operator|+
literal|"d<page1><page2>   print shortest route from page1 to page2\n"
operator|+
literal|"r                   print random walk\n"
operator|+
literal|"q                   quit"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|e
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ArrayIndexOutOfBoundsException
name|e
parameter_list|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Syntax: java ... store.log"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_class
end_unit
