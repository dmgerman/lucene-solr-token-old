begin_unit
begin_comment
comment|/* ====================================================================  * The Apache Software License, Version 1.1  *  * Copyright (c) 2001 The Apache Software Foundation.  All rights  * reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  *  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in  *    the documentation and/or other materials provided with the  *    distribution.  *  * 3. The end-user documentation included with the redistribution,  *    if any, must include the following acknowledgment:  *       "This product includes software developed by the  *        Apache Software Foundation (http://www.apache.org/)."  *    Alternately, this acknowledgment may appear in the software itself,  *    if and wherever such third-party acknowledgments normally appear.  *  * 4. The names "Apache" and "Apache Software Foundation" and  *    "Apache Lucene" must not be used to endorse or promote products  *    derived from this software without prior written permission. For  *    written permission, please contact apache@apache.org.  *  * 5. Products derived from this software may not be called "Apache",  *    "Apache Lucene", nor may "Apache" appear in their name, without  *    prior written permission of the Apache Software Foundation.  *  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED  * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE  * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR  * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF  * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  * ====================================================================  *  * This software consists of voluntary contributions made by many  * individuals on behalf of the Apache Software Foundation.  For more  * information on the Apache Software Foundation, please see  *<http://www.apache.org/>.  */
end_comment
begin_package
DECL|package|de.lanlab.larm.fetcher
package|package
name|de
operator|.
name|lanlab
operator|.
name|larm
operator|.
name|fetcher
package|;
end_package
begin_import
import|import
name|de
operator|.
name|lanlab
operator|.
name|larm
operator|.
name|util
operator|.
name|SimpleObservable
import|;
end_import
begin_import
import|import
name|de
operator|.
name|lanlab
operator|.
name|larm
operator|.
name|util
operator|.
name|State
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|*
import|;
end_import
begin_import
import|import
name|java
operator|.
name|net
operator|.
name|*
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|*
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|oro
operator|.
name|text
operator|.
name|perl
operator|.
name|Perl5Util
import|;
end_import
begin_import
import|import
name|de
operator|.
name|lanlab
operator|.
name|larm
operator|.
name|util
operator|.
name|*
import|;
end_import
begin_import
import|import
name|de
operator|.
name|lanlab
operator|.
name|larm
operator|.
name|threads
operator|.
name|*
import|;
end_import
begin_import
import|import
name|HTTPClient
operator|.
name|*
import|;
end_import
begin_import
import|import
name|de
operator|.
name|lanlab
operator|.
name|larm
operator|.
name|net
operator|.
name|*
import|;
end_import
begin_comment
comment|/**  * this factory simply creates fetcher threads. It's gonna be passed to the  * ThreadPool because the pool is creating the threads on its own  *  * @author    Administrator  * @created   17. Februar 2002  * @version $Id$  */
end_comment
begin_class
DECL|class|REFThreadFactory
class|class
name|REFThreadFactory
extends|extends
name|ThreadFactory
block|{
DECL|field|threadGroup
name|ThreadGroup
name|threadGroup
init|=
operator|new
name|ThreadGroup
argument_list|(
literal|"RobotExclusionFilter"
argument_list|)
decl_stmt|;
comment|/**      * Description of the Method      *      * @param count  Description of the Parameter      * @return       Description of the Return Value      */
DECL|method|createServerThread
specifier|public
name|ServerThread
name|createServerThread
parameter_list|(
name|int
name|count
parameter_list|)
block|{
name|ServerThread
name|newThread
init|=
operator|new
name|ServerThread
argument_list|(
name|count
argument_list|,
literal|"REF-"
operator|+
name|count
argument_list|,
name|threadGroup
argument_list|)
decl_stmt|;
name|newThread
operator|.
name|setPriority
argument_list|(
literal|4
argument_list|)
expr_stmt|;
return|return
name|newThread
return|;
block|}
block|}
end_class
begin_comment
comment|/**  * the RE filter obeys the robot exclusion standard. If a new host name is supposed  * to be accessed, it first loads a "/robots.txt" on the given server and records the  * disallows stated in that file.  * The REFilter has a thread pool on its own to prevent the message handler from being  * clogged up if the server doesn't respond. Incoming messages are queued while the  * robots.txt is loaded.  * The information is stored in HostInfo records of the host manager class  *  * @author    Clemens Marschner  * @created   17. Februar 2002  */
end_comment
begin_class
DECL|class|RobotExclusionFilter
specifier|public
class|class
name|RobotExclusionFilter
extends|extends
name|Filter
implements|implements
name|MessageListener
block|{
DECL|field|hostManager
specifier|protected
name|HostManager
name|hostManager
decl_stmt|;
DECL|field|log
specifier|protected
name|SimpleLogger
name|log
decl_stmt|;
comment|/**      * Constructor for the RobotExclusionFilter object      *      * @param hm  Description of the Parameter      */
DECL|method|RobotExclusionFilter
specifier|public
name|RobotExclusionFilter
parameter_list|(
name|HostManager
name|hm
parameter_list|)
block|{
name|log
operator|=
operator|new
name|SimpleLogger
argument_list|(
literal|"RobotExclusionFilter"
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|hostManager
operator|=
name|hm
expr_stmt|;
name|rePool
operator|=
operator|new
name|ThreadPool
argument_list|(
literal|5
argument_list|,
operator|new
name|REFThreadFactory
argument_list|()
argument_list|)
expr_stmt|;
name|rePool
operator|.
name|init
argument_list|()
expr_stmt|;
name|log
operator|.
name|setFlushAtOnce
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|log
operator|.
name|log
argument_list|(
literal|"refilter: initialized"
argument_list|)
expr_stmt|;
block|}
comment|/**      * called by the message handler      */
DECL|method|notifyAddedToMessageHandler
specifier|public
name|void
name|notifyAddedToMessageHandler
parameter_list|(
name|MessageHandler
name|handler
parameter_list|)
block|{
name|this
operator|.
name|messageHandler
operator|=
name|handler
expr_stmt|;
block|}
DECL|field|messageHandler
name|MessageHandler
name|messageHandler
init|=
literal|null
decl_stmt|;
DECL|field|rePool
name|ThreadPool
name|rePool
decl_stmt|;
comment|/**      * method that handles each URL request<p>      *      * This method will get the robots.txt file the first time a server is      * requested. See the description above.      *      * @param message      *      the (URL)Message      * @return      *      the original message or NULL if this host had a disallow on that URL      * @link{http://info.webcrawler.com/mak/projects/robots/norobots.html})      */
DECL|method|handleRequest
specifier|public
name|Message
name|handleRequest
parameter_list|(
name|Message
name|message
parameter_list|)
block|{
comment|//log.logThreadSafe("handleRequest: got message: " + message);
try|try
block|{
comment|// assert message instanceof URLMessage;
name|URLMessage
name|urlMsg
init|=
operator|(
operator|(
name|URLMessage
operator|)
name|message
operator|)
decl_stmt|;
name|URL
name|url
init|=
name|urlMsg
operator|.
name|getUrl
argument_list|()
decl_stmt|;
comment|//            String urlString = urlMsg.getNormalizedURLString();
comment|//            URL nUrl = new URL(urlString);
comment|//assert url != null;
name|HostInfo
name|h
init|=
name|hostManager
operator|.
name|getHostInfo
argument_list|(
name|url
operator|.
name|getHost
argument_list|()
argument_list|)
decl_stmt|;
synchronized|synchronized
init|(
name|h
init|)
block|{
if|if
condition|(
operator|!
name|h
operator|.
name|isRobotTxtChecked
argument_list|()
operator|&&
operator|!
name|h
operator|.
name|isLoadingRobotsTxt
argument_list|()
condition|)
block|{
name|log
operator|.
name|logThreadSafe
argument_list|(
literal|"handleRequest: starting to get robots.txt"
argument_list|)
expr_stmt|;
comment|// probably this results in Race Conditions here
name|rePool
operator|.
name|doTask
argument_list|(
operator|new
name|RobotExclusionTask
argument_list|(
name|h
argument_list|)
argument_list|,
operator|new
name|Integer
argument_list|(
name|h
operator|.
name|getId
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|h
operator|.
name|setLoadingRobotsTxt
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
comment|// isLoading...() and queuedRequest.insert() must be atomic
if|if
condition|(
name|h
operator|.
name|isLoadingRobotsTxt
argument_list|()
condition|)
block|{
comment|//log.logThreadSafe("handleRequest: other thread is loading");
comment|// assert h.queuedRequests != null
name|h
operator|.
name|insertIntoQueue
argument_list|(
name|message
argument_list|)
expr_stmt|;
comment|// not thread safe
name|log
operator|.
name|logThreadSafe
argument_list|(
literal|"handleRequest: queued file "
operator|+
name|url
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
comment|//log.logThreadSafe("handleRequest: no thread is loading; robots.txt loaded");
comment|//log.logThreadSafe("handleRequest: checking if allowed");
name|String
name|path
init|=
name|url
operator|.
name|getPath
argument_list|()
decl_stmt|;
if|if
condition|(
name|path
operator|==
literal|null
operator|||
name|path
operator|.
name|equals
argument_list|(
literal|""
argument_list|)
condition|)
block|{
name|path
operator|=
literal|"/"
expr_stmt|;
block|}
if|if
condition|(
name|h
operator|.
name|isAllowed
argument_list|(
name|path
argument_list|)
condition|)
block|{
comment|// log.logThreadSafe("handleRequest: file " + urlMsg.getURLString() + " ok");
return|return
name|message
return|;
block|}
name|log
operator|.
name|logThreadSafe
argument_list|(
literal|"handleRequest: file "
operator|+
name|urlMsg
operator|.
name|getURLString
argument_list|()
operator|+
literal|" filtered"
argument_list|)
expr_stmt|;
name|this
operator|.
name|filtered
operator|++
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|e
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
DECL|field|headers
specifier|private
specifier|static
specifier|volatile
name|NVPair
name|headers
index|[]
init|=
operator|new
name|NVPair
index|[
literal|1
index|]
decl_stmt|;
static|static
block|{
name|headers
index|[
literal|0
index|]
operator|=
operator|new
name|HTTPClient
operator|.
name|NVPair
argument_list|(
literal|"User-Agent"
argument_list|,
name|Constants
operator|.
name|CRAWLER_AGENT
argument_list|)
expr_stmt|;
block|}
comment|/**      * the task that actually loads and parses the robots.txt files      *      * @author    Clemens Marschner      * @created   17. Februar 2002      */
DECL|class|RobotExclusionTask
class|class
name|RobotExclusionTask
implements|implements
name|InterruptableTask
block|{
DECL|field|hostInfo
name|HostInfo
name|hostInfo
decl_stmt|;
comment|/**          * Constructor for the RobotExclusionTask object          *          * @param hostInfo  Description of the Parameter          */
DECL|method|RobotExclusionTask
specifier|public
name|RobotExclusionTask
parameter_list|(
name|HostInfo
name|hostInfo
parameter_list|)
block|{
name|this
operator|.
name|hostInfo
operator|=
name|hostInfo
expr_stmt|;
block|}
comment|/**          * dummy          *          * @return   The info value          */
DECL|method|getInfo
specifier|public
name|String
name|getInfo
parameter_list|()
block|{
return|return
literal|""
return|;
block|}
comment|/**          * not used          */
DECL|method|interrupt
specifier|public
name|void
name|interrupt
parameter_list|()
block|{ }
comment|/**          * gets a robots.txt file and adds the information to the hostInfo          * structure          *          * @param thread  the server thread (passed by the thread pool)          */
DECL|method|run
specifier|public
name|void
name|run
parameter_list|(
name|ServerThread
name|thread
parameter_list|)
block|{
name|String
name|threadName
init|=
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|getName
argument_list|()
decl_stmt|;
synchronized|synchronized
init|(
name|hostInfo
init|)
block|{
if|if
condition|(
name|hostInfo
operator|.
name|isRobotTxtChecked
argument_list|()
condition|)
block|{
name|log
operator|.
name|logThreadSafe
argument_list|(
literal|"task "
operator|+
name|threadName
operator|+
literal|": already loaded "
operator|+
name|hostInfo
operator|.
name|getHostName
argument_list|()
argument_list|)
expr_stmt|;
return|return;
comment|// may happen 'cause check is not synchronized
block|}
block|}
comment|// assert hostInfo != null;
name|log
operator|.
name|logThreadSafe
argument_list|(
literal|"task "
operator|+
name|threadName
operator|+
literal|": starting to load "
operator|+
name|hostInfo
operator|.
name|getHostName
argument_list|()
argument_list|)
expr_stmt|;
comment|//hostInfo.setLoadingRobotsTxt(true);
name|String
index|[]
name|disallows
init|=
literal|null
decl_stmt|;
name|boolean
name|errorOccured
init|=
literal|false
decl_stmt|;
try|try
block|{
name|log
operator|.
name|logThreadSafe
argument_list|(
literal|"task "
operator|+
name|threadName
operator|+
literal|": getting connection"
argument_list|)
expr_stmt|;
name|HTTPConnection
name|conn
init|=
operator|new
name|HTTPConnection
argument_list|(
name|hostInfo
operator|.
name|getHostName
argument_list|()
argument_list|)
decl_stmt|;
name|conn
operator|.
name|setTimeout
argument_list|(
literal|30000
argument_list|)
expr_stmt|;
comment|// wait at most 20 secs
name|HTTPResponse
name|res
init|=
name|conn
operator|.
name|Get
argument_list|(
literal|"/robots.txt"
argument_list|,
operator|(
name|String
operator|)
literal|null
argument_list|,
name|headers
argument_list|)
decl_stmt|;
name|log
operator|.
name|logThreadSafe
argument_list|(
literal|"task "
operator|+
name|threadName
operator|+
literal|": got connection."
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|.
name|getStatusCode
argument_list|()
operator|!=
literal|200
condition|)
block|{
name|errorOccured
operator|=
literal|true
expr_stmt|;
name|log
operator|.
name|log
argument_list|(
literal|"task "
operator|+
name|threadName
operator|+
literal|": return code was "
operator|+
name|res
operator|.
name|getStatusCode
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|log
operator|.
name|logThreadSafe
argument_list|(
literal|"task "
operator|+
name|threadName
operator|+
literal|": reading"
argument_list|)
expr_stmt|;
name|byte
index|[]
name|file
init|=
name|res
operator|.
name|getData
argument_list|(
literal|40000
argument_list|)
decl_stmt|;
comment|// max. 40 kb
name|log
operator|.
name|logThreadSafe
argument_list|(
literal|"task "
operator|+
name|threadName
operator|+
literal|": reading done. parsing"
argument_list|)
expr_stmt|;
name|disallows
operator|=
name|parse
argument_list|(
operator|new
name|BufferedReader
argument_list|(
operator|new
name|InputStreamReader
argument_list|(
operator|new
name|ByteArrayInputStream
argument_list|(
name|file
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|log
operator|.
name|logThreadSafe
argument_list|(
literal|"task "
operator|+
name|threadName
operator|+
literal|": parsing done. found "
operator|+
name|disallows
operator|.
name|length
operator|+
literal|" disallows"
argument_list|)
expr_stmt|;
comment|// assert disallows != null
comment|// HostInfo hostInfo = hostManager.getHostInfo(this.hostName);
comment|// assert hostInfo != null
name|log
operator|.
name|logThreadSafe
argument_list|(
literal|"task "
operator|+
name|threadName
operator|+
literal|": setting disallows"
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|java
operator|.
name|net
operator|.
name|UnknownHostException
name|e
parameter_list|)
block|{
name|hostInfo
operator|.
name|setReachable
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|log
operator|.
name|logThreadSafe
argument_list|(
literal|"task "
operator|+
name|threadName
operator|+
literal|": unknown host '"
operator|+
name|hostInfo
operator|.
name|getHostName
argument_list|()
operator|+
literal|"'. setting to unreachable"
argument_list|)
expr_stmt|;
name|errorOccured
operator|=
literal|true
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|java
operator|.
name|net
operator|.
name|NoRouteToHostException
name|e
parameter_list|)
block|{
name|hostInfo
operator|.
name|setReachable
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|log
operator|.
name|logThreadSafe
argument_list|(
literal|"task "
operator|+
name|threadName
operator|+
literal|": no route to '"
operator|+
name|hostInfo
operator|.
name|getHostName
argument_list|()
operator|+
literal|"'. setting to unreachable"
argument_list|)
expr_stmt|;
name|errorOccured
operator|=
literal|true
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|java
operator|.
name|net
operator|.
name|ConnectException
name|e
parameter_list|)
block|{
name|hostInfo
operator|.
name|setReachable
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|log
operator|.
name|logThreadSafe
argument_list|(
literal|"task "
operator|+
name|threadName
operator|+
literal|": connect exception while connecting to '"
operator|+
name|hostInfo
operator|.
name|getHostName
argument_list|()
operator|+
literal|"'. setting to unreachable"
argument_list|)
expr_stmt|;
name|errorOccured
operator|=
literal|true
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|java
operator|.
name|io
operator|.
name|InterruptedIOException
name|e
parameter_list|)
block|{
comment|// time out. fatal in this case
name|hostInfo
operator|.
name|setReachable
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|log
operator|.
name|logThreadSafe
argument_list|(
literal|"task "
operator|+
name|threadName
operator|+
literal|": time out while connecting to '"
operator|+
name|hostInfo
operator|.
name|getHostName
argument_list|()
operator|+
literal|"'. setting to unreachable"
argument_list|)
expr_stmt|;
name|errorOccured
operator|=
literal|true
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|errorOccured
operator|=
literal|true
expr_stmt|;
name|log
operator|.
name|log
argument_list|(
literal|"task "
operator|+
name|threadName
operator|+
literal|": unknown exception: "
operator|+
name|e
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|": "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
operator|+
literal|". continuing"
argument_list|)
expr_stmt|;
name|log
operator|.
name|log
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
name|errorOccured
condition|)
block|{
name|log
operator|.
name|logThreadSafe
argument_list|(
literal|"task "
operator|+
name|threadName
operator|+
literal|": error occured. putback..."
argument_list|)
expr_stmt|;
synchronized|synchronized
init|(
name|hostInfo
init|)
block|{
name|hostInfo
operator|.
name|setRobotsChecked
argument_list|(
literal|true
argument_list|,
literal|null
argument_list|)
expr_stmt|;
comment|// crawl everything
name|hostInfo
operator|.
name|setLoadingRobotsTxt
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|log
operator|.
name|logThreadSafe
argument_list|(
literal|"task "
operator|+
name|threadName
operator|+
literal|": now put "
operator|+
name|hostInfo
operator|.
name|getQueueSize
argument_list|()
operator|+
literal|" queueud requests back"
argument_list|)
expr_stmt|;
comment|//hostInfo.setLoadingRobotsTxt(false);
name|putBackURLs
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
name|log
operator|.
name|logThreadSafe
argument_list|(
literal|"task "
operator|+
name|threadName
operator|+
literal|": finished. putback..."
argument_list|)
expr_stmt|;
synchronized|synchronized
init|(
name|hostInfo
init|)
block|{
name|hostInfo
operator|.
name|setRobotsChecked
argument_list|(
literal|true
argument_list|,
name|disallows
argument_list|)
expr_stmt|;
name|log
operator|.
name|logThreadSafe
argument_list|(
literal|"task "
operator|+
name|threadName
operator|+
literal|": done"
argument_list|)
expr_stmt|;
name|log
operator|.
name|logThreadSafe
argument_list|(
literal|"task "
operator|+
name|threadName
operator|+
literal|": now put "
operator|+
name|hostInfo
operator|.
name|getQueueSize
argument_list|()
operator|+
literal|" queueud requests back"
argument_list|)
expr_stmt|;
name|hostInfo
operator|.
name|setLoadingRobotsTxt
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|putBackURLs
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**          * put back queued URLs          */
DECL|method|putBackURLs
specifier|private
name|void
name|putBackURLs
parameter_list|()
block|{
name|int
name|qSize
init|=
name|hostInfo
operator|.
name|getQueueSize
argument_list|()
decl_stmt|;
while|while
condition|(
name|hostInfo
operator|.
name|getQueueSize
argument_list|()
operator|>
literal|0
condition|)
block|{
name|messageHandler
operator|.
name|putMessage
argument_list|(
operator|(
name|Message
operator|)
name|hostInfo
operator|.
name|removeFromQueue
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|log
operator|.
name|logThreadSafe
argument_list|(
literal|"task "
operator|+
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|": finished. put "
operator|+
name|qSize
operator|+
literal|" URLs back"
argument_list|)
expr_stmt|;
name|hostInfo
operator|.
name|removeQueue
argument_list|()
expr_stmt|;
block|}
comment|/**          * this parses the robots.txt file. It was taken from the PERL implementation          * Since this is only rarely called, it's not optimized for speed          *          * @param r                the robots.txt file          * @return                 the disallows          * @exception IOException  any IOException          */
DECL|method|parse
specifier|public
name|String
index|[]
name|parse
parameter_list|(
name|BufferedReader
name|r
parameter_list|)
throws|throws
name|IOException
block|{
comment|// taken from Perl
name|Perl5Util
name|p
init|=
operator|new
name|Perl5Util
argument_list|()
decl_stmt|;
name|String
name|line
decl_stmt|;
name|boolean
name|isMe
init|=
literal|false
decl_stmt|;
name|boolean
name|isAnon
init|=
literal|false
decl_stmt|;
name|ArrayList
name|disallowed
init|=
operator|new
name|ArrayList
argument_list|()
decl_stmt|;
name|String
name|ua
init|=
literal|null
decl_stmt|;
while|while
condition|(
operator|(
name|line
operator|=
name|r
operator|.
name|readLine
argument_list|()
operator|)
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|p
operator|.
name|match
argument_list|(
literal|"/^#.*/"
argument_list|,
name|line
argument_list|)
condition|)
block|{
comment|// a comment
continue|continue;
block|}
name|line
operator|=
name|p
operator|.
name|substitute
argument_list|(
literal|"s/\\s*\\#.* //"
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|.
name|match
argument_list|(
literal|"/^\\s*$/"
argument_list|,
name|line
argument_list|)
condition|)
block|{
if|if
condition|(
name|isMe
condition|)
block|{
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|p
operator|.
name|match
argument_list|(
literal|"/^User-Agent:\\s*(.*)/i"
argument_list|,
name|line
argument_list|)
condition|)
block|{
name|ua
operator|=
name|p
operator|.
name|group
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|ua
operator|=
name|p
operator|.
name|substitute
argument_list|(
literal|"s/\\s+$//"
argument_list|,
name|ua
argument_list|)
expr_stmt|;
if|if
condition|(
name|isMe
condition|)
block|{
break|break;
block|}
elseif|else
if|if
condition|(
name|ua
operator|.
name|equals
argument_list|(
literal|"*"
argument_list|)
condition|)
block|{
name|isAnon
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Constants
operator|.
name|CRAWLER_AGENT
operator|.
name|startsWith
argument_list|(
name|ua
argument_list|)
condition|)
block|{
name|isMe
operator|=
literal|true
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|p
operator|.
name|match
argument_list|(
literal|"/^Disallow:\\s*(.*)/i"
argument_list|,
name|line
argument_list|)
condition|)
block|{
if|if
condition|(
name|ua
operator|==
literal|null
condition|)
block|{
name|isAnon
operator|=
literal|true
expr_stmt|;
comment|// warn...
block|}
name|String
name|disallow
init|=
name|p
operator|.
name|group
argument_list|(
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|disallow
operator|!=
literal|null
operator|&&
name|disallow
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
comment|// assume we have a relative path
empty_stmt|;
block|}
else|else
block|{
name|disallow
operator|=
literal|"/"
expr_stmt|;
block|}
if|if
condition|(
name|isMe
operator|||
name|isAnon
condition|)
block|{
name|disallowed
operator|.
name|add
argument_list|(
name|disallow
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// warn: unexpected line
block|}
block|}
name|String
index|[]
name|disalloweds
init|=
operator|new
name|String
index|[
name|disallowed
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
name|disallowed
operator|.
name|toArray
argument_list|(
name|disalloweds
argument_list|)
expr_stmt|;
return|return
name|disalloweds
return|;
block|}
block|}
block|}
end_class
end_unit
