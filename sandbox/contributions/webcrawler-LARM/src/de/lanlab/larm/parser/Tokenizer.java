begin_unit
begin_comment
comment|/*  *  $Id$  *  *  Copyright 2000 LANLab  *  */
end_comment
begin_package
DECL|package|de.lanlab.larm.parser
package|package
name|de
operator|.
name|lanlab
operator|.
name|larm
operator|.
name|parser
package|;
end_package
begin_import
import|import
name|hplb
operator|.
name|org
operator|.
name|xml
operator|.
name|sax
operator|.
name|*
import|;
end_import
begin_import
import|import
name|hplb
operator|.
name|xml
operator|.
name|*
import|;
end_import
begin_import
import|import
name|hplb
operator|.
name|xml
operator|.
name|util
operator|.
name|*
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Dictionary
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Hashtable
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|*
import|;
end_import
begin_import
import|import
name|hplb
operator|.
name|misc
operator|.
name|ByteArray
import|;
end_import
begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URL
import|;
end_import
begin_comment
comment|/**  * This parser is based on HEX, the HTML enabled XML parser, written by  * Anders Kristensen, HP Labs Bristol.  * It was stripped down and specialized to handle links in HTML pages. I removed  * some bugs. And it's FAST, about 10 x faster than the original HEX parser.  * Being some sort of SAX parser it calls the callback functions of the LinkHandler  * when links are found.  * @todo add handling of anchor texts  *  * @author    Clemens Marschner  */
end_comment
begin_class
DECL|class|Tokenizer
specifier|public
class|class
name|Tokenizer
implements|implements
name|hplb
operator|.
name|org
operator|.
name|xml
operator|.
name|sax
operator|.
name|Parser
block|{
comment|/**      * Sets the entityHandler attribute of the Tokenizer object      *      * @param e  The new entityHandler value      */
DECL|method|setEntityHandler
specifier|public
name|void
name|setEntityHandler
parameter_list|(
name|hplb
operator|.
name|org
operator|.
name|xml
operator|.
name|sax
operator|.
name|EntityHandler
name|e
parameter_list|)
block|{ }
comment|/**      * Sets the errorHandler attribute of the Tokenizer object      *      * @param e  The new errorHandler value      */
DECL|method|setErrorHandler
specifier|public
name|void
name|setErrorHandler
parameter_list|(
name|hplb
operator|.
name|org
operator|.
name|xml
operator|.
name|sax
operator|.
name|ErrorHandler
name|e
parameter_list|)
block|{ }
comment|/**      * Sets the documentHandler attribute of the Tokenizer object      *      * @param e  The new documentHandler value      */
DECL|method|setDocumentHandler
specifier|public
name|void
name|setDocumentHandler
parameter_list|(
name|hplb
operator|.
name|org
operator|.
name|xml
operator|.
name|sax
operator|.
name|DocumentHandler
name|e
parameter_list|)
block|{ }
comment|/**      * The value of boolean attributes is this string.      */
DECL|field|BOOLATTR
specifier|public
specifier|final
specifier|static
name|String
name|BOOLATTR
init|=
name|Atom
operator|.
name|getAtom
argument_list|(
literal|"BOOLATTR"
argument_list|)
decl_stmt|;
comment|// FSM states:
DECL|field|ST_START
specifier|final
specifier|static
name|int
name|ST_START
init|=
literal|1
decl_stmt|;
DECL|field|ST_TAG_LT
specifier|final
specifier|static
name|int
name|ST_TAG_LT
init|=
literal|3
decl_stmt|;
DECL|field|ST_TAG_NAME
specifier|final
specifier|static
name|int
name|ST_TAG_NAME
init|=
literal|4
decl_stmt|;
DECL|field|ST_TAG_WS
specifier|final
specifier|static
name|int
name|ST_TAG_WS
init|=
literal|5
decl_stmt|;
DECL|field|ST_EMPTY_TAG_SLASH
specifier|final
specifier|static
name|int
name|ST_EMPTY_TAG_SLASH
init|=
literal|6
decl_stmt|;
DECL|field|ST_NAME
specifier|final
specifier|static
name|int
name|ST_NAME
init|=
literal|7
decl_stmt|;
DECL|field|ST_NAME_WS
specifier|final
specifier|static
name|int
name|ST_NAME_WS
init|=
literal|8
decl_stmt|;
DECL|field|ST_EQ
specifier|final
specifier|static
name|int
name|ST_EQ
init|=
literal|9
decl_stmt|;
DECL|field|ST_VALUE
specifier|final
specifier|static
name|int
name|ST_VALUE
init|=
literal|10
decl_stmt|;
DECL|field|ST_VALUE_QUOTED
specifier|final
specifier|static
name|int
name|ST_VALUE_QUOTED
init|=
literal|11
decl_stmt|;
DECL|field|ST_PCDATA
specifier|final
specifier|static
name|int
name|ST_PCDATA
init|=
literal|21
decl_stmt|;
DECL|field|ST_COMMENT
specifier|final
specifier|static
name|int
name|ST_COMMENT
init|=
literal|22
decl_stmt|;
DECL|field|linkHandler
name|LinkHandler
name|linkHandler
decl_stmt|;
DECL|field|sysID
name|String
name|sysID
init|=
literal|"what's this?"
decl_stmt|;
comment|/**      * Description of the Field      */
DECL|field|noCaseElms
specifier|protected
name|Hashtable
name|noCaseElms
decl_stmt|;
comment|/**      * Description of the Field      */
DECL|field|rcgnzWS
specifier|public
name|boolean
name|rcgnzWS
init|=
literal|true
decl_stmt|;
comment|// is white space chars recognized as PCDATA
comment|// even when preceeding tags?
comment|/**      * Description of the Field      */
DECL|field|rcgnzEntities
specifier|public
name|boolean
name|rcgnzEntities
init|=
literal|true
decl_stmt|;
comment|/**      * Description of the Field      */
DECL|field|rcgnzCDATA
specifier|public
name|boolean
name|rcgnzCDATA
init|=
literal|true
decl_stmt|;
comment|/**      * Description of the Field      */
DECL|field|rcgnzComments
specifier|public
name|boolean
name|rcgnzComments
init|=
literal|true
decl_stmt|;
comment|//
comment|/**      * Description of the Field      */
DECL|field|atomize
specifier|public
name|boolean
name|atomize
init|=
literal|false
decl_stmt|;
comment|// make element and attr names atoms
DECL|field|ATTR_HREF
specifier|private
specifier|final
specifier|static
name|int
name|ATTR_HREF
init|=
literal|1
decl_stmt|;
DECL|field|ATTR_SRC
specifier|private
specifier|final
specifier|static
name|int
name|ATTR_SRC
init|=
literal|2
decl_stmt|;
DECL|field|LINKTYPE_NONE
specifier|private
specifier|final
specifier|static
name|int
name|LINKTYPE_NONE
init|=
literal|0
decl_stmt|;
DECL|field|LINKTYPE_LINK
specifier|private
specifier|final
specifier|static
name|int
name|LINKTYPE_LINK
init|=
literal|1
decl_stmt|;
DECL|field|LINKTYPE_BASE
specifier|private
specifier|final
specifier|static
name|int
name|LINKTYPE_BASE
init|=
literal|2
decl_stmt|;
DECL|field|LINKTYPE_FRAME
specifier|private
specifier|final
specifier|static
name|int
name|LINKTYPE_FRAME
init|=
literal|3
decl_stmt|;
DECL|field|linkTagType
specifier|private
name|byte
name|linkTagType
decl_stmt|;
DECL|field|linkAttrFound
specifier|private
name|boolean
name|linkAttrFound
decl_stmt|;
DECL|field|linkAttrType
specifier|private
name|int
name|linkAttrType
decl_stmt|;
DECL|field|linkValue
specifier|private
name|String
name|linkValue
decl_stmt|;
DECL|field|keepPCData
specifier|private
name|boolean
name|keepPCData
decl_stmt|;
DECL|field|isInTitleTag
specifier|private
name|boolean
name|isInTitleTag
decl_stmt|;
DECL|field|isInAnchorTag
specifier|private
name|boolean
name|isInAnchorTag
decl_stmt|;
DECL|field|buf
name|CharBuffer
name|buf
init|=
operator|new
name|CharBuffer
argument_list|()
decl_stmt|;
DECL|field|isStartTag
name|boolean
name|isStartTag
init|=
literal|true
decl_stmt|;
comment|/**      * Signals whether a non-empty element has any children. If not we must      * generate an artificial empty-string child [characters(buf, 0, 0)].      */
DECL|field|noChildren
name|boolean
name|noChildren
decl_stmt|;
DECL|field|tagname
name|CharBuffer
name|tagname
init|=
operator|new
name|CharBuffer
argument_list|()
decl_stmt|;
DECL|field|attrName
name|CharBuffer
name|attrName
init|=
operator|new
name|CharBuffer
argument_list|()
decl_stmt|;
DECL|field|attrValue
name|CharBuffer
name|attrValue
init|=
operator|new
name|CharBuffer
argument_list|(
literal|1000
argument_list|)
decl_stmt|;
DECL|field|pcData
name|CharBuffer
name|pcData
init|=
operator|new
name|CharBuffer
argument_list|(
literal|8000
argument_list|)
decl_stmt|;
DECL|field|in
name|Reader
name|in
decl_stmt|;
comment|/**      * Description of the Field      */
DECL|field|entMngr
specifier|public
specifier|final
name|EntityManager
name|entMngr
init|=
operator|new
name|EntityManager
argument_list|(
name|this
argument_list|)
decl_stmt|;
comment|/**      * Description of the Field      */
DECL|field|state
specifier|protected
name|int
name|state
init|=
name|ST_START
decl_stmt|;
comment|/**      * Description of the Field      */
DECL|field|qchar
specifier|protected
name|int
name|qchar
decl_stmt|;
comment|//<'> or<"> when parsing quoted attr values
comment|/**      * Constructor for the Tokenizer object      */
DECL|method|Tokenizer
specifier|public
name|Tokenizer
parameter_list|()
block|{ }
comment|/**      * Sets the linkHandler attribute of the Tokenizer object      *      * @param handler  The new linkHandler value      */
DECL|method|setLinkHandler
specifier|public
name|void
name|setLinkHandler
parameter_list|(
name|LinkHandler
name|handler
parameter_list|)
block|{
name|linkHandler
operator|=
name|handler
expr_stmt|;
block|}
comment|/**      * Description of the Method      *      * @param publicID       Description of the Parameter      * @param sysID          Description of the Parameter      * @exception Exception  Description of the Exception      */
DECL|method|parse
specifier|public
name|void
name|parse
parameter_list|(
name|String
name|publicID
parameter_list|,
name|String
name|sysID
parameter_list|)
throws|throws
name|Exception
block|{
name|this
operator|.
name|sysID
operator|=
name|sysID
expr_stmt|;
name|parse
argument_list|(
operator|new
name|URL
argument_list|(
name|sysID
argument_list|)
operator|.
name|openStream
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**      * Description of the Method      *      * @param in             Description of the Parameter      * @exception Exception  Description of the Exception      */
DECL|method|parse
specifier|public
name|void
name|parse
parameter_list|(
name|InputStream
name|in
parameter_list|)
throws|throws
name|Exception
block|{
name|parse
argument_list|(
operator|new
name|BufferedReader
argument_list|(
operator|new
name|InputStreamReader
argument_list|(
name|in
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**      * Description of the Method      *      * @param in             Description of the Parameter      * @exception Exception  Description of the Exception      */
DECL|method|parse
specifier|public
name|void
name|parse
parameter_list|(
name|Reader
name|in
parameter_list|)
throws|throws
name|Exception
block|{
if|if
condition|(
name|linkHandler
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"parse called without LinkHandler being set"
argument_list|)
throw|;
block|}
name|this
operator|.
name|in
operator|=
name|in
expr_stmt|;
name|toStart
argument_list|()
expr_stmt|;
name|tokenize
argument_list|()
expr_stmt|;
block|}
comment|/**      * Description of the Method      *      * @param elementName  Description of the Parameter      */
DECL|method|ignoreCase
specifier|public
name|void
name|ignoreCase
parameter_list|(
name|String
name|elementName
parameter_list|)
block|{
if|if
condition|(
name|noCaseElms
operator|==
literal|null
condition|)
block|{
name|noCaseElms
operator|=
operator|new
name|Hashtable
argument_list|()
expr_stmt|;
block|}
name|noCaseElms
operator|.
name|put
argument_list|(
name|elementName
operator|.
name|toLowerCase
argument_list|()
argument_list|,
name|elementName
argument_list|)
expr_stmt|;
block|}
comment|/**      * Description of the Method      *      * @param b  Description of the Parameter      */
DECL|method|rcgnzWS
specifier|public
name|void
name|rcgnzWS
parameter_list|(
name|boolean
name|b
parameter_list|)
block|{
name|rcgnzWS
operator|=
name|b
expr_stmt|;
block|}
comment|// invoked after doing any Handler callback - resets state
comment|/**      * Description of the Method      */
DECL|method|toStart
specifier|protected
name|void
name|toStart
parameter_list|()
block|{
name|state
operator|=
name|ST_START
expr_stmt|;
name|buf
operator|.
name|reset
argument_list|()
expr_stmt|;
name|tagname
operator|.
name|reset
argument_list|()
expr_stmt|;
name|attrName
operator|.
name|reset
argument_list|()
expr_stmt|;
name|attrValue
operator|.
name|reset
argument_list|()
expr_stmt|;
name|pcData
operator|.
name|reset
argument_list|()
expr_stmt|;
comment|//attrs.clear();
name|isStartTag
operator|=
literal|true
expr_stmt|;
comment|// until proven wrong
name|linkTagType
operator|=
name|LINKTYPE_NONE
expr_stmt|;
name|linkAttrFound
operator|=
literal|false
expr_stmt|;
name|linkAttrType
operator|=
literal|0
expr_stmt|;
name|linkValue
operator|=
literal|""
expr_stmt|;
comment|//keepPCData= false;
block|}
comment|/**      * Description of the Method      *      * @exception Exception  Description of the Exception      */
DECL|method|tokenize
specifier|public
name|void
name|tokenize
parameter_list|()
throws|throws
name|Exception
block|{
name|int
name|c
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|read
argument_list|()
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|ST_START
case|:
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'<'
case|:
name|state
operator|=
name|ST_TAG_LT
expr_stmt|;
name|linkTagType
operator|=
name|LINKTYPE_NONE
expr_stmt|;
name|linkAttrFound
operator|=
literal|false
expr_stmt|;
name|linkAttrType
operator|=
literal|0
expr_stmt|;
name|linkValue
operator|=
literal|""
expr_stmt|;
name|isStartTag
operator|=
literal|true
expr_stmt|;
name|keepPCData
operator|=
literal|false
expr_stmt|;
comment|// until proven wrong
name|tagname
operator|.
name|reset
argument_list|()
expr_stmt|;
break|break;
case|case
literal|' '
case|:
case|case
literal|'\t'
case|:
case|case
literal|'\r'
case|:
case|case
literal|'\n'
case|:
if|if
condition|(
operator|!
name|rcgnzWS
condition|)
block|{
break|break;
block|}
comment|// else fall through
default|default:
name|state
operator|=
name|ST_PCDATA
expr_stmt|;
if|if
condition|(
name|keepPCData
condition|)
block|{
name|pcData
operator|.
name|write
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|ST_PCDATA
case|:
if|if
condition|(
name|c
operator|==
literal|'<'
condition|)
block|{
if|if
condition|(
name|keepPCData
condition|)
block|{
name|gotPCDATA
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|keepPCData
operator|=
literal|false
expr_stmt|;
block|}
name|linkTagType
operator|=
name|LINKTYPE_NONE
expr_stmt|;
name|linkAttrFound
operator|=
literal|false
expr_stmt|;
name|linkAttrType
operator|=
literal|0
expr_stmt|;
name|linkValue
operator|=
literal|""
expr_stmt|;
name|state
operator|=
name|ST_TAG_LT
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|keepPCData
condition|)
block|{
name|pcData
operator|.
name|write
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|ST_TAG_LT
case|:
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'/'
case|:
name|isStartTag
operator|=
literal|false
expr_stmt|;
name|state
operator|=
name|ST_TAG_NAME
expr_stmt|;
break|break;
case|case
literal|'!'
case|:
name|c
operator|=
name|read
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|==
literal|'-'
operator|&&
operator|!
name|rcgnzComments
operator|)
operator|||
operator|(
name|c
operator|==
literal|'['
operator|&&
operator|!
name|rcgnzCDATA
operator|)
condition|)
block|{
name|state
operator|=
name|ST_PCDATA
expr_stmt|;
name|pcData
operator|.
name|reset
argument_list|()
expr_stmt|;
name|pcData
operator|.
name|write
argument_list|(
name|c
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|c
operator|==
literal|'-'
condition|)
block|{
name|state
operator|=
name|ST_COMMENT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'['
condition|)
block|{
name|parseCDATA
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|// FIXME: shouldn't be delivered as PCDATA
comment|//warning("Bad markup " + buf);
name|state
operator|=
name|ST_PCDATA
expr_stmt|;
name|pcData
operator|.
name|reset
argument_list|()
expr_stmt|;
name|pcData
operator|.
name|write
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'?'
case|:
name|parsePI
argument_list|()
expr_stmt|;
break|break;
case|case
literal|' '
case|:
case|case
literal|'\t'
case|:
case|case
literal|'\r'
case|:
case|case
literal|'\n'
case|:
name|state
operator|=
name|ST_TAG_WS
expr_stmt|;
break|break;
default|default:
name|tagname
operator|.
name|write
argument_list|(
name|Character
operator|.
name|toLowerCase
argument_list|(
operator|(
name|char
operator|)
name|c
argument_list|)
argument_list|)
expr_stmt|;
comment|// ## changed
name|state
operator|=
name|ST_TAG_NAME
expr_stmt|;
block|}
break|break;
case|case
name|ST_TAG_NAME
case|:
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|' '
case|:
case|case
literal|'\t'
case|:
case|case
literal|'\r'
case|:
case|case
literal|'\n'
case|:
name|state
operator|=
name|ST_TAG_WS
expr_stmt|;
name|gotTagName
argument_list|()
expr_stmt|;
comment|// ## changed
break|break;
case|case
literal|'/'
case|:
name|state
operator|=
name|ST_EMPTY_TAG_SLASH
expr_stmt|;
name|gotTagName
argument_list|()
expr_stmt|;
comment|// ## changed
break|break;
case|case
literal|'>'
case|:
name|gotTagName
argument_list|()
expr_stmt|;
comment|// ## changed
name|gotTag
argument_list|()
expr_stmt|;
break|break;
default|default:
name|tagname
operator|.
name|write
argument_list|(
name|Character
operator|.
name|toLowerCase
argument_list|(
operator|(
name|char
operator|)
name|c
argument_list|)
argument_list|)
expr_stmt|;
comment|// ## changed
block|}
break|break;
case|case
name|ST_TAG_WS
case|:
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|' '
case|:
case|case
literal|'\t'
case|:
case|case
literal|'\r'
case|:
case|case
literal|'\n'
case|:
break|break;
case|case
literal|'/'
case|:
name|state
operator|=
name|ST_EMPTY_TAG_SLASH
expr_stmt|;
break|break;
case|case
literal|'>'
case|:
name|gotTag
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
comment|// NOTE: if !inXMLDecl we fall through to default case
default|default:
if|if
condition|(
operator|!
name|isStartTag
condition|)
block|{
comment|// bit of a hack this...
comment|//errHandler.warning("Malformed tag: "+buf, sysID, _line, _column);
comment|//err_continue("Malformed tag: "+buf);
name|toStart
argument_list|()
expr_stmt|;
comment|// ## changed
if|if
condition|(
name|c
operator|==
literal|'<'
condition|)
block|{
name|gotPCDATA
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|keepPCData
operator|=
literal|false
expr_stmt|;
name|state
operator|=
name|ST_TAG_LT
expr_stmt|;
block|}
else|else
block|{
comment|// we get here e.g. if there's an end tag with attributes
name|state
operator|=
name|ST_PCDATA
expr_stmt|;
name|pcData
operator|.
name|reset
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// FIXME: this accepts way too many first chars for attr name
name|attrName
operator|.
name|write
argument_list|(
name|Character
operator|.
name|toLowerCase
argument_list|(
operator|(
name|char
operator|)
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|state
operator|=
name|ST_NAME
expr_stmt|;
block|}
block|}
break|break;
case|case
name|ST_EMPTY_TAG_SLASH
case|:
if|if
condition|(
name|c
operator|==
literal|'>'
condition|)
block|{
comment|//tagtype = TAG_EMPTY;
name|gotTag
argument_list|()
expr_stmt|;
break|break;
block|}
else|else
block|{
comment|// ERROR !? - can't throw Exception here - we go to next tag...
name|state
operator|=
name|ST_PCDATA
expr_stmt|;
name|pcData
operator|.
name|reset
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|ST_NAME
case|:
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|' '
case|:
case|case
literal|'\t'
case|:
case|case
literal|'\r'
case|:
case|case
literal|'\n'
case|:
if|if
condition|(
name|attrName
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|state
operator|=
name|ST_NAME_WS
expr_stmt|;
block|}
break|break;
case|case
literal|'>'
case|:
if|if
condition|(
name|attrName
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|gotAttr
argument_list|()
expr_stmt|;
block|}
name|gotTag
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'='
case|:
name|state
operator|=
name|ST_EQ
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|isCtlOrTspecial
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|state
operator|=
name|ST_PCDATA
expr_stmt|;
name|pcData
operator|.
name|reset
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|attrName
operator|.
name|write
argument_list|(
name|Character
operator|.
name|toLowerCase
argument_list|(
operator|(
name|char
operator|)
name|c
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|ST_NAME_WS
case|:
comment|// white-space between name and '='
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|' '
case|:
case|case
literal|'\t'
case|:
case|case
literal|'\r'
case|:
case|case
literal|'\n'
case|:
break|break;
case|case
literal|'='
case|:
name|state
operator|=
name|ST_EQ
expr_stmt|;
break|break;
case|case
literal|'>'
case|:
name|gotAttr
argument_list|()
expr_stmt|;
name|gotTag
argument_list|()
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|isNameChar
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|gotAttr
argument_list|()
expr_stmt|;
name|attrName
operator|.
name|write
argument_list|(
name|Character
operator|.
name|toLowerCase
argument_list|(
operator|(
name|char
operator|)
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|state
operator|=
name|ST_TAG_WS
expr_stmt|;
block|}
else|else
block|{
name|state
operator|=
name|ST_PCDATA
expr_stmt|;
name|pcData
operator|.
name|reset
argument_list|()
expr_stmt|;
block|}
block|}
break|break;
case|case
name|ST_EQ
case|:
comment|// white-space between '=' and value
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|' '
case|:
case|case
literal|'\t'
case|:
case|case
literal|'\r'
case|:
case|case
literal|'\n'
case|:
break|break;
case|case
literal|'"'
case|:
name|qchar
operator|=
literal|'"'
expr_stmt|;
name|state
operator|=
name|ST_VALUE_QUOTED
expr_stmt|;
break|break;
case|case
literal|'\''
case|:
name|qchar
operator|=
literal|'\''
expr_stmt|;
name|state
operator|=
name|ST_VALUE_QUOTED
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|isCtlOrTspecial
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|state
operator|=
name|ST_PCDATA
expr_stmt|;
name|pcData
operator|.
name|reset
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|attrValue
operator|.
name|write
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|state
operator|=
name|ST_VALUE
expr_stmt|;
block|}
block|}
break|break;
case|case
name|ST_VALUE
case|:
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|' '
case|:
case|case
literal|'\t'
case|:
case|case
literal|'\r'
case|:
case|case
literal|'\n'
case|:
name|gotAttr
argument_list|()
expr_stmt|;
name|state
operator|=
name|ST_TAG_WS
expr_stmt|;
break|break;
case|case
literal|'>'
case|:
name|gotAttr
argument_list|()
expr_stmt|;
name|gotTag
argument_list|()
expr_stmt|;
break|break;
comment|/*                          *  case '/':     // FIXME: HTML knows things like<a href=a/b.html> !!                          *  gotAttr();                          *  state = ST_EMPTY_TAG_SLASH;                          *  break;                          */
default|default:
if|if
condition|(
name|isValueBreaker
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|state
operator|=
name|ST_PCDATA
expr_stmt|;
name|pcData
operator|.
name|reset
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|attrValue
operator|.
name|write
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|ST_VALUE_QUOTED
case|:
if|if
condition|(
name|c
operator|==
name|qchar
condition|)
block|{
name|gotAttr
argument_list|()
expr_stmt|;
name|state
operator|=
name|ST_TAG_WS
expr_stmt|;
block|}
else|else
block|{
name|attrValue
operator|.
name|write
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ST_COMMENT
case|:
comment|// we've seen "...<!-" by now
try|try
block|{
if|if
condition|(
name|c
operator|!=
literal|'-'
condition|)
block|{
comment|//warning("Bad comment");
name|state
operator|=
name|ST_PCDATA
expr_stmt|;
name|pcData
operator|.
name|reset
argument_list|()
expr_stmt|;
break|break;
block|}
comment|// we're within comment - read till we see "--"
while|while
condition|(
literal|true
condition|)
block|{
while|while
condition|(
name|read_ex
argument_list|()
operator|!=
literal|'-'
condition|)
block|{
empty_stmt|;
block|}
if|if
condition|(
name|read_ex
argument_list|()
operator|==
literal|'-'
condition|)
block|{
break|break;
block|}
block|}
comment|// seen "--" - gotComment() reads past next '>'
name|gotComment
argument_list|()
expr_stmt|;
comment|//while (read_ex() != '>') ;
comment|//state = ST_PCDATA;
block|}
catch|catch
parameter_list|(
name|EmptyInputStream
name|ex
parameter_list|)
block|{
name|gotPCDATA
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|keepPCData
operator|=
literal|false
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|// input stream ended - return rest, if any, as PCDATA
if|if
condition|(
name|buf
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|gotPCDATA
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|keepPCData
operator|=
literal|false
expr_stmt|;
name|buf
operator|.
name|reset
argument_list|()
expr_stmt|;
block|}
block|}
comment|// counts lines and columns - used in error reporting
comment|// a line can be a single \r or \n or it can be \r\n - we handle them all
DECL|field|cc
name|int
name|cc
decl_stmt|;
comment|// last char read
comment|/**      * Description of the Method      *      * @return                 Description of the Return Value      * @exception IOException  Description of the Exception      */
DECL|method|read
specifier|public
specifier|final
name|int
name|read
parameter_list|()
throws|throws
name|IOException
block|{
name|int
name|c
init|=
name|in
operator|.
name|read
argument_list|()
decl_stmt|;
if|if
condition|(
name|c
operator|!=
operator|-
literal|1
condition|)
block|{
name|buf
operator|.
name|write
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
return|return
name|c
return|;
block|}
comment|/**      * Description of the Method      *      * @return                      Description of the Return Value      * @exception IOException       Description of the Exception      * @exception EmptyInputStream  Description of the Exception      */
DECL|method|read_ex
specifier|public
specifier|final
name|int
name|read_ex
parameter_list|()
throws|throws
name|IOException
throws|,
name|EmptyInputStream
block|{
name|int
name|c
init|=
name|read
argument_list|()
decl_stmt|;
if|if
condition|(
name|c
operator|==
operator|-
literal|1
condition|)
block|{
throw|throw
operator|new
name|EmptyInputStream
argument_list|()
throw|;
block|}
return|return
name|c
return|;
block|}
comment|// HTML allows<em>boolean</em> attributes - attributes without a
comment|// value, or rather an implicit value which is the same as the name.
comment|/**      * Description of the Method      *      * @exception Exception  Description of the Exception      */
DECL|method|gotAttr
specifier|protected
specifier|final
name|void
name|gotAttr
parameter_list|()
throws|throws
name|Exception
block|{
comment|// gotTag has to be called first, setting waitForAtt = ATT_HREF or ATT_SRC
if|if
condition|(
operator|!
name|linkAttrFound
condition|)
block|{
name|char
index|[]
name|attName
init|=
name|attrName
operator|.
name|getCharArray
argument_list|()
decl_stmt|;
name|int
name|attLength
init|=
name|attrName
operator|.
name|getLength
argument_list|()
decl_stmt|;
name|boolean
name|gotcha
init|=
literal|false
decl_stmt|;
switch|switch
condition|(
name|attLength
condition|)
block|{
case|case
literal|4
case|:
if|if
condition|(
name|attName
index|[
literal|0
index|]
operator|==
literal|'h'
operator|&&
name|attName
index|[
literal|1
index|]
operator|==
literal|'r'
operator|&&
name|attName
index|[
literal|2
index|]
operator|==
literal|'e'
operator|&&
name|attName
index|[
literal|3
index|]
operator|==
literal|'f'
condition|)
block|{
name|gotcha
operator|=
literal|true
expr_stmt|;
block|}
break|break;
case|case
literal|3
case|:
if|if
condition|(
name|attName
index|[
literal|0
index|]
operator|==
literal|'s'
operator|&&
name|attName
index|[
literal|1
index|]
operator|==
literal|'r'
operator|&&
name|attName
index|[
literal|2
index|]
operator|==
literal|'c'
condition|)
block|{
name|gotcha
operator|=
literal|true
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|gotcha
condition|)
block|{
name|linkValue
operator|=
operator|(
name|rcgnzEntities
condition|?
name|entMngr
operator|.
name|entityDecode
argument_list|(
name|attrValue
argument_list|)
else|:
name|attrValue
operator|)
operator|.
name|toString
argument_list|()
expr_stmt|;
name|linkAttrFound
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|linkValue
operator|=
literal|""
expr_stmt|;
block|}
block|}
name|attrName
operator|.
name|reset
argument_list|()
expr_stmt|;
name|attrValue
operator|.
name|reset
argument_list|()
expr_stmt|;
comment|//attrs.put(nm, val);
block|}
comment|/**      * Description of the Method      */
DECL|method|gotTagName
specifier|protected
name|void
name|gotTagName
parameter_list|()
block|{
name|char
index|[]
name|tag
init|=
name|tagname
operator|.
name|getCharArray
argument_list|()
decl_stmt|;
name|int
name|tagLength
init|=
name|tagname
operator|.
name|getLength
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|tagLength
condition|)
block|{
case|case
literal|1
case|:
comment|// A
if|if
condition|(
name|tag
index|[
literal|0
index|]
operator|==
literal|'a'
condition|)
block|{
name|linkTagType
operator|=
name|LINKTYPE_LINK
expr_stmt|;
name|linkAttrType
operator|=
name|ATTR_HREF
expr_stmt|;
block|}
break|break;
comment|// [case 3: // IMG]
case|case
literal|4
case|:
comment|// BASE, AREA [, LINK]
if|if
condition|(
name|isStartTag
condition|)
block|{
if|if
condition|(
name|tag
index|[
literal|0
index|]
operator|==
literal|'b'
operator|&&
name|tag
index|[
literal|1
index|]
operator|==
literal|'a'
operator|&&
name|tag
index|[
literal|2
index|]
operator|==
literal|'s'
operator|&&
name|tag
index|[
literal|3
index|]
operator|==
literal|'e'
condition|)
block|{
name|linkTagType
operator|=
name|LINKTYPE_BASE
expr_stmt|;
name|linkAttrType
operator|=
name|ATTR_HREF
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tag
index|[
literal|0
index|]
operator|==
literal|'a'
operator|&&
name|tag
index|[
literal|1
index|]
operator|==
literal|'r'
operator|&&
name|tag
index|[
literal|2
index|]
operator|==
literal|'e'
operator|&&
name|tag
index|[
literal|3
index|]
operator|==
literal|'a'
condition|)
block|{
name|linkTagType
operator|=
name|LINKTYPE_LINK
expr_stmt|;
name|linkAttrType
operator|=
name|ATTR_HREF
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|5
case|:
comment|// FRAME
if|if
condition|(
name|isStartTag
condition|)
block|{
if|if
condition|(
name|tag
index|[
literal|0
index|]
operator|==
literal|'f'
operator|&&
name|tag
index|[
literal|1
index|]
operator|==
literal|'r'
operator|&&
name|tag
index|[
literal|2
index|]
operator|==
literal|'a'
operator|&&
name|tag
index|[
literal|3
index|]
operator|==
literal|'m'
operator|&&
name|tag
index|[
literal|4
index|]
operator|==
literal|'e'
condition|)
block|{
name|linkTagType
operator|=
name|LINKTYPE_FRAME
expr_stmt|;
name|linkAttrType
operator|=
name|ATTR_SRC
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tag
index|[
literal|0
index|]
operator|==
literal|'t'
operator|&&
name|tag
index|[
literal|1
index|]
operator|==
literal|'i'
operator|&&
name|tag
index|[
literal|2
index|]
operator|==
literal|'t'
operator|&&
name|tag
index|[
literal|3
index|]
operator|==
literal|'l'
operator|&&
name|tag
index|[
literal|4
index|]
operator|==
literal|'e'
condition|)
block|{
name|isInTitleTag
operator|=
literal|true
expr_stmt|;
name|keepPCData
operator|=
literal|true
expr_stmt|;
block|}
block|}
default|default:
block|}
block|}
comment|/**      * Description of the Method      *      * @exception Exception  Description of the Exception      */
DECL|method|gotTag
specifier|protected
name|void
name|gotTag
parameter_list|()
throws|throws
name|Exception
block|{
if|if
condition|(
name|linkAttrFound
operator|&&
name|isStartTag
condition|)
block|{
switch|switch
condition|(
name|linkTagType
condition|)
block|{
case|case
name|LINKTYPE_LINK
case|:
comment|//System.out.println("got link " + linkValue);
name|linkHandler
operator|.
name|handleLink
argument_list|(
name|linkValue
argument_list|,
literal|false
argument_list|)
expr_stmt|;
break|break;
case|case
name|LINKTYPE_FRAME
case|:
comment|//System.out.println("got link " + linkValue);
name|linkHandler
operator|.
name|handleLink
argument_list|(
name|linkValue
argument_list|,
literal|true
argument_list|)
expr_stmt|;
break|break;
case|case
name|LINKTYPE_BASE
case|:
name|linkHandler
operator|.
name|handleBase
argument_list|(
name|linkValue
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|toStart
argument_list|()
expr_stmt|;
block|}
comment|/**      * Description of the Method      *      * @param attrs  Description of the Parameter      */
DECL|method|keysToLowerCase
specifier|public
specifier|final
name|void
name|keysToLowerCase
parameter_list|(
name|SAXAttributeMap
name|attrs
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|attrs
operator|.
name|n
condition|;
name|i
operator|++
control|)
block|{
name|attrs
operator|.
name|keys
index|[
name|i
index|]
operator|=
name|attrs
operator|.
name|keys
index|[
name|i
index|]
operator|.
name|toLowerCase
argument_list|()
expr_stmt|;
if|if
condition|(
name|atomize
condition|)
block|{
name|attrs
operator|.
name|keys
index|[
name|i
index|]
operator|=
name|Atom
operator|.
name|getAtom
argument_list|(
name|attrs
operator|.
name|keys
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// toomuch true iff we read a '<' of the next token
comment|/**      * Description of the Method      *      * @param toomuch        Description of the Parameter      * @exception Exception  Description of the Exception      */
DECL|method|gotPCDATA
specifier|protected
name|void
name|gotPCDATA
parameter_list|(
name|boolean
name|toomuch
parameter_list|)
throws|throws
name|Exception
block|{
if|if
condition|(
name|isInTitleTag
condition|)
block|{
name|linkHandler
operator|.
name|handleTitle
argument_list|(
name|pcData
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|isInTitleTag
operator|=
literal|false
expr_stmt|;
block|}
comment|// ignore it
name|toStart
argument_list|()
expr_stmt|;
block|}
comment|/*      *  noChildren = false;      *  if (toomuch) {      *  buf.setLength(buf.size() - 1);      *  }      *  CharBuffer buf1 = rcgnzEntities ? entMngr.entityDecode(buf) : buf;      *  docHandler.characters(buf1.getCharArray(), 0, buf1.size());      *  /handler.gotText(getBuffer());      *  toStart();      *  if (toomuch) {      *  buf.write('<');      *  column--;      *  }      *  }      */
comment|// XXX: should pass the comment on as docHandler.ignorable() ??
comment|/**      * Description of the Method      *      * @exception IOException       Description of the Exception      * @exception EmptyInputStream  Description of the Exception      */
DECL|method|gotComment
specifier|protected
name|void
name|gotComment
parameter_list|()
throws|throws
name|IOException
throws|,
name|EmptyInputStream
block|{
comment|//toStart();  // so an unexpected EOF causes rest to be returned as PCDATA
while|while
condition|(
name|read_ex
argument_list|()
operator|!=
literal|'>'
condition|)
block|{
empty_stmt|;
block|}
name|toStart
argument_list|()
expr_stmt|;
block|}
comment|// Processing Instruction
comment|/**      * Description of the Method      *      * @exception Exception  Description of the Exception      */
DECL|method|parsePI
specifier|protected
name|void
name|parsePI
parameter_list|()
throws|throws
name|Exception
block|{
comment|// ignore this
comment|/*          *  int i;          *  String target;          *  noChildren = false;          *  inXMLDecl = false;          *  i = buf.size();          *  try {          *  while (!isWS(read_ex())) ;          *  target = buf.toString();          *  target = target.substring(i, target.length() - 1);          *  if ("XML".equals(target)) {          *  inXMLDecl = true;          *  state = ST_TAG_WS;          *  return;          *  }          *  while (isWS(read_ex())) ;          *  i = buf.size() - 1;          *  while (true) {          *  while (read_ex() != '?') ;          *  if (read_ex() == '>') {          *  String s = buf.toString();          *  docHandler.processingInstruction(          *  Atom.getAtom(target), s.substring(i, s.length()-2));          *  /handler.gotPI(Atom.getAtom(target),          *  /              s.substring(i, s.length()-2));          *  break;          *  }          *  }          *  } catch (EmptyInputStream ex) {          *  gotPCDATA(false);          *  errHandler.warning("EOF while parsing PI", sysID, _line, _column);          *  /err_continue("EOF while parsing PI");          *  }          */
name|toStart
argument_list|()
expr_stmt|;
block|}
comment|// CDATA section
comment|// XXX: should contents be amalgamated with surrounding PCDATA?
comment|/**      * Description of the Method      *      * @exception Exception  Description of the Exception      */
DECL|method|parseCDATA
specifier|protected
name|void
name|parseCDATA
parameter_list|()
throws|throws
name|Exception
block|{
comment|// we've seen "<![" by now
try|try
block|{
if|if
condition|(
name|read_ex
argument_list|()
operator|==
literal|'C'
operator|&&
name|read_ex
argument_list|()
operator|==
literal|'D'
operator|&&
name|read_ex
argument_list|()
operator|==
literal|'A'
operator|&&
name|read_ex
argument_list|()
operator|==
literal|'T'
operator|&&
name|read_ex
argument_list|()
operator|==
literal|'A'
operator|&&
name|read_ex
argument_list|()
operator|==
literal|'['
condition|)
block|{
name|int
name|i1
init|=
name|buf
operator|.
name|size
argument_list|()
decl_stmt|;
while|while
condition|(
name|read_ex
argument_list|()
operator|!=
literal|']'
operator|||
name|read_ex
argument_list|()
operator|!=
literal|']'
operator|||
name|read_ex
argument_list|()
operator|!=
literal|'>'
condition|)
block|{
empty_stmt|;
block|}
comment|// docHandler.characters(buf.getCharArray(), i1, buf.size()-3-i1);
block|}
else|else
block|{
name|warning
argument_list|(
literal|"Bad CDATA markup"
argument_list|)
expr_stmt|;
name|state
operator|=
name|ST_PCDATA
expr_stmt|;
name|pcData
operator|.
name|reset
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|EmptyInputStream
name|ex
parameter_list|)
block|{
name|warning
argument_list|(
literal|"EOF while parsing CDATA section"
argument_list|)
expr_stmt|;
comment|//gotPCDATA(false);
block|}
name|toStart
argument_list|()
expr_stmt|;
block|}
comment|/**      * Gets the wS attribute of the Tokenizer object      *      * @param c  Description of the Parameter      * @return   The wS value      */
DECL|method|isWS
specifier|public
name|boolean
name|isWS
parameter_list|(
name|int
name|c
parameter_list|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|' '
case|:
case|case
literal|'\t'
case|:
case|case
literal|'\r'
case|:
case|case
literal|'\n'
case|:
return|return
literal|true
return|;
default|default:
return|return
literal|false
return|;
block|}
block|}
comment|/**      * Gets the valueBreaker attribute of the Tokenizer class      *      * @param c  Description of the Parameter      * @return   The valueBreaker value      */
DECL|method|isValueBreaker
specifier|public
specifier|final
specifier|static
name|boolean
name|isValueBreaker
parameter_list|(
name|int
name|c
parameter_list|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
comment|// control characters (0-31 and 127):
case|case
literal|0
case|:
case|case
literal|1
case|:
case|case
literal|2
case|:
case|case
literal|3
case|:
case|case
literal|4
case|:
case|case
literal|5
case|:
case|case
literal|6
case|:
case|case
literal|7
case|:
case|case
literal|8
case|:
case|case
literal|9
case|:
case|case
literal|10
case|:
case|case
literal|11
case|:
case|case
literal|12
case|:
case|case
literal|13
case|:
case|case
literal|14
case|:
case|case
literal|15
case|:
case|case
literal|16
case|:
case|case
literal|17
case|:
case|case
literal|18
case|:
case|case
literal|19
case|:
case|case
literal|20
case|:
case|case
literal|21
case|:
case|case
literal|22
case|:
case|case
literal|23
case|:
case|case
literal|24
case|:
case|case
literal|25
case|:
case|case
literal|26
case|:
case|case
literal|27
case|:
case|case
literal|28
case|:
case|case
literal|29
case|:
case|case
literal|30
case|:
case|case
literal|31
case|:
case|case
literal|127
case|:
comment|// tspecials:
case|case
literal|'>'
case|:
case|case
literal|' '
case|:
return|return
literal|true
return|;
default|default:
return|return
literal|false
return|;
block|}
block|}
comment|/**      * Returns true if c is either an ascii control character or a tspecial      * according to the HTTP specification.      *      * @param c  Description of the Parameter      * @return   The ctlOrTspecial value      */
comment|//   private static final boolean[] isCtlOrTSpecial = new boolean[]
comment|//     {
comment|//        /* 0 */     true , true , true , true , true , true , true , true , true , true , true , true , true , true ,
comment|//        /* 14 */    true , true , true , true , true , true , true , true , true , true , true , true , true , true ,
comment|//        /* 28 */    true , true , true , true , true , false, true , false, false, false, false, false, true , true ,
comment|//        /* 42 */    false, false, true , false, false, true , false, false, false, false, false, false, false, false,
comment|//        /* 56 */    false, false, /*FIX: / no control char: true*/ false, true , true , true , true , true , true , false, false, false, false, false,
comment|//        /* 70 */    false, false, false, false, false, false, false, false, false, false, false, false, false, false,
comment|//        /* 84 */    false, false, false, false, false, false, false, true , true , true , false, false, false, false,
comment|//        /* 98 */    false, false, false, false, false, false, false, false, false, false, false, false, false, false,
comment|//        /* 112 */   false, false, false, false, false, false, false, false, false, false, false, true , false, true ,
comment|//        /* 126 */   false, true , false, false, false, false, false, false, false, false, false, false, false, false,
comment|//        /* 140 */   false, false, false, false, false, false, false, false, false, false, false, false, false, false,
comment|//        /* 154 */   false, false, false, false, false, false, false, false, false, false, false, false, false, false,
comment|//        /* 168 */   false, false, false, false, false, false, false, false, false, false, false, false, false, false,
comment|//        /* 182 */   false, false, false, false, false, false, false, false, false, false, false, false, false, false,
comment|//        /* 196 */   false, false, false, false, false, false, false, false, false, false, false, false, false, false,
comment|//        /* 210 */   false, false, false, false, false, false, false, false, false, false, false, false, false, false,
comment|//        /* 224 */   false, false, false, false, false, false, false, false, false, false, false, false, false, false,
comment|//        /* 238 */   false, false, false, false, false, false, false, false, false, false, false, false, false, false,
comment|//        /* 252 */   false, false, false, false
comment|//    };
DECL|method|isCtlOrTspecial
specifier|public
specifier|final
specifier|static
name|boolean
name|isCtlOrTspecial
parameter_list|(
name|int
name|c
parameter_list|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
comment|// control characters (0-31 and 127):
case|case
literal|0
case|:
case|case
literal|1
case|:
case|case
literal|2
case|:
case|case
literal|3
case|:
case|case
literal|4
case|:
case|case
literal|5
case|:
case|case
literal|6
case|:
case|case
literal|7
case|:
case|case
literal|8
case|:
case|case
literal|9
case|:
case|case
literal|10
case|:
case|case
literal|11
case|:
case|case
literal|12
case|:
case|case
literal|13
case|:
case|case
literal|14
case|:
case|case
literal|15
case|:
case|case
literal|16
case|:
case|case
literal|17
case|:
case|case
literal|18
case|:
case|case
literal|19
case|:
case|case
literal|20
case|:
case|case
literal|21
case|:
case|case
literal|22
case|:
case|case
literal|23
case|:
case|case
literal|24
case|:
case|case
literal|25
case|:
case|case
literal|26
case|:
case|case
literal|27
case|:
case|case
literal|28
case|:
case|case
literal|29
case|:
case|case
literal|30
case|:
case|case
literal|31
case|:
case|case
literal|127
case|:
comment|// tspecials:
case|case
literal|'('
case|:
case|case
literal|')'
case|:
case|case
literal|'<'
case|:
case|case
literal|'>'
case|:
case|case
literal|'@'
case|:
case|case
literal|','
case|:
case|case
literal|';'
case|:
case|case
literal|':'
case|:
case|case
literal|'\\'
case|:
case|case
literal|'"'
case|:
comment|/*              *  case '/':              */
case|case
literal|'['
case|:
case|case
literal|']'
case|:
case|case
literal|'?'
case|:
case|case
literal|'='
case|:
case|case
literal|'{'
case|:
case|case
literal|'}'
case|:
case|case
literal|' '
case|:
comment|// case '\t':
return|return
literal|true
return|;
default|default:
return|return
literal|false
return|;
block|}
block|}
comment|/*      *  public static void main(String[])      *  {      *  System.out.println("private static final boolean[] isCtlOrTSpecial = \n{");  // bzw. isNameChar      *  for(int i=0; i<256; i++)      *  {      *  if(i>0)      *  System.out.print(", ");      *  if(i % 14 == 0)      *  {      *  System.out.print("\n/* " + i + " *" + "/   ");      *  }      *  if(Tokenizer.isCtlOrTspecial(i))  // bzw. isNameChar(i)      *  {      *  System.out.print("true ");      *  }      *  else      *  {      *  System.out.print("false");      *  }      *  }      *  System.out.print("};\n\n");      *  }      */
comment|//    public static final boolean isCtlOrTspecial(int c)
comment|//    {
comment|//        return (c< 256 ? isCtlOrTSpecial[c] : false);
comment|//    }
comment|//
comment|//    private static final boolean[] isNameChar =
comment|//    {
comment|//        /* 0 */     false, false, false, false, false, false, false, false, false, false, false, false, false, false,
comment|//        /* 14 */    false, false, false, false, false, false, false, false, false, false, false, false, false, false,
comment|//        /* 28 */    false, false, false, false, false, false, false, false, false, false, false, false, false, false,
comment|//        /* 42 */    false, false, false, true , true , false, true , true , true , true , true , true , true , true ,
comment|//        /* 56 */    true , true , false, false, false, false, false, false, false, true , true , true , true , true ,
comment|//        /* 70 */    true , true , true , true , true , true , true , true , true , true , true , true , true , true ,
comment|//        /* 84 */    true , true , true , true , true , true , true , false, false, false, false, true , false, true ,
comment|//        /* 98 */    true , true , true , true , true , true , true , true , true , true , true , true , true , true ,
comment|//        /* 112 */   true , true , true , true , true , true , true , true , true , true , true , false, false, false,
comment|//        /* 126 */   false, false, false, false, false, false, false, false, false, false, false, false, false, false,
comment|//        /* 140 */   false, false, false, false, false, false, false, false, false, false, false, false, false, false,
comment|//        /* 154 */   false, false, false, false, false, false, false, false, false, false, false, false, false, false,
comment|//        /* 168 */   false, false, false, false, false, false, false, false, false, false, false, false, false, false,
comment|//        /* 182 */   false, false, false, false, false, false, false, false, false, false, false, false, false, false,
comment|//        /* 196 */   false, false, false, false, false, false, false, false, false, false, false, false, false, false,
comment|//        /* 210 */   false, false, false, false, false, false, false, false, false, false, false, false, false, false,
comment|//        /* 224 */   false, false, false, false, false, false, false, false, false, false, false, false, false, false,
comment|//        /* 238 */   false, false, false, false, false, false, false, false, false, false, false, false, false, false,
comment|//        /* 252 */   false, false, false, false
comment|//    };
comment|//    public static final boolean isNameChar(int c)
comment|//    {
comment|//        return (c< 256 ? isNameChar[c] : false);
comment|//    }
comment|//
comment|/*      *  / I don't think this is a very standard definition of what can      *  / go into tag and attribute names.      */
comment|/**      * Gets the nameChar attribute of the Tokenizer class      *      * @param c  Description of the Parameter      * @return   The nameChar value      */
DECL|method|isNameChar
specifier|public
specifier|final
specifier|static
name|boolean
name|isNameChar
parameter_list|(
name|int
name|c
parameter_list|)
block|{
return|return
operator|(
literal|'a'
operator|<=
name|c
operator|&&
name|c
operator|<=
literal|'z'
operator|)
operator|||
operator|(
literal|'A'
operator|<=
name|c
operator|&&
name|c
operator|<=
literal|'Z'
operator|)
operator|||
operator|(
literal|'0'
operator|<=
name|c
operator|&&
name|c
operator|<=
literal|'9'
operator|)
operator|||
name|c
operator|==
literal|'.'
operator|||
name|c
operator|==
literal|'-'
operator|||
name|c
operator|==
literal|'_'
return|;
block|}
comment|/**      * Description of the Method      *      * @param s              Description of the Parameter      * @exception Exception  Description of the Exception      */
DECL|method|warning
specifier|protected
specifier|final
name|void
name|warning
parameter_list|(
name|String
name|s
parameter_list|)
throws|throws
name|Exception
block|{
comment|//errHandler.warning(s, sysID, _line, _column);
block|}
comment|/**      * Description of the Method      *      * @param s              Description of the Parameter      * @exception Exception  Description of the Exception      */
DECL|method|fatal
specifier|protected
specifier|final
name|void
name|fatal
parameter_list|(
name|String
name|s
parameter_list|)
throws|throws
name|Exception
block|{
comment|//errHandler.fatal(s, sysID, _line, _column);
block|}
comment|/**      * The main program for the Tokenizer class      *      * @param argv  The command line arguments      */
DECL|method|main
specifier|public
specifier|static
name|void
name|main
parameter_list|(
name|String
index|[]
name|argv
parameter_list|)
block|{
name|Tokenizer
name|tok
init|=
operator|new
name|Tokenizer
argument_list|()
decl_stmt|;
name|tok
operator|.
name|setLinkHandler
argument_list|(
operator|new
name|LinkHandler
argument_list|()
block|{
name|int
name|nr
init|=
literal|0
decl_stmt|;
specifier|public
name|void
name|handleLink
parameter_list|(
name|String
name|link
parameter_list|,
name|boolean
name|isFrame
parameter_list|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"found link "
operator|+
operator|(
operator|++
name|nr
operator|)
operator|+
literal|": "
operator|+
name|link
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|handleTitle
parameter_list|(
name|String
name|title
parameter_list|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"found title "
operator|+
operator|(
operator|++
name|nr
operator|)
operator|+
literal|": "
operator|+
name|title
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|handleBase
parameter_list|(
name|String
name|link
parameter_list|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"found base "
operator|+
operator|(
operator|++
name|nr
operator|)
operator|+
literal|": "
operator|+
name|link
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
try|try
block|{
name|tok
operator|.
name|parse
argument_list|(
operator|new
name|FileReader
argument_list|(
literal|"C:\\witest.htm"
argument_list|)
argument_list|)
expr_stmt|;
comment|/*              *  "<frame src=\\"link1\"></head>" +              *  "This is some Text\n" +              *  "<a name=_sometest href='link2'>and this is... the link</a>" +              *  "<table width=234><base href=\"'link3'\">"));              */
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Caught Exception: "
operator|+
name|e
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|e
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_class
begin_comment
comment|/**  * Description of the Class  *  * @author    Administrator  * @created   29. Dezember 2001  */
end_comment
begin_class
DECL|class|EmptyInputStream
class|class
name|EmptyInputStream
extends|extends
name|Exception
block|{
comment|/**      * Constructor for the EmptyInputStream object      */
DECL|method|EmptyInputStream
name|EmptyInputStream
parameter_list|()
block|{ }
block|}
end_class
end_unit
