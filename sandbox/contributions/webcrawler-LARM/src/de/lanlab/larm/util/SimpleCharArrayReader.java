begin_unit
begin_comment
comment|/* ====================================================================  * The Apache Software License, Version 1.1  *  * Copyright (c) 2001 The Apache Software Foundation.  All rights  * reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  *  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in  *    the documentation and/or other materials provided with the  *    distribution.  *  * 3. The end-user documentation included with the redistribution,  *    if any, must include the following acknowledgment:  *       "This product includes software developed by the  *        Apache Software Foundation (http://www.apache.org/)."  *    Alternately, this acknowledgment may appear in the software itself,  *    if and wherever such third-party acknowledgments normally appear.  *  * 4. The names "Apache" and "Apache Software Foundation" and  *    "Apache Lucene" must not be used to endorse or promote products  *    derived from this software without prior written permission. For  *    written permission, please contact apache@apache.org.  *  * 5. Products derived from this software may not be called "Apache",  *    "Apache Lucene", nor may "Apache" appear in their name, without  *    prior written permission of the Apache Software Foundation.  *  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED  * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE  * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR  * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF  * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  * ====================================================================  *  * This software consists of voluntary contributions made by many  * individuals on behalf of the Apache Software Foundation.  For more  * information on the Apache Software Foundation, please see  *<http://www.apache.org/>.  */
end_comment
begin_package
DECL|package|de.lanlab.larm.util
package|package
name|de
operator|.
name|lanlab
operator|.
name|larm
operator|.
name|util
package|;
end_package
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|*
import|;
end_import
begin_comment
comment|/**  * A<code>SimpleCharArrayReader</code> contains  * an internal buffer that contains bytes that  * may be read from the stream. An internal  * counter keeps track of the next byte to  * be supplied by the<code>read</code> method.  *<br>  * In contrast to the original<code>CharArrayReader</code> this  * version is not thread safe. The monitor on the read()-function caused programs  * to slow down much, because this function is called for every character. This  * class can thus only be used if only one thread is accessing the stream  * @author  Clemens Marschner  * @version 1.00  * @see     java.io.ByteArrayInputStream  */
end_comment
begin_class
specifier|public
class|class
DECL|class|SimpleCharArrayReader
name|SimpleCharArrayReader
extends|extends
name|Reader
block|{
comment|/**      * A flag that is set to true when this stream is closed.      */
DECL|field|isClosed
specifier|private
name|boolean
name|isClosed
init|=
literal|false
decl_stmt|;
comment|/**      * An array of bytes that was provided      * by the creator of the stream. Elements<code>buf[0]</code>      * through<code>buf[count-1]</code> are the      * only bytes that can ever be read from the      * stream;  element<code>buf[pos]</code> is      * the next byte to be read.      */
DECL|field|buf
specifier|protected
name|char
name|buf
index|[]
decl_stmt|;
comment|/**      * The index of the next character to read from the input stream buffer.      * This value should always be nonnegative      * and not larger than the value of<code>count</code>.      * The next byte to be read from the input stream buffer      * will be<code>buf[pos]</code>.      */
DECL|field|pos
specifier|protected
name|int
name|pos
decl_stmt|;
comment|/**      * The currently marked position in the stream.      * SimpleCharArrayReader objects are marked at position zero by      * default when constructed.  They may be marked at another      * position within the buffer by the<code>mark()</code> method.      * The current buffer position is set to this point by the      *<code>reset()</code> method.      *      * @since   JDK1.1      */
DECL|field|mark
specifier|protected
name|int
name|mark
init|=
literal|0
decl_stmt|;
comment|/**      * The index one greater than the last valid character in the input      * stream buffer.      * This value should always be nonnegative      * and not larger than the length of<code>buf</code>.      * It  is one greater than the position of      * the last byte within<code>buf</code> that      * can ever be read  from the input stream buffer.      */
DECL|field|count
specifier|protected
name|int
name|count
decl_stmt|;
comment|/**      * Creates a<code>SimpleCharArrayReader</code>      * so that it  uses<code>buf</code> as its      * buffer array.      * The buffer array is not copied.      * The initial value of<code>pos</code>      * is<code>0</code> and the initial value      * of<code>count</code> is the length of      *<code>buf</code>.      *      * @param   buf   the input buffer.      */
DECL|method|SimpleCharArrayReader
specifier|public
name|SimpleCharArrayReader
parameter_list|(
name|char
name|buf
index|[]
parameter_list|)
block|{
name|this
operator|.
name|buf
operator|=
name|buf
expr_stmt|;
name|this
operator|.
name|pos
operator|=
literal|0
expr_stmt|;
name|this
operator|.
name|count
operator|=
name|buf
operator|.
name|length
expr_stmt|;
block|}
comment|/**      * Creates<code>SimpleCharArrayReader</code>      * that uses<code>buf</code> as its      * buffer array. The initial value of<code>pos</code>      * is<code>offset</code> and the initial value      * of<code>count</code> is<code>offset+len</code>.      * The buffer array is not copied.      *<p>      * Note that if bytes are simply read from      * the resulting input stream, elements<code>buf[pos]</code>      * through<code>buf[pos+len-1]</code> will      * be read; however, if a<code>reset</code>      * operation  is performed, then bytes<code>buf[0]</code>      * through b<code>uf[pos-1]</code> will then      * become available for input.      *      * @param   buf      the input buffer.      * @param   offset   the offset in the buffer of the first byte to read.      * @param   length   the maximum number of bytes to read from the buffer.      */
DECL|method|SimpleCharArrayReader
specifier|public
name|SimpleCharArrayReader
parameter_list|(
name|char
name|buf
index|[]
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|)
block|{
name|this
operator|.
name|buf
operator|=
name|buf
expr_stmt|;
name|this
operator|.
name|pos
operator|=
name|offset
expr_stmt|;
name|this
operator|.
name|count
operator|=
name|Math
operator|.
name|min
argument_list|(
name|offset
operator|+
name|length
argument_list|,
name|buf
operator|.
name|length
argument_list|)
expr_stmt|;
name|this
operator|.
name|mark
operator|=
name|offset
expr_stmt|;
block|}
comment|/**      * Reads the next byte of data from this input stream. The value      * byte is returned as an<code>int</code> in the range      *<code>0</code> to<code>255</code>. If no byte is available      * because the end of the stream has been reached, the value      *<code>-1</code> is returned.      *<p>      *      * @return  the next byte of data, or<code>-1</code> if the end of the      *          stream has been reached.      */
DECL|method|read
specifier|public
name|int
name|read
parameter_list|()
block|{
return|return
operator|(
name|pos
operator|<
name|count
operator|)
condition|?
operator|(
name|buf
index|[
name|pos
operator|++
index|]
operator|&
literal|0xff
operator|)
else|:
operator|-
literal|1
return|;
block|}
comment|/**      * Reads up to<code>len</code> bytes of data into an array of bytes      * from this input stream.      * If<code>pos</code> equals<code>count</code>,      * then<code>-1</code> is returned to indicate      * end of file. Otherwise, the  number<code>k</code>      * of bytes read is equal to the smaller of      *<code>len</code> and<code>count-pos</code>.      * If<code>k</code> is positive, then bytes      *<code>buf[pos]</code> through<code>buf[pos+k-1]</code>      * are copied into<code>b[off]</code>  through      *<code>b[off+k-1]</code> in the manner performed      * by<code>System.arraycopy</code>. The      * value<code>k</code> is added into<code>pos</code>      * and<code>k</code> is returned.      *<p>      * This<code>read</code> method cannot block.      *      * @param   b     the buffer into which the data is read.      * @param   off   the start offset of the data.      * @param   len   the maximum number of bytes read.      * @return  the total number of bytes read into the buffer, or      *<code>-1</code> if there is no more data because the end of      *          the stream has been reached.      */
DECL|method|read
specifier|public
name|int
name|read
parameter_list|(
name|char
name|b
index|[]
parameter_list|,
name|int
name|off
parameter_list|,
name|int
name|len
parameter_list|)
block|{
if|if
condition|(
name|b
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
block|}
elseif|else
if|if
condition|(
operator|(
name|off
operator|<
literal|0
operator|)
operator|||
operator|(
name|off
operator|>
name|b
operator|.
name|length
operator|)
operator|||
operator|(
name|len
operator|<
literal|0
operator|)
operator|||
operator|(
operator|(
name|off
operator|+
name|len
operator|)
operator|>
name|b
operator|.
name|length
operator|)
operator|||
operator|(
operator|(
name|off
operator|+
name|len
operator|)
operator|<
literal|0
operator|)
condition|)
block|{
throw|throw
operator|new
name|IndexOutOfBoundsException
argument_list|()
throw|;
block|}
if|if
condition|(
name|pos
operator|>=
name|count
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|pos
operator|+
name|len
operator|>
name|count
condition|)
block|{
name|len
operator|=
name|count
operator|-
name|pos
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|<=
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
name|System
operator|.
name|arraycopy
argument_list|(
name|buf
argument_list|,
name|pos
argument_list|,
name|b
argument_list|,
name|off
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|pos
operator|+=
name|len
expr_stmt|;
return|return
name|len
return|;
block|}
comment|/**      * Skips<code>n</code> bytes of input from this input stream. Fewer      * bytes might be skipped if the end of the input stream is reached.      * The actual number<code>k</code>      * of bytes to be skipped is equal to the smaller      * of<code>n</code> and<code>count-pos</code>.      * The value<code>k</code> is added into<code>pos</code>      * and<code>k</code> is returned.      *      * @param   n   the number of bytes to be skipped.      * @return  the actual number of bytes skipped.      */
DECL|method|skip
specifier|public
name|long
name|skip
parameter_list|(
name|long
name|n
parameter_list|)
block|{
if|if
condition|(
name|pos
operator|+
name|n
operator|>
name|count
condition|)
block|{
name|n
operator|=
name|count
operator|-
name|pos
expr_stmt|;
block|}
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
name|pos
operator|+=
name|n
expr_stmt|;
return|return
name|n
return|;
block|}
comment|/**      * Returns the number of bytes that can be read from this input      * stream without blocking.      * The value returned is      *<code>count&nbsp;- pos</code>,      * which is the number of bytes remaining to be read from the input buffer.      *      * @return  the number of bytes that can be read from the input stream      *          without blocking.      */
DECL|method|available
specifier|public
name|int
name|available
parameter_list|()
block|{
return|return
name|count
operator|-
name|pos
return|;
block|}
comment|/**      * Tests if SimpleCharArrayReader supports mark/reset.      *      * @since   JDK1.1      */
DECL|method|markSupported
specifier|public
name|boolean
name|markSupported
parameter_list|()
block|{
return|return
literal|true
return|;
block|}
comment|/**      * Set the current marked position in the stream.      * SimpleCharArrayReader objects are marked at position zero by      * default when constructed.  They may be marked at another      * position within the buffer by this method.      *      * @since   JDK1.1      */
DECL|method|mark
specifier|public
name|void
name|mark
parameter_list|(
name|int
name|readAheadLimit
parameter_list|)
block|{
name|mark
operator|=
name|pos
expr_stmt|;
block|}
comment|/**      * Resets the buffer to the marked position.  The marked position      * is the beginning unless another position was marked.      * The value of<code>pos</code> is set to 0.      */
DECL|method|reset
specifier|public
name|void
name|reset
parameter_list|()
block|{
name|pos
operator|=
name|mark
expr_stmt|;
block|}
comment|/**      * Closes this input stream and releases any system resources      * associated with the stream.      *<p>      */
DECL|method|close
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
name|isClosed
operator|=
literal|true
expr_stmt|;
block|}
comment|/** Check to make sure that the stream has not been closed */
DECL|method|ensureOpen
specifier|private
name|void
name|ensureOpen
parameter_list|()
block|{
comment|/* This method does nothing for now.  Once we add throws clauses      * to the I/O methods in this class, it will throw an IOException      * if the stream has been closed.      */
block|}
block|}
end_class
end_unit
