begin_unit
begin_comment
comment|/*  *  @(#)HTTPConnection.java				0.3-3 06/05/2001  *  *  This file is part of the HTTPClient package  *  Copyright (C) 1996-2001 Ronald Tschalär  *  *  This library is free software; you can redistribute it and/or  *  modify it under the terms of the GNU Lesser General Public  *  License as published by the Free Software Foundation; either  *  version 2 of the License, or (at your option) any later version.  *  *  This library is distributed in the hope that it will be useful,  *  but WITHOUT ANY WARRANTY; without even the implied warranty of  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU  *  Lesser General Public License for more details.  *  *  You should have received a copy of the GNU Lesser General Public  *  License along with this library; if not, write to the Free  *  Software Foundation, Inc., 59 Temple Place, Suite 330, Boston,  *  MA 02111-1307, USA  *  *  For questions, suggestions, bug-reports, enhancement-requests etc.  *  I may be contacted at:  *  *  ronald@innovation.ch  *  *  The HTTPClient's home page is located at:  *  *  http://www.innovation.ch/java/HTTPClient/  *  */
end_comment
begin_package
DECL|package|HTTPClient
package|package
name|HTTPClient
package|;
end_package
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStream
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataOutputStream
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FilterOutputStream
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ByteArrayOutputStream
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InterruptedIOException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URL
import|;
end_import
begin_import
import|import
name|java
operator|.
name|net
operator|.
name|Socket
import|;
end_import
begin_import
import|import
name|java
operator|.
name|net
operator|.
name|InetAddress
import|;
end_import
begin_import
import|import
name|java
operator|.
name|net
operator|.
name|SocketException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|net
operator|.
name|ConnectException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|net
operator|.
name|UnknownHostException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|net
operator|.
name|NoRouteToHostException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Vector
import|;
end_import
begin_import
import|import
name|java
operator|.
name|applet
operator|.
name|Applet
import|;
end_import
begin_comment
comment|/**  * This class implements http protocol requests; it contains most of HTTP/1.1  * and ought to be unconditionally compliant. Redirections are automatically  * handled, and authorizations requests are recognized and dealt with via an  * authorization handler. Only full HTTP/1.0 and HTTP/1.1 requests are  * generated. HTTP/1.1, HTTP/1.0 and HTTP/0.9 responses are recognized.<P>  *  * Using the HTTPClient should be quite simple. First add the import statement '  *<code>import HTTPClient.*;</code>' to your file(s). Request can then be sent  * using one of the methods<var>Head()</var> ,<var>Get()</var> ,<var>Post()  *</var>, etc in<var>HTTPConnection</var> . These methods all return an  * instance of<var>HTTPResponse</var> which has methods for accessing the  * response headers (<var>getHeader()</var> ,<var>getHeaderAsInt()</var> ,  * etc), various response info (<var>getStatusCode()</var> ,<var>  * getReasonLine()</var> , etc) and the reponse data (<var>getData()</var> ,  *<var>getText()</var> , and<var>getInputStream()</var> ). Following are some  * examples.<P>  *  * If this is in an applet you can retrieve files from your server as follows:  *<PRE>  *     try  *     {  *         HTTPConnection con = new HTTPConnection(this);  *         HTTPResponse   rsp = con.Get("/my_file");  *         if (rsp.getStatusCode()>= 300)  *         {  *             System.err.println("Received Error: "+rsp.getReasonLine());  *             System.err.println(rsp.getText());  *         }  *         else  *             data = rsp.getData();  *  *         rsp = con.Get("/another_file");  *         if (rsp.getStatusCode()>= 300)  *         {  *             System.err.println("Received Error: "+rsp.getReasonLine());  *             System.err.println(rsp.getText());  *         }  *         else  *             other_data = rsp.getData();  *     }  *     catch (IOException ioe)  *     {  *         System.err.println(ioe.toString());  *     }  *     catch (ModuleException me)  *     {  *         System.err.println("Error handling request: " + me.getMessage());  *     }  *</PRE> This will get the files "/my_file" and "/another_file" and put their  * contents into byte[]'s accessible via<code>getData()</code>. Note that you  * need to only create a new<var>HTTPConnection</var> when sending a request to  * a new server (different host or port); although you may create a new<var>  * HTTPConnection</var> for every request to the same server this<strong>not  *</strong> recommended, as various information about the server is cached  * after the first request (to optimize subsequent requests) and persistent  * connections are used whenever possible.<P>  *  * To POST form data you would use something like this (assuming you have two  * fields called<var>name</var> and<var>e-mail</var> , whose contents are  * stored in the variables<var>name</var> and<var>email</var> ):<PRE>  *     try  *     {  *         NVPair form_data[] = new NVPair[2];  *         form_data[0] = new NVPair("name", name);  *         form_data[1] = new NVPair("e-mail", email);  *  *         HTTPConnection con = new HTTPConnection(this);  *         HTTPResponse   rsp = con.Post("/cgi-bin/my_script", form_data);  *         if (rsp.getStatusCode()>= 300)  *         {  *             System.err.println("Received Error: "+rsp.getReasonLine());  *             System.err.println(rsp.getText());  *         }  *         else  *             stream = rsp.getInputStream();  *     }  *     catch (IOException ioe)  *     {  *         System.err.println(ioe.toString());  *     }  *     catch (ModuleException me)  *     {  *         System.err.println("Error handling request: " + me.getMessage());  *     }  *</PRE> Here the response data is read at leasure via an<var>InputStream  *</var> instead of all at once into a<var>byte[]</var> .<P>  *  * As another example, if you have a URL you're trying to send a request to you  * would do something like the following:<PRE>  *     try  *     {  *         URL url = new URL("http://www.mydomain.us/test/my_file");  *         HTTPConnection con = new HTTPConnection(url);  *         HTTPResponse   rsp = con.Put(url.getFile(), "Hello World");  *         if (rsp.getStatusCode()>= 300)  *         {  *             System.err.println("Received Error: "+rsp.getReasonLine());  *             System.err.println(rsp.getText());  *         }  *         else  *             text = rsp.getText();  *     }  *     catch (IOException ioe)  *     {  *         System.err.println(ioe.toString());  *     }  *     catch (ModuleException me)  *     {  *         System.err.println("Error handling request: " + me.getMessage());  *     }  *</PRE><P>  *  * There are a whole number of methods for each request type; however the  * general forms are ([...] means that the enclosed is optional):  *<ul>  *<li> Head ( file [, form-data [, headers ] ] )  *<li> Head ( file [, query [, headers ] ] )  *<li> Get ( file [, form-data [, headers ] ] )  *<li> Get ( file [, query [, headers ] ] )  *<li> Post ( file [, form-data [, headers ] ] )  *<li> Post ( file [, data [, headers ] ] )  *<li> Post ( file [, stream [, headers ] ] )  *<li> Put ( file , data [, headers ] )  *<li> Put ( file , stream [, headers ] )  *<li> Delete ( file [, headers ] )  *<li> Options ( file [, headers [, data] ] )  *<li> Options ( file [, headers [, stream] ] )  *<li> Trace ( file [, headers ] )  *</ul>  *  *  * @author    Ronald Tschalär  * @created   29. Dezember 2001  * @version   0.3-3 06/05/2001  */
end_comment
begin_class
DECL|class|HTTPConnection
specifier|public
class|class
name|HTTPConnection
implements|implements
name|GlobalConstants
implements|,
name|HTTPClientModuleConstants
block|{
comment|/**      * The current version of this package.      */
DECL|field|version
specifier|public
specifier|final
specifier|static
name|String
name|version
init|=
literal|"RPT-HTTPClient/0.3-3"
decl_stmt|;
comment|/**      * The default context      */
DECL|field|dflt_context
specifier|private
specifier|final
specifier|static
name|Object
name|dflt_context
init|=
operator|new
name|Object
argument_list|()
decl_stmt|;
comment|/**      * The current context      */
DECL|field|Context
specifier|private
name|Object
name|Context
init|=
literal|null
decl_stmt|;
comment|/**      * The protocol used on this connection      */
DECL|field|Protocol
specifier|private
name|int
name|Protocol
decl_stmt|;
comment|/**      * The server's protocol version; M.m stored as (M<<16 | m)      */
DECL|field|ServerProtocolVersion
name|int
name|ServerProtocolVersion
decl_stmt|;
comment|/**      * Have we gotten the server's protocol version yet?      */
DECL|field|ServProtVersKnown
name|boolean
name|ServProtVersKnown
decl_stmt|;
comment|/**      * The protocol version we send in a request; this is always HTTP/1.1 unless      * we're talking to a broken server in which case it's HTTP/1.0      */
DECL|field|RequestProtocolVersion
specifier|private
name|String
name|RequestProtocolVersion
decl_stmt|;
comment|/**      * The remote host this connection is associated with      */
DECL|field|Host
specifier|private
name|String
name|Host
decl_stmt|;
comment|/**      * The remote port this connection is attached to      */
DECL|field|Port
specifier|private
name|int
name|Port
decl_stmt|;
comment|/**      * The local address this connection is associated with      */
DECL|field|LocalAddr
specifier|private
name|InetAddress
name|LocalAddr
decl_stmt|;
comment|/**      * The local port this connection is attached to      */
DECL|field|LocalPort
specifier|private
name|int
name|LocalPort
decl_stmt|;
comment|/**      * The current proxy host to use (if any)      */
DECL|field|Proxy_Host
specifier|private
name|String
name|Proxy_Host
init|=
literal|null
decl_stmt|;
comment|/**      * The current proxy port      */
DECL|field|Proxy_Port
specifier|private
name|int
name|Proxy_Port
decl_stmt|;
comment|/**      * The default proxy host to use (if any)      */
DECL|field|Default_Proxy_Host
specifier|private
specifier|static
name|String
name|Default_Proxy_Host
init|=
literal|null
decl_stmt|;
comment|/**      * The default proxy port      */
DECL|field|Default_Proxy_Port
specifier|private
specifier|static
name|int
name|Default_Proxy_Port
decl_stmt|;
comment|/**      * The list of hosts for which no proxy is to be used      */
DECL|field|non_proxy_host_list
specifier|private
specifier|static
name|CIHashtable
name|non_proxy_host_list
init|=
operator|new
name|CIHashtable
argument_list|()
decl_stmt|;
DECL|field|non_proxy_dom_list
specifier|private
specifier|static
name|Vector
name|non_proxy_dom_list
init|=
operator|new
name|Vector
argument_list|()
decl_stmt|;
DECL|field|non_proxy_addr_list
specifier|private
specifier|static
name|Vector
name|non_proxy_addr_list
init|=
operator|new
name|Vector
argument_list|()
decl_stmt|;
DECL|field|non_proxy_mask_list
specifier|private
specifier|static
name|Vector
name|non_proxy_mask_list
init|=
operator|new
name|Vector
argument_list|()
decl_stmt|;
comment|/**      * The socks server to use      */
DECL|field|Socks_client
specifier|private
name|SocksClient
name|Socks_client
init|=
literal|null
decl_stmt|;
comment|/**      * The default socks server to use      */
DECL|field|Default_Socks_client
specifier|private
specifier|static
name|SocksClient
name|Default_Socks_client
init|=
literal|null
decl_stmt|;
comment|/**      * the current stream demultiplexor      */
DECL|field|input_demux
specifier|private
name|StreamDemultiplexor
name|input_demux
init|=
literal|null
decl_stmt|;
comment|/**      * a list of active stream demultiplexors      */
DECL|field|DemuxList
name|LinkedList
name|DemuxList
init|=
operator|new
name|LinkedList
argument_list|()
decl_stmt|;
comment|/**      * a list of active requests      */
DECL|field|RequestList
specifier|private
name|LinkedList
name|RequestList
init|=
operator|new
name|LinkedList
argument_list|()
decl_stmt|;
comment|/**      * does the server support keep-alive's?      */
DECL|field|doesKeepAlive
specifier|private
name|boolean
name|doesKeepAlive
init|=
literal|false
decl_stmt|;
comment|/**      * have we been able to determine the above yet?      */
DECL|field|keepAliveUnknown
specifier|private
name|boolean
name|keepAliveUnknown
init|=
literal|true
decl_stmt|;
comment|/**      * the maximum number of requests over a HTTP/1.0 keep-alive connection      */
DECL|field|keepAliveReqMax
specifier|private
name|int
name|keepAliveReqMax
init|=
operator|-
literal|1
decl_stmt|;
comment|/**      * the number of requests over a HTTP/1.0 keep-alive connection left      */
DECL|field|keepAliveReqLeft
specifier|private
name|int
name|keepAliveReqLeft
decl_stmt|;
comment|/**      * hack to force buffering of data instead of using chunked T-E      */
DECL|field|no_chunked
specifier|private
specifier|static
name|boolean
name|no_chunked
init|=
literal|false
decl_stmt|;
comment|/**      * hack to force HTTP/1.0 requests      */
DECL|field|force_1_0
specifier|private
specifier|static
name|boolean
name|force_1_0
init|=
literal|false
decl_stmt|;
comment|/**      * hack to be able to disable pipelining      */
DECL|field|neverPipeline
specifier|private
specifier|static
name|boolean
name|neverPipeline
init|=
literal|false
decl_stmt|;
comment|/**      * hack to be able to disable keep-alives      */
DECL|field|noKeepAlives
specifier|private
specifier|static
name|boolean
name|noKeepAlives
init|=
literal|false
decl_stmt|;
comment|/**      * hack to work around M$ bug      */
DECL|field|haveMSLargeWritesBug
specifier|private
specifier|static
name|boolean
name|haveMSLargeWritesBug
init|=
literal|false
decl_stmt|;
comment|/**      * hack to only enable defered handling of streamed requests when configured      * to do so.      */
DECL|field|deferStreamed
specifier|static
name|boolean
name|deferStreamed
init|=
literal|false
decl_stmt|;
comment|/**      * the default timeout to use for new connections      */
DECL|field|DefaultTimeout
specifier|private
specifier|static
name|int
name|DefaultTimeout
init|=
literal|0
decl_stmt|;
comment|/**      * the timeout to use for reading responses      */
DECL|field|Timeout
specifier|private
name|int
name|Timeout
decl_stmt|;
comment|/**      * The list of default http headers      */
DECL|field|DefaultHeaders
specifier|private
name|NVPair
index|[]
name|DefaultHeaders
init|=
operator|new
name|NVPair
index|[
literal|0
index|]
decl_stmt|;
comment|/**      * The default list of modules (as a Vector of Class objects)      */
DECL|field|DefaultModuleList
specifier|private
specifier|static
name|Vector
name|DefaultModuleList
decl_stmt|;
comment|/**      * The list of modules (as a Vector of Class objects)      */
DECL|field|ModuleList
specifier|private
name|Vector
name|ModuleList
decl_stmt|;
comment|/**      * controls whether modules are allowed to interact with user      */
DECL|field|defaultAllowUI
specifier|private
specifier|static
name|boolean
name|defaultAllowUI
init|=
literal|true
decl_stmt|;
comment|/**      * controls whether modules are allowed to interact with user      */
DECL|field|allowUI
specifier|private
name|boolean
name|allowUI
decl_stmt|;
static|static
block|{
comment|/*          *  Let's try and see if we can figure out whether any proxies are          *  being used.          */
try|try
block|{
comment|// JDK 1.1 naming
name|String
name|host
init|=
name|System
operator|.
name|getProperty
argument_list|(
literal|"http.proxyHost"
argument_list|)
decl_stmt|;
if|if
condition|(
name|host
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|Exception
argument_list|()
throw|;
block|}
comment|// try JDK 1.0.x naming
name|int
name|port
init|=
name|Integer
operator|.
name|getInteger
argument_list|(
literal|"http.proxyPort"
argument_list|,
operator|-
literal|1
argument_list|)
operator|.
name|intValue
argument_list|()
decl_stmt|;
name|Log
operator|.
name|write
argument_list|(
name|Log
operator|.
name|CONN
argument_list|,
literal|"Conn:  using proxy "
operator|+
name|host
operator|+
literal|":"
operator|+
name|port
argument_list|)
expr_stmt|;
name|setProxyServer
argument_list|(
name|host
argument_list|,
name|port
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
try|try
block|{
comment|// JDK 1.0.x naming
if|if
condition|(
name|Boolean
operator|.
name|getBoolean
argument_list|(
literal|"proxySet"
argument_list|)
condition|)
block|{
name|String
name|host
init|=
name|System
operator|.
name|getProperty
argument_list|(
literal|"proxyHost"
argument_list|)
decl_stmt|;
name|int
name|port
init|=
name|Integer
operator|.
name|getInteger
argument_list|(
literal|"proxyPort"
argument_list|,
operator|-
literal|1
argument_list|)
operator|.
name|intValue
argument_list|()
decl_stmt|;
name|Log
operator|.
name|write
argument_list|(
name|Log
operator|.
name|CONN
argument_list|,
literal|"Conn:  using proxy "
operator|+
name|host
operator|+
literal|":"
operator|+
name|port
argument_list|)
expr_stmt|;
name|setProxyServer
argument_list|(
name|host
argument_list|,
name|port
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|ee
parameter_list|)
block|{
name|Default_Proxy_Host
operator|=
literal|null
expr_stmt|;
block|}
block|}
comment|/*          *  now check for the non-proxy list          */
try|try
block|{
name|String
name|hosts
init|=
name|System
operator|.
name|getProperty
argument_list|(
literal|"HTTPClient.nonProxyHosts"
argument_list|)
decl_stmt|;
if|if
condition|(
name|hosts
operator|==
literal|null
condition|)
block|{
name|hosts
operator|=
name|System
operator|.
name|getProperty
argument_list|(
literal|"http.nonProxyHosts"
argument_list|)
expr_stmt|;
block|}
name|String
index|[]
name|list
init|=
name|Util
operator|.
name|splitProperty
argument_list|(
name|hosts
argument_list|)
decl_stmt|;
name|dontProxyFor
argument_list|(
name|list
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{         }
comment|/*          *  we can't turn the JDK SOCKS handling off, so we don't use the          *  properties 'socksProxyHost' and 'socksProxyPort'. Instead we          *  define 'HTTPClient.socksHost', 'HTTPClient.socksPort' and          *  'HTTPClient.socksVersion'.          */
try|try
block|{
name|String
name|host
init|=
name|System
operator|.
name|getProperty
argument_list|(
literal|"HTTPClient.socksHost"
argument_list|)
decl_stmt|;
if|if
condition|(
name|host
operator|!=
literal|null
operator|&&
name|host
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
name|int
name|port
init|=
name|Integer
operator|.
name|getInteger
argument_list|(
literal|"HTTPClient.socksPort"
argument_list|,
operator|-
literal|1
argument_list|)
operator|.
name|intValue
argument_list|()
decl_stmt|;
name|int
name|version
init|=
name|Integer
operator|.
name|getInteger
argument_list|(
literal|"HTTPClient.socksVersion"
argument_list|,
operator|-
literal|1
argument_list|)
operator|.
name|intValue
argument_list|()
decl_stmt|;
name|Log
operator|.
name|write
argument_list|(
name|Log
operator|.
name|CONN
argument_list|,
literal|"Conn:  using SOCKS "
operator|+
name|host
operator|+
literal|":"
operator|+
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
name|version
operator|==
operator|-
literal|1
condition|)
block|{
name|setSocksServer
argument_list|(
name|host
argument_list|,
name|port
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|setSocksServer
argument_list|(
name|host
argument_list|,
name|port
argument_list|,
name|version
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|Default_Socks_client
operator|=
literal|null
expr_stmt|;
block|}
comment|// Set up module list
name|String
name|modules
init|=
literal|"HTTPClient.RetryModule|"
operator|+
literal|"HTTPClient.CookieModule|"
operator|+
literal|"HTTPClient.RedirectionModule|"
operator|+
literal|"HTTPClient.AuthorizationModule|"
operator|+
literal|"HTTPClient.DefaultModule|"
operator|+
literal|"HTTPClient.TransferEncodingModule|"
operator|+
literal|"HTTPClient.ContentMD5Module|"
operator|+
literal|"HTTPClient.ContentEncodingModule"
decl_stmt|;
name|boolean
name|in_applet
init|=
literal|false
decl_stmt|;
try|try
block|{
name|modules
operator|=
name|System
operator|.
name|getProperty
argument_list|(
literal|"HTTPClient.Modules"
argument_list|,
name|modules
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SecurityException
name|se
parameter_list|)
block|{
name|in_applet
operator|=
literal|true
expr_stmt|;
block|}
name|DefaultModuleList
operator|=
operator|new
name|Vector
argument_list|()
expr_stmt|;
name|String
index|[]
name|list
init|=
name|Util
operator|.
name|splitProperty
argument_list|(
name|modules
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|idx
init|=
literal|0
init|;
name|idx
operator|<
name|list
operator|.
name|length
condition|;
name|idx
operator|++
control|)
block|{
try|try
block|{
name|DefaultModuleList
operator|.
name|addElement
argument_list|(
name|Class
operator|.
name|forName
argument_list|(
name|list
index|[
name|idx
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|Log
operator|.
name|write
argument_list|(
name|Log
operator|.
name|CONN
argument_list|,
literal|"Conn:  added module "
operator|+
name|list
index|[
name|idx
index|]
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ClassNotFoundException
name|cnfe
parameter_list|)
block|{
if|if
condition|(
operator|!
name|in_applet
condition|)
block|{
throw|throw
operator|new
name|NoClassDefFoundError
argument_list|(
name|cnfe
operator|.
name|getMessage
argument_list|()
argument_list|)
throw|;
block|}
comment|/*                  *  Just ignore it. This allows for example applets to just                  *  load the necessary modules - if you don't need a module                  *  then don't provide it, and it won't be added to the                  *  list. The disadvantage is that if you accidently misstype                  *  a module name this will lead to a "silent" error.                  */
block|}
block|}
comment|/*          *  Hack: disable pipelining          */
try|try
block|{
name|neverPipeline
operator|=
name|Boolean
operator|.
name|getBoolean
argument_list|(
literal|"HTTPClient.disable_pipelining"
argument_list|)
expr_stmt|;
if|if
condition|(
name|neverPipeline
condition|)
block|{
name|Log
operator|.
name|write
argument_list|(
name|Log
operator|.
name|CONN
argument_list|,
literal|"Conn:  disabling pipelining"
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{         }
comment|/*          *  Hack: disable keep-alives          */
try|try
block|{
name|noKeepAlives
operator|=
name|Boolean
operator|.
name|getBoolean
argument_list|(
literal|"HTTPClient.disableKeepAlives"
argument_list|)
expr_stmt|;
if|if
condition|(
name|noKeepAlives
condition|)
block|{
name|Log
operator|.
name|write
argument_list|(
name|Log
operator|.
name|CONN
argument_list|,
literal|"Conn:  disabling keep-alives"
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{         }
comment|/*          *  Hack: force HTTP/1.0 requests          */
try|try
block|{
name|force_1_0
operator|=
name|Boolean
operator|.
name|getBoolean
argument_list|(
literal|"HTTPClient.forceHTTP_1.0"
argument_list|)
expr_stmt|;
if|if
condition|(
name|force_1_0
condition|)
block|{
name|Log
operator|.
name|write
argument_list|(
name|Log
operator|.
name|CONN
argument_list|,
literal|"Conn:  forcing HTTP/1.0 requests"
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{         }
comment|/*          *  Hack: prevent chunking of request data          */
try|try
block|{
name|no_chunked
operator|=
name|Boolean
operator|.
name|getBoolean
argument_list|(
literal|"HTTPClient.dontChunkRequests"
argument_list|)
expr_stmt|;
if|if
condition|(
name|no_chunked
condition|)
block|{
name|Log
operator|.
name|write
argument_list|(
name|Log
operator|.
name|CONN
argument_list|,
literal|"Conn:  never chunking requests"
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{         }
comment|/*          *  M$ bug: large writes hang the stuff          */
try|try
block|{
if|if
condition|(
name|System
operator|.
name|getProperty
argument_list|(
literal|"os.name"
argument_list|)
operator|.
name|indexOf
argument_list|(
literal|"Windows"
argument_list|)
operator|>=
literal|0
operator|&&
name|System
operator|.
name|getProperty
argument_list|(
literal|"java.version"
argument_list|)
operator|.
name|startsWith
argument_list|(
literal|"1.1"
argument_list|)
condition|)
block|{
name|haveMSLargeWritesBug
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|haveMSLargeWritesBug
condition|)
block|{
name|Log
operator|.
name|write
argument_list|(
name|Log
operator|.
name|CONN
argument_list|,
literal|"Conn:  splitting large writes into 20K chunks (M$ bug)"
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{         }
comment|/*          *  Deferring the handling of responses to requests which used an output          *  stream is new in V0.3-3. Because it can cause memory leaks for apps          *  which aren't expecting this, we only enable this feature if          *  explicitly requested to do so.          */
try|try
block|{
name|deferStreamed
operator|=
name|Boolean
operator|.
name|getBoolean
argument_list|(
literal|"HTTPClient.deferStreamed"
argument_list|)
expr_stmt|;
if|if
condition|(
name|deferStreamed
condition|)
block|{
name|Log
operator|.
name|write
argument_list|(
name|Log
operator|.
name|CONN
argument_list|,
literal|"Conn:  enabling defered handling of "
operator|+
literal|"responses to streamed requests"
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{         }
block|}
comment|// Constructors
comment|/**      * Constructs a connection to the host from where the applet was loaded.      * Note that current security policies only let applets connect home.      *      * @param applet                        the current applet      * @exception ProtocolNotSuppException  Description of the Exception      */
DECL|method|HTTPConnection
specifier|public
name|HTTPConnection
parameter_list|(
name|Applet
name|applet
parameter_list|)
throws|throws
name|ProtocolNotSuppException
block|{
name|this
argument_list|(
name|applet
operator|.
name|getCodeBase
argument_list|()
operator|.
name|getProtocol
argument_list|()
argument_list|,
name|applet
operator|.
name|getCodeBase
argument_list|()
operator|.
name|getHost
argument_list|()
argument_list|,
name|applet
operator|.
name|getCodeBase
argument_list|()
operator|.
name|getPort
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**      * Constructs a connection to the specified host on port 80      *      * @param host  the host      */
DECL|method|HTTPConnection
specifier|public
name|HTTPConnection
parameter_list|(
name|String
name|host
parameter_list|)
block|{
name|Setup
argument_list|(
name|HTTP
argument_list|,
name|host
argument_list|,
literal|80
argument_list|,
literal|null
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/**      * Constructs a connection to the specified host on the specified port      *      * @param host  the host      * @param port  the port      */
DECL|method|HTTPConnection
specifier|public
name|HTTPConnection
parameter_list|(
name|String
name|host
parameter_list|,
name|int
name|port
parameter_list|)
block|{
name|Setup
argument_list|(
name|HTTP
argument_list|,
name|host
argument_list|,
name|port
argument_list|,
literal|null
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/**      * Constructs a connection to the specified host on the specified port,      * using the specified protocol (currently only "http" is supported).      *      * @param prot                          the protocol      * @param host                          the host      * @param port                          the port, or -1 for the default port      * @exception ProtocolNotSuppException  if the protocol is not HTTP      */
DECL|method|HTTPConnection
specifier|public
name|HTTPConnection
parameter_list|(
name|String
name|prot
parameter_list|,
name|String
name|host
parameter_list|,
name|int
name|port
parameter_list|)
throws|throws
name|ProtocolNotSuppException
block|{
name|this
argument_list|(
name|prot
argument_list|,
name|host
argument_list|,
name|port
argument_list|,
literal|null
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/**      * Constructs a connection to the specified host on the specified port,      * using the specified protocol (currently only "http" is supported), local      * address, and local port.      *      * @param prot                          the protocol      * @param host                          the host      * @param port                          the port, or -1 for the default port      * @param localAddr                     the local address to bind to      * @param localPort                     Description of the Parameter      * @exception ProtocolNotSuppException  if the protocol is not HTTP      */
DECL|method|HTTPConnection
specifier|public
name|HTTPConnection
parameter_list|(
name|String
name|prot
parameter_list|,
name|String
name|host
parameter_list|,
name|int
name|port
parameter_list|,
name|InetAddress
name|localAddr
parameter_list|,
name|int
name|localPort
parameter_list|)
throws|throws
name|ProtocolNotSuppException
block|{
name|prot
operator|=
name|prot
operator|.
name|trim
argument_list|()
operator|.
name|toLowerCase
argument_list|()
expr_stmt|;
comment|//if (!prot.equals("http")&&  !prot.equals("https"))
if|if
condition|(
operator|!
name|prot
operator|.
name|equals
argument_list|(
literal|"http"
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|ProtocolNotSuppException
argument_list|(
literal|"Unsupported protocol '"
operator|+
name|prot
operator|+
literal|"'"
argument_list|)
throw|;
block|}
if|if
condition|(
name|prot
operator|.
name|equals
argument_list|(
literal|"http"
argument_list|)
condition|)
block|{
name|Setup
argument_list|(
name|HTTP
argument_list|,
name|host
argument_list|,
name|port
argument_list|,
name|localAddr
argument_list|,
name|localPort
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|prot
operator|.
name|equals
argument_list|(
literal|"https"
argument_list|)
condition|)
block|{
name|Setup
argument_list|(
name|HTTPS
argument_list|,
name|host
argument_list|,
name|port
argument_list|,
name|localAddr
argument_list|,
name|localPort
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|prot
operator|.
name|equals
argument_list|(
literal|"shttp"
argument_list|)
condition|)
block|{
name|Setup
argument_list|(
name|SHTTP
argument_list|,
name|host
argument_list|,
name|port
argument_list|,
name|localAddr
argument_list|,
name|localPort
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|prot
operator|.
name|equals
argument_list|(
literal|"http-ng"
argument_list|)
condition|)
block|{
name|Setup
argument_list|(
name|HTTP_NG
argument_list|,
name|host
argument_list|,
name|port
argument_list|,
name|localAddr
argument_list|,
name|localPort
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Constructs a connection to the host (port) as given in the url.      *      * @param url                           the url      * @exception ProtocolNotSuppException  if the protocol is not HTTP      */
DECL|method|HTTPConnection
specifier|public
name|HTTPConnection
parameter_list|(
name|URL
name|url
parameter_list|)
throws|throws
name|ProtocolNotSuppException
block|{
name|this
argument_list|(
name|url
operator|.
name|getProtocol
argument_list|()
argument_list|,
name|url
operator|.
name|getHost
argument_list|()
argument_list|,
name|url
operator|.
name|getPort
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**      * Constructs a connection to the host (port) as given in the uri.      *      * @param uri                           the uri      * @exception ProtocolNotSuppException  if the protocol is not HTTP      */
DECL|method|HTTPConnection
specifier|public
name|HTTPConnection
parameter_list|(
name|URI
name|uri
parameter_list|)
throws|throws
name|ProtocolNotSuppException
block|{
name|this
argument_list|(
name|uri
operator|.
name|getScheme
argument_list|()
argument_list|,
name|uri
operator|.
name|getHost
argument_list|()
argument_list|,
name|uri
operator|.
name|getPort
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**      * Sets the class variables. Must not be public.      *      * @param prot       the protocol      * @param host       the host      * @param port       the port      * @param localAddr  the local address to bind to; if null, it's ignored      * @param localPort  the local port to bind to      */
DECL|method|Setup
specifier|private
name|void
name|Setup
parameter_list|(
name|int
name|prot
parameter_list|,
name|String
name|host
parameter_list|,
name|int
name|port
parameter_list|,
name|InetAddress
name|localAddr
parameter_list|,
name|int
name|localPort
parameter_list|)
block|{
name|Protocol
operator|=
name|prot
expr_stmt|;
name|Host
operator|=
name|host
operator|.
name|trim
argument_list|()
operator|.
name|toLowerCase
argument_list|()
expr_stmt|;
name|Port
operator|=
name|port
expr_stmt|;
name|LocalAddr
operator|=
name|localAddr
expr_stmt|;
name|LocalPort
operator|=
name|localPort
expr_stmt|;
if|if
condition|(
name|Port
operator|==
operator|-
literal|1
condition|)
block|{
name|Port
operator|=
name|URI
operator|.
name|defaultPort
argument_list|(
name|getProtocol
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|Default_Proxy_Host
operator|!=
literal|null
operator|&&
operator|!
name|matchNonProxy
argument_list|(
name|Host
argument_list|)
condition|)
block|{
name|setCurrentProxy
argument_list|(
name|Default_Proxy_Host
argument_list|,
name|Default_Proxy_Port
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|setCurrentProxy
argument_list|(
literal|null
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|Socks_client
operator|=
name|Default_Socks_client
expr_stmt|;
name|Timeout
operator|=
name|DefaultTimeout
expr_stmt|;
name|ModuleList
operator|=
operator|(
name|Vector
operator|)
name|DefaultModuleList
operator|.
name|clone
argument_list|()
expr_stmt|;
name|allowUI
operator|=
name|defaultAllowUI
expr_stmt|;
if|if
condition|(
name|noKeepAlives
condition|)
block|{
name|setDefaultHeaders
argument_list|(
operator|new
name|NVPair
index|[]
block|{
operator|new
name|NVPair
argument_list|(
literal|"Connection"
argument_list|,
literal|"close"
argument_list|)
block|}
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Determines if the given host matches any entry in the non-proxy list.      *      * @param host  the host to match - must be trim()'d and lowercase      * @return      true if a match is found, false otherwise      * @see         #dontProxyFor(java.lang.String)      */
DECL|method|matchNonProxy
specifier|private
name|boolean
name|matchNonProxy
parameter_list|(
name|String
name|host
parameter_list|)
block|{
comment|// Check host name list
if|if
condition|(
name|non_proxy_host_list
operator|.
name|get
argument_list|(
name|host
argument_list|)
operator|!=
literal|null
condition|)
block|{
return|return
literal|true
return|;
block|}
comment|// Check domain name list
for|for
control|(
name|int
name|idx
init|=
literal|0
init|;
name|idx
operator|<
name|non_proxy_dom_list
operator|.
name|size
argument_list|()
condition|;
name|idx
operator|++
control|)
block|{
if|if
condition|(
name|host
operator|.
name|endsWith
argument_list|(
operator|(
name|String
operator|)
name|non_proxy_dom_list
operator|.
name|elementAt
argument_list|(
name|idx
argument_list|)
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
comment|// Check IP-address and subnet list
if|if
condition|(
name|non_proxy_addr_list
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
literal|false
return|;
block|}
name|InetAddress
index|[]
name|host_addr
decl_stmt|;
try|try
block|{
name|host_addr
operator|=
name|InetAddress
operator|.
name|getAllByName
argument_list|(
name|host
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnknownHostException
name|uhe
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
comment|// maybe the proxy has better luck
for|for
control|(
name|int
name|idx
init|=
literal|0
init|;
name|idx
operator|<
name|non_proxy_addr_list
operator|.
name|size
argument_list|()
condition|;
name|idx
operator|++
control|)
block|{
name|byte
index|[]
name|addr
init|=
operator|(
name|byte
index|[]
operator|)
name|non_proxy_addr_list
operator|.
name|elementAt
argument_list|(
name|idx
argument_list|)
decl_stmt|;
name|byte
index|[]
name|mask
init|=
operator|(
name|byte
index|[]
operator|)
name|non_proxy_mask_list
operator|.
name|elementAt
argument_list|(
name|idx
argument_list|)
decl_stmt|;
name|ip_loop
label|:
for|for
control|(
name|int
name|idx2
init|=
literal|0
init|;
name|idx2
operator|<
name|host_addr
operator|.
name|length
condition|;
name|idx2
operator|++
control|)
block|{
name|byte
index|[]
name|raw_addr
init|=
name|host_addr
index|[
name|idx2
index|]
operator|.
name|getAddress
argument_list|()
decl_stmt|;
if|if
condition|(
name|raw_addr
operator|.
name|length
operator|!=
name|addr
operator|.
name|length
condition|)
block|{
continue|continue;
block|}
for|for
control|(
name|int
name|idx3
init|=
literal|0
init|;
name|idx3
operator|<
name|raw_addr
operator|.
name|length
condition|;
name|idx3
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|raw_addr
index|[
name|idx3
index|]
operator|&
name|mask
index|[
name|idx3
index|]
operator|)
operator|!=
operator|(
name|addr
index|[
name|idx3
index|]
operator|&
name|mask
index|[
name|idx3
index|]
operator|)
condition|)
block|{
continue|continue
name|ip_loop
continue|;
block|}
block|}
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
comment|// Methods
comment|/**      * Sends the HEAD request. This request is just like the corresponding GET      * except that it only returns the headers and no data.      *      * @param file                 the absolute path of the file      * @return                     an HTTPResponse structure containing the      *      response      * @exception ModuleException  if an exception is encountered in any module.      * @exception IOException      Description of the Exception      * @see                        #Get(java.lang.String)      */
DECL|method|Head
specifier|public
name|HTTPResponse
name|Head
parameter_list|(
name|String
name|file
parameter_list|)
throws|throws
name|IOException
throws|,
name|ModuleException
block|{
return|return
name|Head
argument_list|(
name|file
argument_list|,
operator|(
name|String
operator|)
literal|null
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/**      * Sends the HEAD request. This request is just like the corresponding GET      * except that it only returns the headers and no data.      *      * @param file                 the absolute path of the file      * @param form_data            an array of Name/Value pairs      * @return                     an HTTPResponse structure containing the      *      response      * @exception ModuleException  if an exception is encountered in any module.      * @exception IOException      Description of the Exception      * @see                        #Get(java.lang.String, HTTPClient.NVPair[])      */
DECL|method|Head
specifier|public
name|HTTPResponse
name|Head
parameter_list|(
name|String
name|file
parameter_list|,
name|NVPair
name|form_data
index|[]
parameter_list|)
throws|throws
name|IOException
throws|,
name|ModuleException
block|{
return|return
name|Head
argument_list|(
name|file
argument_list|,
name|form_data
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/**      * Sends the HEAD request. This request is just like the corresponding GET      * except that it only returns the headers and no data.      *      * @param file                 the absolute path of the file      * @param form_data            an array of Name/Value pairs      * @param headers              additional headers      * @return                     an HTTPResponse structure containing the      *      response      * @exception ModuleException  if an exception is encountered in any module.      * @exception IOException      Description of the Exception      * @see                        #Get(java.lang.String, HTTPClient.NVPair[],      *      HTTPClient.NVPair[])      */
DECL|method|Head
specifier|public
name|HTTPResponse
name|Head
parameter_list|(
name|String
name|file
parameter_list|,
name|NVPair
index|[]
name|form_data
parameter_list|,
name|NVPair
index|[]
name|headers
parameter_list|)
throws|throws
name|IOException
throws|,
name|ModuleException
block|{
name|String
name|File
init|=
name|stripRef
argument_list|(
name|file
argument_list|)
decl_stmt|;
name|String
name|query
init|=
name|Codecs
operator|.
name|nv2query
argument_list|(
name|form_data
argument_list|)
decl_stmt|;
if|if
condition|(
name|query
operator|!=
literal|null
operator|&&
name|query
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
name|File
operator|+=
literal|"?"
operator|+
name|query
expr_stmt|;
block|}
return|return
name|setupRequest
argument_list|(
literal|"HEAD"
argument_list|,
name|File
argument_list|,
name|headers
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/**      * Sends the HEAD request. This request is just like the corresponding GET      * except that it only returns the headers and no data.      *      * @param file                 the absolute path of the file      * @param query                the query string; it will be urlencoded      * @return                     an HTTPResponse structure containing the      *      response      * @exception ModuleException  if an exception is encountered in any module.      * @exception IOException      Description of the Exception      * @see                        #Get(java.lang.String, java.lang.String)      */
DECL|method|Head
specifier|public
name|HTTPResponse
name|Head
parameter_list|(
name|String
name|file
parameter_list|,
name|String
name|query
parameter_list|)
throws|throws
name|IOException
throws|,
name|ModuleException
block|{
return|return
name|Head
argument_list|(
name|file
argument_list|,
name|query
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/**      * Sends the HEAD request. This request is just like the corresponding GET      * except that it only returns the headers and no data.      *      * @param file                 the absolute path of the file      * @param query                the query string; it will be urlencoded      * @param headers              additional headers      * @return                     an HTTPResponse structure containing the      *      response      * @exception ModuleException  if an exception is encountered in any module.      * @exception IOException      Description of the Exception      * @see                        #Get(java.lang.String, java.lang.String,      *      HTTPClient.NVPair[])      */
DECL|method|Head
specifier|public
name|HTTPResponse
name|Head
parameter_list|(
name|String
name|file
parameter_list|,
name|String
name|query
parameter_list|,
name|NVPair
index|[]
name|headers
parameter_list|)
throws|throws
name|IOException
throws|,
name|ModuleException
block|{
name|String
name|File
init|=
name|stripRef
argument_list|(
name|file
argument_list|)
decl_stmt|;
if|if
condition|(
name|query
operator|!=
literal|null
operator|&&
name|query
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
name|File
operator|+=
literal|"?"
operator|+
name|Codecs
operator|.
name|URLEncode
argument_list|(
name|query
argument_list|)
expr_stmt|;
block|}
return|return
name|setupRequest
argument_list|(
literal|"HEAD"
argument_list|,
name|File
argument_list|,
name|headers
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/**      * GETs the file.      *      * @param file                 the absolute path of the file      * @return                     an HTTPResponse structure containing the      *      response      * @exception ModuleException  if an exception is encountered in any module.      * @exception IOException      Description of the Exception      */
DECL|method|Get
specifier|public
name|HTTPResponse
name|Get
parameter_list|(
name|String
name|file
parameter_list|)
throws|throws
name|IOException
throws|,
name|ModuleException
block|{
return|return
name|Get
argument_list|(
name|file
argument_list|,
operator|(
name|String
operator|)
literal|null
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/**      * GETs the file with a query consisting of the specified form-data. The      * data is urlencoded, turned into a string of the form      * "name1=value1&name2=value2" and then sent as a query string.      *      * @param file                 the absolute path of the file      * @param form_data            an array of Name/Value pairs      * @return                     an HTTPResponse structure containing the      *      response      * @exception ModuleException  if an exception is encountered in any module.      * @exception IOException      Description of the Exception      */
DECL|method|Get
specifier|public
name|HTTPResponse
name|Get
parameter_list|(
name|String
name|file
parameter_list|,
name|NVPair
name|form_data
index|[]
parameter_list|)
throws|throws
name|IOException
throws|,
name|ModuleException
block|{
return|return
name|Get
argument_list|(
name|file
argument_list|,
name|form_data
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/**      * GETs the file with a query consisting of the specified form-data. The      * data is urlencoded, turned into a string of the form      * "name1=value1&name2=value2" and then sent as a query string.      *      * @param file                 the absolute path of the file      * @param form_data            an array of Name/Value pairs      * @param headers              additional headers      * @return                     an HTTPResponse structure containing the      *      response      * @exception ModuleException  if an exception is encountered in any module.      * @exception IOException      Description of the Exception      */
DECL|method|Get
specifier|public
name|HTTPResponse
name|Get
parameter_list|(
name|String
name|file
parameter_list|,
name|NVPair
index|[]
name|form_data
parameter_list|,
name|NVPair
index|[]
name|headers
parameter_list|)
throws|throws
name|IOException
throws|,
name|ModuleException
block|{
name|String
name|File
init|=
name|stripRef
argument_list|(
name|file
argument_list|)
decl_stmt|;
name|String
name|query
init|=
name|Codecs
operator|.
name|nv2query
argument_list|(
name|form_data
argument_list|)
decl_stmt|;
if|if
condition|(
name|query
operator|!=
literal|null
operator|&&
name|query
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
name|File
operator|+=
literal|"?"
operator|+
name|query
expr_stmt|;
block|}
return|return
name|setupRequest
argument_list|(
literal|"GET"
argument_list|,
name|File
argument_list|,
name|headers
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/**      * GETs the file using the specified query string. The query string is first      * urlencoded.      *      * @param file                 the absolute path of the file      * @param query                the query      * @return                     an HTTPResponse structure containing the      *      response      * @exception ModuleException  if an exception is encountered in any module.      * @exception IOException      Description of the Exception      */
DECL|method|Get
specifier|public
name|HTTPResponse
name|Get
parameter_list|(
name|String
name|file
parameter_list|,
name|String
name|query
parameter_list|)
throws|throws
name|IOException
throws|,
name|ModuleException
block|{
return|return
name|Get
argument_list|(
name|file
argument_list|,
name|query
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/**      * GETs the file using the specified query string. The query string is first      * urlencoded.      *      * @param file                 the absolute path of the file      * @param query                the query string      * @param headers              additional headers      * @return                     an HTTPResponse structure containing the      *      response      * @exception ModuleException  if an exception is encountered in any module.      * @exception IOException      Description of the Exception      */
DECL|method|Get
specifier|public
name|HTTPResponse
name|Get
parameter_list|(
name|String
name|file
parameter_list|,
name|String
name|query
parameter_list|,
name|NVPair
index|[]
name|headers
parameter_list|)
throws|throws
name|IOException
throws|,
name|ModuleException
block|{
name|String
name|File
init|=
name|stripRef
argument_list|(
name|file
argument_list|)
decl_stmt|;
if|if
condition|(
name|query
operator|!=
literal|null
operator|&&
name|query
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
name|File
operator|+=
literal|"?"
operator|+
name|Codecs
operator|.
name|URLEncode
argument_list|(
name|query
argument_list|)
expr_stmt|;
block|}
return|return
name|setupRequest
argument_list|(
literal|"GET"
argument_list|,
name|File
argument_list|,
name|headers
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/**      * POSTs to the specified file. No data is sent.      *      * @param file                 the absolute path of the file      * @return                     an HTTPResponse structure containing the      *      response      * @exception ModuleException  if an exception is encountered in any module.      * @exception IOException      Description of the Exception      */
DECL|method|Post
specifier|public
name|HTTPResponse
name|Post
parameter_list|(
name|String
name|file
parameter_list|)
throws|throws
name|IOException
throws|,
name|ModuleException
block|{
return|return
name|Post
argument_list|(
name|file
argument_list|,
operator|(
name|byte
index|[]
operator|)
literal|null
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/**      * POSTs form-data to the specified file. The data is first urlencoded and      * then turned into a string of the form "name1=value1&name2=value2". A      *<var>Content-type</var> header with the value<var>      * application/x-www-form-urlencoded</var> is added.      *      * @param file                 the absolute path of the file      * @param form_data            an array of Name/Value pairs      * @return                     an HTTPResponse structure containing the      *      response      * @exception ModuleException  if an exception is encountered in any module.      * @exception IOException      Description of the Exception      */
DECL|method|Post
specifier|public
name|HTTPResponse
name|Post
parameter_list|(
name|String
name|file
parameter_list|,
name|NVPair
name|form_data
index|[]
parameter_list|)
throws|throws
name|IOException
throws|,
name|ModuleException
block|{
name|NVPair
index|[]
name|headers
init|=
block|{
operator|new
name|NVPair
argument_list|(
literal|"Content-type"
argument_list|,
literal|"application/x-www-form-urlencoded"
argument_list|)
block|}
decl_stmt|;
return|return
name|Post
argument_list|(
name|file
argument_list|,
name|Codecs
operator|.
name|nv2query
argument_list|(
name|form_data
argument_list|)
argument_list|,
name|headers
argument_list|)
return|;
block|}
comment|/**      * POST's form-data to the specified file using the specified headers. The      * data is first urlencoded and then turned into a string of the form      * "name1=value1&name2=value2". If no<var>Content-type</var> header is      * given then one is added with a value of<var>      * application/x-www-form-urlencoded</var> .      *      * @param file                 the absolute path of the file      * @param form_data            an array of Name/Value pairs      * @param headers              additional headers      * @return                     a HTTPResponse structure containing the      *      response      * @exception ModuleException  if an exception is encountered in any module.      * @exception IOException      Description of the Exception      */
DECL|method|Post
specifier|public
name|HTTPResponse
name|Post
parameter_list|(
name|String
name|file
parameter_list|,
name|NVPair
name|form_data
index|[]
parameter_list|,
name|NVPair
name|headers
index|[]
parameter_list|)
throws|throws
name|IOException
throws|,
name|ModuleException
block|{
name|int
name|idx
decl_stmt|;
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|headers
operator|.
name|length
condition|;
name|idx
operator|++
control|)
block|{
if|if
condition|(
name|headers
index|[
name|idx
index|]
operator|.
name|getName
argument_list|()
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"Content-type"
argument_list|)
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
name|idx
operator|==
name|headers
operator|.
name|length
condition|)
block|{
name|headers
operator|=
name|Util
operator|.
name|resizeArray
argument_list|(
name|headers
argument_list|,
name|idx
operator|+
literal|1
argument_list|)
expr_stmt|;
name|headers
index|[
name|idx
index|]
operator|=
operator|new
name|NVPair
argument_list|(
literal|"Content-type"
argument_list|,
literal|"application/x-www-form-urlencoded"
argument_list|)
expr_stmt|;
block|}
return|return
name|Post
argument_list|(
name|file
argument_list|,
name|Codecs
operator|.
name|nv2query
argument_list|(
name|form_data
argument_list|)
argument_list|,
name|headers
argument_list|)
return|;
block|}
comment|/**      * POSTs the data to the specified file. The data is converted to an array      * of bytes using the default character converter. The request is sent using      * the content-type "application/octet-stream".      *      * @param file                 the absolute path of the file      * @param data                 the data      * @return                     an HTTPResponse structure containing the      *      response      * @exception ModuleException  if an exception is encountered in any module.      * @exception IOException      Description of the Exception      * @see                        java.lang.String#getBytes()      */
DECL|method|Post
specifier|public
name|HTTPResponse
name|Post
parameter_list|(
name|String
name|file
parameter_list|,
name|String
name|data
parameter_list|)
throws|throws
name|IOException
throws|,
name|ModuleException
block|{
return|return
name|Post
argument_list|(
name|file
argument_list|,
name|data
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/**      * POSTs the data to the specified file using the specified headers.      *      * @param file                 the absolute path of the file      * @param data                 the data      * @param headers              additional headers      * @return                     an HTTPResponse structure containing the      *      response      * @exception ModuleException  if an exception is encountered in any module.      * @exception IOException      Description of the Exception      * @see                        java.lang.String#getBytes()      */
DECL|method|Post
specifier|public
name|HTTPResponse
name|Post
parameter_list|(
name|String
name|file
parameter_list|,
name|String
name|data
parameter_list|,
name|NVPair
index|[]
name|headers
parameter_list|)
throws|throws
name|IOException
throws|,
name|ModuleException
block|{
name|byte
name|tmp
index|[]
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|data
operator|!=
literal|null
operator|&&
name|data
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
name|tmp
operator|=
name|data
operator|.
name|getBytes
argument_list|()
expr_stmt|;
block|}
return|return
name|Post
argument_list|(
name|file
argument_list|,
name|tmp
argument_list|,
name|headers
argument_list|)
return|;
block|}
comment|/**      * POSTs the raw data to the specified file. The request is sent using the      * content-type "application/octet-stream"      *      * @param file                 the absolute path of the file      * @param data                 the data      * @return                     an HTTPResponse structure containing the      *      response      * @exception ModuleException  if an exception is encountered in any module.      * @exception IOException      Description of the Exception      */
DECL|method|Post
specifier|public
name|HTTPResponse
name|Post
parameter_list|(
name|String
name|file
parameter_list|,
name|byte
name|data
index|[]
parameter_list|)
throws|throws
name|IOException
throws|,
name|ModuleException
block|{
return|return
name|Post
argument_list|(
name|file
argument_list|,
name|data
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/**      * POSTs the raw data to the specified file using the specified headers.      *      * @param file                 the absolute path of the file      * @param data                 the data      * @param headers              additional headers      * @return                     an HTTPResponse structure containing the      *      response      * @exception ModuleException  if an exception is encountered in any module.      * @exception IOException      Description of the Exception      */
DECL|method|Post
specifier|public
name|HTTPResponse
name|Post
parameter_list|(
name|String
name|file
parameter_list|,
name|byte
name|data
index|[]
parameter_list|,
name|NVPair
index|[]
name|headers
parameter_list|)
throws|throws
name|IOException
throws|,
name|ModuleException
block|{
if|if
condition|(
name|data
operator|==
literal|null
condition|)
block|{
name|data
operator|=
operator|new
name|byte
index|[
literal|0
index|]
expr_stmt|;
block|}
comment|// POST must always have a CL
return|return
name|setupRequest
argument_list|(
literal|"POST"
argument_list|,
name|stripRef
argument_list|(
name|file
argument_list|)
argument_list|,
name|headers
argument_list|,
name|data
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/**      * POSTs the data written to the output stream to the specified file. The      * request is sent using the content-type "application/octet-stream"      *      * @param file                 the absolute path of the file      * @param stream               the output stream on which the data is      *      written      * @return                     an HTTPResponse structure containing the      *      response      * @exception ModuleException  if an exception is encountered in any module.      * @exception IOException      Description of the Exception      */
DECL|method|Post
specifier|public
name|HTTPResponse
name|Post
parameter_list|(
name|String
name|file
parameter_list|,
name|HttpOutputStream
name|stream
parameter_list|)
throws|throws
name|IOException
throws|,
name|ModuleException
block|{
return|return
name|Post
argument_list|(
name|file
argument_list|,
name|stream
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/**      * POSTs the data written to the output stream to the specified file using      * the specified headers.      *      * @param file                 the absolute path of the file      * @param stream               the output stream on which the data is      *      written      * @param headers              additional headers      * @return                     an HTTPResponse structure containing the      *      response      * @exception ModuleException  if an exception is encountered in any module.      * @exception IOException      Description of the Exception      */
DECL|method|Post
specifier|public
name|HTTPResponse
name|Post
parameter_list|(
name|String
name|file
parameter_list|,
name|HttpOutputStream
name|stream
parameter_list|,
name|NVPair
index|[]
name|headers
parameter_list|)
throws|throws
name|IOException
throws|,
name|ModuleException
block|{
return|return
name|setupRequest
argument_list|(
literal|"POST"
argument_list|,
name|stripRef
argument_list|(
name|file
argument_list|)
argument_list|,
name|headers
argument_list|,
literal|null
argument_list|,
name|stream
argument_list|)
return|;
block|}
comment|/**      * PUTs the data into the specified file. The data is converted to an array      * of bytes using the default character converter. The request ist sent      * using the content-type "application/octet-stream".      *      * @param file                 the absolute path of the file      * @param data                 the data      * @return                     an HTTPResponse structure containing the      *      response      * @exception ModuleException  if an exception is encountered in any module.      * @exception IOException      Description of the Exception      * @see                        java.lang.String#getBytes()      */
DECL|method|Put
specifier|public
name|HTTPResponse
name|Put
parameter_list|(
name|String
name|file
parameter_list|,
name|String
name|data
parameter_list|)
throws|throws
name|IOException
throws|,
name|ModuleException
block|{
return|return
name|Put
argument_list|(
name|file
argument_list|,
name|data
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/**      * PUTs the data into the specified file using the additional headers for      * the request.      *      * @param file                 the absolute path of the file      * @param data                 the data      * @param headers              additional headers      * @return                     an HTTPResponse structure containing the      *      response      * @exception ModuleException  if an exception is encountered in any module.      * @exception IOException      Description of the Exception      * @see                        java.lang.String#getBytes()      */
DECL|method|Put
specifier|public
name|HTTPResponse
name|Put
parameter_list|(
name|String
name|file
parameter_list|,
name|String
name|data
parameter_list|,
name|NVPair
index|[]
name|headers
parameter_list|)
throws|throws
name|IOException
throws|,
name|ModuleException
block|{
name|byte
name|tmp
index|[]
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|data
operator|!=
literal|null
operator|&&
name|data
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
name|tmp
operator|=
name|data
operator|.
name|getBytes
argument_list|()
expr_stmt|;
block|}
return|return
name|Put
argument_list|(
name|file
argument_list|,
name|tmp
argument_list|,
name|headers
argument_list|)
return|;
block|}
comment|/**      * PUTs the raw data into the specified file. The request is sent using the      * content-type "application/octet-stream".      *      * @param file                 the absolute path of the file      * @param data                 the data      * @return                     an HTTPResponse structure containing the      *      response      * @exception ModuleException  if an exception is encountered in any module.      * @exception IOException      Description of the Exception      */
DECL|method|Put
specifier|public
name|HTTPResponse
name|Put
parameter_list|(
name|String
name|file
parameter_list|,
name|byte
name|data
index|[]
parameter_list|)
throws|throws
name|IOException
throws|,
name|ModuleException
block|{
return|return
name|Put
argument_list|(
name|file
argument_list|,
name|data
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/**      * PUTs the raw data into the specified file using the additional headers.      *      * @param file                 the absolute path of the file      * @param data                 the data      * @param headers              any additional headers      * @return                     an HTTPResponse structure containing the      *      response      * @exception ModuleException  if an exception is encountered in any module.      * @exception IOException      Description of the Exception      */
DECL|method|Put
specifier|public
name|HTTPResponse
name|Put
parameter_list|(
name|String
name|file
parameter_list|,
name|byte
name|data
index|[]
parameter_list|,
name|NVPair
index|[]
name|headers
parameter_list|)
throws|throws
name|IOException
throws|,
name|ModuleException
block|{
if|if
condition|(
name|data
operator|==
literal|null
condition|)
block|{
name|data
operator|=
operator|new
name|byte
index|[
literal|0
index|]
expr_stmt|;
block|}
comment|// PUT must always have a CL
return|return
name|setupRequest
argument_list|(
literal|"PUT"
argument_list|,
name|stripRef
argument_list|(
name|file
argument_list|)
argument_list|,
name|headers
argument_list|,
name|data
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/**      * PUTs the data written to the output stream into the specified file. The      * request is sent using the content-type "application/octet-stream".      *      * @param file                 the absolute path of the file      * @param stream               the output stream on which the data is      *      written      * @return                     an HTTPResponse structure containing the      *      response      * @exception ModuleException  if an exception is encountered in any module.      * @exception IOException      Description of the Exception      */
DECL|method|Put
specifier|public
name|HTTPResponse
name|Put
parameter_list|(
name|String
name|file
parameter_list|,
name|HttpOutputStream
name|stream
parameter_list|)
throws|throws
name|IOException
throws|,
name|ModuleException
block|{
return|return
name|Put
argument_list|(
name|file
argument_list|,
name|stream
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/**      * PUTs the data written to the output stream into the specified file using      * the additional headers.      *      * @param file                 the absolute path of the file      * @param stream               the output stream on which the data is      *      written      * @param headers              any additional headers      * @return                     an HTTPResponse structure containing the      *      response      * @exception ModuleException  if an exception is encountered in any module.      * @exception IOException      Description of the Exception      */
DECL|method|Put
specifier|public
name|HTTPResponse
name|Put
parameter_list|(
name|String
name|file
parameter_list|,
name|HttpOutputStream
name|stream
parameter_list|,
name|NVPair
index|[]
name|headers
parameter_list|)
throws|throws
name|IOException
throws|,
name|ModuleException
block|{
return|return
name|setupRequest
argument_list|(
literal|"PUT"
argument_list|,
name|stripRef
argument_list|(
name|file
argument_list|)
argument_list|,
name|headers
argument_list|,
literal|null
argument_list|,
name|stream
argument_list|)
return|;
block|}
comment|/**      * Request OPTIONS from the server. If<var>file</var> is "*" then the      * request applies to the server as a whole; otherwise it applies only to      * that resource.      *      * @param file                 the absolute path of the resource, or "*"      * @return                     an HTTPResponse structure containing the      *      response      * @exception ModuleException  if an exception is encountered in any module.      * @exception IOException      Description of the Exception      */
DECL|method|Options
specifier|public
name|HTTPResponse
name|Options
parameter_list|(
name|String
name|file
parameter_list|)
throws|throws
name|IOException
throws|,
name|ModuleException
block|{
return|return
name|Options
argument_list|(
name|file
argument_list|,
literal|null
argument_list|,
operator|(
name|byte
index|[]
operator|)
literal|null
argument_list|)
return|;
block|}
comment|/**      * Request OPTIONS from the server. If<var>file</var> is "*" then the      * request applies to the server as a whole; otherwise it applies only to      * that resource.      *      * @param file                 the absolute path of the resource, or "*"      * @param headers              the headers containing optional info.      * @return                     an HTTPResponse structure containing the      *      response      * @exception ModuleException  if an exception is encountered in any module.      * @exception IOException      Description of the Exception      */
DECL|method|Options
specifier|public
name|HTTPResponse
name|Options
parameter_list|(
name|String
name|file
parameter_list|,
name|NVPair
index|[]
name|headers
parameter_list|)
throws|throws
name|IOException
throws|,
name|ModuleException
block|{
return|return
name|Options
argument_list|(
name|file
argument_list|,
name|headers
argument_list|,
operator|(
name|byte
index|[]
operator|)
literal|null
argument_list|)
return|;
block|}
comment|/**      * Request OPTIONS from the server. If<var>file</var> is "*" then the      * request applies to the server as a whole; otherwise it applies only to      * that resource.      *      * @param file                 the absolute path of the resource, or "*"      * @param headers              the headers containing optional info.      * @param data                 any data to be sent in the optional body      * @return                     an HTTPResponse structure containing the      *      response      * @exception ModuleException  if an exception is encountered in any module.      * @exception IOException      Description of the Exception      */
DECL|method|Options
specifier|public
name|HTTPResponse
name|Options
parameter_list|(
name|String
name|file
parameter_list|,
name|NVPair
index|[]
name|headers
parameter_list|,
name|byte
index|[]
name|data
parameter_list|)
throws|throws
name|IOException
throws|,
name|ModuleException
block|{
return|return
name|setupRequest
argument_list|(
literal|"OPTIONS"
argument_list|,
name|stripRef
argument_list|(
name|file
argument_list|)
argument_list|,
name|headers
argument_list|,
name|data
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/**      * Request OPTIONS from the server. If<var>file</var> is "*" then the      * request applies to the server as a whole; otherwise it applies only to      * that resource.      *      * @param file                 the absolute path of the resource, or "*"      * @param headers              the headers containing optional info.      * @param stream               an output stream for sending the optional      *      body      * @return                     an HTTPResponse structure containing the      *      response      * @exception ModuleException  if an exception is encountered in any module.      * @exception IOException      Description of the Exception      */
DECL|method|Options
specifier|public
name|HTTPResponse
name|Options
parameter_list|(
name|String
name|file
parameter_list|,
name|NVPair
index|[]
name|headers
parameter_list|,
name|HttpOutputStream
name|stream
parameter_list|)
throws|throws
name|IOException
throws|,
name|ModuleException
block|{
return|return
name|setupRequest
argument_list|(
literal|"OPTIONS"
argument_list|,
name|stripRef
argument_list|(
name|file
argument_list|)
argument_list|,
name|headers
argument_list|,
literal|null
argument_list|,
name|stream
argument_list|)
return|;
block|}
comment|/**      * Requests that<var>file</var> be DELETEd from the server.      *      * @param file                 the absolute path of the resource      * @return                     an HTTPResponse structure containing the      *      response      * @exception ModuleException  if an exception is encountered in any module.      * @exception IOException      Description of the Exception      */
DECL|method|Delete
specifier|public
name|HTTPResponse
name|Delete
parameter_list|(
name|String
name|file
parameter_list|)
throws|throws
name|IOException
throws|,
name|ModuleException
block|{
return|return
name|Delete
argument_list|(
name|file
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/**      * Requests that<var>file</var> be DELETEd from the server.      *      * @param file                 the absolute path of the resource      * @param headers              additional headers      * @return                     an HTTPResponse structure containing the      *      response      * @exception ModuleException  if an exception is encountered in any module.      * @exception IOException      Description of the Exception      */
DECL|method|Delete
specifier|public
name|HTTPResponse
name|Delete
parameter_list|(
name|String
name|file
parameter_list|,
name|NVPair
index|[]
name|headers
parameter_list|)
throws|throws
name|IOException
throws|,
name|ModuleException
block|{
return|return
name|setupRequest
argument_list|(
literal|"DELETE"
argument_list|,
name|stripRef
argument_list|(
name|file
argument_list|)
argument_list|,
name|headers
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/**      * Requests a TRACE. Headers of particular interest here are "Via" and      * "Max-Forwards".      *      * @param file                 the absolute path of the resource      * @param headers              additional headers      * @return                     an HTTPResponse structure containing the      *      response      * @exception ModuleException  if an exception is encountered in any module.      * @exception IOException      Description of the Exception      */
DECL|method|Trace
specifier|public
name|HTTPResponse
name|Trace
parameter_list|(
name|String
name|file
parameter_list|,
name|NVPair
index|[]
name|headers
parameter_list|)
throws|throws
name|IOException
throws|,
name|ModuleException
block|{
return|return
name|setupRequest
argument_list|(
literal|"TRACE"
argument_list|,
name|stripRef
argument_list|(
name|file
argument_list|)
argument_list|,
name|headers
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/**      * Requests a TRACE.      *      * @param file                 the absolute path of the resource      * @return                     an HTTPResponse structure containing the      *      response      * @exception ModuleException  if an exception is encountered in any module.      * @exception IOException      Description of the Exception      */
DECL|method|Trace
specifier|public
name|HTTPResponse
name|Trace
parameter_list|(
name|String
name|file
parameter_list|)
throws|throws
name|IOException
throws|,
name|ModuleException
block|{
return|return
name|Trace
argument_list|(
name|file
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/**      * This is here to allow an arbitrary, non-standard request to be sent. I'm      * assuming you know what you are doing...      *      * @param method               the extension method      * @param file                 the absolute path of the resource, or null      * @param data                 optional data, or null      * @param headers              optional headers, or null      * @return                     an HTTPResponse structure containing the      *      response      * @exception ModuleException  if an exception is encountered in any module.      * @exception IOException      Description of the Exception      */
DECL|method|ExtensionMethod
specifier|public
name|HTTPResponse
name|ExtensionMethod
parameter_list|(
name|String
name|method
parameter_list|,
name|String
name|file
parameter_list|,
name|byte
index|[]
name|data
parameter_list|,
name|NVPair
index|[]
name|headers
parameter_list|)
throws|throws
name|IOException
throws|,
name|ModuleException
block|{
return|return
name|setupRequest
argument_list|(
name|method
operator|.
name|trim
argument_list|()
argument_list|,
name|stripRef
argument_list|(
name|file
argument_list|)
argument_list|,
name|headers
argument_list|,
name|data
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/**      * This is here to allow an arbitrary, non-standard request to be sent. I'm      * assuming you know what you are doing...      *      * @param method               the extension method      * @param file                 the absolute path of the resource, or null      * @param headers              optional headers, or null      * @param os                   Description of the Parameter      * @return                     an HTTPResponse structure containing the      *      response      * @exception ModuleException  if an exception is encountered in any module.      * @exception IOException      Description of the Exception      */
DECL|method|ExtensionMethod
specifier|public
name|HTTPResponse
name|ExtensionMethod
parameter_list|(
name|String
name|method
parameter_list|,
name|String
name|file
parameter_list|,
name|HttpOutputStream
name|os
parameter_list|,
name|NVPair
index|[]
name|headers
parameter_list|)
throws|throws
name|IOException
throws|,
name|ModuleException
block|{
return|return
name|setupRequest
argument_list|(
name|method
operator|.
name|trim
argument_list|()
argument_list|,
name|stripRef
argument_list|(
name|file
argument_list|)
argument_list|,
name|headers
argument_list|,
literal|null
argument_list|,
name|os
argument_list|)
return|;
block|}
comment|/**      * Aborts all the requests currently in progress on this connection and      * closes all associated sockets. You usually do<em>not</em> need to invoke      * this - it only meant for when you need to abruptly stop things, such as      * for example the stop button in a browser.<P>      *      * Note: there is a small window where a request method such as<code>Get()</code>      * may have been invoked but the request has not been built and added to the      * list. Any request in this window will not be aborted.      *      * @since   V0.2-3      */
DECL|method|stop
specifier|public
name|void
name|stop
parameter_list|()
block|{
for|for
control|(
name|Request
name|req
init|=
operator|(
name|Request
operator|)
name|RequestList
operator|.
name|enumerate
argument_list|()
init|;
name|req
operator|!=
literal|null
condition|;
name|req
operator|=
operator|(
name|Request
operator|)
name|RequestList
operator|.
name|next
argument_list|()
control|)
block|{
name|req
operator|.
name|aborted
operator|=
literal|true
expr_stmt|;
block|}
for|for
control|(
name|StreamDemultiplexor
name|demux
init|=
operator|(
name|StreamDemultiplexor
operator|)
name|DemuxList
operator|.
name|enumerate
argument_list|()
init|;
name|demux
operator|!=
literal|null
condition|;
name|demux
operator|=
operator|(
name|StreamDemultiplexor
operator|)
name|DemuxList
operator|.
name|next
argument_list|()
control|)
block|{
name|demux
operator|.
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * Sets the default http headers to be sent with each request. The actual      * headers sent are determined as follows: for each header specified in      * multiple places a value given as part of the request takes priority over      * any default values set by this method, which in turn takes priority over      * any built-in default values. A different way of looking at it is that we      * start off with a list of all headers specified with the request, then add      * any default headers set by this method which aren't already in our list,      * and finally add any built-in headers which aren't yet in the list. There      * is one exception to this rule: the "Content-length" header is always      * ignored; and when posting form-data any default "Content-type" is ignored      * in favor of the built-in "application/x-www-form-urlencoded" (however it      * will be overriden by any content-type header specified as part of the      * request).<P>      *      * Typical headers you might want to set here are "Accept" and its      * "Accept-*" relatives, "Connection", "From", "User-Agent", etc.      *      * @param headers  an array of header-name/value pairs (do not give the      *      separating ':').      */
DECL|method|setDefaultHeaders
specifier|public
name|void
name|setDefaultHeaders
parameter_list|(
name|NVPair
index|[]
name|headers
parameter_list|)
block|{
name|int
name|length
init|=
operator|(
name|headers
operator|==
literal|null
condition|?
literal|0
else|:
name|headers
operator|.
name|length
operator|)
decl_stmt|;
name|NVPair
index|[]
name|def_hdrs
init|=
operator|new
name|NVPair
index|[
name|length
index|]
decl_stmt|;
comment|// weed out undesired headers
name|int
name|sidx
decl_stmt|;
comment|// weed out undesired headers
name|int
name|didx
decl_stmt|;
for|for
control|(
name|sidx
operator|=
literal|0
operator|,
name|didx
operator|=
literal|0
init|;
name|sidx
operator|<
name|length
condition|;
name|sidx
operator|++
control|)
block|{
if|if
condition|(
name|headers
index|[
name|sidx
index|]
operator|==
literal|null
condition|)
block|{
continue|continue;
block|}
name|String
name|name
init|=
name|headers
index|[
name|sidx
index|]
operator|.
name|getName
argument_list|()
operator|.
name|trim
argument_list|()
decl_stmt|;
if|if
condition|(
name|name
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"Content-length"
argument_list|)
condition|)
block|{
continue|continue;
block|}
name|def_hdrs
index|[
name|didx
operator|++
index|]
operator|=
name|headers
index|[
name|sidx
index|]
expr_stmt|;
block|}
if|if
condition|(
name|didx
operator|<
name|length
condition|)
block|{
name|def_hdrs
operator|=
name|Util
operator|.
name|resizeArray
argument_list|(
name|def_hdrs
argument_list|,
name|didx
argument_list|)
expr_stmt|;
block|}
synchronized|synchronized
init|(
name|DefaultHeaders
init|)
block|{
name|DefaultHeaders
operator|=
name|def_hdrs
expr_stmt|;
block|}
block|}
comment|/**      * Gets the current list of default http headers.      *      * @return   an array of header/value pairs.      */
DECL|method|getDefaultHeaders
specifier|public
name|NVPair
index|[]
name|getDefaultHeaders
parameter_list|()
block|{
synchronized|synchronized
init|(
name|DefaultHeaders
init|)
block|{
return|return
operator|(
name|NVPair
index|[]
operator|)
name|DefaultHeaders
operator|.
name|clone
argument_list|()
return|;
block|}
block|}
comment|/**      * Returns the protocol this connection is talking.      *      * @return   a string containing the (lowercased) protocol      */
DECL|method|getProtocol
specifier|public
name|String
name|getProtocol
parameter_list|()
block|{
switch|switch
condition|(
name|Protocol
condition|)
block|{
case|case
name|HTTP
case|:
return|return
literal|"http"
return|;
case|case
name|HTTPS
case|:
return|return
literal|"https"
return|;
case|case
name|SHTTP
case|:
return|return
literal|"shttp"
return|;
case|case
name|HTTP_NG
case|:
return|return
literal|"http-ng"
return|;
default|default:
throw|throw
operator|new
name|Error
argument_list|(
literal|"HTTPClient Internal Error: invalid protocol "
operator|+
name|Protocol
argument_list|)
throw|;
block|}
block|}
comment|/**      * Returns the host this connection is talking to.      *      * @return   a string containing the (lowercased) host name.      */
DECL|method|getHost
specifier|public
name|String
name|getHost
parameter_list|()
block|{
return|return
name|Host
return|;
block|}
comment|/**      * Returns the port this connection connects to. This is always the actual      * port number, never -1.      *      * @return   the port number      */
DECL|method|getPort
specifier|public
name|int
name|getPort
parameter_list|()
block|{
return|return
name|Port
return|;
block|}
comment|/**      * Returns the host of the proxy this connection is using.      *      * @return   a string containing the (lowercased) host name.      */
DECL|method|getProxyHost
specifier|public
name|String
name|getProxyHost
parameter_list|()
block|{
return|return
name|Proxy_Host
return|;
block|}
comment|/**      * Returns the port of the proxy this connection is using.      *      * @return   the port number      */
DECL|method|getProxyPort
specifier|public
name|int
name|getProxyPort
parameter_list|()
block|{
return|return
name|Proxy_Port
return|;
block|}
comment|/**      * See if the given uri is compatible with this connection. Compatible means      * that the given uri can be retrieved using this connection object.      *      * @param uri  the URI to check      * @return     true if they're compatible, false otherwise      * @since      V0.3-2      */
DECL|method|isCompatibleWith
specifier|public
name|boolean
name|isCompatibleWith
parameter_list|(
name|URI
name|uri
parameter_list|)
block|{
if|if
condition|(
operator|!
name|uri
operator|.
name|getScheme
argument_list|()
operator|.
name|equals
argument_list|(
name|getProtocol
argument_list|()
argument_list|)
operator|||
operator|!
name|uri
operator|.
name|getHost
argument_list|()
operator|.
name|equalsIgnoreCase
argument_list|(
name|Host
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|int
name|port
init|=
name|uri
operator|.
name|getPort
argument_list|()
decl_stmt|;
if|if
condition|(
name|port
operator|==
operator|-
literal|1
condition|)
block|{
name|port
operator|=
name|URI
operator|.
name|defaultPort
argument_list|(
name|uri
operator|.
name|getScheme
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|port
operator|==
name|Port
return|;
block|}
comment|/**      * Sets/Resets raw mode. In raw mode all modules are bypassed, meaning the      * automatic handling of authorization requests, redirections, cookies, etc.      * is turned off.<P>      *      * The default is false.      *      * @param raw    if true removes all modules (except for the retry module)      * @deprecated   This is not really needed anymore; in V0.2 request were      *      synchronous and therefore to do pipelining you needed to disable the      *      processing of responses.      * @see          #removeModule(java.lang.Class)      */
DECL|method|setRawMode
specifier|public
name|void
name|setRawMode
parameter_list|(
name|boolean
name|raw
parameter_list|)
block|{
comment|// Don't remove the retry module
name|String
index|[]
name|modules
init|=
block|{
literal|"HTTPClient.CookieModule"
block|,
literal|"HTTPClient.RedirectionModule"
block|,
literal|"HTTPClient.AuthorizationModule"
block|,
literal|"HTTPClient.DefaultModule"
block|,
literal|"HTTPClient.TransferEncodingModule"
block|,
literal|"HTTPClient.ContentMD5Module"
block|,
literal|"HTTPClient.ContentEncodingModule"
block|}
decl_stmt|;
for|for
control|(
name|int
name|idx
init|=
literal|0
init|;
name|idx
operator|<
name|modules
operator|.
name|length
condition|;
name|idx
operator|++
control|)
block|{
try|try
block|{
if|if
condition|(
name|raw
condition|)
block|{
name|removeModule
argument_list|(
name|Class
operator|.
name|forName
argument_list|(
name|modules
index|[
name|idx
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|addModule
argument_list|(
name|Class
operator|.
name|forName
argument_list|(
name|modules
index|[
name|idx
index|]
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|ClassNotFoundException
name|cnfe
parameter_list|)
block|{             }
block|}
block|}
comment|/**      * Sets the default timeout value to be used for each new HTTPConnection.      * The default is 0.      *      * @param time  the timeout in milliseconds.      * @see         #setTimeout(int)      */
DECL|method|setDefaultTimeout
specifier|public
specifier|static
name|void
name|setDefaultTimeout
parameter_list|(
name|int
name|time
parameter_list|)
block|{
name|DefaultTimeout
operator|=
name|time
expr_stmt|;
block|}
comment|/**      * Gets the default timeout value to be used for each new HTTPConnection.      *      * @return   the timeout in milliseconds.      * @see      #setTimeout(int)      */
DECL|method|getDefaultTimeout
specifier|public
specifier|static
name|int
name|getDefaultTimeout
parameter_list|()
block|{
return|return
name|DefaultTimeout
return|;
block|}
comment|/**      * Sets the timeout to be used for creating connections and reading      * responses. When a timeout expires the operation will throw an      * InterruptedIOException. The operation may be restarted again afterwards.      * If the operation is not restarted and it is a read operation (i.e      * HTTPResponse.xxxx()) then<code>resp.getInputStream().close()</code>      *<strong>should</strong> be invoked.<P>      *      * When creating new sockets the timeout will limit the time spent doing the      * host name translation and establishing the connection with the server.      *<P>      *      * The timeout also influences the reading of the response headers. However,      * it does not specify a how long, for example, getStatusCode() may take, as      * might be assumed. Instead it specifies how long a read on the socket may      * take. If the response dribbles in slowly with packets arriving quicker      * than the timeout then the method will complete normally. I.e. the      * exception is only thrown if nothing arrives on the socket for the      * specified time. Furthermore, the timeout only influences the reading of      * the headers, not the reading of the body.<P>      *      * Read Timeouts are associated with responses, so that you may change this      * value before each request and it won't affect the reading of responses to      * previous requests.      *      * @param time  the time in milliseconds. A time of 0 means wait      *      indefinitely.      * @see         #stop()      */
DECL|method|setTimeout
specifier|public
name|void
name|setTimeout
parameter_list|(
name|int
name|time
parameter_list|)
block|{
name|Timeout
operator|=
name|time
expr_stmt|;
block|}
comment|/**      * Gets the timeout used for reading response data.      *      * @return   the current timeout value      * @see      #setTimeout(int)      */
DECL|method|getTimeout
specifier|public
name|int
name|getTimeout
parameter_list|()
block|{
return|return
name|Timeout
return|;
block|}
comment|/**      * Controls whether modules are allowed to prompt the user or pop up dialogs      * if neccessary.      *      * @param allow  if true allows modules to interact with user.      */
DECL|method|setAllowUserInteraction
specifier|public
name|void
name|setAllowUserInteraction
parameter_list|(
name|boolean
name|allow
parameter_list|)
block|{
name|allowUI
operator|=
name|allow
expr_stmt|;
block|}
comment|/**      * returns whether modules are allowed to prompt or popup dialogs if      * neccessary.      *      * @return   true if modules are allowed to interact with user.      */
DECL|method|getAllowUserInteraction
specifier|public
name|boolean
name|getAllowUserInteraction
parameter_list|()
block|{
return|return
name|allowUI
return|;
block|}
comment|/**      * Sets the default allow-user-action.      *      * @param allow  if true allows modules to interact with user.      */
DECL|method|setDefaultAllowUserInteraction
specifier|public
specifier|static
name|void
name|setDefaultAllowUserInteraction
parameter_list|(
name|boolean
name|allow
parameter_list|)
block|{
name|defaultAllowUI
operator|=
name|allow
expr_stmt|;
block|}
comment|/**      * Gets the default allow-user-action.      *      * @return   true if modules are allowed to interact with user.      */
DECL|method|getDefaultAllowUserInteraction
specifier|public
specifier|static
name|boolean
name|getDefaultAllowUserInteraction
parameter_list|()
block|{
return|return
name|defaultAllowUI
return|;
block|}
comment|/**      * Returns the default list of modules.      *      * @return   an array of classes      */
DECL|method|getDefaultModules
specifier|public
specifier|static
name|Class
index|[]
name|getDefaultModules
parameter_list|()
block|{
return|return
name|getModules
argument_list|(
name|DefaultModuleList
argument_list|)
return|;
block|}
comment|/**      * Adds a module to the default list. It must implement the<var>      * HTTPClientModule</var> interface. If the module is already in the list      * then this method does nothing. This method only affects instances of      * HTTPConnection created after this method has been invoked; it does not      * affect existing instances.<P>      *      * Example:<PRE>      * HTTPConnection.addDefaultModule(Class.forName("HTTPClient.CookieModule"), 1);      *</PRE> adds the cookie module as the second module in the list.<P>      *      * The default list is created at class initialization time from the      * property<var>HTTPClient.Modules</var> . This must contain a "|"      * separated list of classes in the order they're to be invoked. If this      * property is not set it defaults to: "HTTPClient.RetryModule |      * HTTPClient.CookieModule | HTTPClient.RedirectionModule |      * HTTPClient.AuthorizationModule | HTTPClient.DefaultModule |      * HTTPClient.TransferEncodingModule | HTTPClient.ContentMD5Module |      * HTTPClient.ContentEncodingModule"      *      * @param module  the module's Class object      * @param pos     the position of this module in the list; if<var>pos</var>      *>= 0 then this is the absolute position in the list (0 is the first      *      position); if<var>pos</var>< 0 then this is the position relative      *      to the end of the list (-1 means the last element, -2 the second to      *      last element, etc).      * @return        true if module was successfully added; false if the module      *      is already in the list.      * @see           HTTPClientModule      */
DECL|method|addDefaultModule
specifier|public
specifier|static
name|boolean
name|addDefaultModule
parameter_list|(
name|Class
name|module
parameter_list|,
name|int
name|pos
parameter_list|)
block|{
return|return
name|addModule
argument_list|(
name|DefaultModuleList
argument_list|,
name|module
argument_list|,
name|pos
argument_list|)
return|;
block|}
comment|/**      * Removes a module from the default list. If the module is not in the list      * it does nothing. This method only affects instances of HTTPConnection      * created after this method has been invoked; it does not affect existing      * instances.      *      * @param module  the module's Class object      * @return        true if module was successfully removed; false otherwise      */
DECL|method|removeDefaultModule
specifier|public
specifier|static
name|boolean
name|removeDefaultModule
parameter_list|(
name|Class
name|module
parameter_list|)
block|{
return|return
name|removeModule
argument_list|(
name|DefaultModuleList
argument_list|,
name|module
argument_list|)
return|;
block|}
comment|/**      * Returns the list of modules used currently.      *      * @return   an array of classes      */
DECL|method|getModules
specifier|public
name|Class
index|[]
name|getModules
parameter_list|()
block|{
return|return
name|getModules
argument_list|(
name|ModuleList
argument_list|)
return|;
block|}
comment|/**      * Adds a module to the current list. It must implement the<var>      * HTTPClientModule</var> interface. If the module is already in the list      * then this method does nothing.      *      * @param module  the module's Class object      * @param pos     the position of this module in the list; if<var>pos</var>      *>= 0 then this is the absolute position in the list (0 is the first      *      position); if<var>pos</var>< 0 then this is the position relative      *      to the end of the list (-1 means the last element, -2 the second to      *      last element, etc).      * @return        true if module was successfully added; false if the module      *      is already in the list.      * @see           HTTPClientModule      */
DECL|method|addModule
specifier|public
name|boolean
name|addModule
parameter_list|(
name|Class
name|module
parameter_list|,
name|int
name|pos
parameter_list|)
block|{
return|return
name|addModule
argument_list|(
name|ModuleList
argument_list|,
name|module
argument_list|,
name|pos
argument_list|)
return|;
block|}
comment|/**      * Removes a module from the current list. If the module is not in the list      * it does nothing.      *      * @param module  the module's Class object      * @return        true if module was successfully removed; false otherwise      */
DECL|method|removeModule
specifier|public
name|boolean
name|removeModule
parameter_list|(
name|Class
name|module
parameter_list|)
block|{
return|return
name|removeModule
argument_list|(
name|ModuleList
argument_list|,
name|module
argument_list|)
return|;
block|}
comment|/**      * Gets the modules attribute of the HTTPConnection class      *      * @param list  Description of the Parameter      * @return      The modules value      */
DECL|method|getModules
specifier|private
specifier|final
specifier|static
name|Class
index|[]
name|getModules
parameter_list|(
name|Vector
name|list
parameter_list|)
block|{
synchronized|synchronized
init|(
name|list
init|)
block|{
name|Class
index|[]
name|modules
init|=
operator|new
name|Class
index|[
name|list
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
name|list
operator|.
name|copyInto
argument_list|(
name|modules
argument_list|)
expr_stmt|;
return|return
name|modules
return|;
block|}
block|}
comment|/**      * Adds a feature to the Module attribute of the HTTPConnection class      *      * @param list    The feature to be added to the Module attribute      * @param module  The feature to be added to the Module attribute      * @param pos     The feature to be added to the Module attribute      * @return        Description of the Return Value      */
DECL|method|addModule
specifier|private
specifier|final
specifier|static
name|boolean
name|addModule
parameter_list|(
name|Vector
name|list
parameter_list|,
name|Class
name|module
parameter_list|,
name|int
name|pos
parameter_list|)
block|{
if|if
condition|(
name|module
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|// check if module implements HTTPClientModule
try|try
block|{
name|HTTPClientModule
name|tmp
init|=
operator|(
name|HTTPClientModule
operator|)
name|module
operator|.
name|newInstance
argument_list|()
decl_stmt|;
block|}
catch|catch
parameter_list|(
name|RuntimeException
name|re
parameter_list|)
block|{
throw|throw
name|re
throw|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
operator|.
name|toString
argument_list|()
argument_list|)
throw|;
block|}
synchronized|synchronized
init|(
name|list
init|)
block|{
comment|// check if module already in list
if|if
condition|(
name|list
operator|.
name|contains
argument_list|(
name|module
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|// add module to list
if|if
condition|(
name|pos
operator|<
literal|0
condition|)
block|{
name|list
operator|.
name|insertElementAt
argument_list|(
name|module
argument_list|,
name|DefaultModuleList
operator|.
name|size
argument_list|()
operator|+
name|pos
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|list
operator|.
name|insertElementAt
argument_list|(
name|module
argument_list|,
name|pos
argument_list|)
expr_stmt|;
block|}
block|}
name|Log
operator|.
name|write
argument_list|(
name|Log
operator|.
name|CONN
argument_list|,
literal|"Conn:  Added module "
operator|+
name|module
operator|.
name|getName
argument_list|()
operator|+
literal|" to "
operator|+
operator|(
operator|(
name|list
operator|==
name|DefaultModuleList
operator|)
condition|?
literal|"default "
else|:
literal|""
operator|)
operator|+
literal|"list"
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
comment|/**      * Description of the Method      *      * @param list    Description of the Parameter      * @param module  Description of the Parameter      * @return        Description of the Return Value      */
DECL|method|removeModule
specifier|private
specifier|final
specifier|static
name|boolean
name|removeModule
parameter_list|(
name|Vector
name|list
parameter_list|,
name|Class
name|module
parameter_list|)
block|{
if|if
condition|(
name|module
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
name|boolean
name|removed
init|=
name|list
operator|.
name|removeElement
argument_list|(
name|module
argument_list|)
decl_stmt|;
if|if
condition|(
name|removed
condition|)
block|{
name|Log
operator|.
name|write
argument_list|(
name|Log
operator|.
name|CONN
argument_list|,
literal|"Conn:  Removed module "
operator|+
name|module
operator|.
name|getName
argument_list|()
operator|+
literal|" from "
operator|+
operator|(
operator|(
name|list
operator|==
name|DefaultModuleList
operator|)
condition|?
literal|"default "
else|:
literal|""
operator|)
operator|+
literal|"list"
argument_list|)
expr_stmt|;
block|}
return|return
name|removed
return|;
block|}
comment|/**      * Sets the current context. The context is used by modules such as the      * AuthorizationModule and the CookieModule which keep lists of info that is      * normally shared between all instances of HTTPConnection. This is usually      * the desired behaviour. However, in some cases one would like to simulate      * multiple independent clients within the same application and hence the      * sharing of such info should be restricted. This is where the context      * comes in. Modules will only share their info between requests using the      * same context (i.e. they keep multiple lists, one for each context).<P>      *      * The context may be any object. Contexts are considered equal if<code>equals()</code>      * returns true. Examples of useful context objects are threads (e.g. if you      * are running multiple clients, one per thread) and sockets (e.g. if you      * are implementing a gateway).<P>      *      * When a new HTTPConnection is created it is initialized with a default      * context which is the same for all instances. This method must be invoked      * immediately after a new HTTPConnection is created and before any request      * method is invoked. Furthermore, this method may only be called once (i.e.      * the context is "sticky").      *      * @param context  the new context; must be non-null      */
DECL|method|setContext
specifier|public
name|void
name|setContext
parameter_list|(
name|Object
name|context
parameter_list|)
block|{
if|if
condition|(
name|context
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Context must be non-null"
argument_list|)
throw|;
block|}
if|if
condition|(
name|Context
operator|!=
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Context already set"
argument_list|)
throw|;
block|}
name|Context
operator|=
name|context
expr_stmt|;
block|}
comment|/**      * Returns the current context.      *      * @return   the current context, or the default context if<code>setContext()</code>      *      hasn't been invoked      * @see      #setContext(java.lang.Object)      */
DECL|method|getContext
specifier|public
name|Object
name|getContext
parameter_list|()
block|{
if|if
condition|(
name|Context
operator|!=
literal|null
condition|)
block|{
return|return
name|Context
return|;
block|}
else|else
block|{
return|return
name|dflt_context
return|;
block|}
block|}
comment|/**      * Returns the default context.      *      * @return   the default context      * @see      #setContext(java.lang.Object)      */
DECL|method|getDefaultContext
specifier|public
specifier|static
name|Object
name|getDefaultContext
parameter_list|()
block|{
return|return
name|dflt_context
return|;
block|}
comment|/**      * Adds an authorization entry for the "digest" authorization scheme to the      * list. If an entry already exists for the "digest" scheme and the      * specified realm then it is overwritten.<P>      *      * This is a convenience method and just invokes the corresponding method in      * AuthorizationInfo.      *      * @param realm   the realm      * @param user    the username      * @param passwd  The feature to be added to the DigestAuthorization      *      attribute      * @see           AuthorizationInfo#addDigestAuthorization(java.lang.String,      *      int, java.lang.String, java.lang.String, java.lang.String)      */
DECL|method|addDigestAuthorization
specifier|public
name|void
name|addDigestAuthorization
parameter_list|(
name|String
name|realm
parameter_list|,
name|String
name|user
parameter_list|,
name|String
name|passwd
parameter_list|)
block|{
name|AuthorizationInfo
operator|.
name|addDigestAuthorization
argument_list|(
name|Host
argument_list|,
name|Port
argument_list|,
name|realm
argument_list|,
name|user
argument_list|,
name|passwd
argument_list|,
name|getContext
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**      * Adds an authorization entry for the "basic" authorization scheme to the      * list. If an entry already exists for the "basic" scheme and the specified      * realm then it is overwritten.<P>      *      * This is a convenience method and just invokes the corresponding method in      * AuthorizationInfo.      *      * @param realm   the realm      * @param user    the username      * @param passwd  The feature to be added to the BasicAuthorization      *      attribute      * @see           AuthorizationInfo#addBasicAuthorization(java.lang.String,      *      int, java.lang.String, java.lang.String, java.lang.String)      */
DECL|method|addBasicAuthorization
specifier|public
name|void
name|addBasicAuthorization
parameter_list|(
name|String
name|realm
parameter_list|,
name|String
name|user
parameter_list|,
name|String
name|passwd
parameter_list|)
block|{
name|AuthorizationInfo
operator|.
name|addBasicAuthorization
argument_list|(
name|Host
argument_list|,
name|Port
argument_list|,
name|realm
argument_list|,
name|user
argument_list|,
name|passwd
argument_list|,
name|getContext
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**      * Sets the default proxy server to use. The proxy will only be used for new      *<var>HTTPConnection</var> s created after this call and will not affect      * currrent instances of<var>HTTPConnection</var> . A null or empty string      *<var>host</var> parameter disables the proxy.<P>      *      * In an application or using the Appletviewer an alternative to this method      * is to set the following properties (either in the properties file or on      * the command line):<var>http.proxyHost</var> and<var>http.proxyPort      *</var>. Whether<var>http.proxyHost</var> is set or not determines      * whether a proxy server is used.<P>      *      * If the proxy server requires authorization and you wish to set this      * authorization information in the code, then you may use any of the<var>      * AuthorizationInfo.addXXXAuthorization()</var> methods to do so. Specify      * the same<var>host</var> and<var>port</var> as in this method. If you      * have not given any authorization info and the proxy server requires      * authorization then you will be prompted for the necessary info via a      * popup the first time you do a request.      *      * @param host  the host on which the proxy server resides.      * @param port  the port the proxy server is listening on.      * @see         #setCurrentProxy(java.lang.String, int)      */
DECL|method|setProxyServer
specifier|public
specifier|static
name|void
name|setProxyServer
parameter_list|(
name|String
name|host
parameter_list|,
name|int
name|port
parameter_list|)
block|{
if|if
condition|(
name|host
operator|==
literal|null
operator|||
name|host
operator|.
name|trim
argument_list|()
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
block|{
name|Default_Proxy_Host
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
name|Default_Proxy_Host
operator|=
name|host
operator|.
name|trim
argument_list|()
operator|.
name|toLowerCase
argument_list|()
expr_stmt|;
name|Default_Proxy_Port
operator|=
name|port
expr_stmt|;
block|}
block|}
comment|/**      * Sets the proxy used by this instance. This can be used to override the      * proxy setting inherited from the default proxy setting. A null or empty      * string<var>host</var> parameter disables the proxy.<P>      *      * Note that if you set a proxy for the connection using this method, and a      * request made over this connection is redirected to a different server,      * then the connection used for new server will<em>not</em> pick this proxy      * setting, but instead will use the default proxy settings.      *      * @param host  the host the proxy runs on      * @param port  the port the proxy is listening on      * @see         #setProxyServer(java.lang.String, int)      */
DECL|method|setCurrentProxy
specifier|public
specifier|synchronized
name|void
name|setCurrentProxy
parameter_list|(
name|String
name|host
parameter_list|,
name|int
name|port
parameter_list|)
block|{
if|if
condition|(
name|host
operator|==
literal|null
operator|||
name|host
operator|.
name|trim
argument_list|()
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
block|{
name|Proxy_Host
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
name|Proxy_Host
operator|=
name|host
operator|.
name|trim
argument_list|()
operator|.
name|toLowerCase
argument_list|()
expr_stmt|;
if|if
condition|(
name|port
operator|<=
literal|0
condition|)
block|{
name|Proxy_Port
operator|=
literal|80
expr_stmt|;
block|}
else|else
block|{
name|Proxy_Port
operator|=
name|port
expr_stmt|;
block|}
block|}
comment|// the proxy might be talking a different version, so renegotiate
switch|switch
condition|(
name|Protocol
condition|)
block|{
case|case
name|HTTP
case|:
case|case
name|HTTPS
case|:
if|if
condition|(
name|force_1_0
condition|)
block|{
name|ServerProtocolVersion
operator|=
name|HTTP_1_0
expr_stmt|;
name|ServProtVersKnown
operator|=
literal|true
expr_stmt|;
name|RequestProtocolVersion
operator|=
literal|"HTTP/1.0"
expr_stmt|;
block|}
else|else
block|{
name|ServerProtocolVersion
operator|=
name|HTTP_1_1
expr_stmt|;
name|ServProtVersKnown
operator|=
literal|false
expr_stmt|;
name|RequestProtocolVersion
operator|=
literal|"HTTP/1.1"
expr_stmt|;
block|}
break|break;
case|case
name|HTTP_NG
case|:
name|ServerProtocolVersion
operator|=
operator|-
literal|1
expr_stmt|;
comment|/*                  *  Unknown                  */
name|ServProtVersKnown
operator|=
literal|false
expr_stmt|;
name|RequestProtocolVersion
operator|=
literal|""
expr_stmt|;
break|break;
case|case
name|SHTTP
case|:
name|ServerProtocolVersion
operator|=
operator|-
literal|1
expr_stmt|;
comment|/*                  *  Unknown                  */
name|ServProtVersKnown
operator|=
literal|false
expr_stmt|;
name|RequestProtocolVersion
operator|=
literal|"Secure-HTTP/1.3"
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|Error
argument_list|(
literal|"HTTPClient Internal Error: invalid protocol "
operator|+
name|Protocol
argument_list|)
throw|;
block|}
name|keepAliveUnknown
operator|=
literal|true
expr_stmt|;
name|doesKeepAlive
operator|=
literal|false
expr_stmt|;
name|input_demux
operator|=
literal|null
expr_stmt|;
name|early_stall
operator|=
literal|null
expr_stmt|;
name|late_stall
operator|=
literal|null
expr_stmt|;
name|prev_resp
operator|=
literal|null
expr_stmt|;
block|}
comment|/**      * Add<var>host</var> to the list of hosts which should be accessed      * directly, not via any proxy set by<code>setProxyServer()</code>.<P>      *      * The<var>host</var> may be any of:      *<UL>      *<LI> a complete host name (e.g. "www.disney.com")      *<LI> a domain name; domain names must begin with a dot (e.g.      *   ".disney.com")      *<LI> an IP-address (e.g. "12.34.56.78")      *<LI> an IP-subnet, specified as an IP-address and a netmask separated      *   by a "/" (e.g. "34.56.78/255.255.255.192"); a 0 bit in the netmask      *   means that that bit won't be used in the comparison (i.e. the addresses      *   are AND'ed with the netmask before comparison).      *</UL>      *<P>      *      * The two properties<var>HTTPClient.nonProxyHosts</var> and<var>      * http.nonProxyHosts</var> are used when this class is loaded to initialize      * the list of non-proxy hosts. The second property is only read if the      * first one is not set; the second property is also used the JDK's      * URLConnection. These properties must contain a "|" separated list of      * entries which conform to the above rules for the<var>host</var>      * parameter (e.g. "11.22.33.44|.disney.com").      *      * @param host                a host name, domain name, IP-address or      *      IP-subnet.      * @exception ParseException  if the length of the netmask does not match      *      the length of the IP-address      */
DECL|method|dontProxyFor
specifier|public
specifier|static
name|void
name|dontProxyFor
parameter_list|(
name|String
name|host
parameter_list|)
throws|throws
name|ParseException
block|{
name|host
operator|=
name|host
operator|.
name|trim
argument_list|()
operator|.
name|toLowerCase
argument_list|()
expr_stmt|;
comment|// check for domain name
if|if
condition|(
name|host
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
operator|==
literal|'.'
condition|)
block|{
if|if
condition|(
operator|!
name|non_proxy_dom_list
operator|.
name|contains
argument_list|(
name|host
argument_list|)
condition|)
block|{
name|non_proxy_dom_list
operator|.
name|addElement
argument_list|(
name|host
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
comment|// check for host name
for|for
control|(
name|int
name|idx
init|=
literal|0
init|;
name|idx
operator|<
name|host
operator|.
name|length
argument_list|()
condition|;
name|idx
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|Character
operator|.
name|isDigit
argument_list|(
name|host
operator|.
name|charAt
argument_list|(
name|idx
argument_list|)
argument_list|)
operator|&&
name|host
operator|.
name|charAt
argument_list|(
name|idx
argument_list|)
operator|!=
literal|'.'
operator|&&
name|host
operator|.
name|charAt
argument_list|(
name|idx
argument_list|)
operator|!=
literal|'/'
condition|)
block|{
name|non_proxy_host_list
operator|.
name|put
argument_list|(
name|host
argument_list|,
literal|""
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|// must be an IP-address
name|byte
index|[]
name|ip_addr
decl_stmt|;
name|byte
index|[]
name|ip_mask
decl_stmt|;
name|int
name|slash
decl_stmt|;
if|if
condition|(
operator|(
name|slash
operator|=
name|host
operator|.
name|indexOf
argument_list|(
literal|'/'
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
comment|// IP subnet
name|ip_addr
operator|=
name|string2arr
argument_list|(
name|host
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|slash
argument_list|)
argument_list|)
expr_stmt|;
name|ip_mask
operator|=
name|string2arr
argument_list|(
name|host
operator|.
name|substring
argument_list|(
name|slash
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip_addr
operator|.
name|length
operator|!=
name|ip_mask
operator|.
name|length
condition|)
block|{
throw|throw
operator|new
name|ParseException
argument_list|(
literal|"length of IP-address ("
operator|+
name|ip_addr
operator|.
name|length
operator|+
literal|") != length of netmask ("
operator|+
name|ip_mask
operator|.
name|length
operator|+
literal|")"
argument_list|)
throw|;
block|}
block|}
else|else
block|{
name|ip_addr
operator|=
name|string2arr
argument_list|(
name|host
argument_list|)
expr_stmt|;
name|ip_mask
operator|=
operator|new
name|byte
index|[
name|ip_addr
operator|.
name|length
index|]
expr_stmt|;
for|for
control|(
name|int
name|idx
init|=
literal|0
init|;
name|idx
operator|<
name|ip_mask
operator|.
name|length
condition|;
name|idx
operator|++
control|)
block|{
name|ip_mask
index|[
name|idx
index|]
operator|=
operator|(
name|byte
operator|)
literal|255
expr_stmt|;
block|}
block|}
comment|// check if addr or subnet already exists
name|ip_loop
label|:
for|for
control|(
name|int
name|idx
init|=
literal|0
init|;
name|idx
operator|<
name|non_proxy_addr_list
operator|.
name|size
argument_list|()
condition|;
name|idx
operator|++
control|)
block|{
name|byte
index|[]
name|addr
init|=
operator|(
name|byte
index|[]
operator|)
name|non_proxy_addr_list
operator|.
name|elementAt
argument_list|(
name|idx
argument_list|)
decl_stmt|;
name|byte
index|[]
name|mask
init|=
operator|(
name|byte
index|[]
operator|)
name|non_proxy_mask_list
operator|.
name|elementAt
argument_list|(
name|idx
argument_list|)
decl_stmt|;
if|if
condition|(
name|addr
operator|.
name|length
operator|!=
name|ip_addr
operator|.
name|length
condition|)
block|{
continue|continue;
block|}
for|for
control|(
name|int
name|idx2
init|=
literal|0
init|;
name|idx2
operator|<
name|addr
operator|.
name|length
condition|;
name|idx2
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|ip_addr
index|[
name|idx2
index|]
operator|&
name|mask
index|[
name|idx2
index|]
operator|)
operator|!=
operator|(
name|addr
index|[
name|idx2
index|]
operator|&
name|mask
index|[
name|idx2
index|]
operator|)
operator|||
operator|(
name|mask
index|[
name|idx2
index|]
operator|!=
name|ip_mask
index|[
name|idx2
index|]
operator|)
condition|)
block|{
continue|continue
name|ip_loop
continue|;
block|}
block|}
return|return;
comment|// already exists
block|}
name|non_proxy_addr_list
operator|.
name|addElement
argument_list|(
name|ip_addr
argument_list|)
expr_stmt|;
name|non_proxy_mask_list
operator|.
name|addElement
argument_list|(
name|ip_mask
argument_list|)
expr_stmt|;
block|}
comment|/**      * Convenience method to add a number of hosts at once. If any one host is      * null or cannot be parsed it is ignored.      *      * @param hosts  The list of hosts to set      * @see          #dontProxyFor(java.lang.String)      * @since        V0.3-2      */
DECL|method|dontProxyFor
specifier|public
specifier|static
name|void
name|dontProxyFor
parameter_list|(
name|String
index|[]
name|hosts
parameter_list|)
block|{
if|if
condition|(
name|hosts
operator|==
literal|null
operator|||
name|hosts
operator|.
name|length
operator|==
literal|0
condition|)
block|{
return|return;
block|}
for|for
control|(
name|int
name|idx
init|=
literal|0
init|;
name|idx
operator|<
name|hosts
operator|.
name|length
condition|;
name|idx
operator|++
control|)
block|{
try|try
block|{
if|if
condition|(
name|hosts
index|[
name|idx
index|]
operator|!=
literal|null
condition|)
block|{
name|dontProxyFor
argument_list|(
name|hosts
index|[
name|idx
index|]
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|ParseException
name|pe
parameter_list|)
block|{
comment|// ignore it
block|}
block|}
block|}
comment|/**      * Remove<var>host</var> from the list of hosts for which the proxy should      * not be used. This modifies the same list that<code>dontProxyFor()</code>      * uses, i.e. this is used to undo a<code>dontProxyFor()</code> setting.      * The syntax for<var>host</var> is specified in<code>dontProxyFor()</code>      * .      *      * @param host                a host name, domain name, IP-address or      *      IP-subnet.      * @return                    true if the remove was sucessful, false      *      otherwise      * @exception ParseException  if the length of the netmask does not match      *      the length of the IP-address      * @see                       #dontProxyFor(java.lang.String)      */
DECL|method|doProxyFor
specifier|public
specifier|static
name|boolean
name|doProxyFor
parameter_list|(
name|String
name|host
parameter_list|)
throws|throws
name|ParseException
block|{
name|host
operator|=
name|host
operator|.
name|trim
argument_list|()
operator|.
name|toLowerCase
argument_list|()
expr_stmt|;
comment|// check for domain name
if|if
condition|(
name|host
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
operator|==
literal|'.'
condition|)
block|{
return|return
name|non_proxy_dom_list
operator|.
name|removeElement
argument_list|(
name|host
argument_list|)
return|;
block|}
comment|// check for host name
for|for
control|(
name|int
name|idx
init|=
literal|0
init|;
name|idx
operator|<
name|host
operator|.
name|length
argument_list|()
condition|;
name|idx
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|Character
operator|.
name|isDigit
argument_list|(
name|host
operator|.
name|charAt
argument_list|(
name|idx
argument_list|)
argument_list|)
operator|&&
name|host
operator|.
name|charAt
argument_list|(
name|idx
argument_list|)
operator|!=
literal|'.'
operator|&&
name|host
operator|.
name|charAt
argument_list|(
name|idx
argument_list|)
operator|!=
literal|'/'
condition|)
block|{
return|return
operator|(
name|non_proxy_host_list
operator|.
name|remove
argument_list|(
name|host
argument_list|)
operator|!=
literal|null
operator|)
return|;
block|}
block|}
comment|// must be an IP-address
name|byte
index|[]
name|ip_addr
decl_stmt|;
name|byte
index|[]
name|ip_mask
decl_stmt|;
name|int
name|slash
decl_stmt|;
if|if
condition|(
operator|(
name|slash
operator|=
name|host
operator|.
name|indexOf
argument_list|(
literal|'/'
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
comment|// IP subnet
name|ip_addr
operator|=
name|string2arr
argument_list|(
name|host
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|slash
argument_list|)
argument_list|)
expr_stmt|;
name|ip_mask
operator|=
name|string2arr
argument_list|(
name|host
operator|.
name|substring
argument_list|(
name|slash
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip_addr
operator|.
name|length
operator|!=
name|ip_mask
operator|.
name|length
condition|)
block|{
throw|throw
operator|new
name|ParseException
argument_list|(
literal|"length of IP-address ("
operator|+
name|ip_addr
operator|.
name|length
operator|+
literal|") != length of netmask ("
operator|+
name|ip_mask
operator|.
name|length
operator|+
literal|")"
argument_list|)
throw|;
block|}
block|}
else|else
block|{
name|ip_addr
operator|=
name|string2arr
argument_list|(
name|host
argument_list|)
expr_stmt|;
name|ip_mask
operator|=
operator|new
name|byte
index|[
name|ip_addr
operator|.
name|length
index|]
expr_stmt|;
for|for
control|(
name|int
name|idx
init|=
literal|0
init|;
name|idx
operator|<
name|ip_mask
operator|.
name|length
condition|;
name|idx
operator|++
control|)
block|{
name|ip_mask
index|[
name|idx
index|]
operator|=
operator|(
name|byte
operator|)
literal|255
expr_stmt|;
block|}
block|}
name|ip_loop
label|:
for|for
control|(
name|int
name|idx
init|=
literal|0
init|;
name|idx
operator|<
name|non_proxy_addr_list
operator|.
name|size
argument_list|()
condition|;
name|idx
operator|++
control|)
block|{
name|byte
index|[]
name|addr
init|=
operator|(
name|byte
index|[]
operator|)
name|non_proxy_addr_list
operator|.
name|elementAt
argument_list|(
name|idx
argument_list|)
decl_stmt|;
name|byte
index|[]
name|mask
init|=
operator|(
name|byte
index|[]
operator|)
name|non_proxy_mask_list
operator|.
name|elementAt
argument_list|(
name|idx
argument_list|)
decl_stmt|;
if|if
condition|(
name|addr
operator|.
name|length
operator|!=
name|ip_addr
operator|.
name|length
condition|)
block|{
continue|continue;
block|}
for|for
control|(
name|int
name|idx2
init|=
literal|0
init|;
name|idx2
operator|<
name|addr
operator|.
name|length
condition|;
name|idx2
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|ip_addr
index|[
name|idx2
index|]
operator|&
name|mask
index|[
name|idx2
index|]
operator|)
operator|!=
operator|(
name|addr
index|[
name|idx2
index|]
operator|&
name|mask
index|[
name|idx2
index|]
operator|)
operator|||
operator|(
name|mask
index|[
name|idx2
index|]
operator|!=
name|ip_mask
index|[
name|idx2
index|]
operator|)
condition|)
block|{
continue|continue
name|ip_loop
continue|;
block|}
block|}
name|non_proxy_addr_list
operator|.
name|removeElementAt
argument_list|(
name|idx
argument_list|)
expr_stmt|;
name|non_proxy_mask_list
operator|.
name|removeElementAt
argument_list|(
name|idx
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
comment|/**      * Turn an IP-address string into an array (e.g. "12.34.56.78" into { 12,      * 34, 56, 78 }).      *      * @param ip  IP-address      * @return    IP-address in network byte order      */
DECL|method|string2arr
specifier|private
specifier|static
name|byte
index|[]
name|string2arr
parameter_list|(
name|String
name|ip
parameter_list|)
block|{
name|byte
index|[]
name|arr
decl_stmt|;
name|char
index|[]
name|ip_char
init|=
operator|new
name|char
index|[
name|ip
operator|.
name|length
argument_list|()
index|]
decl_stmt|;
name|ip
operator|.
name|getChars
argument_list|(
literal|0
argument_list|,
name|ip_char
operator|.
name|length
argument_list|,
name|ip_char
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|int
name|cnt
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|idx
init|=
literal|0
init|;
name|idx
operator|<
name|ip_char
operator|.
name|length
condition|;
name|idx
operator|++
control|)
block|{
if|if
condition|(
name|ip_char
index|[
name|idx
index|]
operator|==
literal|'.'
condition|)
block|{
name|cnt
operator|++
expr_stmt|;
block|}
block|}
name|arr
operator|=
operator|new
name|byte
index|[
name|cnt
operator|+
literal|1
index|]
expr_stmt|;
name|cnt
operator|=
literal|0
expr_stmt|;
name|int
name|pos
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|idx
init|=
literal|0
init|;
name|idx
operator|<
name|ip_char
operator|.
name|length
condition|;
name|idx
operator|++
control|)
block|{
if|if
condition|(
name|ip_char
index|[
name|idx
index|]
operator|==
literal|'.'
condition|)
block|{
name|arr
index|[
name|cnt
index|]
operator|=
operator|(
name|byte
operator|)
name|Integer
operator|.
name|parseInt
argument_list|(
name|ip
operator|.
name|substring
argument_list|(
name|pos
argument_list|,
name|idx
argument_list|)
argument_list|)
expr_stmt|;
name|cnt
operator|++
expr_stmt|;
name|pos
operator|=
name|idx
operator|+
literal|1
expr_stmt|;
block|}
block|}
name|arr
index|[
name|cnt
index|]
operator|=
operator|(
name|byte
operator|)
name|Integer
operator|.
name|parseInt
argument_list|(
name|ip
operator|.
name|substring
argument_list|(
name|pos
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|arr
return|;
block|}
comment|/**      * Sets the SOCKS server to use. The server will only be used for new      * HTTPConnections created after this call and will not affect currrent      * instances of HTTPConnection. A null or empty string host parameter      * disables SOCKS.<P>      *      * The code will try to determine the SOCKS version to use at connection      * time. This might fail for a number of reasons, however, in which case you      * must specify the version explicitly.      *      * @param host  the host on which the proxy server resides. The port used is      *      the default port 1080.      * @see         #setSocksServer(java.lang.String, int, int)      */
DECL|method|setSocksServer
specifier|public
specifier|static
name|void
name|setSocksServer
parameter_list|(
name|String
name|host
parameter_list|)
block|{
name|setSocksServer
argument_list|(
name|host
argument_list|,
literal|1080
argument_list|)
expr_stmt|;
block|}
comment|/**      * Sets the SOCKS server to use. The server will only be used for new      * HTTPConnections created after this call and will not affect currrent      * instances of HTTPConnection. A null or empty string host parameter      * disables SOCKS.<P>      *      * The code will try to determine the SOCKS version to use at connection      * time. This might fail for a number of reasons, however, in which case you      * must specify the version explicitly.      *      * @param host  the host on which the proxy server resides.      * @param port  the port the proxy server is listening on.      * @see         #setSocksServer(java.lang.String, int, int)      */
DECL|method|setSocksServer
specifier|public
specifier|static
name|void
name|setSocksServer
parameter_list|(
name|String
name|host
parameter_list|,
name|int
name|port
parameter_list|)
block|{
if|if
condition|(
name|port
operator|<=
literal|0
condition|)
block|{
name|port
operator|=
literal|1080
expr_stmt|;
block|}
if|if
condition|(
name|host
operator|==
literal|null
operator|||
name|host
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
block|{
name|Default_Socks_client
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
name|Default_Socks_client
operator|=
operator|new
name|SocksClient
argument_list|(
name|host
argument_list|,
name|port
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Sets the SOCKS server to use. The server will only be used for new      * HTTPConnections created after this call and will not affect currrent      * instances of HTTPConnection. A null or empty string host parameter      * disables SOCKS.<P>      *      * In an application or using the Appletviewer an alternative to this method      * is to set the following properties (either in the properties file or on      * the command line):<var>HTTPClient.socksHost</var> ,<var>      * HTTPClient.socksPort</var> and<var>HTTPClient.socksVersion</var> .      * Whether<var>HTTPClient.socksHost</var> is set or not determines whether      * a SOCKS server is used; if<var>HTTPClient.socksPort</var> is not set it      * defaults to 1080; if<var>HTTPClient.socksVersion</var> is not set an      * attempt will be made to automatically determine the version used by the      * server.<P>      *      * Note: If you have also set a proxy server then a connection will be made      * to the SOCKS server, which in turn then makes a connection to the proxy      * server (possibly via other SOCKS servers), which in turn makes the final      * connection.<P>      *      * If the proxy server is running SOCKS version 5 and requires      * username/password authorization, and you wish to set this authorization      * information in the code, then you may use the<var>      * AuthorizationInfo.addAuthorization()</var> method to do so. Specify the      * same<var>host</var> and<var>port</var> as in this method, give the      *<var>scheme</var> "SOCKS5" and the<var>realm</var> "USER/PASS", set the      *<var>cookie</var> to null and the<var>params</var> to an array      * containing a single<var>NVPair</var> in turn containing the username and      * password. Example:<PRE>      *     NVPair[] up = { new NVPair(username, password) };      *     AuthorizationInfo.addAuthorization(host, port, "SOCKS5", "USER/PASS",      *                                        null, up);      *</PRE> If you have not given any authorization info and the proxy server      * requires authorization then you will be prompted for the necessary info      * via a popup the first time you do a request.      *      * @param host                the host on which the proxy server resides.      * @param port                the port the proxy server is listening on.      * @param version             the SOCKS version the server is running.      *      Currently this must be '4' or '5'.      * @exception SocksException  If<var>version</var> is not '4' or '5'.      */
DECL|method|setSocksServer
specifier|public
specifier|static
name|void
name|setSocksServer
parameter_list|(
name|String
name|host
parameter_list|,
name|int
name|port
parameter_list|,
name|int
name|version
parameter_list|)
throws|throws
name|SocksException
block|{
if|if
condition|(
name|port
operator|<=
literal|0
condition|)
block|{
name|port
operator|=
literal|1080
expr_stmt|;
block|}
if|if
condition|(
name|host
operator|==
literal|null
operator|||
name|host
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
block|{
name|Default_Socks_client
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
name|Default_Socks_client
operator|=
operator|new
name|SocksClient
argument_list|(
name|host
argument_list|,
name|port
argument_list|,
name|version
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Removes the #... part. Returns the stripped name, or "" if either the      *<var>file</var> is null or is the empty string (after stripping).      *      * @param file  the name to strip      * @return      the stripped name      */
DECL|method|stripRef
specifier|private
specifier|final
name|String
name|stripRef
parameter_list|(
name|String
name|file
parameter_list|)
block|{
if|if
condition|(
name|file
operator|==
literal|null
condition|)
block|{
return|return
literal|""
return|;
block|}
name|int
name|hash
init|=
name|file
operator|.
name|indexOf
argument_list|(
literal|'#'
argument_list|)
decl_stmt|;
if|if
condition|(
name|hash
operator|!=
operator|-
literal|1
condition|)
block|{
name|file
operator|=
name|file
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|hash
argument_list|)
expr_stmt|;
block|}
return|return
name|file
operator|.
name|trim
argument_list|()
return|;
block|}
comment|// private helper methods
comment|/**      * Sets up the request, creating the list of headers to send and creating      * instances of the modules. This may be invoked by subclasses which add      * further methods (such as those from DAV and IPP).      *      * @param method               GET, POST, etc.      * @param resource             the resource      * @param headers              an array of headers to be used      * @param entity               the entity (or null)      * @param stream               the output stream (or null) - only one of      *      stream and entity may be non-null      * @return                     the response.      * @exception ModuleException  if an exception is encountered in any module.      * @exception IOException      Description of the Exception      */
DECL|method|setupRequest
specifier|protected
specifier|final
name|HTTPResponse
name|setupRequest
parameter_list|(
name|String
name|method
parameter_list|,
name|String
name|resource
parameter_list|,
name|NVPair
index|[]
name|headers
parameter_list|,
name|byte
index|[]
name|entity
parameter_list|,
name|HttpOutputStream
name|stream
parameter_list|)
throws|throws
name|IOException
throws|,
name|ModuleException
block|{
name|Request
name|req
init|=
operator|new
name|Request
argument_list|(
name|this
argument_list|,
name|method
argument_list|,
name|resource
argument_list|,
name|mergedHeaders
argument_list|(
name|headers
argument_list|)
argument_list|,
name|entity
argument_list|,
name|stream
argument_list|,
name|allowUI
argument_list|)
decl_stmt|;
name|RequestList
operator|.
name|addToEnd
argument_list|(
name|req
argument_list|)
expr_stmt|;
try|try
block|{
name|HTTPResponse
name|resp
init|=
operator|new
name|HTTPResponse
argument_list|(
name|gen_mod_insts
argument_list|()
argument_list|,
name|Timeout
argument_list|,
name|req
argument_list|,
name|defaultIncrement
argument_list|)
decl_stmt|;
name|handleRequest
argument_list|(
name|req
argument_list|,
name|resp
argument_list|,
literal|null
argument_list|,
literal|true
argument_list|)
expr_stmt|;
return|return
name|resp
return|;
block|}
finally|finally
block|{
name|RequestList
operator|.
name|remove
argument_list|(
name|req
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * This merges built-in default headers, user-specified default headers, and      * method-specified headers. Method-specified take precedence over user      * defaults, which take precedence over built-in defaults. The following      * headers are removed if found: "Content-length".      *      * @param spec  the headers specified in the call to the method      * @return      an array consisting of merged headers.      */
DECL|method|mergedHeaders
specifier|private
name|NVPair
index|[]
name|mergedHeaders
parameter_list|(
name|NVPair
index|[]
name|spec
parameter_list|)
block|{
name|int
name|spec_len
init|=
operator|(
name|spec
operator|!=
literal|null
condition|?
name|spec
operator|.
name|length
else|:
literal|0
operator|)
decl_stmt|;
name|int
name|defs_len
decl_stmt|;
name|NVPair
index|[]
name|merged
decl_stmt|;
synchronized|synchronized
init|(
name|DefaultHeaders
init|)
block|{
name|defs_len
operator|=
operator|(
name|DefaultHeaders
operator|!=
literal|null
condition|?
name|DefaultHeaders
operator|.
name|length
else|:
literal|0
operator|)
expr_stmt|;
name|merged
operator|=
operator|new
name|NVPair
index|[
name|spec_len
operator|+
name|defs_len
index|]
expr_stmt|;
comment|// copy default headers
name|System
operator|.
name|arraycopy
argument_list|(
name|DefaultHeaders
argument_list|,
literal|0
argument_list|,
name|merged
argument_list|,
literal|0
argument_list|,
name|defs_len
argument_list|)
expr_stmt|;
block|}
comment|// merge in selected headers
name|int
name|sidx
decl_stmt|;
comment|// merge in selected headers
name|int
name|didx
init|=
name|defs_len
decl_stmt|;
for|for
control|(
name|sidx
operator|=
literal|0
init|;
name|sidx
operator|<
name|spec_len
condition|;
name|sidx
operator|++
control|)
block|{
if|if
condition|(
name|spec
index|[
name|sidx
index|]
operator|==
literal|null
condition|)
block|{
continue|continue;
block|}
name|String
name|s_name
init|=
name|spec
index|[
name|sidx
index|]
operator|.
name|getName
argument_list|()
operator|.
name|trim
argument_list|()
decl_stmt|;
if|if
condition|(
name|s_name
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"Content-length"
argument_list|)
condition|)
block|{
continue|continue;
block|}
name|int
name|search
decl_stmt|;
for|for
control|(
name|search
operator|=
literal|0
init|;
name|search
operator|<
name|didx
condition|;
name|search
operator|++
control|)
block|{
if|if
condition|(
name|merged
index|[
name|search
index|]
operator|.
name|getName
argument_list|()
operator|.
name|trim
argument_list|()
operator|.
name|equalsIgnoreCase
argument_list|(
name|s_name
argument_list|)
condition|)
block|{
break|break;
block|}
block|}
name|merged
index|[
name|search
index|]
operator|=
name|spec
index|[
name|sidx
index|]
expr_stmt|;
if|if
condition|(
name|search
operator|==
name|didx
condition|)
block|{
name|didx
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|didx
operator|<
name|merged
operator|.
name|length
condition|)
block|{
name|merged
operator|=
name|Util
operator|.
name|resizeArray
argument_list|(
name|merged
argument_list|,
name|didx
argument_list|)
expr_stmt|;
block|}
return|return
name|merged
return|;
block|}
comment|/**      * Generate an array of instances of the current modules.      *      * @return   Description of the Return Value      */
DECL|method|gen_mod_insts
specifier|private
name|HTTPClientModule
index|[]
name|gen_mod_insts
parameter_list|()
block|{
synchronized|synchronized
init|(
name|ModuleList
init|)
block|{
name|HTTPClientModule
index|[]
name|mod_insts
init|=
operator|new
name|HTTPClientModule
index|[
name|ModuleList
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
for|for
control|(
name|int
name|idx
init|=
literal|0
init|;
name|idx
operator|<
name|ModuleList
operator|.
name|size
argument_list|()
condition|;
name|idx
operator|++
control|)
block|{
name|Class
name|mod
init|=
operator|(
name|Class
operator|)
name|ModuleList
operator|.
name|elementAt
argument_list|(
name|idx
argument_list|)
decl_stmt|;
try|try
block|{
name|mod_insts
index|[
name|idx
index|]
operator|=
operator|(
name|HTTPClientModule
operator|)
name|mod
operator|.
name|newInstance
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|Error
argument_list|(
literal|"HTTPClient Internal Error: could not "
operator|+
literal|"create instance of "
operator|+
name|mod
operator|.
name|getName
argument_list|()
operator|+
literal|" -\n"
operator|+
name|e
argument_list|)
throw|;
block|}
block|}
return|return
name|mod_insts
return|;
block|}
block|}
comment|/**      * handles the Request. First the request handler for each module is is      * invoked, and then if no response was generated the request is sent.      *      * @param req                  the Request      * @param http_resp            the HTTPResponse      * @param resp                 the Response      * @param usemodules           if false then skip module loop      * @exception IOException      if any module or sendRequest throws it      * @exception ModuleException  if any module throws it      */
DECL|method|handleRequest
name|void
name|handleRequest
parameter_list|(
name|Request
name|req
parameter_list|,
name|HTTPResponse
name|http_resp
parameter_list|,
name|Response
name|resp
parameter_list|,
name|boolean
name|usemodules
parameter_list|)
throws|throws
name|IOException
throws|,
name|ModuleException
block|{
name|Response
index|[]
name|rsp_arr
init|=
block|{
name|resp
block|}
decl_stmt|;
name|HTTPClientModule
index|[]
name|modules
init|=
name|http_resp
operator|.
name|getModules
argument_list|()
decl_stmt|;
comment|// invoke requestHandler for each module
if|if
condition|(
name|usemodules
condition|)
block|{
name|doModules
label|:
for|for
control|(
name|int
name|idx
init|=
literal|0
init|;
name|idx
operator|<
name|modules
operator|.
name|length
condition|;
name|idx
operator|++
control|)
block|{
name|int
name|sts
init|=
name|modules
index|[
name|idx
index|]
operator|.
name|requestHandler
argument_list|(
name|req
argument_list|,
name|rsp_arr
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|sts
condition|)
block|{
case|case
name|REQ_CONTINUE
case|:
comment|// continue processing
break|break;
case|case
name|REQ_RESTART
case|:
comment|// restart processing with first module
name|idx
operator|=
operator|-
literal|1
expr_stmt|;
continue|continue
name|doModules
continue|;
case|case
name|REQ_SHORTCIRC
case|:
comment|// stop processing and send
break|break
name|doModules
break|;
case|case
name|REQ_RESPONSE
case|:
comment|// go to phase 2
case|case
name|REQ_RETURN
case|:
comment|// return response immediately
if|if
condition|(
name|rsp_arr
index|[
literal|0
index|]
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|Error
argument_list|(
literal|"HTTPClient Internal Error: no "
operator|+
literal|"response returned by module "
operator|+
name|modules
index|[
name|idx
index|]
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
throw|;
block|}
name|http_resp
operator|.
name|set
argument_list|(
name|req
argument_list|,
name|rsp_arr
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|req
operator|.
name|getStream
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|req
operator|.
name|getStream
argument_list|()
operator|.
name|ignoreData
argument_list|(
name|req
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|req
operator|.
name|internal_subrequest
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|sts
operator|==
name|REQ_RESPONSE
condition|)
block|{
name|http_resp
operator|.
name|handleResponse
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|http_resp
operator|.
name|init
argument_list|(
name|rsp_arr
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
return|return;
case|case
name|REQ_NEWCON_RST
case|:
comment|// new connection
if|if
condition|(
name|req
operator|.
name|internal_subrequest
condition|)
block|{
return|return;
block|}
name|req
operator|.
name|getConnection
argument_list|()
operator|.
name|handleRequest
argument_list|(
name|req
argument_list|,
name|http_resp
argument_list|,
name|rsp_arr
index|[
literal|0
index|]
argument_list|,
literal|true
argument_list|)
expr_stmt|;
return|return;
case|case
name|REQ_NEWCON_SND
case|:
comment|// new connection, send immediately
if|if
condition|(
name|req
operator|.
name|internal_subrequest
condition|)
block|{
return|return;
block|}
name|req
operator|.
name|getConnection
argument_list|()
operator|.
name|handleRequest
argument_list|(
name|req
argument_list|,
name|http_resp
argument_list|,
name|rsp_arr
index|[
literal|0
index|]
argument_list|,
literal|false
argument_list|)
expr_stmt|;
return|return;
default|default:
comment|// not valid
throw|throw
operator|new
name|Error
argument_list|(
literal|"HTTPClient Internal Error: invalid status"
operator|+
literal|" "
operator|+
name|sts
operator|+
literal|" returned by module "
operator|+
name|modules
index|[
name|idx
index|]
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
throw|;
block|}
block|}
block|}
if|if
condition|(
name|req
operator|.
name|internal_subrequest
condition|)
block|{
return|return;
block|}
comment|// Send the request across the wire
if|if
condition|(
name|req
operator|.
name|getStream
argument_list|()
operator|!=
literal|null
operator|&&
name|req
operator|.
name|getStream
argument_list|()
operator|.
name|getLength
argument_list|()
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|ServProtVersKnown
operator|||
name|ServerProtocolVersion
operator|<
name|HTTP_1_1
operator|||
name|no_chunked
condition|)
block|{
name|req
operator|.
name|getStream
argument_list|()
operator|.
name|goAhead
argument_list|(
name|req
argument_list|,
literal|null
argument_list|,
name|http_resp
operator|.
name|getTimeout
argument_list|()
argument_list|)
expr_stmt|;
name|http_resp
operator|.
name|set
argument_list|(
name|req
argument_list|,
name|req
operator|.
name|getStream
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// add Transfer-Encoding header if necessary
name|int
name|idx
decl_stmt|;
name|NVPair
index|[]
name|hdrs
init|=
name|req
operator|.
name|getHeaders
argument_list|()
decl_stmt|;
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|hdrs
operator|.
name|length
condition|;
name|idx
operator|++
control|)
block|{
if|if
condition|(
name|hdrs
index|[
name|idx
index|]
operator|.
name|getName
argument_list|()
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"Transfer-Encoding"
argument_list|)
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
name|idx
operator|==
name|hdrs
operator|.
name|length
condition|)
block|{
name|hdrs
operator|=
name|Util
operator|.
name|resizeArray
argument_list|(
name|hdrs
argument_list|,
name|idx
operator|+
literal|1
argument_list|)
expr_stmt|;
name|hdrs
index|[
name|idx
index|]
operator|=
operator|new
name|NVPair
argument_list|(
literal|"Transfer-Encoding"
argument_list|,
literal|"chunked"
argument_list|)
expr_stmt|;
name|req
operator|.
name|setHeaders
argument_list|(
name|hdrs
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|String
name|v
init|=
name|hdrs
index|[
name|idx
index|]
operator|.
name|getValue
argument_list|()
decl_stmt|;
try|try
block|{
if|if
condition|(
operator|!
name|Util
operator|.
name|hasToken
argument_list|(
name|v
argument_list|,
literal|"chunked"
argument_list|)
condition|)
block|{
name|hdrs
index|[
name|idx
index|]
operator|=
operator|new
name|NVPair
argument_list|(
literal|"Transfer-Encoding"
argument_list|,
name|v
operator|+
literal|", chunked"
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|ParseException
name|pe
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|pe
operator|.
name|toString
argument_list|()
argument_list|)
throw|;
block|}
block|}
name|http_resp
operator|.
name|set
argument_list|(
name|req
argument_list|,
name|sendRequest
argument_list|(
name|req
argument_list|,
name|http_resp
operator|.
name|getTimeout
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|http_resp
operator|.
name|set
argument_list|(
name|req
argument_list|,
name|sendRequest
argument_list|(
name|req
argument_list|,
name|http_resp
operator|.
name|getTimeout
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|req
operator|.
name|aborted
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Request aborted by user"
argument_list|)
throw|;
block|}
block|}
comment|/**      * These mark the response to stall the next request on, if any      */
DECL|field|early_stall
specifier|private
specifier|volatile
name|Response
name|early_stall
init|=
literal|null
decl_stmt|;
DECL|field|late_stall
specifier|private
specifier|volatile
name|Response
name|late_stall
init|=
literal|null
decl_stmt|;
DECL|field|prev_resp
specifier|private
specifier|volatile
name|Response
name|prev_resp
init|=
literal|null
decl_stmt|;
comment|/**      * This marks the socket output stream as still being used      */
DECL|field|output_finished
specifier|private
name|boolean
name|output_finished
init|=
literal|true
decl_stmt|;
comment|/**      * sends the request over the line.      *      * @param req                  the request      * @param con_timeout          the timeout to use when establishing a socket      *      connection; an InterruptedIOException is thrown if the procedure      *      times out.      * @return                     Description of the Return Value      * @exception IOException      if thrown by the socket      * @exception ModuleException  if any module throws it during the SSL-      *      tunneling handshake      */
DECL|method|sendRequest
name|Response
name|sendRequest
parameter_list|(
name|Request
name|req
parameter_list|,
name|int
name|con_timeout
parameter_list|)
throws|throws
name|IOException
throws|,
name|ModuleException
block|{
name|ByteArrayOutputStream
name|hdr_buf
init|=
operator|new
name|ByteArrayOutputStream
argument_list|(
literal|600
argument_list|)
decl_stmt|;
name|Response
name|resp
init|=
literal|null
decl_stmt|;
name|boolean
name|keep_alive
decl_stmt|;
comment|// The very first request is special in that we need its response
comment|// before any further requests may be made. This is to set things
comment|// like the server version.
if|if
condition|(
name|early_stall
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|Log
operator|.
name|write
argument_list|(
name|Log
operator|.
name|CONN
argument_list|,
literal|"Conn:  Early-stalling Request: "
operator|+
name|req
operator|.
name|getMethod
argument_list|()
operator|+
literal|" "
operator|+
name|req
operator|.
name|getRequestURI
argument_list|()
argument_list|)
expr_stmt|;
synchronized|synchronized
init|(
name|early_stall
init|)
block|{
comment|// wait till the response is received
try|try
block|{
name|early_stall
operator|.
name|getVersion
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{                     }
name|early_stall
operator|=
literal|null
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|NullPointerException
name|npe
parameter_list|)
block|{             }
block|}
name|String
index|[]
name|con_hdrs
init|=
name|assembleHeaders
argument_list|(
name|req
argument_list|,
name|hdr_buf
argument_list|)
decl_stmt|;
comment|// determine if the connection should be kept alive after this
comment|// request
try|try
block|{
if|if
condition|(
name|ServerProtocolVersion
operator|>=
name|HTTP_1_1
operator|&&
operator|!
name|Util
operator|.
name|hasToken
argument_list|(
name|con_hdrs
index|[
literal|0
index|]
argument_list|,
literal|"close"
argument_list|)
operator|||
name|ServerProtocolVersion
operator|==
name|HTTP_1_0
operator|&&
name|Util
operator|.
name|hasToken
argument_list|(
name|con_hdrs
index|[
literal|0
index|]
argument_list|,
literal|"keep-alive"
argument_list|)
condition|)
block|{
name|keep_alive
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|keep_alive
operator|=
literal|false
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|ParseException
name|pe
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|pe
operator|.
name|toString
argument_list|()
argument_list|)
throw|;
block|}
synchronized|synchronized
init|(
name|this
init|)
block|{
comment|// Sometimes we must stall the pipeline until the previous request
comment|// has been answered. However, if we are going to open up a new
comment|// connection anyway we don't really need to stall.
if|if
condition|(
name|late_stall
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|input_demux
operator|!=
literal|null
operator|||
name|keepAliveUnknown
condition|)
block|{
name|Log
operator|.
name|write
argument_list|(
name|Log
operator|.
name|CONN
argument_list|,
literal|"Conn:  Stalling Request: "
operator|+
name|req
operator|.
name|getMethod
argument_list|()
operator|+
literal|" "
operator|+
name|req
operator|.
name|getRequestURI
argument_list|()
argument_list|)
expr_stmt|;
try|try
block|{
comment|// wait till the response is received
name|late_stall
operator|.
name|getVersion
argument_list|()
expr_stmt|;
if|if
condition|(
name|keepAliveUnknown
condition|)
block|{
name|determineKeepAlive
argument_list|(
name|late_stall
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{                     }
block|}
name|late_stall
operator|=
literal|null
expr_stmt|;
block|}
comment|/*              *  POSTs must not be pipelined because of problems if the connection              *  is aborted. Since it is generally impossible to know what urls              *  POST will influence it is impossible to determine if a sequence              *  of requests containing a POST is idempotent.              *  Also, for retried requests we don't want to pipeline either.              */
if|if
condition|(
operator|(
name|req
operator|.
name|getMethod
argument_list|()
operator|.
name|equals
argument_list|(
literal|"POST"
argument_list|)
operator|||
name|req
operator|.
name|dont_pipeline
operator|)
operator|&&
name|prev_resp
operator|!=
literal|null
operator|&&
name|input_demux
operator|!=
literal|null
condition|)
block|{
name|Log
operator|.
name|write
argument_list|(
name|Log
operator|.
name|CONN
argument_list|,
literal|"Conn:  Stalling Request: "
operator|+
name|req
operator|.
name|getMethod
argument_list|()
operator|+
literal|" "
operator|+
name|req
operator|.
name|getRequestURI
argument_list|()
argument_list|)
expr_stmt|;
try|try
block|{
comment|// wait till the response is received
name|prev_resp
operator|.
name|getVersion
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{                 }
block|}
comment|// If the previous request used an output stream, then wait till
comment|// all the data has been written
if|if
condition|(
operator|!
name|output_finished
condition|)
block|{
try|try
block|{
name|wait
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|ie
operator|.
name|toString
argument_list|()
argument_list|)
throw|;
block|}
block|}
if|if
condition|(
name|req
operator|.
name|aborted
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Request aborted by user"
argument_list|)
throw|;
block|}
name|int
name|try_count
init|=
literal|3
decl_stmt|;
comment|/*              *  what a hack! This is to handle the case where the server closes              *  the connection but we don't realize it until we try to send              *  something. The problem is that we only get IOException, but              *  we need a finer specification (i.e. whether it's an EPIPE or              *  something else); I don't trust relying on the message part              *  of IOException (which on SunOS/Solaris gives 'Broken pipe',              *  but what on Windoze/Mac?).              */
while|while
condition|(
name|try_count
operator|--
operator|>
literal|0
condition|)
block|{
try|try
block|{
comment|// get a client socket
name|Socket
name|sock
decl_stmt|;
if|if
condition|(
name|input_demux
operator|==
literal|null
operator|||
operator|(
name|sock
operator|=
name|input_demux
operator|.
name|getSocket
argument_list|()
operator|)
operator|==
literal|null
condition|)
block|{
name|sock
operator|=
name|getSocket
argument_list|(
name|con_timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|Protocol
operator|==
name|HTTPS
condition|)
block|{
if|if
condition|(
name|Proxy_Host
operator|!=
literal|null
condition|)
block|{
name|Socket
index|[]
name|sarr
init|=
block|{
name|sock
block|}
decl_stmt|;
name|resp
operator|=
name|enableSSLTunneling
argument_list|(
name|sarr
argument_list|,
name|req
argument_list|,
name|con_timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|resp
operator|!=
literal|null
condition|)
block|{
name|resp
operator|.
name|final_resp
operator|=
literal|true
expr_stmt|;
return|return
name|resp
return|;
block|}
name|sock
operator|=
name|sarr
index|[
literal|0
index|]
expr_stmt|;
block|}
name|sock
operator|.
name|setSoTimeout
argument_list|(
name|con_timeout
argument_list|)
expr_stmt|;
comment|//sock = new SSLSocket(sock);
block|}
name|input_demux
operator|=
operator|new
name|StreamDemultiplexor
argument_list|(
name|Protocol
argument_list|,
name|sock
argument_list|,
name|this
argument_list|)
expr_stmt|;
name|DemuxList
operator|.
name|addToEnd
argument_list|(
name|input_demux
argument_list|)
expr_stmt|;
name|keepAliveReqLeft
operator|=
name|keepAliveReqMax
expr_stmt|;
block|}
if|if
condition|(
name|req
operator|.
name|aborted
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Request aborted by user"
argument_list|)
throw|;
block|}
name|Log
operator|.
name|write
argument_list|(
name|Log
operator|.
name|CONN
argument_list|,
literal|"Conn:  Sending Request: "
argument_list|,
name|hdr_buf
argument_list|)
expr_stmt|;
comment|// Send headers
name|OutputStream
name|sock_out
init|=
name|sock
operator|.
name|getOutputStream
argument_list|()
decl_stmt|;
if|if
condition|(
name|haveMSLargeWritesBug
condition|)
block|{
name|sock_out
operator|=
operator|new
name|MSLargeWritesBugStream
argument_list|(
name|sock_out
argument_list|)
expr_stmt|;
block|}
name|hdr_buf
operator|.
name|writeTo
argument_list|(
name|sock_out
argument_list|)
expr_stmt|;
comment|// Wait for "100 Continue" status if necessary
try|try
block|{
if|if
condition|(
name|ServProtVersKnown
operator|&&
name|ServerProtocolVersion
operator|>=
name|HTTP_1_1
operator|&&
name|Util
operator|.
name|hasToken
argument_list|(
name|con_hdrs
index|[
literal|1
index|]
argument_list|,
literal|"100-continue"
argument_list|)
condition|)
block|{
name|resp
operator|=
operator|new
name|Response
argument_list|(
name|req
argument_list|,
operator|(
name|Proxy_Host
operator|!=
literal|null
operator|&&
name|Protocol
operator|!=
name|HTTPS
operator|)
argument_list|,
name|input_demux
argument_list|)
expr_stmt|;
name|resp
operator|.
name|timeout
operator|=
literal|60
expr_stmt|;
if|if
condition|(
name|resp
operator|.
name|getContinue
argument_list|()
operator|!=
literal|100
condition|)
block|{
break|break;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|ParseException
name|pe
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|pe
operator|.
name|toString
argument_list|()
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|InterruptedIOException
name|iioe
parameter_list|)
block|{                     }
finally|finally
block|{
if|if
condition|(
name|resp
operator|!=
literal|null
condition|)
block|{
name|resp
operator|.
name|timeout
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|// POST/PUT data
if|if
condition|(
name|req
operator|.
name|getData
argument_list|()
operator|!=
literal|null
operator|&&
name|req
operator|.
name|getData
argument_list|()
operator|.
name|length
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|req
operator|.
name|delay_entity
operator|>
literal|0
condition|)
block|{
comment|// wait for something on the network; check available()
comment|// roughly every 100 ms
name|long
name|num_units
init|=
name|req
operator|.
name|delay_entity
operator|/
literal|100
decl_stmt|;
name|long
name|one_unit
init|=
name|req
operator|.
name|delay_entity
operator|/
name|num_units
decl_stmt|;
for|for
control|(
name|int
name|idx
init|=
literal|0
init|;
name|idx
operator|<
name|num_units
condition|;
name|idx
operator|++
control|)
block|{
if|if
condition|(
name|input_demux
operator|.
name|available
argument_list|(
literal|null
argument_list|)
operator|!=
literal|0
condition|)
block|{
break|break;
block|}
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
name|one_unit
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{                                 }
block|}
if|if
condition|(
name|input_demux
operator|.
name|available
argument_list|(
literal|null
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sock_out
operator|.
name|write
argument_list|(
name|req
operator|.
name|getData
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// he's still waiting
else|else
block|{
name|keep_alive
operator|=
literal|false
expr_stmt|;
block|}
comment|// Uh oh!
block|}
else|else
block|{
name|sock_out
operator|.
name|write
argument_list|(
name|req
operator|.
name|getData
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|req
operator|.
name|getStream
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|req
operator|.
name|getStream
argument_list|()
operator|.
name|goAhead
argument_list|(
name|req
argument_list|,
name|sock_out
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sock_out
operator|.
name|flush
argument_list|()
expr_stmt|;
block|}
comment|// get a new response.
comment|// Note: this does not do a read on the socket.
if|if
condition|(
name|resp
operator|==
literal|null
condition|)
block|{
name|resp
operator|=
operator|new
name|Response
argument_list|(
name|req
argument_list|,
operator|(
name|Proxy_Host
operator|!=
literal|null
operator|&&
name|Protocol
operator|!=
name|HTTPS
operator|)
argument_list|,
name|input_demux
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|Log
operator|.
name|write
argument_list|(
name|Log
operator|.
name|CONN
argument_list|,
literal|"Conn:  "
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
name|closeDemux
argument_list|(
name|ioe
argument_list|,
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|try_count
operator|==
literal|0
operator|||
name|ioe
operator|instanceof
name|UnknownHostException
operator|||
name|ioe
operator|instanceof
name|ConnectException
operator|||
name|ioe
operator|instanceof
name|NoRouteToHostException
operator|||
name|ioe
operator|instanceof
name|InterruptedIOException
operator|||
name|req
operator|.
name|aborted
condition|)
block|{
throw|throw
name|ioe
throw|;
block|}
name|Log
operator|.
name|write
argument_list|(
name|Log
operator|.
name|CONN
argument_list|,
literal|"Conn:  Retrying request"
argument_list|)
expr_stmt|;
continue|continue;
block|}
break|break;
block|}
name|prev_resp
operator|=
name|resp
expr_stmt|;
comment|// close the stream after this response if necessary
if|if
condition|(
operator|(
operator|!
name|keepAliveUnknown
operator|&&
operator|!
name|doesKeepAlive
operator|)
operator|||
operator|!
name|keep_alive
operator|||
operator|(
name|keepAliveReqMax
operator|!=
operator|-
literal|1
operator|&&
name|keepAliveReqLeft
operator|--
operator|==
literal|0
operator|)
condition|)
block|{
name|input_demux
operator|.
name|markForClose
argument_list|(
name|resp
argument_list|)
expr_stmt|;
name|input_demux
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
name|input_demux
operator|.
name|restartTimer
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|keepAliveReqMax
operator|!=
operator|-
literal|1
condition|)
block|{
name|Log
operator|.
name|write
argument_list|(
name|Log
operator|.
name|CONN
argument_list|,
literal|"Conn:  Number of requests left: "
operator|+
name|keepAliveReqLeft
argument_list|)
expr_stmt|;
block|}
comment|/*              *  We don't pipeline the first request, as we need some info              *  about the server (such as which http version it complies with)              */
if|if
condition|(
operator|!
name|ServProtVersKnown
condition|)
block|{
name|early_stall
operator|=
name|resp
expr_stmt|;
name|resp
operator|.
name|markAsFirstResponse
argument_list|(
name|req
argument_list|)
expr_stmt|;
block|}
comment|/*              *  Also don't pipeline until we know if the server supports              *  keep-alive's or not.              *  Note: strictly speaking, HTTP/1.0 keep-alives don't mean we can              *  pipeline requests. I seem to remember some (beta?) version              *  of Netscape's Enterprise server which barfed if you tried              *  push requests down it's throat w/o waiting for the previous              *  response first. However, I've not been able to find such a              *  server lately, and so I'm taking the risk and assuming we              *  can in fact pipeline requests to HTTP/1.0 servers.              */
if|if
condition|(
name|keepAliveUnknown
operator|||
comment|// We don't pipeline POST's ...
operator|!
name|IdempotentSequence
operator|.
name|methodIsIdempotent
argument_list|(
name|req
operator|.
name|getMethod
argument_list|()
argument_list|)
operator|||
name|req
operator|.
name|dont_pipeline
operator|||
comment|// Retries disable pipelining too
name|neverPipeline
condition|)
block|{
comment|// Emergency measure: prevent all pipelining
name|late_stall
operator|=
name|resp
expr_stmt|;
block|}
comment|/*              *  If there is an output stream then just tell the other threads to              *  wait; the stream will notify() when it's done. If there isn't any              *  stream then wake up a waiting thread (if any).              */
if|if
condition|(
name|req
operator|.
name|getStream
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|output_finished
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
name|output_finished
operator|=
literal|true
expr_stmt|;
name|notify
argument_list|()
expr_stmt|;
block|}
comment|// Looks like were finally done
name|Log
operator|.
name|write
argument_list|(
name|Log
operator|.
name|CONN
argument_list|,
literal|"Conn:  Request sent"
argument_list|)
expr_stmt|;
block|}
return|return
name|resp
return|;
block|}
comment|/**      * Gets a socket. Creates a socket to the proxy if set, or else to the      * actual destination.      *      * @param con_timeout      if not 0 then start a new thread to establish the      *      the connection and join(con_timeout) it. If the join() times out an      *      InteruptedIOException is thrown.      * @return                 The socket value      * @exception IOException  Description of the Exception      */
DECL|method|getSocket
specifier|private
name|Socket
name|getSocket
parameter_list|(
name|int
name|con_timeout
parameter_list|)
throws|throws
name|IOException
block|{
name|Socket
name|sock
init|=
literal|null
decl_stmt|;
name|String
name|actual_host
decl_stmt|;
name|int
name|actual_port
decl_stmt|;
if|if
condition|(
name|Proxy_Host
operator|!=
literal|null
condition|)
block|{
name|actual_host
operator|=
name|Proxy_Host
expr_stmt|;
name|actual_port
operator|=
name|Proxy_Port
expr_stmt|;
block|}
else|else
block|{
name|actual_host
operator|=
name|Host
expr_stmt|;
name|actual_port
operator|=
name|Port
expr_stmt|;
block|}
name|Log
operator|.
name|write
argument_list|(
name|Log
operator|.
name|CONN
argument_list|,
literal|"Conn:  Creating Socket: "
operator|+
name|actual_host
operator|+
literal|":"
operator|+
name|actual_port
argument_list|)
expr_stmt|;
if|if
condition|(
name|con_timeout
operator|==
literal|0
condition|)
block|{
comment|// normal connection establishment
if|if
condition|(
name|Socks_client
operator|!=
literal|null
condition|)
block|{
name|sock
operator|=
name|Socks_client
operator|.
name|getSocket
argument_list|(
name|actual_host
argument_list|,
name|actual_port
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// try all A records
name|InetAddress
index|[]
name|addr_list
init|=
name|InetAddress
operator|.
name|getAllByName
argument_list|(
name|actual_host
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|idx
init|=
literal|0
init|;
name|idx
operator|<
name|addr_list
operator|.
name|length
condition|;
name|idx
operator|++
control|)
block|{
try|try
block|{
if|if
condition|(
name|LocalAddr
operator|==
literal|null
condition|)
block|{
name|sock
operator|=
operator|new
name|Socket
argument_list|(
name|addr_list
index|[
name|idx
index|]
argument_list|,
name|actual_port
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sock
operator|=
operator|new
name|Socket
argument_list|(
name|addr_list
index|[
name|idx
index|]
argument_list|,
name|actual_port
argument_list|,
name|LocalAddr
argument_list|,
name|LocalPort
argument_list|)
expr_stmt|;
block|}
break|break;
comment|// success
block|}
catch|catch
parameter_list|(
name|SocketException
name|se
parameter_list|)
block|{
if|if
condition|(
name|idx
operator|==
name|addr_list
operator|.
name|length
operator|-
literal|1
condition|)
block|{
throw|throw
name|se
throw|;
block|}
comment|// we tried them all
block|}
block|}
block|}
block|}
else|else
block|{
name|EstablishConnection
name|con
init|=
operator|new
name|EstablishConnection
argument_list|(
name|actual_host
argument_list|,
name|actual_port
argument_list|,
name|Socks_client
argument_list|)
decl_stmt|;
name|con
operator|.
name|start
argument_list|()
expr_stmt|;
try|try
block|{
name|con
operator|.
name|join
argument_list|(
operator|(
name|long
operator|)
name|con_timeout
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{             }
if|if
condition|(
name|con
operator|.
name|getException
argument_list|()
operator|!=
literal|null
condition|)
block|{
throw|throw
name|con
operator|.
name|getException
argument_list|()
throw|;
block|}
if|if
condition|(
operator|(
name|sock
operator|=
name|con
operator|.
name|getSocket
argument_list|()
operator|)
operator|==
literal|null
condition|)
block|{
name|con
operator|.
name|forget
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|sock
operator|=
name|con
operator|.
name|getSocket
argument_list|()
operator|)
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|InterruptedIOException
argument_list|(
literal|"Connection establishment timed out"
argument_list|)
throw|;
block|}
block|}
block|}
return|return
name|sock
return|;
block|}
comment|/**      * Enable SSL Tunneling if we're talking to a proxy. See ietf draft      * draft-luotonen-ssl-tunneling-03 for more info.      *      * @param sock                 the socket      * @param req                  the request initiating this connection      * @param timeout              the timeout      * @return                     the proxy's last response if unsuccessful, or      *      null if tunnel successfuly established      * @exception IOException      * @exception ModuleException      */
DECL|method|enableSSLTunneling
specifier|private
name|Response
name|enableSSLTunneling
parameter_list|(
name|Socket
index|[]
name|sock
parameter_list|,
name|Request
name|req
parameter_list|,
name|int
name|timeout
parameter_list|)
throws|throws
name|IOException
throws|,
name|ModuleException
block|{
comment|// copy User-Agent and Proxy-Auth headers from request
name|Vector
name|hdrs
init|=
operator|new
name|Vector
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|idx
init|=
literal|0
init|;
name|idx
operator|<
name|req
operator|.
name|getHeaders
argument_list|()
operator|.
name|length
condition|;
name|idx
operator|++
control|)
block|{
name|String
name|name
init|=
name|req
operator|.
name|getHeaders
argument_list|()
index|[
name|idx
index|]
operator|.
name|getName
argument_list|()
decl_stmt|;
if|if
condition|(
name|name
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"User-Agent"
argument_list|)
operator|||
name|name
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"Proxy-Authorization"
argument_list|)
condition|)
block|{
name|hdrs
operator|.
name|addElement
argument_list|(
name|req
operator|.
name|getHeaders
argument_list|()
index|[
name|idx
index|]
argument_list|)
expr_stmt|;
block|}
block|}
comment|// create initial CONNECT subrequest
name|NVPair
index|[]
name|h
init|=
operator|new
name|NVPair
index|[
name|hdrs
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
name|hdrs
operator|.
name|copyInto
argument_list|(
name|h
argument_list|)
expr_stmt|;
name|Request
name|connect
init|=
operator|new
name|Request
argument_list|(
name|this
argument_list|,
literal|"CONNECT"
argument_list|,
name|Host
operator|+
literal|":"
operator|+
name|Port
argument_list|,
name|h
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
name|req
operator|.
name|allowUI
argument_list|()
argument_list|)
decl_stmt|;
name|connect
operator|.
name|internal_subrequest
operator|=
literal|true
expr_stmt|;
name|ByteArrayOutputStream
name|hdr_buf
init|=
operator|new
name|ByteArrayOutputStream
argument_list|(
literal|600
argument_list|)
decl_stmt|;
name|HTTPResponse
name|r
init|=
operator|new
name|HTTPResponse
argument_list|(
name|gen_mod_insts
argument_list|()
argument_list|,
name|timeout
argument_list|,
name|connect
argument_list|,
name|defaultIncrement
argument_list|)
decl_stmt|;
comment|// send and handle CONNECT request until successful or tired
name|Response
name|resp
init|=
literal|null
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|handleRequest
argument_list|(
name|connect
argument_list|,
name|r
argument_list|,
name|resp
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|hdr_buf
operator|.
name|reset
argument_list|()
expr_stmt|;
name|assembleHeaders
argument_list|(
name|connect
argument_list|,
name|hdr_buf
argument_list|)
expr_stmt|;
name|Log
operator|.
name|write
argument_list|(
name|Log
operator|.
name|CONN
argument_list|,
literal|"Conn:  Sending SSL-Tunneling Subrequest: "
argument_list|,
name|hdr_buf
argument_list|)
expr_stmt|;
comment|// send CONNECT
name|hdr_buf
operator|.
name|writeTo
argument_list|(
name|sock
index|[
literal|0
index|]
operator|.
name|getOutputStream
argument_list|()
argument_list|)
expr_stmt|;
comment|// return if successful
name|resp
operator|=
operator|new
name|Response
argument_list|(
name|connect
argument_list|,
name|sock
index|[
literal|0
index|]
operator|.
name|getInputStream
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|resp
operator|.
name|getStatusCode
argument_list|()
operator|==
literal|200
condition|)
block|{
return|return
literal|null
return|;
block|}
comment|// failed!
comment|// make life easy: read data and close socket
try|try
block|{
name|resp
operator|.
name|getData
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{             }
try|try
block|{
name|sock
index|[
literal|0
index|]
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{             }
comment|// handle response
name|r
operator|.
name|set
argument_list|(
name|connect
argument_list|,
name|resp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|r
operator|.
name|handleResponse
argument_list|()
condition|)
block|{
return|return
name|resp
return|;
block|}
name|sock
index|[
literal|0
index|]
operator|=
name|getSocket
argument_list|(
name|timeout
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * This writes out the headers on the<var>hdr_buf</var> . It takes special      * precautions for the following headers:<DL><DT>Content-type<DI>This is      * only written if the request has an entity. If the request has an entity      * and no content-type header was given for the request it defaults to      * "application/octet-stream"<DT>Content-length<DI>This header is generated      * if the request has an entity and the entity isn't being sent with the      * Transfer-Encoding "chunked".<DT>User-Agent<DI>If not present it will be      * generated with the current HTTPClient version strings. Otherwise the      * version string is appended to the given User-Agent string.<DT>Connection      *<DI>This header is only written if no proxy is used. If no connection      * header is specified and the server is not known to understand HTTP/1.1 or      * later then a "Connection: keep-alive" header is generated.<DT>      * Proxy-Connection<DI>This header is only written if a proxy is used. If no      * connection header is specified and the proxy is not known to understand      * HTTP/1.1 or later then a "Proxy-Connection: keep-alive" header is      * generated.<DT>Keep-Alive<DI>This header is only written if the      * Connection or Proxy-Connection header contains the Keep-Alive token.<DT>      * Expect<DI>If there is no entity and this header contains the      * "100-continue" token then this token is removed. before writing the      * header.<DT>TE<DI>If this header does not exist, it is created; else if      * the "trailers" token is not specified this token is added; else the      * header is not touched.</DL> Furthermore, it escapes various characters      * in request-URI.      *      * @param req              the Request      * @param hdr_buf          the buffer onto which to write the headers      * @return                 an array of headers; the first element contains      *      the the value of the Connection or Proxy-Connectin header, the      *      second element the value of the Expect header.      * @exception IOException  if writing on<var>hdr_buf</var> generates an an      *      IOException, or if an error occurs during parsing of a header      */
DECL|method|assembleHeaders
specifier|private
name|String
index|[]
name|assembleHeaders
parameter_list|(
name|Request
name|req
parameter_list|,
name|ByteArrayOutputStream
name|hdr_buf
parameter_list|)
throws|throws
name|IOException
block|{
name|DataOutputStream
name|dataout
init|=
operator|new
name|DataOutputStream
argument_list|(
name|hdr_buf
argument_list|)
decl_stmt|;
name|String
index|[]
name|con_hdrs
init|=
block|{
literal|""
block|,
literal|""
block|}
decl_stmt|;
name|NVPair
index|[]
name|hdrs
init|=
name|req
operator|.
name|getHeaders
argument_list|()
decl_stmt|;
comment|// remember various headers
name|int
name|ho_idx
init|=
operator|-
literal|1
decl_stmt|;
comment|// remember various headers
name|int
name|ct_idx
init|=
operator|-
literal|1
decl_stmt|;
comment|// remember various headers
name|int
name|ua_idx
init|=
operator|-
literal|1
decl_stmt|;
comment|// remember various headers
name|int
name|co_idx
init|=
operator|-
literal|1
decl_stmt|;
comment|// remember various headers
name|int
name|pc_idx
init|=
operator|-
literal|1
decl_stmt|;
comment|// remember various headers
name|int
name|ka_idx
init|=
operator|-
literal|1
decl_stmt|;
comment|// remember various headers
name|int
name|ex_idx
init|=
operator|-
literal|1
decl_stmt|;
comment|// remember various headers
name|int
name|te_idx
init|=
operator|-
literal|1
decl_stmt|;
comment|// remember various headers
name|int
name|tc_idx
init|=
operator|-
literal|1
decl_stmt|;
comment|// remember various headers
name|int
name|ug_idx
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|int
name|idx
init|=
literal|0
init|;
name|idx
operator|<
name|hdrs
operator|.
name|length
condition|;
name|idx
operator|++
control|)
block|{
name|String
name|name
init|=
name|hdrs
index|[
name|idx
index|]
operator|.
name|getName
argument_list|()
operator|.
name|trim
argument_list|()
operator|.
name|toLowerCase
argument_list|()
decl_stmt|;
if|if
condition|(
name|name
operator|.
name|equals
argument_list|(
literal|"host"
argument_list|)
condition|)
block|{
name|ho_idx
operator|=
name|idx
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|name
operator|.
name|equals
argument_list|(
literal|"content-type"
argument_list|)
condition|)
block|{
name|ct_idx
operator|=
name|idx
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|name
operator|.
name|equals
argument_list|(
literal|"user-agent"
argument_list|)
condition|)
block|{
name|ua_idx
operator|=
name|idx
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|name
operator|.
name|equals
argument_list|(
literal|"connection"
argument_list|)
condition|)
block|{
name|co_idx
operator|=
name|idx
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|name
operator|.
name|equals
argument_list|(
literal|"proxy-connection"
argument_list|)
condition|)
block|{
name|pc_idx
operator|=
name|idx
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|name
operator|.
name|equals
argument_list|(
literal|"keep-alive"
argument_list|)
condition|)
block|{
name|ka_idx
operator|=
name|idx
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|name
operator|.
name|equals
argument_list|(
literal|"expect"
argument_list|)
condition|)
block|{
name|ex_idx
operator|=
name|idx
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|name
operator|.
name|equals
argument_list|(
literal|"te"
argument_list|)
condition|)
block|{
name|te_idx
operator|=
name|idx
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|name
operator|.
name|equals
argument_list|(
literal|"transfer-encoding"
argument_list|)
condition|)
block|{
name|tc_idx
operator|=
name|idx
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|name
operator|.
name|equals
argument_list|(
literal|"upgrade"
argument_list|)
condition|)
block|{
name|ug_idx
operator|=
name|idx
expr_stmt|;
block|}
block|}
comment|// Generate request line and Host header
name|String
name|file
init|=
name|Util
operator|.
name|escapeUnsafeChars
argument_list|(
name|req
operator|.
name|getRequestURI
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|Proxy_Host
operator|!=
literal|null
operator|&&
name|Protocol
operator|!=
name|HTTPS
operator|&&
operator|!
name|file
operator|.
name|equals
argument_list|(
literal|"*"
argument_list|)
condition|)
block|{
name|dataout
operator|.
name|writeBytes
argument_list|(
name|req
operator|.
name|getMethod
argument_list|()
operator|+
literal|" http://"
operator|+
name|Host
operator|+
literal|":"
operator|+
name|Port
operator|+
name|file
operator|+
literal|" "
operator|+
name|RequestProtocolVersion
operator|+
literal|"\r\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dataout
operator|.
name|writeBytes
argument_list|(
name|req
operator|.
name|getMethod
argument_list|()
operator|+
literal|" "
operator|+
name|file
operator|+
literal|" "
operator|+
name|RequestProtocolVersion
operator|+
literal|"\r\n"
argument_list|)
expr_stmt|;
block|}
name|String
name|h_hdr
init|=
operator|(
name|ho_idx
operator|>=
literal|0
operator|)
condition|?
name|hdrs
index|[
name|ho_idx
index|]
operator|.
name|getValue
argument_list|()
operator|.
name|trim
argument_list|()
else|:
name|Host
decl_stmt|;
if|if
condition|(
name|Port
operator|!=
name|URI
operator|.
name|defaultPort
argument_list|(
name|getProtocol
argument_list|()
argument_list|)
condition|)
block|{
name|dataout
operator|.
name|writeBytes
argument_list|(
literal|"Host: "
operator|+
name|h_hdr
operator|+
literal|":"
operator|+
name|Port
operator|+
literal|"\r\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Netscape-Enterprise has some bugs...
name|dataout
operator|.
name|writeBytes
argument_list|(
literal|"Host: "
operator|+
name|h_hdr
operator|+
literal|"\r\n"
argument_list|)
expr_stmt|;
block|}
comment|/*          *  What follows is the setup for persistent connections. We default          *  to doing persistent connections for both HTTP/1.0 and HTTP/1.1,          *  unless we're using a proxy server and HTTP/1.0 in which case we          *  must make sure we don't do persistence (because of the problem of          *  1.0 proxies blindly passing the Connection header on).          *          *  Note: there is a "Proxy-Connection" header for use with proxies.          *  This however is only understood by Netscape and Netapp caches.          *  Furthermore, it suffers from the same problem as the Connection          *  header in HTTP/1.0 except that at least two proxies must be          *  involved. But I've taken the risk now and decided to send the          *  Proxy-Connection header. If I get complaints I'll remove it again.          *          *  In any case, with this header we can now modify the above to send          *  the Proxy-Connection header whenever we wouldn't send the normal          *  Connection header.          */
name|String
name|co_hdr
init|=
literal|null
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|ServProtVersKnown
operator|&&
name|ServerProtocolVersion
operator|>=
name|HTTP_1_1
operator|&&
name|co_idx
operator|==
operator|-
literal|1
operator|)
condition|)
block|{
if|if
condition|(
name|co_idx
operator|==
operator|-
literal|1
condition|)
block|{
comment|// no connection header given by user
name|co_hdr
operator|=
literal|"Keep-Alive"
expr_stmt|;
name|con_hdrs
index|[
literal|0
index|]
operator|=
literal|"Keep-Alive"
expr_stmt|;
block|}
else|else
block|{
name|con_hdrs
index|[
literal|0
index|]
operator|=
name|hdrs
index|[
name|co_idx
index|]
operator|.
name|getValue
argument_list|()
operator|.
name|trim
argument_list|()
expr_stmt|;
name|co_hdr
operator|=
name|con_hdrs
index|[
literal|0
index|]
expr_stmt|;
block|}
try|try
block|{
if|if
condition|(
name|ka_idx
operator|!=
operator|-
literal|1
operator|&&
name|Util
operator|.
name|hasToken
argument_list|(
name|con_hdrs
index|[
literal|0
index|]
argument_list|,
literal|"keep-alive"
argument_list|)
condition|)
block|{
name|dataout
operator|.
name|writeBytes
argument_list|(
literal|"Keep-Alive: "
operator|+
name|hdrs
index|[
name|ka_idx
index|]
operator|.
name|getValue
argument_list|()
operator|.
name|trim
argument_list|()
operator|+
literal|"\r\n"
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|ParseException
name|pe
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|pe
operator|.
name|toString
argument_list|()
argument_list|)
throw|;
block|}
block|}
if|if
condition|(
operator|(
name|Proxy_Host
operator|!=
literal|null
operator|&&
name|Protocol
operator|!=
name|HTTPS
operator|)
operator|&&
operator|!
operator|(
name|ServProtVersKnown
operator|&&
name|ServerProtocolVersion
operator|>=
name|HTTP_1_1
operator|)
condition|)
block|{
if|if
condition|(
name|co_hdr
operator|!=
literal|null
condition|)
block|{
name|dataout
operator|.
name|writeBytes
argument_list|(
literal|"Proxy-Connection: "
argument_list|)
expr_stmt|;
name|dataout
operator|.
name|writeBytes
argument_list|(
name|co_hdr
argument_list|)
expr_stmt|;
name|dataout
operator|.
name|writeBytes
argument_list|(
literal|"\r\n"
argument_list|)
expr_stmt|;
name|co_hdr
operator|=
literal|null
expr_stmt|;
block|}
block|}
if|if
condition|(
name|co_hdr
operator|!=
literal|null
condition|)
block|{
try|try
block|{
if|if
condition|(
operator|!
name|Util
operator|.
name|hasToken
argument_list|(
name|co_hdr
argument_list|,
literal|"TE"
argument_list|)
condition|)
block|{
name|co_hdr
operator|+=
literal|", TE"
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|ParseException
name|pe
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|pe
operator|.
name|toString
argument_list|()
argument_list|)
throw|;
block|}
block|}
else|else
block|{
name|co_hdr
operator|=
literal|"TE"
expr_stmt|;
block|}
if|if
condition|(
name|ug_idx
operator|!=
operator|-
literal|1
condition|)
block|{
name|co_hdr
operator|+=
literal|", Upgrade"
expr_stmt|;
block|}
if|if
condition|(
name|co_hdr
operator|!=
literal|null
condition|)
block|{
name|dataout
operator|.
name|writeBytes
argument_list|(
literal|"Connection: "
argument_list|)
expr_stmt|;
name|dataout
operator|.
name|writeBytes
argument_list|(
name|co_hdr
argument_list|)
expr_stmt|;
name|dataout
operator|.
name|writeBytes
argument_list|(
literal|"\r\n"
argument_list|)
expr_stmt|;
block|}
comment|// handle TE header
if|if
condition|(
name|te_idx
operator|!=
operator|-
literal|1
condition|)
block|{
name|dataout
operator|.
name|writeBytes
argument_list|(
literal|"TE: "
argument_list|)
expr_stmt|;
name|Vector
name|pte
decl_stmt|;
try|try
block|{
name|pte
operator|=
name|Util
operator|.
name|parseHeader
argument_list|(
name|hdrs
index|[
name|te_idx
index|]
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ParseException
name|pe
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|pe
operator|.
name|toString
argument_list|()
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|pte
operator|.
name|contains
argument_list|(
operator|new
name|HttpHeaderElement
argument_list|(
literal|"trailers"
argument_list|)
argument_list|)
condition|)
block|{
name|dataout
operator|.
name|writeBytes
argument_list|(
literal|"trailers, "
argument_list|)
expr_stmt|;
block|}
name|dataout
operator|.
name|writeBytes
argument_list|(
name|hdrs
index|[
name|te_idx
index|]
operator|.
name|getValue
argument_list|()
operator|.
name|trim
argument_list|()
operator|+
literal|"\r\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dataout
operator|.
name|writeBytes
argument_list|(
literal|"TE: trailers\r\n"
argument_list|)
expr_stmt|;
block|}
comment|// User-Agent
if|if
condition|(
name|ua_idx
operator|!=
operator|-
literal|1
condition|)
block|{
name|dataout
operator|.
name|writeBytes
argument_list|(
literal|"User-Agent: "
operator|+
name|hdrs
index|[
name|ua_idx
index|]
operator|.
name|getValue
argument_list|()
operator|.
name|trim
argument_list|()
operator|+
literal|"\r\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dataout
operator|.
name|writeBytes
argument_list|(
literal|"User-Agent: "
operator|+
name|version
operator|+
literal|"\r\n"
argument_list|)
expr_stmt|;
block|}
comment|// Write out any headers left
for|for
control|(
name|int
name|idx
init|=
literal|0
init|;
name|idx
operator|<
name|hdrs
operator|.
name|length
condition|;
name|idx
operator|++
control|)
block|{
if|if
condition|(
name|idx
operator|!=
name|ct_idx
operator|&&
name|idx
operator|!=
name|ua_idx
operator|&&
name|idx
operator|!=
name|co_idx
operator|&&
name|idx
operator|!=
name|pc_idx
operator|&&
name|idx
operator|!=
name|ka_idx
operator|&&
name|idx
operator|!=
name|ex_idx
operator|&&
name|idx
operator|!=
name|te_idx
operator|&&
name|idx
operator|!=
name|ho_idx
condition|)
block|{
name|dataout
operator|.
name|writeBytes
argument_list|(
name|hdrs
index|[
name|idx
index|]
operator|.
name|getName
argument_list|()
operator|.
name|trim
argument_list|()
operator|+
literal|": "
operator|+
name|hdrs
index|[
name|idx
index|]
operator|.
name|getValue
argument_list|()
operator|.
name|trim
argument_list|()
operator|+
literal|"\r\n"
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Handle Content-type, Content-length and Expect headers
if|if
condition|(
name|req
operator|.
name|getData
argument_list|()
operator|!=
literal|null
operator|||
name|req
operator|.
name|getStream
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|dataout
operator|.
name|writeBytes
argument_list|(
literal|"Content-type: "
argument_list|)
expr_stmt|;
if|if
condition|(
name|ct_idx
operator|!=
operator|-
literal|1
condition|)
block|{
name|dataout
operator|.
name|writeBytes
argument_list|(
name|hdrs
index|[
name|ct_idx
index|]
operator|.
name|getValue
argument_list|()
operator|.
name|trim
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dataout
operator|.
name|writeBytes
argument_list|(
literal|"application/octet-stream"
argument_list|)
expr_stmt|;
block|}
name|dataout
operator|.
name|writeBytes
argument_list|(
literal|"\r\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|req
operator|.
name|getData
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|dataout
operator|.
name|writeBytes
argument_list|(
literal|"Content-length: "
operator|+
name|req
operator|.
name|getData
argument_list|()
operator|.
name|length
operator|+
literal|"\r\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|req
operator|.
name|getStream
argument_list|()
operator|.
name|getLength
argument_list|()
operator|!=
operator|-
literal|1
operator|&&
name|tc_idx
operator|==
operator|-
literal|1
condition|)
block|{
name|dataout
operator|.
name|writeBytes
argument_list|(
literal|"Content-length: "
operator|+
name|req
operator|.
name|getStream
argument_list|()
operator|.
name|getLength
argument_list|()
operator|+
literal|"\r\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ex_idx
operator|!=
operator|-
literal|1
condition|)
block|{
name|con_hdrs
index|[
literal|1
index|]
operator|=
name|hdrs
index|[
name|ex_idx
index|]
operator|.
name|getValue
argument_list|()
operator|.
name|trim
argument_list|()
expr_stmt|;
name|dataout
operator|.
name|writeBytes
argument_list|(
literal|"Expect: "
operator|+
name|con_hdrs
index|[
literal|1
index|]
operator|+
literal|"\r\n"
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|ex_idx
operator|!=
operator|-
literal|1
condition|)
block|{
name|Vector
name|expect_tokens
decl_stmt|;
try|try
block|{
name|expect_tokens
operator|=
name|Util
operator|.
name|parseHeader
argument_list|(
name|hdrs
index|[
name|ex_idx
index|]
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ParseException
name|pe
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|pe
operator|.
name|toString
argument_list|()
argument_list|)
throw|;
block|}
comment|// remove any 100-continue tokens
name|HttpHeaderElement
name|cont
init|=
operator|new
name|HttpHeaderElement
argument_list|(
literal|"100-continue"
argument_list|)
decl_stmt|;
while|while
condition|(
name|expect_tokens
operator|.
name|removeElement
argument_list|(
name|cont
argument_list|)
condition|)
block|{
empty_stmt|;
block|}
comment|// write out header if any tokens left
if|if
condition|(
operator|!
name|expect_tokens
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|con_hdrs
index|[
literal|1
index|]
operator|=
name|Util
operator|.
name|assembleHeader
argument_list|(
name|expect_tokens
argument_list|)
expr_stmt|;
name|dataout
operator|.
name|writeBytes
argument_list|(
literal|"Expect: "
operator|+
name|con_hdrs
index|[
literal|1
index|]
operator|+
literal|"\r\n"
argument_list|)
expr_stmt|;
block|}
block|}
name|dataout
operator|.
name|writeBytes
argument_list|(
literal|"\r\n"
argument_list|)
expr_stmt|;
comment|// end of header
return|return
name|con_hdrs
return|;
block|}
comment|/**      * The very first request is special in that we use it to figure out the      * protocol version the server (or proxy) is compliant with.      *      * @param req              Description of the Parameter      * @param resp             Description of the Parameter      * @return                 true if all went fine, false if the request needs      *      to be resent      * @exception IOException  if any exception is thrown by the response      */
DECL|method|handleFirstRequest
name|boolean
name|handleFirstRequest
parameter_list|(
name|Request
name|req
parameter_list|,
name|Response
name|resp
parameter_list|)
throws|throws
name|IOException
block|{
comment|// read response headers to get protocol version used by
comment|// the server.
name|ServerProtocolVersion
operator|=
name|String2ProtVers
argument_list|(
name|resp
operator|.
name|getVersion
argument_list|()
argument_list|)
expr_stmt|;
name|ServProtVersKnown
operator|=
literal|true
expr_stmt|;
comment|/*          *  We need to treat connections through proxies specially, because          *  many HTTP/1.0 proxies do not downgrade an HTTP/1.1 response          *  version to HTTP/1.0 (i.e. when we are talking to an HTTP/1.1          *  server through an HTTP/1.0 proxy we are mislead to thinking we're          *  talking to an HTTP/1.1 proxy). We use the absence of the Via          *  header to detect whether we're talking to an HTTP/1.0 proxy,          *  unless the status code indicates an error from the proxy          *  itself. However, this only works when the chain contains          *  only HTTP/1.0 proxies; if you have<client - 1.0 proxy - 1.1          *  proxy - server> then this will fail too. Unfortunately there          *  seems to be no way to reliably detect broken HTTP/1.0          *  proxies...          */
name|int
name|sts
init|=
name|resp
operator|.
name|getStatusCode
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|Proxy_Host
operator|!=
literal|null
operator|&&
name|Protocol
operator|!=
name|HTTPS
operator|)
operator|&&
name|resp
operator|.
name|getHeader
argument_list|(
literal|"Via"
argument_list|)
operator|==
literal|null
operator|&&
name|sts
operator|!=
literal|407
operator|&&
name|sts
operator|!=
literal|502
operator|&&
name|sts
operator|!=
literal|504
condition|)
block|{
name|ServerProtocolVersion
operator|=
name|HTTP_1_0
expr_stmt|;
block|}
name|Log
operator|.
name|write
argument_list|(
name|Log
operator|.
name|CONN
argument_list|,
literal|"Conn:  Protocol Version established: "
operator|+
name|ProtVers2String
argument_list|(
name|ServerProtocolVersion
argument_list|)
argument_list|)
expr_stmt|;
comment|// some (buggy) servers return an error status if they get a
comment|// version they don't comprehend
if|if
condition|(
name|ServerProtocolVersion
operator|==
name|HTTP_1_0
operator|&&
operator|(
name|resp
operator|.
name|getStatusCode
argument_list|()
operator|==
literal|400
operator|||
name|resp
operator|.
name|getStatusCode
argument_list|()
operator|==
literal|500
operator|)
condition|)
block|{
if|if
condition|(
name|input_demux
operator|!=
literal|null
condition|)
block|{
name|input_demux
operator|.
name|markForClose
argument_list|(
name|resp
argument_list|)
expr_stmt|;
block|}
name|input_demux
operator|=
literal|null
expr_stmt|;
name|RequestProtocolVersion
operator|=
literal|"HTTP/1.0"
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
comment|/**      * Description of the Method      *      * @param resp             Description of the Parameter      * @exception IOException  Description of the Exception      */
DECL|method|determineKeepAlive
specifier|private
name|void
name|determineKeepAlive
parameter_list|(
name|Response
name|resp
parameter_list|)
throws|throws
name|IOException
block|{
comment|// try and determine if this server does keep-alives
name|String
name|con
decl_stmt|;
try|try
block|{
if|if
condition|(
name|ServerProtocolVersion
operator|>=
name|HTTP_1_1
operator|||
operator|(
operator|(
operator|(
operator|(
name|Proxy_Host
operator|==
literal|null
operator|||
name|Protocol
operator|==
name|HTTPS
operator|)
operator|&&
operator|(
name|con
operator|=
name|resp
operator|.
name|getHeader
argument_list|(
literal|"Connection"
argument_list|)
operator|)
operator|!=
literal|null
operator|)
operator|||
operator|(
operator|(
name|Proxy_Host
operator|!=
literal|null
operator|&&
name|Protocol
operator|!=
name|HTTPS
operator|)
operator|&&
operator|(
name|con
operator|=
name|resp
operator|.
name|getHeader
argument_list|(
literal|"Proxy-Connection"
argument_list|)
operator|)
operator|!=
literal|null
operator|)
operator|)
operator|&&
name|Util
operator|.
name|hasToken
argument_list|(
name|con
argument_list|,
literal|"keep-alive"
argument_list|)
operator|)
condition|)
block|{
name|doesKeepAlive
operator|=
literal|true
expr_stmt|;
name|keepAliveUnknown
operator|=
literal|false
expr_stmt|;
name|Log
operator|.
name|write
argument_list|(
name|Log
operator|.
name|CONN
argument_list|,
literal|"Conn:  Keep-Alive enabled"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|resp
operator|.
name|getStatusCode
argument_list|()
operator|<
literal|400
condition|)
block|{
name|keepAliveUnknown
operator|=
literal|false
expr_stmt|;
block|}
comment|// get maximum number of requests
if|if
condition|(
name|doesKeepAlive
operator|&&
name|ServerProtocolVersion
operator|==
name|HTTP_1_0
operator|&&
operator|(
name|con
operator|=
name|resp
operator|.
name|getHeader
argument_list|(
literal|"Keep-Alive"
argument_list|)
operator|)
operator|!=
literal|null
condition|)
block|{
name|HttpHeaderElement
name|max
init|=
name|Util
operator|.
name|getElement
argument_list|(
name|Util
operator|.
name|parseHeader
argument_list|(
name|con
argument_list|)
argument_list|,
literal|"max"
argument_list|)
decl_stmt|;
if|if
condition|(
name|max
operator|!=
literal|null
operator|&&
name|max
operator|.
name|getValue
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|keepAliveReqMax
operator|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|max
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
name|keepAliveReqLeft
operator|=
name|keepAliveReqMax
expr_stmt|;
name|Log
operator|.
name|write
argument_list|(
name|Log
operator|.
name|CONN
argument_list|,
literal|"Conn:  Max Keep-Alive requests: "
operator|+
name|keepAliveReqMax
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|ParseException
name|pe
parameter_list|)
block|{         }
catch|catch
parameter_list|(
name|NumberFormatException
name|nfe
parameter_list|)
block|{         }
catch|catch
parameter_list|(
name|ClassCastException
name|cce
parameter_list|)
block|{         }
block|}
comment|/**      * Description of the Method      */
DECL|method|outputFinished
specifier|synchronized
name|void
name|outputFinished
parameter_list|()
block|{
name|output_finished
operator|=
literal|true
expr_stmt|;
name|notify
argument_list|()
expr_stmt|;
block|}
comment|/**      * Description of the Method      *      * @param ioe        Description of the Parameter      * @param was_reset  Description of the Parameter      */
DECL|method|closeDemux
specifier|synchronized
name|void
name|closeDemux
parameter_list|(
name|IOException
name|ioe
parameter_list|,
name|boolean
name|was_reset
parameter_list|)
block|{
if|if
condition|(
name|input_demux
operator|!=
literal|null
condition|)
block|{
name|input_demux
operator|.
name|close
argument_list|(
name|ioe
argument_list|,
name|was_reset
argument_list|)
expr_stmt|;
block|}
name|early_stall
operator|=
literal|null
expr_stmt|;
name|late_stall
operator|=
literal|null
expr_stmt|;
name|prev_resp
operator|=
literal|null
expr_stmt|;
block|}
comment|/**      * Description of the Method      *      * @param prot_vers  Description of the Parameter      * @return           Description of the Return Value      */
DECL|method|ProtVers2String
specifier|final
specifier|static
name|String
name|ProtVers2String
parameter_list|(
name|int
name|prot_vers
parameter_list|)
block|{
return|return
literal|"HTTP/"
operator|+
operator|(
name|prot_vers
operator|>>>
literal|16
operator|)
operator|+
literal|"."
operator|+
operator|(
name|prot_vers
operator|&
literal|0xFFFF
operator|)
return|;
block|}
comment|/**      * Description of the Method      *      * @param prot_vers  Description of the Parameter      * @return           Description of the Return Value      */
DECL|method|String2ProtVers
specifier|final
specifier|static
name|int
name|String2ProtVers
parameter_list|(
name|String
name|prot_vers
parameter_list|)
block|{
name|String
name|vers
init|=
name|prot_vers
operator|.
name|substring
argument_list|(
literal|5
argument_list|)
decl_stmt|;
name|int
name|dot
init|=
name|vers
operator|.
name|indexOf
argument_list|(
literal|'.'
argument_list|)
decl_stmt|;
return|return
name|Integer
operator|.
name|parseInt
argument_list|(
name|vers
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|dot
argument_list|)
argument_list|)
operator|<<
literal|16
operator||
name|Integer
operator|.
name|parseInt
argument_list|(
name|vers
operator|.
name|substring
argument_list|(
name|dot
operator|+
literal|1
argument_list|)
argument_list|)
return|;
block|}
comment|/**      * Generates a string of the form protocol://host.domain:port .      *      * @return   the string      */
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|getProtocol
argument_list|()
operator|+
literal|"://"
operator|+
name|getHost
argument_list|()
operator|+
operator|(
name|getPort
argument_list|()
operator|!=
name|URI
operator|.
name|defaultPort
argument_list|(
name|getProtocol
argument_list|()
argument_list|)
condition|?
literal|":"
operator|+
name|getPort
argument_list|()
else|:
literal|""
operator|)
return|;
block|}
comment|/**      * Description of the Class      *      * @author    Administrator      * @created   29. Dezember 2001      */
DECL|class|EstablishConnection
specifier|private
class|class
name|EstablishConnection
extends|extends
name|Thread
block|{
DECL|field|actual_host
name|String
name|actual_host
decl_stmt|;
DECL|field|actual_port
name|int
name|actual_port
decl_stmt|;
DECL|field|exception
name|IOException
name|exception
decl_stmt|;
DECL|field|sock
name|Socket
name|sock
decl_stmt|;
DECL|field|Socks_client
name|SocksClient
name|Socks_client
decl_stmt|;
DECL|field|close
name|boolean
name|close
decl_stmt|;
comment|/**          * Constructor for the EstablishConnection object          *          * @param host   Description of the Parameter          * @param port   Description of the Parameter          * @param socks  Description of the Parameter          */
DECL|method|EstablishConnection
name|EstablishConnection
parameter_list|(
name|String
name|host
parameter_list|,
name|int
name|port
parameter_list|,
name|SocksClient
name|socks
parameter_list|)
block|{
name|super
argument_list|(
literal|"EstablishConnection ("
operator|+
name|host
operator|+
literal|":"
operator|+
name|port
operator|+
literal|")"
argument_list|)
expr_stmt|;
try|try
block|{
name|setDaemon
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SecurityException
name|se
parameter_list|)
block|{             }
comment|// Oh well...
name|actual_host
operator|=
name|host
expr_stmt|;
name|actual_port
operator|=
name|port
expr_stmt|;
name|Socks_client
operator|=
name|socks
expr_stmt|;
name|exception
operator|=
literal|null
expr_stmt|;
name|sock
operator|=
literal|null
expr_stmt|;
name|close
operator|=
literal|false
expr_stmt|;
block|}
comment|/**          * Main processing method for the EstablishConnection object          */
DECL|method|run
specifier|public
name|void
name|run
parameter_list|()
block|{
try|try
block|{
if|if
condition|(
name|Socks_client
operator|!=
literal|null
condition|)
block|{
name|sock
operator|=
name|Socks_client
operator|.
name|getSocket
argument_list|(
name|actual_host
argument_list|,
name|actual_port
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// try all A records
name|InetAddress
index|[]
name|addr_list
init|=
name|InetAddress
operator|.
name|getAllByName
argument_list|(
name|actual_host
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|idx
init|=
literal|0
init|;
name|idx
operator|<
name|addr_list
operator|.
name|length
condition|;
name|idx
operator|++
control|)
block|{
try|try
block|{
if|if
condition|(
name|LocalAddr
operator|==
literal|null
condition|)
block|{
name|sock
operator|=
operator|new
name|Socket
argument_list|(
name|addr_list
index|[
name|idx
index|]
argument_list|,
name|actual_port
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sock
operator|=
operator|new
name|Socket
argument_list|(
name|addr_list
index|[
name|idx
index|]
argument_list|,
name|actual_port
argument_list|,
name|LocalAddr
argument_list|,
name|LocalPort
argument_list|)
expr_stmt|;
block|}
break|break;
comment|// success
block|}
catch|catch
parameter_list|(
name|SocketException
name|se
parameter_list|)
block|{
if|if
condition|(
name|idx
operator|==
name|addr_list
operator|.
name|length
operator|-
literal|1
operator|||
name|close
condition|)
block|{
throw|throw
name|se
throw|;
block|}
comment|// we tried them all
block|}
block|}
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|exception
operator|=
name|ioe
expr_stmt|;
block|}
if|if
condition|(
name|close
operator|&&
name|sock
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|sock
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{                 }
name|sock
operator|=
literal|null
expr_stmt|;
block|}
block|}
comment|/**          * Gets the exception attribute of the EstablishConnection object          *          * @return   The exception value          */
DECL|method|getException
name|IOException
name|getException
parameter_list|()
block|{
return|return
name|exception
return|;
block|}
comment|/**          * Gets the socket attribute of the EstablishConnection object          *          * @return   The socket value          */
DECL|method|getSocket
name|Socket
name|getSocket
parameter_list|()
block|{
return|return
name|sock
return|;
block|}
comment|/**          * Description of the Method          */
DECL|method|forget
name|void
name|forget
parameter_list|()
block|{
name|close
operator|=
literal|true
expr_stmt|;
block|}
block|}
comment|/**      * M$ has yet another bug in their WinSock: if you try to write too much      * data at once it'll hang itself. This filter therefore splits big writes      * up into multiple writes of at most 20K.      *      * @author    Administrator      * @created   29. Dezember 2001      */
DECL|class|MSLargeWritesBugStream
specifier|private
class|class
name|MSLargeWritesBugStream
extends|extends
name|FilterOutputStream
block|{
DECL|field|CHUNK_SIZE
specifier|private
specifier|final
name|int
name|CHUNK_SIZE
init|=
literal|20000
decl_stmt|;
comment|/**          * Constructor for the MSLargeWritesBugStream object          *          * @param os  Description of the Parameter          */
DECL|method|MSLargeWritesBugStream
name|MSLargeWritesBugStream
parameter_list|(
name|OutputStream
name|os
parameter_list|)
block|{
name|super
argument_list|(
name|os
argument_list|)
expr_stmt|;
block|}
comment|/**          * Description of the Method          *          * @param b                Description of the Parameter          * @param off              Description of the Parameter          * @param len              Description of the Parameter          * @exception IOException  Description of the Exception          */
DECL|method|write
specifier|public
name|void
name|write
parameter_list|(
name|byte
index|[]
name|b
parameter_list|,
name|int
name|off
parameter_list|,
name|int
name|len
parameter_list|)
throws|throws
name|IOException
block|{
while|while
condition|(
name|len
operator|>
name|CHUNK_SIZE
condition|)
block|{
name|out
operator|.
name|write
argument_list|(
name|b
argument_list|,
name|off
argument_list|,
name|CHUNK_SIZE
argument_list|)
expr_stmt|;
name|off
operator|+=
name|CHUNK_SIZE
expr_stmt|;
name|len
operator|-=
name|CHUNK_SIZE
expr_stmt|;
block|}
name|out
operator|.
name|write
argument_list|(
name|b
argument_list|,
name|off
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|setDefaultReadIncement
specifier|public
name|void
name|setDefaultReadIncement
parameter_list|(
name|int
name|increment
parameter_list|)
block|{
name|this
operator|.
name|defaultIncrement
operator|=
name|increment
expr_stmt|;
block|}
DECL|field|defaultIncrement
name|int
name|defaultIncrement
init|=
literal|1000
decl_stmt|;
block|}
end_class
end_unit
