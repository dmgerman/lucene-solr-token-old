begin_unit
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_package
DECL|package|org.apache.solr.util
package|package
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|util
package|;
end_package
begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|annotation
operator|.
name|Documented
import|;
end_import
begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|annotation
operator|.
name|ElementType
import|;
end_import
begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|annotation
operator|.
name|Inherited
import|;
end_import
begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|annotation
operator|.
name|Retention
import|;
end_import
begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|annotation
operator|.
name|RetentionPolicy
import|;
end_import
begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|annotation
operator|.
name|Target
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|LuceneTestCase
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|TestUtil
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|SolrTestCaseJ4
operator|.
name|SuppressSSL
import|;
end_import
begin_comment
comment|/**  * Marker annotation indicating when SSL Randomization should be used for a test class, and if so what   * the typical odds of using SSL should for that test class.  * @see SSLRandomizer#getSSLRandomizerForClass  * @see SuppressSSL  */
end_comment
begin_annotation_defn
annotation|@
name|Documented
annotation|@
name|Inherited
annotation|@
name|Retention
argument_list|(
name|RetentionPolicy
operator|.
name|RUNTIME
argument_list|)
annotation|@
name|Target
argument_list|(
name|ElementType
operator|.
name|TYPE
argument_list|)
DECL|interface|RandomizeSSL
specifier|public
annotation_defn|@interface
name|RandomizeSSL
block|{
comment|// we don't choose ssl that often by default because of SOLR-5776
DECL|field|DEFAULT_ODDS
specifier|public
specifier|static
specifier|final
name|double
name|DEFAULT_ODDS
init|=
literal|0.2D
decl_stmt|;
comment|/** Comment to inlcude when logging details of SSL randomization */
DECL|field|Ó
specifier|public
name|String
name|reason
parameter_list|()
default|default
literal|""
function_decl|;
comment|/**     * Odds (as ratio relative to 1) that SSL should be selected in a typical run.    * Must either be betwen 0.0 and 1.0 (inclusively) or NaN in which case a sensible should be used.    * Actual Odds used for randomization may be higher depending on runner options such as     *<code>tests.multiplier</code> or<code>tests.nightly</code>    *    * @see #DEFAULT_ODDS    * @see LuceneTestCase#TEST_NIGHTLY    * @see LuceneTestCase#RANDOM_MULTIPLIER    */
DECL|field|Double.NaN
specifier|public
name|double
name|ssl
parameter_list|()
default|default
name|Double
operator|.
name|NaN
function_decl|;
comment|/**     * Odds (as ratio relative to 1) that SSL should be selected in a typical run.    * Must either be betwen 0.0 and 1.0 (inclusively) or NaN in which case the effective value of    * {@link #ssl} should be used.    * Actual Odds used for randomization may be higher depending on runner options such as     *<code>tests.multiplier</code> or<code>tests.nightly</code>    *<p>    * NOTE: clientAuth is useless unless ssl is also in used, but we randomize it independently    * just in case it might find bugs in our test/ssl client code (ie: attempting to use    * SSL w/client cert to non-ssl servers)    *</p>    * @see #DEFAULT_ODDS    * @see LuceneTestCase#TEST_NIGHTLY    * @see LuceneTestCase#RANDOM_MULTIPLIER    */
DECL|field|Double.NaN
specifier|public
name|double
name|clientAuth
parameter_list|()
default|default
name|Double
operator|.
name|NaN
function_decl|;
comment|/**    * A shorthand option for controlling both {@link #ssl} and {@link #clientAuth} with a single numeric     * value, For example:<code>@RandomizeSSL(0.5)</code>.    *    * Ignored if {@link #ssl} is set explicitly.    */
DECL|field|Double.NaN
specifier|public
name|double
name|value
parameter_list|()
default|default
name|Double
operator|.
name|NaN
function_decl|;
comment|/**    * A simple data structure for encapsulating the effective values to be used when randomizing    * SSL in a test, based on the configured values in the {@link RandomizeSSL} annotation.    */
DECL|class|SSLRandomizer
specifier|public
specifier|static
specifier|final
class|class
name|SSLRandomizer
block|{
DECL|field|ssl
specifier|public
specifier|final
name|double
name|ssl
decl_stmt|;
DECL|field|clientAuth
specifier|public
specifier|final
name|double
name|clientAuth
decl_stmt|;
DECL|field|debug
specifier|public
specifier|final
name|String
name|debug
decl_stmt|;
comment|/** @lucene.internal */
DECL|method|SSLRandomizer
specifier|public
name|SSLRandomizer
parameter_list|(
name|double
name|ssl
parameter_list|,
name|double
name|clientAuth
parameter_list|,
name|String
name|debug
parameter_list|)
block|{
name|this
operator|.
name|ssl
operator|=
name|ssl
expr_stmt|;
name|this
operator|.
name|clientAuth
operator|=
name|clientAuth
expr_stmt|;
name|this
operator|.
name|debug
operator|=
name|debug
expr_stmt|;
block|}
comment|/**       * Randomly produces an SSLTestConfig taking into account various factors       *      * @see LuceneTestCase#TEST_NIGHTLY      * @see LuceneTestCase#RANDOM_MULTIPLIER      * @see LuceneTestCase#random()      */
DECL|method|createSSLTestConfig
specifier|public
name|SSLTestConfig
name|createSSLTestConfig
parameter_list|()
block|{
comment|// even if we know SSL is disabled, always consume the same amount of randomness
comment|// that way all other test behavior should be consistent even if a user adds/removes @SuppressSSL
specifier|final
name|boolean
name|useSSL
init|=
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|LuceneTestCase
operator|.
name|random
argument_list|()
argument_list|,
literal|0
argument_list|,
literal|1000
argument_list|)
operator|<
call|(
name|int
call|)
argument_list|(
literal|1000
operator|*
name|getEffectiveOdds
argument_list|(
name|ssl
argument_list|,
name|LuceneTestCase
operator|.
name|TEST_NIGHTLY
argument_list|,
name|LuceneTestCase
operator|.
name|RANDOM_MULTIPLIER
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|boolean
name|useClientAuth
init|=
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|LuceneTestCase
operator|.
name|random
argument_list|()
argument_list|,
literal|0
argument_list|,
literal|1000
argument_list|)
operator|<
call|(
name|int
call|)
argument_list|(
literal|1000
operator|*
name|getEffectiveOdds
argument_list|(
name|clientAuth
argument_list|,
name|LuceneTestCase
operator|.
name|TEST_NIGHTLY
argument_list|,
name|LuceneTestCase
operator|.
name|RANDOM_MULTIPLIER
argument_list|)
argument_list|)
decl_stmt|;
return|return
operator|new
name|SSLTestConfig
argument_list|(
name|useSSL
argument_list|,
name|useClientAuth
argument_list|)
return|;
block|}
comment|/** @lucene.internal Public only for testing */
DECL|method|getEffectiveOdds
specifier|public
specifier|static
name|double
name|getEffectiveOdds
parameter_list|(
specifier|final
name|double
name|declaredOdds
parameter_list|,
specifier|final
name|boolean
name|nightly
parameter_list|,
specifier|final
name|int
name|multiplier
parameter_list|)
block|{
assert|assert
name|declaredOdds
operator|<=
literal|1.0D
assert|;
assert|assert
literal|0.0D
operator|<=
name|declaredOdds
assert|;
if|if
condition|(
name|declaredOdds
operator|==
literal|0.0D
operator|||
name|declaredOdds
operator|==
literal|1.0D
condition|)
block|{
return|return
name|declaredOdds
return|;
block|}
assert|assert
literal|0
operator|<
name|multiplier
assert|;
comment|// negate the odds so we can then divide it by our multipling factors
comment|// to increase the final odds
return|return
literal|1.0D
operator|-
operator|(
operator|(
literal|1.0D
operator|-
name|declaredOdds
operator|)
operator|/
operator|(
operator|(
name|nightly
condition|?
literal|1.1D
else|:
literal|1.0D
operator|)
operator|*
operator|(
literal|1.0D
operator|+
name|Math
operator|.
name|log
argument_list|(
name|multiplier
argument_list|)
operator|)
operator|)
operator|)
return|;
block|}
comment|/**      * Returns an SSLRandomizer suitable for the specified (test) class      */
DECL|method|getSSLRandomizerForClass
specifier|public
specifier|static
specifier|final
name|SSLRandomizer
name|getSSLRandomizerForClass
parameter_list|(
name|Class
name|clazz
parameter_list|)
block|{
specifier|final
name|SuppressSSL
name|suppression
init|=
operator|(
name|SuppressSSL
operator|)
name|clazz
operator|.
name|getAnnotation
argument_list|(
name|SuppressSSL
operator|.
name|class
argument_list|)
decl_stmt|;
if|if
condition|(
literal|null
operator|!=
name|suppression
condition|)
block|{
comment|// Even if this class has a RandomizeSSL annotation, any usage of SuppressSSL -- even in a
comment|// super class -- overrules that.
comment|//
comment|// (If it didn't work this way, it would be a pain in the ass to quickly disable SSL for a
comment|// broad hierarchy of tests)
return|return
operator|new
name|SSLRandomizer
argument_list|(
literal|0.0D
argument_list|,
literal|0.0D
argument_list|,
name|suppression
operator|.
name|toString
argument_list|()
argument_list|)
return|;
block|}
specifier|final
name|RandomizeSSL
name|annotation
init|=
operator|(
name|RandomizeSSL
operator|)
name|clazz
operator|.
name|getAnnotation
argument_list|(
name|RandomizeSSL
operator|.
name|class
argument_list|)
decl_stmt|;
if|if
condition|(
literal|null
operator|==
name|annotation
condition|)
block|{
return|return
operator|new
name|SSLRandomizer
argument_list|(
literal|0.0D
argument_list|,
literal|0.0D
argument_list|,
name|RandomizeSSL
operator|.
name|class
operator|.
name|getName
argument_list|()
operator|+
literal|" annotation not specified"
argument_list|)
return|;
block|}
specifier|final
name|double
name|def
init|=
name|Double
operator|.
name|isNaN
argument_list|(
name|annotation
operator|.
name|value
argument_list|()
argument_list|)
condition|?
name|DEFAULT_ODDS
else|:
name|annotation
operator|.
name|value
argument_list|()
decl_stmt|;
if|if
condition|(
name|def
operator|<
literal|0.0D
operator|||
literal|1.0D
operator|<
name|def
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
name|clazz
operator|.
name|getName
argument_list|()
operator|+
literal|": default value is not a ratio between 0 and 1: "
operator|+
name|annotation
operator|.
name|toString
argument_list|()
argument_list|)
throw|;
block|}
specifier|final
name|double
name|ssl
init|=
name|Double
operator|.
name|isNaN
argument_list|(
name|annotation
operator|.
name|ssl
argument_list|()
argument_list|)
condition|?
name|def
else|:
name|annotation
operator|.
name|ssl
argument_list|()
decl_stmt|;
if|if
condition|(
name|ssl
operator|<
literal|0.0D
operator|||
literal|1.0D
operator|<
name|ssl
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
name|clazz
operator|.
name|getName
argument_list|()
operator|+
literal|": ssl value is not a ratio between 0 and 1: "
operator|+
name|annotation
operator|.
name|toString
argument_list|()
argument_list|)
throw|;
block|}
specifier|final
name|double
name|clientAuth
init|=
name|Double
operator|.
name|isNaN
argument_list|(
name|annotation
operator|.
name|clientAuth
argument_list|()
argument_list|)
condition|?
name|ssl
else|:
name|annotation
operator|.
name|clientAuth
argument_list|()
decl_stmt|;
if|if
condition|(
name|clientAuth
operator|<
literal|0.0D
operator|||
literal|1
operator|<
name|clientAuth
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
name|clazz
operator|.
name|getName
argument_list|()
operator|+
literal|": clientAuth value is not a ratio between 0 and 1: "
operator|+
name|annotation
operator|.
name|toString
argument_list|()
argument_list|)
throw|;
block|}
return|return
operator|new
name|SSLRandomizer
argument_list|(
name|ssl
argument_list|,
name|clientAuth
argument_list|,
name|annotation
operator|.
name|toString
argument_list|()
argument_list|)
return|;
block|}
block|}
block|}
end_annotation_defn
end_unit
