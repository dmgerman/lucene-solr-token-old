begin_unit
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_package
DECL|package|org.apache.solr.update.processor
package|package
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|update
operator|.
name|processor
package|;
end_package
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|SolrTestCaseJ4
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|SolrInputDocument
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|params
operator|.
name|ModifiableSolrParams
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|core
operator|.
name|SolrCore
import|;
end_import
begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Before
import|;
end_import
begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|BeforeClass
import|;
end_import
begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Test
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|request
operator|.
name|SolrQueryRequest
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|response
operator|.
name|SolrQueryResponse
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|servlet
operator|.
name|SolrRequestParsers
import|;
end_import
begin_class
DECL|class|LanguageIdentifierUpdateProcessorFactoryTestCase
specifier|public
specifier|abstract
class|class
name|LanguageIdentifierUpdateProcessorFactoryTestCase
extends|extends
name|SolrTestCaseJ4
block|{
DECL|field|_parser
specifier|protected
specifier|static
name|SolrRequestParsers
name|_parser
decl_stmt|;
DECL|field|req
specifier|protected
specifier|static
name|SolrQueryRequest
name|req
decl_stmt|;
DECL|field|resp
specifier|protected
specifier|static
name|SolrQueryResponse
name|resp
init|=
operator|new
name|SolrQueryResponse
argument_list|()
decl_stmt|;
DECL|field|liProcessor
specifier|protected
specifier|static
name|LanguageIdentifierUpdateProcessor
name|liProcessor
decl_stmt|;
DECL|field|parameters
specifier|protected
specifier|static
name|ModifiableSolrParams
name|parameters
decl_stmt|;
annotation|@
name|BeforeClass
DECL|method|beforeClass
specifier|public
specifier|static
name|void
name|beforeClass
parameter_list|()
throws|throws
name|Exception
block|{
name|initCore
argument_list|(
literal|"solrconfig-languageidentifier.xml"
argument_list|,
literal|"schema.xml"
argument_list|,
name|getFile
argument_list|(
literal|"langid/solr"
argument_list|)
operator|.
name|getAbsolutePath
argument_list|()
argument_list|)
expr_stmt|;
name|SolrCore
name|core
init|=
name|h
operator|.
name|getCore
argument_list|()
decl_stmt|;
name|UpdateRequestProcessorChain
name|chained
init|=
name|core
operator|.
name|getUpdateProcessingChain
argument_list|(
literal|"lang_id"
argument_list|)
decl_stmt|;
name|assertNotNull
argument_list|(
name|chained
argument_list|)
expr_stmt|;
name|_parser
operator|=
operator|new
name|SolrRequestParsers
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
annotation|@
name|Before
DECL|method|setUp
specifier|public
name|void
name|setUp
parameter_list|()
throws|throws
name|Exception
block|{
name|super
operator|.
name|setUp
argument_list|()
expr_stmt|;
name|clearIndex
argument_list|()
expr_stmt|;
name|assertU
argument_list|(
name|commit
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testLangIdGlobal
specifier|public
name|void
name|testLangIdGlobal
parameter_list|()
throws|throws
name|Exception
block|{
name|parameters
operator|=
operator|new
name|ModifiableSolrParams
argument_list|()
expr_stmt|;
name|parameters
operator|.
name|add
argument_list|(
literal|"langid.fl"
argument_list|,
literal|"name,subject"
argument_list|)
expr_stmt|;
name|parameters
operator|.
name|add
argument_list|(
literal|"langid.langField"
argument_list|,
literal|"language_s"
argument_list|)
expr_stmt|;
name|parameters
operator|.
name|add
argument_list|(
literal|"langid.fallback"
argument_list|,
literal|"un"
argument_list|)
expr_stmt|;
name|liProcessor
operator|=
name|createLangIdProcessor
argument_list|(
name|parameters
argument_list|)
expr_stmt|;
name|assertLang
argument_list|(
literal|"no"
argument_list|,
literal|"id"
argument_list|,
literal|"1no"
argument_list|,
literal|"name"
argument_list|,
literal|"Lucene"
argument_list|,
literal|"subject"
argument_list|,
literal|"Lucene er et fri/Ã¥pen kildekode programvarebibliotek for informasjonsgjenfinning, opprinnelig utviklet i programmeringssprÃ¥ket Java av Doug Cutting. Lucene stÃ¸ttes av Apache Software Foundation og utgis under Apache-lisensen."
argument_list|)
expr_stmt|;
name|assertLang
argument_list|(
literal|"en"
argument_list|,
literal|"id"
argument_list|,
literal|"2en"
argument_list|,
literal|"name"
argument_list|,
literal|"Lucene"
argument_list|,
literal|"subject"
argument_list|,
literal|"Apache Lucene is a free/open source information retrieval software library, originally created in Java by Doug Cutting. It is supported by the Apache Software Foundation and is released under the Apache Software License."
argument_list|)
expr_stmt|;
name|assertLang
argument_list|(
literal|"sv"
argument_list|,
literal|"id"
argument_list|,
literal|"3sv"
argument_list|,
literal|"name"
argument_list|,
literal|"Maven"
argument_list|,
literal|"subject"
argument_list|,
literal|"Apache Maven Ã¤r ett verktyg utvecklat av Apache Software Foundation och anvÃ¤nds inom systemutveckling av datorprogram i programsprÃ¥ket Java. Maven anvÃ¤nds fÃ¶r att automatiskt paketera (bygga) programfilerna till en distribuerbar enhet. Maven anvÃ¤nds inom samma omrÃ¥de som Apache Ant men dess byggfiler Ã¤r deklarativa till skillnad ifrÃ¥n Ants skriptbaserade."
argument_list|)
expr_stmt|;
name|assertLang
argument_list|(
literal|"es"
argument_list|,
literal|"id"
argument_list|,
literal|"4es"
argument_list|,
literal|"name"
argument_list|,
literal|"Lucene"
argument_list|,
literal|"subject"
argument_list|,
literal|"Lucene es un API de cÃ³digo abierto para recuperaciÃ³n de informaciÃ³n, originalmente implementada en Java por Doug Cutting. EstÃ¡ apoyado por el Apache Software Foundation y se distribuye bajo la Apache Software License. Lucene tiene versiones para otros lenguajes incluyendo Delphi, Perl, C#, C++, Python, Ruby y PHP."
argument_list|)
expr_stmt|;
name|assertLang
argument_list|(
literal|"un"
argument_list|,
literal|"id"
argument_list|,
literal|"5un"
argument_list|,
literal|"name"
argument_list|,
literal|"a"
argument_list|,
literal|"subject"
argument_list|,
literal|"b"
argument_list|)
expr_stmt|;
name|assertLang
argument_list|(
literal|"th"
argument_list|,
literal|"id"
argument_list|,
literal|"6th"
argument_list|,
literal|"name"
argument_list|,
literal|"à¸à¸à¸à¸§à¸²à¸¡à¸à¸±à¸à¸ªà¸£à¸£à¹à¸à¸·à¸­à¸à¸à¸µà¹"
argument_list|,
literal|"subject"
argument_list|,
literal|"à¸­à¸±à¸à¹à¸à¸­à¸¥à¸µà¸ª à¸¡à¸²à¸£à¸µ à¸­à¸±à¸à¹à¸à¸­ à¸à¸£à¸±à¸à¸à¹ à¸«à¸£à¸·à¸­à¸¡à¸±à¸à¸£à¸¹à¹à¸à¸±à¸à¹à¸à¸ à¸²à¸©à¸²à¹à¸à¸¢à¸§à¹à¸² à¹à¸­à¸à¸à¹ à¹à¸à¸£à¸à¸à¹ à¹à¸à¹à¸à¹à¸à¹à¸à¸«à¸à¸´à¸à¸à¸²à¸§à¸¢à¸´à¸§ à¹à¸à¸´à¸à¸à¸µà¹à¹à¸¡à¸·à¸­à¸à¹à¸à¸£à¸à¸à¹à¹à¸à¸´à¸£à¹à¸ à¸à¸£à¸°à¹à¸à¸¨à¹à¸¢à¸­à¸£à¸¡à¸à¸µ à¹à¸à¸­à¸¡à¸µà¸à¸·à¹à¸­à¹à¸ªà¸µà¸¢à¸à¹à¸à¹à¸à¸à¸±à¸à¹à¸à¸à¸²à¸à¸°à¸à¸¹à¹à¹à¸à¸µà¸¢à¸à¸à¸±à¸à¸à¸¶à¸à¸à¸£à¸°à¸à¸³à¸§à¸±à¸à¸à¸¶à¹à¸à¸à¹à¸­à¸¡à¸²à¹à¸à¹à¸£à¸±à¸à¸à¸²à¸£à¸à¸µà¸à¸´à¸¡à¸à¹à¹à¸à¹à¸à¸«à¸à¸±à¸à¸ªà¸·à¸­ à¸à¸£à¸£à¸¢à¸²à¸¢à¹à¸«à¸à¸¸à¸à¸²à¸£à¸à¹à¸à¸à¸°à¸«à¸¥à¸à¸à¹à¸­à¸à¸à¸±à¸§à¸à¸²à¸à¸à¸²à¸£à¸¥à¹à¸²à¸à¸²à¸§à¸¢à¸´à¸§à¹à¸à¸à¸£à¸°à¹à¸à¸¨à¹à¸à¹à¸à¸­à¸£à¹à¹à¸¥à¸à¸à¹ à¸£à¸°à¸«à¸§à¹à¸²à¸à¸à¸µà¹à¸à¸¹à¸à¹à¸¢à¸­à¸£à¸¡à¸à¸µà¹à¸à¹à¸²à¸à¸£à¸­à¸à¸à¸£à¸­à¸à¹à¸à¸à¹à¸§à¸à¸ªà¸à¸à¸£à¸²à¸¡à¹à¸¥à¸à¸à¸£à¸±à¹à¸à¸à¸µà¹à¸ªà¸­à¸"
argument_list|)
expr_stmt|;
name|assertLang
argument_list|(
literal|"ru"
argument_list|,
literal|"id"
argument_list|,
literal|"7ru"
argument_list|,
literal|"name"
argument_list|,
literal|"Lucene"
argument_list|,
literal|"subject"
argument_list|,
literal|"The Apache Lucene â ÑÑÐ¾ ÑÐ²Ð¾Ð±Ð¾Ð´Ð½Ð°Ñ Ð±Ð¸Ð±Ð»Ð¸Ð¾ÑÐµÐºÐ° Ð´Ð»Ñ Ð²ÑÑÐ¾ÐºÐ¾ÑÐºÐ¾ÑÐ¾ÑÑÐ½Ð¾Ð³Ð¾ Ð¿Ð¾Ð»Ð½Ð¾ÑÐµÐºÑÑÐ¾Ð²Ð¾Ð³Ð¾ Ð¿Ð¾Ð¸ÑÐºÐ°, Ð½Ð°Ð¿Ð¸ÑÐ°Ð½Ð½Ð°Ñ Ð½Ð° Java. ÐÐ¾Ð¶ÐµÑ Ð±ÑÑÑ Ð¸ÑÐ¿Ð¾Ð»ÑÐ·Ð¾Ð²Ð°Ð½Ð° Ð´Ð»Ñ Ð¿Ð¾Ð¸ÑÐºÐ° Ð² Ð¸Ð½ÑÐµÑÐ½ÐµÑÐµ Ð¸ Ð´ÑÑÐ³Ð¸Ñ Ð¾Ð±Ð»Ð°ÑÑÑÑ ÐºÐ¾Ð¼Ð¿ÑÑÑÐµÑÐ½Ð¾Ð¹ Ð»Ð¸Ð½Ð³Ð²Ð¸ÑÑÐ¸ÐºÐ¸ (Ð°Ð½Ð°Ð»Ð¸ÑÐ¸ÑÐµÑÐºÐ°Ñ ÑÐ¸Ð»Ð¾ÑÐ¾ÑÐ¸Ñ)."
argument_list|)
expr_stmt|;
name|assertLang
argument_list|(
literal|"de"
argument_list|,
literal|"id"
argument_list|,
literal|"8de"
argument_list|,
literal|"name"
argument_list|,
literal|"Lucene"
argument_list|,
literal|"subject"
argument_list|,
literal|"Lucene ist ein Freie-Software-Projekt der Apache Software Foundation, das eine Suchsoftware erstellt. Durch die hohe LeistungsfÃ¤higkeit und Skalierbarkeit kÃ¶nnen die Lucene-Werkzeuge fÃ¼r beliebige ProjektgrÃ¶Ãen und Anforderungen eingesetzt werden. So setzt beispielsweise Wikipedia Lucene fÃ¼r die Volltextsuche ein. Zudem verwenden die beiden Desktop-Suchprogramme Beagle und Strigi eine C#- bzw. C++- Portierung von Lucene als Indexer."
argument_list|)
expr_stmt|;
name|assertLang
argument_list|(
literal|"fr"
argument_list|,
literal|"id"
argument_list|,
literal|"9fr"
argument_list|,
literal|"name"
argument_list|,
literal|"Lucene"
argument_list|,
literal|"subject"
argument_list|,
literal|"Lucene est un moteur de recherche libre Ã©crit en Java qui permet d'indexer et de rechercher du texte. C'est un projet open source de la fondation Apache mis Ã  disposition sous licence Apache. Il est Ã©galement disponible pour les langages Ruby, Perl, C++, PHP."
argument_list|)
expr_stmt|;
name|assertLang
argument_list|(
literal|"nl"
argument_list|,
literal|"id"
argument_list|,
literal|"10nl"
argument_list|,
literal|"name"
argument_list|,
literal|"Lucene"
argument_list|,
literal|"subject"
argument_list|,
literal|"Lucene is een gratis open source, tekst gebaseerde information retrieval API van origine geschreven in Java door Doug Cutting. Het wordt ondersteund door de Apache Software Foundation en is vrijgegeven onder de Apache Software Licentie. Lucene is ook beschikbaar in andere programeertalen zoals Perl, C#, C++, Python, Ruby en PHP."
argument_list|)
expr_stmt|;
name|assertLang
argument_list|(
literal|"it"
argument_list|,
literal|"id"
argument_list|,
literal|"11it"
argument_list|,
literal|"name"
argument_list|,
literal|"Lucene"
argument_list|,
literal|"subject"
argument_list|,
literal|"Lucene Ã¨ una API gratuita ed open source per il reperimento di informazioni inizialmente implementata in Java da Doug Cutting. Ã supportata dall'Apache Software Foundation ed Ã¨ resa disponibile con l'Apache License. Lucene Ã¨ stata successivamente reimplementata in Perl, C#, C++, Python, Ruby e PHP."
argument_list|)
expr_stmt|;
name|assertLang
argument_list|(
literal|"pt"
argument_list|,
literal|"id"
argument_list|,
literal|"12pt"
argument_list|,
literal|"name"
argument_list|,
literal|"Lucene"
argument_list|,
literal|"subject"
argument_list|,
literal|"Apache Lucene, ou simplesmente Lucene, Ã© um software de busca e uma API de indexaÃ§Ã£o de documentos, escrito na linguagem de programaÃ§Ã£o Java. Ã um software de cÃ³digo aberto da Apache Software Foundation licenciado atravÃ©s da licenÃ§a Apache."
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testMapFieldName
specifier|public
name|void
name|testMapFieldName
parameter_list|()
throws|throws
name|Exception
block|{
name|parameters
operator|=
operator|new
name|ModifiableSolrParams
argument_list|()
expr_stmt|;
name|parameters
operator|.
name|add
argument_list|(
literal|"langid.fl"
argument_list|,
literal|"name"
argument_list|)
expr_stmt|;
name|parameters
operator|.
name|add
argument_list|(
literal|"langid.map.lcmap"
argument_list|,
literal|"jp:s zh:cjk ko:cjk"
argument_list|)
expr_stmt|;
name|parameters
operator|.
name|add
argument_list|(
literal|"langid.enforceSchema"
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
name|liProcessor
operator|=
name|createLangIdProcessor
argument_list|(
name|parameters
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"test_no"
argument_list|,
name|liProcessor
operator|.
name|getMappedField
argument_list|(
literal|"test"
argument_list|,
literal|"no"
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"test_en"
argument_list|,
name|liProcessor
operator|.
name|getMappedField
argument_list|(
literal|"test"
argument_list|,
literal|"en"
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"test_s"
argument_list|,
name|liProcessor
operator|.
name|getMappedField
argument_list|(
literal|"test"
argument_list|,
literal|"jp"
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"test_cjk"
argument_list|,
name|liProcessor
operator|.
name|getMappedField
argument_list|(
literal|"test"
argument_list|,
literal|"zh"
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"test_cjk"
argument_list|,
name|liProcessor
operator|.
name|getMappedField
argument_list|(
literal|"test"
argument_list|,
literal|"ko"
argument_list|)
argument_list|)
expr_stmt|;
comment|// Prove support for other mapping regex
name|parameters
operator|.
name|add
argument_list|(
literal|"langid.map.pattern"
argument_list|,
literal|"text_(.*?)_field"
argument_list|)
expr_stmt|;
name|parameters
operator|.
name|add
argument_list|(
literal|"langid.map.replace"
argument_list|,
literal|"$1_{lang}Text"
argument_list|)
expr_stmt|;
name|liProcessor
operator|=
name|createLangIdProcessor
argument_list|(
name|parameters
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"title_noText"
argument_list|,
name|liProcessor
operator|.
name|getMappedField
argument_list|(
literal|"text_title_field"
argument_list|,
literal|"no"
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"body_svText"
argument_list|,
name|liProcessor
operator|.
name|getMappedField
argument_list|(
literal|"text_body_field"
argument_list|,
literal|"sv"
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testPreExisting
specifier|public
name|void
name|testPreExisting
parameter_list|()
throws|throws
name|Exception
block|{
name|SolrInputDocument
name|doc
decl_stmt|;
name|parameters
operator|=
operator|new
name|ModifiableSolrParams
argument_list|()
expr_stmt|;
name|parameters
operator|.
name|add
argument_list|(
literal|"langid.fl"
argument_list|,
literal|"text"
argument_list|)
expr_stmt|;
name|parameters
operator|.
name|add
argument_list|(
literal|"langid.langField"
argument_list|,
literal|"language"
argument_list|)
expr_stmt|;
name|parameters
operator|.
name|add
argument_list|(
literal|"langid.langsField"
argument_list|,
literal|"languages"
argument_list|)
expr_stmt|;
name|parameters
operator|.
name|add
argument_list|(
literal|"langid.enforceSchema"
argument_list|,
literal|"false"
argument_list|)
expr_stmt|;
name|parameters
operator|.
name|add
argument_list|(
literal|"langid.map"
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
name|liProcessor
operator|=
name|createLangIdProcessor
argument_list|(
name|parameters
argument_list|)
expr_stmt|;
name|doc
operator|=
name|englishDoc
argument_list|()
expr_stmt|;
name|assertEquals
argument_list|(
literal|"en"
argument_list|,
name|liProcessor
operator|.
name|process
argument_list|(
name|doc
argument_list|)
operator|.
name|getFieldValue
argument_list|(
literal|"language"
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"en"
argument_list|,
name|liProcessor
operator|.
name|process
argument_list|(
name|doc
argument_list|)
operator|.
name|getFieldValue
argument_list|(
literal|"languages"
argument_list|)
argument_list|)
expr_stmt|;
name|doc
operator|=
name|englishDoc
argument_list|()
expr_stmt|;
name|doc
operator|.
name|setField
argument_list|(
literal|"language"
argument_list|,
literal|"no"
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"no"
argument_list|,
name|liProcessor
operator|.
name|process
argument_list|(
name|doc
argument_list|)
operator|.
name|getFieldValue
argument_list|(
literal|"language"
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"no"
argument_list|,
name|liProcessor
operator|.
name|process
argument_list|(
name|doc
argument_list|)
operator|.
name|getFieldValue
argument_list|(
literal|"languages"
argument_list|)
argument_list|)
expr_stmt|;
name|assertNotNull
argument_list|(
name|liProcessor
operator|.
name|process
argument_list|(
name|doc
argument_list|)
operator|.
name|getFieldValue
argument_list|(
literal|"text_no"
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testDefaultFallbackEmptyString
specifier|public
name|void
name|testDefaultFallbackEmptyString
parameter_list|()
throws|throws
name|Exception
block|{
name|SolrInputDocument
name|doc
decl_stmt|;
name|parameters
operator|=
operator|new
name|ModifiableSolrParams
argument_list|()
expr_stmt|;
name|parameters
operator|.
name|add
argument_list|(
literal|"langid.fl"
argument_list|,
literal|"text"
argument_list|)
expr_stmt|;
name|parameters
operator|.
name|add
argument_list|(
literal|"langid.langField"
argument_list|,
literal|"language"
argument_list|)
expr_stmt|;
name|parameters
operator|.
name|add
argument_list|(
literal|"langid.enforceSchema"
argument_list|,
literal|"false"
argument_list|)
expr_stmt|;
name|liProcessor
operator|=
name|createLangIdProcessor
argument_list|(
name|parameters
argument_list|)
expr_stmt|;
name|doc
operator|=
name|tooShortDoc
argument_list|()
expr_stmt|;
name|assertEquals
argument_list|(
literal|""
argument_list|,
name|liProcessor
operator|.
name|process
argument_list|(
name|doc
argument_list|)
operator|.
name|getFieldValue
argument_list|(
literal|"language"
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testFallback
specifier|public
name|void
name|testFallback
parameter_list|()
throws|throws
name|Exception
block|{
name|SolrInputDocument
name|doc
decl_stmt|;
name|parameters
operator|=
operator|new
name|ModifiableSolrParams
argument_list|()
expr_stmt|;
name|parameters
operator|.
name|add
argument_list|(
literal|"langid.fl"
argument_list|,
literal|"text"
argument_list|)
expr_stmt|;
name|parameters
operator|.
name|add
argument_list|(
literal|"langid.langField"
argument_list|,
literal|"language"
argument_list|)
expr_stmt|;
name|parameters
operator|.
name|add
argument_list|(
literal|"langid.fallbackFields"
argument_list|,
literal|"noop,fb"
argument_list|)
expr_stmt|;
name|parameters
operator|.
name|add
argument_list|(
literal|"langid.fallback"
argument_list|,
literal|"fbVal"
argument_list|)
expr_stmt|;
name|parameters
operator|.
name|add
argument_list|(
literal|"langid.enforceSchema"
argument_list|,
literal|"false"
argument_list|)
expr_stmt|;
name|liProcessor
operator|=
name|createLangIdProcessor
argument_list|(
name|parameters
argument_list|)
expr_stmt|;
comment|// Verify fallback to field fb (noop field does not exist and is skipped)
name|doc
operator|=
name|tooShortDoc
argument_list|()
expr_stmt|;
name|doc
operator|.
name|addField
argument_list|(
literal|"fb"
argument_list|,
literal|"fbField"
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"fbField"
argument_list|,
name|liProcessor
operator|.
name|process
argument_list|(
name|doc
argument_list|)
operator|.
name|getFieldValue
argument_list|(
literal|"language"
argument_list|)
argument_list|)
expr_stmt|;
comment|// Verify fallback to fallback value since no fallback fields exist
name|doc
operator|=
name|tooShortDoc
argument_list|()
expr_stmt|;
name|assertEquals
argument_list|(
literal|"fbVal"
argument_list|,
name|liProcessor
operator|.
name|process
argument_list|(
name|doc
argument_list|)
operator|.
name|getFieldValue
argument_list|(
literal|"language"
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testResolveLanguage
specifier|public
name|void
name|testResolveLanguage
parameter_list|()
throws|throws
name|Exception
block|{
name|List
argument_list|<
name|DetectedLanguage
argument_list|>
name|langs
decl_stmt|;
name|parameters
operator|=
operator|new
name|ModifiableSolrParams
argument_list|()
expr_stmt|;
name|parameters
operator|.
name|add
argument_list|(
literal|"langid.fl"
argument_list|,
literal|"text"
argument_list|)
expr_stmt|;
name|parameters
operator|.
name|add
argument_list|(
literal|"langid.langField"
argument_list|,
literal|"language"
argument_list|)
expr_stmt|;
name|liProcessor
operator|=
name|createLangIdProcessor
argument_list|(
name|parameters
argument_list|)
expr_stmt|;
comment|// No detected languages
name|langs
operator|=
operator|new
name|ArrayList
argument_list|<
name|DetectedLanguage
argument_list|>
argument_list|()
expr_stmt|;
name|assertEquals
argument_list|(
literal|""
argument_list|,
name|liProcessor
operator|.
name|resolveLanguage
argument_list|(
name|langs
argument_list|,
literal|null
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"fallback"
argument_list|,
name|liProcessor
operator|.
name|resolveLanguage
argument_list|(
name|langs
argument_list|,
literal|"fallback"
argument_list|)
argument_list|)
expr_stmt|;
comment|// One detected language
name|langs
operator|.
name|add
argument_list|(
operator|new
name|DetectedLanguage
argument_list|(
literal|"one"
argument_list|,
literal|1.0
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"one"
argument_list|,
name|liProcessor
operator|.
name|resolveLanguage
argument_list|(
name|langs
argument_list|,
literal|"fallback"
argument_list|)
argument_list|)
expr_stmt|;
comment|// One detected language under default threshold
name|langs
operator|=
operator|new
name|ArrayList
argument_list|<
name|DetectedLanguage
argument_list|>
argument_list|()
expr_stmt|;
name|langs
operator|.
name|add
argument_list|(
operator|new
name|DetectedLanguage
argument_list|(
literal|"under"
argument_list|,
literal|0.1
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"fallback"
argument_list|,
name|liProcessor
operator|.
name|resolveLanguage
argument_list|(
name|langs
argument_list|,
literal|"fallback"
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// Various utility methods
DECL|method|englishDoc
specifier|private
name|SolrInputDocument
name|englishDoc
parameter_list|()
block|{
name|SolrInputDocument
name|doc
init|=
operator|new
name|SolrInputDocument
argument_list|()
decl_stmt|;
name|doc
operator|.
name|addField
argument_list|(
literal|"text"
argument_list|,
literal|"Apache Lucene is a free/open source information retrieval software library, originally created in Java by Doug Cutting. It is supported by the Apache Software Foundation and is released under the Apache Software License."
argument_list|)
expr_stmt|;
return|return
name|doc
return|;
block|}
DECL|method|tooShortDoc
specifier|protected
name|SolrInputDocument
name|tooShortDoc
parameter_list|()
block|{
name|SolrInputDocument
name|doc
init|=
operator|new
name|SolrInputDocument
argument_list|()
decl_stmt|;
name|doc
operator|.
name|addField
argument_list|(
literal|"text"
argument_list|,
literal|"This text is too short"
argument_list|)
expr_stmt|;
return|return
name|doc
return|;
block|}
DECL|method|createLangIdProcessor
specifier|protected
specifier|abstract
name|LanguageIdentifierUpdateProcessor
name|createLangIdProcessor
parameter_list|(
name|ModifiableSolrParams
name|parameters
parameter_list|)
throws|throws
name|Exception
function_decl|;
DECL|method|assertLang
specifier|protected
name|void
name|assertLang
parameter_list|(
name|String
name|langCode
parameter_list|,
name|String
modifier|...
name|fieldsAndValues
parameter_list|)
throws|throws
name|Exception
block|{
if|if
condition|(
name|liProcessor
operator|==
literal|null
condition|)
throw|throw
operator|new
name|Exception
argument_list|(
literal|"Processor must be initialized before calling assertLang()"
argument_list|)
throw|;
name|SolrInputDocument
name|doc
init|=
name|sid
argument_list|(
name|fieldsAndValues
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|langCode
argument_list|,
name|liProcessor
operator|.
name|process
argument_list|(
name|doc
argument_list|)
operator|.
name|getFieldValue
argument_list|(
name|liProcessor
operator|.
name|langField
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|sid
specifier|private
name|SolrInputDocument
name|sid
parameter_list|(
name|String
modifier|...
name|fieldsAndValues
parameter_list|)
block|{
name|SolrInputDocument
name|doc
init|=
operator|new
name|SolrInputDocument
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fieldsAndValues
operator|.
name|length
condition|;
name|i
operator|+=
literal|2
control|)
block|{
name|doc
operator|.
name|addField
argument_list|(
name|fieldsAndValues
index|[
name|i
index|]
argument_list|,
name|fieldsAndValues
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
return|return
name|doc
return|;
block|}
block|}
end_class
end_unit
