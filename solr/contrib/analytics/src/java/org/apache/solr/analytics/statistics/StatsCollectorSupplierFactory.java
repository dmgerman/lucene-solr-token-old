begin_unit
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_package
DECL|package|org.apache.solr.analytics.statistics
package|package
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|analytics
operator|.
name|statistics
package|;
end_package
begin_import
import|import
name|java
operator|.
name|text
operator|.
name|ParseException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashMap
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeMap
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|queries
operator|.
name|function
operator|.
name|ValueSource
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|queries
operator|.
name|function
operator|.
name|valuesource
operator|.
name|BytesRefFieldSource
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|queries
operator|.
name|function
operator|.
name|valuesource
operator|.
name|DoubleFieldSource
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|queries
operator|.
name|function
operator|.
name|valuesource
operator|.
name|FloatFieldSource
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|queries
operator|.
name|function
operator|.
name|valuesource
operator|.
name|IntFieldSource
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|queries
operator|.
name|function
operator|.
name|valuesource
operator|.
name|LongFieldSource
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|analytics
operator|.
name|expression
operator|.
name|ExpressionFactory
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|analytics
operator|.
name|request
operator|.
name|ExpressionRequest
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|analytics
operator|.
name|util
operator|.
name|AnalyticsParams
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|analytics
operator|.
name|util
operator|.
name|AnalyticsParsers
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|analytics
operator|.
name|util
operator|.
name|valuesource
operator|.
name|AbsoluteValueDoubleFunction
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|analytics
operator|.
name|util
operator|.
name|valuesource
operator|.
name|AddDoubleFunction
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|analytics
operator|.
name|util
operator|.
name|valuesource
operator|.
name|ConcatStringFunction
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|analytics
operator|.
name|util
operator|.
name|valuesource
operator|.
name|ConstDateSource
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|analytics
operator|.
name|util
operator|.
name|valuesource
operator|.
name|ConstDoubleSource
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|analytics
operator|.
name|util
operator|.
name|valuesource
operator|.
name|ConstStringSource
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|analytics
operator|.
name|util
operator|.
name|valuesource
operator|.
name|DateFieldSource
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|analytics
operator|.
name|util
operator|.
name|valuesource
operator|.
name|DateMathFunction
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|analytics
operator|.
name|util
operator|.
name|valuesource
operator|.
name|DivDoubleFunction
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|analytics
operator|.
name|util
operator|.
name|valuesource
operator|.
name|DualDoubleFunction
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|analytics
operator|.
name|util
operator|.
name|valuesource
operator|.
name|FilterFieldSource
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|analytics
operator|.
name|util
operator|.
name|valuesource
operator|.
name|LogDoubleFunction
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|analytics
operator|.
name|util
operator|.
name|valuesource
operator|.
name|MultiDateFunction
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|analytics
operator|.
name|util
operator|.
name|valuesource
operator|.
name|MultiDoubleFunction
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|analytics
operator|.
name|util
operator|.
name|valuesource
operator|.
name|MultiplyDoubleFunction
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|analytics
operator|.
name|util
operator|.
name|valuesource
operator|.
name|NegateDoubleFunction
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|analytics
operator|.
name|util
operator|.
name|valuesource
operator|.
name|PowDoubleFunction
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|analytics
operator|.
name|util
operator|.
name|valuesource
operator|.
name|ReverseStringFunction
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|analytics
operator|.
name|util
operator|.
name|valuesource
operator|.
name|SingleDoubleFunction
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|SolrException
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|SolrException
operator|.
name|ErrorCode
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|schema
operator|.
name|FieldType
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|schema
operator|.
name|IndexSchema
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|schema
operator|.
name|SchemaField
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|schema
operator|.
name|StrField
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|schema
operator|.
name|TrieDateField
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|schema
operator|.
name|TrieDoubleField
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|schema
operator|.
name|TrieFloatField
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|schema
operator|.
name|TrieIntField
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|schema
operator|.
name|TrieLongField
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|util
operator|.
name|DateFormatUtil
import|;
end_import
begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import
begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import
begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Supplier
import|;
end_import
begin_class
DECL|class|StatsCollectorSupplierFactory
specifier|public
class|class
name|StatsCollectorSupplierFactory
block|{
DECL|field|log
specifier|private
specifier|static
specifier|final
name|Logger
name|log
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|StatsCollectorSupplierFactory
operator|.
name|class
argument_list|)
decl_stmt|;
comment|// FunctionTypes
DECL|field|NUMBER_TYPE
specifier|final
specifier|static
name|int
name|NUMBER_TYPE
init|=
literal|0
decl_stmt|;
DECL|field|DATE_TYPE
specifier|final
specifier|static
name|int
name|DATE_TYPE
init|=
literal|1
decl_stmt|;
DECL|field|STRING_TYPE
specifier|final
specifier|static
name|int
name|STRING_TYPE
init|=
literal|2
decl_stmt|;
DECL|field|FIELD_TYPE
specifier|final
specifier|static
name|int
name|FIELD_TYPE
init|=
literal|3
decl_stmt|;
DECL|field|FILTER_TYPE
specifier|final
specifier|static
name|int
name|FILTER_TYPE
init|=
literal|4
decl_stmt|;
comment|/**    * Builds a Supplier that will generate identical arrays of new StatsCollectors.    *     * @param schema The Schema being used.    * @param exRequests The expression requests to generate a StatsCollector[] from.    * @return A Supplier that will return an array of new StatsCollector.    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|create
specifier|public
specifier|static
name|Supplier
argument_list|<
name|StatsCollector
index|[]
argument_list|>
name|create
parameter_list|(
name|IndexSchema
name|schema
parameter_list|,
name|List
argument_list|<
name|ExpressionRequest
argument_list|>
name|exRequests
parameter_list|)
block|{
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|Set
argument_list|<
name|String
argument_list|>
argument_list|>
name|collectorStats
init|=
operator|new
name|TreeMap
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|Set
argument_list|<
name|Integer
argument_list|>
argument_list|>
name|collectorPercs
init|=
operator|new
name|TreeMap
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|ValueSource
argument_list|>
name|collectorSources
init|=
operator|new
name|TreeMap
argument_list|<>
argument_list|()
decl_stmt|;
comment|// Iterate through all expression request to make a list of ValueSource strings
comment|// and statistics that need to be calculated on those ValueSources.
for|for
control|(
name|ExpressionRequest
name|expRequest
range|:
name|exRequests
control|)
block|{
name|String
name|statExpression
init|=
name|expRequest
operator|.
name|getExpressionString
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|String
argument_list|>
name|statistics
init|=
name|getStatistics
argument_list|(
name|statExpression
argument_list|)
decl_stmt|;
if|if
condition|(
name|statistics
operator|==
literal|null
condition|)
block|{
continue|continue;
block|}
for|for
control|(
name|String
name|statExp
range|:
name|statistics
control|)
block|{
name|String
name|stat
decl_stmt|;
name|String
name|operands
decl_stmt|;
try|try
block|{
name|stat
operator|=
name|statExp
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|statExp
operator|.
name|indexOf
argument_list|(
literal|'('
argument_list|)
argument_list|)
operator|.
name|trim
argument_list|()
expr_stmt|;
name|operands
operator|=
name|statExp
operator|.
name|substring
argument_list|(
name|statExp
operator|.
name|indexOf
argument_list|(
literal|'('
argument_list|)
operator|+
literal|1
argument_list|,
name|statExp
operator|.
name|lastIndexOf
argument_list|(
literal|')'
argument_list|)
argument_list|)
operator|.
name|trim
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
literal|"Unable to parse statistic: ["
operator|+
name|statExpression
operator|+
literal|"]"
argument_list|,
name|e
argument_list|)
throw|;
block|}
name|String
index|[]
name|arguments
init|=
name|ExpressionFactory
operator|.
name|getArguments
argument_list|(
name|operands
argument_list|)
decl_stmt|;
name|String
name|source
init|=
name|arguments
index|[
literal|0
index|]
decl_stmt|;
if|if
condition|(
name|stat
operator|.
name|equals
argument_list|(
name|AnalyticsParams
operator|.
name|STAT_PERCENTILE
argument_list|)
condition|)
block|{
comment|// The statistic is a percentile, extra parsing is required
if|if
condition|(
name|arguments
operator|.
name|length
operator|<
literal|2
condition|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
literal|"Too few arguments given for "
operator|+
name|stat
operator|+
literal|"() in ["
operator|+
name|statExp
operator|+
literal|"]."
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
name|arguments
operator|.
name|length
operator|>
literal|2
condition|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
literal|"Too many arguments given for "
operator|+
name|stat
operator|+
literal|"() in ["
operator|+
name|statExp
operator|+
literal|"]."
argument_list|)
throw|;
block|}
name|source
operator|=
name|arguments
index|[
literal|1
index|]
expr_stmt|;
name|Set
argument_list|<
name|Integer
argument_list|>
name|percs
init|=
name|collectorPercs
operator|.
name|get
argument_list|(
name|source
argument_list|)
decl_stmt|;
if|if
condition|(
name|percs
operator|==
literal|null
condition|)
block|{
name|percs
operator|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
expr_stmt|;
name|collectorPercs
operator|.
name|put
argument_list|(
name|source
argument_list|,
name|percs
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|int
name|perc
init|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|arguments
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|perc
operator|>
literal|0
operator|&&
name|perc
operator|<
literal|100
condition|)
block|{
name|percs
operator|.
name|add
argument_list|(
name|perc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
literal|"The percentile in ["
operator|+
name|statExp
operator|+
literal|"] is not between 0 and 100, exculsive."
argument_list|)
throw|;
block|}
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
literal|"\""
operator|+
name|arguments
index|[
literal|0
index|]
operator|+
literal|"\" cannot be converted into a percentile."
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
elseif|else
if|if
condition|(
name|arguments
operator|.
name|length
operator|>
literal|1
condition|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
literal|"Too many arguments given for "
operator|+
name|stat
operator|+
literal|"() in ["
operator|+
name|statExp
operator|+
literal|"]."
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
name|arguments
operator|.
name|length
operator|==
literal|0
condition|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
literal|"No arguments given for "
operator|+
name|stat
operator|+
literal|"() in ["
operator|+
name|statExp
operator|+
literal|"]."
argument_list|)
throw|;
block|}
comment|// Only unique ValueSources will be made; therefore statistics must be accumulated for
comment|// each ValueSource, even across different expression requests
name|Set
argument_list|<
name|String
argument_list|>
name|stats
init|=
name|collectorStats
operator|.
name|get
argument_list|(
name|source
argument_list|)
decl_stmt|;
if|if
condition|(
name|stats
operator|==
literal|null
condition|)
block|{
name|stats
operator|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
expr_stmt|;
name|collectorStats
operator|.
name|put
argument_list|(
name|source
argument_list|,
name|stats
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|AnalyticsParams
operator|.
name|STAT_PERCENTILE
operator|.
name|equals
argument_list|(
name|stat
argument_list|)
condition|)
block|{
name|stats
operator|.
name|add
argument_list|(
name|stat
operator|+
literal|"_"
operator|+
name|arguments
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|stats
operator|.
name|add
argument_list|(
name|stat
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|String
index|[]
name|keys
init|=
name|collectorStats
operator|.
name|keySet
argument_list|()
operator|.
name|toArray
argument_list|(
operator|new
name|String
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|sourceStr
range|:
name|keys
control|)
block|{
comment|// Build one ValueSource for each unique value source string
name|ValueSource
name|source
init|=
name|buildSourceTree
argument_list|(
name|schema
argument_list|,
name|sourceStr
argument_list|)
decl_stmt|;
if|if
condition|(
name|source
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
literal|"The statistic ["
operator|+
name|sourceStr
operator|+
literal|"] could not be parsed."
argument_list|)
throw|;
block|}
name|String
name|builtString
init|=
name|source
operator|.
name|toString
argument_list|()
decl_stmt|;
name|collectorSources
operator|.
name|put
argument_list|(
name|builtString
argument_list|,
name|source
argument_list|)
expr_stmt|;
comment|// Replace the user given string with the correctly built string
if|if
condition|(
operator|!
name|builtString
operator|.
name|equals
argument_list|(
name|sourceStr
argument_list|)
condition|)
block|{
name|Set
argument_list|<
name|String
argument_list|>
name|stats
init|=
name|collectorStats
operator|.
name|remove
argument_list|(
name|sourceStr
argument_list|)
decl_stmt|;
if|if
condition|(
name|stats
operator|!=
literal|null
condition|)
block|{
name|collectorStats
operator|.
name|put
argument_list|(
name|builtString
argument_list|,
name|stats
argument_list|)
expr_stmt|;
block|}
name|Set
argument_list|<
name|Integer
argument_list|>
name|percs
init|=
name|collectorPercs
operator|.
name|remove
argument_list|(
name|sourceStr
argument_list|)
decl_stmt|;
if|if
condition|(
name|percs
operator|!=
literal|null
condition|)
block|{
name|collectorPercs
operator|.
name|put
argument_list|(
name|builtString
argument_list|,
name|percs
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|ExpressionRequest
name|er
range|:
name|exRequests
control|)
block|{
name|er
operator|.
name|setExpressionString
argument_list|(
name|er
operator|.
name|getExpressionString
argument_list|()
operator|.
name|replace
argument_list|(
name|sourceStr
argument_list|,
name|builtString
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|collectorSources
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
operator|new
name|Supplier
argument_list|<
name|StatsCollector
index|[]
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|StatsCollector
index|[]
name|get
parameter_list|()
block|{
return|return
operator|new
name|StatsCollector
index|[
literal|0
index|]
return|;
block|}
block|}
return|;
block|}
name|log
operator|.
name|info
argument_list|(
literal|"Stats objects: "
operator|+
name|collectorStats
operator|.
name|size
argument_list|()
operator|+
literal|" sr="
operator|+
name|collectorSources
operator|.
name|size
argument_list|()
operator|+
literal|" pr="
operator|+
name|collectorPercs
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
comment|// All information is stored in final arrays so that nothing
comment|// has to be computed when the Supplier's get() method is called.
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
index|[]
name|statsArr
init|=
name|collectorStats
operator|.
name|values
argument_list|()
operator|.
name|toArray
argument_list|(
operator|new
name|Set
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
specifier|final
name|ValueSource
index|[]
name|sourceArr
init|=
name|collectorSources
operator|.
name|values
argument_list|()
operator|.
name|toArray
argument_list|(
operator|new
name|ValueSource
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
specifier|final
name|boolean
index|[]
name|uniqueBools
init|=
operator|new
name|boolean
index|[
name|statsArr
operator|.
name|length
index|]
decl_stmt|;
specifier|final
name|boolean
index|[]
name|medianBools
init|=
operator|new
name|boolean
index|[
name|statsArr
operator|.
name|length
index|]
decl_stmt|;
specifier|final
name|boolean
index|[]
name|numericBools
init|=
operator|new
name|boolean
index|[
name|statsArr
operator|.
name|length
index|]
decl_stmt|;
specifier|final
name|boolean
index|[]
name|dateBools
init|=
operator|new
name|boolean
index|[
name|statsArr
operator|.
name|length
index|]
decl_stmt|;
specifier|final
name|double
index|[]
index|[]
name|percsArr
init|=
operator|new
name|double
index|[
name|statsArr
operator|.
name|length
index|]
index|[]
decl_stmt|;
specifier|final
name|String
index|[]
index|[]
name|percsNames
init|=
operator|new
name|String
index|[
name|statsArr
operator|.
name|length
index|]
index|[]
decl_stmt|;
for|for
control|(
name|int
name|count
init|=
literal|0
init|;
name|count
operator|<
name|sourceArr
operator|.
name|length
condition|;
name|count
operator|++
control|)
block|{
name|uniqueBools
index|[
name|count
index|]
operator|=
name|statsArr
index|[
name|count
index|]
operator|.
name|contains
argument_list|(
name|AnalyticsParams
operator|.
name|STAT_UNIQUE
argument_list|)
expr_stmt|;
name|medianBools
index|[
name|count
index|]
operator|=
name|statsArr
index|[
name|count
index|]
operator|.
name|contains
argument_list|(
name|AnalyticsParams
operator|.
name|STAT_MEDIAN
argument_list|)
expr_stmt|;
name|numericBools
index|[
name|count
index|]
operator|=
name|statsArr
index|[
name|count
index|]
operator|.
name|contains
argument_list|(
name|AnalyticsParams
operator|.
name|STAT_SUM
argument_list|)
operator|||
name|statsArr
index|[
name|count
index|]
operator|.
name|contains
argument_list|(
name|AnalyticsParams
operator|.
name|STAT_SUM_OF_SQUARES
argument_list|)
operator|||
name|statsArr
index|[
name|count
index|]
operator|.
name|contains
argument_list|(
name|AnalyticsParams
operator|.
name|STAT_MEAN
argument_list|)
operator|||
name|statsArr
index|[
name|count
index|]
operator|.
name|contains
argument_list|(
name|AnalyticsParams
operator|.
name|STAT_STANDARD_DEVIATION
argument_list|)
expr_stmt|;
name|dateBools
index|[
name|count
index|]
operator|=
operator|(
name|sourceArr
index|[
name|count
index|]
operator|instanceof
name|DateFieldSource
operator|)
operator||
operator|(
name|sourceArr
index|[
name|count
index|]
operator|instanceof
name|MultiDateFunction
operator|)
operator||
operator|(
name|sourceArr
index|[
name|count
index|]
operator|instanceof
name|ConstDateSource
operator|)
expr_stmt|;
name|Set
argument_list|<
name|Integer
argument_list|>
name|ps
init|=
name|collectorPercs
operator|.
name|get
argument_list|(
name|sourceArr
index|[
name|count
index|]
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|ps
operator|!=
literal|null
condition|)
block|{
name|percsArr
index|[
name|count
index|]
operator|=
operator|new
name|double
index|[
name|ps
operator|.
name|size
argument_list|()
index|]
expr_stmt|;
name|percsNames
index|[
name|count
index|]
operator|=
operator|new
name|String
index|[
name|ps
operator|.
name|size
argument_list|()
index|]
expr_stmt|;
name|int
name|percCount
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|p
range|:
name|ps
control|)
block|{
name|percsArr
index|[
name|count
index|]
index|[
name|percCount
index|]
operator|=
name|p
operator|/
literal|100.0
expr_stmt|;
name|percsNames
index|[
name|count
index|]
index|[
name|percCount
operator|++
index|]
operator|=
name|AnalyticsParams
operator|.
name|STAT_PERCENTILE
operator|+
literal|"_"
operator|+
name|p
expr_stmt|;
block|}
block|}
block|}
comment|// Making the Supplier
return|return
operator|new
name|Supplier
argument_list|<
name|StatsCollector
index|[]
argument_list|>
argument_list|()
block|{
specifier|public
name|StatsCollector
index|[]
name|get
parameter_list|()
block|{
name|StatsCollector
index|[]
name|collectors
init|=
operator|new
name|StatsCollector
index|[
name|statsArr
operator|.
name|length
index|]
decl_stmt|;
for|for
control|(
name|int
name|count
init|=
literal|0
init|;
name|count
operator|<
name|statsArr
operator|.
name|length
condition|;
name|count
operator|++
control|)
block|{
if|if
condition|(
name|numericBools
index|[
name|count
index|]
condition|)
block|{
name|StatsCollector
name|sc
init|=
operator|new
name|NumericStatsCollector
argument_list|(
name|sourceArr
index|[
name|count
index|]
argument_list|,
name|statsArr
index|[
name|count
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|uniqueBools
index|[
name|count
index|]
condition|)
name|sc
operator|=
operator|new
name|UniqueStatsCollector
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|medianBools
index|[
name|count
index|]
condition|)
name|sc
operator|=
operator|new
name|MedianStatsCollector
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|percsArr
index|[
name|count
index|]
operator|!=
literal|null
condition|)
name|sc
operator|=
operator|new
name|PercentileStatsCollector
argument_list|(
name|sc
argument_list|,
name|percsArr
index|[
name|count
index|]
argument_list|,
name|percsNames
index|[
name|count
index|]
argument_list|)
expr_stmt|;
name|collectors
index|[
name|count
index|]
operator|=
name|sc
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dateBools
index|[
name|count
index|]
condition|)
block|{
name|StatsCollector
name|sc
init|=
operator|new
name|MinMaxStatsCollector
argument_list|(
name|sourceArr
index|[
name|count
index|]
argument_list|,
name|statsArr
index|[
name|count
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|uniqueBools
index|[
name|count
index|]
condition|)
name|sc
operator|=
operator|new
name|UniqueStatsCollector
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|medianBools
index|[
name|count
index|]
condition|)
name|sc
operator|=
operator|new
name|DateMedianStatsCollector
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|percsArr
index|[
name|count
index|]
operator|!=
literal|null
condition|)
name|sc
operator|=
operator|new
name|PercentileStatsCollector
argument_list|(
name|sc
argument_list|,
name|percsArr
index|[
name|count
index|]
argument_list|,
name|percsNames
index|[
name|count
index|]
argument_list|)
expr_stmt|;
name|collectors
index|[
name|count
index|]
operator|=
name|sc
expr_stmt|;
block|}
else|else
block|{
name|StatsCollector
name|sc
init|=
operator|new
name|MinMaxStatsCollector
argument_list|(
name|sourceArr
index|[
name|count
index|]
argument_list|,
name|statsArr
index|[
name|count
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|uniqueBools
index|[
name|count
index|]
condition|)
name|sc
operator|=
operator|new
name|UniqueStatsCollector
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|medianBools
index|[
name|count
index|]
condition|)
name|sc
operator|=
operator|new
name|MedianStatsCollector
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|percsArr
index|[
name|count
index|]
operator|!=
literal|null
condition|)
name|sc
operator|=
operator|new
name|PercentileStatsCollector
argument_list|(
name|sc
argument_list|,
name|percsArr
index|[
name|count
index|]
argument_list|,
name|percsNames
index|[
name|count
index|]
argument_list|)
expr_stmt|;
name|collectors
index|[
name|count
index|]
operator|=
name|sc
expr_stmt|;
block|}
block|}
return|return
name|collectors
return|;
block|}
block|}
return|;
block|}
comment|/**    * Finds the set of statistics that must be computed for the expression.    * @param expression The string representation of an expression    * @return The set of statistics (sum, mean, median, etc.) found in the expression    */
DECL|method|getStatistics
specifier|public
specifier|static
name|Set
argument_list|<
name|String
argument_list|>
name|getStatistics
parameter_list|(
name|String
name|expression
parameter_list|)
block|{
name|HashSet
argument_list|<
name|String
argument_list|>
name|set
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
name|int
name|firstParen
init|=
name|expression
operator|.
name|indexOf
argument_list|(
literal|'('
argument_list|)
decl_stmt|;
if|if
condition|(
name|firstParen
operator|>
literal|0
condition|)
block|{
name|String
name|topOperation
init|=
name|expression
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|firstParen
argument_list|)
operator|.
name|trim
argument_list|()
decl_stmt|;
if|if
condition|(
name|AnalyticsParams
operator|.
name|ALL_STAT_SET
operator|.
name|contains
argument_list|(
name|topOperation
argument_list|)
condition|)
block|{
name|set
operator|.
name|add
argument_list|(
name|expression
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|topOperation
operator|.
name|equals
argument_list|(
name|AnalyticsParams
operator|.
name|CONSTANT_NUMBER
argument_list|)
operator|||
name|topOperation
operator|.
name|equals
argument_list|(
name|AnalyticsParams
operator|.
name|CONSTANT_DATE
argument_list|)
operator|||
name|topOperation
operator|.
name|equals
argument_list|(
name|AnalyticsParams
operator|.
name|CONSTANT_STRING
argument_list|)
operator|)
condition|)
block|{
name|String
name|operands
init|=
name|expression
operator|.
name|substring
argument_list|(
name|firstParen
operator|+
literal|1
argument_list|,
name|expression
operator|.
name|lastIndexOf
argument_list|(
literal|')'
argument_list|)
argument_list|)
operator|.
name|trim
argument_list|()
decl_stmt|;
name|String
index|[]
name|arguments
init|=
name|ExpressionFactory
operator|.
name|getArguments
argument_list|(
name|operands
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|argument
range|:
name|arguments
control|)
block|{
name|Set
argument_list|<
name|String
argument_list|>
name|more
init|=
name|getStatistics
argument_list|(
name|argument
argument_list|)
decl_stmt|;
if|if
condition|(
name|more
operator|!=
literal|null
condition|)
block|{
name|set
operator|.
name|addAll
argument_list|(
name|more
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|set
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|set
return|;
block|}
comment|/**    * Builds a Value Source from a given string    *     * @param schema The schema being used.    * @param expression The string to be turned into an expression.    * @return The completed ValueSource    */
DECL|method|buildSourceTree
specifier|private
specifier|static
name|ValueSource
name|buildSourceTree
parameter_list|(
name|IndexSchema
name|schema
parameter_list|,
name|String
name|expression
parameter_list|)
block|{
return|return
name|buildSourceTree
argument_list|(
name|schema
argument_list|,
name|expression
argument_list|,
name|FIELD_TYPE
argument_list|)
return|;
block|}
comment|/**    * Builds a Value Source from a given string and a given source type    *     * @param schema The schema being used.    * @param expression The string to be turned into an expression.    * @param sourceType The type of source that must be returned.    * @return The completed ValueSource    */
DECL|method|buildSourceTree
specifier|private
specifier|static
name|ValueSource
name|buildSourceTree
parameter_list|(
name|IndexSchema
name|schema
parameter_list|,
name|String
name|expression
parameter_list|,
name|int
name|sourceType
parameter_list|)
block|{
name|int
name|expressionType
init|=
name|getSourceType
argument_list|(
name|expression
argument_list|)
decl_stmt|;
if|if
condition|(
name|sourceType
operator|!=
name|FIELD_TYPE
operator|&&
name|expressionType
operator|!=
name|FIELD_TYPE
operator|&&
name|expressionType
operator|!=
name|FILTER_TYPE
operator|&&
name|expressionType
operator|!=
name|sourceType
condition|)
block|{
return|return
literal|null
return|;
block|}
switch|switch
condition|(
name|expressionType
condition|)
block|{
case|case
name|NUMBER_TYPE
case|:
return|return
name|buildNumericSource
argument_list|(
name|schema
argument_list|,
name|expression
argument_list|)
return|;
case|case
name|DATE_TYPE
case|:
return|return
name|buildDateSource
argument_list|(
name|schema
argument_list|,
name|expression
argument_list|)
return|;
case|case
name|STRING_TYPE
case|:
return|return
name|buildStringSource
argument_list|(
name|schema
argument_list|,
name|expression
argument_list|)
return|;
case|case
name|FIELD_TYPE
case|:
return|return
name|buildFieldSource
argument_list|(
name|schema
argument_list|,
name|expression
argument_list|,
name|sourceType
argument_list|)
return|;
case|case
name|FILTER_TYPE
case|:
return|return
name|buildFilterSource
argument_list|(
name|schema
argument_list|,
name|expression
operator|.
name|substring
argument_list|(
name|expression
operator|.
name|indexOf
argument_list|(
literal|'('
argument_list|)
operator|+
literal|1
argument_list|,
name|expression
operator|.
name|lastIndexOf
argument_list|(
literal|')'
argument_list|)
argument_list|)
argument_list|,
name|sourceType
argument_list|)
return|;
default|default :
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
name|expression
operator|+
literal|" is not a valid operation."
argument_list|)
throw|;
block|}
block|}
comment|/**    * Determines what type of value source the expression represents.    *     * @param expression The expression representing the desired ValueSource    * @return NUMBER_TYPE, DATE_TYPE, STRING_TYPE or -1    */
DECL|method|getSourceType
specifier|private
specifier|static
name|int
name|getSourceType
parameter_list|(
name|String
name|expression
parameter_list|)
block|{
name|int
name|paren
init|=
name|expression
operator|.
name|indexOf
argument_list|(
literal|'('
argument_list|)
decl_stmt|;
if|if
condition|(
name|paren
operator|<
literal|0
condition|)
block|{
return|return
name|FIELD_TYPE
return|;
block|}
name|String
name|operation
init|=
name|expression
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|paren
argument_list|)
operator|.
name|trim
argument_list|()
decl_stmt|;
if|if
condition|(
name|AnalyticsParams
operator|.
name|NUMERIC_OPERATION_SET
operator|.
name|contains
argument_list|(
name|operation
argument_list|)
condition|)
block|{
return|return
name|NUMBER_TYPE
return|;
block|}
elseif|else
if|if
condition|(
name|AnalyticsParams
operator|.
name|DATE_OPERATION_SET
operator|.
name|contains
argument_list|(
name|operation
argument_list|)
condition|)
block|{
return|return
name|DATE_TYPE
return|;
block|}
elseif|else
if|if
condition|(
name|AnalyticsParams
operator|.
name|STRING_OPERATION_SET
operator|.
name|contains
argument_list|(
name|operation
argument_list|)
condition|)
block|{
return|return
name|STRING_TYPE
return|;
block|}
elseif|else
if|if
condition|(
name|operation
operator|.
name|equals
argument_list|(
name|AnalyticsParams
operator|.
name|FILTER
argument_list|)
condition|)
block|{
return|return
name|FILTER_TYPE
return|;
block|}
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
literal|"The operation \""
operator|+
name|operation
operator|+
literal|"\" in ["
operator|+
name|expression
operator|+
literal|"] is not supported."
argument_list|)
throw|;
block|}
comment|/**    *  Builds a value source for a given field, making sure that the field fits a given source type.    * @param schema the schema    * @param expressionString The name of the field to build a Field Source from.    * @param sourceType FIELD_TYPE for any type of field, NUMBER_TYPE for numeric fields,     * DATE_TYPE for date fields and STRING_TYPE for string fields.    * @return a value source    */
DECL|method|buildFieldSource
specifier|private
specifier|static
name|ValueSource
name|buildFieldSource
parameter_list|(
name|IndexSchema
name|schema
parameter_list|,
name|String
name|expressionString
parameter_list|,
name|int
name|sourceType
parameter_list|)
block|{
name|SchemaField
name|sf
decl_stmt|;
try|try
block|{
name|sf
operator|=
name|schema
operator|.
name|getField
argument_list|(
name|expressionString
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SolrException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
literal|"The field "
operator|+
name|expressionString
operator|+
literal|" does not exist."
argument_list|,
name|e
argument_list|)
throw|;
block|}
name|FieldType
name|type
init|=
name|sf
operator|.
name|getType
argument_list|()
decl_stmt|;
if|if
condition|(
name|type
operator|instanceof
name|TrieIntField
condition|)
block|{
if|if
condition|(
name|sourceType
operator|!=
name|NUMBER_TYPE
operator|&&
name|sourceType
operator|!=
name|FIELD_TYPE
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
operator|new
name|IntFieldSource
argument_list|(
name|expressionString
argument_list|)
block|{
specifier|public
name|String
name|description
parameter_list|()
block|{
return|return
name|field
return|;
block|}
block|}
return|;
block|}
elseif|else
if|if
condition|(
name|type
operator|instanceof
name|TrieLongField
condition|)
block|{
if|if
condition|(
name|sourceType
operator|!=
name|NUMBER_TYPE
operator|&&
name|sourceType
operator|!=
name|FIELD_TYPE
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
operator|new
name|LongFieldSource
argument_list|(
name|expressionString
argument_list|)
block|{
specifier|public
name|String
name|description
parameter_list|()
block|{
return|return
name|field
return|;
block|}
block|}
return|;
block|}
elseif|else
if|if
condition|(
name|type
operator|instanceof
name|TrieFloatField
condition|)
block|{
if|if
condition|(
name|sourceType
operator|!=
name|NUMBER_TYPE
operator|&&
name|sourceType
operator|!=
name|FIELD_TYPE
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
operator|new
name|FloatFieldSource
argument_list|(
name|expressionString
argument_list|)
block|{
specifier|public
name|String
name|description
parameter_list|()
block|{
return|return
name|field
return|;
block|}
block|}
return|;
block|}
elseif|else
if|if
condition|(
name|type
operator|instanceof
name|TrieDoubleField
condition|)
block|{
if|if
condition|(
name|sourceType
operator|!=
name|NUMBER_TYPE
operator|&&
name|sourceType
operator|!=
name|FIELD_TYPE
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
operator|new
name|DoubleFieldSource
argument_list|(
name|expressionString
argument_list|)
block|{
specifier|public
name|String
name|description
parameter_list|()
block|{
return|return
name|field
return|;
block|}
block|}
return|;
block|}
elseif|else
if|if
condition|(
name|type
operator|instanceof
name|TrieDateField
condition|)
block|{
if|if
condition|(
name|sourceType
operator|!=
name|DATE_TYPE
operator|&&
name|sourceType
operator|!=
name|FIELD_TYPE
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
operator|new
name|DateFieldSource
argument_list|(
name|expressionString
argument_list|)
block|{
specifier|public
name|String
name|description
parameter_list|()
block|{
return|return
name|field
return|;
block|}
block|}
return|;
block|}
elseif|else
if|if
condition|(
name|type
operator|instanceof
name|StrField
condition|)
block|{
if|if
condition|(
name|sourceType
operator|!=
name|STRING_TYPE
operator|&&
name|sourceType
operator|!=
name|FIELD_TYPE
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
operator|new
name|BytesRefFieldSource
argument_list|(
name|expressionString
argument_list|)
block|{
specifier|public
name|String
name|description
parameter_list|()
block|{
return|return
name|field
return|;
block|}
block|}
return|;
block|}
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
name|type
operator|.
name|toString
argument_list|()
operator|+
literal|" is not a supported field type in Solr Analytics."
argument_list|)
throw|;
block|}
comment|/**    * Builds a default is missing source that wraps a given source. A missing value is required for all     * non-field value sources.    * @param schema the schema    * @param expressionString The name of the field to build a Field Source from.    * @param sourceType FIELD_TYPE for any type of field, NUMBER_TYPE for numeric fields,     * DATE_TYPE for date fields and STRING_TYPE for string fields.    * @return a value source    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"deprecation"
argument_list|)
DECL|method|buildFilterSource
specifier|private
specifier|static
name|ValueSource
name|buildFilterSource
parameter_list|(
name|IndexSchema
name|schema
parameter_list|,
name|String
name|expressionString
parameter_list|,
name|int
name|sourceType
parameter_list|)
block|{
name|String
index|[]
name|arguments
init|=
name|ExpressionFactory
operator|.
name|getArguments
argument_list|(
name|expressionString
argument_list|)
decl_stmt|;
if|if
condition|(
name|arguments
operator|.
name|length
operator|!=
literal|2
condition|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
literal|"Invalid arguments were given for \""
operator|+
name|AnalyticsParams
operator|.
name|FILTER
operator|+
literal|"\"."
argument_list|)
throw|;
block|}
name|ValueSource
name|delegateSource
init|=
name|buildSourceTree
argument_list|(
name|schema
argument_list|,
name|arguments
index|[
literal|0
index|]
argument_list|,
name|sourceType
argument_list|)
decl_stmt|;
if|if
condition|(
name|delegateSource
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|Object
name|defaultObject
decl_stmt|;
name|ValueSource
name|src
init|=
name|delegateSource
decl_stmt|;
if|if
condition|(
name|delegateSource
operator|instanceof
name|FilterFieldSource
condition|)
block|{
name|src
operator|=
operator|(
operator|(
name|FilterFieldSource
operator|)
name|delegateSource
operator|)
operator|.
name|getRootSource
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|src
operator|instanceof
name|IntFieldSource
condition|)
block|{
try|try
block|{
name|defaultObject
operator|=
operator|new
name|Integer
argument_list|(
name|arguments
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
literal|"The filter value "
operator|+
name|arguments
index|[
literal|1
index|]
operator|+
literal|" cannot be converted into an integer."
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
elseif|else
if|if
condition|(
name|src
operator|instanceof
name|DateFieldSource
operator|||
name|src
operator|instanceof
name|MultiDateFunction
condition|)
block|{
try|try
block|{
name|defaultObject
operator|=
name|DateFormatUtil
operator|.
name|parseDate
argument_list|(
name|arguments
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ParseException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
literal|"The filter value "
operator|+
name|arguments
index|[
literal|1
index|]
operator|+
literal|" cannot be converted into a date."
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
elseif|else
if|if
condition|(
name|src
operator|instanceof
name|LongFieldSource
condition|)
block|{
try|try
block|{
name|defaultObject
operator|=
operator|new
name|Long
argument_list|(
name|arguments
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
literal|"The filter value "
operator|+
name|arguments
index|[
literal|1
index|]
operator|+
literal|" cannot be converted into a long."
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
elseif|else
if|if
condition|(
name|src
operator|instanceof
name|FloatFieldSource
condition|)
block|{
try|try
block|{
name|defaultObject
operator|=
operator|new
name|Float
argument_list|(
name|arguments
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
literal|"The filter value "
operator|+
name|arguments
index|[
literal|1
index|]
operator|+
literal|" cannot be converted into a float."
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
elseif|else
if|if
condition|(
name|src
operator|instanceof
name|DoubleFieldSource
operator|||
name|src
operator|instanceof
name|SingleDoubleFunction
operator|||
name|src
operator|instanceof
name|DualDoubleFunction
operator|||
name|src
operator|instanceof
name|MultiDoubleFunction
condition|)
block|{
try|try
block|{
name|defaultObject
operator|=
operator|new
name|Double
argument_list|(
name|arguments
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
literal|"The filter value "
operator|+
name|arguments
index|[
literal|1
index|]
operator|+
literal|" cannot be converted into a double."
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
else|else
block|{
name|defaultObject
operator|=
name|arguments
index|[
literal|1
index|]
expr_stmt|;
block|}
return|return
operator|new
name|FilterFieldSource
argument_list|(
name|delegateSource
argument_list|,
name|defaultObject
argument_list|)
return|;
block|}
comment|/**    * Recursively parses and breaks down the expression string to build a numeric ValueSource.    *     * @param schema The schema to pull fields from.    * @param expressionString The expression string to build a ValueSource from.    * @return The value source represented by the given expressionString    */
DECL|method|buildNumericSource
specifier|private
specifier|static
name|ValueSource
name|buildNumericSource
parameter_list|(
name|IndexSchema
name|schema
parameter_list|,
name|String
name|expressionString
parameter_list|)
block|{
name|int
name|paren
init|=
name|expressionString
operator|.
name|indexOf
argument_list|(
literal|'('
argument_list|)
decl_stmt|;
name|String
index|[]
name|arguments
decl_stmt|;
name|String
name|operands
decl_stmt|;
if|if
condition|(
name|paren
operator|<
literal|0
condition|)
block|{
return|return
name|buildFieldSource
argument_list|(
name|schema
argument_list|,
name|expressionString
argument_list|,
name|NUMBER_TYPE
argument_list|)
return|;
block|}
else|else
block|{
try|try
block|{
name|operands
operator|=
name|expressionString
operator|.
name|substring
argument_list|(
name|paren
operator|+
literal|1
argument_list|,
name|expressionString
operator|.
name|lastIndexOf
argument_list|(
literal|')'
argument_list|)
argument_list|)
operator|.
name|trim
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
literal|"Missing closing parenthesis in ["
operator|+
name|expressionString
operator|+
literal|"]"
argument_list|)
throw|;
block|}
name|arguments
operator|=
name|ExpressionFactory
operator|.
name|getArguments
argument_list|(
name|operands
argument_list|)
expr_stmt|;
block|}
name|String
name|operation
init|=
name|expressionString
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|paren
argument_list|)
operator|.
name|trim
argument_list|()
decl_stmt|;
if|if
condition|(
name|operation
operator|.
name|equals
argument_list|(
name|AnalyticsParams
operator|.
name|CONSTANT_NUMBER
argument_list|)
condition|)
block|{
if|if
condition|(
name|arguments
operator|.
name|length
operator|!=
literal|1
condition|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
literal|"The constant number declaration ["
operator|+
name|expressionString
operator|+
literal|"] does not have exactly 1 argument."
argument_list|)
throw|;
block|}
return|return
operator|new
name|ConstDoubleSource
argument_list|(
name|Double
operator|.
name|parseDouble
argument_list|(
name|arguments
index|[
literal|0
index|]
argument_list|)
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|operation
operator|.
name|equals
argument_list|(
name|AnalyticsParams
operator|.
name|NEGATE
argument_list|)
condition|)
block|{
if|if
condition|(
name|arguments
operator|.
name|length
operator|!=
literal|1
condition|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
literal|"The negate operation ["
operator|+
name|expressionString
operator|+
literal|"] does not have exactly 1 argument."
argument_list|)
throw|;
block|}
name|ValueSource
name|argSource
init|=
name|buildNumericSource
argument_list|(
name|schema
argument_list|,
name|arguments
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|argSource
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
literal|"The operation \""
operator|+
name|AnalyticsParams
operator|.
name|NEGATE
operator|+
literal|"\" requires a numeric field or operation as argument. \""
operator|+
name|arguments
index|[
literal|0
index|]
operator|+
literal|"\" is not a numeric field or operation."
argument_list|)
throw|;
block|}
return|return
operator|new
name|NegateDoubleFunction
argument_list|(
name|argSource
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|operation
operator|.
name|equals
argument_list|(
name|AnalyticsParams
operator|.
name|ABSOLUTE_VALUE
argument_list|)
condition|)
block|{
if|if
condition|(
name|arguments
operator|.
name|length
operator|!=
literal|1
condition|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
literal|"The absolute value operation ["
operator|+
name|expressionString
operator|+
literal|"] does not have exactly 1 argument."
argument_list|)
throw|;
block|}
name|ValueSource
name|argSource
init|=
name|buildNumericSource
argument_list|(
name|schema
argument_list|,
name|arguments
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|argSource
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
literal|"The operation \""
operator|+
name|AnalyticsParams
operator|.
name|NEGATE
operator|+
literal|"\" requires a numeric field or operation as argument. \""
operator|+
name|arguments
index|[
literal|0
index|]
operator|+
literal|"\" is not a numeric field or operation."
argument_list|)
throw|;
block|}
return|return
operator|new
name|AbsoluteValueDoubleFunction
argument_list|(
name|argSource
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|operation
operator|.
name|equals
argument_list|(
name|AnalyticsParams
operator|.
name|FILTER
argument_list|)
condition|)
block|{
return|return
name|buildFilterSource
argument_list|(
name|schema
argument_list|,
name|operands
argument_list|,
name|NUMBER_TYPE
argument_list|)
return|;
block|}
name|List
argument_list|<
name|ValueSource
argument_list|>
name|subExpressions
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|argument
range|:
name|arguments
control|)
block|{
name|ValueSource
name|argSource
init|=
name|buildNumericSource
argument_list|(
name|schema
argument_list|,
name|argument
argument_list|)
decl_stmt|;
if|if
condition|(
name|argSource
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
literal|"The operation \""
operator|+
name|operation
operator|+
literal|"\" requires numeric fields or operations as arguments. \""
operator|+
name|argument
operator|+
literal|"\" is not a numeric field or operation."
argument_list|)
throw|;
block|}
name|subExpressions
operator|.
name|add
argument_list|(
name|argSource
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|operation
operator|.
name|equals
argument_list|(
name|AnalyticsParams
operator|.
name|ADD
argument_list|)
condition|)
block|{
return|return
operator|new
name|AddDoubleFunction
argument_list|(
name|subExpressions
operator|.
name|toArray
argument_list|(
operator|new
name|ValueSource
index|[
literal|0
index|]
argument_list|)
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|operation
operator|.
name|equals
argument_list|(
name|AnalyticsParams
operator|.
name|MULTIPLY
argument_list|)
condition|)
block|{
return|return
operator|new
name|MultiplyDoubleFunction
argument_list|(
name|subExpressions
operator|.
name|toArray
argument_list|(
operator|new
name|ValueSource
index|[
literal|0
index|]
argument_list|)
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|operation
operator|.
name|equals
argument_list|(
name|AnalyticsParams
operator|.
name|DIVIDE
argument_list|)
condition|)
block|{
if|if
condition|(
name|subExpressions
operator|.
name|size
argument_list|()
operator|!=
literal|2
condition|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
literal|"The divide operation ["
operator|+
name|expressionString
operator|+
literal|"] does not have exactly 2 arguments."
argument_list|)
throw|;
block|}
return|return
operator|new
name|DivDoubleFunction
argument_list|(
name|subExpressions
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
name|subExpressions
operator|.
name|get
argument_list|(
literal|1
argument_list|)
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|operation
operator|.
name|equals
argument_list|(
name|AnalyticsParams
operator|.
name|POWER
argument_list|)
condition|)
block|{
if|if
condition|(
name|subExpressions
operator|.
name|size
argument_list|()
operator|!=
literal|2
condition|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
literal|"The power operation ["
operator|+
name|expressionString
operator|+
literal|"] does not have exactly 2 arguments."
argument_list|)
throw|;
block|}
return|return
operator|new
name|PowDoubleFunction
argument_list|(
name|subExpressions
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
name|subExpressions
operator|.
name|get
argument_list|(
literal|1
argument_list|)
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|operation
operator|.
name|equals
argument_list|(
name|AnalyticsParams
operator|.
name|LOG
argument_list|)
condition|)
block|{
if|if
condition|(
name|subExpressions
operator|.
name|size
argument_list|()
operator|!=
literal|2
condition|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
literal|"The log operation ["
operator|+
name|expressionString
operator|+
literal|"] does not have exactly 2 arguments."
argument_list|)
throw|;
block|}
return|return
operator|new
name|LogDoubleFunction
argument_list|(
name|subExpressions
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
name|subExpressions
operator|.
name|get
argument_list|(
literal|1
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
name|AnalyticsParams
operator|.
name|DATE_OPERATION_SET
operator|.
name|contains
argument_list|(
name|operation
argument_list|)
operator|||
name|AnalyticsParams
operator|.
name|STRING_OPERATION_SET
operator|.
name|contains
argument_list|(
name|operation
argument_list|)
condition|)
block|{
return|return
literal|null
return|;
block|}
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
literal|"The operation ["
operator|+
name|expressionString
operator|+
literal|"] is not supported."
argument_list|)
throw|;
block|}
comment|/**    * Recursively parses and breaks down the expression string to build a date ValueSource.    *     * @param schema The schema to pull fields from.    * @param expressionString The expression string to build a ValueSource from.    * @return The value source represented by the given expressionString    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"deprecation"
argument_list|)
DECL|method|buildDateSource
specifier|private
specifier|static
name|ValueSource
name|buildDateSource
parameter_list|(
name|IndexSchema
name|schema
parameter_list|,
name|String
name|expressionString
parameter_list|)
block|{
name|int
name|paren
init|=
name|expressionString
operator|.
name|indexOf
argument_list|(
literal|'('
argument_list|)
decl_stmt|;
name|String
index|[]
name|arguments
decl_stmt|;
if|if
condition|(
name|paren
operator|<
literal|0
condition|)
block|{
return|return
name|buildFieldSource
argument_list|(
name|schema
argument_list|,
name|expressionString
argument_list|,
name|DATE_TYPE
argument_list|)
return|;
block|}
else|else
block|{
name|arguments
operator|=
name|ExpressionFactory
operator|.
name|getArguments
argument_list|(
name|expressionString
operator|.
name|substring
argument_list|(
name|paren
operator|+
literal|1
argument_list|,
name|expressionString
operator|.
name|lastIndexOf
argument_list|(
literal|')'
argument_list|)
argument_list|)
operator|.
name|trim
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|String
name|operands
init|=
name|arguments
index|[
literal|0
index|]
decl_stmt|;
name|String
name|operation
init|=
name|expressionString
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|paren
argument_list|)
operator|.
name|trim
argument_list|()
decl_stmt|;
if|if
condition|(
name|operation
operator|.
name|equals
argument_list|(
name|AnalyticsParams
operator|.
name|CONSTANT_DATE
argument_list|)
condition|)
block|{
if|if
condition|(
name|arguments
operator|.
name|length
operator|!=
literal|1
condition|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
literal|"The constant date declaration ["
operator|+
name|expressionString
operator|+
literal|"] does not have exactly 1 argument."
argument_list|)
throw|;
block|}
try|try
block|{
return|return
operator|new
name|ConstDateSource
argument_list|(
name|DateFormatUtil
operator|.
name|parseDate
argument_list|(
name|operands
argument_list|)
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|ParseException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
literal|"The constant "
operator|+
name|operands
operator|+
literal|" cannot be converted into a date."
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
elseif|else
if|if
condition|(
name|operation
operator|.
name|equals
argument_list|(
name|AnalyticsParams
operator|.
name|FILTER
argument_list|)
condition|)
block|{
return|return
name|buildFilterSource
argument_list|(
name|schema
argument_list|,
name|operands
argument_list|,
name|DATE_TYPE
argument_list|)
return|;
block|}
if|if
condition|(
name|operation
operator|.
name|equals
argument_list|(
name|AnalyticsParams
operator|.
name|DATE_MATH
argument_list|)
condition|)
block|{
name|List
argument_list|<
name|ValueSource
argument_list|>
name|subExpressions
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|boolean
name|first
init|=
literal|true
decl_stmt|;
for|for
control|(
name|String
name|argument
range|:
name|arguments
control|)
block|{
name|ValueSource
name|argSource
decl_stmt|;
if|if
condition|(
name|first
condition|)
block|{
name|first
operator|=
literal|false
expr_stmt|;
name|argSource
operator|=
name|buildDateSource
argument_list|(
name|schema
argument_list|,
name|argument
argument_list|)
expr_stmt|;
if|if
condition|(
name|argSource
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
literal|"\""
operator|+
name|AnalyticsParams
operator|.
name|DATE_MATH
operator|+
literal|"\" requires the first argument be a date operation or field. ["
operator|+
name|argument
operator|+
literal|"] is not a date operation or field."
argument_list|)
throw|;
block|}
block|}
else|else
block|{
name|argSource
operator|=
name|buildStringSource
argument_list|(
name|schema
argument_list|,
name|argument
argument_list|)
expr_stmt|;
if|if
condition|(
name|argSource
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
literal|"\""
operator|+
name|AnalyticsParams
operator|.
name|DATE_MATH
operator|+
literal|"\" requires that all arguments except the first be string operations. ["
operator|+
name|argument
operator|+
literal|"] is not a string operation."
argument_list|)
throw|;
block|}
block|}
name|subExpressions
operator|.
name|add
argument_list|(
name|argSource
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|DateMathFunction
argument_list|(
name|subExpressions
operator|.
name|toArray
argument_list|(
operator|new
name|ValueSource
index|[
literal|0
index|]
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
name|AnalyticsParams
operator|.
name|NUMERIC_OPERATION_SET
operator|.
name|contains
argument_list|(
name|operation
argument_list|)
operator|||
name|AnalyticsParams
operator|.
name|STRING_OPERATION_SET
operator|.
name|contains
argument_list|(
name|operation
argument_list|)
condition|)
block|{
return|return
literal|null
return|;
block|}
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
literal|"The operation ["
operator|+
name|expressionString
operator|+
literal|"] is not supported."
argument_list|)
throw|;
block|}
comment|/**    * Recursively parses and breaks down the expression string to build a string ValueSource.    *     * @param schema The schema to pull fields from.    * @param expressionString The expression string to build a ValueSource from.    * @return The value source represented by the given expressionString    */
DECL|method|buildStringSource
specifier|private
specifier|static
name|ValueSource
name|buildStringSource
parameter_list|(
name|IndexSchema
name|schema
parameter_list|,
name|String
name|expressionString
parameter_list|)
block|{
name|int
name|paren
init|=
name|expressionString
operator|.
name|indexOf
argument_list|(
literal|'('
argument_list|)
decl_stmt|;
name|String
index|[]
name|arguments
decl_stmt|;
if|if
condition|(
name|paren
operator|<
literal|0
condition|)
block|{
return|return
name|buildFieldSource
argument_list|(
name|schema
argument_list|,
name|expressionString
argument_list|,
name|FIELD_TYPE
argument_list|)
return|;
block|}
else|else
block|{
name|arguments
operator|=
name|ExpressionFactory
operator|.
name|getArguments
argument_list|(
name|expressionString
operator|.
name|substring
argument_list|(
name|paren
operator|+
literal|1
argument_list|,
name|expressionString
operator|.
name|lastIndexOf
argument_list|(
literal|')'
argument_list|)
argument_list|)
operator|.
name|trim
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|String
name|operands
init|=
name|arguments
index|[
literal|0
index|]
decl_stmt|;
name|String
name|operation
init|=
name|expressionString
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|paren
argument_list|)
operator|.
name|trim
argument_list|()
decl_stmt|;
if|if
condition|(
name|operation
operator|.
name|equals
argument_list|(
name|AnalyticsParams
operator|.
name|CONSTANT_STRING
argument_list|)
condition|)
block|{
name|operands
operator|=
name|expressionString
operator|.
name|substring
argument_list|(
name|paren
operator|+
literal|1
argument_list|,
name|expressionString
operator|.
name|lastIndexOf
argument_list|(
literal|')'
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|new
name|ConstStringSource
argument_list|(
name|operands
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|operation
operator|.
name|equals
argument_list|(
name|AnalyticsParams
operator|.
name|FILTER
argument_list|)
condition|)
block|{
return|return
name|buildFilterSource
argument_list|(
name|schema
argument_list|,
name|operands
argument_list|,
name|FIELD_TYPE
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|operation
operator|.
name|equals
argument_list|(
name|AnalyticsParams
operator|.
name|REVERSE
argument_list|)
condition|)
block|{
if|if
condition|(
name|arguments
operator|.
name|length
operator|!=
literal|1
condition|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
literal|"\""
operator|+
name|AnalyticsParams
operator|.
name|REVERSE
operator|+
literal|"\" requires exactly one argument. The number of arguments in "
operator|+
name|expressionString
operator|+
literal|" is not 1."
argument_list|)
throw|;
block|}
return|return
operator|new
name|ReverseStringFunction
argument_list|(
name|buildStringSource
argument_list|(
name|schema
argument_list|,
name|operands
argument_list|)
argument_list|)
return|;
block|}
name|List
argument_list|<
name|ValueSource
argument_list|>
name|subExpressions
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|argument
range|:
name|arguments
control|)
block|{
name|subExpressions
operator|.
name|add
argument_list|(
name|buildSourceTree
argument_list|(
name|schema
argument_list|,
name|argument
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|operation
operator|.
name|equals
argument_list|(
name|AnalyticsParams
operator|.
name|CONCATENATE
argument_list|)
condition|)
block|{
return|return
operator|new
name|ConcatStringFunction
argument_list|(
name|subExpressions
operator|.
name|toArray
argument_list|(
operator|new
name|ValueSource
index|[
literal|0
index|]
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
name|AnalyticsParams
operator|.
name|NUMERIC_OPERATION_SET
operator|.
name|contains
argument_list|(
name|operation
argument_list|)
condition|)
block|{
return|return
name|buildNumericSource
argument_list|(
name|schema
argument_list|,
name|expressionString
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|AnalyticsParams
operator|.
name|DATE_OPERATION_SET
operator|.
name|contains
argument_list|(
name|operation
argument_list|)
condition|)
block|{
return|return
name|buildDateSource
argument_list|(
name|schema
argument_list|,
name|expressionString
argument_list|)
return|;
block|}
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
literal|"The operation ["
operator|+
name|expressionString
operator|+
literal|"] is not supported."
argument_list|)
throw|;
block|}
block|}
end_class
end_unit
