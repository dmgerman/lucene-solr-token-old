begin_unit
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_package
DECL|package|org.apache.solr.analytics.accumulator
package|package
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|analytics
operator|.
name|accumulator
package|;
end_package
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Date
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashMap
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
operator|.
name|Entry
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeMap
import|;
end_import
begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Iterables
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|LeafReaderContext
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|BooleanClause
operator|.
name|Occur
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|BooleanQuery
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|Query
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|analytics
operator|.
name|accumulator
operator|.
name|facet
operator|.
name|FacetValueAccumulator
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|analytics
operator|.
name|accumulator
operator|.
name|facet
operator|.
name|FieldFacetAccumulator
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|analytics
operator|.
name|accumulator
operator|.
name|facet
operator|.
name|QueryFacetAccumulator
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|analytics
operator|.
name|accumulator
operator|.
name|facet
operator|.
name|RangeFacetAccumulator
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|analytics
operator|.
name|expression
operator|.
name|Expression
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|analytics
operator|.
name|expression
operator|.
name|ExpressionFactory
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|analytics
operator|.
name|request
operator|.
name|AnalyticsContentHandler
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|analytics
operator|.
name|request
operator|.
name|AnalyticsRequest
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|analytics
operator|.
name|request
operator|.
name|FieldFacetRequest
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|analytics
operator|.
name|request
operator|.
name|FieldFacetRequest
operator|.
name|FacetSortSpecification
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|analytics
operator|.
name|request
operator|.
name|QueryFacetRequest
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|analytics
operator|.
name|request
operator|.
name|RangeFacetRequest
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|analytics
operator|.
name|statistics
operator|.
name|StatsCollector
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|analytics
operator|.
name|util
operator|.
name|AnalyticsParams
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|analytics
operator|.
name|util
operator|.
name|RangeEndpointCalculator
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|analytics
operator|.
name|util
operator|.
name|RangeEndpointCalculator
operator|.
name|FacetRange
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|SolrException
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|SolrException
operator|.
name|ErrorCode
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|util
operator|.
name|NamedList
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|request
operator|.
name|SolrQueryRequest
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|schema
operator|.
name|SchemaField
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|search
operator|.
name|DocSet
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|search
operator|.
name|Filter
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|search
operator|.
name|QParser
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|search
operator|.
name|SolrIndexSearcher
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|search
operator|.
name|SyntaxError
import|;
end_import
begin_comment
comment|/**  * A<code>FacetingAccumulator</code> manages the StatsCollectors and Expressions for facets.  */
end_comment
begin_class
DECL|class|FacetingAccumulator
specifier|public
class|class
name|FacetingAccumulator
extends|extends
name|BasicAccumulator
implements|implements
name|FacetValueAccumulator
block|{
DECL|field|MISSING_VALUE
specifier|public
specifier|static
specifier|final
name|String
name|MISSING_VALUE
init|=
literal|"(MISSING)"
decl_stmt|;
DECL|field|basicsAndFieldFacetsComputed
specifier|protected
name|boolean
name|basicsAndFieldFacetsComputed
decl_stmt|;
DECL|field|leafNum
specifier|protected
name|int
name|leafNum
decl_stmt|;
DECL|field|leaf
specifier|protected
name|LeafReaderContext
name|leaf
decl_stmt|;
DECL|field|analyticsRequest
specifier|protected
specifier|final
name|AnalyticsRequest
name|analyticsRequest
decl_stmt|;
DECL|field|fieldFacetExpressions
specifier|protected
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|Expression
index|[]
argument_list|>
argument_list|>
name|fieldFacetExpressions
decl_stmt|;
DECL|field|rangeFacetExpressions
specifier|protected
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|Expression
index|[]
argument_list|>
argument_list|>
name|rangeFacetExpressions
decl_stmt|;
DECL|field|queryFacetExpressions
specifier|protected
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|Expression
index|[]
argument_list|>
argument_list|>
name|queryFacetExpressions
decl_stmt|;
DECL|field|fieldFacetCollectors
specifier|protected
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|StatsCollector
index|[]
argument_list|>
argument_list|>
name|fieldFacetCollectors
decl_stmt|;
DECL|field|rangeFacetCollectors
specifier|protected
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|StatsCollector
index|[]
argument_list|>
argument_list|>
name|rangeFacetCollectors
decl_stmt|;
DECL|field|queryFacetCollectors
specifier|protected
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|StatsCollector
index|[]
argument_list|>
argument_list|>
name|queryFacetCollectors
decl_stmt|;
DECL|field|facetAccumulators
specifier|protected
specifier|final
name|List
argument_list|<
name|FieldFacetAccumulator
argument_list|>
name|facetAccumulators
decl_stmt|;
DECL|field|hiddenFieldFacets
specifier|protected
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|hiddenFieldFacets
decl_stmt|;
comment|/** the current value of this stat field */
DECL|field|queryRequest
specifier|protected
specifier|final
name|SolrQueryRequest
name|queryRequest
decl_stmt|;
DECL|field|rangeFacets
specifier|protected
name|List
argument_list|<
name|RangeFacetRequest
argument_list|>
name|rangeFacets
init|=
literal|null
decl_stmt|;
DECL|field|queryFacets
specifier|protected
name|List
argument_list|<
name|QueryFacetRequest
argument_list|>
name|queryFacets
init|=
literal|null
decl_stmt|;
DECL|field|queryCount
specifier|protected
name|long
name|queryCount
decl_stmt|;
DECL|method|FacetingAccumulator
specifier|public
name|FacetingAccumulator
parameter_list|(
name|SolrIndexSearcher
name|searcher
parameter_list|,
name|DocSet
name|docs
parameter_list|,
name|AnalyticsRequest
name|request
parameter_list|,
name|SolrQueryRequest
name|queryRequest
parameter_list|)
throws|throws
name|IOException
block|{
comment|// The parent Basic Accumulator keeps track of overall stats while
comment|// the Faceting Accumulator only manages the facet stats
name|super
argument_list|(
name|searcher
argument_list|,
name|docs
argument_list|,
name|request
argument_list|)
expr_stmt|;
name|this
operator|.
name|analyticsRequest
operator|=
name|request
expr_stmt|;
name|this
operator|.
name|queryRequest
operator|=
name|queryRequest
expr_stmt|;
name|basicsAndFieldFacetsComputed
operator|=
literal|false
expr_stmt|;
name|List
argument_list|<
name|FieldFacetRequest
argument_list|>
name|fieldFreqs
init|=
name|request
operator|.
name|getFieldFacets
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|RangeFacetRequest
argument_list|>
name|rangeFreqs
init|=
name|request
operator|.
name|getRangeFacets
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|QueryFacetRequest
argument_list|>
name|queryFreqs
init|=
name|request
operator|.
name|getQueryFacets
argument_list|()
decl_stmt|;
name|this
operator|.
name|fieldFacetExpressions
operator|=
operator|new
name|TreeMap
argument_list|<>
argument_list|()
expr_stmt|;
name|this
operator|.
name|rangeFacetExpressions
operator|=
operator|new
name|LinkedHashMap
argument_list|<>
argument_list|(
name|rangeFreqs
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|queryFacetExpressions
operator|=
operator|new
name|LinkedHashMap
argument_list|<>
argument_list|(
name|queryFreqs
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|fieldFacetCollectors
operator|=
operator|new
name|LinkedHashMap
argument_list|<>
argument_list|(
name|fieldFreqs
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|rangeFacetCollectors
operator|=
operator|new
name|LinkedHashMap
argument_list|<>
argument_list|(
name|rangeFreqs
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|queryFacetCollectors
operator|=
operator|new
name|LinkedHashMap
argument_list|<>
argument_list|(
name|queryFreqs
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|facetAccumulators
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
expr_stmt|;
name|this
operator|.
name|hiddenFieldFacets
operator|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
expr_stmt|;
comment|/**      * For each field facet request add a bucket to the {@link Expression} map and {@link StatsCollector} map.      * Field facets are computed during the initial collection of documents, therefore      * the FieldFacetAccumulators are created initially.      */
for|for
control|(
name|FieldFacetRequest
name|freq
range|:
name|fieldFreqs
control|)
block|{
specifier|final
name|FieldFacetRequest
name|fr
init|=
operator|(
name|FieldFacetRequest
operator|)
name|freq
decl_stmt|;
if|if
condition|(
name|fr
operator|.
name|isHidden
argument_list|()
condition|)
block|{
name|hiddenFieldFacets
operator|.
name|add
argument_list|(
name|fr
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
specifier|final
name|SchemaField
name|ff
init|=
name|fr
operator|.
name|getField
argument_list|()
decl_stmt|;
specifier|final
name|FieldFacetAccumulator
name|facc
init|=
name|FieldFacetAccumulator
operator|.
name|create
argument_list|(
name|searcher
argument_list|,
name|this
argument_list|,
name|ff
argument_list|)
decl_stmt|;
name|facetAccumulators
operator|.
name|add
argument_list|(
name|facc
argument_list|)
expr_stmt|;
name|fieldFacetExpressions
operator|.
name|put
argument_list|(
name|freq
operator|.
name|getName
argument_list|()
argument_list|,
operator|new
name|TreeMap
argument_list|<
name|String
argument_list|,
name|Expression
index|[]
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
name|fieldFacetCollectors
operator|.
name|put
argument_list|(
name|freq
operator|.
name|getName
argument_list|()
argument_list|,
operator|new
name|TreeMap
argument_list|<
name|String
argument_list|,
name|StatsCollector
index|[]
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**      * For each range and query facet request add a bucket to the corresponding      * {@link Expression} map and {@link StatsCollector} map.      * Range and Query Facets are computed in the post processing, so the accumulators      * are not created initially.      */
for|for
control|(
name|RangeFacetRequest
name|freq
range|:
name|rangeFreqs
control|)
block|{
if|if
condition|(
name|rangeFacets
operator|==
literal|null
condition|)
name|rangeFacets
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
expr_stmt|;
name|rangeFacets
operator|.
name|add
argument_list|(
name|freq
argument_list|)
expr_stmt|;
name|rangeFacetExpressions
operator|.
name|put
argument_list|(
name|freq
operator|.
name|getName
argument_list|()
argument_list|,
operator|new
name|LinkedHashMap
argument_list|<
name|String
argument_list|,
name|Expression
index|[]
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
name|rangeFacetCollectors
operator|.
name|put
argument_list|(
name|freq
operator|.
name|getName
argument_list|()
argument_list|,
operator|new
name|LinkedHashMap
argument_list|<
name|String
argument_list|,
name|StatsCollector
index|[]
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|QueryFacetRequest
name|freq
range|:
name|queryFreqs
control|)
block|{
if|if
condition|(
name|queryFacets
operator|==
literal|null
condition|)
name|queryFacets
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
expr_stmt|;
name|queryFacets
operator|.
name|add
argument_list|(
name|freq
argument_list|)
expr_stmt|;
name|queryFacetExpressions
operator|.
name|put
argument_list|(
name|freq
operator|.
name|getName
argument_list|()
argument_list|,
operator|new
name|LinkedHashMap
argument_list|<
name|String
argument_list|,
name|Expression
index|[]
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
name|queryFacetCollectors
operator|.
name|put
argument_list|(
name|freq
operator|.
name|getName
argument_list|()
argument_list|,
operator|new
name|LinkedHashMap
argument_list|<
name|String
argument_list|,
name|StatsCollector
index|[]
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|queryCount
operator|=
literal|0l
expr_stmt|;
block|}
DECL|method|create
specifier|public
specifier|static
name|FacetingAccumulator
name|create
parameter_list|(
name|SolrIndexSearcher
name|searcher
parameter_list|,
name|DocSet
name|docs
parameter_list|,
name|AnalyticsRequest
name|request
parameter_list|,
name|SolrQueryRequest
name|queryRequest
parameter_list|)
throws|throws
name|IOException
block|{
return|return
operator|new
name|FacetingAccumulator
argument_list|(
name|searcher
argument_list|,
name|docs
argument_list|,
name|request
argument_list|,
name|queryRequest
argument_list|)
return|;
block|}
comment|/**    * Update the readers for the {@link BasicAccumulator}, field facets and field facet {@link StatsCollector}s.    * @param context The context to read documents from.    * @throws IOException if there is an error setting the next reader    */
annotation|@
name|Override
DECL|method|doSetNextReader
specifier|protected
name|void
name|doSetNextReader
parameter_list|(
name|LeafReaderContext
name|context
parameter_list|)
throws|throws
name|IOException
block|{
name|super
operator|.
name|doSetNextReader
argument_list|(
name|context
argument_list|)
expr_stmt|;
for|for
control|(
name|Map
argument_list|<
name|String
argument_list|,
name|StatsCollector
index|[]
argument_list|>
name|valueList
range|:
name|fieldFacetCollectors
operator|.
name|values
argument_list|()
control|)
block|{
for|for
control|(
name|StatsCollector
index|[]
name|statsCollectorList
range|:
name|valueList
operator|.
name|values
argument_list|()
control|)
block|{
for|for
control|(
name|StatsCollector
name|statsCollector
range|:
name|statsCollectorList
control|)
block|{
name|statsCollector
operator|.
name|setNextReader
argument_list|(
name|context
argument_list|)
expr_stmt|;
block|}
block|}
block|}
for|for
control|(
name|FieldFacetAccumulator
name|fa
range|:
name|facetAccumulators
control|)
block|{
name|fa
operator|.
name|getLeafCollector
argument_list|(
name|context
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Updates the reader for all of the range facet {@link StatsCollector}s.    * @param context The context to read documents from.    * @throws IOException if there is an error setting the next reader    */
DECL|method|setRangeStatsCollectorReaders
specifier|public
name|void
name|setRangeStatsCollectorReaders
parameter_list|(
name|LeafReaderContext
name|context
parameter_list|)
throws|throws
name|IOException
block|{
name|super
operator|.
name|getLeafCollector
argument_list|(
name|context
argument_list|)
expr_stmt|;
for|for
control|(
name|Map
argument_list|<
name|String
argument_list|,
name|StatsCollector
index|[]
argument_list|>
name|rangeList
range|:
name|rangeFacetCollectors
operator|.
name|values
argument_list|()
control|)
block|{
for|for
control|(
name|StatsCollector
index|[]
name|statsCollectorList
range|:
name|rangeList
operator|.
name|values
argument_list|()
control|)
block|{
for|for
control|(
name|StatsCollector
name|statsCollector
range|:
name|statsCollectorList
control|)
block|{
name|statsCollector
operator|.
name|setNextReader
argument_list|(
name|context
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**    * Updates the reader for all of the query facet {@link StatsCollector}s.    * @param context The context to read documents from.    * @throws IOException if there is an error setting the next reader    */
DECL|method|setQueryStatsCollectorReaders
specifier|public
name|void
name|setQueryStatsCollectorReaders
parameter_list|(
name|LeafReaderContext
name|context
parameter_list|)
throws|throws
name|IOException
block|{
name|super
operator|.
name|getLeafCollector
argument_list|(
name|context
argument_list|)
expr_stmt|;
for|for
control|(
name|Map
argument_list|<
name|String
argument_list|,
name|StatsCollector
index|[]
argument_list|>
name|queryList
range|:
name|queryFacetCollectors
operator|.
name|values
argument_list|()
control|)
block|{
for|for
control|(
name|StatsCollector
index|[]
name|statsCollectorList
range|:
name|queryList
operator|.
name|values
argument_list|()
control|)
block|{
for|for
control|(
name|StatsCollector
name|statsCollector
range|:
name|statsCollectorList
control|)
block|{
name|statsCollector
operator|.
name|setNextReader
argument_list|(
name|context
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**    * Called from Analytics stats, adds documents to the field     * facets and the super {@link BasicAccumulator}.    */
annotation|@
name|Override
DECL|method|collect
specifier|public
name|void
name|collect
parameter_list|(
name|int
name|doc
parameter_list|)
throws|throws
name|IOException
block|{
for|for
control|(
name|FieldFacetAccumulator
name|fa
range|:
name|facetAccumulators
control|)
block|{
name|fa
operator|.
name|collect
argument_list|(
name|doc
argument_list|)
expr_stmt|;
block|}
name|super
operator|.
name|collect
argument_list|(
name|doc
argument_list|)
expr_stmt|;
block|}
comment|/**    * Given a document, fieldFacet field and facetValue, adds the document to the    * {@link StatsCollector}s held in the bucket corresponding to the fieldFacet field and facetValue.    * Called during initial document collection.    */
annotation|@
name|Override
DECL|method|collectField
specifier|public
name|void
name|collectField
parameter_list|(
name|int
name|doc
parameter_list|,
name|String
name|facetField
parameter_list|,
name|String
name|facetValue
parameter_list|)
throws|throws
name|IOException
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|StatsCollector
index|[]
argument_list|>
name|map
init|=
name|fieldFacetCollectors
operator|.
name|get
argument_list|(
name|facetField
argument_list|)
decl_stmt|;
name|StatsCollector
index|[]
name|statsCollectors
init|=
name|map
operator|.
name|get
argument_list|(
name|facetValue
argument_list|)
decl_stmt|;
comment|// If the facetValue has not been seen yet, a StatsCollector array is
comment|// created and associated with that bucket.
if|if
condition|(
name|statsCollectors
operator|==
literal|null
condition|)
block|{
name|statsCollectors
operator|=
name|statsCollectorArraySupplier
operator|.
name|get
argument_list|()
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
name|facetValue
argument_list|,
name|statsCollectors
argument_list|)
expr_stmt|;
name|fieldFacetExpressions
operator|.
name|get
argument_list|(
name|facetField
argument_list|)
operator|.
name|put
argument_list|(
name|facetValue
argument_list|,
name|makeExpressions
argument_list|(
name|statsCollectors
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|StatsCollector
name|statsCollector
range|:
name|statsCollectors
control|)
block|{
name|statsCollector
operator|.
name|setNextReader
argument_list|(
name|context
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|StatsCollector
name|statsCollector
range|:
name|statsCollectors
control|)
block|{
name|statsCollector
operator|.
name|collect
argument_list|(
name|doc
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Given a document, rangeFacet field and range, adds the document to the    * {@link StatsCollector}s held in the bucket corresponding to the rangeFacet field and range.    * Called during post processing.    */
annotation|@
name|Override
DECL|method|collectRange
specifier|public
name|void
name|collectRange
parameter_list|(
name|int
name|doc
parameter_list|,
name|String
name|facetField
parameter_list|,
name|String
name|range
parameter_list|)
throws|throws
name|IOException
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|StatsCollector
index|[]
argument_list|>
name|map
init|=
name|rangeFacetCollectors
operator|.
name|get
argument_list|(
name|facetField
argument_list|)
decl_stmt|;
name|StatsCollector
index|[]
name|statsCollectors
init|=
name|map
operator|.
name|get
argument_list|(
name|range
argument_list|)
decl_stmt|;
comment|// If the range has not been seen yet, a StatsCollector array is
comment|// created and associated with that bucket.
if|if
condition|(
name|statsCollectors
operator|==
literal|null
condition|)
block|{
name|statsCollectors
operator|=
name|statsCollectorArraySupplier
operator|.
name|get
argument_list|()
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
name|range
argument_list|,
name|statsCollectors
argument_list|)
expr_stmt|;
name|rangeFacetExpressions
operator|.
name|get
argument_list|(
name|facetField
argument_list|)
operator|.
name|put
argument_list|(
name|range
argument_list|,
name|makeExpressions
argument_list|(
name|statsCollectors
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|StatsCollector
name|statsCollector
range|:
name|statsCollectors
control|)
block|{
name|statsCollector
operator|.
name|setNextReader
argument_list|(
name|context
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|StatsCollector
name|statsCollector
range|:
name|statsCollectors
control|)
block|{
name|statsCollector
operator|.
name|collect
argument_list|(
name|doc
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Given a document, queryFacet name and query, adds the document to the    * {@link StatsCollector}s held in the bucket corresponding to the queryFacet name and query.    * Called during post processing.    */
annotation|@
name|Override
DECL|method|collectQuery
specifier|public
name|void
name|collectQuery
parameter_list|(
name|int
name|doc
parameter_list|,
name|String
name|facetName
parameter_list|,
name|String
name|query
parameter_list|)
throws|throws
name|IOException
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|StatsCollector
index|[]
argument_list|>
name|map
init|=
name|queryFacetCollectors
operator|.
name|get
argument_list|(
name|facetName
argument_list|)
decl_stmt|;
name|StatsCollector
index|[]
name|statsCollectors
init|=
name|map
operator|.
name|get
argument_list|(
name|query
argument_list|)
decl_stmt|;
comment|// If the query has not been seen yet, a StatsCollector array is
comment|// created and associated with that bucket.
if|if
condition|(
name|statsCollectors
operator|==
literal|null
condition|)
block|{
name|statsCollectors
operator|=
name|statsCollectorArraySupplier
operator|.
name|get
argument_list|()
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
name|query
argument_list|,
name|statsCollectors
argument_list|)
expr_stmt|;
name|queryFacetExpressions
operator|.
name|get
argument_list|(
name|facetName
argument_list|)
operator|.
name|put
argument_list|(
name|query
argument_list|,
name|makeExpressions
argument_list|(
name|statsCollectors
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|StatsCollector
name|statsCollector
range|:
name|statsCollectors
control|)
block|{
name|statsCollector
operator|.
name|setNextReader
argument_list|(
name|context
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|StatsCollector
name|statsCollector
range|:
name|statsCollectors
control|)
block|{
name|statsCollector
operator|.
name|collect
argument_list|(
name|doc
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * A comparator to compare expression values for field facet sorting.    */
DECL|class|EntryComparator
specifier|public
specifier|static
class|class
name|EntryComparator
implements|implements
name|Comparator
argument_list|<
name|Entry
argument_list|<
name|String
argument_list|,
name|Expression
index|[]
argument_list|>
argument_list|>
block|{
DECL|field|comp
specifier|private
specifier|final
name|Comparator
argument_list|<
name|Expression
argument_list|>
name|comp
decl_stmt|;
DECL|field|comparatorExpressionPlace
specifier|private
specifier|final
name|int
name|comparatorExpressionPlace
decl_stmt|;
DECL|method|EntryComparator
specifier|public
name|EntryComparator
parameter_list|(
name|Comparator
argument_list|<
name|Expression
argument_list|>
name|comp
parameter_list|,
name|int
name|comparatorExpressionPlace
parameter_list|)
block|{
name|this
operator|.
name|comp
operator|=
name|comp
expr_stmt|;
name|this
operator|.
name|comparatorExpressionPlace
operator|=
name|comparatorExpressionPlace
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|compare
specifier|public
name|int
name|compare
parameter_list|(
name|Entry
argument_list|<
name|String
argument_list|,
name|Expression
index|[]
argument_list|>
name|o1
parameter_list|,
name|Entry
argument_list|<
name|String
argument_list|,
name|Expression
index|[]
argument_list|>
name|o2
parameter_list|)
block|{
return|return
name|comp
operator|.
name|compare
argument_list|(
name|o1
operator|.
name|getValue
argument_list|()
index|[
name|comparatorExpressionPlace
index|]
argument_list|,
name|o2
operator|.
name|getValue
argument_list|()
index|[
name|comparatorExpressionPlace
index|]
argument_list|)
return|;
block|}
block|}
comment|/**    * Finalizes the statistics within the each facet bucket before exporting;    */
annotation|@
name|Override
DECL|method|compute
specifier|public
name|void
name|compute
parameter_list|()
block|{
if|if
condition|(
operator|!
name|basicsAndFieldFacetsComputed
condition|)
block|{
name|super
operator|.
name|compute
argument_list|()
expr_stmt|;
for|for
control|(
name|Map
argument_list|<
name|String
argument_list|,
name|StatsCollector
index|[]
argument_list|>
name|f
range|:
name|fieldFacetCollectors
operator|.
name|values
argument_list|()
control|)
block|{
for|for
control|(
name|StatsCollector
index|[]
name|arr
range|:
name|f
operator|.
name|values
argument_list|()
control|)
block|{
for|for
control|(
name|StatsCollector
name|b
range|:
name|arr
control|)
block|{
name|b
operator|.
name|compute
argument_list|()
expr_stmt|;
block|}
block|}
block|}
name|basicsAndFieldFacetsComputed
operator|=
literal|true
expr_stmt|;
block|}
block|}
comment|/**    * Finalizes the statistics within the a specific query facet before exporting;    */
DECL|method|computeQueryFacet
specifier|public
name|void
name|computeQueryFacet
parameter_list|(
name|String
name|facet
parameter_list|)
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|StatsCollector
index|[]
argument_list|>
name|f
init|=
name|queryFacetCollectors
operator|.
name|get
argument_list|(
name|facet
argument_list|)
decl_stmt|;
for|for
control|(
name|StatsCollector
index|[]
name|arr
range|:
name|f
operator|.
name|values
argument_list|()
control|)
block|{
for|for
control|(
name|StatsCollector
name|b
range|:
name|arr
control|)
block|{
name|b
operator|.
name|compute
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Finalizes the statistics within the a specific range facet before exporting;    */
DECL|method|computeRangeFacet
specifier|public
name|void
name|computeRangeFacet
parameter_list|(
name|String
name|facet
parameter_list|)
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|StatsCollector
index|[]
argument_list|>
name|f
init|=
name|rangeFacetCollectors
operator|.
name|get
argument_list|(
name|facet
argument_list|)
decl_stmt|;
for|for
control|(
name|StatsCollector
index|[]
name|arr
range|:
name|f
operator|.
name|values
argument_list|()
control|)
block|{
for|for
control|(
name|StatsCollector
name|b
range|:
name|arr
control|)
block|{
name|b
operator|.
name|compute
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Returns the value of an expression to use in a range or query facet.    * @param expressionName the name of the expression    * @param fieldFacet the facet field    * @param facetValue the facet value    * @return String String representation of pivot value    */
annotation|@
name|SuppressWarnings
argument_list|(
block|{
literal|"deprecation"
block|,
literal|"rawtypes"
block|}
argument_list|)
DECL|method|getResult
specifier|public
name|String
name|getResult
parameter_list|(
name|String
name|expressionName
parameter_list|,
name|String
name|fieldFacet
parameter_list|,
name|String
name|facetValue
parameter_list|)
block|{
if|if
condition|(
name|facetValue
operator|.
name|contains
argument_list|(
name|AnalyticsParams
operator|.
name|RESULT
argument_list|)
operator|&&
operator|!
name|facetValue
operator|.
name|contains
argument_list|(
name|AnalyticsParams
operator|.
name|QUERY_RESULT
argument_list|)
condition|)
block|{
try|try
block|{
name|String
index|[]
name|pivotStr
init|=
name|ExpressionFactory
operator|.
name|getArguments
argument_list|(
name|facetValue
operator|.
name|substring
argument_list|(
name|facetValue
operator|.
name|indexOf
argument_list|(
literal|'('
argument_list|)
operator|+
literal|1
argument_list|,
name|facetValue
operator|.
name|lastIndexOf
argument_list|(
literal|')'
argument_list|)
argument_list|)
operator|.
name|trim
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|pivotStr
operator|.
name|length
operator|==
literal|1
condition|)
block|{
name|facetValue
operator|=
name|getResult
argument_list|(
name|pivotStr
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pivotStr
operator|.
name|length
operator|==
literal|3
condition|)
block|{
name|facetValue
operator|=
name|getResult
argument_list|(
name|pivotStr
index|[
literal|0
index|]
argument_list|,
name|pivotStr
index|[
literal|1
index|]
argument_list|,
name|pivotStr
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
literal|"Result request "
operator|+
name|facetValue
operator|+
literal|" has an invalid amount of arguments."
argument_list|)
throw|;
block|}
block|}
catch|catch
parameter_list|(
name|IndexOutOfBoundsException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
literal|"Result request "
operator|+
name|facetValue
operator|+
literal|" is invalid. Lacks parentheses."
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
if|if
condition|(
name|fieldFacetExpressions
operator|.
name|get
argument_list|(
name|fieldFacet
argument_list|)
operator|!=
literal|null
condition|)
block|{
name|Expression
index|[]
name|facetExpressions
init|=
name|fieldFacetExpressions
operator|.
name|get
argument_list|(
name|fieldFacet
argument_list|)
operator|.
name|get
argument_list|(
name|facetValue
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|count
init|=
literal|0
init|;
name|count
operator|<
name|expressionNames
operator|.
name|length
condition|;
name|count
operator|++
control|)
block|{
if|if
condition|(
name|expressionName
operator|.
name|equals
argument_list|(
name|expressionNames
index|[
name|count
index|]
argument_list|)
condition|)
block|{
name|Comparable
name|value
init|=
name|facetExpressions
index|[
name|count
index|]
operator|.
name|getValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|value
operator|.
name|getClass
argument_list|()
operator|.
name|equals
argument_list|(
name|Date
operator|.
name|class
argument_list|)
condition|)
block|{
return|return
operator|(
operator|(
name|Date
operator|)
name|value
operator|)
operator|.
name|toInstant
argument_list|()
operator|.
name|toString
argument_list|()
return|;
block|}
else|else
block|{
return|return
name|value
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
block|}
block|}
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
literal|"Field Facet Pivot expression "
operator|+
name|expressionName
operator|+
literal|" not found."
argument_list|)
throw|;
block|}
comment|/**    * Returns the value of an expression to use in a range or query facet.    * @param currentFacet the name of the current facet    * @param expressionName the name of the expression    * @param queryFacet the facet query    * @param facetValue the field value    * @return String String representation of pivot value    */
annotation|@
name|SuppressWarnings
argument_list|(
block|{
literal|"deprecation"
block|,
literal|"rawtypes"
block|}
argument_list|)
DECL|method|getQueryResult
specifier|public
name|String
name|getQueryResult
parameter_list|(
name|String
name|currentFacet
parameter_list|,
name|String
name|expressionName
parameter_list|,
name|String
name|queryFacet
parameter_list|,
name|String
name|facetValue
parameter_list|)
block|{
if|if
condition|(
name|facetValue
operator|.
name|contains
argument_list|(
name|AnalyticsParams
operator|.
name|RESULT
argument_list|)
operator|&&
operator|!
name|facetValue
operator|.
name|contains
argument_list|(
name|AnalyticsParams
operator|.
name|QUERY_RESULT
argument_list|)
condition|)
block|{
try|try
block|{
name|String
index|[]
name|pivotStr
init|=
name|ExpressionFactory
operator|.
name|getArguments
argument_list|(
name|facetValue
operator|.
name|substring
argument_list|(
name|facetValue
operator|.
name|indexOf
argument_list|(
literal|'('
argument_list|)
operator|+
literal|1
argument_list|,
name|facetValue
operator|.
name|lastIndexOf
argument_list|(
literal|')'
argument_list|)
argument_list|)
operator|.
name|trim
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|pivotStr
operator|.
name|length
operator|==
literal|1
condition|)
block|{
name|facetValue
operator|=
name|getResult
argument_list|(
name|pivotStr
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pivotStr
operator|.
name|length
operator|==
literal|3
condition|)
block|{
name|facetValue
operator|=
name|getResult
argument_list|(
name|pivotStr
index|[
literal|0
index|]
argument_list|,
name|pivotStr
index|[
literal|1
index|]
argument_list|,
name|pivotStr
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
literal|"Result request "
operator|+
name|facetValue
operator|+
literal|" has an invalid amount of arguments."
argument_list|)
throw|;
block|}
block|}
catch|catch
parameter_list|(
name|IndexOutOfBoundsException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
literal|"Result request "
operator|+
name|facetValue
operator|+
literal|" is invalid. Lacks parentheses."
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
if|if
condition|(
name|facetValue
operator|.
name|contains
argument_list|(
name|AnalyticsParams
operator|.
name|QUERY_RESULT
argument_list|)
condition|)
block|{
try|try
block|{
name|String
index|[]
name|pivotStr
init|=
name|ExpressionFactory
operator|.
name|getArguments
argument_list|(
name|facetValue
operator|.
name|substring
argument_list|(
name|facetValue
operator|.
name|indexOf
argument_list|(
literal|'('
argument_list|)
operator|+
literal|1
argument_list|,
name|facetValue
operator|.
name|lastIndexOf
argument_list|(
literal|')'
argument_list|)
argument_list|)
operator|.
name|trim
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|pivotStr
operator|.
name|length
operator|==
literal|1
condition|)
block|{
name|facetValue
operator|=
name|getResult
argument_list|(
name|pivotStr
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pivotStr
operator|.
name|length
operator|==
literal|3
condition|)
block|{
name|facetValue
operator|=
name|getQueryResult
argument_list|(
name|currentFacet
argument_list|,
name|pivotStr
index|[
literal|0
index|]
argument_list|,
name|pivotStr
index|[
literal|1
index|]
argument_list|,
name|pivotStr
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
literal|"Result request "
operator|+
name|facetValue
operator|+
literal|" has an invalid amount of arguments."
argument_list|)
throw|;
block|}
block|}
catch|catch
parameter_list|(
name|IndexOutOfBoundsException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
literal|"Result request "
operator|+
name|facetValue
operator|+
literal|" is invalid. Lacks parentheses."
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
if|if
condition|(
name|queryFacetExpressions
operator|.
name|get
argument_list|(
name|queryFacet
argument_list|)
operator|!=
literal|null
condition|)
block|{
name|Expression
index|[]
name|facetExpressions
init|=
name|queryFacetExpressions
operator|.
name|get
argument_list|(
name|queryFacet
argument_list|)
operator|.
name|get
argument_list|(
name|facetValue
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|count
init|=
literal|0
init|;
name|count
operator|<
name|expressionNames
operator|.
name|length
condition|;
name|count
operator|++
control|)
block|{
if|if
condition|(
name|expressionName
operator|.
name|equals
argument_list|(
name|expressionNames
index|[
name|count
index|]
argument_list|)
condition|)
block|{
name|Comparable
name|value
init|=
name|facetExpressions
index|[
name|count
index|]
operator|.
name|getValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|value
operator|.
name|getClass
argument_list|()
operator|.
name|equals
argument_list|(
name|Date
operator|.
name|class
argument_list|)
condition|)
block|{
return|return
operator|(
operator|(
name|Date
operator|)
name|value
operator|)
operator|.
name|toInstant
argument_list|()
operator|.
name|toString
argument_list|()
return|;
block|}
else|else
block|{
return|return
name|value
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
block|}
block|}
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
literal|"Field Facet Pivot expression "
operator|+
name|expressionName
operator|+
literal|" not found."
argument_list|)
throw|;
block|}
annotation|@
name|Override
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|export
specifier|public
name|NamedList
argument_list|<
name|?
argument_list|>
name|export
parameter_list|()
block|{
specifier|final
name|NamedList
argument_list|<
name|Object
argument_list|>
name|base
init|=
operator|(
name|NamedList
argument_list|<
name|Object
argument_list|>
operator|)
name|super
operator|.
name|export
argument_list|()
decl_stmt|;
name|NamedList
argument_list|<
name|NamedList
argument_list|<
name|?
argument_list|>
argument_list|>
name|facetList
init|=
operator|new
name|NamedList
argument_list|<>
argument_list|()
decl_stmt|;
comment|// Add the field facet buckets to the output
name|base
operator|.
name|add
argument_list|(
literal|"fieldFacets"
argument_list|,
name|facetList
argument_list|)
expr_stmt|;
for|for
control|(
name|FieldFacetRequest
name|freq
range|:
name|request
operator|.
name|getFieldFacets
argument_list|()
control|)
block|{
specifier|final
name|String
name|name
init|=
name|freq
operator|.
name|getName
argument_list|()
decl_stmt|;
if|if
condition|(
name|hiddenFieldFacets
operator|.
name|contains
argument_list|(
name|name
argument_list|)
condition|)
block|{
continue|continue;
block|}
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|Expression
index|[]
argument_list|>
name|buckets
init|=
name|fieldFacetExpressions
operator|.
name|get
argument_list|(
name|name
argument_list|)
decl_stmt|;
specifier|final
name|NamedList
argument_list|<
name|Object
argument_list|>
name|bucketBase
init|=
operator|new
name|NamedList
argument_list|<>
argument_list|()
decl_stmt|;
name|Iterable
argument_list|<
name|Entry
argument_list|<
name|String
argument_list|,
name|Expression
index|[]
argument_list|>
argument_list|>
name|iter
init|=
name|buckets
operator|.
name|entrySet
argument_list|()
decl_stmt|;
specifier|final
name|FieldFacetRequest
name|fr
init|=
operator|(
name|FieldFacetRequest
operator|)
name|freq
decl_stmt|;
specifier|final
name|FacetSortSpecification
name|sort
init|=
name|fr
operator|.
name|getSort
argument_list|()
decl_stmt|;
specifier|final
name|int
name|limit
init|=
name|fr
operator|.
name|getLimit
argument_list|()
decl_stmt|;
specifier|final
name|int
name|offset
init|=
name|fr
operator|.
name|getOffset
argument_list|()
decl_stmt|;
specifier|final
name|boolean
name|showMissing
init|=
name|fr
operator|.
name|showsMissing
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|showMissing
condition|)
block|{
name|buckets
operator|.
name|remove
argument_list|(
name|MISSING_VALUE
argument_list|)
expr_stmt|;
block|}
comment|// Sorting the buckets if a sort specification is provided
if|if
condition|(
name|sort
operator|!=
literal|null
operator|&&
name|buckets
operator|.
name|values
argument_list|()
operator|.
name|iterator
argument_list|()
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|int
name|sortPlace
init|=
name|Arrays
operator|.
name|binarySearch
argument_list|(
name|expressionNames
argument_list|,
name|sort
operator|.
name|getStatistic
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|Expression
name|first
init|=
name|buckets
operator|.
name|values
argument_list|()
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
index|[
name|sortPlace
index|]
decl_stmt|;
specifier|final
name|Comparator
argument_list|<
name|Expression
argument_list|>
name|comp
init|=
operator|(
name|Comparator
argument_list|<
name|Expression
argument_list|>
operator|)
name|first
operator|.
name|comparator
argument_list|(
name|sort
operator|.
name|getDirection
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|Entry
argument_list|<
name|String
argument_list|,
name|Expression
index|[]
argument_list|>
argument_list|>
name|sorted
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|buckets
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
name|Iterables
operator|.
name|addAll
argument_list|(
name|sorted
argument_list|,
name|iter
argument_list|)
expr_stmt|;
name|Collections
operator|.
name|sort
argument_list|(
name|sorted
argument_list|,
operator|new
name|EntryComparator
argument_list|(
name|comp
argument_list|,
name|sortPlace
argument_list|)
argument_list|)
expr_stmt|;
name|iter
operator|=
name|sorted
expr_stmt|;
block|}
comment|// apply the limit
if|if
condition|(
name|limit
operator|>
name|AnalyticsContentHandler
operator|.
name|DEFAULT_FACET_LIMIT
condition|)
block|{
if|if
condition|(
name|offset
operator|>
literal|0
condition|)
block|{
name|iter
operator|=
name|Iterables
operator|.
name|skip
argument_list|(
name|iter
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
name|iter
operator|=
name|Iterables
operator|.
name|limit
argument_list|(
name|iter
argument_list|,
name|limit
argument_list|)
expr_stmt|;
block|}
comment|// Export each expression in the bucket.
for|for
control|(
name|Entry
argument_list|<
name|String
argument_list|,
name|Expression
index|[]
argument_list|>
name|bucket
range|:
name|iter
control|)
block|{
name|bucketBase
operator|.
name|add
argument_list|(
name|bucket
operator|.
name|getKey
argument_list|()
argument_list|,
name|export
argument_list|(
name|bucket
operator|.
name|getValue
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|facetList
operator|.
name|add
argument_list|(
name|name
argument_list|,
name|bucketBase
argument_list|)
expr_stmt|;
block|}
comment|// Add the range facet buckets to the output
name|facetList
operator|=
operator|new
name|NamedList
argument_list|<>
argument_list|()
expr_stmt|;
name|base
operator|.
name|add
argument_list|(
literal|"rangeFacets"
argument_list|,
name|facetList
argument_list|)
expr_stmt|;
for|for
control|(
name|RangeFacetRequest
name|freq
range|:
name|request
operator|.
name|getRangeFacets
argument_list|()
control|)
block|{
specifier|final
name|String
name|name
init|=
name|freq
operator|.
name|getName
argument_list|()
decl_stmt|;
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|Expression
index|[]
argument_list|>
name|buckets
init|=
name|rangeFacetExpressions
operator|.
name|get
argument_list|(
name|name
argument_list|)
decl_stmt|;
specifier|final
name|NamedList
argument_list|<
name|Object
argument_list|>
name|bucketBase
init|=
operator|new
name|NamedList
argument_list|<>
argument_list|()
decl_stmt|;
name|Iterable
argument_list|<
name|Entry
argument_list|<
name|String
argument_list|,
name|Expression
index|[]
argument_list|>
argument_list|>
name|iter
init|=
name|buckets
operator|.
name|entrySet
argument_list|()
decl_stmt|;
for|for
control|(
name|Entry
argument_list|<
name|String
argument_list|,
name|Expression
index|[]
argument_list|>
name|bucket
range|:
name|iter
control|)
block|{
name|bucketBase
operator|.
name|add
argument_list|(
name|bucket
operator|.
name|getKey
argument_list|()
argument_list|,
name|export
argument_list|(
name|bucket
operator|.
name|getValue
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|facetList
operator|.
name|add
argument_list|(
name|name
argument_list|,
name|bucketBase
argument_list|)
expr_stmt|;
block|}
comment|// Add the query facet buckets to the output
name|facetList
operator|=
operator|new
name|NamedList
argument_list|<>
argument_list|()
expr_stmt|;
name|base
operator|.
name|add
argument_list|(
literal|"queryFacets"
argument_list|,
name|facetList
argument_list|)
expr_stmt|;
for|for
control|(
name|QueryFacetRequest
name|freq
range|:
name|request
operator|.
name|getQueryFacets
argument_list|()
control|)
block|{
specifier|final
name|String
name|name
init|=
name|freq
operator|.
name|getName
argument_list|()
decl_stmt|;
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|Expression
index|[]
argument_list|>
name|buckets
init|=
name|queryFacetExpressions
operator|.
name|get
argument_list|(
name|name
argument_list|)
decl_stmt|;
specifier|final
name|NamedList
argument_list|<
name|Object
argument_list|>
name|bucketBase
init|=
operator|new
name|NamedList
argument_list|<>
argument_list|()
decl_stmt|;
name|Iterable
argument_list|<
name|Entry
argument_list|<
name|String
argument_list|,
name|Expression
index|[]
argument_list|>
argument_list|>
name|iter
init|=
name|buckets
operator|.
name|entrySet
argument_list|()
decl_stmt|;
for|for
control|(
name|Entry
argument_list|<
name|String
argument_list|,
name|Expression
index|[]
argument_list|>
name|bucket
range|:
name|iter
control|)
block|{
name|bucketBase
operator|.
name|add
argument_list|(
name|bucket
operator|.
name|getKey
argument_list|()
argument_list|,
name|export
argument_list|(
name|bucket
operator|.
name|getValue
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|facetList
operator|.
name|add
argument_list|(
name|name
argument_list|,
name|bucketBase
argument_list|)
expr_stmt|;
block|}
return|return
name|base
return|;
block|}
comment|/**    * Exports a list of expressions as a NamedList    * @param expressionArr an array of expressions    * @return named list of expressions    */
DECL|method|export
specifier|public
name|NamedList
argument_list|<
name|?
argument_list|>
name|export
parameter_list|(
name|Expression
index|[]
name|expressionArr
parameter_list|)
block|{
name|NamedList
argument_list|<
name|Object
argument_list|>
name|base
init|=
operator|new
name|NamedList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|count
init|=
literal|0
init|;
name|count
operator|<
name|expressionArr
operator|.
name|length
condition|;
name|count
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|hiddenExpressions
operator|.
name|contains
argument_list|(
name|expressionNames
index|[
name|count
index|]
argument_list|)
condition|)
block|{
name|base
operator|.
name|add
argument_list|(
name|expressionNames
index|[
name|count
index|]
argument_list|,
name|expressionArr
index|[
name|count
index|]
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|base
return|;
block|}
comment|/**    * Processes the query and range facets.    * Must be called if range and/or query facets are supported.    */
annotation|@
name|Override
DECL|method|postProcess
specifier|public
name|void
name|postProcess
parameter_list|()
throws|throws
name|IOException
block|{
name|super
operator|.
name|compute
argument_list|()
expr_stmt|;
for|for
control|(
name|Map
argument_list|<
name|String
argument_list|,
name|StatsCollector
index|[]
argument_list|>
name|f
range|:
name|fieldFacetCollectors
operator|.
name|values
argument_list|()
control|)
block|{
for|for
control|(
name|StatsCollector
index|[]
name|arr
range|:
name|f
operator|.
name|values
argument_list|()
control|)
block|{
for|for
control|(
name|StatsCollector
name|b
range|:
name|arr
control|)
block|{
name|b
operator|.
name|compute
argument_list|()
expr_stmt|;
block|}
block|}
block|}
name|basicsAndFieldFacetsComputed
operator|=
literal|true
expr_stmt|;
specifier|final
name|Filter
name|filter
init|=
name|docs
operator|.
name|getTopFilter
argument_list|()
decl_stmt|;
if|if
condition|(
name|rangeFacets
operator|!=
literal|null
condition|)
block|{
name|processRangeFacets
argument_list|(
name|filter
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|queryFacets
operator|!=
literal|null
condition|)
block|{
name|processQueryFacets
argument_list|(
name|filter
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Initiates the collecting of query facets    * @param filter the base filter to work against    * @throws IOException if searching failed    */
DECL|method|processQueryFacets
specifier|public
name|void
name|processQueryFacets
parameter_list|(
specifier|final
name|Filter
name|filter
parameter_list|)
throws|throws
name|IOException
block|{
for|for
control|(
name|QueryFacetRequest
name|qfr
range|:
name|queryFacets
control|)
block|{
for|for
control|(
name|String
name|query
range|:
name|qfr
operator|.
name|getQueries
argument_list|()
control|)
block|{
if|if
condition|(
name|query
operator|.
name|contains
argument_list|(
name|AnalyticsParams
operator|.
name|RESULT
argument_list|)
operator|&&
operator|!
name|query
operator|.
name|contains
argument_list|(
name|AnalyticsParams
operator|.
name|QUERY_RESULT
argument_list|)
condition|)
block|{
try|try
block|{
name|String
index|[]
name|pivotStr
init|=
name|ExpressionFactory
operator|.
name|getArguments
argument_list|(
name|query
operator|.
name|substring
argument_list|(
name|query
operator|.
name|indexOf
argument_list|(
literal|'('
argument_list|)
operator|+
literal|1
argument_list|,
name|query
operator|.
name|lastIndexOf
argument_list|(
literal|')'
argument_list|)
argument_list|)
operator|.
name|trim
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|pivotStr
operator|.
name|length
operator|==
literal|1
condition|)
block|{
name|query
operator|=
name|getResult
argument_list|(
name|pivotStr
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pivotStr
operator|.
name|length
operator|==
literal|3
condition|)
block|{
name|query
operator|=
name|getResult
argument_list|(
name|pivotStr
index|[
literal|0
index|]
argument_list|,
name|pivotStr
index|[
literal|1
index|]
argument_list|,
name|pivotStr
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
literal|"Result request "
operator|+
name|query
operator|+
literal|" has an invalid amount of arguments."
argument_list|)
throw|;
block|}
block|}
catch|catch
parameter_list|(
name|IndexOutOfBoundsException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
literal|"Result request "
operator|+
name|query
operator|+
literal|" is invalid. Lacks parentheses."
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
elseif|else
if|if
condition|(
name|query
operator|.
name|contains
argument_list|(
name|AnalyticsParams
operator|.
name|QUERY_RESULT
argument_list|)
condition|)
block|{
try|try
block|{
name|String
index|[]
name|pivotStr
init|=
name|ExpressionFactory
operator|.
name|getArguments
argument_list|(
name|query
operator|.
name|substring
argument_list|(
name|query
operator|.
name|indexOf
argument_list|(
literal|'('
argument_list|)
operator|+
literal|1
argument_list|,
name|query
operator|.
name|lastIndexOf
argument_list|(
literal|')'
argument_list|)
argument_list|)
operator|.
name|trim
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|pivotStr
operator|.
name|length
operator|==
literal|3
condition|)
block|{
name|query
operator|=
name|getQueryResult
argument_list|(
name|qfr
operator|.
name|getName
argument_list|()
argument_list|,
name|pivotStr
index|[
literal|0
index|]
argument_list|,
name|pivotStr
index|[
literal|1
index|]
argument_list|,
name|pivotStr
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
literal|"Result request "
operator|+
name|query
operator|+
literal|" has an invalid amount of arguments."
argument_list|)
throw|;
block|}
block|}
catch|catch
parameter_list|(
name|IndexOutOfBoundsException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
literal|"Result request "
operator|+
name|query
operator|+
literal|" is invalid. Lacks parentheses."
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
name|QueryFacetAccumulator
name|qAcc
init|=
operator|new
name|QueryFacetAccumulator
argument_list|(
name|this
argument_list|,
name|qfr
operator|.
name|getName
argument_list|()
argument_list|,
name|query
argument_list|)
decl_stmt|;
specifier|final
name|Query
name|q
decl_stmt|;
try|try
block|{
name|q
operator|=
name|QParser
operator|.
name|getParser
argument_list|(
name|query
argument_list|,
literal|null
argument_list|,
name|queryRequest
argument_list|)
operator|.
name|getQuery
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SyntaxError
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
literal|"Invalid query '"
operator|+
name|query
operator|+
literal|"'"
argument_list|,
name|e
argument_list|)
throw|;
block|}
comment|// The searcher sends docIds to the QueryFacetAccumulator which forwards
comment|// them to<code>collectQuery()</code> in this class for collection.
name|Query
name|filtered
init|=
operator|new
name|BooleanQuery
operator|.
name|Builder
argument_list|()
operator|.
name|add
argument_list|(
name|q
argument_list|,
name|Occur
operator|.
name|MUST
argument_list|)
operator|.
name|add
argument_list|(
name|filter
argument_list|,
name|Occur
operator|.
name|FILTER
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|searcher
operator|.
name|search
argument_list|(
name|filtered
argument_list|,
name|qAcc
argument_list|)
expr_stmt|;
name|computeQueryFacet
argument_list|(
name|qfr
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|queryCount
operator|++
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|Override
DECL|method|getNumQueries
specifier|public
name|long
name|getNumQueries
parameter_list|()
block|{
return|return
name|queryCount
return|;
block|}
comment|/**    * Initiates the collecting of range facets    * @param filter the base filter to use    * @throws IOException if searching fails    */
DECL|method|processRangeFacets
specifier|public
name|void
name|processRangeFacets
parameter_list|(
specifier|final
name|Filter
name|filter
parameter_list|)
throws|throws
name|IOException
block|{
for|for
control|(
name|RangeFacetRequest
name|rfr
range|:
name|rangeFacets
control|)
block|{
name|String
index|[]
name|pivotStr
decl_stmt|;
name|String
name|start
init|=
name|rfr
operator|.
name|getStart
argument_list|()
decl_stmt|;
if|if
condition|(
name|start
operator|.
name|contains
argument_list|(
name|AnalyticsParams
operator|.
name|QUERY_RESULT
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
literal|"Query result requests can not be used in Range Facets"
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
name|start
operator|.
name|contains
argument_list|(
name|AnalyticsParams
operator|.
name|RESULT
argument_list|)
condition|)
block|{
try|try
block|{
name|pivotStr
operator|=
name|ExpressionFactory
operator|.
name|getArguments
argument_list|(
name|start
operator|.
name|substring
argument_list|(
name|start
operator|.
name|indexOf
argument_list|(
literal|'('
argument_list|)
operator|+
literal|1
argument_list|,
name|start
operator|.
name|indexOf
argument_list|(
literal|')'
argument_list|)
argument_list|)
operator|.
name|trim
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|pivotStr
operator|.
name|length
operator|==
literal|1
condition|)
block|{
name|rfr
operator|.
name|setStart
argument_list|(
name|getResult
argument_list|(
name|pivotStr
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pivotStr
operator|.
name|length
operator|==
literal|3
condition|)
block|{
name|rfr
operator|.
name|setStart
argument_list|(
name|getResult
argument_list|(
name|pivotStr
index|[
literal|0
index|]
argument_list|,
name|pivotStr
index|[
literal|1
index|]
argument_list|,
name|pivotStr
index|[
literal|2
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
literal|"Result request "
operator|+
name|start
operator|+
literal|" has an invalid amount of arguments."
argument_list|)
throw|;
block|}
block|}
catch|catch
parameter_list|(
name|IndexOutOfBoundsException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
literal|"Result request "
operator|+
name|start
operator|+
literal|" is invalid. Lacks parentheses."
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
name|String
name|end
init|=
name|rfr
operator|.
name|getEnd
argument_list|()
decl_stmt|;
if|if
condition|(
name|end
operator|.
name|contains
argument_list|(
name|AnalyticsParams
operator|.
name|QUERY_RESULT
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
literal|"Query result requests can not be used in Range Facets"
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
name|end
operator|.
name|contains
argument_list|(
name|AnalyticsParams
operator|.
name|RESULT
argument_list|)
condition|)
block|{
try|try
block|{
name|pivotStr
operator|=
name|ExpressionFactory
operator|.
name|getArguments
argument_list|(
name|end
operator|.
name|substring
argument_list|(
name|end
operator|.
name|indexOf
argument_list|(
literal|'('
argument_list|)
operator|+
literal|1
argument_list|,
name|end
operator|.
name|indexOf
argument_list|(
literal|')'
argument_list|)
argument_list|)
operator|.
name|trim
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|pivotStr
operator|.
name|length
operator|==
literal|1
condition|)
block|{
name|rfr
operator|.
name|setEnd
argument_list|(
name|getResult
argument_list|(
name|pivotStr
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pivotStr
operator|.
name|length
operator|==
literal|3
condition|)
block|{
name|rfr
operator|.
name|setEnd
argument_list|(
name|getResult
argument_list|(
name|pivotStr
index|[
literal|0
index|]
argument_list|,
name|pivotStr
index|[
literal|1
index|]
argument_list|,
name|pivotStr
index|[
literal|2
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
literal|"Result request "
operator|+
name|end
operator|+
literal|" has an invalid amount of arguments."
argument_list|)
throw|;
block|}
block|}
catch|catch
parameter_list|(
name|IndexOutOfBoundsException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
literal|"Result request "
operator|+
name|end
operator|+
literal|" is invalid. Lacks parentheses."
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
name|String
index|[]
name|gaps
init|=
name|rfr
operator|.
name|getGaps
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|count
init|=
literal|0
init|;
name|count
operator|<
name|gaps
operator|.
name|length
condition|;
name|count
operator|++
control|)
block|{
name|String
name|gap
init|=
name|gaps
index|[
name|count
index|]
decl_stmt|;
if|if
condition|(
name|gap
operator|.
name|contains
argument_list|(
name|AnalyticsParams
operator|.
name|QUERY_RESULT
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
literal|"Query result requests can not be used in Range Facets"
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
name|gap
operator|.
name|contains
argument_list|(
name|AnalyticsParams
operator|.
name|RESULT
argument_list|)
condition|)
block|{
try|try
block|{
name|pivotStr
operator|=
name|ExpressionFactory
operator|.
name|getArguments
argument_list|(
name|gap
operator|.
name|substring
argument_list|(
name|gap
operator|.
name|indexOf
argument_list|(
literal|'('
argument_list|)
operator|+
literal|1
argument_list|,
name|gap
operator|.
name|indexOf
argument_list|(
literal|')'
argument_list|)
argument_list|)
operator|.
name|trim
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|pivotStr
operator|.
name|length
operator|==
literal|1
condition|)
block|{
name|gaps
index|[
name|count
index|]
operator|=
name|getResult
argument_list|(
name|pivotStr
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pivotStr
operator|.
name|length
operator|==
literal|3
condition|)
block|{
name|gaps
index|[
name|count
index|]
operator|=
name|getResult
argument_list|(
name|pivotStr
index|[
literal|0
index|]
argument_list|,
name|pivotStr
index|[
literal|1
index|]
argument_list|,
name|pivotStr
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
literal|"Result request "
operator|+
name|gap
operator|+
literal|" has an invalid amount of arguments."
argument_list|)
throw|;
block|}
block|}
catch|catch
parameter_list|(
name|IndexOutOfBoundsException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
literal|"Result request "
operator|+
name|gap
operator|+
literal|" is invalid. Lacks parentheses."
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
block|}
comment|// Computes the end points of the ranges in the rangeFacet
specifier|final
name|RangeEndpointCalculator
argument_list|<
name|?
extends|extends
name|Comparable
argument_list|<
name|?
argument_list|>
argument_list|>
name|rec
init|=
name|RangeEndpointCalculator
operator|.
name|create
argument_list|(
name|rfr
argument_list|)
decl_stmt|;
specifier|final
name|SchemaField
name|sf
init|=
name|rfr
operator|.
name|getField
argument_list|()
decl_stmt|;
comment|// Create a rangeFacetAccumulator for each range and
comment|// collect the documents for that range.
for|for
control|(
name|FacetRange
name|range
range|:
name|rec
operator|.
name|getRanges
argument_list|()
control|)
block|{
specifier|final
name|String
name|upper
decl_stmt|;
specifier|final
name|String
name|lower
decl_stmt|;
name|String
name|facetValue
init|=
literal|""
decl_stmt|;
if|if
condition|(
name|range
operator|.
name|lower
operator|==
literal|null
condition|)
block|{
name|facetValue
operator|=
literal|"(*"
expr_stmt|;
name|lower
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
name|lower
operator|=
name|range
operator|.
name|lower
expr_stmt|;
name|facetValue
operator|=
operator|(
operator|(
name|range
operator|.
name|includeLower
operator|)
condition|?
literal|"["
else|:
literal|"("
operator|)
operator|+
name|range
operator|.
name|lower
expr_stmt|;
block|}
name|facetValue
operator|+=
literal|" TO "
expr_stmt|;
if|if
condition|(
name|range
operator|.
name|upper
operator|==
literal|null
condition|)
block|{
name|upper
operator|=
literal|null
expr_stmt|;
name|facetValue
operator|+=
literal|"*)"
expr_stmt|;
block|}
else|else
block|{
name|upper
operator|=
name|range
operator|.
name|upper
expr_stmt|;
name|facetValue
operator|+=
name|range
operator|.
name|upper
operator|+
operator|(
operator|(
name|range
operator|.
name|includeUpper
operator|)
condition|?
literal|"]"
else|:
literal|")"
operator|)
expr_stmt|;
block|}
name|Query
name|q
init|=
name|sf
operator|.
name|getType
argument_list|()
operator|.
name|getRangeQuery
argument_list|(
literal|null
argument_list|,
name|sf
argument_list|,
name|lower
argument_list|,
name|upper
argument_list|,
name|range
operator|.
name|includeLower
argument_list|,
name|range
operator|.
name|includeUpper
argument_list|)
decl_stmt|;
name|RangeFacetAccumulator
name|rAcc
init|=
operator|new
name|RangeFacetAccumulator
argument_list|(
name|this
argument_list|,
name|rfr
operator|.
name|getName
argument_list|()
argument_list|,
name|facetValue
argument_list|)
decl_stmt|;
comment|// The searcher sends docIds to the RangeFacetAccumulator which forwards
comment|// them to<code>collectRange()</code> in this class for collection.
name|Query
name|filtered
init|=
operator|new
name|BooleanQuery
operator|.
name|Builder
argument_list|()
operator|.
name|add
argument_list|(
name|q
argument_list|,
name|Occur
operator|.
name|MUST
argument_list|)
operator|.
name|add
argument_list|(
name|filter
argument_list|,
name|Occur
operator|.
name|FILTER
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|searcher
operator|.
name|search
argument_list|(
name|filtered
argument_list|,
name|rAcc
argument_list|)
expr_stmt|;
name|computeRangeFacet
argument_list|(
name|sf
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_class
end_unit
