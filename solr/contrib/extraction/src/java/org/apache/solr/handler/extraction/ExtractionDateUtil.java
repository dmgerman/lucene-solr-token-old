begin_unit
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_package
DECL|package|org.apache.solr.handler.extraction
package|package
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|handler
operator|.
name|extraction
package|;
end_package
begin_import
import|import
name|java
operator|.
name|text
operator|.
name|ParseException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|text
operator|.
name|SimpleDateFormat
import|;
end_import
begin_import
import|import
name|java
operator|.
name|time
operator|.
name|Instant
import|;
end_import
begin_import
import|import
name|java
operator|.
name|time
operator|.
name|format
operator|.
name|DateTimeFormatter
import|;
end_import
begin_import
import|import
name|java
operator|.
name|time
operator|.
name|format
operator|.
name|DateTimeFormatterBuilder
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Calendar
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Date
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Locale
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TimeZone
import|;
end_import
begin_comment
comment|/**  * This class has some code from HttpClient DateUtil.  */
end_comment
begin_class
DECL|class|ExtractionDateUtil
specifier|public
class|class
name|ExtractionDateUtil
block|{
comment|//start HttpClient
comment|/**    * Date format pattern used to parse HTTP date headers in RFC 1123 format.    */
DECL|field|PATTERN_RFC1123
specifier|public
specifier|static
specifier|final
name|String
name|PATTERN_RFC1123
init|=
literal|"EEE, dd MMM yyyy HH:mm:ss zzz"
decl_stmt|;
comment|/**    * Date format pattern used to parse HTTP date headers in RFC 1036 format.    */
DECL|field|PATTERN_RFC1036
specifier|public
specifier|static
specifier|final
name|String
name|PATTERN_RFC1036
init|=
literal|"EEEE, dd-MMM-yy HH:mm:ss zzz"
decl_stmt|;
comment|/**    * Date format pattern used to parse HTTP date headers in ANSI C    *<code>asctime()</code> format.    */
DECL|field|PATTERN_ASCTIME
specifier|public
specifier|static
specifier|final
name|String
name|PATTERN_ASCTIME
init|=
literal|"EEE MMM d HH:mm:ss yyyy"
decl_stmt|;
comment|//These are included for back compat
DECL|field|DEFAULT_HTTP_CLIENT_PATTERNS
specifier|private
specifier|static
specifier|final
name|Collection
argument_list|<
name|String
argument_list|>
name|DEFAULT_HTTP_CLIENT_PATTERNS
init|=
name|Arrays
operator|.
name|asList
argument_list|(
name|PATTERN_ASCTIME
argument_list|,
name|PATTERN_RFC1036
argument_list|,
name|PATTERN_RFC1123
argument_list|)
decl_stmt|;
DECL|field|DEFAULT_TWO_DIGIT_YEAR_START
specifier|private
specifier|static
specifier|final
name|Date
name|DEFAULT_TWO_DIGIT_YEAR_START
decl_stmt|;
static|static
block|{
name|Calendar
name|calendar
init|=
name|Calendar
operator|.
name|getInstance
argument_list|(
name|TimeZone
operator|.
name|getTimeZone
argument_list|(
literal|"GMT"
argument_list|)
argument_list|,
name|Locale
operator|.
name|ROOT
argument_list|)
decl_stmt|;
name|calendar
operator|.
name|set
argument_list|(
literal|2000
argument_list|,
name|Calendar
operator|.
name|JANUARY
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|DEFAULT_TWO_DIGIT_YEAR_START
operator|=
name|calendar
operator|.
name|getTime
argument_list|()
expr_stmt|;
block|}
DECL|field|GMT
specifier|private
specifier|static
specifier|final
name|TimeZone
name|GMT
init|=
name|TimeZone
operator|.
name|getTimeZone
argument_list|(
literal|"GMT"
argument_list|)
decl_stmt|;
comment|//end HttpClient
comment|//---------------------------------------------------------------------------------------
comment|/**    * Differs by {@link DateTimeFormatter#ISO_INSTANT} in that it's lenient.    */
DECL|field|ISO_8601_PARSER
specifier|public
specifier|static
specifier|final
name|DateTimeFormatter
name|ISO_8601_PARSER
init|=
operator|new
name|DateTimeFormatterBuilder
argument_list|()
operator|.
name|parseCaseInsensitive
argument_list|()
operator|.
name|parseLenient
argument_list|()
operator|.
name|appendInstant
argument_list|()
operator|.
name|toFormatter
argument_list|(
name|Locale
operator|.
name|ROOT
argument_list|)
decl_stmt|;
comment|/**    * A suite of default date formats that can be parsed, and thus transformed to the Solr specific format    */
DECL|field|DEFAULT_DATE_FORMATS
specifier|public
specifier|static
specifier|final
name|Collection
argument_list|<
name|String
argument_list|>
name|DEFAULT_DATE_FORMATS
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
static|static
block|{
name|DEFAULT_DATE_FORMATS
operator|.
name|add
argument_list|(
literal|"yyyy-MM-dd'T'HH:mm:ss'Z'"
argument_list|)
expr_stmt|;
name|DEFAULT_DATE_FORMATS
operator|.
name|add
argument_list|(
literal|"yyyy-MM-dd'T'HH:mm:ss"
argument_list|)
expr_stmt|;
name|DEFAULT_DATE_FORMATS
operator|.
name|add
argument_list|(
literal|"yyyy-MM-dd"
argument_list|)
expr_stmt|;
name|DEFAULT_DATE_FORMATS
operator|.
name|add
argument_list|(
literal|"yyyy-MM-dd hh:mm:ss"
argument_list|)
expr_stmt|;
name|DEFAULT_DATE_FORMATS
operator|.
name|add
argument_list|(
literal|"yyyy-MM-dd HH:mm:ss"
argument_list|)
expr_stmt|;
name|DEFAULT_DATE_FORMATS
operator|.
name|add
argument_list|(
literal|"EEE MMM d hh:mm:ss z yyyy"
argument_list|)
expr_stmt|;
name|DEFAULT_DATE_FORMATS
operator|.
name|addAll
argument_list|(
name|DEFAULT_HTTP_CLIENT_PATTERNS
argument_list|)
expr_stmt|;
block|}
comment|/**    * Returns a formatter that can be use by the current thread if needed to    * convert Date objects to the Internal representation.    *    * @param d The input date to parse    * @return The parsed {@link java.util.Date}    * @throws java.text.ParseException If the input can't be parsed    */
DECL|method|parseDate
specifier|public
specifier|static
name|Date
name|parseDate
parameter_list|(
name|String
name|d
parameter_list|)
throws|throws
name|ParseException
block|{
return|return
name|parseDate
argument_list|(
name|d
argument_list|,
name|DEFAULT_DATE_FORMATS
argument_list|)
return|;
block|}
DECL|method|parseDate
specifier|public
specifier|static
name|Date
name|parseDate
parameter_list|(
name|String
name|d
parameter_list|,
name|Collection
argument_list|<
name|String
argument_list|>
name|fmts
parameter_list|)
throws|throws
name|ParseException
block|{
if|if
condition|(
name|d
operator|.
name|length
argument_list|()
operator|>
literal|0
operator|&&
name|d
operator|.
name|charAt
argument_list|(
name|d
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
operator|==
literal|'Z'
condition|)
block|{
try|try
block|{
return|return
operator|new
name|Date
argument_list|(
name|ISO_8601_PARSER
operator|.
name|parse
argument_list|(
name|d
argument_list|,
name|Instant
operator|::
name|from
argument_list|)
operator|.
name|toEpochMilli
argument_list|()
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
comment|//ignore; perhaps we can parse with one of the formats below...
block|}
block|}
return|return
name|parseDate
argument_list|(
name|d
argument_list|,
name|fmts
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/**    * Slightly modified from org.apache.commons.httpclient.util.DateUtil.parseDate    *<p>    * Parses the date value using the given date formats.    *    * @param dateValue   the date value to parse    * @param dateFormats the date formats to use    * @param startDate   During parsing, two digit years will be placed in the range    *<code>startDate</code> to<code>startDate + 100 years</code>. This value may    *                    be<code>null</code>. When<code>null</code> is given as a parameter, year    *<code>2000</code> will be used.    * @return the parsed date    * @throws ParseException if none of the dataFormats could parse the dateValue    */
DECL|method|parseDate
specifier|public
specifier|static
name|Date
name|parseDate
parameter_list|(
name|String
name|dateValue
parameter_list|,
name|Collection
argument_list|<
name|String
argument_list|>
name|dateFormats
parameter_list|,
name|Date
name|startDate
parameter_list|)
throws|throws
name|ParseException
block|{
if|if
condition|(
name|dateValue
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"dateValue is null"
argument_list|)
throw|;
block|}
if|if
condition|(
name|dateFormats
operator|==
literal|null
condition|)
block|{
name|dateFormats
operator|=
name|DEFAULT_HTTP_CLIENT_PATTERNS
expr_stmt|;
block|}
if|if
condition|(
name|startDate
operator|==
literal|null
condition|)
block|{
name|startDate
operator|=
name|DEFAULT_TWO_DIGIT_YEAR_START
expr_stmt|;
block|}
comment|// trim single quotes around date if present
comment|// see issue #5279
if|if
condition|(
name|dateValue
operator|.
name|length
argument_list|()
operator|>
literal|1
operator|&&
name|dateValue
operator|.
name|startsWith
argument_list|(
literal|"'"
argument_list|)
operator|&&
name|dateValue
operator|.
name|endsWith
argument_list|(
literal|"'"
argument_list|)
condition|)
block|{
name|dateValue
operator|=
name|dateValue
operator|.
name|substring
argument_list|(
literal|1
argument_list|,
name|dateValue
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|//TODO upgrade to Java 8 DateTimeFormatter. But how to deal with the GMT as a default?
name|SimpleDateFormat
name|dateParser
init|=
literal|null
decl_stmt|;
name|Iterator
name|formatIter
init|=
name|dateFormats
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|formatIter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|String
name|format
init|=
operator|(
name|String
operator|)
name|formatIter
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|dateParser
operator|==
literal|null
condition|)
block|{
name|dateParser
operator|=
operator|new
name|SimpleDateFormat
argument_list|(
name|format
argument_list|,
name|Locale
operator|.
name|ENGLISH
argument_list|)
expr_stmt|;
name|dateParser
operator|.
name|setTimeZone
argument_list|(
name|GMT
argument_list|)
expr_stmt|;
name|dateParser
operator|.
name|set2DigitYearStart
argument_list|(
name|startDate
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dateParser
operator|.
name|applyPattern
argument_list|(
name|format
argument_list|)
expr_stmt|;
block|}
try|try
block|{
return|return
name|dateParser
operator|.
name|parse
argument_list|(
name|dateValue
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|ParseException
name|pe
parameter_list|)
block|{
comment|// ignore this exception, we will try the next format
block|}
block|}
comment|// we were unable to parse the date
throw|throw
operator|new
name|ParseException
argument_list|(
literal|"Unable to parse the date "
operator|+
name|dateValue
argument_list|,
literal|0
argument_list|)
throw|;
block|}
block|}
end_class
end_unit
