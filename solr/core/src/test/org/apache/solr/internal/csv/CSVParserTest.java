begin_unit
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_package
DECL|package|org.apache.solr.internal.csv
package|package
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|internal
operator|.
name|csv
package|;
end_package
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Reader
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|StringReader
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import
begin_import
import|import
name|junit
operator|.
name|framework
operator|.
name|TestCase
import|;
end_import
begin_comment
comment|/**  * CSVParserTest  *  * The test are organized in three different sections:  * The 'setter/getter' section, the lexer section and finally the parser   * section. In case a test fails, you should follow a top-down approach for   * fixing a potential bug (it's likely that the parser itself fails if the lexer  * has problems...).  */
end_comment
begin_class
DECL|class|CSVParserTest
specifier|public
class|class
name|CSVParserTest
extends|extends
name|TestCase
block|{
comment|/**    * TestCSVParser.    */
DECL|class|TestCSVParser
class|class
name|TestCSVParser
extends|extends
name|CSVParser
block|{
comment|/**      * Test parser to investigate the type of the internal Token.      * @param in a Reader      */
DECL|method|TestCSVParser
name|TestCSVParser
parameter_list|(
name|Reader
name|in
parameter_list|)
block|{
name|super
argument_list|(
name|in
argument_list|)
expr_stmt|;
block|}
DECL|method|TestCSVParser
name|TestCSVParser
parameter_list|(
name|Reader
name|in
parameter_list|,
name|CSVStrategy
name|strategy
parameter_list|)
block|{
name|super
argument_list|(
name|in
argument_list|,
name|strategy
argument_list|)
expr_stmt|;
block|}
comment|/**      * Calls super.nextToken() and prints out a String representation of token      * type and content.      * @return String representation of token type and content      * @throws IOException like {@link CSVParser#nextToken()}      */
DECL|method|testNextToken
specifier|public
name|String
name|testNextToken
parameter_list|()
throws|throws
name|IOException
block|{
name|Token
name|t
init|=
name|super
operator|.
name|nextToken
argument_list|()
decl_stmt|;
return|return
name|Integer
operator|.
name|toString
argument_list|(
name|t
operator|.
name|type
argument_list|)
operator|+
literal|";"
operator|+
name|t
operator|.
name|content
operator|+
literal|";"
return|;
block|}
block|}
comment|// ======================================================
comment|//   lexer tests
comment|// ======================================================
comment|// Single line (without comment)
DECL|method|testNextToken1
specifier|public
name|void
name|testNextToken1
parameter_list|()
throws|throws
name|IOException
block|{
name|String
name|code
init|=
literal|"abc,def, hijk,  lmnop,   qrst,uv ,wxy   ,z , ,"
decl_stmt|;
name|TestCSVParser
name|parser
init|=
operator|new
name|TestCSVParser
argument_list|(
operator|new
name|StringReader
argument_list|(
name|code
argument_list|)
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|CSVParser
operator|.
name|TT_TOKEN
operator|+
literal|";abc;"
argument_list|,
name|parser
operator|.
name|testNextToken
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|CSVParser
operator|.
name|TT_TOKEN
operator|+
literal|";def;"
argument_list|,
name|parser
operator|.
name|testNextToken
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|CSVParser
operator|.
name|TT_TOKEN
operator|+
literal|";hijk;"
argument_list|,
name|parser
operator|.
name|testNextToken
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|CSVParser
operator|.
name|TT_TOKEN
operator|+
literal|";lmnop;"
argument_list|,
name|parser
operator|.
name|testNextToken
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|CSVParser
operator|.
name|TT_TOKEN
operator|+
literal|";qrst;"
argument_list|,
name|parser
operator|.
name|testNextToken
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|CSVParser
operator|.
name|TT_TOKEN
operator|+
literal|";uv;"
argument_list|,
name|parser
operator|.
name|testNextToken
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|CSVParser
operator|.
name|TT_TOKEN
operator|+
literal|";wxy;"
argument_list|,
name|parser
operator|.
name|testNextToken
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|CSVParser
operator|.
name|TT_TOKEN
operator|+
literal|";z;"
argument_list|,
name|parser
operator|.
name|testNextToken
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|CSVParser
operator|.
name|TT_TOKEN
operator|+
literal|";;"
argument_list|,
name|parser
operator|.
name|testNextToken
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|CSVParser
operator|.
name|TT_EOF
operator|+
literal|";;"
argument_list|,
name|parser
operator|.
name|testNextToken
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// multiline including comments (and empty lines)
DECL|method|testNextToken2
specifier|public
name|void
name|testNextToken2
parameter_list|()
throws|throws
name|IOException
block|{
comment|/*   file:   1,2,3,      *           a,b x,c      *      *           # this is a comment       *           d,e,      *       */
name|String
name|code
init|=
literal|"1,2,3,\na,b x,c\n#foo\n\nd,e,\n\n"
decl_stmt|;
name|CSVStrategy
name|strategy
init|=
operator|(
name|CSVStrategy
operator|)
name|CSVStrategy
operator|.
name|DEFAULT_STRATEGY
operator|.
name|clone
argument_list|()
decl_stmt|;
comment|// strategy.setIgnoreEmptyLines(false);
name|strategy
operator|.
name|setCommentStart
argument_list|(
literal|'#'
argument_list|)
expr_stmt|;
name|TestCSVParser
name|parser
init|=
operator|new
name|TestCSVParser
argument_list|(
operator|new
name|StringReader
argument_list|(
name|code
argument_list|)
argument_list|,
name|strategy
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|CSVParser
operator|.
name|TT_TOKEN
operator|+
literal|";1;"
argument_list|,
name|parser
operator|.
name|testNextToken
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|CSVParser
operator|.
name|TT_TOKEN
operator|+
literal|";2;"
argument_list|,
name|parser
operator|.
name|testNextToken
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|CSVParser
operator|.
name|TT_TOKEN
operator|+
literal|";3;"
argument_list|,
name|parser
operator|.
name|testNextToken
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|CSVParser
operator|.
name|TT_EORECORD
operator|+
literal|";;"
argument_list|,
name|parser
operator|.
name|testNextToken
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|CSVParser
operator|.
name|TT_TOKEN
operator|+
literal|";a;"
argument_list|,
name|parser
operator|.
name|testNextToken
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|CSVParser
operator|.
name|TT_TOKEN
operator|+
literal|";b x;"
argument_list|,
name|parser
operator|.
name|testNextToken
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|CSVParser
operator|.
name|TT_EORECORD
operator|+
literal|";c;"
argument_list|,
name|parser
operator|.
name|testNextToken
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|CSVParser
operator|.
name|TT_EORECORD
operator|+
literal|";;"
argument_list|,
name|parser
operator|.
name|testNextToken
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|CSVParser
operator|.
name|TT_TOKEN
operator|+
literal|";d;"
argument_list|,
name|parser
operator|.
name|testNextToken
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|CSVParser
operator|.
name|TT_TOKEN
operator|+
literal|";e;"
argument_list|,
name|parser
operator|.
name|testNextToken
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|CSVParser
operator|.
name|TT_EORECORD
operator|+
literal|";;"
argument_list|,
name|parser
operator|.
name|testNextToken
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|CSVParser
operator|.
name|TT_EOF
operator|+
literal|";;"
argument_list|,
name|parser
operator|.
name|testNextToken
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|CSVParser
operator|.
name|TT_EOF
operator|+
literal|";;"
argument_list|,
name|parser
operator|.
name|testNextToken
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// simple token with escaping
DECL|method|testNextToken3
specifier|public
name|void
name|testNextToken3
parameter_list|()
throws|throws
name|IOException
block|{
comment|/* file: a,\,,b      *       \,,      */
name|String
name|code
init|=
literal|"a,\\,,b\n\\,,"
decl_stmt|;
name|CSVStrategy
name|strategy
init|=
operator|(
name|CSVStrategy
operator|)
name|CSVStrategy
operator|.
name|DEFAULT_STRATEGY
operator|.
name|clone
argument_list|()
decl_stmt|;
name|strategy
operator|.
name|setCommentStart
argument_list|(
literal|'#'
argument_list|)
expr_stmt|;
name|TestCSVParser
name|parser
init|=
operator|new
name|TestCSVParser
argument_list|(
operator|new
name|StringReader
argument_list|(
name|code
argument_list|)
argument_list|,
name|strategy
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|CSVParser
operator|.
name|TT_TOKEN
operator|+
literal|";a;"
argument_list|,
name|parser
operator|.
name|testNextToken
argument_list|()
argument_list|)
expr_stmt|;
comment|// an unquoted single backslash is not an escape char
name|assertEquals
argument_list|(
name|CSVParser
operator|.
name|TT_TOKEN
operator|+
literal|";\\;"
argument_list|,
name|parser
operator|.
name|testNextToken
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|CSVParser
operator|.
name|TT_TOKEN
operator|+
literal|";;"
argument_list|,
name|parser
operator|.
name|testNextToken
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|CSVParser
operator|.
name|TT_EORECORD
operator|+
literal|";b;"
argument_list|,
name|parser
operator|.
name|testNextToken
argument_list|()
argument_list|)
expr_stmt|;
comment|// an unquoted single backslash is not an escape char
name|assertEquals
argument_list|(
name|CSVParser
operator|.
name|TT_TOKEN
operator|+
literal|";\\;"
argument_list|,
name|parser
operator|.
name|testNextToken
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|CSVParser
operator|.
name|TT_TOKEN
operator|+
literal|";;"
argument_list|,
name|parser
operator|.
name|testNextToken
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|CSVParser
operator|.
name|TT_EOF
operator|+
literal|";;"
argument_list|,
name|parser
operator|.
name|testNextToken
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// encapsulator tokenizer (sinle line)
DECL|method|testNextToken4
specifier|public
name|void
name|testNextToken4
parameter_list|()
throws|throws
name|IOException
block|{
comment|/* file:  a,"foo",b      *        a,   " foo",b      *        a,"foo "   ,b     // whitespace after closing encapsulator      *        a,  " foo " ,b      */
name|String
name|code
init|=
literal|"a,\"foo\",b\na,   \" foo\",b\na,\"foo \"  ,b\na,  \" foo \"  ,b"
decl_stmt|;
name|TestCSVParser
name|parser
init|=
operator|new
name|TestCSVParser
argument_list|(
operator|new
name|StringReader
argument_list|(
name|code
argument_list|)
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|CSVParser
operator|.
name|TT_TOKEN
operator|+
literal|";a;"
argument_list|,
name|parser
operator|.
name|testNextToken
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|CSVParser
operator|.
name|TT_TOKEN
operator|+
literal|";foo;"
argument_list|,
name|parser
operator|.
name|testNextToken
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|CSVParser
operator|.
name|TT_EORECORD
operator|+
literal|";b;"
argument_list|,
name|parser
operator|.
name|testNextToken
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|CSVParser
operator|.
name|TT_TOKEN
operator|+
literal|";a;"
argument_list|,
name|parser
operator|.
name|testNextToken
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|CSVParser
operator|.
name|TT_TOKEN
operator|+
literal|"; foo;"
argument_list|,
name|parser
operator|.
name|testNextToken
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|CSVParser
operator|.
name|TT_EORECORD
operator|+
literal|";b;"
argument_list|,
name|parser
operator|.
name|testNextToken
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|CSVParser
operator|.
name|TT_TOKEN
operator|+
literal|";a;"
argument_list|,
name|parser
operator|.
name|testNextToken
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|CSVParser
operator|.
name|TT_TOKEN
operator|+
literal|";foo ;"
argument_list|,
name|parser
operator|.
name|testNextToken
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|CSVParser
operator|.
name|TT_EORECORD
operator|+
literal|";b;"
argument_list|,
name|parser
operator|.
name|testNextToken
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|CSVParser
operator|.
name|TT_TOKEN
operator|+
literal|";a;"
argument_list|,
name|parser
operator|.
name|testNextToken
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|CSVParser
operator|.
name|TT_TOKEN
operator|+
literal|"; foo ;"
argument_list|,
name|parser
operator|.
name|testNextToken
argument_list|()
argument_list|)
expr_stmt|;
comment|//     assertEquals(CSVParser.TT_EORECORD + ";b;", parser.testNextToken());
name|assertEquals
argument_list|(
name|CSVParser
operator|.
name|TT_EOF
operator|+
literal|";b;"
argument_list|,
name|parser
operator|.
name|testNextToken
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// encapsulator tokenizer (multi line, delimiter in string)
DECL|method|testNextToken5
specifier|public
name|void
name|testNextToken5
parameter_list|()
throws|throws
name|IOException
block|{
name|String
name|code
init|=
literal|"a,\"foo\n\",b\n\"foo\n  baar ,,,\"\n\"\n\t \n\""
decl_stmt|;
name|TestCSVParser
name|parser
init|=
operator|new
name|TestCSVParser
argument_list|(
operator|new
name|StringReader
argument_list|(
name|code
argument_list|)
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|CSVParser
operator|.
name|TT_TOKEN
operator|+
literal|";a;"
argument_list|,
name|parser
operator|.
name|testNextToken
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|CSVParser
operator|.
name|TT_TOKEN
operator|+
literal|";foo\n;"
argument_list|,
name|parser
operator|.
name|testNextToken
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|CSVParser
operator|.
name|TT_EORECORD
operator|+
literal|";b;"
argument_list|,
name|parser
operator|.
name|testNextToken
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|CSVParser
operator|.
name|TT_EORECORD
operator|+
literal|";foo\n  baar ,,,;"
argument_list|,
name|parser
operator|.
name|testNextToken
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|CSVParser
operator|.
name|TT_EOF
operator|+
literal|";\n\t \n;"
argument_list|,
name|parser
operator|.
name|testNextToken
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// change delimiters, comment, encapsulater
DECL|method|testNextToken6
specifier|public
name|void
name|testNextToken6
parameter_list|()
throws|throws
name|IOException
block|{
comment|/* file: a;'b and \' more      *       '      *       !comment;;;;      *       ;;      */
name|String
name|code
init|=
literal|"a;'b and '' more\n'\n!comment;;;;\n;;"
decl_stmt|;
name|TestCSVParser
name|parser
init|=
operator|new
name|TestCSVParser
argument_list|(
operator|new
name|StringReader
argument_list|(
name|code
argument_list|)
argument_list|,
operator|new
name|CSVStrategy
argument_list|(
literal|';'
argument_list|,
literal|'\''
argument_list|,
literal|'!'
argument_list|)
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|CSVParser
operator|.
name|TT_TOKEN
operator|+
literal|";a;"
argument_list|,
name|parser
operator|.
name|testNextToken
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|CSVParser
operator|.
name|TT_EORECORD
operator|+
literal|";b and ' more\n;"
argument_list|,
name|parser
operator|.
name|testNextToken
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// ======================================================
comment|//   parser tests
comment|// ======================================================
DECL|field|code
name|String
name|code
init|=
literal|"a,b,c,d\n"
operator|+
literal|" a , b , 1 2 \n"
operator|+
literal|"\"foo baar\", b,\n"
comment|// + "   \"foo\n,,\n\"\",,\n\\\"\",d,e\n";
operator|+
literal|"   \"foo\n,,\n\"\",,\n\"\"\",d,e\n"
decl_stmt|;
comment|// changed to use standard CSV escaping
DECL|field|res
name|String
index|[]
index|[]
name|res
init|=
block|{
block|{
literal|"a"
block|,
literal|"b"
block|,
literal|"c"
block|,
literal|"d"
block|}
block|,
block|{
literal|"a"
block|,
literal|"b"
block|,
literal|"1 2"
block|}
block|,
block|{
literal|"foo baar"
block|,
literal|"b"
block|,
literal|""
block|}
block|,
block|{
literal|"foo\n,,\n\",,\n\""
block|,
literal|"d"
block|,
literal|"e"
block|}
block|}
decl_stmt|;
DECL|method|testGetLine
specifier|public
name|void
name|testGetLine
parameter_list|()
throws|throws
name|IOException
block|{
name|CSVParser
name|parser
init|=
operator|new
name|CSVParser
argument_list|(
operator|new
name|StringReader
argument_list|(
name|code
argument_list|)
argument_list|)
decl_stmt|;
name|String
index|[]
name|tmp
init|=
literal|null
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|res
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|tmp
operator|=
name|parser
operator|.
name|getLine
argument_list|()
expr_stmt|;
name|assertTrue
argument_list|(
name|Arrays
operator|.
name|equals
argument_list|(
name|res
index|[
name|i
index|]
argument_list|,
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|tmp
operator|=
name|parser
operator|.
name|getLine
argument_list|()
expr_stmt|;
name|assertTrue
argument_list|(
name|tmp
operator|==
literal|null
argument_list|)
expr_stmt|;
block|}
DECL|method|testNextValue
specifier|public
name|void
name|testNextValue
parameter_list|()
throws|throws
name|IOException
block|{
name|CSVParser
name|parser
init|=
operator|new
name|CSVParser
argument_list|(
operator|new
name|StringReader
argument_list|(
name|code
argument_list|)
argument_list|)
decl_stmt|;
name|String
name|tmp
init|=
literal|null
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|res
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|res
index|[
name|i
index|]
operator|.
name|length
condition|;
name|j
operator|++
control|)
block|{
name|tmp
operator|=
name|parser
operator|.
name|nextValue
argument_list|()
expr_stmt|;
name|assertEquals
argument_list|(
name|res
index|[
name|i
index|]
index|[
name|j
index|]
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
block|}
block|}
name|tmp
operator|=
name|parser
operator|.
name|nextValue
argument_list|()
expr_stmt|;
name|assertTrue
argument_list|(
name|tmp
operator|==
literal|null
argument_list|)
expr_stmt|;
block|}
DECL|method|testGetAllValues
specifier|public
name|void
name|testGetAllValues
parameter_list|()
throws|throws
name|IOException
block|{
name|CSVParser
name|parser
init|=
operator|new
name|CSVParser
argument_list|(
operator|new
name|StringReader
argument_list|(
name|code
argument_list|)
argument_list|)
decl_stmt|;
name|String
index|[]
index|[]
name|tmp
init|=
name|parser
operator|.
name|getAllValues
argument_list|()
decl_stmt|;
name|assertEquals
argument_list|(
name|res
operator|.
name|length
argument_list|,
name|tmp
operator|.
name|length
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|tmp
operator|.
name|length
operator|>
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|res
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|assertTrue
argument_list|(
name|Arrays
operator|.
name|equals
argument_list|(
name|res
index|[
name|i
index|]
argument_list|,
name|tmp
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|testExcelStrategy1
specifier|public
name|void
name|testExcelStrategy1
parameter_list|()
throws|throws
name|IOException
block|{
name|String
name|code
init|=
literal|"value1,value2,value3,value4\r\na,b,c,d\r\n  x,,,"
operator|+
literal|"\r\n\r\n\"\"\"hello\"\"\",\"  \"\"world\"\"\",\"abc\ndef\",\r\n"
decl_stmt|;
name|String
index|[]
index|[]
name|res
init|=
block|{
block|{
literal|"value1"
block|,
literal|"value2"
block|,
literal|"value3"
block|,
literal|"value4"
block|}
block|,
block|{
literal|"a"
block|,
literal|"b"
block|,
literal|"c"
block|,
literal|"d"
block|}
block|,
block|{
literal|"  x"
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|}
block|,
block|{
literal|""
block|}
block|,
block|{
literal|"\"hello\""
block|,
literal|"  \"world\""
block|,
literal|"abc\ndef"
block|,
literal|""
block|}
block|}
decl_stmt|;
name|CSVParser
name|parser
init|=
operator|new
name|CSVParser
argument_list|(
operator|new
name|StringReader
argument_list|(
name|code
argument_list|)
argument_list|,
name|CSVStrategy
operator|.
name|EXCEL_STRATEGY
argument_list|)
decl_stmt|;
name|String
index|[]
index|[]
name|tmp
init|=
name|parser
operator|.
name|getAllValues
argument_list|()
decl_stmt|;
name|assertEquals
argument_list|(
name|res
operator|.
name|length
argument_list|,
name|tmp
operator|.
name|length
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|tmp
operator|.
name|length
operator|>
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|res
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|assertTrue
argument_list|(
name|Arrays
operator|.
name|equals
argument_list|(
name|res
index|[
name|i
index|]
argument_list|,
name|tmp
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|testExcelStrategy2
specifier|public
name|void
name|testExcelStrategy2
parameter_list|()
throws|throws
name|Exception
block|{
name|String
name|code
init|=
literal|"foo,baar\r\n\r\nhello,\r\n\r\nworld,\r\n"
decl_stmt|;
name|String
index|[]
index|[]
name|res
init|=
block|{
block|{
literal|"foo"
block|,
literal|"baar"
block|}
block|,
block|{
literal|""
block|}
block|,
block|{
literal|"hello"
block|,
literal|""
block|}
block|,
block|{
literal|""
block|}
block|,
block|{
literal|"world"
block|,
literal|""
block|}
block|}
decl_stmt|;
name|CSVParser
name|parser
init|=
operator|new
name|CSVParser
argument_list|(
operator|new
name|StringReader
argument_list|(
name|code
argument_list|)
argument_list|,
name|CSVStrategy
operator|.
name|EXCEL_STRATEGY
argument_list|)
decl_stmt|;
name|String
index|[]
index|[]
name|tmp
init|=
name|parser
operator|.
name|getAllValues
argument_list|()
decl_stmt|;
name|assertEquals
argument_list|(
name|res
operator|.
name|length
argument_list|,
name|tmp
operator|.
name|length
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|tmp
operator|.
name|length
operator|>
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|res
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|assertTrue
argument_list|(
name|Arrays
operator|.
name|equals
argument_list|(
name|res
index|[
name|i
index|]
argument_list|,
name|tmp
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|testEndOfFileBehaviourExcel
specifier|public
name|void
name|testEndOfFileBehaviourExcel
parameter_list|()
throws|throws
name|Exception
block|{
name|String
index|[]
name|codes
init|=
block|{
literal|"hello,\r\n\r\nworld,\r\n"
block|,
literal|"hello,\r\n\r\nworld,"
block|,
literal|"hello,\r\n\r\nworld,\"\"\r\n"
block|,
literal|"hello,\r\n\r\nworld,\"\""
block|,
literal|"hello,\r\n\r\nworld,\n"
block|,
literal|"hello,\r\n\r\nworld,"
block|,
literal|"hello,\r\n\r\nworld,\"\"\n"
block|,
literal|"hello,\r\n\r\nworld,\"\""
block|}
decl_stmt|;
name|String
index|[]
index|[]
name|res
init|=
block|{
block|{
literal|"hello"
block|,
literal|""
block|}
block|,
block|{
literal|""
block|}
block|,
comment|// ExcelStrategy does not ignore empty lines
block|{
literal|"world"
block|,
literal|""
block|}
block|}
decl_stmt|;
name|String
name|code
decl_stmt|;
for|for
control|(
name|int
name|codeIndex
init|=
literal|0
init|;
name|codeIndex
operator|<
name|codes
operator|.
name|length
condition|;
name|codeIndex
operator|++
control|)
block|{
name|code
operator|=
name|codes
index|[
name|codeIndex
index|]
expr_stmt|;
name|CSVParser
name|parser
init|=
operator|new
name|CSVParser
argument_list|(
operator|new
name|StringReader
argument_list|(
name|code
argument_list|)
argument_list|,
name|CSVStrategy
operator|.
name|EXCEL_STRATEGY
argument_list|)
decl_stmt|;
name|String
index|[]
index|[]
name|tmp
init|=
name|parser
operator|.
name|getAllValues
argument_list|()
decl_stmt|;
name|assertEquals
argument_list|(
name|res
operator|.
name|length
argument_list|,
name|tmp
operator|.
name|length
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|tmp
operator|.
name|length
operator|>
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|res
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|assertTrue
argument_list|(
name|Arrays
operator|.
name|equals
argument_list|(
name|res
index|[
name|i
index|]
argument_list|,
name|tmp
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|testEndOfFileBehaviorCSV
specifier|public
name|void
name|testEndOfFileBehaviorCSV
parameter_list|()
throws|throws
name|Exception
block|{
name|String
index|[]
name|codes
init|=
block|{
literal|"hello,\r\n\r\nworld,\r\n"
block|,
literal|"hello,\r\n\r\nworld,"
block|,
literal|"hello,\r\n\r\nworld,\"\"\r\n"
block|,
literal|"hello,\r\n\r\nworld,\"\""
block|,
literal|"hello,\r\n\r\nworld,\n"
block|,
literal|"hello,\r\n\r\nworld,"
block|,
literal|"hello,\r\n\r\nworld,\"\"\n"
block|,
literal|"hello,\r\n\r\nworld,\"\""
block|}
decl_stmt|;
name|String
index|[]
index|[]
name|res
init|=
block|{
block|{
literal|"hello"
block|,
literal|""
block|}
block|,
comment|// CSV Strategy ignores empty lines
block|{
literal|"world"
block|,
literal|""
block|}
block|}
decl_stmt|;
name|String
name|code
decl_stmt|;
for|for
control|(
name|int
name|codeIndex
init|=
literal|0
init|;
name|codeIndex
operator|<
name|codes
operator|.
name|length
condition|;
name|codeIndex
operator|++
control|)
block|{
name|code
operator|=
name|codes
index|[
name|codeIndex
index|]
expr_stmt|;
name|CSVParser
name|parser
init|=
operator|new
name|CSVParser
argument_list|(
operator|new
name|StringReader
argument_list|(
name|code
argument_list|)
argument_list|)
decl_stmt|;
name|String
index|[]
index|[]
name|tmp
init|=
name|parser
operator|.
name|getAllValues
argument_list|()
decl_stmt|;
name|assertEquals
argument_list|(
name|res
operator|.
name|length
argument_list|,
name|tmp
operator|.
name|length
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|tmp
operator|.
name|length
operator|>
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|res
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|assertTrue
argument_list|(
name|Arrays
operator|.
name|equals
argument_list|(
name|res
index|[
name|i
index|]
argument_list|,
name|tmp
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|testEmptyLineBehaviourExcel
specifier|public
name|void
name|testEmptyLineBehaviourExcel
parameter_list|()
throws|throws
name|Exception
block|{
name|String
index|[]
name|codes
init|=
block|{
literal|"hello,\r\n\r\n\r\n"
block|,
literal|"hello,\n\n\n"
block|,
literal|"hello,\"\"\r\n\r\n\r\n"
block|,
literal|"hello,\"\"\n\n\n"
block|}
decl_stmt|;
name|String
index|[]
index|[]
name|res
init|=
block|{
block|{
literal|"hello"
block|,
literal|""
block|}
block|,
block|{
literal|""
block|}
block|,
comment|// ExcelStrategy does not ignore empty lines
block|{
literal|""
block|}
block|}
decl_stmt|;
name|String
name|code
decl_stmt|;
for|for
control|(
name|int
name|codeIndex
init|=
literal|0
init|;
name|codeIndex
operator|<
name|codes
operator|.
name|length
condition|;
name|codeIndex
operator|++
control|)
block|{
name|code
operator|=
name|codes
index|[
name|codeIndex
index|]
expr_stmt|;
name|CSVParser
name|parser
init|=
operator|new
name|CSVParser
argument_list|(
operator|new
name|StringReader
argument_list|(
name|code
argument_list|)
argument_list|,
name|CSVStrategy
operator|.
name|EXCEL_STRATEGY
argument_list|)
decl_stmt|;
name|String
index|[]
index|[]
name|tmp
init|=
name|parser
operator|.
name|getAllValues
argument_list|()
decl_stmt|;
name|assertEquals
argument_list|(
name|res
operator|.
name|length
argument_list|,
name|tmp
operator|.
name|length
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|tmp
operator|.
name|length
operator|>
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|res
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|assertTrue
argument_list|(
name|Arrays
operator|.
name|equals
argument_list|(
name|res
index|[
name|i
index|]
argument_list|,
name|tmp
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|testEmptyLineBehaviourCSV
specifier|public
name|void
name|testEmptyLineBehaviourCSV
parameter_list|()
throws|throws
name|Exception
block|{
name|String
index|[]
name|codes
init|=
block|{
literal|"hello,\r\n\r\n\r\n"
block|,
literal|"hello,\n\n\n"
block|,
literal|"hello,\"\"\r\n\r\n\r\n"
block|,
literal|"hello,\"\"\n\n\n"
block|}
decl_stmt|;
name|String
index|[]
index|[]
name|res
init|=
block|{
block|{
literal|"hello"
block|,
literal|""
block|}
comment|// CSV Strategy ignores empty lines
block|}
decl_stmt|;
name|String
name|code
decl_stmt|;
for|for
control|(
name|int
name|codeIndex
init|=
literal|0
init|;
name|codeIndex
operator|<
name|codes
operator|.
name|length
condition|;
name|codeIndex
operator|++
control|)
block|{
name|code
operator|=
name|codes
index|[
name|codeIndex
index|]
expr_stmt|;
name|CSVParser
name|parser
init|=
operator|new
name|CSVParser
argument_list|(
operator|new
name|StringReader
argument_list|(
name|code
argument_list|)
argument_list|)
decl_stmt|;
name|String
index|[]
index|[]
name|tmp
init|=
name|parser
operator|.
name|getAllValues
argument_list|()
decl_stmt|;
name|assertEquals
argument_list|(
name|res
operator|.
name|length
argument_list|,
name|tmp
operator|.
name|length
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|tmp
operator|.
name|length
operator|>
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|res
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|assertTrue
argument_list|(
name|Arrays
operator|.
name|equals
argument_list|(
name|res
index|[
name|i
index|]
argument_list|,
name|tmp
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|OLDtestBackslashEscaping
specifier|public
name|void
name|OLDtestBackslashEscaping
parameter_list|()
throws|throws
name|IOException
block|{
name|String
name|code
init|=
literal|"one,two,three\n"
operator|+
literal|"on\\\"e,two\n"
operator|+
literal|"on\"e,two\n"
operator|+
literal|"one,\"tw\\\"o\"\n"
operator|+
literal|"one,\"t\\,wo\"\n"
operator|+
literal|"one,two,\"th,ree\"\n"
operator|+
literal|"\"a\\\\\"\n"
operator|+
literal|"a\\,b\n"
operator|+
literal|"\"a\\\\,b\""
decl_stmt|;
name|String
index|[]
index|[]
name|res
init|=
block|{
block|{
literal|"one"
block|,
literal|"two"
block|,
literal|"three"
block|}
block|,
block|{
literal|"on\\\"e"
block|,
literal|"two"
block|}
block|,
block|{
literal|"on\"e"
block|,
literal|"two"
block|}
block|,
block|{
literal|"one"
block|,
literal|"tw\"o"
block|}
block|,
block|{
literal|"one"
block|,
literal|"t\\,wo"
block|}
block|,
comment|// backslash in quotes only escapes a delimiter (",")
block|{
literal|"one"
block|,
literal|"two"
block|,
literal|"th,ree"
block|}
block|,
block|{
literal|"a\\\\"
block|}
block|,
comment|// backslash in quotes only escapes a delimiter (",")
block|{
literal|"a\\"
block|,
literal|"b"
block|}
block|,
comment|// a backslash must be returnd
block|{
literal|"a\\\\,b"
block|}
comment|// backslash in quotes only escapes a delimiter (",")
block|}
decl_stmt|;
name|CSVParser
name|parser
init|=
operator|new
name|CSVParser
argument_list|(
operator|new
name|StringReader
argument_list|(
name|code
argument_list|)
argument_list|)
decl_stmt|;
name|String
index|[]
index|[]
name|tmp
init|=
name|parser
operator|.
name|getAllValues
argument_list|()
decl_stmt|;
name|assertEquals
argument_list|(
name|res
operator|.
name|length
argument_list|,
name|tmp
operator|.
name|length
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|tmp
operator|.
name|length
operator|>
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|res
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|assertTrue
argument_list|(
name|Arrays
operator|.
name|equals
argument_list|(
name|res
index|[
name|i
index|]
argument_list|,
name|tmp
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|testBackslashEscaping
specifier|public
name|void
name|testBackslashEscaping
parameter_list|()
throws|throws
name|IOException
block|{
comment|// To avoid confusion over the need for escaping chars in java code,
comment|// We will test with a forward slash as the escape char, and a single
comment|// quote as the encapsulator.
name|String
name|code
init|=
literal|"one,two,three\n"
comment|// 0
operator|+
literal|"'',''\n"
comment|// 1) empty encapsulators
operator|+
literal|"/',/'\n"
comment|// 2) single encapsulators
operator|+
literal|"'/'','/''\n"
comment|// 3) single encapsulators encapsulated via escape
operator|+
literal|"'''',''''\n"
comment|// 4) single encapsulators encapsulated via doubling
operator|+
literal|"/,,/,\n"
comment|// 5) separator escaped
operator|+
literal|"//,//\n"
comment|// 6) escape escaped
operator|+
literal|"'//','//'\n"
comment|// 7) escape escaped in encapsulation
operator|+
literal|"   8   ,   \"quoted \"\" /\" // string\"   \n"
comment|// don't eat spaces
operator|+
literal|"9,   /\n   \n"
comment|// escaped newline
operator|+
literal|""
decl_stmt|;
name|String
index|[]
index|[]
name|res
init|=
block|{
block|{
literal|"one"
block|,
literal|"two"
block|,
literal|"three"
block|}
block|,
comment|// 0
block|{
literal|""
block|,
literal|""
block|}
block|,
comment|// 1
block|{
literal|"'"
block|,
literal|"'"
block|}
block|,
comment|// 2
block|{
literal|"'"
block|,
literal|"'"
block|}
block|,
comment|// 3
block|{
literal|"'"
block|,
literal|"'"
block|}
block|,
comment|// 4
block|{
literal|","
block|,
literal|","
block|}
block|,
comment|// 5
block|{
literal|"/"
block|,
literal|"/"
block|}
block|,
comment|// 6
block|{
literal|"/"
block|,
literal|"/"
block|}
block|,
comment|// 7
block|{
literal|"   8   "
block|,
literal|"   \"quoted \"\" \" / string\"   "
block|}
block|,
block|{
literal|"9"
block|,
literal|"   \n   "
block|}
block|,       }
decl_stmt|;
name|CSVStrategy
name|strategy
init|=
operator|new
name|CSVStrategy
argument_list|(
literal|','
argument_list|,
literal|'\''
argument_list|,
name|CSVStrategy
operator|.
name|COMMENTS_DISABLED
argument_list|,
literal|'/'
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|,
literal|true
argument_list|,
literal|true
argument_list|,
literal|"\n"
argument_list|)
decl_stmt|;
name|CSVParser
name|parser
init|=
operator|new
name|CSVParser
argument_list|(
operator|new
name|StringReader
argument_list|(
name|code
argument_list|)
argument_list|,
name|strategy
argument_list|)
decl_stmt|;
name|String
index|[]
index|[]
name|tmp
init|=
name|parser
operator|.
name|getAllValues
argument_list|()
decl_stmt|;
name|assertTrue
argument_list|(
name|tmp
operator|.
name|length
operator|>
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|res
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|assertTrue
argument_list|(
name|Arrays
operator|.
name|equals
argument_list|(
name|res
index|[
name|i
index|]
argument_list|,
name|tmp
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|testBackslashEscaping2
specifier|public
name|void
name|testBackslashEscaping2
parameter_list|()
throws|throws
name|IOException
block|{
comment|// To avoid confusion over the need for escaping chars in java code,
comment|// We will test with a forward slash as the escape char, and a single
comment|// quote as the encapsulator.
name|String
name|code
init|=
literal|""
operator|+
literal|" , , \n"
comment|// 1)
operator|+
literal|" \t ,  , \n"
comment|// 2)
operator|+
literal|" // , /, , /,\n"
comment|// 3)
operator|+
literal|""
decl_stmt|;
name|String
index|[]
index|[]
name|res
init|=
block|{
block|{
literal|" "
block|,
literal|" "
block|,
literal|" "
block|}
block|,
comment|// 1
block|{
literal|" \t "
block|,
literal|"  "
block|,
literal|" "
block|}
block|,
comment|// 2
block|{
literal|" / "
block|,
literal|" , "
block|,
literal|" ,"
block|}
block|,
comment|//3
block|}
decl_stmt|;
name|CSVStrategy
name|strategy
init|=
operator|new
name|CSVStrategy
argument_list|(
literal|','
argument_list|,
name|CSVStrategy
operator|.
name|ENCAPSULATOR_DISABLED
argument_list|,
name|CSVStrategy
operator|.
name|COMMENTS_DISABLED
argument_list|,
literal|'/'
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|,
literal|true
argument_list|,
literal|true
argument_list|,
literal|"\n"
argument_list|)
decl_stmt|;
name|CSVParser
name|parser
init|=
operator|new
name|CSVParser
argument_list|(
operator|new
name|StringReader
argument_list|(
name|code
argument_list|)
argument_list|,
name|strategy
argument_list|)
decl_stmt|;
name|String
index|[]
index|[]
name|tmp
init|=
name|parser
operator|.
name|getAllValues
argument_list|()
decl_stmt|;
name|assertTrue
argument_list|(
name|tmp
operator|.
name|length
operator|>
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|CSVPrinterTest
operator|.
name|equals
argument_list|(
name|res
argument_list|,
name|tmp
argument_list|)
condition|)
block|{
name|assertTrue
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|testDefaultStrategy
specifier|public
name|void
name|testDefaultStrategy
parameter_list|()
throws|throws
name|IOException
block|{
name|String
name|code
init|=
literal|""
operator|+
literal|"a,b\n"
comment|// 1)
operator|+
literal|"\"\n\",\" \"\n"
comment|// 2)
operator|+
literal|"\"\",#\n"
comment|// 2)
decl_stmt|;
name|String
index|[]
index|[]
name|res
init|=
block|{
block|{
literal|"a"
block|,
literal|"b"
block|}
block|,
block|{
literal|"\n"
block|,
literal|" "
block|}
block|,
block|{
literal|""
block|,
literal|"#"
block|}
block|,     }
decl_stmt|;
name|CSVStrategy
name|strategy
init|=
name|CSVStrategy
operator|.
name|DEFAULT_STRATEGY
decl_stmt|;
name|assertEquals
argument_list|(
name|CSVStrategy
operator|.
name|COMMENTS_DISABLED
argument_list|,
name|strategy
operator|.
name|getCommentStart
argument_list|()
argument_list|)
expr_stmt|;
name|CSVParser
name|parser
init|=
operator|new
name|CSVParser
argument_list|(
operator|new
name|StringReader
argument_list|(
name|code
argument_list|)
argument_list|,
name|strategy
argument_list|)
decl_stmt|;
name|String
index|[]
index|[]
name|tmp
init|=
name|parser
operator|.
name|getAllValues
argument_list|()
decl_stmt|;
name|assertTrue
argument_list|(
name|tmp
operator|.
name|length
operator|>
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|CSVPrinterTest
operator|.
name|equals
argument_list|(
name|res
argument_list|,
name|tmp
argument_list|)
condition|)
block|{
name|assertTrue
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
name|String
index|[]
index|[]
name|res_comments
init|=
block|{
block|{
literal|"a"
block|,
literal|"b"
block|}
block|,
block|{
literal|"\n"
block|,
literal|" "
block|}
block|,
block|{
literal|""
block|}
block|,     }
decl_stmt|;
name|strategy
operator|=
operator|new
name|CSVStrategy
argument_list|(
literal|','
argument_list|,
literal|'"'
argument_list|,
literal|'#'
argument_list|)
expr_stmt|;
name|parser
operator|=
operator|new
name|CSVParser
argument_list|(
operator|new
name|StringReader
argument_list|(
name|code
argument_list|)
argument_list|,
name|strategy
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|parser
operator|.
name|getAllValues
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|CSVPrinterTest
operator|.
name|equals
argument_list|(
name|res_comments
argument_list|,
name|tmp
argument_list|)
condition|)
block|{
name|assertTrue
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|testUnicodeEscape
specifier|public
name|void
name|testUnicodeEscape
parameter_list|()
throws|throws
name|IOException
block|{
name|String
name|code
init|=
literal|"abc,\\u0070\\u0075\\u0062\\u006C\\u0069\\u0063"
decl_stmt|;
name|CSVStrategy
name|strategy
init|=
operator|(
name|CSVStrategy
operator|)
name|CSVStrategy
operator|.
name|DEFAULT_STRATEGY
operator|.
name|clone
argument_list|()
decl_stmt|;
name|strategy
operator|.
name|setUnicodeEscapeInterpretation
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|CSVParser
name|parser
init|=
operator|new
name|CSVParser
argument_list|(
operator|new
name|StringReader
argument_list|(
name|code
argument_list|)
argument_list|,
name|strategy
argument_list|)
decl_stmt|;
name|String
index|[]
name|data
init|=
name|parser
operator|.
name|getLine
argument_list|()
decl_stmt|;
name|assertEquals
argument_list|(
literal|2
argument_list|,
name|data
operator|.
name|length
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"abc"
argument_list|,
name|data
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"public"
argument_list|,
name|data
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
DECL|method|testCarriageReturnLineFeedEndings
specifier|public
name|void
name|testCarriageReturnLineFeedEndings
parameter_list|()
throws|throws
name|IOException
block|{
name|String
name|code
init|=
literal|"foo\r\nbaar,\r\nhello,world\r\n,kanu"
decl_stmt|;
name|CSVParser
name|parser
init|=
operator|new
name|CSVParser
argument_list|(
operator|new
name|StringReader
argument_list|(
name|code
argument_list|)
argument_list|)
decl_stmt|;
name|String
index|[]
index|[]
name|data
init|=
name|parser
operator|.
name|getAllValues
argument_list|()
decl_stmt|;
name|assertEquals
argument_list|(
literal|4
argument_list|,
name|data
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
DECL|method|testIgnoreEmptyLines
specifier|public
name|void
name|testIgnoreEmptyLines
parameter_list|()
throws|throws
name|IOException
block|{
name|String
name|code
init|=
literal|"\nfoo,baar\n\r\n,\n\n,world\r\n\n"
decl_stmt|;
comment|//String code = "world\r\n\n";
comment|//String code = "foo;baar\r\n\r\nhello;\r\n\r\nworld;\r\n";
name|CSVParser
name|parser
init|=
operator|new
name|CSVParser
argument_list|(
operator|new
name|StringReader
argument_list|(
name|code
argument_list|)
argument_list|)
decl_stmt|;
name|String
index|[]
index|[]
name|data
init|=
name|parser
operator|.
name|getAllValues
argument_list|()
decl_stmt|;
name|assertEquals
argument_list|(
literal|3
argument_list|,
name|data
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
DECL|method|testLineTokenConsistency
specifier|public
name|void
name|testLineTokenConsistency
parameter_list|()
throws|throws
name|IOException
block|{
name|String
name|code
init|=
literal|"\nfoo,baar\n\r\n,\n\n,world\r\n\n"
decl_stmt|;
name|CSVParser
name|parser
init|=
operator|new
name|CSVParser
argument_list|(
operator|new
name|StringReader
argument_list|(
name|code
argument_list|)
argument_list|)
decl_stmt|;
name|String
index|[]
index|[]
name|data
init|=
name|parser
operator|.
name|getAllValues
argument_list|()
decl_stmt|;
name|parser
operator|=
operator|new
name|CSVParser
argument_list|(
operator|new
name|StringReader
argument_list|(
name|code
argument_list|)
argument_list|)
expr_stmt|;
name|CSVParser
name|parser1
init|=
operator|new
name|CSVParser
argument_list|(
operator|new
name|StringReader
argument_list|(
name|code
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|data
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|assertTrue
argument_list|(
name|Arrays
operator|.
name|equals
argument_list|(
name|parser1
operator|.
name|getLine
argument_list|()
argument_list|,
name|data
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|data
index|[
name|i
index|]
operator|.
name|length
condition|;
name|j
operator|++
control|)
block|{
name|assertEquals
argument_list|(
name|parser
operator|.
name|nextValue
argument_list|()
argument_list|,
name|data
index|[
name|i
index|]
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// From SANDBOX-153
DECL|method|testDelimiterIsWhitespace
specifier|public
name|void
name|testDelimiterIsWhitespace
parameter_list|()
throws|throws
name|IOException
block|{
name|String
name|code
init|=
literal|"one\ttwo\t\tfour \t five\t six"
decl_stmt|;
name|TestCSVParser
name|parser
init|=
operator|new
name|TestCSVParser
argument_list|(
operator|new
name|StringReader
argument_list|(
name|code
argument_list|)
argument_list|,
name|CSVStrategy
operator|.
name|TDF_STRATEGY
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|CSVParser
operator|.
name|TT_TOKEN
operator|+
literal|";one;"
argument_list|,
name|parser
operator|.
name|testNextToken
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|CSVParser
operator|.
name|TT_TOKEN
operator|+
literal|";two;"
argument_list|,
name|parser
operator|.
name|testNextToken
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|CSVParser
operator|.
name|TT_TOKEN
operator|+
literal|";;"
argument_list|,
name|parser
operator|.
name|testNextToken
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|CSVParser
operator|.
name|TT_TOKEN
operator|+
literal|";four;"
argument_list|,
name|parser
operator|.
name|testNextToken
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|CSVParser
operator|.
name|TT_TOKEN
operator|+
literal|";five;"
argument_list|,
name|parser
operator|.
name|testNextToken
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|CSVParser
operator|.
name|TT_EOF
operator|+
literal|";six;"
argument_list|,
name|parser
operator|.
name|testNextToken
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
end_class
end_unit
