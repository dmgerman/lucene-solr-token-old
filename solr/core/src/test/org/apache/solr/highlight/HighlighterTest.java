begin_unit
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_package
DECL|package|org.apache.solr.highlight
package|package
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|highlight
package|;
end_package
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|Analyzer
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|TokenStream
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|core
operator|.
name|WhitespaceAnalyzer
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|Term
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|Query
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|payloads
operator|.
name|SpanPayloadCheckQuery
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|spans
operator|.
name|SpanTermQuery
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|SolrTestCaseJ4
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|params
operator|.
name|HighlightParams
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|handler
operator|.
name|component
operator|.
name|HighlightComponent
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|handler
operator|.
name|component
operator|.
name|ResponseBuilder
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|handler
operator|.
name|component
operator|.
name|SearchComponent
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|request
operator|.
name|SolrQueryRequest
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|response
operator|.
name|SolrQueryResponse
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|search
operator|.
name|DocSet
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|util
operator|.
name|TestHarness
import|;
end_import
begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|After
import|;
end_import
begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|BeforeClass
import|;
end_import
begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Test
import|;
end_import
begin_comment
comment|/**  * Tests some basic functionality of Solr while demonstrating good  * Best Practices for using AbstractSolrTestCase  */
end_comment
begin_class
DECL|class|HighlighterTest
specifier|public
class|class
name|HighlighterTest
extends|extends
name|SolrTestCaseJ4
block|{
DECL|field|LONG_TEXT
specifier|private
specifier|static
name|String
name|LONG_TEXT
init|=
literal|"a long days night this should be a piece of text which is is is is is is is is is is is is is is is is is is is "
operator|+
literal|"is is is is is isis is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is "
operator|+
literal|"is is is is is is is is is is is is is "
operator|+
literal|"is is is is is is is is is is is is is is is is is is is is sufficiently lengthly to produce multiple fragments which are not concatenated "
operator|+
literal|"at all--we want two disjoint long fragments."
decl_stmt|;
annotation|@
name|BeforeClass
DECL|method|beforeClass
specifier|public
specifier|static
name|void
name|beforeClass
parameter_list|()
throws|throws
name|Exception
block|{
name|initCore
argument_list|(
literal|"solrconfig.xml"
argument_list|,
literal|"schema.xml"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|After
annotation|@
name|Override
DECL|method|tearDown
specifier|public
name|void
name|tearDown
parameter_list|()
throws|throws
name|Exception
block|{
comment|// if you override setUp or tearDown, you better call
comment|// the super classes version
name|clearIndex
argument_list|()
expr_stmt|;
name|super
operator|.
name|tearDown
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testConfig
specifier|public
name|void
name|testConfig
parameter_list|()
block|{
name|DefaultSolrHighlighter
name|highlighter
init|=
operator|(
name|DefaultSolrHighlighter
operator|)
name|HighlightComponent
operator|.
name|getHighlighter
argument_list|(
name|h
operator|.
name|getCore
argument_list|()
argument_list|)
decl_stmt|;
comment|// Make sure we loaded the one formatter
name|SolrFormatter
name|fmt1
init|=
name|highlighter
operator|.
name|formatters
operator|.
name|get
argument_list|(
literal|null
argument_list|)
decl_stmt|;
name|SolrFormatter
name|fmt2
init|=
name|highlighter
operator|.
name|formatters
operator|.
name|get
argument_list|(
literal|""
argument_list|)
decl_stmt|;
name|assertSame
argument_list|(
name|fmt1
argument_list|,
name|fmt2
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|fmt1
operator|instanceof
name|HtmlFormatter
argument_list|)
expr_stmt|;
comment|// Make sure we loaded the one formatter
name|SolrFragmenter
name|gap
init|=
name|highlighter
operator|.
name|fragmenters
operator|.
name|get
argument_list|(
literal|"gap"
argument_list|)
decl_stmt|;
name|SolrFragmenter
name|regex
init|=
name|highlighter
operator|.
name|fragmenters
operator|.
name|get
argument_list|(
literal|"regex"
argument_list|)
decl_stmt|;
name|SolrFragmenter
name|frag
init|=
name|highlighter
operator|.
name|fragmenters
operator|.
name|get
argument_list|(
literal|null
argument_list|)
decl_stmt|;
name|assertSame
argument_list|(
name|gap
argument_list|,
name|frag
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|gap
operator|instanceof
name|GapFragmenter
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|regex
operator|instanceof
name|RegexFragmenter
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testMergeContiguous
specifier|public
name|void
name|testMergeContiguous
parameter_list|()
throws|throws
name|Exception
block|{
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|args
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|args
operator|.
name|put
argument_list|(
name|HighlightParams
operator|.
name|HIGHLIGHT
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
name|args
operator|.
name|put
argument_list|(
literal|"df"
argument_list|,
literal|"t_text"
argument_list|)
expr_stmt|;
name|args
operator|.
name|put
argument_list|(
name|HighlightParams
operator|.
name|FIELDS
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|args
operator|.
name|put
argument_list|(
name|HighlightParams
operator|.
name|SNIPPETS
argument_list|,
name|String
operator|.
name|valueOf
argument_list|(
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|args
operator|.
name|put
argument_list|(
name|HighlightParams
operator|.
name|FRAGSIZE
argument_list|,
name|String
operator|.
name|valueOf
argument_list|(
literal|40
argument_list|)
argument_list|)
expr_stmt|;
name|args
operator|.
name|put
argument_list|(
name|HighlightParams
operator|.
name|MERGE_CONTIGUOUS_FRAGMENTS
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
name|TestHarness
operator|.
name|LocalRequestFactory
name|sumLRF
init|=
name|h
operator|.
name|getRequestFactory
argument_list|(
literal|"standard"
argument_list|,
literal|0
argument_list|,
literal|200
argument_list|,
name|args
argument_list|)
decl_stmt|;
name|String
name|input
init|=
literal|"this is some long text.  It has the word long in many places.  In fact, it has long on some different fragments.  "
operator|+
literal|"Let us see what happens to long in this case."
decl_stmt|;
name|String
name|gold
init|=
literal|"this is some<em>long</em> text.  It has the word<em>long</em> in many places.  In fact, it has<em>long</em> on some different fragments.  "
operator|+
literal|"Let us see what happens to<em>long</em> in this case."
decl_stmt|;
name|assertU
argument_list|(
name|adoc
argument_list|(
literal|"t_text"
argument_list|,
name|input
argument_list|,
literal|"id"
argument_list|,
literal|"1"
argument_list|)
argument_list|)
expr_stmt|;
name|assertU
argument_list|(
name|commit
argument_list|()
argument_list|)
expr_stmt|;
name|assertU
argument_list|(
name|optimize
argument_list|()
argument_list|)
expr_stmt|;
name|assertQ
argument_list|(
literal|"Merge Contiguous"
argument_list|,
name|sumLRF
operator|.
name|makeRequest
argument_list|(
literal|"t_text:long"
argument_list|)
argument_list|,
literal|"//lst[@name='highlighting']/lst[@name='1']"
argument_list|,
literal|"//lst[@name='1']/arr[@name='t_text']/str[.='"
operator|+
name|gold
operator|+
literal|"']"
argument_list|)
expr_stmt|;
name|args
operator|.
name|put
argument_list|(
literal|"f.t_text."
operator|+
name|HighlightParams
operator|.
name|MERGE_CONTIGUOUS_FRAGMENTS
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
name|assertU
argument_list|(
name|adoc
argument_list|(
literal|"t_text"
argument_list|,
name|input
argument_list|,
literal|"id"
argument_list|,
literal|"1"
argument_list|)
argument_list|)
expr_stmt|;
name|assertU
argument_list|(
name|commit
argument_list|()
argument_list|)
expr_stmt|;
name|assertU
argument_list|(
name|optimize
argument_list|()
argument_list|)
expr_stmt|;
name|assertQ
argument_list|(
literal|"Merge Contiguous"
argument_list|,
name|sumLRF
operator|.
name|makeRequest
argument_list|(
literal|"t_text:long"
argument_list|)
argument_list|,
literal|"//lst[@name='highlighting']/lst[@name='1']"
argument_list|,
literal|"//lst[@name='1']/arr[@name='t_text']/str[.='"
operator|+
name|gold
operator|+
literal|"']"
argument_list|)
expr_stmt|;
name|args
operator|.
name|put
argument_list|(
name|HighlightParams
operator|.
name|MERGE_CONTIGUOUS_FRAGMENTS
argument_list|,
literal|"false"
argument_list|)
expr_stmt|;
name|args
operator|.
name|put
argument_list|(
literal|"f.t_text."
operator|+
name|HighlightParams
operator|.
name|MERGE_CONTIGUOUS_FRAGMENTS
argument_list|,
literal|"false"
argument_list|)
expr_stmt|;
name|sumLRF
operator|=
name|h
operator|.
name|getRequestFactory
argument_list|(
literal|"standard"
argument_list|,
literal|0
argument_list|,
literal|200
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|assertQ
argument_list|(
literal|"Merge Contiguous"
argument_list|,
name|sumLRF
operator|.
name|makeRequest
argument_list|(
literal|"t_text:long"
argument_list|)
argument_list|,
literal|"//lst[@name='highlighting']/lst[@name='1']"
argument_list|,
literal|"//lst[@name='1']/arr[@name='t_text']/str[.='this is some<em>long</em> text.  It has']"
argument_list|,
literal|"//lst[@name='1']/arr[@name='t_text']/str[.=' the word<em>long</em> in many places.  In fact, it has']"
argument_list|,
literal|"//lst[@name='1']/arr[@name='t_text']/str[.='<em>long</em> on some different fragments.  Let us']"
argument_list|,
literal|"//lst[@name='1']/arr[@name='t_text']/str[.=' see what happens to<em>long</em> in this case.']"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testTermVecHighlight
specifier|public
name|void
name|testTermVecHighlight
parameter_list|()
block|{
comment|// do summarization using term vectors
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|args
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|args
operator|.
name|put
argument_list|(
literal|"hl"
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
name|args
operator|.
name|put
argument_list|(
literal|"hl.fl"
argument_list|,
literal|"tv_text"
argument_list|)
expr_stmt|;
name|args
operator|.
name|put
argument_list|(
literal|"hl.snippets"
argument_list|,
literal|"2"
argument_list|)
expr_stmt|;
name|TestHarness
operator|.
name|LocalRequestFactory
name|sumLRF
init|=
name|h
operator|.
name|getRequestFactory
argument_list|(
literal|"standard"
argument_list|,
literal|0
argument_list|,
literal|200
argument_list|,
name|args
argument_list|)
decl_stmt|;
name|assertU
argument_list|(
name|adoc
argument_list|(
literal|"tv_text"
argument_list|,
name|LONG_TEXT
argument_list|,
literal|"id"
argument_list|,
literal|"1"
argument_list|)
argument_list|)
expr_stmt|;
name|assertU
argument_list|(
name|commit
argument_list|()
argument_list|)
expr_stmt|;
name|assertU
argument_list|(
name|optimize
argument_list|()
argument_list|)
expr_stmt|;
name|assertQ
argument_list|(
literal|"Basic summarization"
argument_list|,
name|sumLRF
operator|.
name|makeRequest
argument_list|(
literal|"tv_text:long"
argument_list|)
argument_list|,
literal|"//lst[@name='highlighting']/lst[@name='1']"
argument_list|,
literal|"//lst[@name='1']/arr[@name='tv_text']/str[.='a<em>long</em> days night this should be a piece of text which']"
argument_list|,
literal|"//arr[@name='tv_text']/str[.='<em>long</em> fragments.']"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testTermVectorWithoutOffsetsHighlight
specifier|public
name|void
name|testTermVectorWithoutOffsetsHighlight
parameter_list|()
block|{
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|args
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|args
operator|.
name|put
argument_list|(
literal|"hl"
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
name|args
operator|.
name|put
argument_list|(
literal|"hl.fl"
argument_list|,
literal|"tv_no_off_text"
argument_list|)
expr_stmt|;
name|TestHarness
operator|.
name|LocalRequestFactory
name|sumLRF
init|=
name|h
operator|.
name|getRequestFactory
argument_list|(
literal|"standard"
argument_list|,
literal|0
argument_list|,
literal|200
argument_list|,
name|args
argument_list|)
decl_stmt|;
name|assertU
argument_list|(
name|adoc
argument_list|(
literal|"tv_no_off_text"
argument_list|,
literal|"Crackerjack Cameron"
argument_list|,
literal|"id"
argument_list|,
literal|"1"
argument_list|)
argument_list|)
expr_stmt|;
name|assertU
argument_list|(
name|commit
argument_list|()
argument_list|)
expr_stmt|;
name|assertU
argument_list|(
name|optimize
argument_list|()
argument_list|)
expr_stmt|;
name|assertQ
argument_list|(
literal|"Fields with term vectors switched on but no offsets should be correctly highlighted"
argument_list|,
name|sumLRF
operator|.
name|makeRequest
argument_list|(
literal|"tv_no_off_text:cameron"
argument_list|)
argument_list|,
literal|"//arr[@name='tv_no_off_text']/str[.='Crackerjack<em>Cameron</em>']"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testOffsetWindowTokenFilter
specifier|public
name|void
name|testOffsetWindowTokenFilter
parameter_list|()
throws|throws
name|Exception
block|{
name|String
index|[]
name|multivalued
init|=
block|{
literal|"a b c d"
block|,
literal|"e f g"
block|,
literal|"h"
block|,
literal|"i j k l m n"
block|}
decl_stmt|;
name|Analyzer
name|a1
init|=
operator|new
name|WhitespaceAnalyzer
argument_list|()
decl_stmt|;
name|TokenStream
name|tokenStream
init|=
name|a1
operator|.
name|tokenStream
argument_list|(
literal|""
argument_list|,
literal|"a b c d e f g h i j k l m n"
argument_list|)
decl_stmt|;
name|OffsetWindowTokenFilter
name|tots
init|=
operator|new
name|OffsetWindowTokenFilter
argument_list|(
name|tokenStream
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|v
range|:
name|multivalued
control|)
block|{
name|TokenStream
name|ts1
init|=
name|tots
operator|.
name|advanceToNextWindowOfLength
argument_list|(
name|v
operator|.
name|length
argument_list|()
argument_list|)
decl_stmt|;
name|ts1
operator|.
name|reset
argument_list|()
expr_stmt|;
name|Analyzer
name|a2
init|=
operator|new
name|WhitespaceAnalyzer
argument_list|()
decl_stmt|;
name|TokenStream
name|ts2
init|=
name|a2
operator|.
name|tokenStream
argument_list|(
literal|""
argument_list|,
name|v
argument_list|)
decl_stmt|;
name|ts2
operator|.
name|reset
argument_list|()
expr_stmt|;
while|while
condition|(
name|ts1
operator|.
name|incrementToken
argument_list|()
condition|)
block|{
name|assertTrue
argument_list|(
name|ts2
operator|.
name|incrementToken
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|ts1
argument_list|,
name|ts2
argument_list|)
expr_stmt|;
block|}
name|assertFalse
argument_list|(
name|ts2
operator|.
name|incrementToken
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Test
DECL|method|testTermVecMultiValuedHighlight
specifier|public
name|void
name|testTermVecMultiValuedHighlight
parameter_list|()
throws|throws
name|Exception
block|{
comment|// do summarization using term vectors on multivalued field
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|args
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|args
operator|.
name|put
argument_list|(
literal|"hl"
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
name|args
operator|.
name|put
argument_list|(
literal|"hl.fl"
argument_list|,
literal|"tv_mv_text"
argument_list|)
expr_stmt|;
name|args
operator|.
name|put
argument_list|(
literal|"hl.snippets"
argument_list|,
literal|"2"
argument_list|)
expr_stmt|;
name|TestHarness
operator|.
name|LocalRequestFactory
name|sumLRF
init|=
name|h
operator|.
name|getRequestFactory
argument_list|(
literal|"standard"
argument_list|,
literal|0
argument_list|,
literal|200
argument_list|,
name|args
argument_list|)
decl_stmt|;
name|assertU
argument_list|(
name|adoc
argument_list|(
literal|"tv_mv_text"
argument_list|,
name|LONG_TEXT
argument_list|,
literal|"tv_mv_text"
argument_list|,
name|LONG_TEXT
argument_list|,
literal|"id"
argument_list|,
literal|"1"
argument_list|)
argument_list|)
expr_stmt|;
name|assertU
argument_list|(
name|commit
argument_list|()
argument_list|)
expr_stmt|;
name|assertU
argument_list|(
name|optimize
argument_list|()
argument_list|)
expr_stmt|;
name|assertQ
argument_list|(
literal|"Basic summarization"
argument_list|,
name|sumLRF
operator|.
name|makeRequest
argument_list|(
literal|"tv_mv_text:long"
argument_list|)
argument_list|,
literal|"//lst[@name='highlighting']/lst[@name='1']"
argument_list|,
literal|"//lst[@name='1']/arr[@name='tv_mv_text']/str[.='a<em>long</em> days night this should be a piece of text which']"
argument_list|,
literal|"//arr[@name='tv_mv_text']/str[.='<em>long</em> fragments.']"
argument_list|)
expr_stmt|;
block|}
comment|// Variant of testTermVecMultiValuedHighlight to make sure that
comment|// more than just the first value of a multi-valued field is
comment|// considered for highlighting.
annotation|@
name|Test
DECL|method|testTermVecMultiValuedHighlight2
specifier|public
name|void
name|testTermVecMultiValuedHighlight2
parameter_list|()
throws|throws
name|Exception
block|{
comment|// do summarization using term vectors on multivalued field
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|args
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|args
operator|.
name|put
argument_list|(
literal|"hl"
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
name|args
operator|.
name|put
argument_list|(
literal|"hl.fl"
argument_list|,
literal|"tv_mv_text"
argument_list|)
expr_stmt|;
name|args
operator|.
name|put
argument_list|(
literal|"hl.snippets"
argument_list|,
literal|"2"
argument_list|)
expr_stmt|;
name|TestHarness
operator|.
name|LocalRequestFactory
name|sumLRF
init|=
name|h
operator|.
name|getRequestFactory
argument_list|(
literal|"standard"
argument_list|,
literal|0
argument_list|,
literal|200
argument_list|,
name|args
argument_list|)
decl_stmt|;
name|String
name|shortText
init|=
literal|"short"
decl_stmt|;
name|assertU
argument_list|(
name|adoc
argument_list|(
literal|"tv_mv_text"
argument_list|,
name|shortText
argument_list|,
literal|"tv_mv_text"
argument_list|,
name|LONG_TEXT
argument_list|,
literal|"id"
argument_list|,
literal|"1"
argument_list|)
argument_list|)
expr_stmt|;
name|assertU
argument_list|(
name|commit
argument_list|()
argument_list|)
expr_stmt|;
name|assertU
argument_list|(
name|optimize
argument_list|()
argument_list|)
expr_stmt|;
name|assertQ
argument_list|(
literal|"Basic summarization"
argument_list|,
name|sumLRF
operator|.
name|makeRequest
argument_list|(
literal|"tv_mv_text:long"
argument_list|)
argument_list|,
literal|"//lst[@name='highlighting']/lst[@name='1']"
argument_list|,
literal|"//lst[@name='1']/arr[@name='tv_mv_text']/str[.='a<em>long</em> days night this should be a piece of text which']"
argument_list|,
literal|"//arr[@name='tv_mv_text']/str[.='<em>long</em> fragments.']"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testDisMaxHighlight
specifier|public
name|void
name|testDisMaxHighlight
parameter_list|()
block|{
comment|// same test run through dismax handler
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|args
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|args
operator|.
name|put
argument_list|(
literal|"hl"
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
name|args
operator|.
name|put
argument_list|(
literal|"hl.fl"
argument_list|,
literal|"tv_text"
argument_list|)
expr_stmt|;
name|args
operator|.
name|put
argument_list|(
literal|"qf"
argument_list|,
literal|"tv_text"
argument_list|)
expr_stmt|;
name|args
operator|.
name|put
argument_list|(
literal|"q.alt"
argument_list|,
literal|"*:*"
argument_list|)
expr_stmt|;
name|TestHarness
operator|.
name|LocalRequestFactory
name|sumLRF
init|=
name|h
operator|.
name|getRequestFactory
argument_list|(
literal|"dismax"
argument_list|,
literal|0
argument_list|,
literal|200
argument_list|,
name|args
argument_list|)
decl_stmt|;
name|assertU
argument_list|(
name|adoc
argument_list|(
literal|"tv_text"
argument_list|,
literal|"a long day's night"
argument_list|,
literal|"id"
argument_list|,
literal|"1"
argument_list|)
argument_list|)
expr_stmt|;
name|assertU
argument_list|(
name|commit
argument_list|()
argument_list|)
expr_stmt|;
name|assertU
argument_list|(
name|optimize
argument_list|()
argument_list|)
expr_stmt|;
name|assertQ
argument_list|(
literal|"Basic summarization"
argument_list|,
name|sumLRF
operator|.
name|makeRequest
argument_list|(
literal|"long"
argument_list|)
argument_list|,
literal|"//lst[@name='highlighting']/lst[@name='1']"
argument_list|,
literal|"//lst[@name='1']/arr[@name='tv_text']/str"
argument_list|)
expr_stmt|;
comment|// try the same thing without a q param
name|assertQ
argument_list|(
literal|"Should not explode..."
argument_list|,
comment|// q.alt should return everything
name|sumLRF
operator|.
name|makeRequest
argument_list|(
operator|new
name|String
index|[]
block|{
literal|null
block|}
argument_list|)
argument_list|,
comment|// empty query
literal|"//result[@numFound='1']"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testMultiValueAnalysisHighlight
specifier|public
name|void
name|testMultiValueAnalysisHighlight
parameter_list|()
block|{
comment|// do summarization using re-analysis of the field
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|args
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|args
operator|.
name|put
argument_list|(
literal|"hl"
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
name|args
operator|.
name|put
argument_list|(
literal|"hl.fl"
argument_list|,
literal|"textgap"
argument_list|)
expr_stmt|;
name|args
operator|.
name|put
argument_list|(
literal|"df"
argument_list|,
literal|"textgap"
argument_list|)
expr_stmt|;
name|TestHarness
operator|.
name|LocalRequestFactory
name|sumLRF
init|=
name|h
operator|.
name|getRequestFactory
argument_list|(
literal|"standard"
argument_list|,
literal|0
argument_list|,
literal|200
argument_list|,
name|args
argument_list|)
decl_stmt|;
name|assertU
argument_list|(
name|adoc
argument_list|(
literal|"textgap"
argument_list|,
literal|"first entry hasnt queryword"
argument_list|,
literal|"textgap"
argument_list|,
literal|"second entry has queryword long"
argument_list|,
literal|"id"
argument_list|,
literal|"1"
argument_list|)
argument_list|)
expr_stmt|;
name|assertU
argument_list|(
name|commit
argument_list|()
argument_list|)
expr_stmt|;
name|assertU
argument_list|(
name|optimize
argument_list|()
argument_list|)
expr_stmt|;
name|assertQ
argument_list|(
literal|"Basic summarization"
argument_list|,
name|sumLRF
operator|.
name|makeRequest
argument_list|(
literal|"long"
argument_list|)
argument_list|,
literal|"//lst[@name='highlighting']/lst[@name='1']"
argument_list|,
literal|"//lst[@name='1']/arr[@name='textgap']/str"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testMultiValueBestFragmentHighlight
specifier|public
name|void
name|testMultiValueBestFragmentHighlight
parameter_list|()
block|{
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|args
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|args
operator|.
name|put
argument_list|(
literal|"hl"
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
name|args
operator|.
name|put
argument_list|(
literal|"hl.fl"
argument_list|,
literal|"textgap"
argument_list|)
expr_stmt|;
name|args
operator|.
name|put
argument_list|(
literal|"df"
argument_list|,
literal|"textgap"
argument_list|)
expr_stmt|;
name|TestHarness
operator|.
name|LocalRequestFactory
name|sumLRF
init|=
name|h
operator|.
name|getRequestFactory
argument_list|(
literal|"standard"
argument_list|,
literal|0
argument_list|,
literal|200
argument_list|,
name|args
argument_list|)
decl_stmt|;
name|assertU
argument_list|(
name|adoc
argument_list|(
literal|"textgap"
argument_list|,
literal|"first entry has one word foo"
argument_list|,
literal|"textgap"
argument_list|,
literal|"second entry has both words foo bar"
argument_list|,
literal|"id"
argument_list|,
literal|"1"
argument_list|)
argument_list|)
expr_stmt|;
name|assertU
argument_list|(
name|commit
argument_list|()
argument_list|)
expr_stmt|;
name|assertU
argument_list|(
name|optimize
argument_list|()
argument_list|)
expr_stmt|;
name|assertQ
argument_list|(
literal|"Best fragment summarization"
argument_list|,
name|sumLRF
operator|.
name|makeRequest
argument_list|(
literal|"foo bar"
argument_list|)
argument_list|,
literal|"//lst[@name='highlighting']/lst[@name='1']"
argument_list|,
literal|"//lst[@name='1']/arr[@name='textgap']/str[.=\'second entry has both words<em>foo</em><em>bar</em>\']"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testPreserveMulti
specifier|public
name|void
name|testPreserveMulti
parameter_list|()
throws|throws
name|Exception
block|{
name|assertU
argument_list|(
name|adoc
argument_list|(
literal|"id"
argument_list|,
literal|"1"
argument_list|,
literal|"cat"
argument_list|,
literal|"electronics"
argument_list|,
literal|"cat"
argument_list|,
literal|"monitor"
argument_list|)
argument_list|)
expr_stmt|;
name|assertU
argument_list|(
name|commit
argument_list|()
argument_list|)
expr_stmt|;
name|assertJQ
argument_list|(
name|req
argument_list|(
literal|"q"
argument_list|,
literal|"cat:monitor"
argument_list|,
literal|"hl"
argument_list|,
literal|"true"
argument_list|,
literal|"hl.fl"
argument_list|,
literal|"cat"
argument_list|,
literal|"hl.snippets"
argument_list|,
literal|"2"
argument_list|,
literal|"f.cat.hl.preserveMulti"
argument_list|,
literal|"true"
argument_list|)
argument_list|,
literal|"/highlighting/1/cat==['electronics','<em>monitor</em>']"
argument_list|)
expr_stmt|;
comment|// No match still lists all snippets?
name|assertJQ
argument_list|(
name|req
argument_list|(
literal|"q"
argument_list|,
literal|"id:1 OR cat:duuuude"
argument_list|,
literal|"hl"
argument_list|,
literal|"true"
argument_list|,
literal|"hl.fl"
argument_list|,
literal|"cat"
argument_list|,
literal|"hl.snippets"
argument_list|,
literal|"2"
argument_list|,
literal|"f.cat.hl.preserveMulti"
argument_list|,
literal|"true"
argument_list|)
argument_list|,
literal|"/highlighting/1/cat==['electronics','monitor']"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testDefaultFieldHighlight
specifier|public
name|void
name|testDefaultFieldHighlight
parameter_list|()
block|{
comment|// do summarization using re-analysis of the field
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|args
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|args
operator|.
name|put
argument_list|(
literal|"hl"
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
name|args
operator|.
name|put
argument_list|(
literal|"df"
argument_list|,
literal|"t_text"
argument_list|)
expr_stmt|;
name|args
operator|.
name|put
argument_list|(
literal|"hl.fl"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|TestHarness
operator|.
name|LocalRequestFactory
name|sumLRF
init|=
name|h
operator|.
name|getRequestFactory
argument_list|(
literal|"standard"
argument_list|,
literal|0
argument_list|,
literal|200
argument_list|,
name|args
argument_list|)
decl_stmt|;
name|assertU
argument_list|(
name|adoc
argument_list|(
literal|"t_text"
argument_list|,
literal|"a long day's night"
argument_list|,
literal|"id"
argument_list|,
literal|"1"
argument_list|)
argument_list|)
expr_stmt|;
name|assertU
argument_list|(
name|commit
argument_list|()
argument_list|)
expr_stmt|;
name|assertU
argument_list|(
name|optimize
argument_list|()
argument_list|)
expr_stmt|;
name|assertQ
argument_list|(
literal|"Basic summarization"
argument_list|,
name|sumLRF
operator|.
name|makeRequest
argument_list|(
literal|"long"
argument_list|)
argument_list|,
literal|"//lst[@name='highlighting']/lst[@name='1']"
argument_list|,
literal|"//lst[@name='1']/arr[@name='t_text']/str"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testHighlightDisabled
specifier|public
name|void
name|testHighlightDisabled
parameter_list|()
block|{
comment|// ensure highlighting can be explicitly disabled
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|args
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|args
operator|.
name|put
argument_list|(
literal|"hl"
argument_list|,
literal|"false"
argument_list|)
expr_stmt|;
name|args
operator|.
name|put
argument_list|(
literal|"hl.fl"
argument_list|,
literal|"t_text"
argument_list|)
expr_stmt|;
name|TestHarness
operator|.
name|LocalRequestFactory
name|sumLRF
init|=
name|h
operator|.
name|getRequestFactory
argument_list|(
literal|"standard"
argument_list|,
literal|0
argument_list|,
literal|200
argument_list|,
name|args
argument_list|)
decl_stmt|;
name|assertU
argument_list|(
name|adoc
argument_list|(
literal|"t_text"
argument_list|,
literal|"a long day's night"
argument_list|,
literal|"id"
argument_list|,
literal|"1"
argument_list|)
argument_list|)
expr_stmt|;
name|assertU
argument_list|(
name|commit
argument_list|()
argument_list|)
expr_stmt|;
name|assertU
argument_list|(
name|optimize
argument_list|()
argument_list|)
expr_stmt|;
name|assertQ
argument_list|(
literal|"Basic summarization"
argument_list|,
name|sumLRF
operator|.
name|makeRequest
argument_list|(
literal|"t_text:long"
argument_list|)
argument_list|,
literal|"not(//lst[@name='highlighting'])"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testTwoFieldHighlight
specifier|public
name|void
name|testTwoFieldHighlight
parameter_list|()
block|{
comment|// do summarization using re-analysis of the field
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|args
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|args
operator|.
name|put
argument_list|(
literal|"hl"
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
name|args
operator|.
name|put
argument_list|(
literal|"hl.fl"
argument_list|,
literal|"t_text tv_text"
argument_list|)
expr_stmt|;
name|TestHarness
operator|.
name|LocalRequestFactory
name|sumLRF
init|=
name|h
operator|.
name|getRequestFactory
argument_list|(
literal|"standard"
argument_list|,
literal|0
argument_list|,
literal|200
argument_list|,
name|args
argument_list|)
decl_stmt|;
name|assertU
argument_list|(
name|adoc
argument_list|(
literal|"t_text"
argument_list|,
literal|"a long day's night"
argument_list|,
literal|"id"
argument_list|,
literal|"1"
argument_list|,
literal|"tv_text"
argument_list|,
literal|"a long night's day"
argument_list|)
argument_list|)
expr_stmt|;
name|assertU
argument_list|(
name|commit
argument_list|()
argument_list|)
expr_stmt|;
name|assertU
argument_list|(
name|optimize
argument_list|()
argument_list|)
expr_stmt|;
name|assertQ
argument_list|(
literal|"Basic summarization"
argument_list|,
name|sumLRF
operator|.
name|makeRequest
argument_list|(
literal|"t_text:long"
argument_list|)
argument_list|,
literal|"//lst[@name='highlighting']/lst[@name='1']"
argument_list|,
literal|"//lst[@name='1']/arr[@name='t_text']/str"
argument_list|,
literal|"//lst[@name='1']/arr[@name='tv_text']/str"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testFieldMatch
specifier|public
name|void
name|testFieldMatch
parameter_list|()
block|{
name|assertU
argument_list|(
name|adoc
argument_list|(
literal|"t_text1"
argument_list|,
literal|"random words for highlighting tests"
argument_list|,
literal|"id"
argument_list|,
literal|"1"
argument_list|,
literal|"t_text2"
argument_list|,
literal|"more random words for second field"
argument_list|)
argument_list|)
expr_stmt|;
name|assertU
argument_list|(
name|commit
argument_list|()
argument_list|)
expr_stmt|;
name|assertU
argument_list|(
name|optimize
argument_list|()
argument_list|)
expr_stmt|;
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|args
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|args
operator|.
name|put
argument_list|(
literal|"hl"
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
name|args
operator|.
name|put
argument_list|(
literal|"hl.fl"
argument_list|,
literal|"t_text1 t_text2"
argument_list|)
expr_stmt|;
name|TestHarness
operator|.
name|LocalRequestFactory
name|sumLRF
init|=
name|h
operator|.
name|getRequestFactory
argument_list|(
literal|"standard"
argument_list|,
literal|0
argument_list|,
literal|200
argument_list|,
name|args
argument_list|)
decl_stmt|;
comment|// default should highlight both random and words in both fields
name|assertQ
argument_list|(
literal|"Test Default"
argument_list|,
name|sumLRF
operator|.
name|makeRequest
argument_list|(
literal|"t_text1:random OR t_text2:words"
argument_list|)
argument_list|,
literal|"//lst[@name='highlighting']/lst[@name='1']"
argument_list|,
literal|"//lst[@name='1']/arr[@name='t_text1']/str[.='<em>random</em><em>words</em> for highlighting tests']"
argument_list|,
literal|"//lst[@name='1']/arr[@name='t_text2']/str[.='more<em>random</em><em>words</em> for second field']"
argument_list|)
expr_stmt|;
comment|// requireFieldMatch=true - highlighting should only occur if term matched in that field
name|args
operator|.
name|put
argument_list|(
literal|"hl.requireFieldMatch"
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
name|sumLRF
operator|=
name|h
operator|.
name|getRequestFactory
argument_list|(
literal|"standard"
argument_list|,
literal|0
argument_list|,
literal|200
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|assertQ
argument_list|(
literal|"Test RequireFieldMatch"
argument_list|,
name|sumLRF
operator|.
name|makeRequest
argument_list|(
literal|"t_text1:random OR t_text2:words"
argument_list|)
argument_list|,
literal|"//lst[@name='highlighting']/lst[@name='1']"
argument_list|,
literal|"//lst[@name='1']/arr[@name='t_text1']/str[.='<em>random</em> words for highlighting tests']"
argument_list|,
literal|"//lst[@name='1']/arr[@name='t_text2']/str[.='more random<em>words</em> for second field']"
argument_list|)
expr_stmt|;
comment|// test case for un-optimized index
name|assertU
argument_list|(
name|adoc
argument_list|(
literal|"t_text1"
argument_list|,
literal|"random words for highlighting tests"
argument_list|,
literal|"id"
argument_list|,
literal|"2"
argument_list|,
literal|"t_text2"
argument_list|,
literal|"more random words for second field"
argument_list|)
argument_list|)
expr_stmt|;
name|assertU
argument_list|(
name|delI
argument_list|(
literal|"1"
argument_list|)
argument_list|)
expr_stmt|;
name|assertU
argument_list|(
name|commit
argument_list|()
argument_list|)
expr_stmt|;
name|sumLRF
operator|=
name|h
operator|.
name|getRequestFactory
argument_list|(
literal|"standard"
argument_list|,
literal|0
argument_list|,
literal|200
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|assertQ
argument_list|(
literal|"Test RequireFieldMatch on un-optimized index"
argument_list|,
name|sumLRF
operator|.
name|makeRequest
argument_list|(
literal|"t_text1:random OR t_text2:words"
argument_list|)
argument_list|,
literal|"//lst[@name='highlighting']/lst[@name='2']"
argument_list|,
literal|"//lst[@name='2']/arr[@name='t_text1']/str[.='<em>random</em> words for highlighting tests']"
argument_list|,
literal|"//lst[@name='2']/arr[@name='t_text2']/str[.='more random<em>words</em> for second field']"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testCustomSimpleFormatterHighlight
specifier|public
name|void
name|testCustomSimpleFormatterHighlight
parameter_list|()
block|{
comment|// do summarization using a custom formatter
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|args
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|args
operator|.
name|put
argument_list|(
literal|"hl"
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
name|args
operator|.
name|put
argument_list|(
literal|"hl.fl"
argument_list|,
literal|"t_text"
argument_list|)
expr_stmt|;
name|args
operator|.
name|put
argument_list|(
literal|"hl.simple.pre"
argument_list|,
literal|"<B>"
argument_list|)
expr_stmt|;
name|args
operator|.
name|put
argument_list|(
literal|"hl.simple.post"
argument_list|,
literal|"</B>"
argument_list|)
expr_stmt|;
name|TestHarness
operator|.
name|LocalRequestFactory
name|sumLRF
init|=
name|h
operator|.
name|getRequestFactory
argument_list|(
literal|"standard"
argument_list|,
literal|0
argument_list|,
literal|200
argument_list|,
name|args
argument_list|)
decl_stmt|;
name|assertU
argument_list|(
name|adoc
argument_list|(
literal|"t_text"
argument_list|,
literal|"a long days night"
argument_list|,
literal|"id"
argument_list|,
literal|"1"
argument_list|)
argument_list|)
expr_stmt|;
name|assertU
argument_list|(
name|commit
argument_list|()
argument_list|)
expr_stmt|;
name|assertU
argument_list|(
name|optimize
argument_list|()
argument_list|)
expr_stmt|;
name|assertQ
argument_list|(
literal|"Basic summarization"
argument_list|,
name|sumLRF
operator|.
name|makeRequest
argument_list|(
literal|"t_text:long"
argument_list|)
argument_list|,
literal|"//lst[@name='highlighting']/lst[@name='1']"
argument_list|,
literal|"//lst[@name='1']/arr[@name='t_text']/str[.='a<B>long</B> days night']"
argument_list|)
expr_stmt|;
comment|// test a per-field override
name|args
operator|.
name|put
argument_list|(
literal|"f.t_text.hl.simple.pre"
argument_list|,
literal|"<I>"
argument_list|)
expr_stmt|;
name|args
operator|.
name|put
argument_list|(
literal|"f.t_text.hl.simple.post"
argument_list|,
literal|"</I>"
argument_list|)
expr_stmt|;
name|sumLRF
operator|=
name|h
operator|.
name|getRequestFactory
argument_list|(
literal|"standard"
argument_list|,
literal|0
argument_list|,
literal|200
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|assertQ
argument_list|(
literal|"Basic summarization"
argument_list|,
name|sumLRF
operator|.
name|makeRequest
argument_list|(
literal|"t_text:long"
argument_list|)
argument_list|,
literal|"//lst[@name='highlighting']/lst[@name='1']"
argument_list|,
literal|"//lst[@name='1']/arr[@name='t_text']/str[.='a<I>long</I> days night']"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testLongFragment
specifier|public
name|void
name|testLongFragment
parameter_list|()
block|{
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|args
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|args
operator|.
name|put
argument_list|(
literal|"hl"
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
name|args
operator|.
name|put
argument_list|(
literal|"hl.fl"
argument_list|,
literal|"tv_text"
argument_list|)
expr_stmt|;
name|TestHarness
operator|.
name|LocalRequestFactory
name|sumLRF
init|=
name|h
operator|.
name|getRequestFactory
argument_list|(
literal|"standard"
argument_list|,
literal|0
argument_list|,
literal|200
argument_list|,
name|args
argument_list|)
decl_stmt|;
name|String
name|text
init|=
literal|"junit: [mkdir] Created dir: /home/klaas/worio/backend/trunk/build-src/solr-nightly/build/test-results [junit] Running org.apache.solr.BasicFunctionalityTest [junit] Tests run: 7, Failures: 0, Errors: 0, Time elapsed: 5.36 sec [junit] Running org.apache.solr.ConvertedLegacyTest [junit] Tests run: 1, Failures: 0, Errors: 0, Time elapsed: 8.268 sec [junit] Running org.apache.solr.DisMaxRequestHandlerTest [junit] Tests run: 1, Failures: 0, Errors: 0, Time elapsed: 1.56 sec [junit] Running org.apache.solr.HighlighterTest [junit] Tests run: 7, Failures: 0, Errors: 0, Time elapsed: 4.979 sec [junit] Running org.apache.solr.OutputWriterTest [junit] Tests run: 2, Failures: 0, Errors: 0, Time elapsed: 0.797 sec [junit] Running org.apache.solr.SampleTest [junit] Tests run: 2, Failures: 0, Errors: 0, Time elapsed: 1.021 sec [junit] Running org.apache.solr.analysis.TestBufferedTokenStream [junit] Tests run: 2, Failures: 0, Errors: 0, Time elapsed: 0.05 sec [junit] Running org.apache.solr.analysis.TestRemoveDuplicatesTokenFilter [junit] Tests run: 3, Failures: 0, Errors: 0, Time elapsed: 0.054 sec [junit] Running org.apache.solr.analysis.TestSynonymFilter [junit] Tests run: 6, Failures: 0, Errors: 0, Time elapsed: 0.081 sec [junit] Running org.apache.solr.analysis.TestWordDelimiterFilter [junit] Tests run: 1, Failures: 0, Errors: 0, Time elapsed: 1.714 sec [junit] Running org.apache.solr.search.TestDocSet [junit] Tests run: 1, Failures: 0, Errors: 0, Time elapsed: 0.788 sec [junit] Running org.apache.solr.util.SolrPluginUtilsTest [junit] Tests run: 5, Failures: 0, Errors: 0, Time elapsed: 3.519 sec [junit] Running org.apache.solr.util.TestOpenBitSet [junit] Tests run: 2, Failures: 0, Errors: 0, Time elapsed: 0.533 sec"
decl_stmt|;
name|assertU
argument_list|(
name|adoc
argument_list|(
literal|"tv_text"
argument_list|,
name|text
argument_list|,
literal|"id"
argument_list|,
literal|"1"
argument_list|)
argument_list|)
expr_stmt|;
name|assertU
argument_list|(
name|commit
argument_list|()
argument_list|)
expr_stmt|;
name|assertU
argument_list|(
name|optimize
argument_list|()
argument_list|)
expr_stmt|;
name|assertQ
argument_list|(
literal|"Basic summarization"
argument_list|,
name|sumLRF
operator|.
name|makeRequest
argument_list|(
literal|"tv_text:dir"
argument_list|)
argument_list|,
literal|"//lst[@name='highlighting']/lst[@name='1']"
argument_list|,
literal|"//lst[@name='1']/arr[@name='tv_text']/str"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testMaxChars
specifier|public
name|void
name|testMaxChars
parameter_list|()
block|{
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|args
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|args
operator|.
name|put
argument_list|(
literal|"fl"
argument_list|,
literal|"id score"
argument_list|)
expr_stmt|;
name|args
operator|.
name|put
argument_list|(
literal|"hl"
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
name|args
operator|.
name|put
argument_list|(
literal|"hl.snippets"
argument_list|,
literal|"10"
argument_list|)
expr_stmt|;
specifier|final
name|String
name|field
init|=
name|random
argument_list|()
operator|.
name|nextBoolean
argument_list|()
condition|?
literal|"t_text"
else|:
literal|"tv_text"
decl_stmt|;
name|args
operator|.
name|put
argument_list|(
literal|"hl.fl"
argument_list|,
name|field
argument_list|)
expr_stmt|;
name|TestHarness
operator|.
name|LocalRequestFactory
name|sumLRF
init|=
name|h
operator|.
name|getRequestFactory
argument_list|(
literal|"standard"
argument_list|,
literal|0
argument_list|,
literal|200
argument_list|,
name|args
argument_list|)
decl_stmt|;
name|assertU
argument_list|(
name|adoc
argument_list|(
name|field
argument_list|,
name|LONG_TEXT
argument_list|,
literal|"id"
argument_list|,
literal|"1"
argument_list|)
argument_list|)
expr_stmt|;
name|assertU
argument_list|(
name|commit
argument_list|()
argument_list|)
expr_stmt|;
name|assertQ
argument_list|(
literal|"token at start of text"
argument_list|,
name|sumLRF
operator|.
name|makeRequest
argument_list|(
name|field
operator|+
literal|":disjoint"
argument_list|)
argument_list|,
literal|"//lst[@name='highlighting']/lst[@name='1']"
argument_list|,
literal|"//lst[@name='1']/arr[count(str)=1]"
argument_list|)
expr_stmt|;
name|args
operator|.
name|put
argument_list|(
literal|"hl.maxAnalyzedChars"
argument_list|,
literal|"20"
argument_list|)
expr_stmt|;
name|sumLRF
operator|=
name|h
operator|.
name|getRequestFactory
argument_list|(
literal|"standard"
argument_list|,
literal|0
argument_list|,
literal|200
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|assertQ
argument_list|(
literal|"token at end of text"
argument_list|,
name|sumLRF
operator|.
name|makeRequest
argument_list|(
name|field
operator|+
literal|":disjoint"
argument_list|)
argument_list|,
literal|"//lst[@name='highlighting']/lst[@name='1']"
argument_list|,
literal|"//lst[@name='1'][not(*)]"
argument_list|)
expr_stmt|;
name|args
operator|.
name|put
argument_list|(
literal|"hl.maxAnalyzedChars"
argument_list|,
literal|"-1"
argument_list|)
expr_stmt|;
name|sumLRF
operator|=
name|h
operator|.
name|getRequestFactory
argument_list|(
literal|"standard"
argument_list|,
literal|0
argument_list|,
literal|200
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|assertQ
argument_list|(
literal|"token at start of text"
argument_list|,
name|sumLRF
operator|.
name|makeRequest
argument_list|(
name|field
operator|+
literal|":disjoint"
argument_list|)
argument_list|,
literal|"//lst[@name='highlighting']/lst[@name='1']"
argument_list|,
literal|"//lst[@name='1']/arr[count(str)=1]"
argument_list|)
expr_stmt|;
block|}
comment|// Test multi-valued together with hl.maxAnalyzedChars
annotation|@
name|Test
DECL|method|testMultiValuedMaxAnalyzedChars
specifier|public
name|void
name|testMultiValuedMaxAnalyzedChars
parameter_list|()
throws|throws
name|Exception
block|{
name|String
name|shortText
init|=
literal|"some short blah blah blah blah"
decl_stmt|;
specifier|final
name|String
name|field
init|=
name|random
argument_list|()
operator|.
name|nextBoolean
argument_list|()
condition|?
literal|"tv_mv_text"
else|:
literal|"textgap"
decl_stmt|;
comment|// term vecs or not
name|assertU
argument_list|(
name|adoc
argument_list|(
name|field
argument_list|,
name|shortText
argument_list|,
name|field
argument_list|,
name|LONG_TEXT
argument_list|,
literal|"id"
argument_list|,
literal|"1"
argument_list|)
argument_list|)
expr_stmt|;
name|assertU
argument_list|(
name|commit
argument_list|()
argument_list|)
expr_stmt|;
name|assertQ
argument_list|(
name|req
argument_list|(
literal|"q"
argument_list|,
name|field
operator|+
literal|":(short OR long)"
argument_list|,
literal|"indent"
argument_list|,
literal|"on"
argument_list|,
literal|"hl"
argument_list|,
literal|"true"
argument_list|,
literal|"hl.fl"
argument_list|,
name|field
argument_list|,
literal|"hl.snippets"
argument_list|,
literal|"2"
argument_list|,
literal|"hl.maxAnalyzedChars"
argument_list|,
literal|"8"
argument_list|)
argument_list|,
literal|"//lst[@name='highlighting']/lst[@name='1']/arr[count(*)=1]"
argument_list|,
literal|"//lst[@name='1']/arr/str[1][.='some<em>short</em>']"
comment|//"//lst[@name='1']/arr/str[2][.='a<em>long</em> days']"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testRegexFragmenter
specifier|public
name|void
name|testRegexFragmenter
parameter_list|()
block|{
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|args
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|args
operator|.
name|put
argument_list|(
literal|"fl"
argument_list|,
literal|"id score"
argument_list|)
expr_stmt|;
name|args
operator|.
name|put
argument_list|(
literal|"hl"
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
name|args
operator|.
name|put
argument_list|(
literal|"hl.snippets"
argument_list|,
literal|"10"
argument_list|)
expr_stmt|;
name|args
operator|.
name|put
argument_list|(
literal|"hl.fl"
argument_list|,
literal|"t_text"
argument_list|)
expr_stmt|;
name|args
operator|.
name|put
argument_list|(
literal|"hl.fragmenter"
argument_list|,
literal|"regex"
argument_list|)
expr_stmt|;
name|args
operator|.
name|put
argument_list|(
literal|"hl.regex.pattern"
argument_list|,
literal|"[-\\w ,\"']{20,200}"
argument_list|)
expr_stmt|;
name|args
operator|.
name|put
argument_list|(
literal|"hl.regex.slop"
argument_list|,
literal|".9"
argument_list|)
expr_stmt|;
name|TestHarness
operator|.
name|LocalRequestFactory
name|sumLRF
init|=
name|h
operator|.
name|getRequestFactory
argument_list|(
literal|"standard"
argument_list|,
literal|0
argument_list|,
literal|200
argument_list|,
name|args
argument_list|)
decl_stmt|;
name|String
name|t
init|=
literal|"This is an example of a sentence. Another example \"sentence\" with "
operator|+
literal|"special characters\nand a line-break! Miscellaneous character like ^ are "
operator|+
literal|"unknowns and end up being bad example s of sentences? I wonder how "
operator|+
literal|"slashes/other punctuation fare in these examples?"
decl_stmt|;
name|assertU
argument_list|(
name|adoc
argument_list|(
literal|"t_text"
argument_list|,
name|t
argument_list|,
literal|"id"
argument_list|,
literal|"1"
argument_list|)
argument_list|)
expr_stmt|;
name|assertU
argument_list|(
name|commit
argument_list|()
argument_list|)
expr_stmt|;
name|assertU
argument_list|(
name|optimize
argument_list|()
argument_list|)
expr_stmt|;
name|assertQ
argument_list|(
literal|"regex fragmenter"
argument_list|,
name|sumLRF
operator|.
name|makeRequest
argument_list|(
literal|"t_text:example"
argument_list|)
argument_list|,
literal|"//lst[@name='highlighting']/lst[@name='1']"
argument_list|,
literal|"//arr/str[.='This is an<em>example</em> of a sentence']"
argument_list|,
literal|"//arr/str[.='. Another<em>example</em> \"sentence\" with special characters\nand a line-break']"
argument_list|,
literal|"//arr/str[.=' ^ are unknowns and end up being bad<em>example</em> s of sentences']"
argument_list|,
literal|"//arr/str[.='/other punctuation fare in these<em>examples</em>?']"
argument_list|)
expr_stmt|;
comment|// try with some punctuation included
name|args
operator|.
name|put
argument_list|(
literal|"hl.regex.pattern"
argument_list|,
literal|"[-\\w ,^/\\n\"']{20,200}"
argument_list|)
expr_stmt|;
name|sumLRF
operator|=
name|h
operator|.
name|getRequestFactory
argument_list|(
literal|"standard"
argument_list|,
literal|0
argument_list|,
literal|200
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|assertQ
argument_list|(
literal|"regex fragmenter 2"
argument_list|,
name|sumLRF
operator|.
name|makeRequest
argument_list|(
literal|"t_text:example"
argument_list|)
argument_list|,
literal|"//lst[@name='highlighting']/lst[@name='1']"
argument_list|,
literal|"//arr/str[.='This is an<em>example</em> of a sentence']"
argument_list|,
literal|"//arr/str[.='. Another<em>example</em> \"sentence\" with special characters\nand a line-break']"
argument_list|,
literal|"//arr/str[.='! Miscellaneous character like ^ are unknowns and end up being bad<em>example</em> s of sentences']"
argument_list|,
literal|"//arr/str[.='? I wonder how slashes/other punctuation fare in these<em>examples</em>?']"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testVariableFragsize
specifier|public
name|void
name|testVariableFragsize
parameter_list|()
block|{
name|assertU
argument_list|(
name|adoc
argument_list|(
literal|"tv_text"
argument_list|,
literal|"a long days night this should be a piece of text which is is is is is is is is is is is is is is is is is is is is is is is is isis is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is sufficiently lengthly to produce multiple fragments which are not concatenated at all"
argument_list|,
literal|"id"
argument_list|,
literal|"1"
argument_list|)
argument_list|)
expr_stmt|;
name|assertU
argument_list|(
name|commit
argument_list|()
argument_list|)
expr_stmt|;
name|assertU
argument_list|(
name|optimize
argument_list|()
argument_list|)
expr_stmt|;
comment|// default length
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|args
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|args
operator|.
name|put
argument_list|(
literal|"hl"
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
name|args
operator|.
name|put
argument_list|(
literal|"hl.fl"
argument_list|,
literal|"tv_text"
argument_list|)
expr_stmt|;
name|TestHarness
operator|.
name|LocalRequestFactory
name|sumLRF
init|=
name|h
operator|.
name|getRequestFactory
argument_list|(
literal|"standard"
argument_list|,
literal|0
argument_list|,
literal|200
argument_list|,
name|args
argument_list|)
decl_stmt|;
name|assertQ
argument_list|(
literal|"Basic summarization"
argument_list|,
name|sumLRF
operator|.
name|makeRequest
argument_list|(
literal|"tv_text:long"
argument_list|)
argument_list|,
literal|"//lst[@name='highlighting']/lst[@name='1']"
argument_list|,
literal|"//lst[@name='1']/arr[@name='tv_text']/str[.='a<em>long</em> days night this should be a piece of text which']"
argument_list|)
expr_stmt|;
comment|// 25
name|args
operator|.
name|put
argument_list|(
literal|"hl.fragsize"
argument_list|,
literal|"25"
argument_list|)
expr_stmt|;
name|sumLRF
operator|=
name|h
operator|.
name|getRequestFactory
argument_list|(
literal|"standard"
argument_list|,
literal|0
argument_list|,
literal|200
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|assertQ
argument_list|(
literal|"Basic summarization"
argument_list|,
name|sumLRF
operator|.
name|makeRequest
argument_list|(
literal|"tv_text:long"
argument_list|)
argument_list|,
literal|"//lst[@name='highlighting']/lst[@name='1']"
argument_list|,
literal|"//lst[@name='1']/arr[@name='tv_text']/str[.='a<em>long</em> days night']"
argument_list|)
expr_stmt|;
comment|// 0 - NullFragmenter
name|args
operator|.
name|put
argument_list|(
literal|"hl.fragsize"
argument_list|,
literal|"0"
argument_list|)
expr_stmt|;
name|sumLRF
operator|=
name|h
operator|.
name|getRequestFactory
argument_list|(
literal|"standard"
argument_list|,
literal|0
argument_list|,
literal|200
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|assertQ
argument_list|(
literal|"Basic summarization"
argument_list|,
name|sumLRF
operator|.
name|makeRequest
argument_list|(
literal|"tv_text:long"
argument_list|)
argument_list|,
literal|"//lst[@name='highlighting']/lst[@name='1']"
argument_list|,
literal|"//lst[@name='1']/arr[@name='tv_text']/str[.='a<em>long</em> days night this should be a piece of text which is is is is is is is is is is is is is is is is is is is is is is is is isis is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is sufficiently lengthly to produce multiple fragments which are not concatenated at all']"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testAlternateSummary
specifier|public
name|void
name|testAlternateSummary
parameter_list|()
block|{
comment|//long document
name|assertU
argument_list|(
name|adoc
argument_list|(
literal|"tv_text"
argument_list|,
literal|"keyword is only here"
argument_list|,
literal|"t_text"
argument_list|,
literal|"a piece of text to be substituted"
argument_list|,
literal|"id"
argument_list|,
literal|"1"
argument_list|,
literal|"foo_t"
argument_list|,
literal|"hi"
argument_list|)
argument_list|)
expr_stmt|;
name|assertU
argument_list|(
name|commit
argument_list|()
argument_list|)
expr_stmt|;
name|assertU
argument_list|(
name|optimize
argument_list|()
argument_list|)
expr_stmt|;
comment|// do summarization
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|args
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|args
operator|.
name|put
argument_list|(
literal|"hl"
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
name|args
operator|.
name|put
argument_list|(
literal|"hl.fragsize"
argument_list|,
literal|"0"
argument_list|)
expr_stmt|;
name|args
operator|.
name|put
argument_list|(
literal|"hl.fl"
argument_list|,
literal|"t_text"
argument_list|)
expr_stmt|;
name|TestHarness
operator|.
name|LocalRequestFactory
name|sumLRF
init|=
name|h
operator|.
name|getRequestFactory
argument_list|(
literal|"standard"
argument_list|,
literal|0
argument_list|,
literal|200
argument_list|,
name|args
argument_list|)
decl_stmt|;
comment|// no alternate
name|assertQ
argument_list|(
literal|"Alternate summarization"
argument_list|,
name|sumLRF
operator|.
name|makeRequest
argument_list|(
literal|"tv_text:keyword"
argument_list|)
argument_list|,
literal|"//lst[@name='highlighting']/lst[@name='1']"
argument_list|,
literal|"//lst[@name='highlighting']/lst[@name='1' and count(*)=0]"
argument_list|)
expr_stmt|;
comment|// with an alternate
name|args
operator|.
name|put
argument_list|(
literal|"hl.alternateField"
argument_list|,
literal|"foo_t"
argument_list|)
expr_stmt|;
name|sumLRF
operator|=
name|h
operator|.
name|getRequestFactory
argument_list|(
literal|"standard"
argument_list|,
literal|0
argument_list|,
literal|200
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|assertQ
argument_list|(
literal|"Alternate summarization"
argument_list|,
name|sumLRF
operator|.
name|makeRequest
argument_list|(
literal|"tv_text:keyword"
argument_list|)
argument_list|,
literal|"//lst[@name='highlighting']/lst[@name='1' and count(*)=1]"
argument_list|,
literal|"//lst[@name='highlighting']/lst[@name='1']/arr[@name='t_text']/str[.='hi']"
argument_list|)
expr_stmt|;
comment|// with an alternate + max length
name|args
operator|.
name|put
argument_list|(
literal|"hl.alternateField"
argument_list|,
literal|"t_text"
argument_list|)
expr_stmt|;
name|args
operator|.
name|put
argument_list|(
literal|"hl.maxAlternateFieldLength"
argument_list|,
literal|"15"
argument_list|)
expr_stmt|;
name|sumLRF
operator|=
name|h
operator|.
name|getRequestFactory
argument_list|(
literal|"standard"
argument_list|,
literal|0
argument_list|,
literal|200
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|assertQ
argument_list|(
literal|"Alternate summarization"
argument_list|,
name|sumLRF
operator|.
name|makeRequest
argument_list|(
literal|"tv_text:keyword"
argument_list|)
argument_list|,
literal|"//lst[@name='highlighting']/lst[@name='1' and count(*)=1]"
argument_list|,
literal|"//lst[@name='highlighting']/lst[@name='1']/arr[@name='t_text']/str[.='a piece of text']"
argument_list|)
expr_stmt|;
comment|// with a non-existing alternate field + max length
name|args
operator|.
name|put
argument_list|(
literal|"hl.alternateField"
argument_list|,
literal|"NonExistingField"
argument_list|)
expr_stmt|;
name|args
operator|.
name|put
argument_list|(
literal|"hl.maxAlternateFieldLength"
argument_list|,
literal|"15"
argument_list|)
expr_stmt|;
name|sumLRF
operator|=
name|h
operator|.
name|getRequestFactory
argument_list|(
literal|"standard"
argument_list|,
literal|0
argument_list|,
literal|200
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|assertQ
argument_list|(
literal|"Alternate summarization"
argument_list|,
name|sumLRF
operator|.
name|makeRequest
argument_list|(
literal|"tv_text:keyword"
argument_list|)
argument_list|,
literal|"//lst[@name='highlighting']/lst[@name='1' and count(*)=1]"
argument_list|,
literal|"//lst[@name='highlighting']/lst[@name='1']/arr[@name='t_text']/str[.='a piece of text']"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testPhraseHighlighter
specifier|public
name|void
name|testPhraseHighlighter
parameter_list|()
block|{
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|args
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|args
operator|.
name|put
argument_list|(
literal|"hl"
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
name|args
operator|.
name|put
argument_list|(
literal|"hl.fl"
argument_list|,
literal|"t_text"
argument_list|)
expr_stmt|;
name|args
operator|.
name|put
argument_list|(
literal|"hl.fragsize"
argument_list|,
literal|"40"
argument_list|)
expr_stmt|;
name|args
operator|.
name|put
argument_list|(
literal|"hl.snippets"
argument_list|,
literal|"10"
argument_list|)
expr_stmt|;
name|args
operator|.
name|put
argument_list|(
literal|"hl.usePhraseHighlighter"
argument_list|,
literal|"false"
argument_list|)
expr_stmt|;
name|TestHarness
operator|.
name|LocalRequestFactory
name|sumLRF
init|=
name|h
operator|.
name|getRequestFactory
argument_list|(
literal|"standard"
argument_list|,
literal|0
argument_list|,
literal|200
argument_list|,
name|args
argument_list|)
decl_stmt|;
comment|// String borrowed from Lucene's HighlighterTest
name|String
name|t
init|=
literal|"This piece of text refers to Kennedy at the beginning then has a longer piece of text that is very long in the middle and finally ends with another reference to Kennedy"
decl_stmt|;
name|assertU
argument_list|(
name|adoc
argument_list|(
literal|"t_text"
argument_list|,
name|t
argument_list|,
literal|"id"
argument_list|,
literal|"1"
argument_list|)
argument_list|)
expr_stmt|;
name|assertU
argument_list|(
name|commit
argument_list|()
argument_list|)
expr_stmt|;
name|assertU
argument_list|(
name|optimize
argument_list|()
argument_list|)
expr_stmt|;
name|String
name|oldHighlight1
init|=
literal|"//lst[@name='1']/arr[@name='t_text']/str[.='This piece of<em>text</em><em>refers</em> to Kennedy']"
decl_stmt|;
name|String
name|oldHighlight2
init|=
literal|"//lst[@name='1']/arr[@name='t_text']/str[.=' at the beginning then has a longer piece of<em>text</em>']"
decl_stmt|;
name|String
name|oldHighlight3
init|=
literal|"//lst[@name='1']/arr[@name='t_text']/str[.=' with another<em>reference</em> to Kennedy']"
decl_stmt|;
name|String
name|newHighlight1
init|=
literal|"//lst[@name='1']/arr[@name='t_text']/str[.='This piece of<em>text</em><em>refers</em> to Kennedy']"
decl_stmt|;
comment|// check if old functionality is still the same
name|assertQ
argument_list|(
literal|"Phrase highlighting - old"
argument_list|,
name|sumLRF
operator|.
name|makeRequest
argument_list|(
literal|"t_text:\"text refers\""
argument_list|)
argument_list|,
literal|"//lst[@name='highlighting']/lst[@name='1']"
argument_list|,
name|oldHighlight1
argument_list|,
name|oldHighlight2
argument_list|,
name|oldHighlight3
argument_list|)
expr_stmt|;
name|assertQ
argument_list|(
literal|"Phrase highlighting - old"
argument_list|,
name|sumLRF
operator|.
name|makeRequest
argument_list|(
literal|"t_text:text refers"
argument_list|)
argument_list|,
literal|"//lst[@name='highlighting']/lst[@name='1']"
argument_list|,
name|oldHighlight1
argument_list|,
name|oldHighlight2
argument_list|,
name|oldHighlight3
argument_list|)
expr_stmt|;
comment|// now check if Lucene-794 highlighting works as expected
name|args
operator|.
name|put
argument_list|(
literal|"hl.usePhraseHighlighter"
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
name|sumLRF
operator|=
name|h
operator|.
name|getRequestFactory
argument_list|(
literal|"standard"
argument_list|,
literal|0
argument_list|,
literal|200
argument_list|,
name|args
argument_list|)
expr_stmt|;
comment|// check phrase highlighting
name|assertQ
argument_list|(
literal|"Phrase highlighting - Lucene-794"
argument_list|,
name|sumLRF
operator|.
name|makeRequest
argument_list|(
literal|"t_text:\"text refers\""
argument_list|)
argument_list|,
literal|"//lst[@name='highlighting']/lst[@name='1']"
argument_list|,
name|newHighlight1
argument_list|)
expr_stmt|;
comment|// non phrase queries should be highlighted as they were before this fix
name|assertQ
argument_list|(
literal|"Phrase highlighting - Lucene-794"
argument_list|,
name|sumLRF
operator|.
name|makeRequest
argument_list|(
literal|"t_text:text refers"
argument_list|)
argument_list|,
literal|"//lst[@name='highlighting']/lst[@name='1']"
argument_list|,
name|oldHighlight1
argument_list|,
name|oldHighlight2
argument_list|,
name|oldHighlight3
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testGetHighlightFields
specifier|public
name|void
name|testGetHighlightFields
parameter_list|()
block|{
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|args
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|args
operator|.
name|put
argument_list|(
literal|"fl"
argument_list|,
literal|"id score"
argument_list|)
expr_stmt|;
name|args
operator|.
name|put
argument_list|(
literal|"hl"
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
name|args
operator|.
name|put
argument_list|(
literal|"hl.fl"
argument_list|,
literal|"t*"
argument_list|)
expr_stmt|;
name|assertU
argument_list|(
name|adoc
argument_list|(
literal|"id"
argument_list|,
literal|"0"
argument_list|,
literal|"title"
argument_list|,
literal|"test"
argument_list|,
comment|// static stored
literal|"text"
argument_list|,
literal|"test"
argument_list|,
comment|// static not stored
literal|"foo_s"
argument_list|,
literal|"test"
argument_list|,
comment|// dynamic stored
literal|"foo_sI"
argument_list|,
literal|"test"
argument_list|,
comment|// dynamic not stored
literal|"weight"
argument_list|,
literal|"1.0"
argument_list|)
argument_list|)
expr_stmt|;
comment|// stored but not text
name|assertU
argument_list|(
name|commit
argument_list|()
argument_list|)
expr_stmt|;
name|assertU
argument_list|(
name|optimize
argument_list|()
argument_list|)
expr_stmt|;
name|TestHarness
operator|.
name|LocalRequestFactory
name|lrf
init|=
name|h
operator|.
name|getRequestFactory
argument_list|(
literal|"standard"
argument_list|,
literal|0
argument_list|,
literal|10
argument_list|,
name|args
argument_list|)
decl_stmt|;
name|SolrQueryRequest
name|request
init|=
name|lrf
operator|.
name|makeRequest
argument_list|(
literal|"test"
argument_list|)
decl_stmt|;
name|SolrHighlighter
name|highlighter
init|=
name|HighlightComponent
operator|.
name|getHighlighter
argument_list|(
name|h
operator|.
name|getCore
argument_list|()
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|highlightFieldNames
init|=
name|Arrays
operator|.
name|asList
argument_list|(
name|highlighter
operator|.
name|getHighlightFields
argument_list|(
literal|null
argument_list|,
name|request
argument_list|,
operator|new
name|String
index|[]
block|{}
argument_list|)
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
literal|"Expected to highlight on field \"title\""
argument_list|,
name|highlightFieldNames
operator|.
name|contains
argument_list|(
literal|"title"
argument_list|)
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
literal|"Expected to not highlight on field \"text\""
argument_list|,
name|highlightFieldNames
operator|.
name|contains
argument_list|(
literal|"text"
argument_list|)
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
literal|"Expected to not highlight on field \"weight\""
argument_list|,
name|highlightFieldNames
operator|.
name|contains
argument_list|(
literal|"weight"
argument_list|)
argument_list|)
expr_stmt|;
name|request
operator|.
name|close
argument_list|()
expr_stmt|;
name|args
operator|.
name|put
argument_list|(
literal|"hl.fl"
argument_list|,
literal|"foo_*"
argument_list|)
expr_stmt|;
name|lrf
operator|=
name|h
operator|.
name|getRequestFactory
argument_list|(
literal|"standard"
argument_list|,
literal|0
argument_list|,
literal|10
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|request
operator|=
name|lrf
operator|.
name|makeRequest
argument_list|(
literal|"test"
argument_list|)
expr_stmt|;
name|highlighter
operator|=
name|HighlightComponent
operator|.
name|getHighlighter
argument_list|(
name|h
operator|.
name|getCore
argument_list|()
argument_list|)
expr_stmt|;
name|highlightFieldNames
operator|=
name|Arrays
operator|.
name|asList
argument_list|(
name|highlighter
operator|.
name|getHighlightFields
argument_list|(
literal|null
argument_list|,
name|request
argument_list|,
operator|new
name|String
index|[]
block|{}
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Expected one field to highlight on"
argument_list|,
literal|1
argument_list|,
name|highlightFieldNames
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Expected to highlight on field \"foo_s\""
argument_list|,
literal|"foo_s"
argument_list|,
name|highlightFieldNames
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|request
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testDefaultFieldPrefixWildcardHighlight
specifier|public
name|void
name|testDefaultFieldPrefixWildcardHighlight
parameter_list|()
block|{
comment|// do summarization using re-analysis of the field
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|args
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|args
operator|.
name|put
argument_list|(
literal|"hl"
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
name|args
operator|.
name|put
argument_list|(
literal|"df"
argument_list|,
literal|"t_text"
argument_list|)
expr_stmt|;
name|args
operator|.
name|put
argument_list|(
literal|"hl.fl"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|args
operator|.
name|put
argument_list|(
literal|"hl.usePhraseHighlighter"
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
name|args
operator|.
name|put
argument_list|(
literal|"hl.highlightMultiTerm"
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
name|TestHarness
operator|.
name|LocalRequestFactory
name|sumLRF
init|=
name|h
operator|.
name|getRequestFactory
argument_list|(
literal|"standard"
argument_list|,
literal|0
argument_list|,
literal|200
argument_list|,
name|args
argument_list|)
decl_stmt|;
name|assertU
argument_list|(
name|adoc
argument_list|(
literal|"t_text"
argument_list|,
literal|"a long day's night"
argument_list|,
literal|"id"
argument_list|,
literal|"1"
argument_list|)
argument_list|)
expr_stmt|;
name|assertU
argument_list|(
name|commit
argument_list|()
argument_list|)
expr_stmt|;
name|assertU
argument_list|(
name|optimize
argument_list|()
argument_list|)
expr_stmt|;
name|assertQ
argument_list|(
literal|"Basic summarization"
argument_list|,
name|sumLRF
operator|.
name|makeRequest
argument_list|(
literal|"lon*"
argument_list|)
argument_list|,
literal|"//lst[@name='highlighting']/lst[@name='1']"
argument_list|,
literal|"//lst[@name='1']/arr[@name='t_text']/str"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testDefaultFieldNonPrefixWildcardHighlight
specifier|public
name|void
name|testDefaultFieldNonPrefixWildcardHighlight
parameter_list|()
block|{
comment|// do summarization using re-analysis of the field
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|args
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|args
operator|.
name|put
argument_list|(
literal|"hl"
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
name|args
operator|.
name|put
argument_list|(
literal|"df"
argument_list|,
literal|"t_text"
argument_list|)
expr_stmt|;
name|args
operator|.
name|put
argument_list|(
literal|"hl.fl"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|args
operator|.
name|put
argument_list|(
literal|"hl.usePhraseHighlighter"
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
name|args
operator|.
name|put
argument_list|(
literal|"hl.highlightMultiTerm"
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
name|TestHarness
operator|.
name|LocalRequestFactory
name|sumLRF
init|=
name|h
operator|.
name|getRequestFactory
argument_list|(
literal|"standard"
argument_list|,
literal|0
argument_list|,
literal|200
argument_list|,
name|args
argument_list|)
decl_stmt|;
name|assertU
argument_list|(
name|adoc
argument_list|(
literal|"t_text"
argument_list|,
literal|"a long day's night"
argument_list|,
literal|"id"
argument_list|,
literal|"1"
argument_list|)
argument_list|)
expr_stmt|;
name|assertU
argument_list|(
name|commit
argument_list|()
argument_list|)
expr_stmt|;
name|assertU
argument_list|(
name|optimize
argument_list|()
argument_list|)
expr_stmt|;
name|assertQ
argument_list|(
literal|"Basic summarization"
argument_list|,
name|sumLRF
operator|.
name|makeRequest
argument_list|(
literal|"l*g"
argument_list|)
argument_list|,
literal|"//lst[@name='highlighting']/lst[@name='1']"
argument_list|,
literal|"//lst[@name='1']/arr[@name='t_text']/str"
argument_list|)
expr_stmt|;
block|}
DECL|method|testSubwordWildcardHighlight
specifier|public
name|void
name|testSubwordWildcardHighlight
parameter_list|()
block|{
name|assertU
argument_list|(
name|adoc
argument_list|(
literal|"subword"
argument_list|,
literal|"lorem PowerShot.com ipsum"
argument_list|,
literal|"id"
argument_list|,
literal|"1"
argument_list|)
argument_list|)
expr_stmt|;
name|assertU
argument_list|(
name|commit
argument_list|()
argument_list|)
expr_stmt|;
name|assertQ
argument_list|(
literal|"subword wildcard highlighting"
argument_list|,
name|req
argument_list|(
literal|"q"
argument_list|,
literal|"subword:pow*"
argument_list|,
literal|"hl"
argument_list|,
literal|"true"
argument_list|,
literal|"hl.fl"
argument_list|,
literal|"subword"
argument_list|)
argument_list|,
literal|"//lst[@name='highlighting']/lst[@name='1']"
operator|+
literal|"/arr[@name='subword']/str='lorem<em>PowerShot.com</em> ipsum'"
argument_list|)
expr_stmt|;
block|}
DECL|method|testSubwordWildcardHighlightWithTermOffsets
specifier|public
name|void
name|testSubwordWildcardHighlightWithTermOffsets
parameter_list|()
block|{
name|assertU
argument_list|(
name|adoc
argument_list|(
literal|"subword_offsets"
argument_list|,
literal|"lorem PowerShot.com ipsum"
argument_list|,
literal|"id"
argument_list|,
literal|"1"
argument_list|)
argument_list|)
expr_stmt|;
name|assertU
argument_list|(
name|commit
argument_list|()
argument_list|)
expr_stmt|;
name|assertQ
argument_list|(
literal|"subword wildcard highlighting"
argument_list|,
name|req
argument_list|(
literal|"q"
argument_list|,
literal|"subword_offsets:pow*"
argument_list|,
literal|"hl"
argument_list|,
literal|"true"
argument_list|,
literal|"hl.fl"
argument_list|,
literal|"subword_offsets"
argument_list|)
argument_list|,
literal|"//lst[@name='highlighting']/lst[@name='1']"
operator|+
literal|"/arr[@name='subword_offsets']/str='lorem<em>PowerShot.com</em> ipsum'"
argument_list|)
expr_stmt|;
block|}
DECL|method|testSubwordWildcardHighlightWithTermOffsets2
specifier|public
name|void
name|testSubwordWildcardHighlightWithTermOffsets2
parameter_list|()
block|{
name|assertU
argument_list|(
name|adoc
argument_list|(
literal|"subword_offsets"
argument_list|,
literal|"lorem PowerShot ipsum"
argument_list|,
literal|"id"
argument_list|,
literal|"1"
argument_list|)
argument_list|)
expr_stmt|;
name|assertU
argument_list|(
name|commit
argument_list|()
argument_list|)
expr_stmt|;
name|assertQ
argument_list|(
literal|"subword wildcard highlighting"
argument_list|,
name|req
argument_list|(
literal|"q"
argument_list|,
literal|"subword_offsets:pow*"
argument_list|,
literal|"hl"
argument_list|,
literal|"true"
argument_list|,
literal|"hl.fl"
argument_list|,
literal|"subword_offsets"
argument_list|)
argument_list|,
literal|"//lst[@name='highlighting']/lst[@name='1']"
operator|+
literal|"/arr[@name='subword_offsets']/str='lorem<em>PowerShot</em> ipsum'"
argument_list|)
expr_stmt|;
block|}
DECL|method|testHlQParameter
specifier|public
name|void
name|testHlQParameter
parameter_list|()
block|{
name|assertU
argument_list|(
name|adoc
argument_list|(
literal|"title"
argument_list|,
literal|"Apache Software Foundation"
argument_list|,
literal|"t_text"
argument_list|,
literal|"apache software foundation"
argument_list|,
literal|"id"
argument_list|,
literal|"1"
argument_list|)
argument_list|)
expr_stmt|;
name|assertU
argument_list|(
name|commit
argument_list|()
argument_list|)
expr_stmt|;
name|assertQ
argument_list|(
literal|"hl.q parameter overrides q parameter"
argument_list|,
name|req
argument_list|(
literal|"q"
argument_list|,
literal|"title:Apache"
argument_list|,
literal|"hl"
argument_list|,
literal|"true"
argument_list|,
literal|"hl.fl"
argument_list|,
literal|"title"
argument_list|,
literal|"hl.q"
argument_list|,
literal|"title:Software"
argument_list|)
argument_list|,
literal|"//lst[@name='highlighting']/lst[@name='1']"
operator|+
literal|"/arr[@name='title']/str='Apache<em>Software</em> Foundation'"
argument_list|)
expr_stmt|;
name|assertQ
argument_list|(
literal|"hl.q parameter overrides q parameter"
argument_list|,
name|req
argument_list|(
literal|"q"
argument_list|,
literal|"title:Apache"
argument_list|,
literal|"hl"
argument_list|,
literal|"true"
argument_list|,
literal|"hl.fl"
argument_list|,
literal|"title"
argument_list|,
literal|"hl.q"
argument_list|,
literal|"{!v=$qq}"
argument_list|,
literal|"qq"
argument_list|,
literal|"title:Foundation"
argument_list|)
argument_list|,
literal|"//lst[@name='highlighting']/lst[@name='1']"
operator|+
literal|"/arr[@name='title']/str='Apache Software<em>Foundation</em>'"
argument_list|)
expr_stmt|;
name|assertQ
argument_list|(
literal|"hl.q parameter uses localparam parser definition correctly"
argument_list|,
name|req
argument_list|(
literal|"q"
argument_list|,
literal|"Apache"
argument_list|,
literal|"defType"
argument_list|,
literal|"edismax"
argument_list|,
literal|"qf"
argument_list|,
literal|"title t_text"
argument_list|,
literal|"hl"
argument_list|,
literal|"true"
argument_list|,
literal|"hl.fl"
argument_list|,
literal|"title"
argument_list|,
literal|"hl.q"
argument_list|,
literal|"{!edismax}Software"
argument_list|)
argument_list|,
literal|"//lst[@name='highlighting']/lst[@name='1']"
operator|+
literal|"/arr[@name='title']/str='Apache<em>Software</em> Foundation'"
argument_list|)
expr_stmt|;
name|assertQ
argument_list|(
literal|"hl.q parameter uses defType correctly"
argument_list|,
name|req
argument_list|(
literal|"q"
argument_list|,
literal|"Apache"
argument_list|,
literal|"defType"
argument_list|,
literal|"edismax"
argument_list|,
literal|"qf"
argument_list|,
literal|"title t_text"
argument_list|,
literal|"hl"
argument_list|,
literal|"true"
argument_list|,
literal|"hl.fl"
argument_list|,
literal|"title"
argument_list|,
literal|"hl.q"
argument_list|,
literal|"Software"
argument_list|)
argument_list|,
literal|"//lst[@name='highlighting']/lst[@name='1']"
operator|+
literal|"/arr[@name='title']/str='Apache<em>Software</em> Foundation'"
argument_list|)
expr_stmt|;
name|assertQ
argument_list|(
literal|"hl.q parameter uses hl.qparser param correctly"
argument_list|,
name|req
argument_list|(
literal|"q"
argument_list|,
literal|"t_text:Apache"
argument_list|,
literal|"qf"
argument_list|,
literal|"title t_text"
argument_list|,
literal|"hl"
argument_list|,
literal|"true"
argument_list|,
literal|"hl.fl"
argument_list|,
literal|"title"
argument_list|,
literal|"hl.q"
argument_list|,
literal|"Software"
argument_list|,
literal|"hl.qparser"
argument_list|,
literal|"edismax"
argument_list|)
argument_list|,
literal|"//lst[@name='highlighting']/lst[@name='1']"
operator|+
literal|"/arr[@name='title']/str='Apache<em>Software</em> Foundation'"
argument_list|)
expr_stmt|;
block|}
DECL|method|testHlQEdismaxParameter
specifier|public
name|void
name|testHlQEdismaxParameter
parameter_list|()
block|{
name|assertU
argument_list|(
name|adoc
argument_list|(
literal|"title"
argument_list|,
literal|"Apache Software Foundation"
argument_list|,
literal|"id"
argument_list|,
literal|"1"
argument_list|)
argument_list|)
expr_stmt|;
name|assertU
argument_list|(
name|commit
argument_list|()
argument_list|)
expr_stmt|;
name|assertQ
argument_list|(
literal|"hl.q parameter overrides q parameter"
argument_list|,
name|req
argument_list|(
literal|"q"
argument_list|,
literal|"title:Apache"
argument_list|,
literal|"hl"
argument_list|,
literal|"true"
argument_list|,
literal|"hl.fl"
argument_list|,
literal|"title"
argument_list|,
literal|"hl.q"
argument_list|,
literal|"{!edismax qf=title v=Software}"
argument_list|)
argument_list|,
literal|"//lst[@name='highlighting']/lst[@name='1']"
operator|+
literal|"/arr[@name='title']/str='Apache<em>Software</em> Foundation'"
argument_list|)
expr_stmt|;
name|assertQ
argument_list|(
literal|"hl.q parameter overrides q parameter"
argument_list|,
name|req
argument_list|(
literal|"q"
argument_list|,
literal|"title:Apache"
argument_list|,
literal|"hl"
argument_list|,
literal|"true"
argument_list|,
literal|"hl.fl"
argument_list|,
literal|"title"
argument_list|,
literal|"hl.q"
argument_list|,
literal|"{!v=$qq}"
argument_list|,
literal|"qq"
argument_list|,
literal|"title:Foundation"
argument_list|)
argument_list|,
literal|"//lst[@name='highlighting']/lst[@name='1']"
operator|+
literal|"/arr[@name='title']/str='Apache Software<em>Foundation</em>'"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testMaxMvParams
specifier|public
name|void
name|testMaxMvParams
parameter_list|()
block|{
name|assertU
argument_list|(
name|adoc
argument_list|(
literal|"title"
argument_list|,
literal|"Apache Software Foundation"
argument_list|,
literal|"id"
argument_list|,
literal|"1000"
argument_list|,
literal|"lower"
argument_list|,
literal|"gap1 target"
argument_list|,
literal|"lower"
argument_list|,
literal|"gap2 target"
argument_list|,
literal|"lower"
argument_list|,
literal|"gap3 nothing"
argument_list|,
literal|"lower"
argument_list|,
literal|"gap4 nothing"
argument_list|,
literal|"lower"
argument_list|,
literal|"gap5 target"
argument_list|,
literal|"lower"
argument_list|,
literal|"gap6 target"
argument_list|,
literal|"lower"
argument_list|,
literal|"gap7 nothing"
argument_list|,
literal|"lower"
argument_list|,
literal|"gap8 nothing"
argument_list|,
literal|"lower"
argument_list|,
literal|"gap9 target"
argument_list|,
literal|"lower"
argument_list|,
literal|"gap10 target"
argument_list|)
argument_list|)
expr_stmt|;
name|assertU
argument_list|(
name|commit
argument_list|()
argument_list|)
expr_stmt|;
comment|// First ensure we can count all six
name|assertQ
argument_list|(
literal|"Counting all MV pairs failed"
argument_list|,
name|req
argument_list|(
literal|"q"
argument_list|,
literal|"id:1000"
argument_list|,
name|HighlightParams
operator|.
name|HIGHLIGHT
argument_list|,
literal|"true"
argument_list|,
name|HighlightParams
operator|.
name|FIELDS
argument_list|,
literal|"lower"
argument_list|,
name|HighlightParams
operator|.
name|Q
argument_list|,
literal|"target"
argument_list|,
name|HighlightParams
operator|.
name|SNIPPETS
argument_list|,
literal|"100"
argument_list|)
argument_list|,
literal|"//lst[@name='highlighting']/lst[@name='1000']/arr[@name='lower' and count(*)=6]"
argument_list|)
expr_stmt|;
comment|// NOTE: These tests seem repeated, but we're testing for off-by-one errors
comment|// Now we should see exactly 2 by limiting the number of values searched to 4
name|assertQ
argument_list|(
literal|"Off by one by going too far"
argument_list|,
name|req
argument_list|(
literal|"q"
argument_list|,
literal|"id:1000"
argument_list|,
name|HighlightParams
operator|.
name|HIGHLIGHT
argument_list|,
literal|"true"
argument_list|,
name|HighlightParams
operator|.
name|FIELDS
argument_list|,
literal|"lower"
argument_list|,
name|HighlightParams
operator|.
name|Q
argument_list|,
literal|"target"
argument_list|,
name|HighlightParams
operator|.
name|SNIPPETS
argument_list|,
literal|"100"
argument_list|,
name|HighlightParams
operator|.
name|MAX_MULTIVALUED_TO_EXAMINE
argument_list|,
literal|"4"
argument_list|)
argument_list|,
literal|"//lst[@name='highlighting']/lst[@name='1000']/arr[@name='lower' and count(*)=2]"
argument_list|)
expr_stmt|;
comment|// Does 0 work?
name|assertQ
argument_list|(
literal|"Off by one by going too far"
argument_list|,
name|req
argument_list|(
literal|"q"
argument_list|,
literal|"id:1000"
argument_list|,
name|HighlightParams
operator|.
name|HIGHLIGHT
argument_list|,
literal|"true"
argument_list|,
name|HighlightParams
operator|.
name|FIELDS
argument_list|,
literal|"lower"
argument_list|,
name|HighlightParams
operator|.
name|Q
argument_list|,
literal|"target"
argument_list|,
name|HighlightParams
operator|.
name|SNIPPETS
argument_list|,
literal|"100"
argument_list|,
name|HighlightParams
operator|.
name|MAX_MULTIVALUED_TO_EXAMINE
argument_list|,
literal|"0"
argument_list|)
argument_list|,
literal|"//lst[@name='highlighting']/lst[@name='1000' and count(child::*) = 0]"
argument_list|)
expr_stmt|;
comment|// Now we should see exactly 2 by limiting the number of values searched to 2
name|assertQ
argument_list|(
literal|"Off by one by not going far enough"
argument_list|,
name|req
argument_list|(
literal|"q"
argument_list|,
literal|"id:1000"
argument_list|,
name|HighlightParams
operator|.
name|HIGHLIGHT
argument_list|,
literal|"true"
argument_list|,
name|HighlightParams
operator|.
name|FIELDS
argument_list|,
literal|"lower"
argument_list|,
name|HighlightParams
operator|.
name|Q
argument_list|,
literal|"target"
argument_list|,
name|HighlightParams
operator|.
name|SNIPPETS
argument_list|,
literal|"100"
argument_list|,
name|HighlightParams
operator|.
name|MAX_MULTIVALUED_TO_EXAMINE
argument_list|,
literal|"2"
argument_list|)
argument_list|,
literal|"//lst[@name='highlighting']/lst[@name='1000']/arr[@name='lower' and count(*)=2]"
argument_list|)
expr_stmt|;
comment|// Now we should see exactly 1 by limiting the number of values searched to 1
name|assertQ
argument_list|(
literal|"Not counting exactly 1"
argument_list|,
name|req
argument_list|(
literal|"q"
argument_list|,
literal|"id:1000"
argument_list|,
name|HighlightParams
operator|.
name|HIGHLIGHT
argument_list|,
literal|"true"
argument_list|,
name|HighlightParams
operator|.
name|FIELDS
argument_list|,
literal|"lower"
argument_list|,
name|HighlightParams
operator|.
name|Q
argument_list|,
literal|"target"
argument_list|,
name|HighlightParams
operator|.
name|SNIPPETS
argument_list|,
literal|"100"
argument_list|,
name|HighlightParams
operator|.
name|MAX_MULTIVALUED_TO_EXAMINE
argument_list|,
literal|"1"
argument_list|)
argument_list|,
literal|"//lst[@name='highlighting']/lst[@name='1000']/arr[@name='lower' and count(*)=1]"
argument_list|)
expr_stmt|;
comment|// Now we should see exactly 4 by limiting the number of values found to 4
name|assertQ
argument_list|(
literal|"Matching 4 should exactly match 4"
argument_list|,
name|req
argument_list|(
literal|"q"
argument_list|,
literal|"id:1000"
argument_list|,
name|HighlightParams
operator|.
name|HIGHLIGHT
argument_list|,
literal|"true"
argument_list|,
name|HighlightParams
operator|.
name|FIELDS
argument_list|,
literal|"lower"
argument_list|,
name|HighlightParams
operator|.
name|Q
argument_list|,
literal|"target"
argument_list|,
name|HighlightParams
operator|.
name|SNIPPETS
argument_list|,
literal|"100"
argument_list|,
name|HighlightParams
operator|.
name|MAX_MULTIVALUED_TO_MATCH
argument_list|,
literal|"4"
argument_list|)
argument_list|,
literal|"//lst[@name='highlighting']/lst[@name='1000']/arr[@name='lower' and count(*)=4]"
argument_list|)
expr_stmt|;
comment|// But if hl.preserveMulti=true then we should see 6 snippets even though 2 didn't match
name|assertQ
argument_list|(
literal|"hl.preserveMulti"
argument_list|,
name|req
argument_list|(
literal|"q"
argument_list|,
literal|"id:1000"
argument_list|,
name|HighlightParams
operator|.
name|HIGHLIGHT
argument_list|,
literal|"true"
argument_list|,
name|HighlightParams
operator|.
name|FIELDS
argument_list|,
literal|"lower"
argument_list|,
name|HighlightParams
operator|.
name|Q
argument_list|,
literal|"target"
argument_list|,
name|HighlightParams
operator|.
name|SNIPPETS
argument_list|,
literal|"100"
argument_list|,
name|HighlightParams
operator|.
name|MAX_MULTIVALUED_TO_MATCH
argument_list|,
literal|"4"
argument_list|,
name|HighlightParams
operator|.
name|PRESERVE_MULTI
argument_list|,
literal|"true"
argument_list|)
argument_list|,
literal|"//lst[@name='highlighting']/lst[@name='1000']/arr[@name='lower' and count(*)=6]"
argument_list|)
expr_stmt|;
comment|// Now we should see exactly 2 by limiting the number of values found to 2
name|assertQ
argument_list|(
literal|"Matching 6 should exactly search them all"
argument_list|,
name|req
argument_list|(
literal|"q"
argument_list|,
literal|"id:1000"
argument_list|,
name|HighlightParams
operator|.
name|HIGHLIGHT
argument_list|,
literal|"true"
argument_list|,
name|HighlightParams
operator|.
name|FIELDS
argument_list|,
literal|"lower"
argument_list|,
name|HighlightParams
operator|.
name|Q
argument_list|,
literal|"target"
argument_list|,
name|HighlightParams
operator|.
name|SNIPPETS
argument_list|,
literal|"100"
argument_list|,
name|HighlightParams
operator|.
name|MAX_MULTIVALUED_TO_MATCH
argument_list|,
literal|"6"
argument_list|)
argument_list|,
literal|"//lst[@name='highlighting']/lst[@name='1000']/arr[@name='lower' and count(*)=6]"
argument_list|)
expr_stmt|;
comment|// Now we should see exactly 1 by limiting the number of values found to 1
name|assertQ
argument_list|(
literal|"Matching 6 should exactly match them all"
argument_list|,
name|req
argument_list|(
literal|"q"
argument_list|,
literal|"id:1000"
argument_list|,
name|HighlightParams
operator|.
name|HIGHLIGHT
argument_list|,
literal|"true"
argument_list|,
name|HighlightParams
operator|.
name|FIELDS
argument_list|,
literal|"lower"
argument_list|,
name|HighlightParams
operator|.
name|Q
argument_list|,
literal|"target"
argument_list|,
name|HighlightParams
operator|.
name|SNIPPETS
argument_list|,
literal|"100"
argument_list|,
name|HighlightParams
operator|.
name|MAX_MULTIVALUED_TO_MATCH
argument_list|,
literal|"1"
argument_list|)
argument_list|,
literal|"//lst[@name='highlighting']/lst[@name='1000']/arr[@name='lower' and count(*)=1]"
argument_list|)
expr_stmt|;
comment|// Now we should see exactly 0 by limiting the number of values found to 0
name|assertQ
argument_list|(
literal|"Matching 6 should exactly match them all"
argument_list|,
name|req
argument_list|(
literal|"q"
argument_list|,
literal|"id:1000"
argument_list|,
name|HighlightParams
operator|.
name|HIGHLIGHT
argument_list|,
literal|"true"
argument_list|,
name|HighlightParams
operator|.
name|FIELDS
argument_list|,
literal|"lower"
argument_list|,
name|HighlightParams
operator|.
name|Q
argument_list|,
literal|"target"
argument_list|,
name|HighlightParams
operator|.
name|SNIPPETS
argument_list|,
literal|"100"
argument_list|,
name|HighlightParams
operator|.
name|MAX_MULTIVALUED_TO_MATCH
argument_list|,
literal|"0"
argument_list|)
argument_list|,
literal|"//lst[@name='highlighting']/lst[@name='1000' and count(child::*) = 0]"
argument_list|)
expr_stmt|;
comment|// Should bail at the first parameter matched.
name|assertQ
argument_list|(
literal|"Matching 6 should exactly match them all"
argument_list|,
name|req
argument_list|(
literal|"q"
argument_list|,
literal|"id:1000"
argument_list|,
name|HighlightParams
operator|.
name|HIGHLIGHT
argument_list|,
literal|"true"
argument_list|,
name|HighlightParams
operator|.
name|FIELDS
argument_list|,
literal|"lower"
argument_list|,
name|HighlightParams
operator|.
name|Q
argument_list|,
literal|"target"
argument_list|,
name|HighlightParams
operator|.
name|SNIPPETS
argument_list|,
literal|"100"
argument_list|,
name|HighlightParams
operator|.
name|MAX_MULTIVALUED_TO_MATCH
argument_list|,
literal|"2"
argument_list|,
name|HighlightParams
operator|.
name|MAX_MULTIVALUED_TO_EXAMINE
argument_list|,
literal|"10"
argument_list|)
argument_list|,
literal|"//lst[@name='highlighting']/lst[@name='1000']/arr[@name='lower' and count(*)=2]"
argument_list|)
expr_stmt|;
comment|// Should bail at the first parameter matched.
name|assertQ
argument_list|(
literal|"Matching 6 should exactly match them all"
argument_list|,
name|req
argument_list|(
literal|"q"
argument_list|,
literal|"id:1000"
argument_list|,
name|HighlightParams
operator|.
name|HIGHLIGHT
argument_list|,
literal|"true"
argument_list|,
name|HighlightParams
operator|.
name|FIELDS
argument_list|,
literal|"lower"
argument_list|,
name|HighlightParams
operator|.
name|Q
argument_list|,
literal|"target"
argument_list|,
name|HighlightParams
operator|.
name|SNIPPETS
argument_list|,
literal|"100"
argument_list|,
name|HighlightParams
operator|.
name|MAX_MULTIVALUED_TO_MATCH
argument_list|,
literal|"10"
argument_list|,
name|HighlightParams
operator|.
name|MAX_MULTIVALUED_TO_EXAMINE
argument_list|,
literal|"2"
argument_list|)
argument_list|,
literal|"//lst[@name='highlighting']/lst[@name='1000']/arr[@name='lower' and count(*)=2]"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|payloadFilteringSpanQuery
specifier|public
name|void
name|payloadFilteringSpanQuery
parameter_list|()
throws|throws
name|IOException
block|{
name|clearIndex
argument_list|()
expr_stmt|;
name|String
name|FIELD_NAME
init|=
literal|"payloadDelimited"
decl_stmt|;
name|assertU
argument_list|(
name|adoc
argument_list|(
literal|"id"
argument_list|,
literal|"0"
argument_list|,
name|FIELD_NAME
argument_list|,
literal|"word|7 word|2"
argument_list|)
argument_list|)
expr_stmt|;
name|assertU
argument_list|(
name|commit
argument_list|()
argument_list|)
expr_stmt|;
comment|//We search at a lower level than typical Solr tests because there's no QParser for payloads
comment|//Create query matching this payload
name|Query
name|query
init|=
operator|new
name|SpanPayloadCheckQuery
argument_list|(
operator|new
name|SpanTermQuery
argument_list|(
operator|new
name|Term
argument_list|(
name|FIELD_NAME
argument_list|,
literal|"word"
argument_list|)
argument_list|)
argument_list|,
name|Collections
operator|.
name|singleton
argument_list|(
operator|new
name|byte
index|[]
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|7
block|}
argument_list|)
argument_list|)
decl_stmt|;
comment|//bytes for integer 7
comment|//invoke highlight component... the hard way
specifier|final
name|SearchComponent
name|hlComp
init|=
name|h
operator|.
name|getCore
argument_list|()
operator|.
name|getSearchComponent
argument_list|(
literal|"highlight"
argument_list|)
decl_stmt|;
name|SolrQueryRequest
name|req
init|=
name|req
argument_list|(
literal|"hl"
argument_list|,
literal|"true"
argument_list|,
literal|"hl.fl"
argument_list|,
name|FIELD_NAME
argument_list|,
name|HighlightParams
operator|.
name|USE_PHRASE_HIGHLIGHTER
argument_list|,
literal|"true"
argument_list|)
decl_stmt|;
try|try
block|{
name|SolrQueryResponse
name|resp
init|=
operator|new
name|SolrQueryResponse
argument_list|()
decl_stmt|;
name|ResponseBuilder
name|rb
init|=
operator|new
name|ResponseBuilder
argument_list|(
name|req
argument_list|,
name|resp
argument_list|,
name|Collections
operator|.
name|singletonList
argument_list|(
name|hlComp
argument_list|)
argument_list|)
decl_stmt|;
name|rb
operator|.
name|setHighlightQuery
argument_list|(
name|query
argument_list|)
expr_stmt|;
name|rb
operator|.
name|setResults
argument_list|(
name|req
operator|.
name|getSearcher
argument_list|()
operator|.
name|getDocListAndSet
argument_list|(
name|query
argument_list|,
operator|(
name|DocSet
operator|)
literal|null
argument_list|,
literal|null
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|//highlight:
name|hlComp
operator|.
name|prepare
argument_list|(
name|rb
argument_list|)
expr_stmt|;
name|hlComp
operator|.
name|process
argument_list|(
name|rb
argument_list|)
expr_stmt|;
comment|//inspect response
specifier|final
name|String
index|[]
name|snippets
init|=
operator|(
name|String
index|[]
operator|)
name|resp
operator|.
name|getValues
argument_list|()
operator|.
name|findRecursive
argument_list|(
literal|"highlighting"
argument_list|,
literal|"0"
argument_list|,
name|FIELD_NAME
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|"<em>word|7</em> word|2"
argument_list|,
name|snippets
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|req
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_class
end_unit
