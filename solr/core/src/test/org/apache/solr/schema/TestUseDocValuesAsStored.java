begin_unit
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_package
DECL|package|org.apache.solr.schema
package|package
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|schema
package|;
end_package
begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|parsers
operator|.
name|DocumentBuilder
import|;
end_import
begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|parsers
operator|.
name|DocumentBuilderFactory
import|;
end_import
begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|xpath
operator|.
name|XPath
import|;
end_import
begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|xpath
operator|.
name|XPathConstants
import|;
end_import
begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|xpath
operator|.
name|XPathFactory
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import
begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|charset
operator|.
name|StandardCharsets
import|;
end_import
begin_import
import|import
name|java
operator|.
name|time
operator|.
name|Instant
import|;
end_import
begin_import
import|import
name|java
operator|.
name|time
operator|.
name|LocalDateTime
import|;
end_import
begin_import
import|import
name|java
operator|.
name|time
operator|.
name|Month
import|;
end_import
begin_import
import|import
name|java
operator|.
name|time
operator|.
name|ZoneOffset
import|;
end_import
begin_import
import|import
name|java
operator|.
name|time
operator|.
name|format
operator|.
name|DateTimeFormatter
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Pattern
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|io
operator|.
name|FileUtils
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|IOUtils
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|TestUtil
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|core
operator|.
name|AbstractBadConfigTestBase
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|util
operator|.
name|DOMUtil
import|;
end_import
begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|After
import|;
end_import
begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Before
import|;
end_import
begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Test
import|;
end_import
begin_import
import|import
name|org
operator|.
name|w3c
operator|.
name|dom
operator|.
name|Document
import|;
end_import
begin_import
import|import
name|org
operator|.
name|w3c
operator|.
name|dom
operator|.
name|NodeList
import|;
end_import
begin_import
import|import
name|org
operator|.
name|xml
operator|.
name|sax
operator|.
name|InputSource
import|;
end_import
begin_comment
comment|/**  * Tests the useDocValuesAsStored functionality.  */
end_comment
begin_class
DECL|class|TestUseDocValuesAsStored
specifier|public
class|class
name|TestUseDocValuesAsStored
extends|extends
name|AbstractBadConfigTestBase
block|{
DECL|field|id
specifier|private
name|int
name|id
init|=
literal|1
decl_stmt|;
DECL|field|tmpSolrHome
specifier|private
specifier|static
name|File
name|tmpSolrHome
decl_stmt|;
DECL|field|tmpConfDir
specifier|private
specifier|static
name|File
name|tmpConfDir
decl_stmt|;
DECL|field|collection
specifier|private
specifier|static
specifier|final
name|String
name|collection
init|=
literal|"collection1"
decl_stmt|;
DECL|field|confDir
specifier|private
specifier|static
specifier|final
name|String
name|confDir
init|=
name|collection
operator|+
literal|"/conf"
decl_stmt|;
DECL|field|START_RANDOM_EPOCH_MILLIS
specifier|private
specifier|static
specifier|final
name|long
name|START_RANDOM_EPOCH_MILLIS
decl_stmt|;
DECL|field|END_RANDOM_EPOCH_MILLIS
specifier|private
specifier|static
specifier|final
name|long
name|END_RANDOM_EPOCH_MILLIS
decl_stmt|;
DECL|field|SEVERITY
specifier|private
specifier|static
specifier|final
name|String
index|[]
name|SEVERITY
decl_stmt|;
comment|// http://www.w3.org/TR/2006/REC-xml-20060816/#charsets
DECL|field|NON_XML_CHARS
specifier|private
specifier|static
specifier|final
name|String
name|NON_XML_CHARS
init|=
literal|"\u0000-\u0008\u000B-\u000C\u000E-\u001F\uFFFE\uFFFF"
decl_stmt|;
comment|// Avoid single quotes (problematic in XPath literals) and carriage returns (XML roundtripping fails)
DECL|field|BAD_CHAR_PATTERN
specifier|private
specifier|static
specifier|final
name|Pattern
name|BAD_CHAR_PATTERN
init|=
name|Pattern
operator|.
name|compile
argument_list|(
literal|"[\'\r"
operator|+
name|NON_XML_CHARS
operator|+
literal|"]"
argument_list|)
decl_stmt|;
DECL|field|STORED_FIELD_NAME_PATTERN
specifier|private
specifier|static
specifier|final
name|Pattern
name|STORED_FIELD_NAME_PATTERN
init|=
name|Pattern
operator|.
name|compile
argument_list|(
literal|"_dv$"
argument_list|)
decl_stmt|;
static|static
block|{
comment|// Copy of DateTimeFormatter.ISO_INSTANT with fixed 3 digit milliseconds
name|START_RANDOM_EPOCH_MILLIS
operator|=
name|LocalDateTime
operator|.
name|of
argument_list|(
literal|1970
argument_list|,
name|Month
operator|.
name|JANUARY
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|.
name|toInstant
argument_list|(
name|ZoneOffset
operator|.
name|UTC
argument_list|)
operator|.
name|toEpochMilli
argument_list|()
expr_stmt|;
name|END_RANDOM_EPOCH_MILLIS
operator|=
name|LocalDateTime
operator|.
name|of
argument_list|(
literal|2030
argument_list|,
name|Month
operator|.
name|DECEMBER
argument_list|,
literal|31
argument_list|,
literal|23
argument_list|,
literal|59
argument_list|,
literal|59
argument_list|,
literal|999_000_000
argument_list|)
operator|.
name|toInstant
argument_list|(
name|ZoneOffset
operator|.
name|UTC
argument_list|)
operator|.
name|toEpochMilli
argument_list|()
expr_stmt|;
try|try
block|{
name|DocumentBuilder
name|builder
init|=
name|DocumentBuilderFactory
operator|.
name|newInstance
argument_list|()
operator|.
name|newDocumentBuilder
argument_list|()
decl_stmt|;
name|InputStream
name|stream
init|=
name|TestUseDocValuesAsStored
operator|.
name|class
operator|.
name|getResourceAsStream
argument_list|(
literal|"/solr/collection1/conf/enumsConfig.xml"
argument_list|)
decl_stmt|;
name|Document
name|doc
init|=
name|builder
operator|.
name|parse
argument_list|(
operator|new
name|InputSource
argument_list|(
name|IOUtils
operator|.
name|getDecodingReader
argument_list|(
name|stream
argument_list|,
name|StandardCharsets
operator|.
name|UTF_8
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|XPath
name|xpath
init|=
name|XPathFactory
operator|.
name|newInstance
argument_list|()
operator|.
name|newXPath
argument_list|()
decl_stmt|;
name|NodeList
name|nodes
init|=
operator|(
name|NodeList
operator|)
name|xpath
operator|.
name|evaluate
argument_list|(
literal|"/enumsConfig/enum[@name='severity']/value"
argument_list|,
name|doc
argument_list|,
name|XPathConstants
operator|.
name|NODESET
argument_list|)
decl_stmt|;
name|SEVERITY
operator|=
operator|new
name|String
index|[
name|nodes
operator|.
name|getLength
argument_list|()
index|]
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nodes
operator|.
name|getLength
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|SEVERITY
index|[
name|i
index|]
operator|=
name|DOMUtil
operator|.
name|getText
argument_list|(
name|nodes
operator|.
name|item
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Before
DECL|method|initManagedSchemaCore
specifier|private
name|void
name|initManagedSchemaCore
parameter_list|()
throws|throws
name|Exception
block|{
name|tmpSolrHome
operator|=
name|createTempDir
argument_list|()
operator|.
name|toFile
argument_list|()
expr_stmt|;
name|tmpConfDir
operator|=
operator|new
name|File
argument_list|(
name|tmpSolrHome
argument_list|,
name|confDir
argument_list|)
expr_stmt|;
name|File
name|testHomeConfDir
init|=
operator|new
name|File
argument_list|(
name|TEST_HOME
argument_list|()
argument_list|,
name|confDir
argument_list|)
decl_stmt|;
name|FileUtils
operator|.
name|copyFileToDirectory
argument_list|(
operator|new
name|File
argument_list|(
name|testHomeConfDir
argument_list|,
literal|"solrconfig-managed-schema.xml"
argument_list|)
argument_list|,
name|tmpConfDir
argument_list|)
expr_stmt|;
name|FileUtils
operator|.
name|copyFileToDirectory
argument_list|(
operator|new
name|File
argument_list|(
name|testHomeConfDir
argument_list|,
literal|"solrconfig.snippet.randomindexconfig.xml"
argument_list|)
argument_list|,
name|tmpConfDir
argument_list|)
expr_stmt|;
name|FileUtils
operator|.
name|copyFileToDirectory
argument_list|(
operator|new
name|File
argument_list|(
name|testHomeConfDir
argument_list|,
literal|"enumsConfig.xml"
argument_list|)
argument_list|,
name|tmpConfDir
argument_list|)
expr_stmt|;
name|FileUtils
operator|.
name|copyFileToDirectory
argument_list|(
operator|new
name|File
argument_list|(
name|testHomeConfDir
argument_list|,
literal|"schema-non-stored-docvalues.xml"
argument_list|)
argument_list|,
name|tmpConfDir
argument_list|)
expr_stmt|;
comment|// initCore will trigger an upgrade to managed schema, since the solrconfig has
comment|//<schemaFactory class="ManagedIndexSchemaFactory" ... />
name|System
operator|.
name|setProperty
argument_list|(
literal|"enable.update.log"
argument_list|,
literal|"false"
argument_list|)
expr_stmt|;
name|System
operator|.
name|setProperty
argument_list|(
literal|"managed.schema.mutable"
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
name|initCore
argument_list|(
literal|"solrconfig-managed-schema.xml"
argument_list|,
literal|"schema-non-stored-docvalues.xml"
argument_list|,
name|tmpSolrHome
operator|.
name|getPath
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|After
DECL|method|afterClass
specifier|private
name|void
name|afterClass
parameter_list|()
throws|throws
name|Exception
block|{
name|deleteCore
argument_list|()
expr_stmt|;
name|System
operator|.
name|clearProperty
argument_list|(
literal|"managed.schema.mutable"
argument_list|)
expr_stmt|;
name|System
operator|.
name|clearProperty
argument_list|(
literal|"enable.update.log"
argument_list|)
expr_stmt|;
block|}
DECL|method|getCoreName
specifier|public
name|String
name|getCoreName
parameter_list|()
block|{
return|return
literal|"basic"
return|;
block|}
annotation|@
name|Test
DECL|method|testOnEmptyIndex
specifier|public
name|void
name|testOnEmptyIndex
parameter_list|()
throws|throws
name|Exception
block|{
name|clearIndex
argument_list|()
expr_stmt|;
name|assertU
argument_list|(
name|commit
argument_list|()
argument_list|)
expr_stmt|;
name|assertJQ
argument_list|(
name|req
argument_list|(
literal|"q"
argument_list|,
literal|"*:*"
argument_list|)
argument_list|,
literal|"/response/numFound==0"
argument_list|)
expr_stmt|;
name|assertJQ
argument_list|(
name|req
argument_list|(
literal|"q"
argument_list|,
literal|"*:*"
argument_list|,
literal|"fl"
argument_list|,
literal|"*"
argument_list|)
argument_list|,
literal|"/response/numFound==0"
argument_list|)
expr_stmt|;
name|assertJQ
argument_list|(
name|req
argument_list|(
literal|"q"
argument_list|,
literal|"*:*"
argument_list|,
literal|"fl"
argument_list|,
literal|"test_nonstored_dv_str"
argument_list|)
argument_list|,
literal|"/response/numFound==0"
argument_list|)
expr_stmt|;
name|assertJQ
argument_list|(
name|req
argument_list|(
literal|"q"
argument_list|,
literal|"*:*"
argument_list|,
literal|"fl"
argument_list|,
literal|"*,test_nonstored_dv_str"
argument_list|)
argument_list|,
literal|"/response/numFound==0"
argument_list|)
expr_stmt|;
name|assertU
argument_list|(
name|adoc
argument_list|(
literal|"id"
argument_list|,
literal|"xyz"
argument_list|,
literal|"test_nonstored_dv_str"
argument_list|,
literal|"xyz"
argument_list|)
argument_list|)
expr_stmt|;
name|assertJQ
argument_list|(
name|req
argument_list|(
literal|"q"
argument_list|,
literal|"*:*"
argument_list|)
argument_list|,
literal|"/response/numFound==0"
argument_list|)
expr_stmt|;
name|assertJQ
argument_list|(
name|req
argument_list|(
literal|"q"
argument_list|,
literal|"*:*"
argument_list|,
literal|"fl"
argument_list|,
literal|"*"
argument_list|)
argument_list|,
literal|"/response/numFound==0"
argument_list|)
expr_stmt|;
name|assertJQ
argument_list|(
name|req
argument_list|(
literal|"q"
argument_list|,
literal|"*:*"
argument_list|,
literal|"fl"
argument_list|,
literal|"test_nonstored_dv_str"
argument_list|)
argument_list|,
literal|"/response/numFound==0"
argument_list|)
expr_stmt|;
name|assertJQ
argument_list|(
name|req
argument_list|(
literal|"q"
argument_list|,
literal|"*:*"
argument_list|,
literal|"fl"
argument_list|,
literal|"*,test_nonstored_dv_str"
argument_list|)
argument_list|,
literal|"/response/numFound==0"
argument_list|)
expr_stmt|;
name|assertU
argument_list|(
name|commit
argument_list|()
argument_list|)
expr_stmt|;
name|assertJQ
argument_list|(
name|req
argument_list|(
literal|"q"
argument_list|,
literal|"*:*"
argument_list|)
argument_list|,
literal|"/response/numFound==1"
argument_list|,
literal|"/response/docs==["
operator|+
literal|"{'id':'xyz','test_nonstored_dv_str':'xyz'}"
operator|+
literal|"]"
argument_list|)
expr_stmt|;
name|assertJQ
argument_list|(
name|req
argument_list|(
literal|"q"
argument_list|,
literal|"*:*"
argument_list|,
literal|"fl"
argument_list|,
literal|"*"
argument_list|)
argument_list|,
literal|"/response/numFound==1"
argument_list|,
literal|"/response/docs==["
operator|+
literal|"{'id':'xyz','test_nonstored_dv_str':'xyz'}"
operator|+
literal|"]"
argument_list|)
expr_stmt|;
name|assertJQ
argument_list|(
name|req
argument_list|(
literal|"q"
argument_list|,
literal|"*:*"
argument_list|,
literal|"fl"
argument_list|,
literal|"test_nonstored_dv_str"
argument_list|)
argument_list|,
literal|"/response/numFound==1"
argument_list|,
literal|"/response/docs==["
operator|+
literal|"{'test_nonstored_dv_str':'xyz'}"
operator|+
literal|"]"
argument_list|)
expr_stmt|;
name|assertJQ
argument_list|(
name|req
argument_list|(
literal|"q"
argument_list|,
literal|"*:*"
argument_list|,
literal|"fl"
argument_list|,
literal|"*,test_nonstored_dv_str"
argument_list|)
argument_list|,
literal|"/response/numFound==1"
argument_list|,
literal|"/response/docs==["
operator|+
literal|"{'id':'xyz','test_nonstored_dv_str':'xyz'}"
operator|+
literal|"]"
argument_list|)
expr_stmt|;
name|assertU
argument_list|(
name|adoc
argument_list|(
literal|"id"
argument_list|,
literal|"xyz"
argument_list|)
argument_list|)
expr_stmt|;
name|assertU
argument_list|(
name|commit
argument_list|()
argument_list|)
expr_stmt|;
name|assertJQ
argument_list|(
name|req
argument_list|(
literal|"q"
argument_list|,
literal|"*:*"
argument_list|)
argument_list|,
literal|"/response/numFound==1"
argument_list|,
literal|"/response/docs==["
operator|+
literal|"{'id':'xyz'}"
operator|+
literal|"]"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testRandomSingleAndMultiValued
specifier|public
name|void
name|testRandomSingleAndMultiValued
parameter_list|()
throws|throws
name|Exception
block|{
for|for
control|(
name|int
name|c
init|=
literal|0
init|;
name|c
operator|<
literal|10
operator|*
name|RANDOM_MULTIPLIER
condition|;
operator|++
name|c
control|)
block|{
name|clearIndex
argument_list|()
expr_stmt|;
name|int
index|[]
name|arity
init|=
operator|new
name|int
index|[
literal|9
index|]
decl_stmt|;
for|for
control|(
name|int
name|a
init|=
literal|0
init|;
name|a
operator|<
name|arity
operator|.
name|length
condition|;
operator|++
name|a
control|)
block|{
comment|// Single-valued 50% of the time; other 50%: 2-10 values equally likely
name|arity
index|[
name|a
index|]
operator|=
name|random
argument_list|()
operator|.
name|nextBoolean
argument_list|()
condition|?
literal|1
else|:
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|random
argument_list|()
argument_list|,
literal|2
argument_list|,
literal|10
argument_list|)
expr_stmt|;
block|}
name|doTest
argument_list|(
literal|"check string value is correct"
argument_list|,
name|dvStringFieldName
argument_list|(
name|arity
index|[
literal|0
index|]
argument_list|,
literal|true
argument_list|,
literal|false
argument_list|)
argument_list|,
literal|"str"
argument_list|,
name|nextValues
argument_list|(
name|arity
index|[
literal|0
index|]
argument_list|,
literal|"str"
argument_list|)
argument_list|)
expr_stmt|;
name|doTest
argument_list|(
literal|"check int value is correct"
argument_list|,
literal|"test_i"
operator|+
name|plural
argument_list|(
name|arity
index|[
literal|1
index|]
argument_list|)
operator|+
literal|"_dvo"
argument_list|,
literal|"int"
argument_list|,
name|nextValues
argument_list|(
name|arity
index|[
literal|1
index|]
argument_list|,
literal|"int"
argument_list|)
argument_list|)
expr_stmt|;
name|doTest
argument_list|(
literal|"check double value is correct"
argument_list|,
literal|"test_d"
operator|+
name|plural
argument_list|(
name|arity
index|[
literal|2
index|]
argument_list|)
operator|+
literal|"_dvo"
argument_list|,
literal|"double"
argument_list|,
name|nextValues
argument_list|(
name|arity
index|[
literal|2
index|]
argument_list|,
literal|"double"
argument_list|)
argument_list|)
expr_stmt|;
name|doTest
argument_list|(
literal|"check long value is correct"
argument_list|,
literal|"test_l"
operator|+
name|plural
argument_list|(
name|arity
index|[
literal|3
index|]
argument_list|)
operator|+
literal|"_dvo"
argument_list|,
literal|"long"
argument_list|,
name|nextValues
argument_list|(
name|arity
index|[
literal|3
index|]
argument_list|,
literal|"long"
argument_list|)
argument_list|)
expr_stmt|;
name|doTest
argument_list|(
literal|"check float value is correct"
argument_list|,
literal|"test_f"
operator|+
name|plural
argument_list|(
name|arity
index|[
literal|4
index|]
argument_list|)
operator|+
literal|"_dvo"
argument_list|,
literal|"float"
argument_list|,
name|nextValues
argument_list|(
name|arity
index|[
literal|4
index|]
argument_list|,
literal|"float"
argument_list|)
argument_list|)
expr_stmt|;
name|doTest
argument_list|(
literal|"check date value is correct"
argument_list|,
literal|"test_dt"
operator|+
name|plural
argument_list|(
name|arity
index|[
literal|5
index|]
argument_list|)
operator|+
literal|"_dvo"
argument_list|,
literal|"date"
argument_list|,
name|nextValues
argument_list|(
name|arity
index|[
literal|5
index|]
argument_list|,
literal|"date"
argument_list|)
argument_list|)
expr_stmt|;
name|doTest
argument_list|(
literal|"check stored and docValues value is correct"
argument_list|,
name|dvStringFieldName
argument_list|(
name|arity
index|[
literal|6
index|]
argument_list|,
literal|true
argument_list|,
literal|true
argument_list|)
argument_list|,
literal|"str"
argument_list|,
name|nextValues
argument_list|(
name|arity
index|[
literal|6
index|]
argument_list|,
literal|"str"
argument_list|)
argument_list|)
expr_stmt|;
name|doTest
argument_list|(
literal|"check non-stored and non-indexed is accessible"
argument_list|,
name|dvStringFieldName
argument_list|(
name|arity
index|[
literal|7
index|]
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|)
argument_list|,
literal|"str"
argument_list|,
name|nextValues
argument_list|(
name|arity
index|[
literal|7
index|]
argument_list|,
literal|"str"
argument_list|)
argument_list|)
expr_stmt|;
name|doTest
argument_list|(
literal|"enumField"
argument_list|,
literal|"enum"
operator|+
name|plural
argument_list|(
name|arity
index|[
literal|8
index|]
argument_list|)
operator|+
literal|"_dvo"
argument_list|,
literal|"str"
argument_list|,
name|nextValues
argument_list|(
name|arity
index|[
literal|8
index|]
argument_list|,
literal|"enum"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|plural
specifier|private
name|String
name|plural
parameter_list|(
name|int
name|arity
parameter_list|)
block|{
return|return
name|arity
operator|>
literal|1
condition|?
literal|"s"
else|:
literal|""
return|;
block|}
DECL|method|isStoredField
specifier|private
specifier|static
name|boolean
name|isStoredField
parameter_list|(
name|String
name|fieldName
parameter_list|)
block|{
return|return
name|STORED_FIELD_NAME_PATTERN
operator|.
name|matcher
argument_list|(
name|fieldName
argument_list|)
operator|.
name|find
argument_list|()
return|;
block|}
DECL|method|dvStringFieldName
specifier|private
name|String
name|dvStringFieldName
parameter_list|(
name|int
name|arity
parameter_list|,
name|boolean
name|indexed
parameter_list|,
name|boolean
name|stored
parameter_list|)
block|{
name|String
name|base
init|=
literal|"test_s"
operator|+
operator|(
name|arity
operator|>
literal|1
condition|?
literal|"s"
else|:
literal|""
operator|)
decl_stmt|;
name|String
name|suffix
init|=
literal|""
decl_stmt|;
if|if
condition|(
name|indexed
operator|&&
name|stored
condition|)
name|suffix
operator|=
literal|"_dv"
expr_stmt|;
elseif|else
if|if
condition|(
name|indexed
operator|&&
operator|!
name|stored
condition|)
name|suffix
operator|=
literal|"_dvo"
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|indexed
operator|&&
operator|!
name|stored
condition|)
name|suffix
operator|=
literal|"_dvo2"
expr_stmt|;
else|else
name|assertTrue
argument_list|(
literal|"unsupported dv string field combination: stored and not indexed"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
return|return
name|base
operator|+
name|suffix
return|;
block|}
DECL|method|nextValues
specifier|private
name|String
index|[]
name|nextValues
parameter_list|(
name|int
name|arity
parameter_list|,
name|String
name|valueType
parameter_list|)
throws|throws
name|Exception
block|{
name|String
index|[]
name|values
init|=
operator|new
name|String
index|[
name|arity
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|arity
condition|;
operator|++
name|i
control|)
block|{
switch|switch
condition|(
name|valueType
condition|)
block|{
case|case
literal|"int"
case|:
name|values
index|[
name|i
index|]
operator|=
name|String
operator|.
name|valueOf
argument_list|(
name|random
argument_list|()
operator|.
name|nextInt
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
literal|"double"
case|:
name|values
index|[
name|i
index|]
operator|=
name|String
operator|.
name|valueOf
argument_list|(
name|Double
operator|.
name|longBitsToDouble
argument_list|(
name|random
argument_list|()
operator|.
name|nextLong
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|"long"
case|:
name|values
index|[
name|i
index|]
operator|=
name|String
operator|.
name|valueOf
argument_list|(
name|random
argument_list|()
operator|.
name|nextLong
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
literal|"float"
case|:
name|values
index|[
name|i
index|]
operator|=
name|String
operator|.
name|valueOf
argument_list|(
name|Float
operator|.
name|intBitsToFloat
argument_list|(
name|random
argument_list|()
operator|.
name|nextInt
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|"enum"
case|:
name|values
index|[
name|i
index|]
operator|=
name|SEVERITY
index|[
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|random
argument_list|()
argument_list|,
literal|0
argument_list|,
name|SEVERITY
operator|.
name|length
operator|-
literal|1
argument_list|)
index|]
expr_stmt|;
break|break;
case|case
literal|"str"
case|:
block|{
name|String
name|str
init|=
name|TestUtil
operator|.
name|randomRealisticUnicodeString
argument_list|(
name|random
argument_list|()
argument_list|)
decl_stmt|;
name|values
index|[
name|i
index|]
operator|=
name|BAD_CHAR_PATTERN
operator|.
name|matcher
argument_list|(
name|str
argument_list|)
operator|.
name|replaceAll
argument_list|(
literal|"\uFFFD"
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
literal|"date"
case|:
block|{
name|long
name|epochMillis
init|=
name|TestUtil
operator|.
name|nextLong
argument_list|(
name|random
argument_list|()
argument_list|,
name|START_RANDOM_EPOCH_MILLIS
argument_list|,
name|END_RANDOM_EPOCH_MILLIS
argument_list|)
decl_stmt|;
name|LocalDateTime
name|dateTime
init|=
name|LocalDateTime
operator|.
name|ofInstant
argument_list|(
name|Instant
operator|.
name|ofEpochMilli
argument_list|(
name|epochMillis
argument_list|)
argument_list|,
name|ZoneOffset
operator|.
name|UTC
argument_list|)
decl_stmt|;
name|values
index|[
name|i
index|]
operator|=
name|dateTime
operator|.
name|format
argument_list|(
name|DateTimeFormatter
operator|.
name|ISO_LOCAL_DATE_TIME
argument_list|)
operator|+
literal|'Z'
expr_stmt|;
break|break;
block|}
default|default:
throw|throw
operator|new
name|Exception
argument_list|(
literal|"unknown type '"
operator|+
name|valueType
operator|+
literal|"'"
argument_list|)
throw|;
block|}
block|}
return|return
name|values
return|;
block|}
annotation|@
name|Test
DECL|method|testMultipleSearchResults
specifier|public
name|void
name|testMultipleSearchResults
parameter_list|()
throws|throws
name|Exception
block|{
comment|// Three documents with different numbers of values for a field
name|assertU
argument_list|(
name|adoc
argument_list|(
literal|"id"
argument_list|,
literal|"myid1"
argument_list|,
literal|"test_is_dvo"
argument_list|,
literal|"101"
argument_list|,
literal|"test_is_dvo"
argument_list|,
literal|"102"
argument_list|,
literal|"test_is_dvo"
argument_list|,
literal|"103"
argument_list|)
argument_list|)
expr_stmt|;
name|assertU
argument_list|(
name|adoc
argument_list|(
literal|"id"
argument_list|,
literal|"myid2"
argument_list|,
literal|"test_is_dvo"
argument_list|,
literal|"201"
argument_list|,
literal|"test_is_dvo"
argument_list|,
literal|"202"
argument_list|)
argument_list|)
expr_stmt|;
name|assertU
argument_list|(
name|adoc
argument_list|(
literal|"id"
argument_list|,
literal|"myid3"
argument_list|,
literal|"test_is_dvo"
argument_list|,
literal|"301"
argument_list|,
literal|"test_is_dvo"
argument_list|,
literal|"302"
argument_list|,
literal|"test_is_dvo"
argument_list|,
literal|"303"
argument_list|,
literal|"test_is_dvo"
argument_list|,
literal|"304"
argument_list|)
argument_list|)
expr_stmt|;
comment|// Multivalued and singly valued fields in the same document
name|assertU
argument_list|(
name|adoc
argument_list|(
literal|"id"
argument_list|,
literal|"myid4"
argument_list|,
literal|"test_s_dvo"
argument_list|,
literal|"hello"
argument_list|,
literal|"test_is_dvo"
argument_list|,
literal|"401"
argument_list|,
literal|"test_is_dvo"
argument_list|,
literal|"402"
argument_list|)
argument_list|)
expr_stmt|;
comment|// Test a field which has useDocValuesAsStored=false
name|assertU
argument_list|(
name|adoc
argument_list|(
literal|"id"
argument_list|,
literal|"myid5"
argument_list|,
literal|"nonstored_dv_str"
argument_list|,
literal|"dont see me"
argument_list|)
argument_list|)
expr_stmt|;
name|assertU
argument_list|(
name|adoc
argument_list|(
literal|"id"
argument_list|,
literal|"myid6"
argument_list|,
literal|"nonstored_dv_str"
argument_list|,
literal|"dont see me"
argument_list|,
literal|"test_s_dvo"
argument_list|,
literal|"hello"
argument_list|)
argument_list|)
expr_stmt|;
name|assertU
argument_list|(
name|commit
argument_list|()
argument_list|)
expr_stmt|;
name|assertJQ
argument_list|(
name|req
argument_list|(
literal|"q"
argument_list|,
literal|"id:myid*"
argument_list|,
literal|"fl"
argument_list|,
literal|"*"
argument_list|)
argument_list|,
literal|"/response/docs==["
operator|+
literal|"{'id':'myid1','test_is_dvo':[101,102,103]},"
operator|+
literal|"{'id':'myid2','test_is_dvo':[201,202]},"
operator|+
literal|"{'id':'myid3','test_is_dvo':[301,302,303,304]},"
operator|+
literal|"{'id':'myid4','test_s_dvo':'hello','test_is_dvo':[401,402]},"
operator|+
literal|"{'id':'myid5'},"
operator|+
literal|"{'id':'myid6','test_s_dvo':'hello'}"
operator|+
literal|"]"
argument_list|)
expr_stmt|;
block|}
DECL|method|testManagedSchema
specifier|public
name|void
name|testManagedSchema
parameter_list|()
throws|throws
name|Exception
block|{
name|IndexSchema
name|oldSchema
init|=
name|h
operator|.
name|getCore
argument_list|()
operator|.
name|getLatestSchema
argument_list|()
decl_stmt|;
name|StrField
name|type
init|=
operator|new
name|StrField
argument_list|()
decl_stmt|;
name|type
operator|.
name|setTypeName
argument_list|(
literal|"str"
argument_list|)
expr_stmt|;
name|SchemaField
name|falseDVASField
init|=
operator|new
name|SchemaField
argument_list|(
literal|"false_dvas"
argument_list|,
name|type
argument_list|,
name|SchemaField
operator|.
name|INDEXED
operator||
name|SchemaField
operator|.
name|DOC_VALUES
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|SchemaField
name|trueDVASField
init|=
operator|new
name|SchemaField
argument_list|(
literal|"true_dvas"
argument_list|,
name|type
argument_list|,
name|SchemaField
operator|.
name|INDEXED
operator||
name|SchemaField
operator|.
name|DOC_VALUES
operator||
name|SchemaField
operator|.
name|USE_DOCVALUES_AS_STORED
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|IndexSchema
name|newSchema
init|=
name|oldSchema
operator|.
name|addField
argument_list|(
name|falseDVASField
argument_list|)
operator|.
name|addField
argument_list|(
name|trueDVASField
argument_list|)
decl_stmt|;
name|h
operator|.
name|getCore
argument_list|()
operator|.
name|setLatestSchema
argument_list|(
name|newSchema
argument_list|)
expr_stmt|;
name|clearIndex
argument_list|()
expr_stmt|;
name|assertU
argument_list|(
name|adoc
argument_list|(
literal|"id"
argument_list|,
literal|"myid1"
argument_list|,
literal|"false_dvas"
argument_list|,
literal|"101"
argument_list|,
literal|"true_dvas"
argument_list|,
literal|"102"
argument_list|)
argument_list|)
expr_stmt|;
name|assertU
argument_list|(
name|commit
argument_list|()
argument_list|)
expr_stmt|;
name|assertJQ
argument_list|(
name|req
argument_list|(
literal|"q"
argument_list|,
literal|"id:myid*"
argument_list|,
literal|"fl"
argument_list|,
literal|"*"
argument_list|)
argument_list|,
literal|"/response/docs==["
operator|+
literal|"{'id':'myid1', 'true_dvas':'102'}]"
argument_list|)
expr_stmt|;
block|}
DECL|method|doTest
specifier|private
name|void
name|doTest
parameter_list|(
name|String
name|desc
parameter_list|,
name|String
name|field
parameter_list|,
name|String
name|type
parameter_list|,
name|String
modifier|...
name|value
parameter_list|)
block|{
name|String
name|id
init|=
literal|""
operator|+
name|this
operator|.
name|id
operator|++
decl_stmt|;
name|String
index|[]
name|xpaths
init|=
operator|new
name|String
index|[
name|value
operator|.
name|length
operator|+
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|value
operator|.
name|length
operator|>
literal|1
condition|)
block|{
name|Set
argument_list|<
name|String
argument_list|>
name|valueSet
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
name|valueSet
operator|.
name|addAll
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|String
index|[]
name|fieldAndValues
init|=
operator|new
name|String
index|[
name|value
operator|.
name|length
operator|*
literal|2
operator|+
literal|2
index|]
decl_stmt|;
name|fieldAndValues
index|[
literal|0
index|]
operator|=
literal|"id"
expr_stmt|;
name|fieldAndValues
index|[
literal|1
index|]
operator|=
name|id
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|value
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
name|fieldAndValues
index|[
name|i
operator|*
literal|2
operator|+
literal|2
index|]
operator|=
name|field
expr_stmt|;
name|fieldAndValues
index|[
name|i
operator|*
literal|2
operator|+
literal|3
index|]
operator|=
name|value
index|[
name|i
index|]
expr_stmt|;
name|xpaths
index|[
name|i
index|]
operator|=
literal|"//arr[@name='"
operator|+
name|field
operator|+
literal|"']/"
operator|+
name|type
operator|+
literal|"[.='"
operator|+
name|value
index|[
name|i
index|]
operator|+
literal|"']"
expr_stmt|;
block|}
comment|// Docvalues are sets, but stored values are ordered multisets, so cardinality depends on the value source
name|xpaths
index|[
name|value
operator|.
name|length
index|]
operator|=
literal|"*[count(//arr[@name='"
operator|+
name|field
operator|+
literal|"']/"
operator|+
name|type
operator|+
literal|") = "
operator|+
operator|(
name|isStoredField
argument_list|(
name|field
argument_list|)
condition|?
name|value
operator|.
name|length
else|:
name|valueSet
operator|.
name|size
argument_list|()
operator|)
operator|+
literal|"]"
expr_stmt|;
name|assertU
argument_list|(
name|adoc
argument_list|(
name|fieldAndValues
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|assertU
argument_list|(
name|adoc
argument_list|(
literal|"id"
argument_list|,
name|id
argument_list|,
name|field
argument_list|,
name|value
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|xpaths
index|[
literal|0
index|]
operator|=
literal|"//"
operator|+
name|type
operator|+
literal|"[@name='"
operator|+
name|field
operator|+
literal|"'][.='"
operator|+
name|value
index|[
literal|0
index|]
operator|+
literal|"']"
expr_stmt|;
name|xpaths
index|[
literal|1
index|]
operator|=
literal|"*[count(//"
operator|+
name|type
operator|+
literal|"[@name='"
operator|+
name|field
operator|+
literal|"']) = 1]"
expr_stmt|;
block|}
name|assertU
argument_list|(
name|commit
argument_list|()
argument_list|)
expr_stmt|;
name|String
name|fl
init|=
name|field
decl_stmt|;
name|assertQ
argument_list|(
name|desc
operator|+
literal|": "
operator|+
name|fl
argument_list|,
name|req
argument_list|(
literal|"q"
argument_list|,
literal|"id:"
operator|+
name|id
argument_list|,
literal|"fl"
argument_list|,
name|fl
argument_list|)
argument_list|,
name|xpaths
argument_list|)
expr_stmt|;
name|fl
operator|=
name|field
operator|+
literal|",*"
expr_stmt|;
name|assertQ
argument_list|(
name|desc
operator|+
literal|": "
operator|+
name|fl
argument_list|,
name|req
argument_list|(
literal|"q"
argument_list|,
literal|"id:"
operator|+
name|id
argument_list|,
literal|"fl"
argument_list|,
name|fl
argument_list|)
argument_list|,
name|xpaths
argument_list|)
expr_stmt|;
name|fl
operator|=
literal|"*"
operator|+
name|field
operator|.
name|substring
argument_list|(
name|field
operator|.
name|length
argument_list|()
operator|-
literal|3
argument_list|)
expr_stmt|;
name|assertQ
argument_list|(
name|desc
operator|+
literal|": "
operator|+
name|fl
argument_list|,
name|req
argument_list|(
literal|"q"
argument_list|,
literal|"id:"
operator|+
name|id
argument_list|,
literal|"fl"
argument_list|,
name|fl
argument_list|)
argument_list|,
name|xpaths
argument_list|)
expr_stmt|;
name|fl
operator|=
literal|"*"
expr_stmt|;
name|assertQ
argument_list|(
name|desc
operator|+
literal|": "
operator|+
name|fl
argument_list|,
name|req
argument_list|(
literal|"q"
argument_list|,
literal|"id:"
operator|+
name|id
argument_list|,
literal|"fl"
argument_list|,
name|fl
argument_list|)
argument_list|,
name|xpaths
argument_list|)
expr_stmt|;
name|fl
operator|=
name|field
operator|+
literal|",fakeFieldName"
expr_stmt|;
name|assertQ
argument_list|(
name|desc
operator|+
literal|": "
operator|+
name|fl
argument_list|,
name|req
argument_list|(
literal|"q"
argument_list|,
literal|"id:"
operator|+
name|id
argument_list|,
literal|"fl"
argument_list|,
name|fl
argument_list|)
argument_list|,
name|xpaths
argument_list|)
expr_stmt|;
name|fl
operator|=
literal|"*"
expr_stmt|;
name|assertQ
argument_list|(
name|desc
operator|+
literal|": "
operator|+
name|fl
argument_list|,
name|req
argument_list|(
literal|"q"
argument_list|,
literal|"*:*"
argument_list|,
literal|"fl"
argument_list|,
name|fl
argument_list|)
argument_list|,
name|xpaths
argument_list|)
expr_stmt|;
block|}
comment|// See SOLR-8740 for a discussion. This test is here to make sure we consciously change behavior of multiValued
comment|// fields given that we can now return docValues fields. The behavior we've guaranteed in the past is that if
comment|// multiValued fields are stored, they're returned in the document in the order they were added.
comment|// There are four new fieldTypes added:
comment|//<field name="test_mvt_dvt_st_str" type="string" indexed="true" multiValued="true" docValues="true"  stored="true"/>
comment|//<field name="test_mvt_dvt_sf_str" type="string" indexed="true" multiValued="true" docValues="true"  stored="false"/>
comment|//<field name="test_mvt_dvf_st_str" type="string" indexed="true" multiValued="true" docValues="false" stored="true"/>
comment|//<field name="test_mvt_dvu_st_str" type="string" indexed="true" multiValued="true"                   stored="true"/>
comment|//
comment|// If any of these tests break as a result of returning DocValues rather than stored values, make sure we reach some
comment|// consensus that any breaks on back-compat are A Good Thing and that that behavior is carefully documented!
annotation|@
name|Test
DECL|method|testMultivaluedOrdering
specifier|public
name|void
name|testMultivaluedOrdering
parameter_list|()
throws|throws
name|Exception
block|{
name|clearIndex
argument_list|()
expr_stmt|;
comment|// multiValued=true, docValues=true, stored=true. Should return in original order
name|assertU
argument_list|(
name|adoc
argument_list|(
literal|"id"
argument_list|,
literal|"1"
argument_list|,
literal|"test_mvt_dvt_st_str"
argument_list|,
literal|"cccc"
argument_list|,
literal|"test_mvt_dvt_st_str"
argument_list|,
literal|"aaaa"
argument_list|,
literal|"test_mvt_dvt_st_str"
argument_list|,
literal|"bbbb"
argument_list|)
argument_list|)
expr_stmt|;
comment|// multiValued=true, docValues=true, stored=false. Should return in sorted order
name|assertU
argument_list|(
name|adoc
argument_list|(
literal|"id"
argument_list|,
literal|"2"
argument_list|,
literal|"test_mvt_dvt_sf_str"
argument_list|,
literal|"cccc"
argument_list|,
literal|"test_mvt_dvt_sf_str"
argument_list|,
literal|"aaaa"
argument_list|,
literal|"test_mvt_dvt_sf_str"
argument_list|,
literal|"bbbb"
argument_list|)
argument_list|)
expr_stmt|;
comment|// multiValued=true, docValues=false, stored=true. Should return in original order
name|assertU
argument_list|(
name|adoc
argument_list|(
literal|"id"
argument_list|,
literal|"3"
argument_list|,
literal|"test_mvt_dvf_st_str"
argument_list|,
literal|"cccc"
argument_list|,
literal|"test_mvt_dvf_st_str"
argument_list|,
literal|"aaaa"
argument_list|,
literal|"test_mvt_dvf_st_str"
argument_list|,
literal|"bbbb"
argument_list|)
argument_list|)
expr_stmt|;
comment|// multiValued=true, docValues=not specified, stored=true. Should return in original order
name|assertU
argument_list|(
name|adoc
argument_list|(
literal|"id"
argument_list|,
literal|"4"
argument_list|,
literal|"test_mvt_dvu_st_str"
argument_list|,
literal|"cccc"
argument_list|,
literal|"test_mvt_dvu_st_str"
argument_list|,
literal|"aaaa"
argument_list|,
literal|"test_mvt_dvu_st_str"
argument_list|,
literal|"bbbb"
argument_list|)
argument_list|)
expr_stmt|;
name|assertU
argument_list|(
name|commit
argument_list|()
argument_list|)
expr_stmt|;
name|assertJQ
argument_list|(
name|req
argument_list|(
literal|"q"
argument_list|,
literal|"id:1"
argument_list|,
literal|"fl"
argument_list|,
literal|"test_mvt_dvt_st_str"
argument_list|)
argument_list|,
literal|"/response/docs/[0]/test_mvt_dvt_st_str/[0]==cccc"
argument_list|,
literal|"/response/docs/[0]/test_mvt_dvt_st_str/[1]==aaaa"
argument_list|,
literal|"/response/docs/[0]/test_mvt_dvt_st_str/[2]==bbbb"
argument_list|)
expr_stmt|;
comment|// Currently, this test fails since stored=false. When SOLR-8740 is committed, it should not throw an exception
comment|// and should succeed, returning the field in sorted order.
try|try
block|{
name|assertJQ
argument_list|(
name|req
argument_list|(
literal|"q"
argument_list|,
literal|"id:2"
argument_list|,
literal|"fl"
argument_list|,
literal|"test_mvt_dvt_sf_str"
argument_list|)
argument_list|,
literal|"/response/docs/[0]/test_mvt_dvt_sf_str/[0]==aaaa"
argument_list|,
literal|"/response/docs/[0]/test_mvt_dvt_sf_str/[1]==bbbb"
argument_list|,
literal|"/response/docs/[0]/test_mvt_dvt_sf_str/[2]==cccc"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
comment|// do nothing until SOLR-8740 is committed. At that point this should not throw an exception.
comment|// NOTE: I think the test is correct after 8740 so just remove the try/catch
block|}
name|assertJQ
argument_list|(
name|req
argument_list|(
literal|"q"
argument_list|,
literal|"id:3"
argument_list|,
literal|"fl"
argument_list|,
literal|"test_mvt_dvf_st_str"
argument_list|)
argument_list|,
literal|"/response/docs/[0]/test_mvt_dvf_st_str/[0]==cccc"
argument_list|,
literal|"/response/docs/[0]/test_mvt_dvf_st_str/[1]==aaaa"
argument_list|,
literal|"/response/docs/[0]/test_mvt_dvf_st_str/[2]==bbbb"
argument_list|)
expr_stmt|;
name|assertJQ
argument_list|(
name|req
argument_list|(
literal|"q"
argument_list|,
literal|"id:4"
argument_list|,
literal|"fl"
argument_list|,
literal|"test_mvt_dvu_st_str"
argument_list|)
argument_list|,
literal|"/response/docs/[0]/test_mvt_dvu_st_str/[0]==cccc"
argument_list|,
literal|"/response/docs/[0]/test_mvt_dvu_st_str/[1]==aaaa"
argument_list|,
literal|"/response/docs/[0]/test_mvt_dvu_st_str/[2]==bbbb"
argument_list|)
expr_stmt|;
block|}
block|}
end_class
end_unit
