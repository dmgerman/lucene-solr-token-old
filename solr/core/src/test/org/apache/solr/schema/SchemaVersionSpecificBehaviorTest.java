begin_unit
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_package
DECL|package|org.apache.solr.schema
package|package
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|schema
package|;
end_package
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|SolrTestCaseJ4
import|;
end_import
begin_class
DECL|class|SchemaVersionSpecificBehaviorTest
specifier|public
class|class
name|SchemaVersionSpecificBehaviorTest
extends|extends
name|SolrTestCaseJ4
block|{
DECL|method|testVersionBehavior
specifier|public
name|void
name|testVersionBehavior
parameter_list|()
throws|throws
name|Exception
block|{
for|for
control|(
name|float
name|v
range|:
operator|new
name|float
index|[]
block|{
literal|1.0F
block|,
literal|1.1F
block|,
literal|1.2F
block|,
literal|1.3F
block|,
literal|1.4F
block|,
literal|1.5F
block|,
literal|1.6F
block|}
control|)
block|{
try|try
block|{
specifier|final
name|IndexSchema
name|schema
init|=
name|initCoreUsingSchemaVersion
argument_list|(
name|v
argument_list|)
decl_stmt|;
specifier|final
name|String
name|ver
init|=
name|String
operator|.
name|valueOf
argument_list|(
name|v
argument_list|)
decl_stmt|;
comment|// check defaults for fields where neither the field nor the field type
comment|// have any properties set on them
for|for
control|(
name|String
name|f
range|:
operator|new
name|String
index|[]
block|{
literal|"text"
block|,
literal|"xx_dyn_text"
block|,
literal|"bool"
block|,
literal|"xx_dyn_bool"
block|,
literal|"str"
block|,
literal|"xx_dyn_str"
block|,
literal|"int"
block|,
literal|"xx_dyn_int"
block|}
control|)
block|{
name|SchemaField
name|field
init|=
name|schema
operator|.
name|getField
argument_list|(
name|f
argument_list|)
decl_stmt|;
comment|// 1.1: multiValued default changed
name|assertEquals
argument_list|(
name|f
operator|+
literal|" field's multiValued is wrong for ver="
operator|+
name|ver
argument_list|,
operator|(
name|v
operator|<
literal|1.1F
operator|)
argument_list|,
name|field
operator|.
name|multiValued
argument_list|()
argument_list|)
expr_stmt|;
comment|// 1.2: omitTermFreqAndPositions default changed
comment|// to true for non TextField
name|assertEquals
argument_list|(
name|f
operator|+
literal|" field's type has wrong omitTfP for ver="
operator|+
name|ver
argument_list|,
operator|(
name|v
operator|<
literal|1.2F
condition|?
literal|false
else|:
operator|!
operator|(
name|field
operator|.
name|getType
argument_list|()
operator|instanceof
name|TextField
operator|)
operator|)
argument_list|,
name|field
operator|.
name|omitTermFreqAndPositions
argument_list|()
argument_list|)
expr_stmt|;
comment|// 1.4: autoGeneratePhraseQueries default changed to false
if|if
condition|(
name|field
operator|.
name|getType
argument_list|()
operator|instanceof
name|TextField
condition|)
block|{
name|TextField
name|ft
init|=
operator|(
name|TextField
operator|)
name|field
operator|.
name|getType
argument_list|()
decl_stmt|;
name|assertEquals
argument_list|(
name|f
operator|+
literal|" field's autoPhrase is wrong for ver="
operator|+
name|ver
argument_list|,
operator|(
name|v
operator|<
literal|1.4F
operator|)
argument_list|,
name|ft
operator|.
name|getAutoGeneratePhraseQueries
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// 1.5: omitNorms default changed to true for non TextField
name|assertEquals
argument_list|(
name|f
operator|+
literal|" field's type has wrong omitNorm for ver="
operator|+
name|ver
argument_list|,
operator|(
name|v
operator|<
literal|1.5F
condition|?
literal|false
else|:
operator|!
operator|(
name|field
operator|.
name|getType
argument_list|()
operator|instanceof
name|TextField
operator|)
operator|)
argument_list|,
name|field
operator|.
name|omitNorms
argument_list|()
argument_list|)
expr_stmt|;
comment|// 1.6: useDocValuesAsStored defaults to true
name|assertEquals
argument_list|(
name|f
operator|+
literal|" field's type has wrong useDocValuesAsStored for ver="
operator|+
name|ver
argument_list|,
operator|(
name|v
operator|<
literal|1.6F
condition|?
literal|false
else|:
literal|true
operator|)
argument_list|,
name|field
operator|.
name|useDocValuesAsStored
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// regardless of version, explicit multiValued values on field or type
comment|// should be correct
for|for
control|(
name|String
name|f
range|:
operator|new
name|String
index|[]
block|{
literal|"multi_f"
block|,
literal|"multi_t"
block|,
literal|"ft_multi_f"
block|,
literal|"ft_multi_t"
block|,
literal|"xx_dyn_str_multi_f"
block|,
literal|"xx_dyn_str_multi_t"
block|,
literal|"xx_dyn_str_ft_multi_f"
block|,
literal|"xx_dyn_str_ft_multi_t"
block|}
control|)
block|{
name|boolean
name|expected
init|=
name|f
operator|.
name|endsWith
argument_list|(
literal|"multi_t"
argument_list|)
decl_stmt|;
name|SchemaField
name|field
init|=
name|schema
operator|.
name|getField
argument_list|(
name|f
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|f
operator|+
literal|" field's multiValued is wrong for ver="
operator|+
name|ver
argument_list|,
name|expected
argument_list|,
name|field
operator|.
name|multiValued
argument_list|()
argument_list|)
expr_stmt|;
name|FieldType
name|ft
init|=
name|field
operator|.
name|getType
argument_list|()
decl_stmt|;
if|if
condition|(
name|f
operator|.
name|contains
argument_list|(
literal|"ft_multi"
argument_list|)
condition|)
block|{
comment|// sanity check that we really are inheriting from fieldtype
name|assertEquals
argument_list|(
name|f
operator|+
literal|" field's multiValued doesn't match type for ver="
operator|+
name|ver
argument_list|,
name|expected
argument_list|,
name|ft
operator|.
name|isMultiValued
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// for fields where the property is explicit, make sure
comment|// we aren't getting a false negative because someone changed the
comment|// schema and we're inheriting from fieldType
name|assertEquals
argument_list|(
name|f
operator|+
literal|" field's type has wrong multiValued is wrong for ver="
operator|+
name|ver
argument_list|,
operator|(
name|v
operator|<
literal|1.1F
operator|)
argument_list|,
name|ft
operator|.
name|isMultiValued
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|// regardless of version, explicit useDocValuesAsStored values on field or type
comment|// should be correct
for|for
control|(
name|String
name|f
range|:
operator|new
name|String
index|[]
block|{
literal|"ft_intdvas_f"
block|,
literal|"ft_intdvas_t"
block|,
literal|"intdvas_f"
block|,
literal|"intdvas_t"
block|,
literal|"xx_dyn_ft_intdvas_f"
block|,
literal|"xx_dyn_ft_intdvas_f"
block|,
literal|"xx_dyn_intdvas_f"
block|,
literal|"xx_dyn_intdvas_f"
block|}
control|)
block|{
name|boolean
name|expected
init|=
name|f
operator|.
name|endsWith
argument_list|(
literal|"dvas_t"
argument_list|)
decl_stmt|;
name|SchemaField
name|field
init|=
name|schema
operator|.
name|getField
argument_list|(
name|f
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|f
operator|+
literal|" field's useDocValuesAsStored is wrong for ver="
operator|+
name|ver
argument_list|,
name|expected
argument_list|,
name|field
operator|.
name|useDocValuesAsStored
argument_list|()
argument_list|)
expr_stmt|;
name|FieldType
name|ft
init|=
name|field
operator|.
name|getType
argument_list|()
decl_stmt|;
if|if
condition|(
name|f
operator|.
name|contains
argument_list|(
literal|"ft_"
argument_list|)
condition|)
block|{
comment|// sanity check that we really are inheriting from fieldtype
name|assertEquals
argument_list|(
name|f
operator|+
literal|" field's omitTfP doesn't match type for ver="
operator|+
name|ver
argument_list|,
name|expected
argument_list|,
name|ft
operator|.
name|hasProperty
argument_list|(
name|FieldType
operator|.
name|USE_DOCVALUES_AS_STORED
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// for fields where the property is explicit, make sure
comment|// we aren't getting a false negative because someone changed the
comment|// schema and we're inheriting from fieldType
name|assertEquals
argument_list|(
name|f
operator|+
literal|" field's type has wrong useDocValuesAsStored for ver="
operator|+
name|ver
argument_list|,
operator|(
name|v
operator|<
literal|1.6F
condition|?
literal|false
else|:
literal|true
operator|)
argument_list|,
name|ft
operator|.
name|hasProperty
argument_list|(
name|FieldType
operator|.
name|USE_DOCVALUES_AS_STORED
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|// regardless of version, explicit omitTfP values on field or type
comment|// should be correct
for|for
control|(
name|String
name|f
range|:
operator|new
name|String
index|[]
block|{
literal|"strTfP_f"
block|,
literal|"strTfP_t"
block|,
literal|"txtTfP_f"
block|,
literal|"txtTfP_t"
block|,
literal|"ft_strTfP_f"
block|,
literal|"ft_strTfP_t"
block|,
literal|"ft_txtTfP_f"
block|,
literal|"ft_txtTfP_t"
block|,
literal|"xx_dyn_strTfP_f"
block|,
literal|"xx_dyn_strTfP_t"
block|,
literal|"xx_dyn_txtTfP_f"
block|,
literal|"xx_dyn_txtTfP_t"
block|,
literal|"xx_dyn_ft_strTfP_f"
block|,
literal|"xx_dyn_ft_strTfP_t"
block|,
literal|"xx_dyn_ft_txtTfP_f"
block|,
literal|"xx_dyn_ft_txtTfP_t"
block|}
control|)
block|{
name|boolean
name|expected
init|=
name|f
operator|.
name|endsWith
argument_list|(
literal|"TfP_t"
argument_list|)
decl_stmt|;
name|SchemaField
name|field
init|=
name|schema
operator|.
name|getField
argument_list|(
name|f
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|f
operator|+
literal|" field's omitTfP is wrong for ver="
operator|+
name|ver
argument_list|,
name|expected
argument_list|,
name|field
operator|.
name|omitTermFreqAndPositions
argument_list|()
argument_list|)
expr_stmt|;
name|FieldType
name|ft
init|=
name|field
operator|.
name|getType
argument_list|()
decl_stmt|;
if|if
condition|(
name|f
operator|.
name|contains
argument_list|(
literal|"ft_"
argument_list|)
condition|)
block|{
comment|// sanity check that we really are inheriting from fieldtype
name|assertEquals
argument_list|(
name|f
operator|+
literal|" field's omitTfP doesn't match type for ver="
operator|+
name|ver
argument_list|,
name|expected
argument_list|,
name|ft
operator|.
name|hasProperty
argument_list|(
name|FieldType
operator|.
name|OMIT_TF_POSITIONS
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// for fields where the property is explicit, make sure
comment|// we aren't getting a false negative because someone changed the
comment|// schema and we're inheriting from fieldType
name|assertEquals
argument_list|(
name|f
operator|+
literal|" field's type has wrong omitTfP for ver="
operator|+
name|ver
argument_list|,
operator|(
name|v
operator|<
literal|1.2F
condition|?
literal|false
else|:
operator|!
operator|(
name|field
operator|.
name|getType
argument_list|()
operator|instanceof
name|TextField
operator|)
operator|)
argument_list|,
name|ft
operator|.
name|hasProperty
argument_list|(
name|FieldType
operator|.
name|OMIT_TF_POSITIONS
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|// regardless of version, explicit autophrase values on type
comment|// should be correct
for|for
control|(
name|String
name|f
range|:
operator|new
name|String
index|[]
block|{
literal|"ft_txt_phrase_f"
block|,
literal|"ft_txt_phrase_t"
block|,
literal|"xx_dyn_ft_txt_phrase_f"
block|,
literal|"xx_dyn_ft_txt_phrase_t"
block|}
control|)
block|{
name|boolean
name|expected
init|=
name|f
operator|.
name|endsWith
argument_list|(
literal|"phrase_t"
argument_list|)
decl_stmt|;
name|FieldType
name|ft
init|=
name|schema
operator|.
name|getFieldType
argument_list|(
name|f
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
literal|"broken test, assert only valid on text fields: "
operator|+
name|f
argument_list|,
name|ft
operator|instanceof
name|TextField
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|f
operator|+
literal|" field's autophrase is wrong for ver="
operator|+
name|ver
argument_list|,
name|expected
argument_list|,
operator|(
operator|(
name|TextField
operator|)
name|ft
operator|)
operator|.
name|getAutoGeneratePhraseQueries
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// regardless of version, explicit multiValued values on field or type
comment|// should be correct
for|for
control|(
name|String
name|f
range|:
operator|new
name|String
index|[]
block|{
literal|"strnorm_f"
block|,
literal|"strnorm_t"
block|,
literal|"txtnorm_f"
block|,
literal|"txtnorm_t"
block|,
literal|"ft_strnorm_f"
block|,
literal|"ft_strnorm_t"
block|,
literal|"ft_txtnorm_f"
block|,
literal|"ft_txtnorm_t"
block|,
literal|"xx_dyn_strnorm_f"
block|,
literal|"xx_dyn_strnorm_t"
block|,
literal|"xx_dyn_txtnorm_f"
block|,
literal|"xx_dyn_txtnorm_t"
block|,
literal|"xx_dyn_ft_strnorm_f"
block|,
literal|"xx_dyn_ft_strnorm_t"
block|,
literal|"xx_dyn_ft_txtnorm_f"
block|,
literal|"xx_dyn_ft_txtnorm_t"
block|}
control|)
block|{
name|boolean
name|expected
init|=
name|f
operator|.
name|endsWith
argument_list|(
literal|"norm_t"
argument_list|)
decl_stmt|;
name|SchemaField
name|field
init|=
name|schema
operator|.
name|getField
argument_list|(
name|f
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|f
operator|+
literal|" field's omitNorm is wrong for ver="
operator|+
name|ver
argument_list|,
name|expected
argument_list|,
name|field
operator|.
name|omitNorms
argument_list|()
argument_list|)
expr_stmt|;
name|FieldType
name|ft
init|=
name|field
operator|.
name|getType
argument_list|()
decl_stmt|;
if|if
condition|(
name|f
operator|.
name|contains
argument_list|(
literal|"ft_"
argument_list|)
condition|)
block|{
comment|// sanity check that we really are inheriting from fieldtype
name|assertEquals
argument_list|(
name|f
operator|+
literal|" field's omitNorm doesn't match type for ver="
operator|+
name|ver
argument_list|,
name|expected
argument_list|,
name|ft
operator|.
name|hasProperty
argument_list|(
name|FieldType
operator|.
name|OMIT_NORMS
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// for fields where the property is explicit, make sure
comment|// we aren't getting a false negative because someone changed the
comment|// schema and we're inheriting from fieldType
name|assertEquals
argument_list|(
name|f
operator|+
literal|" field's type has wrong omitNorm for ver="
operator|+
name|ver
argument_list|,
operator|(
name|v
operator|<
literal|1.5F
condition|?
literal|false
else|:
operator|!
operator|(
name|field
operator|.
name|getType
argument_list|()
operator|instanceof
name|TextField
operator|)
operator|)
argument_list|,
name|ft
operator|.
name|hasProperty
argument_list|(
name|FieldType
operator|.
name|OMIT_NORMS
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
finally|finally
block|{
name|deleteCore
argument_list|()
expr_stmt|;
block|}
block|}
block|}
DECL|method|initCoreUsingSchemaVersion
specifier|public
name|IndexSchema
name|initCoreUsingSchemaVersion
parameter_list|(
specifier|final
name|float
name|ver
parameter_list|)
throws|throws
name|Exception
block|{
try|try
block|{
name|System
operator|.
name|setProperty
argument_list|(
literal|"solr.schema.test.ver"
argument_list|,
name|String
operator|.
name|valueOf
argument_list|(
name|ver
argument_list|)
argument_list|)
expr_stmt|;
name|initCore
argument_list|(
literal|"solrconfig-basic.xml"
argument_list|,
literal|"schema-behavior.xml"
argument_list|)
expr_stmt|;
name|IndexSchema
name|s
init|=
name|h
operator|.
name|getCore
argument_list|()
operator|.
name|getLatestSchema
argument_list|()
decl_stmt|;
name|assertEquals
argument_list|(
literal|"Schema version not set correctly"
argument_list|,
name|String
operator|.
name|valueOf
argument_list|(
name|ver
argument_list|)
argument_list|,
name|String
operator|.
name|valueOf
argument_list|(
name|s
operator|.
name|getVersion
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
finally|finally
block|{
name|System
operator|.
name|clearProperty
argument_list|(
literal|"solr.schema.test.ver"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_class
end_unit
