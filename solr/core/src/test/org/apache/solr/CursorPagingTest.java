begin_unit
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_package
DECL|package|org.apache.solr
package|package
name|org
operator|.
name|apache
operator|.
name|solr
package|;
end_package
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|TestUtil
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|SentinelIntSet
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|mutable
operator|.
name|MutableValueInt
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|core
operator|.
name|SolrInfoMBean
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|SolrInputDocument
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|params
operator|.
name|CursorMarkParams
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|params
operator|.
name|SolrParams
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|params
operator|.
name|CommonParams
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|params
operator|.
name|GroupParams
import|;
end_import
begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|params
operator|.
name|CursorMarkParams
operator|.
name|CURSOR_MARK_PARAM
import|;
end_import
begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|params
operator|.
name|CursorMarkParams
operator|.
name|CURSOR_MARK_NEXT
import|;
end_import
begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|params
operator|.
name|CursorMarkParams
operator|.
name|CURSOR_MARK_START
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|SolrException
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|SolrException
operator|.
name|ErrorCode
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|request
operator|.
name|SolrQueryRequest
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|search
operator|.
name|CursorMark
import|;
end_import
begin_comment
comment|//jdoc
end_comment
begin_import
import|import
name|org
operator|.
name|noggit
operator|.
name|ObjectBuilder
import|;
end_import
begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|ByteBuffer
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|UUID
import|;
end_import
begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|BeforeClass
import|;
end_import
begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|After
import|;
end_import
begin_comment
comment|/**  * Tests of deep paging using {@link CursorMark} and {@link CursorMarkParams#CURSOR_MARK_PARAM}.  */
end_comment
begin_class
DECL|class|CursorPagingTest
specifier|public
class|class
name|CursorPagingTest
extends|extends
name|SolrTestCaseJ4
block|{
comment|/** solrconfig.xml file name, shared with other cursor related tests */
DECL|field|TEST_SOLRCONFIG_NAME
specifier|public
specifier|final
specifier|static
name|String
name|TEST_SOLRCONFIG_NAME
init|=
literal|"solrconfig-deeppaging.xml"
decl_stmt|;
comment|/** schema.xml file name, shared with other cursor related tests */
DECL|field|TEST_SCHEMAXML_NAME
specifier|public
specifier|final
specifier|static
name|String
name|TEST_SCHEMAXML_NAME
init|=
literal|"schema-sorts.xml"
decl_stmt|;
comment|/** values from enumConfig.xml */
DECL|field|SEVERITY_ENUM_VALUES
specifier|public
specifier|static
specifier|final
name|String
index|[]
name|SEVERITY_ENUM_VALUES
init|=
block|{
literal|"Not Available"
block|,
literal|"Low"
block|,
literal|"Medium"
block|,
literal|"High"
block|,
literal|"Critical"
block|}
decl_stmt|;
annotation|@
name|BeforeClass
DECL|method|beforeTests
specifier|public
specifier|static
name|void
name|beforeTests
parameter_list|()
throws|throws
name|Exception
block|{
name|System
operator|.
name|setProperty
argument_list|(
literal|"solr.test.useFilterForSortedQuery"
argument_list|,
name|Boolean
operator|.
name|toString
argument_list|(
name|random
argument_list|()
operator|.
name|nextBoolean
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|initCore
argument_list|(
name|TEST_SOLRCONFIG_NAME
argument_list|,
name|TEST_SCHEMAXML_NAME
argument_list|)
expr_stmt|;
block|}
annotation|@
name|After
DECL|method|cleanup
specifier|public
name|void
name|cleanup
parameter_list|()
throws|throws
name|Exception
block|{
name|assertU
argument_list|(
name|delQ
argument_list|(
literal|"*:*"
argument_list|)
argument_list|)
expr_stmt|;
name|assertU
argument_list|(
name|commit
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/** verify expected error msgs from bad client behavior */
DECL|method|testBadInputs
specifier|public
name|void
name|testBadInputs
parameter_list|()
throws|throws
name|Exception
block|{
comment|// sometimes seed some data, othertimes use an empty index
if|if
condition|(
name|random
argument_list|()
operator|.
name|nextBoolean
argument_list|()
condition|)
block|{
name|assertU
argument_list|(
name|adoc
argument_list|(
literal|"id"
argument_list|,
literal|"42"
argument_list|,
literal|"str"
argument_list|,
literal|"z"
argument_list|,
literal|"float"
argument_list|,
literal|"99.99"
argument_list|,
literal|"int"
argument_list|,
literal|"42"
argument_list|)
argument_list|)
expr_stmt|;
name|assertU
argument_list|(
name|adoc
argument_list|(
literal|"id"
argument_list|,
literal|"66"
argument_list|,
literal|"str"
argument_list|,
literal|"x"
argument_list|,
literal|"float"
argument_list|,
literal|"22.00"
argument_list|,
literal|"int"
argument_list|,
literal|"-66"
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|assertU
argument_list|(
name|commit
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|assertU
argument_list|(
name|commit
argument_list|()
argument_list|)
expr_stmt|;
comment|// empty, blank, or bogus cursor
for|for
control|(
name|String
name|c
range|:
operator|new
name|String
index|[]
block|{
literal|""
block|,
literal|"   "
block|,
literal|"all the docs please!"
block|}
control|)
block|{
name|assertFail
argument_list|(
name|params
argument_list|(
literal|"q"
argument_list|,
literal|"*:*"
argument_list|,
literal|"sort"
argument_list|,
literal|"id desc"
argument_list|,
name|CURSOR_MARK_PARAM
argument_list|,
name|c
argument_list|)
argument_list|,
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
literal|"Unable to parse"
argument_list|)
expr_stmt|;
block|}
comment|// no id in sort
name|assertFail
argument_list|(
name|params
argument_list|(
literal|"q"
argument_list|,
literal|"*:*"
argument_list|,
literal|"sort"
argument_list|,
literal|"score desc"
argument_list|,
name|CURSOR_MARK_PARAM
argument_list|,
name|CURSOR_MARK_START
argument_list|)
argument_list|,
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
literal|"uniqueKey field"
argument_list|)
expr_stmt|;
comment|// _docid_
name|assertFail
argument_list|(
name|params
argument_list|(
literal|"q"
argument_list|,
literal|"*:*"
argument_list|,
literal|"sort"
argument_list|,
literal|"_docid_ asc, id desc"
argument_list|,
name|CURSOR_MARK_PARAM
argument_list|,
name|CURSOR_MARK_START
argument_list|)
argument_list|,
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
literal|"_docid_"
argument_list|)
expr_stmt|;
comment|// using cursor w/ timeAllowed
name|assertFail
argument_list|(
name|params
argument_list|(
literal|"q"
argument_list|,
literal|"*:*"
argument_list|,
literal|"sort"
argument_list|,
literal|"id desc"
argument_list|,
name|CommonParams
operator|.
name|TIME_ALLOWED
argument_list|,
literal|"1000"
argument_list|,
name|CURSOR_MARK_PARAM
argument_list|,
name|CURSOR_MARK_START
argument_list|)
argument_list|,
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
name|CommonParams
operator|.
name|TIME_ALLOWED
argument_list|)
expr_stmt|;
comment|// using cursor w/ grouping
name|assertFail
argument_list|(
name|params
argument_list|(
literal|"q"
argument_list|,
literal|"*:*"
argument_list|,
literal|"sort"
argument_list|,
literal|"id desc"
argument_list|,
name|GroupParams
operator|.
name|GROUP
argument_list|,
literal|"true"
argument_list|,
name|GroupParams
operator|.
name|GROUP_FIELD
argument_list|,
literal|"str"
argument_list|,
name|CURSOR_MARK_PARAM
argument_list|,
name|CURSOR_MARK_START
argument_list|)
argument_list|,
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
literal|"Grouping"
argument_list|)
expr_stmt|;
block|}
comment|/** simple static test of some carefully crafted docs */
DECL|method|testSimple
specifier|public
name|void
name|testSimple
parameter_list|()
throws|throws
name|Exception
block|{
name|String
name|cursorMark
decl_stmt|;
name|SolrParams
name|params
init|=
literal|null
decl_stmt|;
specifier|final
name|String
name|intsort
init|=
literal|"int"
operator|+
operator|(
name|random
argument_list|()
operator|.
name|nextBoolean
argument_list|()
condition|?
literal|""
else|:
literal|"_dv"
operator|)
decl_stmt|;
specifier|final
name|String
name|intmissingsort
init|=
name|intsort
decl_stmt|;
comment|// trivial base case: ensure cursorMark against an empty index doesn't blow up
name|cursorMark
operator|=
name|CURSOR_MARK_START
expr_stmt|;
name|params
operator|=
name|params
argument_list|(
literal|"q"
argument_list|,
literal|"*:*"
argument_list|,
literal|"rows"
argument_list|,
literal|"4"
argument_list|,
literal|"fl"
argument_list|,
literal|"id"
argument_list|,
literal|"sort"
argument_list|,
literal|"id desc"
argument_list|)
expr_stmt|;
name|cursorMark
operator|=
name|assertCursor
argument_list|(
name|req
argument_list|(
name|params
argument_list|,
name|CURSOR_MARK_PARAM
argument_list|,
name|cursorMark
argument_list|)
argument_list|,
literal|"/response/numFound==0"
argument_list|,
literal|"/response/start==0"
argument_list|,
literal|"/response/docs==[]"
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|CURSOR_MARK_START
argument_list|,
name|cursorMark
argument_list|)
expr_stmt|;
comment|// don't add in order of any field to ensure we aren't inadvertantly
comment|// counting on internal docid ordering
name|assertU
argument_list|(
name|adoc
argument_list|(
literal|"id"
argument_list|,
literal|"9"
argument_list|,
literal|"str"
argument_list|,
literal|"c"
argument_list|,
literal|"float"
argument_list|,
literal|"-3.2"
argument_list|,
literal|"int"
argument_list|,
literal|"42"
argument_list|)
argument_list|)
expr_stmt|;
name|assertU
argument_list|(
name|adoc
argument_list|(
literal|"id"
argument_list|,
literal|"7"
argument_list|,
literal|"str"
argument_list|,
literal|"c"
argument_list|,
literal|"float"
argument_list|,
literal|"-3.2"
argument_list|,
literal|"int"
argument_list|,
literal|"-1976"
argument_list|)
argument_list|)
expr_stmt|;
name|assertU
argument_list|(
name|adoc
argument_list|(
literal|"id"
argument_list|,
literal|"2"
argument_list|,
literal|"str"
argument_list|,
literal|"c"
argument_list|,
literal|"float"
argument_list|,
literal|"-3.2"
argument_list|,
literal|"int"
argument_list|,
literal|"666"
argument_list|)
argument_list|)
expr_stmt|;
name|assertU
argument_list|(
name|adoc
argument_list|(
literal|"id"
argument_list|,
literal|"0"
argument_list|,
literal|"str"
argument_list|,
literal|"b"
argument_list|,
literal|"float"
argument_list|,
literal|"64.5"
argument_list|,
literal|"int"
argument_list|,
literal|"-42"
argument_list|)
argument_list|)
expr_stmt|;
name|assertU
argument_list|(
name|adoc
argument_list|(
literal|"id"
argument_list|,
literal|"5"
argument_list|,
literal|"str"
argument_list|,
literal|"b"
argument_list|,
literal|"float"
argument_list|,
literal|"64.5"
argument_list|,
literal|"int"
argument_list|,
literal|"2001"
argument_list|)
argument_list|)
expr_stmt|;
name|assertU
argument_list|(
name|adoc
argument_list|(
literal|"id"
argument_list|,
literal|"8"
argument_list|,
literal|"str"
argument_list|,
literal|"b"
argument_list|,
literal|"float"
argument_list|,
literal|"64.5"
argument_list|,
literal|"int"
argument_list|,
literal|"4055"
argument_list|)
argument_list|)
expr_stmt|;
name|assertU
argument_list|(
name|adoc
argument_list|(
literal|"id"
argument_list|,
literal|"6"
argument_list|,
literal|"str"
argument_list|,
literal|"a"
argument_list|,
literal|"float"
argument_list|,
literal|"64.5"
argument_list|,
literal|"int"
argument_list|,
literal|"7"
argument_list|)
argument_list|)
expr_stmt|;
name|assertU
argument_list|(
name|adoc
argument_list|(
literal|"id"
argument_list|,
literal|"1"
argument_list|,
literal|"str"
argument_list|,
literal|"a"
argument_list|,
literal|"float"
argument_list|,
literal|"64.5"
argument_list|,
literal|"int"
argument_list|,
literal|"7"
argument_list|)
argument_list|)
expr_stmt|;
name|assertU
argument_list|(
name|adoc
argument_list|(
literal|"id"
argument_list|,
literal|"4"
argument_list|,
literal|"str"
argument_list|,
literal|"a"
argument_list|,
literal|"float"
argument_list|,
literal|"11.1"
argument_list|,
literal|"int"
argument_list|,
literal|"6"
argument_list|)
argument_list|)
expr_stmt|;
name|assertU
argument_list|(
name|adoc
argument_list|(
literal|"id"
argument_list|,
literal|"3"
argument_list|,
literal|"str"
argument_list|,
literal|"a"
argument_list|,
literal|"float"
argument_list|,
literal|"11.1"
argument_list|)
argument_list|)
expr_stmt|;
comment|// int is missing
name|assertU
argument_list|(
name|commit
argument_list|()
argument_list|)
expr_stmt|;
comment|// base case: ensure cursorMark that matches no docs doesn't blow up
name|cursorMark
operator|=
name|CURSOR_MARK_START
expr_stmt|;
name|params
operator|=
name|params
argument_list|(
literal|"q"
argument_list|,
literal|"id:9999999"
argument_list|,
literal|"rows"
argument_list|,
literal|"4"
argument_list|,
literal|"fl"
argument_list|,
literal|"id"
argument_list|,
literal|"sort"
argument_list|,
literal|"id desc"
argument_list|)
expr_stmt|;
name|cursorMark
operator|=
name|assertCursor
argument_list|(
name|req
argument_list|(
name|params
argument_list|,
name|CURSOR_MARK_PARAM
argument_list|,
name|cursorMark
argument_list|)
argument_list|,
literal|"/response/numFound==0"
argument_list|,
literal|"/response/start==0"
argument_list|,
literal|"/response/docs==[]"
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|CURSOR_MARK_START
argument_list|,
name|cursorMark
argument_list|)
expr_stmt|;
comment|// edge case: ensure rows=0 doesn't blow up and gives back same cursor for next
name|cursorMark
operator|=
name|CURSOR_MARK_START
expr_stmt|;
name|params
operator|=
name|params
argument_list|(
literal|"q"
argument_list|,
literal|"*:*"
argument_list|,
literal|"rows"
argument_list|,
literal|"0"
argument_list|,
literal|"fl"
argument_list|,
literal|"id"
argument_list|,
literal|"sort"
argument_list|,
literal|"id desc"
argument_list|)
expr_stmt|;
name|cursorMark
operator|=
name|assertCursor
argument_list|(
name|req
argument_list|(
name|params
argument_list|,
name|CURSOR_MARK_PARAM
argument_list|,
name|cursorMark
argument_list|)
argument_list|,
literal|"/response/numFound==10"
argument_list|,
literal|"/response/start==0"
argument_list|,
literal|"/response/docs==[]"
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|CURSOR_MARK_START
argument_list|,
name|cursorMark
argument_list|)
expr_stmt|;
comment|// simple id sort w/some faceting
name|cursorMark
operator|=
name|CURSOR_MARK_START
expr_stmt|;
name|params
operator|=
name|params
argument_list|(
literal|"q"
argument_list|,
literal|"-int:6"
argument_list|,
literal|"rows"
argument_list|,
literal|"4"
argument_list|,
literal|"fl"
argument_list|,
literal|"id"
argument_list|,
literal|"sort"
argument_list|,
literal|"id desc"
argument_list|)
expr_stmt|;
name|cursorMark
operator|=
name|assertCursor
argument_list|(
name|req
argument_list|(
name|params
argument_list|,
name|CURSOR_MARK_PARAM
argument_list|,
name|cursorMark
argument_list|)
argument_list|,
literal|"/response/numFound==9"
argument_list|,
literal|"/response/start==0"
argument_list|,
literal|"/response/docs==[{'id':9},{'id':8},{'id':7},{'id':6}]"
argument_list|)
expr_stmt|;
name|cursorMark
operator|=
name|assertCursor
argument_list|(
name|req
argument_list|(
name|params
argument_list|,
name|CURSOR_MARK_PARAM
argument_list|,
name|cursorMark
argument_list|)
argument_list|,
literal|"/response/numFound==9"
argument_list|,
literal|"/response/start==0"
argument_list|,
literal|"/response/docs==[{'id':5},{'id':3},{'id':2},{'id':1}]"
argument_list|)
expr_stmt|;
name|cursorMark
operator|=
name|assertCursor
argument_list|(
name|req
argument_list|(
name|params
argument_list|,
name|CURSOR_MARK_PARAM
argument_list|,
name|cursorMark
argument_list|)
argument_list|,
literal|"/response/numFound==9"
argument_list|,
literal|"/response/start==0"
argument_list|,
literal|"/response/docs==[{'id':0}]"
argument_list|)
expr_stmt|;
comment|// no more, so no change to cursorMark, and no new docs
name|assertEquals
argument_list|(
name|cursorMark
argument_list|,
name|assertCursor
argument_list|(
name|req
argument_list|(
name|params
argument_list|,
name|CURSOR_MARK_PARAM
argument_list|,
name|cursorMark
argument_list|)
argument_list|,
literal|"/response/numFound==9"
argument_list|,
literal|"/response/start==0"
argument_list|,
literal|"/response/docs==[]"
argument_list|)
argument_list|)
expr_stmt|;
comment|// simple score sort w/some faceting
name|cursorMark
operator|=
name|CURSOR_MARK_START
expr_stmt|;
name|params
operator|=
name|params
argument_list|(
literal|"q"
argument_list|,
literal|"float:[0 TO *] int:7 id:6"
argument_list|,
literal|"rows"
argument_list|,
literal|"4"
argument_list|,
literal|"fl"
argument_list|,
literal|"id"
argument_list|,
literal|"facet"
argument_list|,
literal|"true"
argument_list|,
literal|"facet.field"
argument_list|,
literal|"str"
argument_list|,
literal|"json.nl"
argument_list|,
literal|"map"
argument_list|,
literal|"sort"
argument_list|,
literal|"score desc, id desc"
argument_list|)
expr_stmt|;
name|cursorMark
operator|=
name|assertCursor
argument_list|(
name|req
argument_list|(
name|params
argument_list|,
name|CURSOR_MARK_PARAM
argument_list|,
name|cursorMark
argument_list|)
argument_list|,
literal|"/response/numFound==7"
argument_list|,
literal|"/response/start==0"
argument_list|,
literal|"/response/docs==[{'id':6},{'id':1},{'id':8},{'id':5}]"
argument_list|,
literal|"/facet_counts/facet_fields/str=={'a':4,'b':3,'c':0}"
argument_list|)
expr_stmt|;
name|cursorMark
operator|=
name|assertCursor
argument_list|(
name|req
argument_list|(
name|params
argument_list|,
name|CURSOR_MARK_PARAM
argument_list|,
name|cursorMark
argument_list|)
argument_list|,
literal|"/response/numFound==7"
argument_list|,
literal|"/response/start==0"
argument_list|,
literal|"/response/docs==[{'id':4},{'id':3},{'id':0}]"
argument_list|,
literal|"/facet_counts/facet_fields/str=={'a':4,'b':3,'c':0}"
argument_list|)
expr_stmt|;
comment|// no more, so no change to cursorMark, and no new docs
name|assertEquals
argument_list|(
name|cursorMark
argument_list|,
name|assertCursor
argument_list|(
name|req
argument_list|(
name|params
argument_list|,
name|CURSOR_MARK_PARAM
argument_list|,
name|cursorMark
argument_list|)
argument_list|,
literal|"/response/numFound==7"
argument_list|,
literal|"/response/start==0"
argument_list|,
literal|"/response/docs==[]"
argument_list|,
literal|"/facet_counts/facet_fields/str=={'a':4,'b':3,'c':0}"
argument_list|)
argument_list|)
expr_stmt|;
comment|// int sort with dups, id tie breaker ... and some faceting
name|cursorMark
operator|=
name|CURSOR_MARK_START
expr_stmt|;
name|params
operator|=
name|params
argument_list|(
literal|"q"
argument_list|,
literal|"-int:2001 -int:4055"
argument_list|,
literal|"rows"
argument_list|,
literal|"3"
argument_list|,
literal|"fl"
argument_list|,
literal|"id"
argument_list|,
literal|"facet"
argument_list|,
literal|"true"
argument_list|,
literal|"facet.field"
argument_list|,
literal|"str"
argument_list|,
literal|"json.nl"
argument_list|,
literal|"map"
argument_list|,
literal|"sort"
argument_list|,
name|intsort
operator|+
literal|" asc, id asc"
argument_list|)
expr_stmt|;
name|cursorMark
operator|=
name|assertCursor
argument_list|(
name|req
argument_list|(
name|params
argument_list|,
name|CURSOR_MARK_PARAM
argument_list|,
name|cursorMark
argument_list|)
argument_list|,
literal|"/response/numFound==8"
argument_list|,
literal|"/response/start==0"
argument_list|,
literal|"/response/docs==[{'id':7},{'id':0},{'id':3}]"
argument_list|,
literal|"/facet_counts/facet_fields/str=={'a':4,'b':1,'c':3}"
argument_list|)
expr_stmt|;
name|cursorMark
operator|=
name|assertCursor
argument_list|(
name|req
argument_list|(
name|params
argument_list|,
name|CURSOR_MARK_PARAM
argument_list|,
name|cursorMark
argument_list|)
argument_list|,
literal|"/response/numFound==8"
argument_list|,
literal|"/response/start==0"
argument_list|,
literal|"/response/docs==[{'id':4},{'id':1},{'id':6}]"
argument_list|,
literal|"/facet_counts/facet_fields/str=={'a':4,'b':1,'c':3}"
argument_list|)
expr_stmt|;
name|cursorMark
operator|=
name|assertCursor
argument_list|(
name|req
argument_list|(
name|params
argument_list|,
name|CURSOR_MARK_PARAM
argument_list|,
name|cursorMark
argument_list|)
argument_list|,
literal|"/response/numFound==8"
argument_list|,
literal|"/response/start==0"
argument_list|,
literal|"/response/docs==[{'id':9},{'id':2}]"
argument_list|,
literal|"/facet_counts/facet_fields/str=={'a':4,'b':1,'c':3}"
argument_list|)
expr_stmt|;
comment|// no more, so no change to cursorMark, and no new docs
name|assertEquals
argument_list|(
name|cursorMark
argument_list|,
name|assertCursor
argument_list|(
name|req
argument_list|(
name|params
argument_list|,
name|CURSOR_MARK_PARAM
argument_list|,
name|cursorMark
argument_list|)
argument_list|,
literal|"/response/numFound==8"
argument_list|,
literal|"/response/start==0"
argument_list|,
literal|"/response/docs==[]"
argument_list|,
literal|"/facet_counts/facet_fields/str=={'a':4,'b':1,'c':3}"
argument_list|)
argument_list|)
expr_stmt|;
comment|// int missing first sort with dups, id tie breaker
name|cursorMark
operator|=
name|CURSOR_MARK_START
expr_stmt|;
name|params
operator|=
name|params
argument_list|(
literal|"q"
argument_list|,
literal|"-int:2001 -int:4055"
argument_list|,
literal|"rows"
argument_list|,
literal|"3"
argument_list|,
literal|"fl"
argument_list|,
literal|"id"
argument_list|,
literal|"json.nl"
argument_list|,
literal|"map"
argument_list|,
literal|"sort"
argument_list|,
name|intmissingsort
operator|+
literal|"_first asc, id asc"
argument_list|)
expr_stmt|;
name|cursorMark
operator|=
name|assertCursor
argument_list|(
name|req
argument_list|(
name|params
argument_list|,
name|CURSOR_MARK_PARAM
argument_list|,
name|cursorMark
argument_list|)
argument_list|,
literal|"/response/numFound==8"
argument_list|,
literal|"/response/start==0"
argument_list|,
literal|"/response/docs==[{'id':3},{'id':7},{'id':0}]"
argument_list|)
expr_stmt|;
name|cursorMark
operator|=
name|assertCursor
argument_list|(
name|req
argument_list|(
name|params
argument_list|,
name|CURSOR_MARK_PARAM
argument_list|,
name|cursorMark
argument_list|)
argument_list|,
literal|"/response/numFound==8"
argument_list|,
literal|"/response/start==0"
argument_list|,
literal|"/response/docs==[{'id':4},{'id':1},{'id':6}]"
argument_list|)
expr_stmt|;
name|cursorMark
operator|=
name|assertCursor
argument_list|(
name|req
argument_list|(
name|params
argument_list|,
name|CURSOR_MARK_PARAM
argument_list|,
name|cursorMark
argument_list|)
argument_list|,
literal|"/response/numFound==8"
argument_list|,
literal|"/response/start==0"
argument_list|,
literal|"/response/docs==[{'id':9},{'id':2}]"
argument_list|)
expr_stmt|;
comment|// no more, so no change to cursorMark, and no new docs
name|assertEquals
argument_list|(
name|cursorMark
argument_list|,
name|assertCursor
argument_list|(
name|req
argument_list|(
name|params
argument_list|,
name|CURSOR_MARK_PARAM
argument_list|,
name|cursorMark
argument_list|)
argument_list|,
literal|"/response/numFound==8"
argument_list|,
literal|"/response/start==0"
argument_list|,
literal|"/response/docs==[]"
argument_list|)
argument_list|)
expr_stmt|;
comment|// int missing last sort with dups, id tie breaker
name|cursorMark
operator|=
name|CURSOR_MARK_START
expr_stmt|;
name|params
operator|=
name|params
argument_list|(
literal|"q"
argument_list|,
literal|"-int:2001 -int:4055"
argument_list|,
literal|"rows"
argument_list|,
literal|"3"
argument_list|,
literal|"fl"
argument_list|,
literal|"id"
argument_list|,
literal|"json.nl"
argument_list|,
literal|"map"
argument_list|,
literal|"sort"
argument_list|,
name|intmissingsort
operator|+
literal|"_last asc, id asc"
argument_list|)
expr_stmt|;
name|cursorMark
operator|=
name|assertCursor
argument_list|(
name|req
argument_list|(
name|params
argument_list|,
name|CURSOR_MARK_PARAM
argument_list|,
name|cursorMark
argument_list|)
argument_list|,
literal|"/response/numFound==8"
argument_list|,
literal|"/response/start==0"
argument_list|,
literal|"/response/docs==[{'id':7},{'id':0},{'id':4}]"
argument_list|)
expr_stmt|;
name|cursorMark
operator|=
name|assertCursor
argument_list|(
name|req
argument_list|(
name|params
argument_list|,
name|CURSOR_MARK_PARAM
argument_list|,
name|cursorMark
argument_list|)
argument_list|,
literal|"/response/numFound==8"
argument_list|,
literal|"/response/start==0"
argument_list|,
literal|"/response/docs==[{'id':1},{'id':6},{'id':9}]"
argument_list|)
expr_stmt|;
name|cursorMark
operator|=
name|assertCursor
argument_list|(
name|req
argument_list|(
name|params
argument_list|,
name|CURSOR_MARK_PARAM
argument_list|,
name|cursorMark
argument_list|)
argument_list|,
literal|"/response/numFound==8"
argument_list|,
literal|"/response/start==0"
argument_list|,
literal|"/response/docs==[{'id':2},{'id':3}]"
argument_list|)
expr_stmt|;
comment|// no more, so no change to cursorMark, and no new docs
name|assertEquals
argument_list|(
name|cursorMark
argument_list|,
name|assertCursor
argument_list|(
name|req
argument_list|(
name|params
argument_list|,
name|CURSOR_MARK_PARAM
argument_list|,
name|cursorMark
argument_list|)
argument_list|,
literal|"/response/numFound==8"
argument_list|,
literal|"/response/start==0"
argument_list|,
literal|"/response/docs==[]"
argument_list|)
argument_list|)
expr_stmt|;
comment|// string sort with dups, id tie breaker
name|cursorMark
operator|=
name|CURSOR_MARK_START
expr_stmt|;
name|params
operator|=
name|params
argument_list|(
literal|"q"
argument_list|,
literal|"*:*"
argument_list|,
literal|"rows"
argument_list|,
literal|"6"
argument_list|,
literal|"fl"
argument_list|,
literal|"id"
argument_list|,
literal|"sort"
argument_list|,
literal|"str asc, id desc"
argument_list|)
expr_stmt|;
name|cursorMark
operator|=
name|assertCursor
argument_list|(
name|req
argument_list|(
name|params
argument_list|,
name|CURSOR_MARK_PARAM
argument_list|,
name|cursorMark
argument_list|)
argument_list|,
literal|"/response/numFound==10"
argument_list|,
literal|"/response/start==0"
argument_list|,
literal|"/response/docs==[{'id':6},{'id':4},{'id':3},{'id':1},{'id':8},{'id':5}]"
argument_list|)
expr_stmt|;
name|cursorMark
operator|=
name|assertCursor
argument_list|(
name|req
argument_list|(
name|params
argument_list|,
name|CURSOR_MARK_PARAM
argument_list|,
name|cursorMark
argument_list|)
argument_list|,
literal|"/response/numFound==10"
argument_list|,
literal|"/response/start==0"
argument_list|,
literal|"/response/docs==[{'id':0},{'id':9},{'id':7},{'id':2}]"
argument_list|)
expr_stmt|;
comment|// no more, so no change to cursorMark, and no new docs
name|assertEquals
argument_list|(
name|cursorMark
argument_list|,
name|assertCursor
argument_list|(
name|req
argument_list|(
name|params
argument_list|,
name|CURSOR_MARK_PARAM
argument_list|,
name|cursorMark
argument_list|)
argument_list|,
literal|"/response/numFound==10"
argument_list|,
literal|"/response/start==0"
argument_list|,
literal|"/response/docs==[]"
argument_list|)
argument_list|)
expr_stmt|;
comment|// tri-level sort with more dups of primary then fit on a page
name|cursorMark
operator|=
name|CURSOR_MARK_START
expr_stmt|;
name|params
operator|=
name|params
argument_list|(
literal|"q"
argument_list|,
literal|"*:*"
argument_list|,
literal|"rows"
argument_list|,
literal|"2"
argument_list|,
literal|"fl"
argument_list|,
literal|"id"
argument_list|,
literal|"sort"
argument_list|,
literal|"float asc, "
operator|+
name|intsort
operator|+
literal|" desc, id desc"
argument_list|)
expr_stmt|;
name|cursorMark
operator|=
name|assertCursor
argument_list|(
name|req
argument_list|(
name|params
argument_list|,
name|CURSOR_MARK_PARAM
argument_list|,
name|cursorMark
argument_list|)
argument_list|,
literal|"/response/numFound==10"
argument_list|,
literal|"/response/start==0"
argument_list|,
literal|"/response/docs==[{'id':2},{'id':9}]"
argument_list|)
expr_stmt|;
name|cursorMark
operator|=
name|assertCursor
argument_list|(
name|req
argument_list|(
name|params
argument_list|,
name|CURSOR_MARK_PARAM
argument_list|,
name|cursorMark
argument_list|)
argument_list|,
literal|"/response/numFound==10"
argument_list|,
literal|"/response/start==0"
argument_list|,
literal|"/response/docs==[{'id':7},{'id':4}]"
argument_list|)
expr_stmt|;
name|cursorMark
operator|=
name|assertCursor
argument_list|(
name|req
argument_list|(
name|params
argument_list|,
name|CURSOR_MARK_PARAM
argument_list|,
name|cursorMark
argument_list|)
argument_list|,
literal|"/response/numFound==10"
argument_list|,
literal|"/response/start==0"
argument_list|,
literal|"/response/docs==[{'id':3},{'id':8}]"
argument_list|)
expr_stmt|;
name|cursorMark
operator|=
name|assertCursor
argument_list|(
name|req
argument_list|(
name|params
argument_list|,
name|CURSOR_MARK_PARAM
argument_list|,
name|cursorMark
argument_list|)
argument_list|,
literal|"/response/numFound==10"
argument_list|,
literal|"/response/start==0"
argument_list|,
literal|"/response/docs==[{'id':5},{'id':6}]"
argument_list|)
expr_stmt|;
name|cursorMark
operator|=
name|assertCursor
argument_list|(
name|req
argument_list|(
name|params
argument_list|,
name|CURSOR_MARK_PARAM
argument_list|,
name|cursorMark
argument_list|)
argument_list|,
literal|"/response/numFound==10"
argument_list|,
literal|"/response/start==0"
argument_list|,
literal|"/response/docs==[{'id':1},{'id':0}]"
argument_list|)
expr_stmt|;
comment|// we've exactly exhausted all the results, but solr had no way of know that
comment|// no more, so no change to cursorMark, and no new docs
name|assertEquals
argument_list|(
name|cursorMark
argument_list|,
name|assertCursor
argument_list|(
name|req
argument_list|(
name|params
argument_list|,
name|CURSOR_MARK_PARAM
argument_list|,
name|cursorMark
argument_list|)
argument_list|,
literal|"/response/numFound==10"
argument_list|,
literal|"/response/start==0"
argument_list|,
literal|"/response/docs==[]"
argument_list|)
argument_list|)
expr_stmt|;
comment|// trivial base case: rows bigger then number of matches
name|cursorMark
operator|=
name|CURSOR_MARK_START
expr_stmt|;
name|params
operator|=
name|params
argument_list|(
literal|"q"
argument_list|,
literal|"id:3 id:7"
argument_list|,
literal|"rows"
argument_list|,
literal|"111"
argument_list|,
literal|"fl"
argument_list|,
literal|"id"
argument_list|,
literal|"sort"
argument_list|,
name|intsort
operator|+
literal|" asc, id asc"
argument_list|)
expr_stmt|;
name|cursorMark
operator|=
name|assertCursor
argument_list|(
name|req
argument_list|(
name|params
argument_list|,
name|CURSOR_MARK_PARAM
argument_list|,
name|cursorMark
argument_list|)
argument_list|,
literal|"/response/numFound==2"
argument_list|,
literal|"/response/start==0"
argument_list|,
literal|"/response/docs==[{'id':7},{'id':3}]"
argument_list|)
expr_stmt|;
comment|// no more, so no change to cursorMark, and no new docs
name|assertEquals
argument_list|(
name|cursorMark
argument_list|,
name|assertCursor
argument_list|(
name|req
argument_list|(
name|params
argument_list|,
name|CURSOR_MARK_PARAM
argument_list|,
name|cursorMark
argument_list|)
argument_list|,
literal|"/response/numFound==2"
argument_list|,
literal|"/response/start==0"
argument_list|,
literal|"/response/docs==[]"
argument_list|)
argument_list|)
expr_stmt|;
comment|// sanity check our full walk method
name|SentinelIntSet
name|ids
decl_stmt|;
name|ids
operator|=
name|assertFullWalkNoDups
argument_list|(
literal|10
argument_list|,
name|params
argument_list|(
literal|"q"
argument_list|,
literal|"*:*"
argument_list|,
literal|"rows"
argument_list|,
literal|"4"
argument_list|,
literal|"sort"
argument_list|,
literal|"id desc"
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|10
argument_list|,
name|ids
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|ids
operator|=
name|assertFullWalkNoDups
argument_list|(
literal|9
argument_list|,
name|params
argument_list|(
literal|"q"
argument_list|,
literal|"*:*"
argument_list|,
literal|"rows"
argument_list|,
literal|"1"
argument_list|,
literal|"fq"
argument_list|,
literal|"-id:4"
argument_list|,
literal|"sort"
argument_list|,
literal|"id asc"
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|9
argument_list|,
name|ids
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
literal|"matched on id:4 unexpectedly"
argument_list|,
name|ids
operator|.
name|exists
argument_list|(
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|ids
operator|=
name|assertFullWalkNoDups
argument_list|(
literal|9
argument_list|,
name|params
argument_list|(
literal|"q"
argument_list|,
literal|"*:*"
argument_list|,
literal|"rows"
argument_list|,
literal|"3"
argument_list|,
literal|"fq"
argument_list|,
literal|"-id:6"
argument_list|,
literal|"sort"
argument_list|,
literal|"float desc, id asc, "
operator|+
name|intsort
operator|+
literal|" asc"
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|9
argument_list|,
name|ids
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
literal|"matched on id:6 unexpectedly"
argument_list|,
name|ids
operator|.
name|exists
argument_list|(
literal|6
argument_list|)
argument_list|)
expr_stmt|;
name|ids
operator|=
name|assertFullWalkNoDups
argument_list|(
literal|9
argument_list|,
name|params
argument_list|(
literal|"q"
argument_list|,
literal|"float:[0 TO *] int:7 id:6"
argument_list|,
literal|"rows"
argument_list|,
literal|"3"
argument_list|,
literal|"sort"
argument_list|,
literal|"score desc, id desc"
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|7
argument_list|,
name|ids
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
literal|"matched on id:9 unexpectedly"
argument_list|,
name|ids
operator|.
name|exists
argument_list|(
literal|9
argument_list|)
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
literal|"matched on id:7 unexpectedly"
argument_list|,
name|ids
operator|.
name|exists
argument_list|(
literal|7
argument_list|)
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
literal|"matched on id:2 unexpectedly"
argument_list|,
name|ids
operator|.
name|exists
argument_list|(
literal|2
argument_list|)
argument_list|)
expr_stmt|;
comment|// strategically delete/add some docs in the middle of walking the cursor
name|cursorMark
operator|=
name|CURSOR_MARK_START
expr_stmt|;
name|params
operator|=
name|params
argument_list|(
literal|"q"
argument_list|,
literal|"*:*"
argument_list|,
literal|"rows"
argument_list|,
literal|"2"
argument_list|,
literal|"fl"
argument_list|,
literal|"id"
argument_list|,
literal|"sort"
argument_list|,
literal|"str asc, id asc"
argument_list|)
expr_stmt|;
name|cursorMark
operator|=
name|assertCursor
argument_list|(
name|req
argument_list|(
name|params
argument_list|,
name|CURSOR_MARK_PARAM
argument_list|,
name|cursorMark
argument_list|)
argument_list|,
literal|"/response/numFound==10"
argument_list|,
literal|"/response/start==0"
argument_list|,
literal|"/response/docs==[{'id':1},{'id':3}]"
argument_list|)
expr_stmt|;
comment|// delete the last guy we got
name|assertU
argument_list|(
name|delI
argument_list|(
literal|"3"
argument_list|)
argument_list|)
expr_stmt|;
name|assertU
argument_list|(
name|commit
argument_list|()
argument_list|)
expr_stmt|;
name|cursorMark
operator|=
name|assertCursor
argument_list|(
name|req
argument_list|(
name|params
argument_list|,
name|CURSOR_MARK_PARAM
argument_list|,
name|cursorMark
argument_list|)
argument_list|,
literal|"/response/numFound==9"
argument_list|,
literal|"/response/start==0"
argument_list|,
literal|"/response/docs==[{'id':4},{'id':6}]"
argument_list|)
expr_stmt|;
comment|// delete the next guy we expect
name|assertU
argument_list|(
name|delI
argument_list|(
literal|"0"
argument_list|)
argument_list|)
expr_stmt|;
name|assertU
argument_list|(
name|commit
argument_list|()
argument_list|)
expr_stmt|;
name|cursorMark
operator|=
name|assertCursor
argument_list|(
name|req
argument_list|(
name|params
argument_list|,
name|CURSOR_MARK_PARAM
argument_list|,
name|cursorMark
argument_list|)
argument_list|,
literal|"/response/numFound==8"
argument_list|,
literal|"/response/start==0"
argument_list|,
literal|"/response/docs==[{'id':5},{'id':8}]"
argument_list|)
expr_stmt|;
comment|// update a doc we've already seen so it repeats
name|assertU
argument_list|(
name|adoc
argument_list|(
literal|"id"
argument_list|,
literal|"5"
argument_list|,
literal|"str"
argument_list|,
literal|"c"
argument_list|)
argument_list|)
expr_stmt|;
name|assertU
argument_list|(
name|commit
argument_list|()
argument_list|)
expr_stmt|;
name|cursorMark
operator|=
name|assertCursor
argument_list|(
name|req
argument_list|(
name|params
argument_list|,
name|CURSOR_MARK_PARAM
argument_list|,
name|cursorMark
argument_list|)
argument_list|,
literal|"/response/numFound==8"
argument_list|,
literal|"/response/start==0"
argument_list|,
literal|"/response/docs==[{'id':2},{'id':5}]"
argument_list|)
expr_stmt|;
comment|// update the next doc we expect so it's now in the past
name|assertU
argument_list|(
name|adoc
argument_list|(
literal|"id"
argument_list|,
literal|"7"
argument_list|,
literal|"str"
argument_list|,
literal|"a"
argument_list|)
argument_list|)
expr_stmt|;
name|assertU
argument_list|(
name|commit
argument_list|()
argument_list|)
expr_stmt|;
name|cursorMark
operator|=
name|assertCursor
argument_list|(
name|req
argument_list|(
name|params
argument_list|,
name|CURSOR_MARK_PARAM
argument_list|,
name|cursorMark
argument_list|)
argument_list|,
literal|"/response/numFound==8"
argument_list|,
literal|"/response/start==0"
argument_list|,
literal|"/response/docs==[{'id':9}]"
argument_list|)
expr_stmt|;
comment|// no more, so no change to cursorMark, and no new docs
name|assertEquals
argument_list|(
name|cursorMark
argument_list|,
name|assertCursor
argument_list|(
name|req
argument_list|(
name|params
argument_list|,
name|CURSOR_MARK_PARAM
argument_list|,
name|cursorMark
argument_list|)
argument_list|,
literal|"/response/numFound==8"
argument_list|,
literal|"/response/start==0"
argument_list|,
literal|"/response/docs==[]"
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * test that our assumptions about how caches are affected hold true    */
DECL|method|testCacheImpacts
specifier|public
name|void
name|testCacheImpacts
parameter_list|()
throws|throws
name|Exception
block|{
comment|// cursor queryies can't live in the queryResultCache, but independent filters
comment|// should still be cached& reused
comment|// don't add in order of any field to ensure we aren't inadvertantly
comment|// counting on internal docid ordering
name|assertU
argument_list|(
name|adoc
argument_list|(
literal|"id"
argument_list|,
literal|"9"
argument_list|,
literal|"str"
argument_list|,
literal|"c"
argument_list|,
literal|"float"
argument_list|,
literal|"-3.2"
argument_list|,
literal|"int"
argument_list|,
literal|"42"
argument_list|)
argument_list|)
expr_stmt|;
name|assertU
argument_list|(
name|adoc
argument_list|(
literal|"id"
argument_list|,
literal|"7"
argument_list|,
literal|"str"
argument_list|,
literal|"c"
argument_list|,
literal|"float"
argument_list|,
literal|"-3.2"
argument_list|,
literal|"int"
argument_list|,
literal|"-1976"
argument_list|)
argument_list|)
expr_stmt|;
name|assertU
argument_list|(
name|adoc
argument_list|(
literal|"id"
argument_list|,
literal|"2"
argument_list|,
literal|"str"
argument_list|,
literal|"c"
argument_list|,
literal|"float"
argument_list|,
literal|"-3.2"
argument_list|,
literal|"int"
argument_list|,
literal|"666"
argument_list|)
argument_list|)
expr_stmt|;
name|assertU
argument_list|(
name|adoc
argument_list|(
literal|"id"
argument_list|,
literal|"0"
argument_list|,
literal|"str"
argument_list|,
literal|"b"
argument_list|,
literal|"float"
argument_list|,
literal|"64.5"
argument_list|,
literal|"int"
argument_list|,
literal|"-42"
argument_list|)
argument_list|)
expr_stmt|;
name|assertU
argument_list|(
name|adoc
argument_list|(
literal|"id"
argument_list|,
literal|"5"
argument_list|,
literal|"str"
argument_list|,
literal|"b"
argument_list|,
literal|"float"
argument_list|,
literal|"64.5"
argument_list|,
literal|"int"
argument_list|,
literal|"2001"
argument_list|)
argument_list|)
expr_stmt|;
name|assertU
argument_list|(
name|adoc
argument_list|(
literal|"id"
argument_list|,
literal|"8"
argument_list|,
literal|"str"
argument_list|,
literal|"b"
argument_list|,
literal|"float"
argument_list|,
literal|"64.5"
argument_list|,
literal|"int"
argument_list|,
literal|"4055"
argument_list|)
argument_list|)
expr_stmt|;
name|assertU
argument_list|(
name|adoc
argument_list|(
literal|"id"
argument_list|,
literal|"6"
argument_list|,
literal|"str"
argument_list|,
literal|"a"
argument_list|,
literal|"float"
argument_list|,
literal|"64.5"
argument_list|,
literal|"int"
argument_list|,
literal|"7"
argument_list|)
argument_list|)
expr_stmt|;
name|assertU
argument_list|(
name|adoc
argument_list|(
literal|"id"
argument_list|,
literal|"1"
argument_list|,
literal|"str"
argument_list|,
literal|"a"
argument_list|,
literal|"float"
argument_list|,
literal|"64.5"
argument_list|,
literal|"int"
argument_list|,
literal|"7"
argument_list|)
argument_list|)
expr_stmt|;
name|assertU
argument_list|(
name|adoc
argument_list|(
literal|"id"
argument_list|,
literal|"4"
argument_list|,
literal|"str"
argument_list|,
literal|"a"
argument_list|,
literal|"float"
argument_list|,
literal|"11.1"
argument_list|,
literal|"int"
argument_list|,
literal|"6"
argument_list|)
argument_list|)
expr_stmt|;
name|assertU
argument_list|(
name|adoc
argument_list|(
literal|"id"
argument_list|,
literal|"3"
argument_list|,
literal|"str"
argument_list|,
literal|"a"
argument_list|,
literal|"float"
argument_list|,
literal|"11.1"
argument_list|,
literal|"int"
argument_list|,
literal|"3"
argument_list|)
argument_list|)
expr_stmt|;
name|assertU
argument_list|(
name|commit
argument_list|()
argument_list|)
expr_stmt|;
specifier|final
name|Collection
argument_list|<
name|String
argument_list|>
name|allFieldNames
init|=
name|getAllSortFieldNames
argument_list|()
decl_stmt|;
specifier|final
name|SolrInfoMBean
name|filterCacheStats
init|=
name|h
operator|.
name|getCore
argument_list|()
operator|.
name|getInfoRegistry
argument_list|()
operator|.
name|get
argument_list|(
literal|"filterCache"
argument_list|)
decl_stmt|;
name|assertNotNull
argument_list|(
name|filterCacheStats
argument_list|)
expr_stmt|;
specifier|final
name|SolrInfoMBean
name|queryCacheStats
init|=
name|h
operator|.
name|getCore
argument_list|()
operator|.
name|getInfoRegistry
argument_list|()
operator|.
name|get
argument_list|(
literal|"queryResultCache"
argument_list|)
decl_stmt|;
name|assertNotNull
argument_list|(
name|queryCacheStats
argument_list|)
expr_stmt|;
specifier|final
name|long
name|preQcIn
init|=
operator|(
name|Long
operator|)
name|queryCacheStats
operator|.
name|getStatistics
argument_list|()
operator|.
name|get
argument_list|(
literal|"inserts"
argument_list|)
decl_stmt|;
specifier|final
name|long
name|preFcIn
init|=
operator|(
name|Long
operator|)
name|filterCacheStats
operator|.
name|getStatistics
argument_list|()
operator|.
name|get
argument_list|(
literal|"inserts"
argument_list|)
decl_stmt|;
specifier|final
name|long
name|preFcHits
init|=
operator|(
name|Long
operator|)
name|filterCacheStats
operator|.
name|getStatistics
argument_list|()
operator|.
name|get
argument_list|(
literal|"hits"
argument_list|)
decl_stmt|;
name|SentinelIntSet
name|ids
init|=
name|assertFullWalkNoDups
argument_list|(
literal|10
argument_list|,
name|params
argument_list|(
literal|"q"
argument_list|,
literal|"*:*"
argument_list|,
literal|"rows"
argument_list|,
literal|""
operator|+
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|random
argument_list|()
argument_list|,
literal|1
argument_list|,
literal|11
argument_list|)
argument_list|,
literal|"fq"
argument_list|,
literal|"-id:[1 TO 2]"
argument_list|,
literal|"fq"
argument_list|,
literal|"-id:[6 TO 7]"
argument_list|,
literal|"fl"
argument_list|,
literal|"id"
argument_list|,
literal|"sort"
argument_list|,
name|buildRandomSort
argument_list|(
name|allFieldNames
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|6
argument_list|,
name|ids
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
specifier|final
name|long
name|postQcIn
init|=
operator|(
name|Long
operator|)
name|queryCacheStats
operator|.
name|getStatistics
argument_list|()
operator|.
name|get
argument_list|(
literal|"inserts"
argument_list|)
decl_stmt|;
specifier|final
name|long
name|postFcIn
init|=
operator|(
name|Long
operator|)
name|filterCacheStats
operator|.
name|getStatistics
argument_list|()
operator|.
name|get
argument_list|(
literal|"inserts"
argument_list|)
decl_stmt|;
specifier|final
name|long
name|postFcHits
init|=
operator|(
name|Long
operator|)
name|filterCacheStats
operator|.
name|getStatistics
argument_list|()
operator|.
name|get
argument_list|(
literal|"hits"
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|"query cache inserts changed"
argument_list|,
name|preQcIn
argument_list|,
name|postQcIn
argument_list|)
expr_stmt|;
comment|// NOTE: use of pure negative filters causees "*:* to be tracked in filterCache
name|assertEquals
argument_list|(
literal|"filter cache did not grow correctly"
argument_list|,
literal|3
argument_list|,
name|postFcIn
operator|-
name|preFcIn
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"filter cache did not have any new cache hits"
argument_list|,
literal|0
operator|<
name|postFcHits
operator|-
name|preFcHits
argument_list|)
expr_stmt|;
block|}
comment|/** randomized testing of a non-trivial number of docs using assertFullWalkNoDups     */
DECL|method|testRandomSortsOnLargeIndex
specifier|public
name|void
name|testRandomSortsOnLargeIndex
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|Collection
argument_list|<
name|String
argument_list|>
name|allFieldNames
init|=
name|getAllSortFieldNames
argument_list|()
decl_stmt|;
specifier|final
name|int
name|initialDocs
init|=
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|random
argument_list|()
argument_list|,
literal|100
argument_list|,
literal|200
argument_list|)
decl_stmt|;
specifier|final
name|int
name|totalDocs
init|=
name|atLeast
argument_list|(
literal|500
argument_list|)
decl_stmt|;
comment|// start with a smallish number of documents, and test that we can do a full walk using a
comment|// sort on *every* field in the schema...
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<=
name|initialDocs
condition|;
name|i
operator|++
control|)
block|{
name|SolrInputDocument
name|doc
init|=
name|buildRandomDocument
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|assertU
argument_list|(
name|adoc
argument_list|(
name|doc
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|assertU
argument_list|(
name|commit
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|String
name|f
range|:
name|allFieldNames
control|)
block|{
for|for
control|(
name|String
name|order
range|:
operator|new
name|String
index|[]
block|{
literal|" asc"
block|,
literal|" desc"
block|}
control|)
block|{
name|String
name|sort
init|=
name|f
operator|+
name|order
operator|+
operator|(
literal|"id"
operator|.
name|equals
argument_list|(
name|f
argument_list|)
condition|?
literal|""
else|:
literal|", id"
operator|+
name|order
operator|)
decl_stmt|;
name|String
name|rows
init|=
literal|""
operator|+
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|random
argument_list|()
argument_list|,
literal|13
argument_list|,
literal|50
argument_list|)
decl_stmt|;
name|SentinelIntSet
name|ids
init|=
name|assertFullWalkNoDups
argument_list|(
name|totalDocs
argument_list|,
name|params
argument_list|(
literal|"q"
argument_list|,
literal|"*:*"
argument_list|,
literal|"fl"
argument_list|,
literal|"id"
argument_list|,
literal|"rows"
argument_list|,
name|rows
argument_list|,
literal|"sort"
argument_list|,
name|sort
argument_list|)
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|initialDocs
argument_list|,
name|ids
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|// now add a lot more docs, and test a handful of randomized sorts
for|for
control|(
name|int
name|i
init|=
name|initialDocs
operator|+
literal|1
init|;
name|i
operator|<=
name|totalDocs
condition|;
name|i
operator|++
control|)
block|{
name|SolrInputDocument
name|doc
init|=
name|buildRandomDocument
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|assertU
argument_list|(
name|adoc
argument_list|(
name|doc
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|assertU
argument_list|(
name|commit
argument_list|()
argument_list|)
expr_stmt|;
specifier|final
name|int
name|numRandomSorts
init|=
name|atLeast
argument_list|(
literal|3
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numRandomSorts
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|String
name|sort
init|=
name|buildRandomSort
argument_list|(
name|allFieldNames
argument_list|)
decl_stmt|;
specifier|final
name|String
name|rows
init|=
literal|""
operator|+
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|random
argument_list|()
argument_list|,
literal|63
argument_list|,
literal|113
argument_list|)
decl_stmt|;
specifier|final
name|String
name|fl
init|=
name|random
argument_list|()
operator|.
name|nextBoolean
argument_list|()
condition|?
literal|"id"
else|:
literal|"id,score"
decl_stmt|;
specifier|final
name|boolean
name|matchAll
init|=
name|random
argument_list|()
operator|.
name|nextBoolean
argument_list|()
decl_stmt|;
specifier|final
name|String
name|q
init|=
name|matchAll
condition|?
literal|"*:*"
else|:
name|buildRandomQuery
argument_list|()
decl_stmt|;
name|SentinelIntSet
name|ids
init|=
name|assertFullWalkNoDups
argument_list|(
name|totalDocs
argument_list|,
name|params
argument_list|(
literal|"q"
argument_list|,
name|q
argument_list|,
literal|"fl"
argument_list|,
name|fl
argument_list|,
literal|"rows"
argument_list|,
name|rows
argument_list|,
literal|"sort"
argument_list|,
name|sort
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|matchAll
condition|)
block|{
name|assertEquals
argument_list|(
name|totalDocs
argument_list|,
name|ids
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/** Similar to usually() but we want it to happen just as often regardless    * of test multiplier and nightly status     */
DECL|method|useField
specifier|private
specifier|static
name|boolean
name|useField
parameter_list|()
block|{
return|return
literal|0
operator|!=
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|random
argument_list|()
argument_list|,
literal|0
argument_list|,
literal|30
argument_list|)
return|;
block|}
comment|/**    * An immutable list of the fields in the schema that can be used for sorting,    * deterministically random order.    */
DECL|method|getAllSortFieldNames
specifier|private
name|List
argument_list|<
name|String
argument_list|>
name|getAllSortFieldNames
parameter_list|()
block|{
return|return
name|pruneAndDeterministicallySort
argument_list|(
name|h
operator|.
name|getCore
argument_list|()
operator|.
name|getLatestSchema
argument_list|()
operator|.
name|getFields
argument_list|()
operator|.
name|keySet
argument_list|()
argument_list|)
return|;
block|}
comment|/**    *<p>    * Given a list of field names in the schema, returns an immutable list in     * deterministically random order with the following things removed:    *</p>    *<ul>    *<li><code>_version_</code> is removed</li>    *</ul>    */
DECL|method|pruneAndDeterministicallySort
specifier|public
specifier|static
name|List
argument_list|<
name|String
argument_list|>
name|pruneAndDeterministicallySort
parameter_list|(
name|Collection
argument_list|<
name|String
argument_list|>
name|raw
parameter_list|)
block|{
name|ArrayList
argument_list|<
name|String
argument_list|>
name|names
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
literal|37
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|f
range|:
name|raw
control|)
block|{
if|if
condition|(
name|f
operator|.
name|equals
argument_list|(
literal|"_version_"
argument_list|)
condition|)
block|{
continue|continue;
block|}
name|names
operator|.
name|add
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
name|Collections
operator|.
name|sort
argument_list|(
name|names
argument_list|)
expr_stmt|;
name|Collections
operator|.
name|shuffle
argument_list|(
name|names
argument_list|,
name|random
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|Collections
operator|.
expr|<
name|String
operator|>
name|unmodifiableList
argument_list|(
name|names
argument_list|)
return|;
block|}
comment|/**    * Given a set of params, executes a cursor query using {@link CursorMarkParams#CURSOR_MARK_START}    * and then continuously walks the results using {@link CursorMarkParams#CURSOR_MARK_START} as long    * as a non-0 number of docs ar returned.  This method records the the set of all id's    * (must be positive ints) encountered and throws an assertion failure if any id is    * encountered more than once, or if the set grows above maxSize    */
DECL|method|assertFullWalkNoDups
specifier|public
name|SentinelIntSet
name|assertFullWalkNoDups
parameter_list|(
name|int
name|maxSize
parameter_list|,
name|SolrParams
name|params
parameter_list|)
throws|throws
name|Exception
block|{
name|SentinelIntSet
name|ids
init|=
operator|new
name|SentinelIntSet
argument_list|(
name|maxSize
argument_list|,
operator|-
literal|1
argument_list|)
decl_stmt|;
name|String
name|cursorMark
init|=
name|CURSOR_MARK_START
decl_stmt|;
name|int
name|docsOnThisPage
init|=
name|Integer
operator|.
name|MAX_VALUE
decl_stmt|;
while|while
condition|(
literal|0
operator|<
name|docsOnThisPage
condition|)
block|{
name|String
name|json
init|=
name|assertJQ
argument_list|(
name|req
argument_list|(
name|params
argument_list|,
name|CURSOR_MARK_PARAM
argument_list|,
name|cursorMark
argument_list|)
argument_list|)
decl_stmt|;
name|Map
name|rsp
init|=
operator|(
name|Map
operator|)
name|ObjectBuilder
operator|.
name|fromJSON
argument_list|(
name|json
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
literal|"response doesn't contain "
operator|+
name|CURSOR_MARK_NEXT
operator|+
literal|": "
operator|+
name|json
argument_list|,
name|rsp
operator|.
name|containsKey
argument_list|(
name|CURSOR_MARK_NEXT
argument_list|)
argument_list|)
expr_stmt|;
name|String
name|nextCursorMark
init|=
operator|(
name|String
operator|)
name|rsp
operator|.
name|get
argument_list|(
name|CURSOR_MARK_NEXT
argument_list|)
decl_stmt|;
name|assertNotNull
argument_list|(
name|CURSOR_MARK_NEXT
operator|+
literal|" is null"
argument_list|,
name|nextCursorMark
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|Map
argument_list|<
name|Object
argument_list|,
name|Object
argument_list|>
argument_list|>
name|docs
init|=
call|(
name|List
call|)
argument_list|(
operator|(
operator|(
name|Map
operator|)
name|rsp
operator|.
name|get
argument_list|(
literal|"response"
argument_list|)
operator|)
operator|.
name|get
argument_list|(
literal|"docs"
argument_list|)
argument_list|)
decl_stmt|;
name|docsOnThisPage
operator|=
name|docs
operator|.
name|size
argument_list|()
expr_stmt|;
if|if
condition|(
literal|null
operator|!=
name|params
operator|.
name|getInt
argument_list|(
name|CommonParams
operator|.
name|ROWS
argument_list|)
condition|)
block|{
name|int
name|rows
init|=
name|params
operator|.
name|getInt
argument_list|(
name|CommonParams
operator|.
name|ROWS
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
literal|"Too many docs on this page: "
operator|+
name|rows
operator|+
literal|"< "
operator|+
name|docsOnThisPage
argument_list|,
name|docsOnThisPage
operator|<=
name|rows
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
literal|0
operator|==
name|docsOnThisPage
condition|)
block|{
name|assertEquals
argument_list|(
literal|"no more docs, but "
operator|+
name|CURSOR_MARK_NEXT
operator|+
literal|" isn't same"
argument_list|,
name|cursorMark
argument_list|,
name|nextCursorMark
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|Map
argument_list|<
name|Object
argument_list|,
name|Object
argument_list|>
name|doc
range|:
name|docs
control|)
block|{
name|int
name|id
init|=
operator|(
operator|(
name|Long
operator|)
name|doc
operator|.
name|get
argument_list|(
literal|"id"
argument_list|)
operator|)
operator|.
name|intValue
argument_list|()
decl_stmt|;
name|assertFalse
argument_list|(
literal|"walk already seen: "
operator|+
name|id
argument_list|,
name|ids
operator|.
name|exists
argument_list|(
name|id
argument_list|)
argument_list|)
expr_stmt|;
name|ids
operator|.
name|put
argument_list|(
name|id
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
literal|"id set bigger then max allowed ("
operator|+
name|maxSize
operator|+
literal|"): "
operator|+
name|ids
operator|.
name|size
argument_list|()
argument_list|,
name|maxSize
operator|<
name|ids
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|cursorMark
operator|=
name|nextCursorMark
expr_stmt|;
block|}
return|return
name|ids
return|;
block|}
comment|/**    * test faceting with deep paging    */
DECL|method|testFacetingWithRandomSorts
specifier|public
name|void
name|testFacetingWithRandomSorts
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|int
name|numDocs
init|=
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|random
argument_list|()
argument_list|,
literal|1000
argument_list|,
literal|3000
argument_list|)
decl_stmt|;
name|String
index|[]
name|fieldsToFacetOn
init|=
block|{
literal|"int"
block|,
literal|"long"
block|,
literal|"str"
block|}
decl_stmt|;
name|String
index|[]
name|facetMethods
init|=
block|{
literal|"enum"
block|,
literal|"fc"
block|,
literal|"fcs"
block|}
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<=
name|numDocs
condition|;
name|i
operator|++
control|)
block|{
name|SolrInputDocument
name|doc
init|=
name|buildRandomDocument
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|assertU
argument_list|(
name|adoc
argument_list|(
name|doc
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|assertU
argument_list|(
name|commit
argument_list|()
argument_list|)
expr_stmt|;
name|Collection
argument_list|<
name|String
argument_list|>
name|allFieldNames
init|=
name|getAllSortFieldNames
argument_list|()
decl_stmt|;
name|String
index|[]
name|fieldNames
init|=
operator|new
name|String
index|[
name|allFieldNames
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
name|allFieldNames
operator|.
name|toArray
argument_list|(
name|fieldNames
argument_list|)
expr_stmt|;
name|String
name|f
init|=
name|fieldNames
index|[
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|random
argument_list|()
argument_list|,
literal|0
argument_list|,
name|fieldNames
operator|.
name|length
operator|-
literal|1
argument_list|)
index|]
decl_stmt|;
name|String
name|order
init|=
literal|0
operator|==
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|random
argument_list|()
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
condition|?
literal|" asc"
else|:
literal|" desc"
decl_stmt|;
name|String
name|sort
init|=
name|f
operator|+
name|order
operator|+
operator|(
name|f
operator|.
name|equals
argument_list|(
literal|"id"
argument_list|)
condition|?
literal|""
else|:
literal|", id"
operator|+
name|order
operator|)
decl_stmt|;
name|String
name|rows
init|=
literal|""
operator|+
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|random
argument_list|()
argument_list|,
literal|13
argument_list|,
literal|50
argument_list|)
decl_stmt|;
name|String
name|facetField
init|=
name|fieldsToFacetOn
index|[
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|random
argument_list|()
argument_list|,
literal|0
argument_list|,
name|fieldsToFacetOn
operator|.
name|length
operator|-
literal|1
argument_list|)
index|]
decl_stmt|;
name|String
name|facetMethod
init|=
name|facetMethods
index|[
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|random
argument_list|()
argument_list|,
literal|0
argument_list|,
name|facetMethods
operator|.
name|length
operator|-
literal|1
argument_list|)
index|]
decl_stmt|;
name|SentinelIntSet
name|ids
init|=
name|assertFullWalkNoDupsWithFacets
argument_list|(
name|numDocs
argument_list|,
name|params
argument_list|(
literal|"q"
argument_list|,
literal|"*:*"
argument_list|,
literal|"fl"
argument_list|,
literal|"id,"
operator|+
name|facetField
argument_list|,
literal|"facet"
argument_list|,
literal|"true"
argument_list|,
literal|"facet.field"
argument_list|,
name|facetField
argument_list|,
literal|"facet.method"
argument_list|,
name|facetMethod
argument_list|,
literal|"facet.missing"
argument_list|,
literal|"true"
argument_list|,
literal|"facet.limit"
argument_list|,
literal|"-1"
argument_list|,
comment|// unlimited
literal|"rows"
argument_list|,
name|rows
argument_list|,
literal|"sort"
argument_list|,
name|sort
argument_list|)
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|numDocs
argument_list|,
name|ids
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * Given a set of params, executes a cursor query using {@link CursorMarkParams#CURSOR_MARK_START}    * and then continuously walks the results using {@link CursorMarkParams#CURSOR_MARK_START} as long    * as a non-0 number of docs ar returned.  This method records the the set of all id's    * (must be positive ints) encountered and throws an assertion failure if any id is    * encountered more than once, or if the set grows above maxSize.    *    * Also checks that facets are the same with each page, and that they are correct.    */
DECL|method|assertFullWalkNoDupsWithFacets
specifier|public
name|SentinelIntSet
name|assertFullWalkNoDupsWithFacets
parameter_list|(
name|int
name|maxSize
parameter_list|,
name|SolrParams
name|params
parameter_list|)
throws|throws
name|Exception
block|{
specifier|final
name|String
name|facetField
init|=
name|params
operator|.
name|get
argument_list|(
literal|"facet.field"
argument_list|)
decl_stmt|;
name|assertNotNull
argument_list|(
literal|"facet.field param not specified"
argument_list|,
name|facetField
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
literal|"facet.field param contains multiple values"
argument_list|,
name|facetField
operator|.
name|contains
argument_list|(
literal|","
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"facet.limit param not set to -1"
argument_list|,
literal|"-1"
argument_list|,
name|params
operator|.
name|get
argument_list|(
literal|"facet.limit"
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|MutableValueInt
argument_list|>
name|facetCounts
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|SentinelIntSet
name|ids
init|=
operator|new
name|SentinelIntSet
argument_list|(
name|maxSize
argument_list|,
operator|-
literal|1
argument_list|)
decl_stmt|;
name|String
name|cursorMark
init|=
name|CURSOR_MARK_START
decl_stmt|;
name|int
name|docsOnThisPage
init|=
name|Integer
operator|.
name|MAX_VALUE
decl_stmt|;
name|List
name|previousFacets
init|=
literal|null
decl_stmt|;
while|while
condition|(
literal|0
operator|<
name|docsOnThisPage
condition|)
block|{
name|String
name|json
init|=
name|assertJQ
argument_list|(
name|req
argument_list|(
name|params
argument_list|,
name|CURSOR_MARK_PARAM
argument_list|,
name|cursorMark
argument_list|)
argument_list|)
decl_stmt|;
name|Map
name|rsp
init|=
operator|(
name|Map
operator|)
name|ObjectBuilder
operator|.
name|fromJSON
argument_list|(
name|json
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
literal|"response doesn't contain "
operator|+
name|CURSOR_MARK_NEXT
operator|+
literal|": "
operator|+
name|json
argument_list|,
name|rsp
operator|.
name|containsKey
argument_list|(
name|CURSOR_MARK_NEXT
argument_list|)
argument_list|)
expr_stmt|;
name|String
name|nextCursorMark
init|=
operator|(
name|String
operator|)
name|rsp
operator|.
name|get
argument_list|(
name|CURSOR_MARK_NEXT
argument_list|)
decl_stmt|;
name|assertNotNull
argument_list|(
name|CURSOR_MARK_NEXT
operator|+
literal|" is null"
argument_list|,
name|nextCursorMark
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|Map
argument_list|<
name|Object
argument_list|,
name|Object
argument_list|>
argument_list|>
name|docs
init|=
call|(
name|List
call|)
argument_list|(
operator|(
operator|(
name|Map
operator|)
name|rsp
operator|.
name|get
argument_list|(
literal|"response"
argument_list|)
operator|)
operator|.
name|get
argument_list|(
literal|"docs"
argument_list|)
argument_list|)
decl_stmt|;
name|docsOnThisPage
operator|=
name|docs
operator|.
name|size
argument_list|()
expr_stmt|;
if|if
condition|(
literal|null
operator|!=
name|params
operator|.
name|getInt
argument_list|(
name|CommonParams
operator|.
name|ROWS
argument_list|)
condition|)
block|{
name|int
name|rows
init|=
name|params
operator|.
name|getInt
argument_list|(
name|CommonParams
operator|.
name|ROWS
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
literal|"Too many docs on this page: "
operator|+
name|rows
operator|+
literal|"< "
operator|+
name|docsOnThisPage
argument_list|,
name|docsOnThisPage
operator|<=
name|rows
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
literal|0
operator|==
name|docsOnThisPage
condition|)
block|{
name|assertEquals
argument_list|(
literal|"no more docs, but "
operator|+
name|CURSOR_MARK_NEXT
operator|+
literal|" isn't same"
argument_list|,
name|cursorMark
argument_list|,
name|nextCursorMark
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|Map
argument_list|<
name|Object
argument_list|,
name|Object
argument_list|>
name|doc
range|:
name|docs
control|)
block|{
name|int
name|id
init|=
operator|(
operator|(
name|Long
operator|)
name|doc
operator|.
name|get
argument_list|(
literal|"id"
argument_list|)
operator|)
operator|.
name|intValue
argument_list|()
decl_stmt|;
name|assertFalse
argument_list|(
literal|"walk already seen: "
operator|+
name|id
argument_list|,
name|ids
operator|.
name|exists
argument_list|(
name|id
argument_list|)
argument_list|)
expr_stmt|;
name|ids
operator|.
name|put
argument_list|(
name|id
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
literal|"id set bigger then max allowed ("
operator|+
name|maxSize
operator|+
literal|"): "
operator|+
name|ids
operator|.
name|size
argument_list|()
argument_list|,
name|maxSize
operator|<
name|ids
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|Object
name|facet
init|=
name|doc
operator|.
name|get
argument_list|(
name|facetField
argument_list|)
decl_stmt|;
name|String
name|facetString
init|=
literal|null
operator|==
name|facet
condition|?
literal|null
else|:
name|facet
operator|.
name|toString
argument_list|()
decl_stmt|;
comment|// null: missing facet value
name|MutableValueInt
name|count
init|=
name|facetCounts
operator|.
name|get
argument_list|(
name|facetString
argument_list|)
decl_stmt|;
if|if
condition|(
literal|null
operator|==
name|count
condition|)
block|{
name|count
operator|=
operator|new
name|MutableValueInt
argument_list|()
expr_stmt|;
name|facetCounts
operator|.
name|put
argument_list|(
name|facetString
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
operator|++
name|count
operator|.
name|value
expr_stmt|;
block|}
name|cursorMark
operator|=
name|nextCursorMark
expr_stmt|;
name|Map
name|facetFields
init|=
call|(
name|Map
call|)
argument_list|(
operator|(
name|Map
operator|)
name|rsp
operator|.
name|get
argument_list|(
literal|"facet_counts"
argument_list|)
argument_list|)
operator|.
name|get
argument_list|(
literal|"facet_fields"
argument_list|)
decl_stmt|;
name|List
name|facets
init|=
operator|(
name|List
operator|)
name|facetFields
operator|.
name|get
argument_list|(
name|facetField
argument_list|)
decl_stmt|;
if|if
condition|(
literal|null
operator|!=
name|previousFacets
condition|)
block|{
name|assertEquals
argument_list|(
literal|"Facets not the same as on previous page:\nprevious page facets: "
operator|+
name|Arrays
operator|.
name|toString
argument_list|(
name|facets
operator|.
name|toArray
argument_list|(
operator|new
name|Object
index|[
name|facets
operator|.
name|size
argument_list|()
index|]
argument_list|)
argument_list|)
operator|+
literal|"\ncurrent page facets: "
operator|+
name|Arrays
operator|.
name|toString
argument_list|(
name|previousFacets
operator|.
name|toArray
argument_list|(
operator|new
name|Object
index|[
name|previousFacets
operator|.
name|size
argument_list|()
index|]
argument_list|)
argument_list|)
argument_list|,
name|previousFacets
argument_list|,
name|facets
argument_list|)
expr_stmt|;
block|}
name|previousFacets
operator|=
name|facets
expr_stmt|;
block|}
name|assertNotNull
argument_list|(
literal|"previousFacets is null"
argument_list|,
name|previousFacets
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Mismatch in number of facets: "
argument_list|,
name|facetCounts
operator|.
name|size
argument_list|()
argument_list|,
name|previousFacets
operator|.
name|size
argument_list|()
operator|/
literal|2
argument_list|)
expr_stmt|;
name|int
name|pos
decl_stmt|;
for|for
control|(
name|pos
operator|=
literal|0
init|;
name|pos
operator|<
name|previousFacets
operator|.
name|size
argument_list|()
condition|;
name|pos
operator|+=
literal|2
control|)
block|{
name|String
name|label
init|=
operator|(
name|String
operator|)
name|previousFacets
operator|.
name|get
argument_list|(
name|pos
argument_list|)
decl_stmt|;
name|int
name|expectedCount
init|=
operator|(
operator|(
name|Number
operator|)
name|previousFacets
operator|.
name|get
argument_list|(
name|pos
operator|+
literal|1
argument_list|)
operator|)
operator|.
name|intValue
argument_list|()
decl_stmt|;
name|MutableValueInt
name|count
init|=
name|facetCounts
operator|.
name|get
argument_list|(
name|label
argument_list|)
decl_stmt|;
name|assertNotNull
argument_list|(
literal|"Expected facet label #"
operator|+
operator|(
name|pos
operator|/
literal|2
operator|)
operator|+
literal|" not found: '"
operator|+
name|label
operator|+
literal|"'"
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Facet count mismatch for label #"
operator|+
operator|(
name|pos
operator|/
literal|2
operator|)
operator|+
literal|" '"
operator|+
name|label
operator|+
literal|"'"
argument_list|,
name|expectedCount
argument_list|,
name|facetCounts
operator|.
name|get
argument_list|(
name|label
argument_list|)
operator|.
name|value
argument_list|)
expr_stmt|;
name|pos
operator|+=
literal|2
expr_stmt|;
block|}
return|return
name|ids
return|;
block|}
comment|/**    * Asserts that the query matches the specified JSON patterns and then returns the    * {@link CursorMarkParams#CURSOR_MARK_NEXT} value from the response    *    * @see #assertJQ    */
DECL|method|assertCursor
specifier|public
name|String
name|assertCursor
parameter_list|(
name|SolrQueryRequest
name|req
parameter_list|,
name|String
modifier|...
name|tests
parameter_list|)
throws|throws
name|Exception
block|{
name|String
name|json
init|=
name|assertJQ
argument_list|(
name|req
argument_list|,
name|tests
argument_list|)
decl_stmt|;
name|Map
name|rsp
init|=
operator|(
name|Map
operator|)
name|ObjectBuilder
operator|.
name|fromJSON
argument_list|(
name|json
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
literal|"response doesn't contain "
operator|+
name|CURSOR_MARK_NEXT
operator|+
literal|": "
operator|+
name|json
argument_list|,
name|rsp
operator|.
name|containsKey
argument_list|(
name|CURSOR_MARK_NEXT
argument_list|)
argument_list|)
expr_stmt|;
name|String
name|next
init|=
operator|(
name|String
operator|)
name|rsp
operator|.
name|get
argument_list|(
name|CURSOR_MARK_NEXT
argument_list|)
decl_stmt|;
name|assertNotNull
argument_list|(
name|CURSOR_MARK_NEXT
operator|+
literal|" is null"
argument_list|,
name|next
argument_list|)
expr_stmt|;
return|return
name|next
return|;
block|}
comment|/**    * execute a local request, verify that we get an expected error    */
DECL|method|assertFail
specifier|public
name|void
name|assertFail
parameter_list|(
name|SolrParams
name|p
parameter_list|,
name|ErrorCode
name|expCode
parameter_list|,
name|String
name|expSubstr
parameter_list|)
throws|throws
name|Exception
block|{
try|try
block|{
name|ignoreException
argument_list|(
name|expSubstr
argument_list|)
expr_stmt|;
name|assertJQ
argument_list|(
name|req
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"no exception matching expected: "
operator|+
name|expCode
operator|.
name|code
operator|+
literal|": "
operator|+
name|expSubstr
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SolrException
name|e
parameter_list|)
block|{
name|assertEquals
argument_list|(
name|expCode
operator|.
name|code
argument_list|,
name|e
operator|.
name|code
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"Expected substr not found: "
operator|+
name|expSubstr
operator|+
literal|"<!< "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
operator|.
name|getMessage
argument_list|()
operator|.
name|contains
argument_list|(
name|expSubstr
argument_list|)
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|unIgnoreException
argument_list|(
name|expSubstr
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Creates a document with randomized field values, some of which be missing values,     * and some of which will be skewed so that small subsets of the ranges will be     * more common (resulting in an increased likelihood of duplicate values)    *     * @see #buildRandomQuery    */
DECL|method|buildRandomDocument
specifier|public
specifier|static
name|SolrInputDocument
name|buildRandomDocument
parameter_list|(
name|int
name|id
parameter_list|)
block|{
name|SolrInputDocument
name|doc
init|=
name|sdoc
argument_list|(
literal|"id"
argument_list|,
name|id
argument_list|)
decl_stmt|;
comment|// most fields are in most docs
comment|// if field is in a doc, then "skewed" chance val is from a dense range
comment|// (hopefully with lots of duplication)
if|if
condition|(
name|useField
argument_list|()
condition|)
block|{
name|doc
operator|.
name|addField
argument_list|(
literal|"int"
argument_list|,
name|skewed
argument_list|(
name|random
argument_list|()
operator|.
name|nextInt
argument_list|()
argument_list|,
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|random
argument_list|()
argument_list|,
literal|20
argument_list|,
literal|50
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|useField
argument_list|()
condition|)
block|{
name|doc
operator|.
name|addField
argument_list|(
literal|"long"
argument_list|,
name|skewed
argument_list|(
name|random
argument_list|()
operator|.
name|nextLong
argument_list|()
argument_list|,
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|random
argument_list|()
argument_list|,
literal|5000
argument_list|,
literal|5100
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|useField
argument_list|()
condition|)
block|{
name|doc
operator|.
name|addField
argument_list|(
literal|"float"
argument_list|,
name|skewed
argument_list|(
name|random
argument_list|()
operator|.
name|nextFloat
argument_list|()
operator|*
name|random
argument_list|()
operator|.
name|nextInt
argument_list|()
argument_list|,
literal|1.0F
operator|/
name|random
argument_list|()
operator|.
name|nextInt
argument_list|(
literal|23
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|useField
argument_list|()
condition|)
block|{
name|doc
operator|.
name|addField
argument_list|(
literal|"double"
argument_list|,
name|skewed
argument_list|(
name|random
argument_list|()
operator|.
name|nextDouble
argument_list|()
operator|*
name|random
argument_list|()
operator|.
name|nextInt
argument_list|()
argument_list|,
literal|1.0D
operator|/
name|random
argument_list|()
operator|.
name|nextInt
argument_list|(
literal|37
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|useField
argument_list|()
condition|)
block|{
name|doc
operator|.
name|addField
argument_list|(
literal|"str"
argument_list|,
name|skewed
argument_list|(
name|randomXmlUsableUnicodeString
argument_list|()
argument_list|,
name|TestUtil
operator|.
name|randomSimpleString
argument_list|(
name|random
argument_list|()
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|useField
argument_list|()
condition|)
block|{
name|int
name|numBytes
init|=
operator|(
name|int
operator|)
name|skewed
argument_list|(
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|random
argument_list|()
argument_list|,
literal|20
argument_list|,
literal|50
argument_list|)
argument_list|,
literal|2
argument_list|)
decl_stmt|;
name|byte
index|[]
name|randBytes
init|=
operator|new
name|byte
index|[
name|numBytes
index|]
decl_stmt|;
name|random
argument_list|()
operator|.
name|nextBytes
argument_list|(
name|randBytes
argument_list|)
expr_stmt|;
name|doc
operator|.
name|addField
argument_list|(
literal|"bin"
argument_list|,
name|ByteBuffer
operator|.
name|wrap
argument_list|(
name|randBytes
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|useField
argument_list|()
condition|)
block|{
name|doc
operator|.
name|addField
argument_list|(
literal|"date"
argument_list|,
name|skewed
argument_list|(
name|randomDate
argument_list|()
argument_list|,
name|randomSkewedDate
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|useField
argument_list|()
condition|)
block|{
name|doc
operator|.
name|addField
argument_list|(
literal|"uuid"
argument_list|,
name|UUID
operator|.
name|randomUUID
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|useField
argument_list|()
condition|)
block|{
name|doc
operator|.
name|addField
argument_list|(
literal|"currency"
argument_list|,
name|skewed
argument_list|(
literal|""
operator|+
operator|(
name|random
argument_list|()
operator|.
name|nextInt
argument_list|()
operator|/
literal|100.
operator|)
operator|+
literal|","
operator|+
name|randomCurrency
argument_list|()
argument_list|,
literal|""
operator|+
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|random
argument_list|()
argument_list|,
literal|250
argument_list|,
literal|320
argument_list|)
operator|+
literal|",USD"
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|useField
argument_list|()
condition|)
block|{
name|doc
operator|.
name|addField
argument_list|(
literal|"bool"
argument_list|,
name|random
argument_list|()
operator|.
name|nextBoolean
argument_list|()
condition|?
literal|"t"
else|:
literal|"f"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|useField
argument_list|()
condition|)
block|{
name|doc
operator|.
name|addField
argument_list|(
literal|"enum"
argument_list|,
name|randomEnumValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|doc
return|;
block|}
comment|/**    * Generates a random query using the fields populated by     * {@link #buildRandomDocument}.  Queries will typically be fairly simple, but     * won't be so trivial that the scores are completely constant.    */
DECL|method|buildRandomQuery
specifier|public
specifier|static
name|String
name|buildRandomQuery
parameter_list|()
block|{
name|List
argument_list|<
name|String
argument_list|>
name|numericFields
init|=
name|Arrays
operator|.
name|asList
argument_list|(
literal|"int"
argument_list|,
literal|"long"
argument_list|,
literal|"float"
argument_list|,
literal|"double"
argument_list|)
decl_stmt|;
name|Collections
operator|.
name|shuffle
argument_list|(
name|numericFields
argument_list|,
name|random
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|random
argument_list|()
operator|.
name|nextBoolean
argument_list|()
condition|)
block|{
comment|// simple function query across one field.
return|return
literal|"{!func}"
operator|+
name|numericFields
operator|.
name|get
argument_list|(
literal|0
argument_list|)
return|;
block|}
else|else
block|{
comment|// several SHOULD clauses on range queries
name|int
name|low
init|=
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|random
argument_list|()
argument_list|,
operator|-
literal|2379
argument_list|,
literal|2
argument_list|)
decl_stmt|;
name|int
name|high
init|=
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|random
argument_list|()
argument_list|,
literal|4
argument_list|,
literal|5713
argument_list|)
decl_stmt|;
return|return
name|numericFields
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|+
literal|":[* TO 0] "
operator|+
name|numericFields
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|+
literal|":[0 TO *] "
operator|+
name|numericFields
operator|.
name|get
argument_list|(
literal|2
argument_list|)
operator|+
literal|":["
operator|+
name|low
operator|+
literal|" TO "
operator|+
name|high
operator|+
literal|"]"
return|;
block|}
block|}
DECL|field|currencies
specifier|private
specifier|static
specifier|final
name|String
index|[]
name|currencies
init|=
block|{
literal|"USD"
block|,
literal|"EUR"
block|,
literal|"NOK"
block|}
decl_stmt|;
DECL|method|randomCurrency
specifier|public
specifier|static
name|String
name|randomCurrency
parameter_list|()
block|{
return|return
name|currencies
index|[
name|random
argument_list|()
operator|.
name|nextInt
argument_list|(
name|currencies
operator|.
name|length
argument_list|)
index|]
return|;
block|}
DECL|method|randomEnumValue
specifier|private
specifier|static
name|String
name|randomEnumValue
parameter_list|()
block|{
return|return
name|SEVERITY_ENUM_VALUES
index|[
name|random
argument_list|()
operator|.
name|nextInt
argument_list|(
name|SEVERITY_ENUM_VALUES
operator|.
name|length
argument_list|)
index|]
return|;
block|}
comment|/**    * Given a list of fieldNames, builds up a random sort string which is guaranteed to    * have at least 3 clauses, ending with the "id" field for tie breaking    */
DECL|method|buildRandomSort
specifier|public
specifier|static
name|String
name|buildRandomSort
parameter_list|(
specifier|final
name|Collection
argument_list|<
name|String
argument_list|>
name|fieldNames
parameter_list|)
block|{
name|ArrayList
argument_list|<
name|String
argument_list|>
name|shuffledNames
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|fieldNames
argument_list|)
decl_stmt|;
name|Collections
operator|.
name|replaceAll
argument_list|(
name|shuffledNames
argument_list|,
literal|"id"
argument_list|,
literal|"score"
argument_list|)
expr_stmt|;
name|Collections
operator|.
name|shuffle
argument_list|(
name|shuffledNames
argument_list|,
name|random
argument_list|()
argument_list|)
expr_stmt|;
specifier|final
name|StringBuilder
name|result
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
specifier|final
name|int
name|numClauses
init|=
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|random
argument_list|()
argument_list|,
literal|2
argument_list|,
literal|5
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numClauses
condition|;
name|i
operator|++
control|)
block|{
name|String
name|field
init|=
name|shuffledNames
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
comment|// wrap in a function sometimes
if|if
condition|(
operator|!
literal|"score"
operator|.
name|equals
argument_list|(
name|field
argument_list|)
operator|&&
literal|0
operator|==
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|random
argument_list|()
argument_list|,
literal|0
argument_list|,
literal|7
argument_list|)
condition|)
block|{
comment|// specific function doesn't matter, just proving that we can handle the concept.
comment|// but we do have to be careful with non numeric fields
if|if
condition|(
name|field
operator|.
name|contains
argument_list|(
literal|"float"
argument_list|)
operator|||
name|field
operator|.
name|contains
argument_list|(
literal|"double"
argument_list|)
operator|||
name|field
operator|.
name|contains
argument_list|(
literal|"int"
argument_list|)
operator|||
name|field
operator|.
name|contains
argument_list|(
literal|"long"
argument_list|)
condition|)
block|{
name|field
operator|=
literal|"abs("
operator|+
name|field
operator|+
literal|")"
expr_stmt|;
block|}
else|else
block|{
name|field
operator|=
literal|"if(exists("
operator|+
name|field
operator|+
literal|"),47,83)"
expr_stmt|;
block|}
block|}
name|result
operator|.
name|append
argument_list|(
name|field
argument_list|)
operator|.
name|append
argument_list|(
name|random
argument_list|()
operator|.
name|nextBoolean
argument_list|()
condition|?
literal|" asc, "
else|:
literal|" desc, "
argument_list|)
expr_stmt|;
block|}
name|result
operator|.
name|append
argument_list|(
literal|"id"
argument_list|)
operator|.
name|append
argument_list|(
name|random
argument_list|()
operator|.
name|nextBoolean
argument_list|()
condition|?
literal|" asc"
else|:
literal|" desc"
argument_list|)
expr_stmt|;
return|return
name|result
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
end_class
end_unit
