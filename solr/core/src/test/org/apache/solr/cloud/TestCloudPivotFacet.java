begin_unit
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_package
DECL|package|org.apache.solr.cloud
package|package
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|cloud
package|;
end_package
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|lang
operator|.
name|StringUtils
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|TestUtil
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|SolrTestCaseJ4
operator|.
name|SuppressSSL
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|client
operator|.
name|solrj
operator|.
name|SolrServerException
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|client
operator|.
name|solrj
operator|.
name|response
operator|.
name|FieldStatsInfo
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|client
operator|.
name|solrj
operator|.
name|response
operator|.
name|PivotField
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|client
operator|.
name|solrj
operator|.
name|response
operator|.
name|QueryResponse
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|SolrInputDocument
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|params
operator|.
name|FacetParams
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|params
operator|.
name|ModifiableSolrParams
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|params
operator|.
name|SolrParams
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|params
operator|.
name|StatsParams
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|util
operator|.
name|NamedList
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|schema
operator|.
name|TrieDateField
import|;
end_import
begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|BeforeClass
import|;
end_import
begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Test
import|;
end_import
begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import
begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Date
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import
begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|params
operator|.
name|FacetParams
operator|.
name|FACET
import|;
end_import
begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|params
operator|.
name|FacetParams
operator|.
name|FACET_LIMIT
import|;
end_import
begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|params
operator|.
name|FacetParams
operator|.
name|FACET_MISSING
import|;
end_import
begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|params
operator|.
name|FacetParams
operator|.
name|FACET_OFFSET
import|;
end_import
begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|params
operator|.
name|FacetParams
operator|.
name|FACET_OVERREQUEST_COUNT
import|;
end_import
begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|params
operator|.
name|FacetParams
operator|.
name|FACET_OVERREQUEST_RATIO
import|;
end_import
begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|params
operator|.
name|FacetParams
operator|.
name|FACET_PIVOT
import|;
end_import
begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|params
operator|.
name|FacetParams
operator|.
name|FACET_PIVOT_MINCOUNT
import|;
end_import
begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|params
operator|.
name|FacetParams
operator|.
name|FACET_SORT
import|;
end_import
begin_comment
comment|/**  *<p>  * Randomized testing of Pivot Faceting using SolrCloud.  *</p>  *<p>  * After indexing a bunch of random docs, picks some random fields to pivot facet on,   * and then confirms that the resulting counts match the results of filtering on those   * values.  This gives us strong assertions on the correctness of the total counts for   * each pivot value, but no assertions that the correct "top" counts were chosen.  *</p>  *<p>  * NOTE: this test ignores the control collection and only deals with the   * CloudSolrServer - this is because the randomized field values make it very easy for   * the term stats to miss values even with the overrequest.  * (because so many values will tie for "1").  What we care about here is   * that the counts we get back are correct and match what we get when filtering on those   * constraints.  *</p>  *  *  *  */
end_comment
begin_class
annotation|@
name|SuppressSSL
comment|// Too Slow
DECL|class|TestCloudPivotFacet
specifier|public
class|class
name|TestCloudPivotFacet
extends|extends
name|AbstractFullDistribZkTestBase
block|{
DECL|field|log
specifier|public
specifier|static
name|Logger
name|log
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|TestCloudPivotFacet
operator|.
name|class
argument_list|)
decl_stmt|;
comment|// param used by test purely for tracing& validation
DECL|field|TRACE_MIN
specifier|private
specifier|static
name|String
name|TRACE_MIN
init|=
literal|"_test_min"
decl_stmt|;
comment|// param used by test purely for tracing& validation
DECL|field|TRACE_MISS
specifier|private
specifier|static
name|String
name|TRACE_MISS
init|=
literal|"_test_miss"
decl_stmt|;
comment|// param used by test purely for tracing& validation
DECL|field|TRACE_SORT
specifier|private
specifier|static
name|String
name|TRACE_SORT
init|=
literal|"_test_sort"
decl_stmt|;
comment|/**     * Controls the odds of any given doc having a value in any given field -- as this gets lower,     * the counts for "facet.missing" pivots should increase.    * @see #useField()    */
DECL|field|useFieldRandomizedFactor
specifier|private
specifier|static
name|int
name|useFieldRandomizedFactor
init|=
operator|-
literal|1
decl_stmt|;
annotation|@
name|BeforeClass
DECL|method|initUseFieldRandomizedFactor
specifier|public
specifier|static
name|void
name|initUseFieldRandomizedFactor
parameter_list|()
block|{
name|useFieldRandomizedFactor
operator|=
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|random
argument_list|()
argument_list|,
literal|2
argument_list|,
literal|30
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"init'ing useFieldRandomizedFactor = {}"
argument_list|,
name|useFieldRandomizedFactor
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|test
specifier|public
name|void
name|test
parameter_list|()
throws|throws
name|Exception
block|{
name|sanityCheckAssertDoubles
argument_list|()
expr_stmt|;
name|waitForThingsToLevelOut
argument_list|(
literal|30000
argument_list|)
expr_stmt|;
comment|// TODO: why whould we have to wait?
comment|//
name|handle
operator|.
name|clear
argument_list|()
expr_stmt|;
name|handle
operator|.
name|put
argument_list|(
literal|"QTime"
argument_list|,
name|SKIPVAL
argument_list|)
expr_stmt|;
name|handle
operator|.
name|put
argument_list|(
literal|"timestamp"
argument_list|,
name|SKIPVAL
argument_list|)
expr_stmt|;
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|fieldNameSet
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
comment|// build up a randomized index
specifier|final
name|int
name|numDocs
init|=
name|atLeast
argument_list|(
literal|500
argument_list|)
decl_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"numDocs: {}"
argument_list|,
name|numDocs
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<=
name|numDocs
condition|;
name|i
operator|++
control|)
block|{
name|SolrInputDocument
name|doc
init|=
name|buildRandomDocument
argument_list|(
name|i
argument_list|)
decl_stmt|;
comment|// not efficient, but it guarantees that even if people change buildRandomDocument
comment|// we'll always have the full list of fields w/o needing to keep code in sync
name|fieldNameSet
operator|.
name|addAll
argument_list|(
name|doc
operator|.
name|getFieldNames
argument_list|()
argument_list|)
expr_stmt|;
name|cloudClient
operator|.
name|add
argument_list|(
name|doc
argument_list|)
expr_stmt|;
block|}
name|cloudClient
operator|.
name|commit
argument_list|()
expr_stmt|;
name|fieldNameSet
operator|.
name|remove
argument_list|(
literal|"id"
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"WTF, bogus field exists?"
argument_list|,
name|fieldNameSet
operator|.
name|add
argument_list|(
literal|"bogus_not_in_any_doc_s"
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|String
index|[]
name|fieldNames
init|=
name|fieldNameSet
operator|.
name|toArray
argument_list|(
operator|new
name|String
index|[
name|fieldNameSet
operator|.
name|size
argument_list|()
index|]
argument_list|)
decl_stmt|;
name|Arrays
operator|.
name|sort
argument_list|(
name|fieldNames
argument_list|)
expr_stmt|;
comment|// need determinism when picking random fields
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|5
condition|;
name|i
operator|++
control|)
block|{
name|String
name|q
init|=
literal|"*:*"
decl_stmt|;
if|if
condition|(
name|random
argument_list|()
operator|.
name|nextBoolean
argument_list|()
condition|)
block|{
name|q
operator|=
literal|"id:[* TO "
operator|+
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|random
argument_list|()
argument_list|,
literal|300
argument_list|,
name|numDocs
argument_list|)
operator|+
literal|"]"
expr_stmt|;
block|}
name|ModifiableSolrParams
name|baseP
init|=
name|params
argument_list|(
literal|"rows"
argument_list|,
literal|"0"
argument_list|,
literal|"q"
argument_list|,
name|q
argument_list|)
decl_stmt|;
if|if
condition|(
name|random
argument_list|()
operator|.
name|nextBoolean
argument_list|()
condition|)
block|{
name|baseP
operator|.
name|add
argument_list|(
literal|"fq"
argument_list|,
literal|"id:[* TO "
operator|+
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|random
argument_list|()
argument_list|,
literal|200
argument_list|,
name|numDocs
argument_list|)
operator|+
literal|"]"
argument_list|)
expr_stmt|;
block|}
specifier|final
name|boolean
name|stats
init|=
name|random
argument_list|()
operator|.
name|nextBoolean
argument_list|()
decl_stmt|;
if|if
condition|(
name|stats
condition|)
block|{
name|baseP
operator|.
name|add
argument_list|(
name|StatsParams
operator|.
name|STATS
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
comment|// if we are doing stats, then always generated the same # of STATS_FIELD
comment|// params, using multiple tags from a fixed set, but with diff fieldName values.
comment|// later, each pivot will randomly pick a tag.
name|baseP
operator|.
name|add
argument_list|(
name|StatsParams
operator|.
name|STATS_FIELD
argument_list|,
literal|"{!key=sk1 tag=st1,st2}"
operator|+
name|pickRandomStatsFields
argument_list|(
name|fieldNames
argument_list|)
argument_list|)
expr_stmt|;
name|baseP
operator|.
name|add
argument_list|(
name|StatsParams
operator|.
name|STATS_FIELD
argument_list|,
literal|"{!key=sk2 tag=st2,st3}"
operator|+
name|pickRandomStatsFields
argument_list|(
name|fieldNames
argument_list|)
argument_list|)
expr_stmt|;
name|baseP
operator|.
name|add
argument_list|(
name|StatsParams
operator|.
name|STATS_FIELD
argument_list|,
literal|"{!key=sk3 tag=st3,st4}"
operator|+
name|pickRandomStatsFields
argument_list|(
name|fieldNames
argument_list|)
argument_list|)
expr_stmt|;
comment|// NOTE: there's a chance that some of those stats field names
comment|// will be the same, but if so, all the better to test that edge case
block|}
name|ModifiableSolrParams
name|pivotP
init|=
name|params
argument_list|(
name|FACET
argument_list|,
literal|"true"
argument_list|)
decl_stmt|;
name|pivotP
operator|.
name|add
argument_list|(
name|FACET_PIVOT
argument_list|,
name|buildPivotParamValue
argument_list|(
name|buildRandomPivot
argument_list|(
name|fieldNames
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|random
argument_list|()
operator|.
name|nextBoolean
argument_list|()
condition|)
block|{
name|pivotP
operator|.
name|add
argument_list|(
name|FACET_PIVOT
argument_list|,
name|buildPivotParamValue
argument_list|(
name|buildRandomPivot
argument_list|(
name|fieldNames
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// keep limit low - lots of unique values, and lots of depth in pivots
name|pivotP
operator|.
name|add
argument_list|(
name|FACET_LIMIT
argument_list|,
literal|""
operator|+
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|random
argument_list|()
argument_list|,
literal|1
argument_list|,
literal|17
argument_list|)
argument_list|)
expr_stmt|;
comment|// sometimes use an offset
if|if
condition|(
name|random
argument_list|()
operator|.
name|nextBoolean
argument_list|()
condition|)
block|{
name|pivotP
operator|.
name|add
argument_list|(
name|FACET_OFFSET
argument_list|,
literal|""
operator|+
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|random
argument_list|()
argument_list|,
literal|0
argument_list|,
literal|7
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|random
argument_list|()
operator|.
name|nextBoolean
argument_list|()
condition|)
block|{
name|String
name|min
init|=
literal|""
operator|+
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|random
argument_list|()
argument_list|,
literal|0
argument_list|,
name|numDocs
operator|+
literal|10
argument_list|)
decl_stmt|;
name|pivotP
operator|.
name|add
argument_list|(
name|FACET_PIVOT_MINCOUNT
argument_list|,
name|min
argument_list|)
expr_stmt|;
comment|// trace param for validation
name|baseP
operator|.
name|add
argument_list|(
name|TRACE_MIN
argument_list|,
name|min
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|random
argument_list|()
operator|.
name|nextBoolean
argument_list|()
condition|)
block|{
name|String
name|missing
init|=
literal|""
operator|+
name|random
argument_list|()
operator|.
name|nextBoolean
argument_list|()
decl_stmt|;
name|pivotP
operator|.
name|add
argument_list|(
name|FACET_MISSING
argument_list|,
name|missing
argument_list|)
expr_stmt|;
comment|// trace param for validation
name|baseP
operator|.
name|add
argument_list|(
name|TRACE_MISS
argument_list|,
name|missing
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|random
argument_list|()
operator|.
name|nextBoolean
argument_list|()
condition|)
block|{
name|String
name|sort
init|=
name|random
argument_list|()
operator|.
name|nextBoolean
argument_list|()
condition|?
literal|"index"
else|:
literal|"count"
decl_stmt|;
name|pivotP
operator|.
name|add
argument_list|(
name|FACET_SORT
argument_list|,
name|sort
argument_list|)
expr_stmt|;
comment|// trace param for validation
name|baseP
operator|.
name|add
argument_list|(
name|TRACE_SORT
argument_list|,
name|sort
argument_list|)
expr_stmt|;
block|}
comment|// overrequest
comment|//
comment|// NOTE: since this test focuses on accuracy of refinement, and doesn't do
comment|// control collection comparisons, there isn't a lot of need for excessive
comment|// overrequesting -- we focus here on trying to exercise the various edge cases
comment|// involved as different values are used with overrequest
if|if
condition|(
literal|0
operator|==
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|random
argument_list|()
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|)
condition|)
block|{
comment|// we want a decent chance of no overrequest at all
name|pivotP
operator|.
name|add
argument_list|(
name|FACET_OVERREQUEST_COUNT
argument_list|,
literal|"0"
argument_list|)
expr_stmt|;
name|pivotP
operator|.
name|add
argument_list|(
name|FACET_OVERREQUEST_RATIO
argument_list|,
literal|"0"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|random
argument_list|()
operator|.
name|nextBoolean
argument_list|()
condition|)
block|{
name|pivotP
operator|.
name|add
argument_list|(
name|FACET_OVERREQUEST_COUNT
argument_list|,
literal|""
operator|+
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|random
argument_list|()
argument_list|,
literal|0
argument_list|,
literal|5
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|random
argument_list|()
operator|.
name|nextBoolean
argument_list|()
condition|)
block|{
comment|// sometimes give a ratio less then 1, code should be smart enough to deal
name|float
name|ratio
init|=
literal|0.5F
operator|+
name|random
argument_list|()
operator|.
name|nextFloat
argument_list|()
decl_stmt|;
comment|// sometimes go negative
if|if
condition|(
name|random
argument_list|()
operator|.
name|nextBoolean
argument_list|()
condition|)
block|{
name|ratio
operator|*=
operator|-
literal|1
expr_stmt|;
block|}
name|pivotP
operator|.
name|add
argument_list|(
name|FACET_OVERREQUEST_RATIO
argument_list|,
literal|""
operator|+
name|ratio
argument_list|)
expr_stmt|;
block|}
block|}
name|assertPivotCountsAreCorrect
argument_list|(
name|baseP
argument_list|,
name|pivotP
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Given some query params, executes the request against the cloudClient and     * then walks the pivot facet values in the response, treating each one as a     * filter query to assert the pivot counts are correct.    */
DECL|method|assertPivotCountsAreCorrect
specifier|private
name|void
name|assertPivotCountsAreCorrect
parameter_list|(
name|SolrParams
name|baseParams
parameter_list|,
name|SolrParams
name|pivotParams
parameter_list|)
throws|throws
name|SolrServerException
block|{
name|SolrParams
name|initParams
init|=
name|SolrParams
operator|.
name|wrapAppended
argument_list|(
name|pivotParams
argument_list|,
name|baseParams
argument_list|)
decl_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Doing full run: {}"
argument_list|,
name|initParams
argument_list|)
expr_stmt|;
name|countNumFoundChecks
operator|=
literal|0
expr_stmt|;
name|NamedList
argument_list|<
name|List
argument_list|<
name|PivotField
argument_list|>
argument_list|>
name|pivots
init|=
literal|null
decl_stmt|;
try|try
block|{
name|QueryResponse
name|initResponse
init|=
name|cloudClient
operator|.
name|query
argument_list|(
name|initParams
argument_list|)
decl_stmt|;
name|pivots
operator|=
name|initResponse
operator|.
name|getFacetPivot
argument_list|()
expr_stmt|;
name|assertNotNull
argument_list|(
name|initParams
operator|+
literal|" has null pivots?"
argument_list|,
name|pivots
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|initParams
operator|+
literal|" num pivots"
argument_list|,
name|initParams
operator|.
name|getParams
argument_list|(
literal|"facet.pivot"
argument_list|)
operator|.
name|length
argument_list|,
name|pivots
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"init query failed: "
operator|+
name|initParams
operator|+
literal|": "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
try|try
block|{
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|PivotField
argument_list|>
argument_list|>
name|pivot
range|:
name|pivots
control|)
block|{
specifier|final
name|String
name|pivotKey
init|=
name|pivot
operator|.
name|getKey
argument_list|()
decl_stmt|;
comment|// :HACK: for counting the max possible pivot depth
specifier|final
name|int
name|maxDepth
init|=
literal|1
operator|+
name|pivotKey
operator|.
name|length
argument_list|()
operator|-
name|pivotKey
operator|.
name|replace
argument_list|(
literal|","
argument_list|,
literal|""
argument_list|)
operator|.
name|length
argument_list|()
decl_stmt|;
name|assertTraceOk
argument_list|(
name|pivotKey
argument_list|,
name|baseParams
argument_list|,
name|pivot
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
comment|// NOTE: we can't make any assumptions/assertions about the number of
comment|// constraints here because of the random data - which means if pivotting is
comment|// completely broken and there are no constrains this loop could be a No-Op
comment|// but in that case we just have to trust that DistributedFacetPivotTest
comment|// will catch it.
for|for
control|(
name|PivotField
name|constraint
range|:
name|pivot
operator|.
name|getValue
argument_list|()
control|)
block|{
name|int
name|depth
init|=
name|assertPivotCountsAreCorrect
argument_list|(
name|pivotKey
argument_list|,
name|baseParams
argument_list|,
name|constraint
argument_list|)
decl_stmt|;
comment|// we can't assert that the depth reached is the same as the depth requested
comment|// because the fq and/or mincount may have pruned the tree too much
name|assertTrue
argument_list|(
literal|"went too deep: "
operator|+
name|depth
operator|+
literal|": "
operator|+
name|pivotKey
operator|+
literal|" ==> "
operator|+
name|pivot
argument_list|,
name|depth
operator|<=
name|maxDepth
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|AssertionError
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
name|initParams
operator|+
literal|" ==> "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
finally|finally
block|{
name|log
operator|.
name|info
argument_list|(
literal|"Ending full run (countNumFoundChecks={}): {}"
argument_list|,
name|countNumFoundChecks
argument_list|,
name|initParams
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Recursive Helper method for asserting that pivot constraint counds match    * results when filtering on those constraints. Returns the recursive depth reached     * (for sanity checking)    */
DECL|method|assertPivotCountsAreCorrect
specifier|private
name|int
name|assertPivotCountsAreCorrect
parameter_list|(
name|String
name|pivotName
parameter_list|,
name|SolrParams
name|baseParams
parameter_list|,
name|PivotField
name|constraint
parameter_list|)
throws|throws
name|SolrServerException
block|{
name|SolrParams
name|p
init|=
name|SolrParams
operator|.
name|wrapAppended
argument_list|(
name|baseParams
argument_list|,
name|params
argument_list|(
literal|"fq"
argument_list|,
name|buildFilter
argument_list|(
name|constraint
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|PivotField
argument_list|>
name|subPivots
init|=
literal|null
decl_stmt|;
try|try
block|{
name|assertPivotData
argument_list|(
name|pivotName
argument_list|,
name|constraint
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|subPivots
operator|=
name|constraint
operator|.
name|getPivot
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|pivotName
operator|+
literal|": count query failed: "
operator|+
name|p
operator|+
literal|": "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
name|int
name|depth
init|=
literal|0
decl_stmt|;
if|if
condition|(
literal|null
operator|!=
name|subPivots
condition|)
block|{
name|assertTraceOk
argument_list|(
name|pivotName
argument_list|,
name|baseParams
argument_list|,
name|subPivots
argument_list|)
expr_stmt|;
for|for
control|(
name|PivotField
name|subPivot
range|:
name|subPivots
control|)
block|{
name|depth
operator|=
name|assertPivotCountsAreCorrect
argument_list|(
name|pivotName
argument_list|,
name|p
argument_list|,
name|subPivot
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|depth
operator|+
literal|1
return|;
block|}
comment|/**    * Executes a query and compares the results with the data available in the     * {@link PivotField} constraint -- this method is not recursive, and doesn't     * check anything about the sub-pivots (if any).    *    * @param pivotName pivot name    * @param constraint filters on pivot    * @param params base solr parameters    */
DECL|method|assertPivotData
specifier|private
name|void
name|assertPivotData
parameter_list|(
name|String
name|pivotName
parameter_list|,
name|PivotField
name|constraint
parameter_list|,
name|SolrParams
name|params
parameter_list|)
throws|throws
name|SolrServerException
throws|,
name|IOException
block|{
name|SolrParams
name|p
init|=
name|SolrParams
operator|.
name|wrapDefaults
argument_list|(
name|params
argument_list|(
literal|"rows"
argument_list|,
literal|"0"
argument_list|)
argument_list|,
name|params
argument_list|)
decl_stmt|;
name|QueryResponse
name|res
init|=
name|cloudClient
operator|.
name|query
argument_list|(
name|p
argument_list|)
decl_stmt|;
name|String
name|msg
init|=
name|pivotName
operator|+
literal|": "
operator|+
name|p
decl_stmt|;
name|assertNumFound
argument_list|(
name|msg
argument_list|,
name|constraint
operator|.
name|getCount
argument_list|()
argument_list|,
name|res
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|.
name|getBool
argument_list|(
name|StatsParams
operator|.
name|STATS
argument_list|,
literal|false
argument_list|)
condition|)
block|{
comment|// only check stats if stats expected
name|assertPivotStats
argument_list|(
name|msg
argument_list|,
name|constraint
argument_list|,
name|res
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Compare top level stats in response with stats from pivot constraint    */
DECL|method|assertPivotStats
specifier|private
name|void
name|assertPivotStats
parameter_list|(
name|String
name|message
parameter_list|,
name|PivotField
name|constraint
parameter_list|,
name|QueryResponse
name|response
parameter_list|)
throws|throws
name|SolrServerException
block|{
if|if
condition|(
literal|null
operator|==
name|constraint
operator|.
name|getFieldStatsInfo
argument_list|()
condition|)
block|{
comment|// no stats for this pivot, nothing to check
comment|// TODO: use a trace param to know if/how-many to expect ?
name|log
operator|.
name|info
argument_list|(
literal|"No stats to check for => "
operator|+
name|message
argument_list|)
expr_stmt|;
return|return;
block|}
name|Map
argument_list|<
name|String
argument_list|,
name|FieldStatsInfo
argument_list|>
name|actualFieldStatsInfoMap
init|=
name|response
operator|.
name|getFieldStatsInfo
argument_list|()
decl_stmt|;
for|for
control|(
name|FieldStatsInfo
name|pivotStats
range|:
name|constraint
operator|.
name|getFieldStatsInfo
argument_list|()
operator|.
name|values
argument_list|()
control|)
block|{
name|String
name|statsKey
init|=
name|pivotStats
operator|.
name|getName
argument_list|()
decl_stmt|;
name|FieldStatsInfo
name|actualStats
init|=
name|actualFieldStatsInfoMap
operator|.
name|get
argument_list|(
name|statsKey
argument_list|)
decl_stmt|;
if|if
condition|(
name|actualStats
operator|==
literal|null
condition|)
block|{
comment|// handle case for not found stats (using stats query)
comment|//
comment|// these has to be a special case check due to the legacy behavior of "top level"
comment|// StatsComponent results being "null" (and not even included in the
comment|// getFieldStatsInfo() Map due to specila SolrJ logic)
name|log
operator|.
name|info
argument_list|(
literal|"Requested stats missing in verification query, pivot stats: "
operator|+
name|pivotStats
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Special Count"
argument_list|,
literal|0L
argument_list|,
name|pivotStats
operator|.
name|getCount
argument_list|()
operator|.
name|longValue
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Special Missing"
argument_list|,
name|constraint
operator|.
name|getCount
argument_list|()
argument_list|,
name|pivotStats
operator|.
name|getMissing
argument_list|()
operator|.
name|longValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// regular stats, compare everything...
assert|assert
name|actualStats
operator|!=
literal|null
assert|;
name|String
name|msg
init|=
literal|" of "
operator|+
name|statsKey
operator|+
literal|" => "
operator|+
name|message
decl_stmt|;
name|assertEquals
argument_list|(
literal|"Min"
operator|+
name|msg
argument_list|,
name|pivotStats
operator|.
name|getMin
argument_list|()
argument_list|,
name|actualStats
operator|.
name|getMin
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Max"
operator|+
name|msg
argument_list|,
name|pivotStats
operator|.
name|getMax
argument_list|()
argument_list|,
name|actualStats
operator|.
name|getMax
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Mean"
operator|+
name|msg
argument_list|,
name|pivotStats
operator|.
name|getMean
argument_list|()
argument_list|,
name|actualStats
operator|.
name|getMean
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Sum"
operator|+
name|msg
argument_list|,
name|pivotStats
operator|.
name|getSum
argument_list|()
argument_list|,
name|actualStats
operator|.
name|getSum
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Count"
operator|+
name|msg
argument_list|,
name|pivotStats
operator|.
name|getCount
argument_list|()
argument_list|,
name|actualStats
operator|.
name|getCount
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Missing"
operator|+
name|msg
argument_list|,
name|pivotStats
operator|.
name|getMissing
argument_list|()
argument_list|,
name|actualStats
operator|.
name|getMissing
argument_list|()
argument_list|)
expr_stmt|;
name|assertDoubles
argument_list|(
literal|"Stddev"
operator|+
name|msg
argument_list|,
name|pivotStats
operator|.
name|getStddev
argument_list|()
argument_list|,
name|actualStats
operator|.
name|getStddev
argument_list|()
argument_list|)
expr_stmt|;
name|assertDoubles
argument_list|(
literal|"SumOfSquares"
operator|+
name|msg
argument_list|,
name|pivotStats
operator|.
name|getSumOfSquares
argument_list|()
argument_list|,
name|actualStats
operator|.
name|getSumOfSquares
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|constraint
operator|.
name|getFieldStatsInfo
argument_list|()
operator|.
name|containsKey
argument_list|(
literal|"sk2"
argument_list|)
condition|)
block|{
comment|// cheeseball hack
comment|// if "sk2" was one of hte stats we computed, then we must have also seen
comment|// sk1 or sk3 because of the way the tags are fixed
name|assertEquals
argument_list|(
literal|"had stats sk2, but not another stat?"
argument_list|,
literal|2
argument_list|,
name|constraint
operator|.
name|getFieldStatsInfo
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// if we did not see "sk2", then 1 of the others must be alone
name|assertEquals
argument_list|(
literal|"only expected 1 stat"
argument_list|,
literal|1
argument_list|,
name|constraint
operator|.
name|getFieldStatsInfo
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"not sk1 or sk3"
argument_list|,
name|constraint
operator|.
name|getFieldStatsInfo
argument_list|()
operator|.
name|containsKey
argument_list|(
literal|"sk1"
argument_list|)
operator|||
name|constraint
operator|.
name|getFieldStatsInfo
argument_list|()
operator|.
name|containsKey
argument_list|(
literal|"sk3"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Verify that the PivotFields we're lookin at doesn't violate any of the expected     * behaviors based on the<code>TRACE_*</code> params found in the base params    */
DECL|method|assertTraceOk
specifier|private
name|void
name|assertTraceOk
parameter_list|(
name|String
name|pivotName
parameter_list|,
name|SolrParams
name|baseParams
parameter_list|,
name|List
argument_list|<
name|PivotField
argument_list|>
name|constraints
parameter_list|)
block|{
if|if
condition|(
literal|null
operator|==
name|constraints
operator|||
literal|0
operator|==
name|constraints
operator|.
name|size
argument_list|()
condition|)
block|{
return|return;
block|}
specifier|final
name|int
name|maxIdx
init|=
name|constraints
operator|.
name|size
argument_list|()
operator|-
literal|1
decl_stmt|;
specifier|final
name|int
name|min
init|=
name|baseParams
operator|.
name|getInt
argument_list|(
name|TRACE_MIN
argument_list|,
operator|-
literal|1
argument_list|)
decl_stmt|;
specifier|final
name|boolean
name|expectMissing
init|=
name|baseParams
operator|.
name|getBool
argument_list|(
name|TRACE_MISS
argument_list|,
literal|false
argument_list|)
decl_stmt|;
specifier|final
name|boolean
name|checkCount
init|=
literal|"count"
operator|.
name|equals
argument_list|(
name|baseParams
operator|.
name|get
argument_list|(
name|TRACE_SORT
argument_list|,
literal|"count"
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|prevCount
init|=
name|Integer
operator|.
name|MAX_VALUE
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<=
name|maxIdx
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|PivotField
name|constraint
init|=
name|constraints
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
specifier|final
name|int
name|count
init|=
name|constraint
operator|.
name|getCount
argument_list|()
decl_stmt|;
if|if
condition|(
literal|0
operator|<
name|min
condition|)
block|{
name|assertTrue
argument_list|(
name|pivotName
operator|+
literal|": val #"
operator|+
name|i
operator|+
literal|" of "
operator|+
name|maxIdx
operator|+
literal|": count("
operator|+
name|count
operator|+
literal|")< facet.mincount("
operator|+
name|min
operator|+
literal|"): "
operator|+
name|constraint
argument_list|,
name|min
operator|<=
name|count
argument_list|)
expr_stmt|;
block|}
comment|// missing value must always come last, but only if facet.missing was used
comment|// and may not exist at all (mincount, none missing for this sub-facet, etc...)
if|if
condition|(
operator|(
name|i
operator|<
name|maxIdx
operator|)
operator|||
operator|(
operator|!
name|expectMissing
operator|)
condition|)
block|{
name|assertNotNull
argument_list|(
name|pivotName
operator|+
literal|": val #"
operator|+
name|i
operator|+
literal|" of "
operator|+
name|maxIdx
operator|+
literal|" has null value: "
operator|+
name|constraint
argument_list|,
name|constraint
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// if we are expecting count based sort, then the count of each constraint
comment|// must be lt-or-eq the count that came before -- or it must be the last value and
comment|// be "missing"
if|if
condition|(
name|checkCount
condition|)
block|{
name|assertTrue
argument_list|(
name|pivotName
operator|+
literal|": val #"
operator|+
name|i
operator|+
literal|" of"
operator|+
name|maxIdx
operator|+
literal|": count("
operator|+
name|count
operator|+
literal|")> prevCount("
operator|+
name|prevCount
operator|+
literal|"): "
operator|+
name|constraint
argument_list|,
operator|(
operator|(
name|count
operator|<=
name|prevCount
operator|)
operator|||
operator|(
name|expectMissing
operator|&&
name|i
operator|==
name|maxIdx
operator|&&
literal|null
operator|==
name|constraint
operator|.
name|getValue
argument_list|()
operator|)
operator|)
argument_list|)
expr_stmt|;
name|prevCount
operator|=
name|count
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Given a PivotField constraint, generate a query for the field+value    * for use in an<code>fq</code> to verify the constraint count    */
DECL|method|buildFilter
specifier|private
specifier|static
name|String
name|buildFilter
parameter_list|(
name|PivotField
name|constraint
parameter_list|)
block|{
name|Object
name|value
init|=
name|constraint
operator|.
name|getValue
argument_list|()
decl_stmt|;
if|if
condition|(
literal|null
operator|==
name|value
condition|)
block|{
comment|// facet.missing, exclude any indexed term
return|return
literal|"-"
operator|+
name|constraint
operator|.
name|getField
argument_list|()
operator|+
literal|":[* TO *]"
return|;
block|}
comment|// otherwise, build up a term filter...
name|String
name|prefix
init|=
literal|"{!term f="
operator|+
name|constraint
operator|.
name|getField
argument_list|()
operator|+
literal|"}"
decl_stmt|;
if|if
condition|(
name|value
operator|instanceof
name|Date
condition|)
block|{
return|return
name|prefix
operator|+
name|TrieDateField
operator|.
name|formatExternal
argument_list|(
operator|(
name|Date
operator|)
name|value
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|prefix
operator|+
name|value
return|;
block|}
block|}
comment|/**    * Creates a random facet.pivot param string using some of the specified fieldNames    */
DECL|method|buildRandomPivot
specifier|private
specifier|static
name|String
name|buildRandomPivot
parameter_list|(
name|String
index|[]
name|fieldNames
parameter_list|)
block|{
specifier|final
name|int
name|depth
init|=
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|random
argument_list|()
argument_list|,
literal|1
argument_list|,
literal|3
argument_list|)
decl_stmt|;
name|String
index|[]
name|fields
init|=
operator|new
name|String
index|[
name|depth
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|depth
condition|;
name|i
operator|++
control|)
block|{
comment|// yes this means we might use the same field twice
comment|// makes it a robust test (especially for multi-valued fields)
name|fields
index|[
name|i
index|]
operator|=
name|fieldNames
index|[
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|random
argument_list|()
argument_list|,
literal|0
argument_list|,
name|fieldNames
operator|.
name|length
operator|-
literal|1
argument_list|)
index|]
expr_stmt|;
block|}
return|return
name|StringUtils
operator|.
name|join
argument_list|(
name|fields
argument_list|,
literal|","
argument_list|)
return|;
block|}
comment|/**    * Picks a random field to use for Stats    */
DECL|method|pickRandomStatsFields
specifier|private
specifier|static
name|String
name|pickRandomStatsFields
parameter_list|(
name|String
index|[]
name|fieldNames
parameter_list|)
block|{
comment|// we need to skip boolean fields when computing stats
name|String
name|fieldName
decl_stmt|;
do|do
block|{
name|fieldName
operator|=
name|fieldNames
index|[
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|random
argument_list|()
argument_list|,
literal|0
argument_list|,
name|fieldNames
operator|.
name|length
operator|-
literal|1
argument_list|)
index|]
expr_stmt|;
block|}
do|while
condition|(
name|fieldName
operator|.
name|endsWith
argument_list|(
literal|"_b"
argument_list|)
operator|||
name|fieldName
operator|.
name|endsWith
argument_list|(
literal|"_b1"
argument_list|)
condition|)
do|;
return|return
name|fieldName
return|;
block|}
comment|/**    * Generates a random {@link FacetParams#FACET_PIVOT} value w/ local params     * using the specified pivotValue.    */
DECL|method|buildPivotParamValue
specifier|private
specifier|static
name|String
name|buildPivotParamValue
parameter_list|(
name|String
name|pivotValue
parameter_list|)
block|{
comment|// randomly decide which stat tag to use
comment|// if this is 0, or stats aren't enabled, we'll be asking for a tag that doesn't exist
comment|// ...which should be fine (just like excluding a taged fq that doesn't exist)
specifier|final
name|int
name|statTag
init|=
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|random
argument_list|()
argument_list|,
operator|-
literal|1
argument_list|,
literal|4
argument_list|)
decl_stmt|;
if|if
condition|(
literal|0
operator|<=
name|statTag
condition|)
block|{
comment|// only use 1 tag name in the 'stats' localparam - see SOLR-6663
return|return
literal|"{!stats=st"
operator|+
name|statTag
operator|+
literal|"}"
operator|+
name|pivotValue
return|;
block|}
else|else
block|{
comment|// statTag< 0 == sanity check the case of a pivot w/o any stats
return|return
name|pivotValue
return|;
block|}
block|}
comment|/**    * Creates a document with randomized field values, some of which be missing values,     * some of which will be multi-valued (per the schema) and some of which will be     * skewed so that small subsets of the ranges will be more common (resulting in an     * increased likelihood of duplicate values)    *     * @see #buildRandomPivot    */
DECL|method|buildRandomDocument
specifier|private
specifier|static
name|SolrInputDocument
name|buildRandomDocument
parameter_list|(
name|int
name|id
parameter_list|)
block|{
name|SolrInputDocument
name|doc
init|=
name|sdoc
argument_list|(
literal|"id"
argument_list|,
name|id
argument_list|)
decl_stmt|;
comment|// most fields are in most docs
comment|// if field is in a doc, then "skewed" chance val is from a dense range
comment|// (hopefully with lots of duplication)
for|for
control|(
name|String
name|prefix
range|:
operator|new
name|String
index|[]
block|{
literal|"pivot_i"
block|,
literal|"pivot_ti"
block|}
control|)
block|{
if|if
condition|(
name|useField
argument_list|()
condition|)
block|{
name|doc
operator|.
name|addField
argument_list|(
name|prefix
operator|+
literal|"1"
argument_list|,
name|skewed
argument_list|(
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|random
argument_list|()
argument_list|,
literal|20
argument_list|,
literal|50
argument_list|)
argument_list|,
name|random
argument_list|()
operator|.
name|nextInt
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|useField
argument_list|()
condition|)
block|{
name|int
name|numMulti
init|=
name|atLeast
argument_list|(
literal|1
argument_list|)
decl_stmt|;
while|while
condition|(
literal|0
operator|<
name|numMulti
operator|--
condition|)
block|{
name|doc
operator|.
name|addField
argument_list|(
name|prefix
argument_list|,
name|skewed
argument_list|(
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|random
argument_list|()
argument_list|,
literal|20
argument_list|,
literal|50
argument_list|)
argument_list|,
name|random
argument_list|()
operator|.
name|nextInt
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
for|for
control|(
name|String
name|prefix
range|:
operator|new
name|String
index|[]
block|{
literal|"pivot_l"
block|,
literal|"pivot_tl"
block|}
control|)
block|{
if|if
condition|(
name|useField
argument_list|()
condition|)
block|{
name|doc
operator|.
name|addField
argument_list|(
name|prefix
operator|+
literal|"1"
argument_list|,
name|skewed
argument_list|(
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|random
argument_list|()
argument_list|,
literal|5000
argument_list|,
literal|5100
argument_list|)
argument_list|,
name|random
argument_list|()
operator|.
name|nextLong
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|useField
argument_list|()
condition|)
block|{
name|int
name|numMulti
init|=
name|atLeast
argument_list|(
literal|1
argument_list|)
decl_stmt|;
while|while
condition|(
literal|0
operator|<
name|numMulti
operator|--
condition|)
block|{
name|doc
operator|.
name|addField
argument_list|(
name|prefix
argument_list|,
name|skewed
argument_list|(
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|random
argument_list|()
argument_list|,
literal|5000
argument_list|,
literal|5100
argument_list|)
argument_list|,
name|random
argument_list|()
operator|.
name|nextLong
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
for|for
control|(
name|String
name|prefix
range|:
operator|new
name|String
index|[]
block|{
literal|"pivot_f"
block|,
literal|"pivot_tf"
block|}
control|)
block|{
if|if
condition|(
name|useField
argument_list|()
condition|)
block|{
name|doc
operator|.
name|addField
argument_list|(
name|prefix
operator|+
literal|"1"
argument_list|,
name|skewed
argument_list|(
literal|1.0F
operator|/
name|random
argument_list|()
operator|.
name|nextInt
argument_list|(
literal|13
argument_list|)
argument_list|,
name|random
argument_list|()
operator|.
name|nextFloat
argument_list|()
operator|*
name|random
argument_list|()
operator|.
name|nextInt
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|useField
argument_list|()
condition|)
block|{
name|int
name|numMulti
init|=
name|atLeast
argument_list|(
literal|1
argument_list|)
decl_stmt|;
while|while
condition|(
literal|0
operator|<
name|numMulti
operator|--
condition|)
block|{
name|doc
operator|.
name|addField
argument_list|(
name|prefix
argument_list|,
name|skewed
argument_list|(
literal|1.0F
operator|/
name|random
argument_list|()
operator|.
name|nextInt
argument_list|(
literal|13
argument_list|)
argument_list|,
name|random
argument_list|()
operator|.
name|nextFloat
argument_list|()
operator|*
name|random
argument_list|()
operator|.
name|nextInt
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
for|for
control|(
name|String
name|prefix
range|:
operator|new
name|String
index|[]
block|{
literal|"pivot_d"
block|,
literal|"pivot_td"
block|}
control|)
block|{
if|if
condition|(
name|useField
argument_list|()
condition|)
block|{
name|doc
operator|.
name|addField
argument_list|(
name|prefix
operator|+
literal|"1"
argument_list|,
name|skewed
argument_list|(
literal|1.0D
operator|/
name|random
argument_list|()
operator|.
name|nextInt
argument_list|(
literal|19
argument_list|)
argument_list|,
name|random
argument_list|()
operator|.
name|nextDouble
argument_list|()
operator|*
name|random
argument_list|()
operator|.
name|nextInt
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|useField
argument_list|()
condition|)
block|{
name|int
name|numMulti
init|=
name|atLeast
argument_list|(
literal|1
argument_list|)
decl_stmt|;
while|while
condition|(
literal|0
operator|<
name|numMulti
operator|--
condition|)
block|{
name|doc
operator|.
name|addField
argument_list|(
name|prefix
argument_list|,
name|skewed
argument_list|(
literal|1.0D
operator|/
name|random
argument_list|()
operator|.
name|nextInt
argument_list|(
literal|19
argument_list|)
argument_list|,
name|random
argument_list|()
operator|.
name|nextDouble
argument_list|()
operator|*
name|random
argument_list|()
operator|.
name|nextInt
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
for|for
control|(
name|String
name|prefix
range|:
operator|new
name|String
index|[]
block|{
literal|"pivot_dt"
block|,
literal|"pivot_tdt"
block|}
control|)
block|{
if|if
condition|(
name|useField
argument_list|()
condition|)
block|{
name|doc
operator|.
name|addField
argument_list|(
name|prefix
operator|+
literal|"1"
argument_list|,
name|skewed
argument_list|(
name|randomSkewedDate
argument_list|()
argument_list|,
name|randomDate
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|useField
argument_list|()
condition|)
block|{
name|int
name|numMulti
init|=
name|atLeast
argument_list|(
literal|1
argument_list|)
decl_stmt|;
while|while
condition|(
literal|0
operator|<
name|numMulti
operator|--
condition|)
block|{
name|doc
operator|.
name|addField
argument_list|(
name|prefix
argument_list|,
name|skewed
argument_list|(
name|randomSkewedDate
argument_list|()
argument_list|,
name|randomDate
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|{
name|String
name|prefix
init|=
literal|"pivot_b"
decl_stmt|;
if|if
condition|(
name|useField
argument_list|()
condition|)
block|{
name|doc
operator|.
name|addField
argument_list|(
name|prefix
operator|+
literal|"1"
argument_list|,
name|random
argument_list|()
operator|.
name|nextBoolean
argument_list|()
condition|?
literal|"t"
else|:
literal|"f"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|useField
argument_list|()
condition|)
block|{
name|int
name|numMulti
init|=
name|atLeast
argument_list|(
literal|1
argument_list|)
decl_stmt|;
while|while
condition|(
literal|0
operator|<
name|numMulti
operator|--
condition|)
block|{
name|doc
operator|.
name|addField
argument_list|(
name|prefix
argument_list|,
name|random
argument_list|()
operator|.
name|nextBoolean
argument_list|()
condition|?
literal|"t"
else|:
literal|"f"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
for|for
control|(
name|String
name|prefix
range|:
operator|new
name|String
index|[]
block|{
literal|"pivot_x_s"
block|,
literal|"pivot_y_s"
block|,
literal|"pivot_z_s"
block|}
control|)
block|{
if|if
condition|(
name|useField
argument_list|()
condition|)
block|{
name|doc
operator|.
name|addField
argument_list|(
name|prefix
operator|+
literal|"1"
argument_list|,
name|skewed
argument_list|(
name|TestUtil
operator|.
name|randomSimpleString
argument_list|(
name|random
argument_list|()
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
argument_list|,
name|randomXmlUsableUnicodeString
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|useField
argument_list|()
condition|)
block|{
name|int
name|numMulti
init|=
name|atLeast
argument_list|(
literal|1
argument_list|)
decl_stmt|;
while|while
condition|(
literal|0
operator|<
name|numMulti
operator|--
condition|)
block|{
name|doc
operator|.
name|addField
argument_list|(
name|prefix
argument_list|,
name|skewed
argument_list|(
name|TestUtil
operator|.
name|randomSimpleString
argument_list|(
name|random
argument_list|()
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
argument_list|,
name|randomXmlUsableUnicodeString
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|//
comment|// for the remaining fields, make every doc have a value in a dense range
comment|//
for|for
control|(
name|String
name|prefix
range|:
operator|new
name|String
index|[]
block|{
literal|"dense_pivot_x_s"
block|,
literal|"dense_pivot_y_s"
block|}
control|)
block|{
if|if
condition|(
name|useField
argument_list|()
condition|)
block|{
name|doc
operator|.
name|addField
argument_list|(
name|prefix
operator|+
literal|"1"
argument_list|,
name|TestUtil
operator|.
name|randomSimpleString
argument_list|(
name|random
argument_list|()
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|useField
argument_list|()
condition|)
block|{
name|int
name|numMulti
init|=
name|atLeast
argument_list|(
literal|1
argument_list|)
decl_stmt|;
while|while
condition|(
literal|0
operator|<
name|numMulti
operator|--
condition|)
block|{
name|doc
operator|.
name|addField
argument_list|(
name|prefix
argument_list|,
name|TestUtil
operator|.
name|randomSimpleString
argument_list|(
name|random
argument_list|()
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
for|for
control|(
name|String
name|prefix
range|:
operator|new
name|String
index|[]
block|{
literal|"dense_pivot_i"
block|,
literal|"dense_pivot_ti"
block|}
control|)
block|{
if|if
condition|(
name|useField
argument_list|()
condition|)
block|{
name|doc
operator|.
name|addField
argument_list|(
name|prefix
operator|+
literal|"1"
argument_list|,
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|random
argument_list|()
argument_list|,
literal|20
argument_list|,
literal|50
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|useField
argument_list|()
condition|)
block|{
name|int
name|numMulti
init|=
name|atLeast
argument_list|(
literal|1
argument_list|)
decl_stmt|;
while|while
condition|(
literal|0
operator|<
name|numMulti
operator|--
condition|)
block|{
name|doc
operator|.
name|addField
argument_list|(
name|prefix
argument_list|,
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|random
argument_list|()
argument_list|,
literal|20
argument_list|,
literal|50
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|doc
return|;
block|}
comment|/**     * Similar to usually() but we want it to happen just as often regardless    * of test multiplier and nightly status    *    * @see #useFieldRandomizedFactor    */
DECL|method|useField
specifier|private
specifier|static
name|boolean
name|useField
parameter_list|()
block|{
assert|assert
literal|0
operator|<
name|useFieldRandomizedFactor
assert|;
return|return
literal|0
operator|!=
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|random
argument_list|()
argument_list|,
literal|0
argument_list|,
name|useFieldRandomizedFactor
argument_list|)
return|;
block|}
comment|/**    * Asserts the number of docs found in the response    */
DECL|method|assertNumFound
specifier|private
name|void
name|assertNumFound
parameter_list|(
name|String
name|msg
parameter_list|,
name|int
name|expected
parameter_list|,
name|QueryResponse
name|response
parameter_list|)
throws|throws
name|SolrServerException
block|{
name|countNumFoundChecks
operator|++
expr_stmt|;
name|assertEquals
argument_list|(
name|msg
argument_list|,
name|expected
argument_list|,
name|response
operator|.
name|getResults
argument_list|()
operator|.
name|getNumFound
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * Given two objects, asserts that they are either both null, or both Numbers    * with double values that are equally-ish with a "small" epsilon (relative to the     * scale of the expected value)    *    * @see Number#doubleValue    */
DECL|method|assertDoubles
specifier|private
name|void
name|assertDoubles
parameter_list|(
name|String
name|msg
parameter_list|,
name|Object
name|expected
parameter_list|,
name|Object
name|actual
parameter_list|)
block|{
if|if
condition|(
literal|null
operator|==
name|expected
operator|||
literal|null
operator|==
name|actual
condition|)
block|{
name|assertEquals
argument_list|(
name|msg
argument_list|,
name|expected
argument_list|,
name|actual
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|assertTrue
argument_list|(
name|msg
operator|+
literal|" ... expected not a double: "
operator|+
name|expected
operator|+
literal|"=>"
operator|+
name|expected
operator|.
name|getClass
argument_list|()
argument_list|,
name|expected
operator|instanceof
name|Number
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|msg
operator|+
literal|" ... actual not a double: "
operator|+
name|actual
operator|+
literal|"=>"
operator|+
name|actual
operator|.
name|getClass
argument_list|()
argument_list|,
name|actual
operator|instanceof
name|Number
argument_list|)
expr_stmt|;
comment|// compute an epsilon relative to the size of the expected value
name|double
name|expect
init|=
operator|(
operator|(
name|Number
operator|)
name|expected
operator|)
operator|.
name|doubleValue
argument_list|()
decl_stmt|;
name|double
name|epsilon
init|=
name|expect
operator|*
literal|0.1E
operator|-
literal|7D
decl_stmt|;
name|assertEquals
argument_list|(
name|msg
argument_list|,
name|expect
argument_list|,
operator|(
operator|(
name|Number
operator|)
name|actual
operator|)
operator|.
name|doubleValue
argument_list|()
argument_list|,
name|epsilon
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * test the test    */
DECL|method|sanityCheckAssertDoubles
specifier|private
name|void
name|sanityCheckAssertDoubles
parameter_list|()
block|{
name|assertDoubles
argument_list|(
literal|"Null?"
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|assertDoubles
argument_list|(
literal|"big"
argument_list|,
operator|new
name|Double
argument_list|(
literal|2.3005390038169265E9
argument_list|)
argument_list|,
operator|new
name|Double
argument_list|(
literal|2.300539003816927E9
argument_list|)
argument_list|)
expr_stmt|;
name|assertDoubles
argument_list|(
literal|"small"
argument_list|,
operator|new
name|Double
argument_list|(
literal|2.3005390038169265E
operator|-
literal|9
argument_list|)
argument_list|,
operator|new
name|Double
argument_list|(
literal|2.300539003816927E
operator|-
literal|9
argument_list|)
argument_list|)
expr_stmt|;
try|try
block|{
name|assertDoubles
argument_list|(
literal|"non-null"
argument_list|,
literal|null
argument_list|,
literal|42
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"expected was null"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|AssertionError
name|e
parameter_list|)
block|{}
try|try
block|{
name|assertDoubles
argument_list|(
literal|"non-null"
argument_list|,
literal|42
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"actual was null"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|AssertionError
name|e
parameter_list|)
block|{}
try|try
block|{
name|assertDoubles
argument_list|(
literal|"non-number"
argument_list|,
literal|42
argument_list|,
literal|"foo"
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"actual was non-number"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|AssertionError
name|e
parameter_list|)
block|{}
try|try
block|{
name|assertDoubles
argument_list|(
literal|"diff"
argument_list|,
operator|new
name|Double
argument_list|(
literal|2.3005390038169265E9
argument_list|)
argument_list|,
operator|new
name|Double
argument_list|(
literal|2.267272520100462E9
argument_list|)
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"big& diff"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|AssertionError
name|e
parameter_list|)
block|{}
try|try
block|{
name|assertDoubles
argument_list|(
literal|"diff"
argument_list|,
operator|new
name|Double
argument_list|(
literal|2.3005390038169265E
operator|-
literal|9
argument_list|)
argument_list|,
operator|new
name|Double
argument_list|(
literal|2.267272520100462E
operator|-
literal|9
argument_list|)
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"small& diff"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|AssertionError
name|e
parameter_list|)
block|{}
block|}
comment|/**    * @see #assertNumFound    * @see #assertPivotCountsAreCorrect(SolrParams,SolrParams)    */
DECL|field|countNumFoundChecks
specifier|private
name|int
name|countNumFoundChecks
init|=
literal|0
decl_stmt|;
block|}
end_class
end_unit
