begin_unit
begin_package
DECL|package|org.apache.solr.cloud
package|package
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|cloud
package|;
end_package
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|LuceneTestCase
operator|.
name|Slow
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|SolrInputDocument
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|util
operator|.
name|NamedList
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|handler
operator|.
name|CdcrParams
import|;
end_import
begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Test
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Locale
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import
begin_class
annotation|@
name|Slow
DECL|class|CdcrReplicationDistributedZkTest
specifier|public
class|class
name|CdcrReplicationDistributedZkTest
extends|extends
name|BaseCdcrDistributedZkTest
block|{
annotation|@
name|Override
DECL|method|distribSetUp
specifier|public
name|void
name|distribSetUp
parameter_list|()
throws|throws
name|Exception
block|{
name|schemaString
operator|=
literal|"schema15.xml"
expr_stmt|;
comment|// we need a string id
name|super
operator|.
name|distribSetUp
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
annotation|@
name|ShardsFixed
argument_list|(
name|num
operator|=
literal|4
argument_list|)
DECL|method|doTests
specifier|public
name|void
name|doTests
parameter_list|()
throws|throws
name|Exception
block|{
name|this
operator|.
name|doTestDeleteCreateSourceCollection
argument_list|()
expr_stmt|;
name|this
operator|.
name|doTestTargetCollectionNotAvailable
argument_list|()
expr_stmt|;
name|this
operator|.
name|doTestReplicationStartStop
argument_list|()
expr_stmt|;
name|this
operator|.
name|doTestReplicationAfterRestart
argument_list|()
expr_stmt|;
name|this
operator|.
name|doTestReplicationAfterLeaderChange
argument_list|()
expr_stmt|;
name|this
operator|.
name|doTestUpdateLogSynchronisation
argument_list|()
expr_stmt|;
name|this
operator|.
name|doTestBufferOnNonLeader
argument_list|()
expr_stmt|;
name|this
operator|.
name|doTestOps
argument_list|()
expr_stmt|;
name|this
operator|.
name|doTestBatchAddsWithDelete
argument_list|()
expr_stmt|;
name|this
operator|.
name|doTestBatchBoundaries
argument_list|()
expr_stmt|;
name|this
operator|.
name|doTestResilienceWithDeleteByQueryOnTarget
argument_list|()
expr_stmt|;
block|}
comment|/**    * Checks that the test framework handles properly the creation and deletion of collections and the    * restart of servers.    */
DECL|method|doTestDeleteCreateSourceCollection
specifier|public
name|void
name|doTestDeleteCreateSourceCollection
parameter_list|()
throws|throws
name|Exception
block|{
name|this
operator|.
name|clearSourceCollection
argument_list|()
expr_stmt|;
name|this
operator|.
name|clearTargetCollection
argument_list|()
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Indexing documents"
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|SolrInputDocument
argument_list|>
name|docs
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|10
condition|;
name|i
operator|++
control|)
block|{
name|docs
operator|.
name|add
argument_list|(
name|getDoc
argument_list|(
name|id
argument_list|,
name|Integer
operator|.
name|toString
argument_list|(
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|index
argument_list|(
name|SOURCE_COLLECTION
argument_list|,
name|docs
argument_list|)
expr_stmt|;
name|index
argument_list|(
name|TARGET_COLLECTION
argument_list|,
name|docs
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|10
argument_list|,
name|getNumDocs
argument_list|(
name|SOURCE_COLLECTION
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|10
argument_list|,
name|getNumDocs
argument_list|(
name|TARGET_COLLECTION
argument_list|)
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Restarting leader @ source_collection:shard1"
argument_list|)
expr_stmt|;
name|this
operator|.
name|restartServer
argument_list|(
name|shardToLeaderJetty
operator|.
name|get
argument_list|(
name|SOURCE_COLLECTION
argument_list|)
operator|.
name|get
argument_list|(
name|SHARD1
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|10
argument_list|,
name|getNumDocs
argument_list|(
name|SOURCE_COLLECTION
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|10
argument_list|,
name|getNumDocs
argument_list|(
name|TARGET_COLLECTION
argument_list|)
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Clearing source_collection"
argument_list|)
expr_stmt|;
name|this
operator|.
name|clearSourceCollection
argument_list|()
expr_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|getNumDocs
argument_list|(
name|SOURCE_COLLECTION
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|10
argument_list|,
name|getNumDocs
argument_list|(
name|TARGET_COLLECTION
argument_list|)
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Restarting leader @ target_collection:shard1"
argument_list|)
expr_stmt|;
name|this
operator|.
name|restartServer
argument_list|(
name|shardToLeaderJetty
operator|.
name|get
argument_list|(
name|TARGET_COLLECTION
argument_list|)
operator|.
name|get
argument_list|(
name|SHARD1
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|getNumDocs
argument_list|(
name|SOURCE_COLLECTION
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|10
argument_list|,
name|getNumDocs
argument_list|(
name|TARGET_COLLECTION
argument_list|)
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Clearing target_collection"
argument_list|)
expr_stmt|;
name|this
operator|.
name|clearTargetCollection
argument_list|()
expr_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|getNumDocs
argument_list|(
name|SOURCE_COLLECTION
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|getNumDocs
argument_list|(
name|TARGET_COLLECTION
argument_list|)
argument_list|)
expr_stmt|;
name|assertCollectionExpectations
argument_list|(
name|SOURCE_COLLECTION
argument_list|)
expr_stmt|;
name|assertCollectionExpectations
argument_list|(
name|TARGET_COLLECTION
argument_list|)
expr_stmt|;
block|}
DECL|method|doTestTargetCollectionNotAvailable
specifier|public
name|void
name|doTestTargetCollectionNotAvailable
parameter_list|()
throws|throws
name|Exception
block|{
name|this
operator|.
name|clearSourceCollection
argument_list|()
expr_stmt|;
name|this
operator|.
name|clearTargetCollection
argument_list|()
expr_stmt|;
comment|// send start action to first shard
name|NamedList
name|rsp
init|=
name|invokeCdcrAction
argument_list|(
name|shardToLeaderJetty
operator|.
name|get
argument_list|(
name|SOURCE_COLLECTION
argument_list|)
operator|.
name|get
argument_list|(
name|SHARD1
argument_list|)
argument_list|,
name|CdcrParams
operator|.
name|CdcrAction
operator|.
name|START
argument_list|)
decl_stmt|;
name|NamedList
name|status
init|=
operator|(
name|NamedList
operator|)
name|rsp
operator|.
name|get
argument_list|(
name|CdcrParams
operator|.
name|CdcrAction
operator|.
name|STATUS
operator|.
name|toLower
argument_list|()
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|CdcrParams
operator|.
name|ProcessState
operator|.
name|STARTED
operator|.
name|toLower
argument_list|()
argument_list|,
name|status
operator|.
name|get
argument_list|(
name|CdcrParams
operator|.
name|ProcessState
operator|.
name|getParam
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
comment|// check status
name|this
operator|.
name|assertState
argument_list|(
name|SOURCE_COLLECTION
argument_list|,
name|CdcrParams
operator|.
name|ProcessState
operator|.
name|STARTED
argument_list|,
name|CdcrParams
operator|.
name|BufferState
operator|.
name|ENABLED
argument_list|)
expr_stmt|;
comment|// Kill all the servers of the target
name|this
operator|.
name|deleteCollection
argument_list|(
name|TARGET_COLLECTION
argument_list|)
expr_stmt|;
comment|// Index a few documents to trigger the replication
name|index
argument_list|(
name|SOURCE_COLLECTION
argument_list|,
name|getDoc
argument_list|(
name|id
argument_list|,
literal|"a"
argument_list|)
argument_list|)
expr_stmt|;
name|index
argument_list|(
name|SOURCE_COLLECTION
argument_list|,
name|getDoc
argument_list|(
name|id
argument_list|,
literal|"b"
argument_list|)
argument_list|)
expr_stmt|;
name|index
argument_list|(
name|SOURCE_COLLECTION
argument_list|,
name|getDoc
argument_list|(
name|id
argument_list|,
literal|"c"
argument_list|)
argument_list|)
expr_stmt|;
name|index
argument_list|(
name|SOURCE_COLLECTION
argument_list|,
name|getDoc
argument_list|(
name|id
argument_list|,
literal|"d"
argument_list|)
argument_list|)
expr_stmt|;
name|index
argument_list|(
name|SOURCE_COLLECTION
argument_list|,
name|getDoc
argument_list|(
name|id
argument_list|,
literal|"e"
argument_list|)
argument_list|)
expr_stmt|;
name|index
argument_list|(
name|SOURCE_COLLECTION
argument_list|,
name|getDoc
argument_list|(
name|id
argument_list|,
literal|"f"
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|6
argument_list|,
name|getNumDocs
argument_list|(
name|SOURCE_COLLECTION
argument_list|)
argument_list|)
expr_stmt|;
name|Thread
operator|.
name|sleep
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
comment|// wait a bit for the replicator thread to be triggered
name|rsp
operator|=
name|invokeCdcrAction
argument_list|(
name|shardToLeaderJetty
operator|.
name|get
argument_list|(
name|SOURCE_COLLECTION
argument_list|)
operator|.
name|get
argument_list|(
name|SHARD2
argument_list|)
argument_list|,
name|CdcrParams
operator|.
name|CdcrAction
operator|.
name|ERRORS
argument_list|)
expr_stmt|;
name|NamedList
name|collections
init|=
call|(
name|NamedList
call|)
argument_list|(
operator|(
name|NamedList
operator|)
name|rsp
operator|.
name|get
argument_list|(
name|CdcrParams
operator|.
name|ERRORS
argument_list|)
argument_list|)
operator|.
name|getVal
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|NamedList
name|errors
init|=
operator|(
name|NamedList
operator|)
name|collections
operator|.
name|get
argument_list|(
name|TARGET_COLLECTION
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
literal|0
operator|<
operator|(
name|Long
operator|)
name|errors
operator|.
name|get
argument_list|(
name|CdcrParams
operator|.
name|CONSECUTIVE_ERRORS
argument_list|)
argument_list|)
expr_stmt|;
name|NamedList
name|lastErrors
init|=
operator|(
name|NamedList
operator|)
name|errors
operator|.
name|get
argument_list|(
name|CdcrParams
operator|.
name|LAST
argument_list|)
decl_stmt|;
name|assertNotNull
argument_list|(
name|lastErrors
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|0
operator|<
name|lastErrors
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|doTestReplicationStartStop
specifier|public
name|void
name|doTestReplicationStartStop
parameter_list|()
throws|throws
name|Exception
block|{
name|this
operator|.
name|clearSourceCollection
argument_list|()
expr_stmt|;
name|this
operator|.
name|clearTargetCollection
argument_list|()
expr_stmt|;
comment|// this might log a warning to indicate he was not able to delete the collection (collection was deleted in the previous test)
name|int
name|start
init|=
literal|0
decl_stmt|;
name|List
argument_list|<
name|SolrInputDocument
argument_list|>
name|docs
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
init|;
name|start
operator|<
literal|10
condition|;
name|start
operator|++
control|)
block|{
name|docs
operator|.
name|add
argument_list|(
name|getDoc
argument_list|(
name|id
argument_list|,
name|Integer
operator|.
name|toString
argument_list|(
name|start
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|index
argument_list|(
name|SOURCE_COLLECTION
argument_list|,
name|docs
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|10
argument_list|,
name|getNumDocs
argument_list|(
name|SOURCE_COLLECTION
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|getNumDocs
argument_list|(
name|TARGET_COLLECTION
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|invokeCdcrAction
argument_list|(
name|shardToLeaderJetty
operator|.
name|get
argument_list|(
name|SOURCE_COLLECTION
argument_list|)
operator|.
name|get
argument_list|(
name|SHARD1
argument_list|)
argument_list|,
name|CdcrParams
operator|.
name|CdcrAction
operator|.
name|START
argument_list|)
expr_stmt|;
name|this
operator|.
name|waitForCdcrStateReplication
argument_list|(
name|SOURCE_COLLECTION
argument_list|)
expr_stmt|;
name|this
operator|.
name|waitForReplicationToComplete
argument_list|(
name|SOURCE_COLLECTION
argument_list|,
name|SHARD1
argument_list|)
expr_stmt|;
name|this
operator|.
name|waitForReplicationToComplete
argument_list|(
name|SOURCE_COLLECTION
argument_list|,
name|SHARD2
argument_list|)
expr_stmt|;
name|commit
argument_list|(
name|TARGET_COLLECTION
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|10
argument_list|,
name|getNumDocs
argument_list|(
name|SOURCE_COLLECTION
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|10
argument_list|,
name|getNumDocs
argument_list|(
name|TARGET_COLLECTION
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|invokeCdcrAction
argument_list|(
name|shardToLeaderJetty
operator|.
name|get
argument_list|(
name|SOURCE_COLLECTION
argument_list|)
operator|.
name|get
argument_list|(
name|SHARD1
argument_list|)
argument_list|,
name|CdcrParams
operator|.
name|CdcrAction
operator|.
name|STOP
argument_list|)
expr_stmt|;
name|this
operator|.
name|waitForCdcrStateReplication
argument_list|(
name|SOURCE_COLLECTION
argument_list|)
expr_stmt|;
name|docs
operator|.
name|clear
argument_list|()
expr_stmt|;
for|for
control|(
init|;
name|start
operator|<
literal|110
condition|;
name|start
operator|++
control|)
block|{
name|docs
operator|.
name|add
argument_list|(
name|getDoc
argument_list|(
name|id
argument_list|,
name|Integer
operator|.
name|toString
argument_list|(
name|start
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|index
argument_list|(
name|SOURCE_COLLECTION
argument_list|,
name|docs
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|110
argument_list|,
name|getNumDocs
argument_list|(
name|SOURCE_COLLECTION
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|10
argument_list|,
name|getNumDocs
argument_list|(
name|TARGET_COLLECTION
argument_list|)
argument_list|)
expr_stmt|;
comment|// Start again CDCR, the source cluster should reinitialise its log readers
comment|// with the latest checkpoints
name|this
operator|.
name|invokeCdcrAction
argument_list|(
name|shardToLeaderJetty
operator|.
name|get
argument_list|(
name|SOURCE_COLLECTION
argument_list|)
operator|.
name|get
argument_list|(
name|SHARD1
argument_list|)
argument_list|,
name|CdcrParams
operator|.
name|CdcrAction
operator|.
name|START
argument_list|)
expr_stmt|;
name|this
operator|.
name|waitForCdcrStateReplication
argument_list|(
name|SOURCE_COLLECTION
argument_list|)
expr_stmt|;
name|this
operator|.
name|waitForReplicationToComplete
argument_list|(
name|SOURCE_COLLECTION
argument_list|,
name|SHARD1
argument_list|)
expr_stmt|;
name|this
operator|.
name|waitForReplicationToComplete
argument_list|(
name|SOURCE_COLLECTION
argument_list|,
name|SHARD2
argument_list|)
expr_stmt|;
name|commit
argument_list|(
name|TARGET_COLLECTION
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|110
argument_list|,
name|getNumDocs
argument_list|(
name|SOURCE_COLLECTION
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|110
argument_list|,
name|getNumDocs
argument_list|(
name|TARGET_COLLECTION
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Check that the replication manager is properly restarted after a node failure.    */
DECL|method|doTestReplicationAfterRestart
specifier|public
name|void
name|doTestReplicationAfterRestart
parameter_list|()
throws|throws
name|Exception
block|{
name|this
operator|.
name|clearSourceCollection
argument_list|()
expr_stmt|;
name|this
operator|.
name|clearTargetCollection
argument_list|()
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Starting CDCR"
argument_list|)
expr_stmt|;
comment|// send start action to first shard
name|this
operator|.
name|invokeCdcrAction
argument_list|(
name|shardToLeaderJetty
operator|.
name|get
argument_list|(
name|SOURCE_COLLECTION
argument_list|)
operator|.
name|get
argument_list|(
name|SHARD1
argument_list|)
argument_list|,
name|CdcrParams
operator|.
name|CdcrAction
operator|.
name|START
argument_list|)
expr_stmt|;
name|this
operator|.
name|waitForCdcrStateReplication
argument_list|(
name|SOURCE_COLLECTION
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Indexing 10 documents"
argument_list|)
expr_stmt|;
name|int
name|start
init|=
literal|0
decl_stmt|;
name|List
argument_list|<
name|SolrInputDocument
argument_list|>
name|docs
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
init|;
name|start
operator|<
literal|10
condition|;
name|start
operator|++
control|)
block|{
name|docs
operator|.
name|add
argument_list|(
name|getDoc
argument_list|(
name|id
argument_list|,
name|Integer
operator|.
name|toString
argument_list|(
name|start
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|index
argument_list|(
name|SOURCE_COLLECTION
argument_list|,
name|docs
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Querying source collection"
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|10
argument_list|,
name|getNumDocs
argument_list|(
name|SOURCE_COLLECTION
argument_list|)
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Waiting for replication"
argument_list|)
expr_stmt|;
name|this
operator|.
name|waitForReplicationToComplete
argument_list|(
name|SOURCE_COLLECTION
argument_list|,
name|SHARD1
argument_list|)
expr_stmt|;
name|this
operator|.
name|waitForReplicationToComplete
argument_list|(
name|SOURCE_COLLECTION
argument_list|,
name|SHARD2
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Querying target collection"
argument_list|)
expr_stmt|;
name|commit
argument_list|(
name|TARGET_COLLECTION
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|10
argument_list|,
name|getNumDocs
argument_list|(
name|TARGET_COLLECTION
argument_list|)
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Restarting shard1"
argument_list|)
expr_stmt|;
name|this
operator|.
name|restartServers
argument_list|(
name|shardToJetty
operator|.
name|get
argument_list|(
name|SOURCE_COLLECTION
argument_list|)
operator|.
name|get
argument_list|(
name|SHARD1
argument_list|)
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Indexing 100 documents"
argument_list|)
expr_stmt|;
name|docs
operator|.
name|clear
argument_list|()
expr_stmt|;
for|for
control|(
init|;
name|start
operator|<
literal|110
condition|;
name|start
operator|++
control|)
block|{
name|docs
operator|.
name|add
argument_list|(
name|getDoc
argument_list|(
name|id
argument_list|,
name|Integer
operator|.
name|toString
argument_list|(
name|start
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|index
argument_list|(
name|SOURCE_COLLECTION
argument_list|,
name|docs
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Querying source collection"
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|110
argument_list|,
name|getNumDocs
argument_list|(
name|SOURCE_COLLECTION
argument_list|)
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Waiting for replication"
argument_list|)
expr_stmt|;
name|this
operator|.
name|waitForReplicationToComplete
argument_list|(
name|SOURCE_COLLECTION
argument_list|,
name|SHARD1
argument_list|)
expr_stmt|;
name|this
operator|.
name|waitForReplicationToComplete
argument_list|(
name|SOURCE_COLLECTION
argument_list|,
name|SHARD2
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Querying target collection"
argument_list|)
expr_stmt|;
name|commit
argument_list|(
name|TARGET_COLLECTION
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|110
argument_list|,
name|getNumDocs
argument_list|(
name|TARGET_COLLECTION
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Check that the replication manager is properly started after a change of leader.    * This test also checks that the log readers on the new leaders are initialised with    * the target's checkpoint.    */
DECL|method|doTestReplicationAfterLeaderChange
specifier|public
name|void
name|doTestReplicationAfterLeaderChange
parameter_list|()
throws|throws
name|Exception
block|{
name|this
operator|.
name|clearSourceCollection
argument_list|()
expr_stmt|;
name|this
operator|.
name|clearTargetCollection
argument_list|()
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Starting CDCR"
argument_list|)
expr_stmt|;
comment|// send start action to first shard
name|this
operator|.
name|invokeCdcrAction
argument_list|(
name|shardToLeaderJetty
operator|.
name|get
argument_list|(
name|SOURCE_COLLECTION
argument_list|)
operator|.
name|get
argument_list|(
name|SHARD1
argument_list|)
argument_list|,
name|CdcrParams
operator|.
name|CdcrAction
operator|.
name|START
argument_list|)
expr_stmt|;
name|this
operator|.
name|waitForCdcrStateReplication
argument_list|(
name|SOURCE_COLLECTION
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Indexing 10 documents"
argument_list|)
expr_stmt|;
name|int
name|start
init|=
literal|0
decl_stmt|;
name|List
argument_list|<
name|SolrInputDocument
argument_list|>
name|docs
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
init|;
name|start
operator|<
literal|10
condition|;
name|start
operator|++
control|)
block|{
name|docs
operator|.
name|add
argument_list|(
name|getDoc
argument_list|(
name|id
argument_list|,
name|Integer
operator|.
name|toString
argument_list|(
name|start
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|index
argument_list|(
name|SOURCE_COLLECTION
argument_list|,
name|docs
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Querying source collection"
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|10
argument_list|,
name|getNumDocs
argument_list|(
name|SOURCE_COLLECTION
argument_list|)
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Waiting for replication"
argument_list|)
expr_stmt|;
name|this
operator|.
name|waitForReplicationToComplete
argument_list|(
name|SOURCE_COLLECTION
argument_list|,
name|SHARD1
argument_list|)
expr_stmt|;
name|this
operator|.
name|waitForReplicationToComplete
argument_list|(
name|SOURCE_COLLECTION
argument_list|,
name|SHARD2
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Querying target collection"
argument_list|)
expr_stmt|;
name|commit
argument_list|(
name|TARGET_COLLECTION
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|10
argument_list|,
name|getNumDocs
argument_list|(
name|TARGET_COLLECTION
argument_list|)
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Restarting target leaders"
argument_list|)
expr_stmt|;
comment|// Close all the leaders, then restart them
name|this
operator|.
name|restartServer
argument_list|(
name|shardToLeaderJetty
operator|.
name|get
argument_list|(
name|TARGET_COLLECTION
argument_list|)
operator|.
name|get
argument_list|(
name|SHARD1
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|restartServer
argument_list|(
name|shardToLeaderJetty
operator|.
name|get
argument_list|(
name|TARGET_COLLECTION
argument_list|)
operator|.
name|get
argument_list|(
name|SHARD2
argument_list|)
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Restarting source leaders"
argument_list|)
expr_stmt|;
comment|// Close all the leaders, then restart them
name|this
operator|.
name|restartServer
argument_list|(
name|shardToLeaderJetty
operator|.
name|get
argument_list|(
name|SOURCE_COLLECTION
argument_list|)
operator|.
name|get
argument_list|(
name|SHARD1
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|restartServer
argument_list|(
name|shardToLeaderJetty
operator|.
name|get
argument_list|(
name|SOURCE_COLLECTION
argument_list|)
operator|.
name|get
argument_list|(
name|SHARD2
argument_list|)
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Checking queue size of new source leaders"
argument_list|)
expr_stmt|;
comment|// If the log readers of the new leaders are initialised with the target's checkpoint, the
comment|// queue size must be inferior to the current number of documents indexed.
comment|// The queue might be not completely empty since the new target checkpoint is probably not the
comment|// last document received
name|assertTrue
argument_list|(
name|this
operator|.
name|getQueueSize
argument_list|(
name|SOURCE_COLLECTION
argument_list|,
name|SHARD1
argument_list|)
operator|<
literal|10
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|this
operator|.
name|getQueueSize
argument_list|(
name|SOURCE_COLLECTION
argument_list|,
name|SHARD2
argument_list|)
operator|<
literal|10
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Indexing 100 documents"
argument_list|)
expr_stmt|;
name|docs
operator|.
name|clear
argument_list|()
expr_stmt|;
for|for
control|(
init|;
name|start
operator|<
literal|110
condition|;
name|start
operator|++
control|)
block|{
name|docs
operator|.
name|add
argument_list|(
name|getDoc
argument_list|(
name|id
argument_list|,
name|Integer
operator|.
name|toString
argument_list|(
name|start
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|index
argument_list|(
name|SOURCE_COLLECTION
argument_list|,
name|docs
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Querying source collection"
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|110
argument_list|,
name|getNumDocs
argument_list|(
name|SOURCE_COLLECTION
argument_list|)
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Waiting for replication"
argument_list|)
expr_stmt|;
name|this
operator|.
name|waitForReplicationToComplete
argument_list|(
name|SOURCE_COLLECTION
argument_list|,
name|SHARD1
argument_list|)
expr_stmt|;
name|this
operator|.
name|waitForReplicationToComplete
argument_list|(
name|SOURCE_COLLECTION
argument_list|,
name|SHARD2
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Querying target collection"
argument_list|)
expr_stmt|;
name|commit
argument_list|(
name|TARGET_COLLECTION
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|110
argument_list|,
name|getNumDocs
argument_list|(
name|TARGET_COLLECTION
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Check that the update logs are synchronised between leader and non-leader nodes    */
DECL|method|doTestUpdateLogSynchronisation
specifier|public
name|void
name|doTestUpdateLogSynchronisation
parameter_list|()
throws|throws
name|Exception
block|{
name|this
operator|.
name|clearSourceCollection
argument_list|()
expr_stmt|;
name|this
operator|.
name|clearTargetCollection
argument_list|()
expr_stmt|;
comment|// buffering is enabled by default, so disable it
name|this
operator|.
name|invokeCdcrAction
argument_list|(
name|shardToLeaderJetty
operator|.
name|get
argument_list|(
name|SOURCE_COLLECTION
argument_list|)
operator|.
name|get
argument_list|(
name|SHARD1
argument_list|)
argument_list|,
name|CdcrParams
operator|.
name|CdcrAction
operator|.
name|DISABLEBUFFER
argument_list|)
expr_stmt|;
name|this
operator|.
name|waitForCdcrStateReplication
argument_list|(
name|SOURCE_COLLECTION
argument_list|)
expr_stmt|;
name|this
operator|.
name|invokeCdcrAction
argument_list|(
name|shardToLeaderJetty
operator|.
name|get
argument_list|(
name|SOURCE_COLLECTION
argument_list|)
operator|.
name|get
argument_list|(
name|SHARD1
argument_list|)
argument_list|,
name|CdcrParams
operator|.
name|CdcrAction
operator|.
name|START
argument_list|)
expr_stmt|;
name|this
operator|.
name|waitForCdcrStateReplication
argument_list|(
name|SOURCE_COLLECTION
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|50
condition|;
name|i
operator|++
control|)
block|{
comment|// will perform a commit for every document and will create one tlog file per commit
name|index
argument_list|(
name|SOURCE_COLLECTION
argument_list|,
name|getDoc
argument_list|(
name|id
argument_list|,
name|Integer
operator|.
name|toString
argument_list|(
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// wait a bit for the replication to complete
name|this
operator|.
name|waitForReplicationToComplete
argument_list|(
name|SOURCE_COLLECTION
argument_list|,
name|SHARD1
argument_list|)
expr_stmt|;
name|this
operator|.
name|waitForReplicationToComplete
argument_list|(
name|SOURCE_COLLECTION
argument_list|,
name|SHARD2
argument_list|)
expr_stmt|;
name|commit
argument_list|(
name|TARGET_COLLECTION
argument_list|)
expr_stmt|;
comment|// Stop CDCR
name|this
operator|.
name|invokeCdcrAction
argument_list|(
name|shardToLeaderJetty
operator|.
name|get
argument_list|(
name|SOURCE_COLLECTION
argument_list|)
operator|.
name|get
argument_list|(
name|SHARD1
argument_list|)
argument_list|,
name|CdcrParams
operator|.
name|CdcrAction
operator|.
name|STOP
argument_list|)
expr_stmt|;
name|this
operator|.
name|waitForCdcrStateReplication
argument_list|(
name|SOURCE_COLLECTION
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|50
argument_list|,
name|getNumDocs
argument_list|(
name|SOURCE_COLLECTION
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|50
argument_list|,
name|getNumDocs
argument_list|(
name|TARGET_COLLECTION
argument_list|)
argument_list|)
expr_stmt|;
comment|// some of the tlogs should be trimmed, we must have less than 50 tlog files on both leader and non-leader
name|assertNumberOfTlogFiles
argument_list|(
name|SOURCE_COLLECTION
argument_list|,
literal|50
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|50
init|;
name|i
operator|<
literal|100
condition|;
name|i
operator|++
control|)
block|{
name|index
argument_list|(
name|SOURCE_COLLECTION
argument_list|,
name|getDoc
argument_list|(
name|id
argument_list|,
name|Integer
operator|.
name|toString
argument_list|(
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// at this stage, we should have created one tlog file per document, and some of them must have been cleaned on the
comment|// leader since we are not buffering and replication is stopped, (we should have exactly 10 tlog files on the leader
comment|// and 11 on the non-leader)
comment|// the non-leader must have synchronised its update log with its leader
name|assertNumberOfTlogFiles
argument_list|(
name|SOURCE_COLLECTION
argument_list|,
literal|50
argument_list|)
expr_stmt|;
block|}
comment|/**    * Check that the buffer is always activated on non-leader nodes.    */
DECL|method|doTestBufferOnNonLeader
specifier|public
name|void
name|doTestBufferOnNonLeader
parameter_list|()
throws|throws
name|Exception
block|{
name|this
operator|.
name|clearSourceCollection
argument_list|()
expr_stmt|;
name|this
operator|.
name|clearTargetCollection
argument_list|()
expr_stmt|;
comment|// buffering is enabled by default, so disable it
name|this
operator|.
name|invokeCdcrAction
argument_list|(
name|shardToLeaderJetty
operator|.
name|get
argument_list|(
name|SOURCE_COLLECTION
argument_list|)
operator|.
name|get
argument_list|(
name|SHARD1
argument_list|)
argument_list|,
name|CdcrParams
operator|.
name|CdcrAction
operator|.
name|DISABLEBUFFER
argument_list|)
expr_stmt|;
name|this
operator|.
name|waitForCdcrStateReplication
argument_list|(
name|SOURCE_COLLECTION
argument_list|)
expr_stmt|;
comment|// Start CDCR
name|this
operator|.
name|invokeCdcrAction
argument_list|(
name|shardToLeaderJetty
operator|.
name|get
argument_list|(
name|SOURCE_COLLECTION
argument_list|)
operator|.
name|get
argument_list|(
name|SHARD1
argument_list|)
argument_list|,
name|CdcrParams
operator|.
name|CdcrAction
operator|.
name|START
argument_list|)
expr_stmt|;
name|this
operator|.
name|waitForCdcrStateReplication
argument_list|(
name|SOURCE_COLLECTION
argument_list|)
expr_stmt|;
comment|// Index documents
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|200
condition|;
name|i
operator|++
control|)
block|{
name|index
argument_list|(
name|SOURCE_COLLECTION
argument_list|,
name|getDoc
argument_list|(
name|id
argument_list|,
name|Integer
operator|.
name|toString
argument_list|(
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|// will perform a commit for every document
block|}
comment|// And immediately, close all the leaders, then restart them. It is likely that the replication will not be
comment|// performed fully, and therefore be continued by the new leader
comment|// At this stage, the new leader must have been elected
name|this
operator|.
name|restartServer
argument_list|(
name|shardToLeaderJetty
operator|.
name|get
argument_list|(
name|SOURCE_COLLECTION
argument_list|)
operator|.
name|get
argument_list|(
name|SHARD1
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|restartServer
argument_list|(
name|shardToLeaderJetty
operator|.
name|get
argument_list|(
name|SOURCE_COLLECTION
argument_list|)
operator|.
name|get
argument_list|(
name|SHARD2
argument_list|)
argument_list|)
expr_stmt|;
comment|// wait a bit for the replication to complete
name|this
operator|.
name|waitForReplicationToComplete
argument_list|(
name|SOURCE_COLLECTION
argument_list|,
name|SHARD1
argument_list|)
expr_stmt|;
name|this
operator|.
name|waitForReplicationToComplete
argument_list|(
name|SOURCE_COLLECTION
argument_list|,
name|SHARD2
argument_list|)
expr_stmt|;
name|commit
argument_list|(
name|TARGET_COLLECTION
argument_list|)
expr_stmt|;
comment|// If the non-leader node were buffering updates, then the replication must be complete
name|assertEquals
argument_list|(
literal|200
argument_list|,
name|getNumDocs
argument_list|(
name|SOURCE_COLLECTION
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|200
argument_list|,
name|getNumDocs
argument_list|(
name|TARGET_COLLECTION
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Check the ops statistics.    */
DECL|method|doTestOps
specifier|public
name|void
name|doTestOps
parameter_list|()
throws|throws
name|Exception
block|{
name|this
operator|.
name|clearSourceCollection
argument_list|()
expr_stmt|;
name|this
operator|.
name|clearTargetCollection
argument_list|()
expr_stmt|;
comment|// Index documents
name|List
argument_list|<
name|SolrInputDocument
argument_list|>
name|docs
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|200
condition|;
name|i
operator|++
control|)
block|{
name|docs
operator|.
name|add
argument_list|(
name|getDoc
argument_list|(
name|id
argument_list|,
name|Integer
operator|.
name|toString
argument_list|(
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|index
argument_list|(
name|SOURCE_COLLECTION
argument_list|,
name|docs
argument_list|)
expr_stmt|;
comment|// Start CDCR
name|this
operator|.
name|invokeCdcrAction
argument_list|(
name|shardToLeaderJetty
operator|.
name|get
argument_list|(
name|SOURCE_COLLECTION
argument_list|)
operator|.
name|get
argument_list|(
name|SHARD1
argument_list|)
argument_list|,
name|CdcrParams
operator|.
name|CdcrAction
operator|.
name|START
argument_list|)
expr_stmt|;
name|this
operator|.
name|waitForCdcrStateReplication
argument_list|(
name|SOURCE_COLLECTION
argument_list|)
expr_stmt|;
comment|// wait a bit for the replication to complete
name|this
operator|.
name|waitForReplicationToComplete
argument_list|(
name|SOURCE_COLLECTION
argument_list|,
name|SHARD1
argument_list|)
expr_stmt|;
name|this
operator|.
name|waitForReplicationToComplete
argument_list|(
name|SOURCE_COLLECTION
argument_list|,
name|SHARD2
argument_list|)
expr_stmt|;
name|NamedList
name|rsp
init|=
name|this
operator|.
name|invokeCdcrAction
argument_list|(
name|shardToLeaderJetty
operator|.
name|get
argument_list|(
name|SOURCE_COLLECTION
argument_list|)
operator|.
name|get
argument_list|(
name|SHARD1
argument_list|)
argument_list|,
name|CdcrParams
operator|.
name|CdcrAction
operator|.
name|OPS
argument_list|)
decl_stmt|;
name|NamedList
name|collections
init|=
call|(
name|NamedList
call|)
argument_list|(
operator|(
name|NamedList
operator|)
name|rsp
operator|.
name|get
argument_list|(
name|CdcrParams
operator|.
name|OPERATIONS_PER_SECOND
argument_list|)
argument_list|)
operator|.
name|getVal
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|NamedList
name|ops
init|=
operator|(
name|NamedList
operator|)
name|collections
operator|.
name|get
argument_list|(
name|TARGET_COLLECTION
argument_list|)
decl_stmt|;
name|double
name|opsAll
init|=
operator|(
name|Double
operator|)
name|ops
operator|.
name|get
argument_list|(
name|CdcrParams
operator|.
name|COUNTER_ALL
argument_list|)
decl_stmt|;
name|double
name|opsAdds
init|=
operator|(
name|Double
operator|)
name|ops
operator|.
name|get
argument_list|(
name|CdcrParams
operator|.
name|COUNTER_ADDS
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|opsAll
operator|>
literal|0
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|opsAll
argument_list|,
name|opsAdds
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|double
name|opsDeletes
init|=
operator|(
name|Double
operator|)
name|ops
operator|.
name|get
argument_list|(
name|CdcrParams
operator|.
name|COUNTER_DELETES
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|opsDeletes
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/**    * Check that batch updates with deletes    */
DECL|method|doTestBatchAddsWithDelete
specifier|public
name|void
name|doTestBatchAddsWithDelete
parameter_list|()
throws|throws
name|Exception
block|{
name|this
operator|.
name|clearSourceCollection
argument_list|()
expr_stmt|;
name|this
operator|.
name|clearTargetCollection
argument_list|()
expr_stmt|;
comment|// Index 50 documents
name|int
name|start
init|=
literal|0
decl_stmt|;
name|List
argument_list|<
name|SolrInputDocument
argument_list|>
name|docs
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
init|;
name|start
operator|<
literal|50
condition|;
name|start
operator|++
control|)
block|{
name|docs
operator|.
name|add
argument_list|(
name|getDoc
argument_list|(
name|id
argument_list|,
name|Integer
operator|.
name|toString
argument_list|(
name|start
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|index
argument_list|(
name|SOURCE_COLLECTION
argument_list|,
name|docs
argument_list|)
expr_stmt|;
comment|// Delete 10 documents: 10-19
name|List
argument_list|<
name|String
argument_list|>
name|ids
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|id
init|=
literal|10
init|;
name|id
operator|<
literal|20
condition|;
name|id
operator|++
control|)
block|{
name|ids
operator|.
name|add
argument_list|(
name|Integer
operator|.
name|toString
argument_list|(
name|id
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|deleteById
argument_list|(
name|SOURCE_COLLECTION
argument_list|,
name|ids
argument_list|)
expr_stmt|;
comment|// Index 10 documents
name|docs
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
expr_stmt|;
for|for
control|(
init|;
name|start
operator|<
literal|60
condition|;
name|start
operator|++
control|)
block|{
name|docs
operator|.
name|add
argument_list|(
name|getDoc
argument_list|(
name|id
argument_list|,
name|Integer
operator|.
name|toString
argument_list|(
name|start
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|index
argument_list|(
name|SOURCE_COLLECTION
argument_list|,
name|docs
argument_list|)
expr_stmt|;
comment|// Delete 1 document: 50
name|ids
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
expr_stmt|;
name|ids
operator|.
name|add
argument_list|(
name|Integer
operator|.
name|toString
argument_list|(
literal|50
argument_list|)
argument_list|)
expr_stmt|;
name|deleteById
argument_list|(
name|SOURCE_COLLECTION
argument_list|,
name|ids
argument_list|)
expr_stmt|;
comment|// Index 10 documents
name|docs
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
expr_stmt|;
for|for
control|(
init|;
name|start
operator|<
literal|70
condition|;
name|start
operator|++
control|)
block|{
name|docs
operator|.
name|add
argument_list|(
name|getDoc
argument_list|(
name|id
argument_list|,
name|Integer
operator|.
name|toString
argument_list|(
name|start
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|index
argument_list|(
name|SOURCE_COLLECTION
argument_list|,
name|docs
argument_list|)
expr_stmt|;
comment|// Start CDCR
name|this
operator|.
name|invokeCdcrAction
argument_list|(
name|shardToLeaderJetty
operator|.
name|get
argument_list|(
name|SOURCE_COLLECTION
argument_list|)
operator|.
name|get
argument_list|(
name|SHARD1
argument_list|)
argument_list|,
name|CdcrParams
operator|.
name|CdcrAction
operator|.
name|START
argument_list|)
expr_stmt|;
name|this
operator|.
name|waitForCdcrStateReplication
argument_list|(
name|SOURCE_COLLECTION
argument_list|)
expr_stmt|;
comment|// wait a bit for the replication to complete
name|this
operator|.
name|waitForReplicationToComplete
argument_list|(
name|SOURCE_COLLECTION
argument_list|,
name|SHARD1
argument_list|)
expr_stmt|;
name|this
operator|.
name|waitForReplicationToComplete
argument_list|(
name|SOURCE_COLLECTION
argument_list|,
name|SHARD2
argument_list|)
expr_stmt|;
name|commit
argument_list|(
name|TARGET_COLLECTION
argument_list|)
expr_stmt|;
comment|// If the non-leader node were buffering updates, then the replication must be complete
name|assertEquals
argument_list|(
literal|59
argument_list|,
name|getNumDocs
argument_list|(
name|SOURCE_COLLECTION
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|59
argument_list|,
name|getNumDocs
argument_list|(
name|TARGET_COLLECTION
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Checks that batches are correctly constructed when batch boundaries are reached.    */
DECL|method|doTestBatchBoundaries
specifier|public
name|void
name|doTestBatchBoundaries
parameter_list|()
throws|throws
name|Exception
block|{
name|this
operator|.
name|invokeCdcrAction
argument_list|(
name|shardToLeaderJetty
operator|.
name|get
argument_list|(
name|SOURCE_COLLECTION
argument_list|)
operator|.
name|get
argument_list|(
name|SHARD1
argument_list|)
argument_list|,
name|CdcrParams
operator|.
name|CdcrAction
operator|.
name|START
argument_list|)
expr_stmt|;
name|this
operator|.
name|waitForCdcrStateReplication
argument_list|(
name|SOURCE_COLLECTION
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Indexing documents"
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|SolrInputDocument
argument_list|>
name|docs
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|128
condition|;
name|i
operator|++
control|)
block|{
comment|// should create two full batches (default batch = 64)
name|docs
operator|.
name|add
argument_list|(
name|getDoc
argument_list|(
name|id
argument_list|,
name|Integer
operator|.
name|toString
argument_list|(
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|index
argument_list|(
name|SOURCE_COLLECTION
argument_list|,
name|docs
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|128
argument_list|,
name|getNumDocs
argument_list|(
name|SOURCE_COLLECTION
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|waitForReplicationToComplete
argument_list|(
name|SOURCE_COLLECTION
argument_list|,
name|SHARD1
argument_list|)
expr_stmt|;
name|this
operator|.
name|waitForReplicationToComplete
argument_list|(
name|SOURCE_COLLECTION
argument_list|,
name|SHARD2
argument_list|)
expr_stmt|;
name|commit
argument_list|(
name|TARGET_COLLECTION
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|128
argument_list|,
name|getNumDocs
argument_list|(
name|SOURCE_COLLECTION
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|128
argument_list|,
name|getNumDocs
argument_list|(
name|TARGET_COLLECTION
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Check resilience of replication with delete by query executed on targets    */
DECL|method|doTestResilienceWithDeleteByQueryOnTarget
specifier|public
name|void
name|doTestResilienceWithDeleteByQueryOnTarget
parameter_list|()
throws|throws
name|Exception
block|{
name|this
operator|.
name|clearSourceCollection
argument_list|()
expr_stmt|;
name|this
operator|.
name|clearTargetCollection
argument_list|()
expr_stmt|;
comment|// Index 50 documents
name|int
name|start
init|=
literal|0
decl_stmt|;
name|List
argument_list|<
name|SolrInputDocument
argument_list|>
name|docs
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
init|;
name|start
operator|<
literal|50
condition|;
name|start
operator|++
control|)
block|{
name|docs
operator|.
name|add
argument_list|(
name|getDoc
argument_list|(
name|id
argument_list|,
name|Integer
operator|.
name|toString
argument_list|(
name|start
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|index
argument_list|(
name|SOURCE_COLLECTION
argument_list|,
name|docs
argument_list|)
expr_stmt|;
comment|// Start CDCR
name|this
operator|.
name|invokeCdcrAction
argument_list|(
name|shardToLeaderJetty
operator|.
name|get
argument_list|(
name|SOURCE_COLLECTION
argument_list|)
operator|.
name|get
argument_list|(
name|SHARD1
argument_list|)
argument_list|,
name|CdcrParams
operator|.
name|CdcrAction
operator|.
name|START
argument_list|)
expr_stmt|;
name|this
operator|.
name|waitForCdcrStateReplication
argument_list|(
name|SOURCE_COLLECTION
argument_list|)
expr_stmt|;
comment|// wait a bit for the replication to complete
name|this
operator|.
name|waitForReplicationToComplete
argument_list|(
name|SOURCE_COLLECTION
argument_list|,
name|SHARD1
argument_list|)
expr_stmt|;
name|this
operator|.
name|waitForReplicationToComplete
argument_list|(
name|SOURCE_COLLECTION
argument_list|,
name|SHARD2
argument_list|)
expr_stmt|;
name|commit
argument_list|(
name|TARGET_COLLECTION
argument_list|)
expr_stmt|;
comment|// If the non-leader node were buffering updates, then the replication must be complete
name|assertEquals
argument_list|(
literal|50
argument_list|,
name|getNumDocs
argument_list|(
name|SOURCE_COLLECTION
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|50
argument_list|,
name|getNumDocs
argument_list|(
name|TARGET_COLLECTION
argument_list|)
argument_list|)
expr_stmt|;
name|deleteByQuery
argument_list|(
name|SOURCE_COLLECTION
argument_list|,
literal|"*:*"
argument_list|)
expr_stmt|;
name|deleteByQuery
argument_list|(
name|TARGET_COLLECTION
argument_list|,
literal|"*:*"
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|getNumDocs
argument_list|(
name|SOURCE_COLLECTION
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|getNumDocs
argument_list|(
name|TARGET_COLLECTION
argument_list|)
argument_list|)
expr_stmt|;
name|docs
operator|.
name|clear
argument_list|()
expr_stmt|;
for|for
control|(
init|;
name|start
operator|<
literal|100
condition|;
name|start
operator|++
control|)
block|{
name|docs
operator|.
name|add
argument_list|(
name|getDoc
argument_list|(
name|id
argument_list|,
name|Integer
operator|.
name|toString
argument_list|(
name|start
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|index
argument_list|(
name|SOURCE_COLLECTION
argument_list|,
name|docs
argument_list|)
expr_stmt|;
comment|// wait a bit for the replication to complete
name|this
operator|.
name|waitForReplicationToComplete
argument_list|(
name|SOURCE_COLLECTION
argument_list|,
name|SHARD1
argument_list|)
expr_stmt|;
name|this
operator|.
name|waitForReplicationToComplete
argument_list|(
name|SOURCE_COLLECTION
argument_list|,
name|SHARD2
argument_list|)
expr_stmt|;
name|commit
argument_list|(
name|TARGET_COLLECTION
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|50
argument_list|,
name|getNumDocs
argument_list|(
name|SOURCE_COLLECTION
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|50
argument_list|,
name|getNumDocs
argument_list|(
name|TARGET_COLLECTION
argument_list|)
argument_list|)
expr_stmt|;
name|deleteByQuery
argument_list|(
name|TARGET_COLLECTION
argument_list|,
literal|"*:*"
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|50
argument_list|,
name|getNumDocs
argument_list|(
name|SOURCE_COLLECTION
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|getNumDocs
argument_list|(
name|TARGET_COLLECTION
argument_list|)
argument_list|)
expr_stmt|;
comment|// Restart CDCR
name|this
operator|.
name|invokeCdcrAction
argument_list|(
name|shardToLeaderJetty
operator|.
name|get
argument_list|(
name|SOURCE_COLLECTION
argument_list|)
operator|.
name|get
argument_list|(
name|SHARD1
argument_list|)
argument_list|,
name|CdcrParams
operator|.
name|CdcrAction
operator|.
name|STOP
argument_list|)
expr_stmt|;
name|this
operator|.
name|waitForCdcrStateReplication
argument_list|(
name|SOURCE_COLLECTION
argument_list|)
expr_stmt|;
name|this
operator|.
name|invokeCdcrAction
argument_list|(
name|shardToLeaderJetty
operator|.
name|get
argument_list|(
name|SOURCE_COLLECTION
argument_list|)
operator|.
name|get
argument_list|(
name|SHARD1
argument_list|)
argument_list|,
name|CdcrParams
operator|.
name|CdcrAction
operator|.
name|START
argument_list|)
expr_stmt|;
name|this
operator|.
name|waitForCdcrStateReplication
argument_list|(
name|SOURCE_COLLECTION
argument_list|)
expr_stmt|;
name|docs
operator|.
name|clear
argument_list|()
expr_stmt|;
for|for
control|(
init|;
name|start
operator|<
literal|150
condition|;
name|start
operator|++
control|)
block|{
name|docs
operator|.
name|add
argument_list|(
name|getDoc
argument_list|(
name|id
argument_list|,
name|Integer
operator|.
name|toString
argument_list|(
name|start
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|index
argument_list|(
name|SOURCE_COLLECTION
argument_list|,
name|docs
argument_list|)
expr_stmt|;
comment|// wait a bit for the replication to complete
name|this
operator|.
name|waitForReplicationToComplete
argument_list|(
name|SOURCE_COLLECTION
argument_list|,
name|SHARD1
argument_list|)
expr_stmt|;
name|this
operator|.
name|waitForReplicationToComplete
argument_list|(
name|SOURCE_COLLECTION
argument_list|,
name|SHARD2
argument_list|)
expr_stmt|;
name|commit
argument_list|(
name|TARGET_COLLECTION
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|100
argument_list|,
name|getNumDocs
argument_list|(
name|SOURCE_COLLECTION
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|50
argument_list|,
name|getNumDocs
argument_list|(
name|TARGET_COLLECTION
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Asserts the number of transaction logs across all the shards. Since the cleaning of the update logs    * is not immediate on the slave nodes (it relies on the update log synchronizer that is executed every second),    * it will retry until the assert is successful or until the timeout.    */
DECL|method|assertNumberOfTlogFiles
specifier|protected
name|void
name|assertNumberOfTlogFiles
parameter_list|(
name|String
name|collection
parameter_list|,
name|int
name|maxNumberOfTLogs
parameter_list|)
throws|throws
name|Exception
block|{
name|int
name|cnt
init|=
literal|15
decl_stmt|;
comment|// timeout after 15 seconds
name|AssertionError
name|lastAssertionError
init|=
literal|null
decl_stmt|;
while|while
condition|(
name|cnt
operator|>
literal|0
condition|)
block|{
try|try
block|{
comment|// Fire a DeleteById query with a commit to trigger update log cleaning on the non-leader nodes
name|List
argument_list|<
name|String
argument_list|>
name|ids
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|ids
operator|.
name|add
argument_list|(
literal|"_NON_EXISTING_ID_"
argument_list|)
expr_stmt|;
name|deleteById
argument_list|(
name|collection
argument_list|,
name|ids
argument_list|)
expr_stmt|;
comment|// Check the update logs
name|this
operator|.
name|_assertNumberOfTlogFiles
argument_list|(
name|collection
argument_list|,
name|maxNumberOfTLogs
argument_list|)
expr_stmt|;
return|return;
block|}
catch|catch
parameter_list|(
name|AssertionError
name|e
parameter_list|)
block|{
name|lastAssertionError
operator|=
name|e
expr_stmt|;
name|cnt
operator|--
expr_stmt|;
name|Thread
operator|.
name|sleep
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
block|}
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"Timeout while trying to assert update logs @ collection="
operator|+
name|collection
argument_list|,
name|lastAssertionError
argument_list|)
throw|;
block|}
comment|/**    * Asserts the number of transaction logs across all the shards    */
DECL|method|_assertNumberOfTlogFiles
specifier|private
name|void
name|_assertNumberOfTlogFiles
parameter_list|(
name|String
name|collection
parameter_list|,
name|int
name|maxNumberOfTLogs
parameter_list|)
throws|throws
name|Exception
block|{
name|CollectionInfo
name|info
init|=
name|collectInfo
argument_list|(
name|collection
argument_list|)
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|CollectionInfo
operator|.
name|CoreInfo
argument_list|>
argument_list|>
name|shardToCoresMap
init|=
name|info
operator|.
name|getShardToCoresMap
argument_list|()
decl_stmt|;
name|int
name|leaderLogs
init|=
literal|0
decl_stmt|;
name|ArrayList
argument_list|<
name|Integer
argument_list|>
name|replicasLogs
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|Collections
operator|.
name|nCopies
argument_list|(
name|replicationFactor
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|shard
range|:
name|shardToCoresMap
operator|.
name|keySet
argument_list|()
control|)
block|{
name|leaderLogs
operator|+=
name|numberOfFiles
argument_list|(
name|info
operator|.
name|getLeader
argument_list|(
name|shard
argument_list|)
operator|.
name|ulogDir
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|replicationFactor
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|replicasLogs
operator|.
name|set
argument_list|(
name|i
argument_list|,
name|replicasLogs
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|+
name|numberOfFiles
argument_list|(
name|info
operator|.
name|getReplicas
argument_list|(
name|shard
argument_list|)
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|ulogDir
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|Integer
name|replicaLogs
range|:
name|replicasLogs
control|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"Number of logs in update log on leader {} and on replica {}"
argument_list|,
name|leaderLogs
argument_list|,
name|replicaLogs
argument_list|)
expr_stmt|;
comment|// replica logs must be always equal or superior to leader logs
name|assertTrue
argument_list|(
name|String
operator|.
name|format
argument_list|(
name|Locale
operator|.
name|ENGLISH
argument_list|,
literal|"Number of tlogs on replica: %d is different than on leader: %d."
argument_list|,
name|replicaLogs
argument_list|,
name|leaderLogs
argument_list|)
argument_list|,
name|leaderLogs
operator|<=
name|replicaLogs
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|String
operator|.
name|format
argument_list|(
name|Locale
operator|.
name|ENGLISH
argument_list|,
literal|"Number of tlogs on leader: %d is superior to: %d."
argument_list|,
name|leaderLogs
argument_list|,
name|maxNumberOfTLogs
argument_list|)
argument_list|,
name|maxNumberOfTLogs
operator|>=
name|leaderLogs
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|String
operator|.
name|format
argument_list|(
name|Locale
operator|.
name|ENGLISH
argument_list|,
literal|"Number of tlogs on replica: %d is superior to: %d."
argument_list|,
name|replicaLogs
argument_list|,
name|maxNumberOfTLogs
argument_list|)
argument_list|,
name|maxNumberOfTLogs
operator|>=
name|replicaLogs
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|numberOfFiles
specifier|private
name|int
name|numberOfFiles
parameter_list|(
name|String
name|dir
parameter_list|)
block|{
name|File
name|file
init|=
operator|new
name|File
argument_list|(
name|dir
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|file
operator|.
name|isDirectory
argument_list|()
condition|)
block|{
name|assertTrue
argument_list|(
literal|"Path to tlog "
operator|+
name|dir
operator|+
literal|" does not exists or it's not a directory."
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
name|log
operator|.
name|debug
argument_list|(
literal|"Update log dir {} contains: {}"
argument_list|,
name|dir
argument_list|,
name|file
operator|.
name|listFiles
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|file
operator|.
name|listFiles
argument_list|()
operator|.
name|length
return|;
block|}
block|}
end_class
end_unit
