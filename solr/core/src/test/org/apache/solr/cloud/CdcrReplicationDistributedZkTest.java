begin_unit
begin_package
DECL|package|org.apache.solr.cloud
package|package
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|cloud
package|;
end_package
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_import
import|import
name|com
operator|.
name|carrotsearch
operator|.
name|randomizedtesting
operator|.
name|annotations
operator|.
name|ThreadLeakLingering
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|LuceneTestCase
operator|.
name|Slow
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|LuceneTestCase
operator|.
name|Nightly
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|SolrInputDocument
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|util
operator|.
name|NamedList
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|handler
operator|.
name|CdcrParams
import|;
end_import
begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Test
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import
begin_class
annotation|@
name|Nightly
DECL|class|CdcrReplicationDistributedZkTest
specifier|public
class|class
name|CdcrReplicationDistributedZkTest
extends|extends
name|BaseCdcrDistributedZkTest
block|{
annotation|@
name|Override
DECL|method|distribSetUp
specifier|public
name|void
name|distribSetUp
parameter_list|()
throws|throws
name|Exception
block|{
name|schemaString
operator|=
literal|"schema15.xml"
expr_stmt|;
comment|// we need a string id
name|super
operator|.
name|distribSetUp
argument_list|()
expr_stmt|;
block|}
comment|/**    * Checks that the test framework handles properly the creation and deletion of collections and the    * restart of servers.    */
annotation|@
name|Test
annotation|@
name|ShardsFixed
argument_list|(
name|num
operator|=
literal|4
argument_list|)
DECL|method|testDeleteCreateSourceCollection
specifier|public
name|void
name|testDeleteCreateSourceCollection
parameter_list|()
throws|throws
name|Exception
block|{
name|log
operator|.
name|info
argument_list|(
literal|"Indexing documents"
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|SolrInputDocument
argument_list|>
name|docs
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|10
condition|;
name|i
operator|++
control|)
block|{
name|docs
operator|.
name|add
argument_list|(
name|getDoc
argument_list|(
name|id
argument_list|,
name|Integer
operator|.
name|toString
argument_list|(
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|index
argument_list|(
name|SOURCE_COLLECTION
argument_list|,
name|docs
argument_list|)
expr_stmt|;
name|index
argument_list|(
name|TARGET_COLLECTION
argument_list|,
name|docs
argument_list|)
expr_stmt|;
name|assertNumDocs
argument_list|(
literal|10
argument_list|,
name|SOURCE_COLLECTION
argument_list|)
expr_stmt|;
name|assertNumDocs
argument_list|(
literal|10
argument_list|,
name|TARGET_COLLECTION
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Restarting leader @ source_collection:shard1"
argument_list|)
expr_stmt|;
name|this
operator|.
name|restartServer
argument_list|(
name|shardToLeaderJetty
operator|.
name|get
argument_list|(
name|SOURCE_COLLECTION
argument_list|)
operator|.
name|get
argument_list|(
name|SHARD1
argument_list|)
argument_list|)
expr_stmt|;
name|assertNumDocs
argument_list|(
literal|10
argument_list|,
name|SOURCE_COLLECTION
argument_list|)
expr_stmt|;
name|assertNumDocs
argument_list|(
literal|10
argument_list|,
name|TARGET_COLLECTION
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Clearing source_collection"
argument_list|)
expr_stmt|;
name|this
operator|.
name|clearSourceCollection
argument_list|()
expr_stmt|;
name|assertNumDocs
argument_list|(
literal|0
argument_list|,
name|SOURCE_COLLECTION
argument_list|)
expr_stmt|;
name|assertNumDocs
argument_list|(
literal|10
argument_list|,
name|TARGET_COLLECTION
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Restarting leader @ target_collection:shard1"
argument_list|)
expr_stmt|;
name|this
operator|.
name|restartServer
argument_list|(
name|shardToLeaderJetty
operator|.
name|get
argument_list|(
name|TARGET_COLLECTION
argument_list|)
operator|.
name|get
argument_list|(
name|SHARD1
argument_list|)
argument_list|)
expr_stmt|;
name|assertNumDocs
argument_list|(
literal|0
argument_list|,
name|SOURCE_COLLECTION
argument_list|)
expr_stmt|;
name|assertNumDocs
argument_list|(
literal|10
argument_list|,
name|TARGET_COLLECTION
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Clearing target_collection"
argument_list|)
expr_stmt|;
name|this
operator|.
name|clearTargetCollection
argument_list|()
expr_stmt|;
name|assertNumDocs
argument_list|(
literal|0
argument_list|,
name|SOURCE_COLLECTION
argument_list|)
expr_stmt|;
name|assertNumDocs
argument_list|(
literal|0
argument_list|,
name|TARGET_COLLECTION
argument_list|)
expr_stmt|;
name|assertCollectionExpectations
argument_list|(
name|SOURCE_COLLECTION
argument_list|)
expr_stmt|;
name|assertCollectionExpectations
argument_list|(
name|TARGET_COLLECTION
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
annotation|@
name|ShardsFixed
argument_list|(
name|num
operator|=
literal|4
argument_list|)
DECL|method|testTargetCollectionNotAvailable
specifier|public
name|void
name|testTargetCollectionNotAvailable
parameter_list|()
throws|throws
name|Exception
block|{
comment|// send start action to first shard
name|NamedList
name|rsp
init|=
name|invokeCdcrAction
argument_list|(
name|shardToLeaderJetty
operator|.
name|get
argument_list|(
name|SOURCE_COLLECTION
argument_list|)
operator|.
name|get
argument_list|(
name|SHARD1
argument_list|)
argument_list|,
name|CdcrParams
operator|.
name|CdcrAction
operator|.
name|START
argument_list|)
decl_stmt|;
name|NamedList
name|status
init|=
operator|(
name|NamedList
operator|)
name|rsp
operator|.
name|get
argument_list|(
name|CdcrParams
operator|.
name|CdcrAction
operator|.
name|STATUS
operator|.
name|toLower
argument_list|()
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|CdcrParams
operator|.
name|ProcessState
operator|.
name|STARTED
operator|.
name|toLower
argument_list|()
argument_list|,
name|status
operator|.
name|get
argument_list|(
name|CdcrParams
operator|.
name|ProcessState
operator|.
name|getParam
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
comment|// check status
name|this
operator|.
name|assertState
argument_list|(
name|SOURCE_COLLECTION
argument_list|,
name|CdcrParams
operator|.
name|ProcessState
operator|.
name|STARTED
argument_list|,
name|CdcrParams
operator|.
name|BufferState
operator|.
name|ENABLED
argument_list|)
expr_stmt|;
comment|// Kill all the servers of the target
name|this
operator|.
name|deleteCollection
argument_list|(
name|TARGET_COLLECTION
argument_list|)
expr_stmt|;
comment|// Index a few documents to trigger the replication
name|index
argument_list|(
name|SOURCE_COLLECTION
argument_list|,
name|getDoc
argument_list|(
name|id
argument_list|,
literal|"a"
argument_list|)
argument_list|)
expr_stmt|;
name|index
argument_list|(
name|SOURCE_COLLECTION
argument_list|,
name|getDoc
argument_list|(
name|id
argument_list|,
literal|"b"
argument_list|)
argument_list|)
expr_stmt|;
name|index
argument_list|(
name|SOURCE_COLLECTION
argument_list|,
name|getDoc
argument_list|(
name|id
argument_list|,
literal|"c"
argument_list|)
argument_list|)
expr_stmt|;
name|index
argument_list|(
name|SOURCE_COLLECTION
argument_list|,
name|getDoc
argument_list|(
name|id
argument_list|,
literal|"d"
argument_list|)
argument_list|)
expr_stmt|;
name|index
argument_list|(
name|SOURCE_COLLECTION
argument_list|,
name|getDoc
argument_list|(
name|id
argument_list|,
literal|"e"
argument_list|)
argument_list|)
expr_stmt|;
name|index
argument_list|(
name|SOURCE_COLLECTION
argument_list|,
name|getDoc
argument_list|(
name|id
argument_list|,
literal|"f"
argument_list|)
argument_list|)
expr_stmt|;
name|assertNumDocs
argument_list|(
literal|6
argument_list|,
name|SOURCE_COLLECTION
argument_list|)
expr_stmt|;
comment|// we need to wait until the replicator thread is triggered
name|int
name|cnt
init|=
literal|15
decl_stmt|;
comment|// timeout after 15 seconds
name|AssertionError
name|lastAssertionError
init|=
literal|null
decl_stmt|;
while|while
condition|(
name|cnt
operator|>
literal|0
condition|)
block|{
try|try
block|{
name|rsp
operator|=
name|invokeCdcrAction
argument_list|(
name|shardToLeaderJetty
operator|.
name|get
argument_list|(
name|SOURCE_COLLECTION
argument_list|)
operator|.
name|get
argument_list|(
name|SHARD2
argument_list|)
argument_list|,
name|CdcrParams
operator|.
name|CdcrAction
operator|.
name|ERRORS
argument_list|)
expr_stmt|;
name|NamedList
name|collections
init|=
call|(
name|NamedList
call|)
argument_list|(
operator|(
name|NamedList
operator|)
name|rsp
operator|.
name|get
argument_list|(
name|CdcrParams
operator|.
name|ERRORS
argument_list|)
argument_list|)
operator|.
name|getVal
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|NamedList
name|errors
init|=
operator|(
name|NamedList
operator|)
name|collections
operator|.
name|get
argument_list|(
name|TARGET_COLLECTION
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
literal|0
operator|<
operator|(
name|Long
operator|)
name|errors
operator|.
name|get
argument_list|(
name|CdcrParams
operator|.
name|CONSECUTIVE_ERRORS
argument_list|)
argument_list|)
expr_stmt|;
name|NamedList
name|lastErrors
init|=
operator|(
name|NamedList
operator|)
name|errors
operator|.
name|get
argument_list|(
name|CdcrParams
operator|.
name|LAST
argument_list|)
decl_stmt|;
name|assertNotNull
argument_list|(
name|lastErrors
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|0
operator|<
name|lastErrors
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
catch|catch
parameter_list|(
name|AssertionError
name|e
parameter_list|)
block|{
name|lastAssertionError
operator|=
name|e
expr_stmt|;
name|cnt
operator|--
expr_stmt|;
name|Thread
operator|.
name|sleep
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
block|}
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"Timeout while trying to assert replication errors"
argument_list|,
name|lastAssertionError
argument_list|)
throw|;
block|}
annotation|@
name|Test
annotation|@
name|ShardsFixed
argument_list|(
name|num
operator|=
literal|4
argument_list|)
DECL|method|testReplicationStartStop
specifier|public
name|void
name|testReplicationStartStop
parameter_list|()
throws|throws
name|Exception
block|{
name|int
name|start
init|=
literal|0
decl_stmt|;
name|List
argument_list|<
name|SolrInputDocument
argument_list|>
name|docs
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
init|;
name|start
operator|<
literal|10
condition|;
name|start
operator|++
control|)
block|{
name|docs
operator|.
name|add
argument_list|(
name|getDoc
argument_list|(
name|id
argument_list|,
name|Integer
operator|.
name|toString
argument_list|(
name|start
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|index
argument_list|(
name|SOURCE_COLLECTION
argument_list|,
name|docs
argument_list|)
expr_stmt|;
name|assertNumDocs
argument_list|(
literal|10
argument_list|,
name|SOURCE_COLLECTION
argument_list|)
expr_stmt|;
name|assertNumDocs
argument_list|(
literal|0
argument_list|,
name|TARGET_COLLECTION
argument_list|)
expr_stmt|;
name|this
operator|.
name|invokeCdcrAction
argument_list|(
name|shardToLeaderJetty
operator|.
name|get
argument_list|(
name|SOURCE_COLLECTION
argument_list|)
operator|.
name|get
argument_list|(
name|SHARD1
argument_list|)
argument_list|,
name|CdcrParams
operator|.
name|CdcrAction
operator|.
name|START
argument_list|)
expr_stmt|;
name|this
operator|.
name|waitForCdcrStateReplication
argument_list|(
name|SOURCE_COLLECTION
argument_list|)
expr_stmt|;
name|this
operator|.
name|waitForReplicationToComplete
argument_list|(
name|SOURCE_COLLECTION
argument_list|,
name|SHARD1
argument_list|)
expr_stmt|;
name|this
operator|.
name|waitForReplicationToComplete
argument_list|(
name|SOURCE_COLLECTION
argument_list|,
name|SHARD2
argument_list|)
expr_stmt|;
name|commit
argument_list|(
name|TARGET_COLLECTION
argument_list|)
expr_stmt|;
name|assertNumDocs
argument_list|(
literal|10
argument_list|,
name|SOURCE_COLLECTION
argument_list|)
expr_stmt|;
name|assertNumDocs
argument_list|(
literal|10
argument_list|,
name|TARGET_COLLECTION
argument_list|)
expr_stmt|;
name|this
operator|.
name|invokeCdcrAction
argument_list|(
name|shardToLeaderJetty
operator|.
name|get
argument_list|(
name|SOURCE_COLLECTION
argument_list|)
operator|.
name|get
argument_list|(
name|SHARD1
argument_list|)
argument_list|,
name|CdcrParams
operator|.
name|CdcrAction
operator|.
name|STOP
argument_list|)
expr_stmt|;
name|this
operator|.
name|waitForCdcrStateReplication
argument_list|(
name|SOURCE_COLLECTION
argument_list|)
expr_stmt|;
name|docs
operator|.
name|clear
argument_list|()
expr_stmt|;
for|for
control|(
init|;
name|start
operator|<
literal|110
condition|;
name|start
operator|++
control|)
block|{
name|docs
operator|.
name|add
argument_list|(
name|getDoc
argument_list|(
name|id
argument_list|,
name|Integer
operator|.
name|toString
argument_list|(
name|start
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|index
argument_list|(
name|SOURCE_COLLECTION
argument_list|,
name|docs
argument_list|)
expr_stmt|;
name|assertNumDocs
argument_list|(
literal|110
argument_list|,
name|SOURCE_COLLECTION
argument_list|)
expr_stmt|;
name|assertNumDocs
argument_list|(
literal|10
argument_list|,
name|TARGET_COLLECTION
argument_list|)
expr_stmt|;
comment|// Start again CDCR, the source cluster should reinitialise its log readers
comment|// with the latest checkpoints
name|this
operator|.
name|invokeCdcrAction
argument_list|(
name|shardToLeaderJetty
operator|.
name|get
argument_list|(
name|SOURCE_COLLECTION
argument_list|)
operator|.
name|get
argument_list|(
name|SHARD1
argument_list|)
argument_list|,
name|CdcrParams
operator|.
name|CdcrAction
operator|.
name|START
argument_list|)
expr_stmt|;
name|this
operator|.
name|waitForCdcrStateReplication
argument_list|(
name|SOURCE_COLLECTION
argument_list|)
expr_stmt|;
name|this
operator|.
name|waitForReplicationToComplete
argument_list|(
name|SOURCE_COLLECTION
argument_list|,
name|SHARD1
argument_list|)
expr_stmt|;
name|this
operator|.
name|waitForReplicationToComplete
argument_list|(
name|SOURCE_COLLECTION
argument_list|,
name|SHARD2
argument_list|)
expr_stmt|;
name|commit
argument_list|(
name|TARGET_COLLECTION
argument_list|)
expr_stmt|;
name|assertNumDocs
argument_list|(
literal|110
argument_list|,
name|SOURCE_COLLECTION
argument_list|)
expr_stmt|;
name|assertNumDocs
argument_list|(
literal|110
argument_list|,
name|TARGET_COLLECTION
argument_list|)
expr_stmt|;
block|}
comment|/**    * Check that the replication manager is properly restarted after a node failure.    */
annotation|@
name|Test
annotation|@
name|ShardsFixed
argument_list|(
name|num
operator|=
literal|4
argument_list|)
DECL|method|testReplicationAfterRestart
specifier|public
name|void
name|testReplicationAfterRestart
parameter_list|()
throws|throws
name|Exception
block|{
name|log
operator|.
name|info
argument_list|(
literal|"Starting CDCR"
argument_list|)
expr_stmt|;
comment|// send start action to first shard
name|this
operator|.
name|invokeCdcrAction
argument_list|(
name|shardToLeaderJetty
operator|.
name|get
argument_list|(
name|SOURCE_COLLECTION
argument_list|)
operator|.
name|get
argument_list|(
name|SHARD1
argument_list|)
argument_list|,
name|CdcrParams
operator|.
name|CdcrAction
operator|.
name|START
argument_list|)
expr_stmt|;
name|this
operator|.
name|waitForCdcrStateReplication
argument_list|(
name|SOURCE_COLLECTION
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Indexing 10 documents"
argument_list|)
expr_stmt|;
name|int
name|start
init|=
literal|0
decl_stmt|;
name|List
argument_list|<
name|SolrInputDocument
argument_list|>
name|docs
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
init|;
name|start
operator|<
literal|10
condition|;
name|start
operator|++
control|)
block|{
name|docs
operator|.
name|add
argument_list|(
name|getDoc
argument_list|(
name|id
argument_list|,
name|Integer
operator|.
name|toString
argument_list|(
name|start
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|index
argument_list|(
name|SOURCE_COLLECTION
argument_list|,
name|docs
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Querying source collection"
argument_list|)
expr_stmt|;
name|assertNumDocs
argument_list|(
literal|10
argument_list|,
name|SOURCE_COLLECTION
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Waiting for replication"
argument_list|)
expr_stmt|;
name|this
operator|.
name|waitForReplicationToComplete
argument_list|(
name|SOURCE_COLLECTION
argument_list|,
name|SHARD1
argument_list|)
expr_stmt|;
name|this
operator|.
name|waitForReplicationToComplete
argument_list|(
name|SOURCE_COLLECTION
argument_list|,
name|SHARD2
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Querying target collection"
argument_list|)
expr_stmt|;
name|commit
argument_list|(
name|TARGET_COLLECTION
argument_list|)
expr_stmt|;
name|assertNumDocs
argument_list|(
literal|10
argument_list|,
name|TARGET_COLLECTION
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Restarting shard1"
argument_list|)
expr_stmt|;
name|this
operator|.
name|restartServers
argument_list|(
name|shardToJetty
operator|.
name|get
argument_list|(
name|SOURCE_COLLECTION
argument_list|)
operator|.
name|get
argument_list|(
name|SHARD1
argument_list|)
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Indexing 100 documents"
argument_list|)
expr_stmt|;
name|docs
operator|.
name|clear
argument_list|()
expr_stmt|;
for|for
control|(
init|;
name|start
operator|<
literal|110
condition|;
name|start
operator|++
control|)
block|{
name|docs
operator|.
name|add
argument_list|(
name|getDoc
argument_list|(
name|id
argument_list|,
name|Integer
operator|.
name|toString
argument_list|(
name|start
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|index
argument_list|(
name|SOURCE_COLLECTION
argument_list|,
name|docs
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Querying source collection"
argument_list|)
expr_stmt|;
name|assertNumDocs
argument_list|(
literal|110
argument_list|,
name|SOURCE_COLLECTION
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Waiting for replication"
argument_list|)
expr_stmt|;
name|this
operator|.
name|waitForReplicationToComplete
argument_list|(
name|SOURCE_COLLECTION
argument_list|,
name|SHARD1
argument_list|)
expr_stmt|;
name|this
operator|.
name|waitForReplicationToComplete
argument_list|(
name|SOURCE_COLLECTION
argument_list|,
name|SHARD2
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Querying target collection"
argument_list|)
expr_stmt|;
name|commit
argument_list|(
name|TARGET_COLLECTION
argument_list|)
expr_stmt|;
name|assertNumDocs
argument_list|(
literal|110
argument_list|,
name|TARGET_COLLECTION
argument_list|)
expr_stmt|;
block|}
comment|/**    * Check that the replication manager is properly started after a change of leader.    * This test also checks that the log readers on the new leaders are initialised with    * the target's checkpoint.    */
annotation|@
name|Test
annotation|@
name|ShardsFixed
argument_list|(
name|num
operator|=
literal|4
argument_list|)
DECL|method|testReplicationAfterLeaderChange
specifier|public
name|void
name|testReplicationAfterLeaderChange
parameter_list|()
throws|throws
name|Exception
block|{
name|log
operator|.
name|info
argument_list|(
literal|"Starting CDCR"
argument_list|)
expr_stmt|;
comment|// send start action to first shard
name|this
operator|.
name|invokeCdcrAction
argument_list|(
name|shardToLeaderJetty
operator|.
name|get
argument_list|(
name|SOURCE_COLLECTION
argument_list|)
operator|.
name|get
argument_list|(
name|SHARD1
argument_list|)
argument_list|,
name|CdcrParams
operator|.
name|CdcrAction
operator|.
name|START
argument_list|)
expr_stmt|;
name|this
operator|.
name|waitForCdcrStateReplication
argument_list|(
name|SOURCE_COLLECTION
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Indexing 10 documents"
argument_list|)
expr_stmt|;
name|int
name|start
init|=
literal|0
decl_stmt|;
name|List
argument_list|<
name|SolrInputDocument
argument_list|>
name|docs
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
init|;
name|start
operator|<
literal|10
condition|;
name|start
operator|++
control|)
block|{
name|docs
operator|.
name|add
argument_list|(
name|getDoc
argument_list|(
name|id
argument_list|,
name|Integer
operator|.
name|toString
argument_list|(
name|start
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|index
argument_list|(
name|SOURCE_COLLECTION
argument_list|,
name|docs
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Querying source collection"
argument_list|)
expr_stmt|;
name|assertNumDocs
argument_list|(
literal|10
argument_list|,
name|SOURCE_COLLECTION
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Waiting for replication"
argument_list|)
expr_stmt|;
name|this
operator|.
name|waitForReplicationToComplete
argument_list|(
name|SOURCE_COLLECTION
argument_list|,
name|SHARD1
argument_list|)
expr_stmt|;
name|this
operator|.
name|waitForReplicationToComplete
argument_list|(
name|SOURCE_COLLECTION
argument_list|,
name|SHARD2
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Querying target collection"
argument_list|)
expr_stmt|;
name|commit
argument_list|(
name|TARGET_COLLECTION
argument_list|)
expr_stmt|;
name|assertNumDocs
argument_list|(
literal|10
argument_list|,
name|TARGET_COLLECTION
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Restarting target leaders"
argument_list|)
expr_stmt|;
comment|// Close all the leaders, then restart them
name|this
operator|.
name|restartServer
argument_list|(
name|shardToLeaderJetty
operator|.
name|get
argument_list|(
name|TARGET_COLLECTION
argument_list|)
operator|.
name|get
argument_list|(
name|SHARD1
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|restartServer
argument_list|(
name|shardToLeaderJetty
operator|.
name|get
argument_list|(
name|TARGET_COLLECTION
argument_list|)
operator|.
name|get
argument_list|(
name|SHARD2
argument_list|)
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Restarting source leaders"
argument_list|)
expr_stmt|;
comment|// Close all the leaders, then restart them
name|this
operator|.
name|restartServer
argument_list|(
name|shardToLeaderJetty
operator|.
name|get
argument_list|(
name|SOURCE_COLLECTION
argument_list|)
operator|.
name|get
argument_list|(
name|SHARD1
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|restartServer
argument_list|(
name|shardToLeaderJetty
operator|.
name|get
argument_list|(
name|SOURCE_COLLECTION
argument_list|)
operator|.
name|get
argument_list|(
name|SHARD2
argument_list|)
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Checking queue size of new source leaders"
argument_list|)
expr_stmt|;
comment|// If the log readers of the new leaders are initialised with the target's checkpoint, the
comment|// queue size must be inferior to the current number of documents indexed.
comment|// The queue might be not completely empty since the new target checkpoint is probably not the
comment|// last document received
name|assertTrue
argument_list|(
name|this
operator|.
name|getQueueSize
argument_list|(
name|SOURCE_COLLECTION
argument_list|,
name|SHARD1
argument_list|)
operator|<
literal|10
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|this
operator|.
name|getQueueSize
argument_list|(
name|SOURCE_COLLECTION
argument_list|,
name|SHARD2
argument_list|)
operator|<
literal|10
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Indexing 100 documents"
argument_list|)
expr_stmt|;
name|docs
operator|.
name|clear
argument_list|()
expr_stmt|;
for|for
control|(
init|;
name|start
operator|<
literal|110
condition|;
name|start
operator|++
control|)
block|{
name|docs
operator|.
name|add
argument_list|(
name|getDoc
argument_list|(
name|id
argument_list|,
name|Integer
operator|.
name|toString
argument_list|(
name|start
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|index
argument_list|(
name|SOURCE_COLLECTION
argument_list|,
name|docs
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Querying source collection"
argument_list|)
expr_stmt|;
name|assertNumDocs
argument_list|(
literal|110
argument_list|,
name|SOURCE_COLLECTION
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Waiting for replication"
argument_list|)
expr_stmt|;
name|this
operator|.
name|waitForReplicationToComplete
argument_list|(
name|SOURCE_COLLECTION
argument_list|,
name|SHARD1
argument_list|)
expr_stmt|;
name|this
operator|.
name|waitForReplicationToComplete
argument_list|(
name|SOURCE_COLLECTION
argument_list|,
name|SHARD2
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Querying target collection"
argument_list|)
expr_stmt|;
name|commit
argument_list|(
name|TARGET_COLLECTION
argument_list|)
expr_stmt|;
name|assertNumDocs
argument_list|(
literal|110
argument_list|,
name|TARGET_COLLECTION
argument_list|)
expr_stmt|;
block|}
comment|/**    * Check that the update logs are synchronised between leader and non-leader nodes    * when CDCR is on and buffer is disabled    */
annotation|@
name|Test
annotation|@
name|ShardsFixed
argument_list|(
name|num
operator|=
literal|4
argument_list|)
DECL|method|testUpdateLogSynchronisation
specifier|public
name|void
name|testUpdateLogSynchronisation
parameter_list|()
throws|throws
name|Exception
block|{
name|this
operator|.
name|invokeCdcrAction
argument_list|(
name|shardToLeaderJetty
operator|.
name|get
argument_list|(
name|SOURCE_COLLECTION
argument_list|)
operator|.
name|get
argument_list|(
name|SHARD1
argument_list|)
argument_list|,
name|CdcrParams
operator|.
name|CdcrAction
operator|.
name|START
argument_list|)
expr_stmt|;
name|this
operator|.
name|waitForCdcrStateReplication
argument_list|(
name|SOURCE_COLLECTION
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|100
condition|;
name|i
operator|++
control|)
block|{
comment|// will perform a commit for every document and will create one tlog file per commit
name|index
argument_list|(
name|SOURCE_COLLECTION
argument_list|,
name|getDoc
argument_list|(
name|id
argument_list|,
name|Integer
operator|.
name|toString
argument_list|(
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// wait a bit for the replication to complete
name|this
operator|.
name|waitForReplicationToComplete
argument_list|(
name|SOURCE_COLLECTION
argument_list|,
name|SHARD1
argument_list|)
expr_stmt|;
name|this
operator|.
name|waitForReplicationToComplete
argument_list|(
name|SOURCE_COLLECTION
argument_list|,
name|SHARD2
argument_list|)
expr_stmt|;
name|commit
argument_list|(
name|TARGET_COLLECTION
argument_list|)
expr_stmt|;
comment|// Check that the replication was done properly
name|assertNumDocs
argument_list|(
literal|100
argument_list|,
name|SOURCE_COLLECTION
argument_list|)
expr_stmt|;
name|assertNumDocs
argument_list|(
literal|100
argument_list|,
name|TARGET_COLLECTION
argument_list|)
expr_stmt|;
comment|// Get the number of tlog files on the replicas (should be equal to the number of documents indexed)
name|int
name|nTlogs
init|=
name|getNumberOfTlogFilesOnReplicas
argument_list|(
name|SOURCE_COLLECTION
argument_list|)
decl_stmt|;
comment|// Disable the buffer - ulog synch should start on non-leader nodes
name|this
operator|.
name|invokeCdcrAction
argument_list|(
name|shardToLeaderJetty
operator|.
name|get
argument_list|(
name|SOURCE_COLLECTION
argument_list|)
operator|.
name|get
argument_list|(
name|SHARD1
argument_list|)
argument_list|,
name|CdcrParams
operator|.
name|CdcrAction
operator|.
name|DISABLEBUFFER
argument_list|)
expr_stmt|;
name|this
operator|.
name|waitForCdcrStateReplication
argument_list|(
name|SOURCE_COLLECTION
argument_list|)
expr_stmt|;
name|int
name|cnt
init|=
literal|15
decl_stmt|;
comment|// timeout after 15 seconds
while|while
condition|(
name|cnt
operator|>
literal|0
condition|)
block|{
comment|// Index a new document with a commit to trigger update log cleaning
name|index
argument_list|(
name|SOURCE_COLLECTION
argument_list|,
name|getDoc
argument_list|(
name|id
argument_list|,
name|Integer
operator|.
name|toString
argument_list|(
literal|50
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|// Check the update logs on non-leader nodes, the number of tlog files should decrease
name|int
name|n
init|=
name|getNumberOfTlogFilesOnReplicas
argument_list|(
name|SOURCE_COLLECTION
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
operator|<
name|nTlogs
condition|)
return|return;
name|cnt
operator|--
expr_stmt|;
name|Thread
operator|.
name|sleep
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"Timeout while trying to assert update logs @ source_collection"
argument_list|)
throw|;
block|}
comment|/**    * Check that the buffer is always activated on non-leader nodes.    */
annotation|@
name|Test
annotation|@
name|ShardsFixed
argument_list|(
name|num
operator|=
literal|4
argument_list|)
DECL|method|testBufferOnNonLeader
specifier|public
name|void
name|testBufferOnNonLeader
parameter_list|()
throws|throws
name|Exception
block|{
comment|// buffering is enabled by default, so disable it
name|this
operator|.
name|invokeCdcrAction
argument_list|(
name|shardToLeaderJetty
operator|.
name|get
argument_list|(
name|SOURCE_COLLECTION
argument_list|)
operator|.
name|get
argument_list|(
name|SHARD1
argument_list|)
argument_list|,
name|CdcrParams
operator|.
name|CdcrAction
operator|.
name|DISABLEBUFFER
argument_list|)
expr_stmt|;
name|this
operator|.
name|waitForCdcrStateReplication
argument_list|(
name|SOURCE_COLLECTION
argument_list|)
expr_stmt|;
comment|// Start CDCR
name|this
operator|.
name|invokeCdcrAction
argument_list|(
name|shardToLeaderJetty
operator|.
name|get
argument_list|(
name|SOURCE_COLLECTION
argument_list|)
operator|.
name|get
argument_list|(
name|SHARD1
argument_list|)
argument_list|,
name|CdcrParams
operator|.
name|CdcrAction
operator|.
name|START
argument_list|)
expr_stmt|;
name|this
operator|.
name|waitForCdcrStateReplication
argument_list|(
name|SOURCE_COLLECTION
argument_list|)
expr_stmt|;
comment|// Index documents
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|200
condition|;
name|i
operator|++
control|)
block|{
name|index
argument_list|(
name|SOURCE_COLLECTION
argument_list|,
name|getDoc
argument_list|(
name|id
argument_list|,
name|Integer
operator|.
name|toString
argument_list|(
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|// will perform a commit for every document
block|}
comment|// And immediately, close all the leaders, then restart them. It is likely that the replication will not be
comment|// performed fully, and therefore be continued by the new leader
comment|// At this stage, the new leader must have been elected
name|this
operator|.
name|restartServer
argument_list|(
name|shardToLeaderJetty
operator|.
name|get
argument_list|(
name|SOURCE_COLLECTION
argument_list|)
operator|.
name|get
argument_list|(
name|SHARD1
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|restartServer
argument_list|(
name|shardToLeaderJetty
operator|.
name|get
argument_list|(
name|SOURCE_COLLECTION
argument_list|)
operator|.
name|get
argument_list|(
name|SHARD2
argument_list|)
argument_list|)
expr_stmt|;
comment|// wait a bit for the replication to complete
name|this
operator|.
name|waitForReplicationToComplete
argument_list|(
name|SOURCE_COLLECTION
argument_list|,
name|SHARD1
argument_list|)
expr_stmt|;
name|this
operator|.
name|waitForReplicationToComplete
argument_list|(
name|SOURCE_COLLECTION
argument_list|,
name|SHARD2
argument_list|)
expr_stmt|;
comment|// Commit to make the documents visible on the target
name|commit
argument_list|(
name|TARGET_COLLECTION
argument_list|)
expr_stmt|;
comment|// If the non-leader node were buffering updates, then the replication must be complete
name|assertNumDocs
argument_list|(
literal|200
argument_list|,
name|SOURCE_COLLECTION
argument_list|)
expr_stmt|;
name|assertNumDocs
argument_list|(
literal|200
argument_list|,
name|TARGET_COLLECTION
argument_list|)
expr_stmt|;
block|}
comment|/**    * Check the ops statistics.    */
annotation|@
name|Test
annotation|@
name|ShardsFixed
argument_list|(
name|num
operator|=
literal|4
argument_list|)
DECL|method|testOps
specifier|public
name|void
name|testOps
parameter_list|()
throws|throws
name|Exception
block|{
comment|// Index documents
name|List
argument_list|<
name|SolrInputDocument
argument_list|>
name|docs
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|200
condition|;
name|i
operator|++
control|)
block|{
name|docs
operator|.
name|add
argument_list|(
name|getDoc
argument_list|(
name|id
argument_list|,
name|Integer
operator|.
name|toString
argument_list|(
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|index
argument_list|(
name|SOURCE_COLLECTION
argument_list|,
name|docs
argument_list|)
expr_stmt|;
comment|// Start CDCR
name|this
operator|.
name|invokeCdcrAction
argument_list|(
name|shardToLeaderJetty
operator|.
name|get
argument_list|(
name|SOURCE_COLLECTION
argument_list|)
operator|.
name|get
argument_list|(
name|SHARD1
argument_list|)
argument_list|,
name|CdcrParams
operator|.
name|CdcrAction
operator|.
name|START
argument_list|)
expr_stmt|;
name|this
operator|.
name|waitForCdcrStateReplication
argument_list|(
name|SOURCE_COLLECTION
argument_list|)
expr_stmt|;
comment|// wait a bit for the replication to complete
name|this
operator|.
name|waitForReplicationToComplete
argument_list|(
name|SOURCE_COLLECTION
argument_list|,
name|SHARD1
argument_list|)
expr_stmt|;
name|this
operator|.
name|waitForReplicationToComplete
argument_list|(
name|SOURCE_COLLECTION
argument_list|,
name|SHARD2
argument_list|)
expr_stmt|;
name|NamedList
name|rsp
init|=
name|this
operator|.
name|invokeCdcrAction
argument_list|(
name|shardToLeaderJetty
operator|.
name|get
argument_list|(
name|SOURCE_COLLECTION
argument_list|)
operator|.
name|get
argument_list|(
name|SHARD1
argument_list|)
argument_list|,
name|CdcrParams
operator|.
name|CdcrAction
operator|.
name|OPS
argument_list|)
decl_stmt|;
name|NamedList
name|collections
init|=
call|(
name|NamedList
call|)
argument_list|(
operator|(
name|NamedList
operator|)
name|rsp
operator|.
name|get
argument_list|(
name|CdcrParams
operator|.
name|OPERATIONS_PER_SECOND
argument_list|)
argument_list|)
operator|.
name|getVal
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|NamedList
name|ops
init|=
operator|(
name|NamedList
operator|)
name|collections
operator|.
name|get
argument_list|(
name|TARGET_COLLECTION
argument_list|)
decl_stmt|;
name|double
name|opsAll
init|=
operator|(
name|Double
operator|)
name|ops
operator|.
name|get
argument_list|(
name|CdcrParams
operator|.
name|COUNTER_ALL
argument_list|)
decl_stmt|;
name|double
name|opsAdds
init|=
operator|(
name|Double
operator|)
name|ops
operator|.
name|get
argument_list|(
name|CdcrParams
operator|.
name|COUNTER_ADDS
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|opsAll
operator|>
literal|0
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|opsAll
argument_list|,
name|opsAdds
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|double
name|opsDeletes
init|=
operator|(
name|Double
operator|)
name|ops
operator|.
name|get
argument_list|(
name|CdcrParams
operator|.
name|COUNTER_DELETES
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|opsDeletes
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/**    * Check that batch updates with deletes    */
annotation|@
name|Test
annotation|@
name|ShardsFixed
argument_list|(
name|num
operator|=
literal|4
argument_list|)
DECL|method|testBatchAddsWithDelete
specifier|public
name|void
name|testBatchAddsWithDelete
parameter_list|()
throws|throws
name|Exception
block|{
comment|// Index 50 documents
name|int
name|start
init|=
literal|0
decl_stmt|;
name|List
argument_list|<
name|SolrInputDocument
argument_list|>
name|docs
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
init|;
name|start
operator|<
literal|50
condition|;
name|start
operator|++
control|)
block|{
name|docs
operator|.
name|add
argument_list|(
name|getDoc
argument_list|(
name|id
argument_list|,
name|Integer
operator|.
name|toString
argument_list|(
name|start
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|index
argument_list|(
name|SOURCE_COLLECTION
argument_list|,
name|docs
argument_list|)
expr_stmt|;
comment|// Delete 10 documents: 10-19
name|List
argument_list|<
name|String
argument_list|>
name|ids
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|id
init|=
literal|10
init|;
name|id
operator|<
literal|20
condition|;
name|id
operator|++
control|)
block|{
name|ids
operator|.
name|add
argument_list|(
name|Integer
operator|.
name|toString
argument_list|(
name|id
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|deleteById
argument_list|(
name|SOURCE_COLLECTION
argument_list|,
name|ids
argument_list|)
expr_stmt|;
comment|// Index 10 documents
name|docs
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
expr_stmt|;
for|for
control|(
init|;
name|start
operator|<
literal|60
condition|;
name|start
operator|++
control|)
block|{
name|docs
operator|.
name|add
argument_list|(
name|getDoc
argument_list|(
name|id
argument_list|,
name|Integer
operator|.
name|toString
argument_list|(
name|start
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|index
argument_list|(
name|SOURCE_COLLECTION
argument_list|,
name|docs
argument_list|)
expr_stmt|;
comment|// Delete 1 document: 50
name|ids
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
expr_stmt|;
name|ids
operator|.
name|add
argument_list|(
name|Integer
operator|.
name|toString
argument_list|(
literal|50
argument_list|)
argument_list|)
expr_stmt|;
name|deleteById
argument_list|(
name|SOURCE_COLLECTION
argument_list|,
name|ids
argument_list|)
expr_stmt|;
comment|// Index 10 documents
name|docs
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
expr_stmt|;
for|for
control|(
init|;
name|start
operator|<
literal|70
condition|;
name|start
operator|++
control|)
block|{
name|docs
operator|.
name|add
argument_list|(
name|getDoc
argument_list|(
name|id
argument_list|,
name|Integer
operator|.
name|toString
argument_list|(
name|start
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|index
argument_list|(
name|SOURCE_COLLECTION
argument_list|,
name|docs
argument_list|)
expr_stmt|;
comment|// Start CDCR
name|this
operator|.
name|invokeCdcrAction
argument_list|(
name|shardToLeaderJetty
operator|.
name|get
argument_list|(
name|SOURCE_COLLECTION
argument_list|)
operator|.
name|get
argument_list|(
name|SHARD1
argument_list|)
argument_list|,
name|CdcrParams
operator|.
name|CdcrAction
operator|.
name|START
argument_list|)
expr_stmt|;
name|this
operator|.
name|waitForCdcrStateReplication
argument_list|(
name|SOURCE_COLLECTION
argument_list|)
expr_stmt|;
comment|// wait a bit for the replication to complete
name|this
operator|.
name|waitForReplicationToComplete
argument_list|(
name|SOURCE_COLLECTION
argument_list|,
name|SHARD1
argument_list|)
expr_stmt|;
name|this
operator|.
name|waitForReplicationToComplete
argument_list|(
name|SOURCE_COLLECTION
argument_list|,
name|SHARD2
argument_list|)
expr_stmt|;
name|commit
argument_list|(
name|TARGET_COLLECTION
argument_list|)
expr_stmt|;
comment|// If the non-leader node were buffering updates, then the replication must be complete
name|assertNumDocs
argument_list|(
literal|59
argument_list|,
name|SOURCE_COLLECTION
argument_list|)
expr_stmt|;
name|assertNumDocs
argument_list|(
literal|59
argument_list|,
name|TARGET_COLLECTION
argument_list|)
expr_stmt|;
block|}
comment|/**    * Checks that batches are correctly constructed when batch boundaries are reached.    */
annotation|@
name|Test
annotation|@
name|ShardsFixed
argument_list|(
name|num
operator|=
literal|4
argument_list|)
DECL|method|testBatchBoundaries
specifier|public
name|void
name|testBatchBoundaries
parameter_list|()
throws|throws
name|Exception
block|{
name|this
operator|.
name|invokeCdcrAction
argument_list|(
name|shardToLeaderJetty
operator|.
name|get
argument_list|(
name|SOURCE_COLLECTION
argument_list|)
operator|.
name|get
argument_list|(
name|SHARD1
argument_list|)
argument_list|,
name|CdcrParams
operator|.
name|CdcrAction
operator|.
name|START
argument_list|)
expr_stmt|;
name|this
operator|.
name|waitForCdcrStateReplication
argument_list|(
name|SOURCE_COLLECTION
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Indexing documents"
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|SolrInputDocument
argument_list|>
name|docs
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|128
condition|;
name|i
operator|++
control|)
block|{
comment|// should create two full batches (default batch = 64)
name|docs
operator|.
name|add
argument_list|(
name|getDoc
argument_list|(
name|id
argument_list|,
name|Integer
operator|.
name|toString
argument_list|(
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|index
argument_list|(
name|SOURCE_COLLECTION
argument_list|,
name|docs
argument_list|)
expr_stmt|;
name|assertNumDocs
argument_list|(
literal|128
argument_list|,
name|SOURCE_COLLECTION
argument_list|)
expr_stmt|;
name|this
operator|.
name|waitForReplicationToComplete
argument_list|(
name|SOURCE_COLLECTION
argument_list|,
name|SHARD1
argument_list|)
expr_stmt|;
name|this
operator|.
name|waitForReplicationToComplete
argument_list|(
name|SOURCE_COLLECTION
argument_list|,
name|SHARD2
argument_list|)
expr_stmt|;
name|commit
argument_list|(
name|TARGET_COLLECTION
argument_list|)
expr_stmt|;
name|assertNumDocs
argument_list|(
literal|128
argument_list|,
name|SOURCE_COLLECTION
argument_list|)
expr_stmt|;
name|assertNumDocs
argument_list|(
literal|128
argument_list|,
name|TARGET_COLLECTION
argument_list|)
expr_stmt|;
block|}
comment|/**    * Check resilience of replication with delete by query executed on targets    */
annotation|@
name|Test
annotation|@
name|ShardsFixed
argument_list|(
name|num
operator|=
literal|4
argument_list|)
DECL|method|testResilienceWithDeleteByQueryOnTarget
specifier|public
name|void
name|testResilienceWithDeleteByQueryOnTarget
parameter_list|()
throws|throws
name|Exception
block|{
comment|// Index 50 documents
name|int
name|start
init|=
literal|0
decl_stmt|;
name|List
argument_list|<
name|SolrInputDocument
argument_list|>
name|docs
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
init|;
name|start
operator|<
literal|50
condition|;
name|start
operator|++
control|)
block|{
name|docs
operator|.
name|add
argument_list|(
name|getDoc
argument_list|(
name|id
argument_list|,
name|Integer
operator|.
name|toString
argument_list|(
name|start
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|index
argument_list|(
name|SOURCE_COLLECTION
argument_list|,
name|docs
argument_list|)
expr_stmt|;
comment|// Start CDCR
name|this
operator|.
name|invokeCdcrAction
argument_list|(
name|shardToLeaderJetty
operator|.
name|get
argument_list|(
name|SOURCE_COLLECTION
argument_list|)
operator|.
name|get
argument_list|(
name|SHARD1
argument_list|)
argument_list|,
name|CdcrParams
operator|.
name|CdcrAction
operator|.
name|START
argument_list|)
expr_stmt|;
name|this
operator|.
name|waitForCdcrStateReplication
argument_list|(
name|SOURCE_COLLECTION
argument_list|)
expr_stmt|;
comment|// wait a bit for the replication to complete
name|this
operator|.
name|waitForReplicationToComplete
argument_list|(
name|SOURCE_COLLECTION
argument_list|,
name|SHARD1
argument_list|)
expr_stmt|;
name|this
operator|.
name|waitForReplicationToComplete
argument_list|(
name|SOURCE_COLLECTION
argument_list|,
name|SHARD2
argument_list|)
expr_stmt|;
name|commit
argument_list|(
name|TARGET_COLLECTION
argument_list|)
expr_stmt|;
comment|// If the non-leader node were buffering updates, then the replication must be complete
name|assertNumDocs
argument_list|(
literal|50
argument_list|,
name|SOURCE_COLLECTION
argument_list|)
expr_stmt|;
name|assertNumDocs
argument_list|(
literal|50
argument_list|,
name|TARGET_COLLECTION
argument_list|)
expr_stmt|;
name|deleteByQuery
argument_list|(
name|SOURCE_COLLECTION
argument_list|,
literal|"*:*"
argument_list|)
expr_stmt|;
name|deleteByQuery
argument_list|(
name|TARGET_COLLECTION
argument_list|,
literal|"*:*"
argument_list|)
expr_stmt|;
name|assertNumDocs
argument_list|(
literal|0
argument_list|,
name|SOURCE_COLLECTION
argument_list|)
expr_stmt|;
name|assertNumDocs
argument_list|(
literal|0
argument_list|,
name|TARGET_COLLECTION
argument_list|)
expr_stmt|;
name|docs
operator|.
name|clear
argument_list|()
expr_stmt|;
for|for
control|(
init|;
name|start
operator|<
literal|100
condition|;
name|start
operator|++
control|)
block|{
name|docs
operator|.
name|add
argument_list|(
name|getDoc
argument_list|(
name|id
argument_list|,
name|Integer
operator|.
name|toString
argument_list|(
name|start
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|index
argument_list|(
name|SOURCE_COLLECTION
argument_list|,
name|docs
argument_list|)
expr_stmt|;
comment|// wait a bit for the replication to complete
name|this
operator|.
name|waitForReplicationToComplete
argument_list|(
name|SOURCE_COLLECTION
argument_list|,
name|SHARD1
argument_list|)
expr_stmt|;
name|this
operator|.
name|waitForReplicationToComplete
argument_list|(
name|SOURCE_COLLECTION
argument_list|,
name|SHARD2
argument_list|)
expr_stmt|;
name|commit
argument_list|(
name|TARGET_COLLECTION
argument_list|)
expr_stmt|;
name|assertNumDocs
argument_list|(
literal|50
argument_list|,
name|SOURCE_COLLECTION
argument_list|)
expr_stmt|;
name|assertNumDocs
argument_list|(
literal|50
argument_list|,
name|TARGET_COLLECTION
argument_list|)
expr_stmt|;
name|deleteByQuery
argument_list|(
name|TARGET_COLLECTION
argument_list|,
literal|"*:*"
argument_list|)
expr_stmt|;
name|assertNumDocs
argument_list|(
literal|50
argument_list|,
name|SOURCE_COLLECTION
argument_list|)
expr_stmt|;
name|assertNumDocs
argument_list|(
literal|0
argument_list|,
name|TARGET_COLLECTION
argument_list|)
expr_stmt|;
comment|// Restart CDCR
name|this
operator|.
name|invokeCdcrAction
argument_list|(
name|shardToLeaderJetty
operator|.
name|get
argument_list|(
name|SOURCE_COLLECTION
argument_list|)
operator|.
name|get
argument_list|(
name|SHARD1
argument_list|)
argument_list|,
name|CdcrParams
operator|.
name|CdcrAction
operator|.
name|STOP
argument_list|)
expr_stmt|;
name|this
operator|.
name|waitForCdcrStateReplication
argument_list|(
name|SOURCE_COLLECTION
argument_list|)
expr_stmt|;
name|this
operator|.
name|invokeCdcrAction
argument_list|(
name|shardToLeaderJetty
operator|.
name|get
argument_list|(
name|SOURCE_COLLECTION
argument_list|)
operator|.
name|get
argument_list|(
name|SHARD1
argument_list|)
argument_list|,
name|CdcrParams
operator|.
name|CdcrAction
operator|.
name|START
argument_list|)
expr_stmt|;
name|this
operator|.
name|waitForCdcrStateReplication
argument_list|(
name|SOURCE_COLLECTION
argument_list|)
expr_stmt|;
name|docs
operator|.
name|clear
argument_list|()
expr_stmt|;
for|for
control|(
init|;
name|start
operator|<
literal|150
condition|;
name|start
operator|++
control|)
block|{
name|docs
operator|.
name|add
argument_list|(
name|getDoc
argument_list|(
name|id
argument_list|,
name|Integer
operator|.
name|toString
argument_list|(
name|start
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|index
argument_list|(
name|SOURCE_COLLECTION
argument_list|,
name|docs
argument_list|)
expr_stmt|;
comment|// wait a bit for the replication to complete
name|this
operator|.
name|waitForReplicationToComplete
argument_list|(
name|SOURCE_COLLECTION
argument_list|,
name|SHARD1
argument_list|)
expr_stmt|;
name|this
operator|.
name|waitForReplicationToComplete
argument_list|(
name|SOURCE_COLLECTION
argument_list|,
name|SHARD2
argument_list|)
expr_stmt|;
name|commit
argument_list|(
name|TARGET_COLLECTION
argument_list|)
expr_stmt|;
name|assertNumDocs
argument_list|(
literal|100
argument_list|,
name|SOURCE_COLLECTION
argument_list|)
expr_stmt|;
name|assertNumDocs
argument_list|(
literal|50
argument_list|,
name|TARGET_COLLECTION
argument_list|)
expr_stmt|;
block|}
DECL|method|numberOfFiles
specifier|private
name|int
name|numberOfFiles
parameter_list|(
name|String
name|dir
parameter_list|)
block|{
name|File
name|file
init|=
operator|new
name|File
argument_list|(
name|dir
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|file
operator|.
name|isDirectory
argument_list|()
condition|)
block|{
name|assertTrue
argument_list|(
literal|"Path to tlog "
operator|+
name|dir
operator|+
literal|" does not exists or it's not a directory."
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
name|log
operator|.
name|debug
argument_list|(
literal|"Update log dir {} contains: {}"
argument_list|,
name|dir
argument_list|,
name|file
operator|.
name|listFiles
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|file
operator|.
name|listFiles
argument_list|()
operator|.
name|length
return|;
block|}
DECL|method|getNumberOfTlogFilesOnReplicas
specifier|private
name|int
name|getNumberOfTlogFilesOnReplicas
parameter_list|(
name|String
name|collection
parameter_list|)
throws|throws
name|Exception
block|{
name|CollectionInfo
name|info
init|=
name|collectInfo
argument_list|(
name|collection
argument_list|)
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|CollectionInfo
operator|.
name|CoreInfo
argument_list|>
argument_list|>
name|shardToCoresMap
init|=
name|info
operator|.
name|getShardToCoresMap
argument_list|()
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
for|for
control|(
name|String
name|shard
range|:
name|shardToCoresMap
operator|.
name|keySet
argument_list|()
control|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|replicationFactor
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|count
operator|+=
name|numberOfFiles
argument_list|(
name|info
operator|.
name|getReplicas
argument_list|(
name|shard
argument_list|)
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|ulogDir
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|count
return|;
block|}
block|}
end_class
end_unit
