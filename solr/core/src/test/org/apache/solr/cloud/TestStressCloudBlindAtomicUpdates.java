begin_unit
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_package
DECL|package|org.apache.solr.cloud
package|package
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|cloud
package|;
end_package
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import
begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|invoke
operator|.
name|MethodHandles
import|;
end_import
begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|Path
import|;
end_import
begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|Paths
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicLong
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|CountDownLatch
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ExecutionException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ExecutorService
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Future
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Random
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|SolrTestCaseJ4
operator|.
name|SuppressSSL
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|cloud
operator|.
name|SolrCloudTestCase
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|client
operator|.
name|solrj
operator|.
name|SolrClient
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|client
operator|.
name|solrj
operator|.
name|SolrServerException
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|client
operator|.
name|solrj
operator|.
name|embedded
operator|.
name|JettySolrRunner
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|client
operator|.
name|solrj
operator|.
name|impl
operator|.
name|HttpSolrClient
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|client
operator|.
name|solrj
operator|.
name|impl
operator|.
name|CloudSolrClient
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|client
operator|.
name|solrj
operator|.
name|request
operator|.
name|UpdateRequest
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|client
operator|.
name|solrj
operator|.
name|response
operator|.
name|UpdateResponse
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|client
operator|.
name|solrj
operator|.
name|request
operator|.
name|schema
operator|.
name|SchemaRequest
operator|.
name|Field
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|client
operator|.
name|solrj
operator|.
name|request
operator|.
name|schema
operator|.
name|SchemaRequest
operator|.
name|FieldType
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|client
operator|.
name|solrj
operator|.
name|response
operator|.
name|schema
operator|.
name|SchemaResponse
operator|.
name|FieldResponse
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|client
operator|.
name|solrj
operator|.
name|response
operator|.
name|schema
operator|.
name|SchemaResponse
operator|.
name|FieldTypeResponse
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|SolrDocument
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|SolrDocumentList
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|SolrInputDocument
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|SolrInputField
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|SolrException
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|params
operator|.
name|ModifiableSolrParams
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|params
operator|.
name|SolrParams
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|util
operator|.
name|ExecutorUtil
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|util
operator|.
name|SimpleOrderedMap
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|util
operator|.
name|NamedList
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|util
operator|.
name|DefaultSolrThreadFactory
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|util
operator|.
name|TestInjection
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|LuceneTestCase
operator|.
name|Slow
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|TestUtil
import|;
end_import
begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|AfterClass
import|;
end_import
begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Before
import|;
end_import
begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|BeforeClass
import|;
end_import
begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import
begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import
begin_comment
comment|/**  * Stress test of Atomic Updates in a MinCloud Cluster.  *   * Focus of test is parallel threads hammering updates on diff docs using random clients/nodes,   * Optimistic Concurrency is not used here because of SOLR-8733, instead we just throw lots of   * "inc" operations at a numeric field and check that the math works out at the end.  */
end_comment
begin_class
annotation|@
name|Slow
annotation|@
name|SuppressSSL
argument_list|(
name|bugUrl
operator|=
literal|"SSL overhead seems to cause OutOfMemory when stress testing"
argument_list|)
DECL|class|TestStressCloudBlindAtomicUpdates
specifier|public
class|class
name|TestStressCloudBlindAtomicUpdates
extends|extends
name|SolrCloudTestCase
block|{
DECL|field|log
specifier|private
specifier|static
specifier|final
name|Logger
name|log
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|MethodHandles
operator|.
name|lookup
argument_list|()
operator|.
name|lookupClass
argument_list|()
argument_list|)
decl_stmt|;
DECL|field|DEBUG_LABEL
specifier|private
specifier|static
specifier|final
name|String
name|DEBUG_LABEL
init|=
name|MethodHandles
operator|.
name|lookup
argument_list|()
operator|.
name|lookupClass
argument_list|()
operator|.
name|getName
argument_list|()
decl_stmt|;
DECL|field|COLLECTION_NAME
specifier|private
specifier|static
specifier|final
name|String
name|COLLECTION_NAME
init|=
literal|"test_col"
decl_stmt|;
comment|/** A basic client for operations at the cloud level, default collection will be set */
DECL|field|CLOUD_CLIENT
specifier|private
specifier|static
name|CloudSolrClient
name|CLOUD_CLIENT
decl_stmt|;
comment|/** One client per node */
DECL|field|CLIENTS
specifier|private
specifier|static
name|ArrayList
argument_list|<
name|HttpSolrClient
argument_list|>
name|CLIENTS
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
literal|5
argument_list|)
decl_stmt|;
comment|/** Service to execute all parallel work     * @see #NUM_THREADS    */
DECL|field|EXEC_SERVICE
specifier|private
specifier|static
name|ExecutorService
name|EXEC_SERVICE
decl_stmt|;
comment|/** num parallel threads in use by {@link #EXEC_SERVICE} */
DECL|field|NUM_THREADS
specifier|private
specifier|static
name|int
name|NUM_THREADS
decl_stmt|;
comment|/**     * Used as an increment and multiplier when deciding how many docs should be in    * the test index.  1 means every doc in the index is a candidate for updates, bigger numbers mean a    * larger index is used (so tested docs are more likeely to be spread out in multiple segments)    */
DECL|field|DOC_ID_INCR
specifier|private
specifier|static
name|int
name|DOC_ID_INCR
decl_stmt|;
annotation|@
name|BeforeClass
DECL|method|createMiniSolrCloudCluster
specifier|private
specifier|static
name|void
name|createMiniSolrCloudCluster
parameter_list|()
throws|throws
name|Exception
block|{
comment|// NOTE: numDocsToCheck uses atLeast, so nightly& multiplier are alreayd a factor in index size
comment|// no need to redundently factor them in here as well
name|DOC_ID_INCR
operator|=
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|random
argument_list|()
argument_list|,
literal|1
argument_list|,
literal|7
argument_list|)
expr_stmt|;
name|NUM_THREADS
operator|=
name|atLeast
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|EXEC_SERVICE
operator|=
name|ExecutorUtil
operator|.
name|newMDCAwareFixedThreadPool
argument_list|(
name|NUM_THREADS
argument_list|,
operator|new
name|DefaultSolrThreadFactory
argument_list|(
name|DEBUG_LABEL
argument_list|)
argument_list|)
expr_stmt|;
comment|// at least 2, but don't go crazy on nightly/test.multiplier with "atLeast()"
specifier|final
name|int
name|numShards
init|=
name|TEST_NIGHTLY
condition|?
literal|5
else|:
literal|2
decl_stmt|;
specifier|final
name|int
name|repFactor
init|=
literal|2
decl_stmt|;
specifier|final
name|int
name|numNodes
init|=
name|numShards
operator|*
name|repFactor
decl_stmt|;
specifier|final
name|String
name|configName
init|=
name|DEBUG_LABEL
operator|+
literal|"_config-set"
decl_stmt|;
specifier|final
name|Path
name|configDir
init|=
name|Paths
operator|.
name|get
argument_list|(
name|TEST_HOME
argument_list|()
argument_list|,
literal|"collection1"
argument_list|,
literal|"conf"
argument_list|)
decl_stmt|;
name|configureCluster
argument_list|(
name|numNodes
argument_list|)
operator|.
name|addConfig
argument_list|(
name|configName
argument_list|,
name|configDir
argument_list|)
operator|.
name|configure
argument_list|()
expr_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|collectionProperties
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|collectionProperties
operator|.
name|put
argument_list|(
literal|"config"
argument_list|,
literal|"solrconfig-tlog.xml"
argument_list|)
expr_stmt|;
name|collectionProperties
operator|.
name|put
argument_list|(
literal|"schema"
argument_list|,
literal|"schema-minimal-atomic-stress.xml"
argument_list|)
expr_stmt|;
name|assertNotNull
argument_list|(
name|cluster
operator|.
name|createCollection
argument_list|(
name|COLLECTION_NAME
argument_list|,
name|numShards
argument_list|,
name|repFactor
argument_list|,
name|configName
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
name|collectionProperties
argument_list|)
argument_list|)
expr_stmt|;
name|CLOUD_CLIENT
operator|=
name|cluster
operator|.
name|getSolrClient
argument_list|()
expr_stmt|;
name|CLOUD_CLIENT
operator|.
name|setDefaultCollection
argument_list|(
name|COLLECTION_NAME
argument_list|)
expr_stmt|;
name|waitForRecoveriesToFinish
argument_list|(
name|CLOUD_CLIENT
argument_list|)
expr_stmt|;
for|for
control|(
name|JettySolrRunner
name|jetty
range|:
name|cluster
operator|.
name|getJettySolrRunners
argument_list|()
control|)
block|{
name|CLIENTS
operator|.
name|add
argument_list|(
name|getHttpSolrClient
argument_list|(
name|jetty
operator|.
name|getBaseUrl
argument_list|()
operator|+
literal|"/"
operator|+
name|COLLECTION_NAME
operator|+
literal|"/"
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// sanity check no one broke the assumptions we make about our schema
name|checkExpectedSchemaType
argument_list|(
name|map
argument_list|(
literal|"name"
argument_list|,
literal|"long"
argument_list|,
literal|"class"
argument_list|,
literal|"solr.TrieLongField"
argument_list|,
literal|"multiValued"
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|,
literal|"indexed"
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|,
literal|"stored"
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|,
literal|"docValues"
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|AfterClass
DECL|method|afterClass
specifier|private
specifier|static
name|void
name|afterClass
parameter_list|()
throws|throws
name|Exception
block|{
name|TestInjection
operator|.
name|reset
argument_list|()
expr_stmt|;
name|ExecutorUtil
operator|.
name|shutdownAndAwaitTermination
argument_list|(
name|EXEC_SERVICE
argument_list|)
expr_stmt|;
name|EXEC_SERVICE
operator|=
literal|null
expr_stmt|;
name|CLOUD_CLIENT
operator|.
name|close
argument_list|()
expr_stmt|;
name|CLOUD_CLIENT
operator|=
literal|null
expr_stmt|;
for|for
control|(
name|HttpSolrClient
name|client
range|:
name|CLIENTS
control|)
block|{
name|client
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
name|CLIENTS
operator|=
literal|null
expr_stmt|;
block|}
annotation|@
name|Before
DECL|method|clearCloudCollection
specifier|private
name|void
name|clearCloudCollection
parameter_list|()
throws|throws
name|Exception
block|{
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|CLOUD_CLIENT
operator|.
name|deleteByQuery
argument_list|(
literal|"*:*"
argument_list|)
operator|.
name|getStatus
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|CLOUD_CLIENT
operator|.
name|optimize
argument_list|()
operator|.
name|getStatus
argument_list|()
argument_list|)
expr_stmt|;
name|TestInjection
operator|.
name|reset
argument_list|()
expr_stmt|;
specifier|final
name|int
name|injectionPercentage
init|=
operator|(
name|int
operator|)
name|Math
operator|.
name|ceil
argument_list|(
name|atLeast
argument_list|(
literal|1
argument_list|)
operator|/
literal|2
argument_list|)
decl_stmt|;
specifier|final
name|String
name|testInjection
init|=
name|usually
argument_list|()
condition|?
literal|"false:0"
else|:
operator|(
literal|"true:"
operator|+
name|injectionPercentage
operator|)
decl_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"TestInjection: fail replica, update pause, tlog pauses: "
operator|+
name|testInjection
argument_list|)
expr_stmt|;
name|TestInjection
operator|.
name|failReplicaRequests
operator|=
name|testInjection
expr_stmt|;
name|TestInjection
operator|.
name|updateLogReplayRandomPause
operator|=
name|testInjection
expr_stmt|;
name|TestInjection
operator|.
name|updateRandomPause
operator|=
name|testInjection
expr_stmt|;
block|}
DECL|method|test_dv
specifier|public
name|void
name|test_dv
parameter_list|()
throws|throws
name|Exception
block|{
name|String
name|field
init|=
literal|"long_dv"
decl_stmt|;
name|checkExpectedSchemaField
argument_list|(
name|map
argument_list|(
literal|"name"
argument_list|,
name|field
argument_list|,
literal|"type"
argument_list|,
literal|"long"
argument_list|,
literal|"stored"
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|,
literal|"indexed"
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|,
literal|"docValues"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
argument_list|)
expr_stmt|;
name|checkField
argument_list|(
name|field
argument_list|)
expr_stmt|;
block|}
DECL|method|test_dv_stored
specifier|public
name|void
name|test_dv_stored
parameter_list|()
throws|throws
name|Exception
block|{
name|String
name|field
init|=
literal|"long_dv_stored"
decl_stmt|;
name|checkExpectedSchemaField
argument_list|(
name|map
argument_list|(
literal|"name"
argument_list|,
name|field
argument_list|,
literal|"type"
argument_list|,
literal|"long"
argument_list|,
literal|"stored"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|,
literal|"indexed"
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|,
literal|"docValues"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
argument_list|)
expr_stmt|;
name|checkField
argument_list|(
name|field
argument_list|)
expr_stmt|;
block|}
DECL|method|test_dv_stored_idx
specifier|public
name|void
name|test_dv_stored_idx
parameter_list|()
throws|throws
name|Exception
block|{
name|String
name|field
init|=
literal|"long_dv_stored_idx"
decl_stmt|;
name|checkExpectedSchemaField
argument_list|(
name|map
argument_list|(
literal|"name"
argument_list|,
name|field
argument_list|,
literal|"type"
argument_list|,
literal|"long"
argument_list|,
literal|"stored"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|,
literal|"indexed"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|,
literal|"docValues"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
argument_list|)
expr_stmt|;
name|checkField
argument_list|(
name|field
argument_list|)
expr_stmt|;
block|}
DECL|method|test_dv_idx
specifier|public
name|void
name|test_dv_idx
parameter_list|()
throws|throws
name|Exception
block|{
name|String
name|field
init|=
literal|"long_dv_idx"
decl_stmt|;
name|checkExpectedSchemaField
argument_list|(
name|map
argument_list|(
literal|"name"
argument_list|,
name|field
argument_list|,
literal|"type"
argument_list|,
literal|"long"
argument_list|,
literal|"stored"
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|,
literal|"indexed"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|,
literal|"docValues"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
argument_list|)
expr_stmt|;
name|checkField
argument_list|(
name|field
argument_list|)
expr_stmt|;
block|}
DECL|method|test_stored_idx
specifier|public
name|void
name|test_stored_idx
parameter_list|()
throws|throws
name|Exception
block|{
name|String
name|field
init|=
literal|"long_stored_idx"
decl_stmt|;
name|checkExpectedSchemaField
argument_list|(
name|map
argument_list|(
literal|"name"
argument_list|,
name|field
argument_list|,
literal|"type"
argument_list|,
literal|"long"
argument_list|,
literal|"stored"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|,
literal|"indexed"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|,
literal|"docValues"
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
argument_list|)
expr_stmt|;
name|checkField
argument_list|(
name|field
argument_list|)
expr_stmt|;
block|}
DECL|method|checkField
specifier|public
name|void
name|checkField
parameter_list|(
specifier|final
name|String
name|numericFieldName
parameter_list|)
throws|throws
name|Exception
block|{
specifier|final
name|CountDownLatch
name|abortLatch
init|=
operator|new
name|CountDownLatch
argument_list|(
literal|1
argument_list|)
decl_stmt|;
specifier|final
name|int
name|numDocsToCheck
init|=
name|atLeast
argument_list|(
literal|37
argument_list|)
decl_stmt|;
specifier|final
name|int
name|numDocsInIndex
init|=
operator|(
name|numDocsToCheck
operator|*
name|DOC_ID_INCR
operator|)
decl_stmt|;
specifier|final
name|AtomicLong
index|[]
name|expected
init|=
operator|new
name|AtomicLong
index|[
name|numDocsToCheck
index|]
decl_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Testing "
operator|+
name|numericFieldName
operator|+
literal|": numDocsToCheck="
operator|+
name|numDocsToCheck
operator|+
literal|", numDocsInIndex="
operator|+
name|numDocsInIndex
operator|+
literal|", incr="
operator|+
name|DOC_ID_INCR
argument_list|)
expr_stmt|;
comment|// seed the index& keep track of what docs exist and with what values
for|for
control|(
name|int
name|id
init|=
literal|0
init|;
name|id
operator|<
name|numDocsInIndex
condition|;
name|id
operator|++
control|)
block|{
comment|// NOTE: the field we're mutating is a long, but we seed with a random int,
comment|// and we will inc/dec by random smaller ints, to ensure we never over/under flow
specifier|final
name|int
name|initValue
init|=
name|random
argument_list|()
operator|.
name|nextInt
argument_list|()
decl_stmt|;
name|SolrInputDocument
name|doc
init|=
name|doc
argument_list|(
name|f
argument_list|(
literal|"id"
argument_list|,
literal|""
operator|+
name|id
argument_list|)
argument_list|,
name|f
argument_list|(
name|numericFieldName
argument_list|,
name|initValue
argument_list|)
argument_list|)
decl_stmt|;
name|UpdateResponse
name|rsp
init|=
name|update
argument_list|(
name|doc
argument_list|)
operator|.
name|process
argument_list|(
name|CLOUD_CLIENT
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|doc
operator|.
name|toString
argument_list|()
operator|+
literal|" => "
operator|+
name|rsp
operator|.
name|toString
argument_list|()
argument_list|,
literal|0
argument_list|,
name|rsp
operator|.
name|getStatus
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|==
name|id
operator|%
name|DOC_ID_INCR
condition|)
block|{
name|expected
index|[
call|(
name|int
call|)
argument_list|(
name|id
operator|/
name|DOC_ID_INCR
argument_list|)
index|]
operator|=
operator|new
name|AtomicLong
argument_list|(
name|initValue
argument_list|)
expr_stmt|;
block|}
block|}
name|assertNotNull
argument_list|(
literal|"Sanity Check no off-by-one in expected init: "
argument_list|,
name|expected
index|[
name|expected
operator|.
name|length
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
comment|// sanity check index contents
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|CLOUD_CLIENT
operator|.
name|commit
argument_list|()
operator|.
name|getStatus
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|numDocsInIndex
argument_list|,
name|CLOUD_CLIENT
operator|.
name|query
argument_list|(
name|params
argument_list|(
literal|"q"
argument_list|,
literal|"*:*"
argument_list|)
argument_list|)
operator|.
name|getResults
argument_list|()
operator|.
name|getNumFound
argument_list|()
argument_list|)
expr_stmt|;
comment|// spin up parallel workers to hammer updates
name|List
argument_list|<
name|Future
argument_list|<
name|Worker
argument_list|>
argument_list|>
name|results
init|=
operator|new
name|ArrayList
argument_list|<
name|Future
argument_list|<
name|Worker
argument_list|>
argument_list|>
argument_list|(
name|NUM_THREADS
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|workerId
init|=
literal|0
init|;
name|workerId
operator|<
name|NUM_THREADS
condition|;
name|workerId
operator|++
control|)
block|{
name|Worker
name|worker
init|=
operator|new
name|Worker
argument_list|(
name|workerId
argument_list|,
name|expected
argument_list|,
name|abortLatch
argument_list|,
operator|new
name|Random
argument_list|(
name|random
argument_list|()
operator|.
name|nextLong
argument_list|()
argument_list|)
argument_list|,
name|numericFieldName
argument_list|)
decl_stmt|;
comment|// ask for the Worker to be returned in the Future so we can inspect it
name|results
operator|.
name|add
argument_list|(
name|EXEC_SERVICE
operator|.
name|submit
argument_list|(
name|worker
argument_list|,
name|worker
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// check the results of all our workers
for|for
control|(
name|Future
argument_list|<
name|Worker
argument_list|>
name|r
range|:
name|results
control|)
block|{
try|try
block|{
name|Worker
name|w
init|=
name|r
operator|.
name|get
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|w
operator|.
name|getFinishedOk
argument_list|()
condition|)
block|{
comment|// quick and dirty sanity check if any workers didn't succeed, but didn't throw an exception either
name|abortLatch
operator|.
name|countDown
argument_list|()
expr_stmt|;
name|log
operator|.
name|error
argument_list|(
literal|"worker={} didn't finish ok, but didn't throw exception?"
argument_list|,
name|w
operator|.
name|workerId
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|ExecutionException
name|ee
parameter_list|)
block|{
name|Throwable
name|rootCause
init|=
name|ee
operator|.
name|getCause
argument_list|()
decl_stmt|;
if|if
condition|(
name|rootCause
operator|instanceof
name|Error
condition|)
block|{
comment|// low level error, or test assertion failure - either way don't leave it wrapped
name|log
operator|.
name|error
argument_list|(
literal|"Worker exec Error, throwing root cause"
argument_list|,
name|ee
argument_list|)
expr_stmt|;
throw|throw
operator|(
name|Error
operator|)
name|rootCause
throw|;
block|}
else|else
block|{
name|log
operator|.
name|error
argument_list|(
literal|"Worker ExecutionException, re-throwing"
argument_list|,
name|ee
argument_list|)
expr_stmt|;
throw|throw
name|ee
throw|;
block|}
block|}
block|}
name|assertEquals
argument_list|(
literal|"Abort latch has changed, why didn't we get an exception from a worker?"
argument_list|,
literal|1L
argument_list|,
name|abortLatch
operator|.
name|getCount
argument_list|()
argument_list|)
expr_stmt|;
name|TestInjection
operator|.
name|reset
argument_list|()
expr_stmt|;
name|waitForRecoveriesToFinish
argument_list|(
name|CLOUD_CLIENT
argument_list|)
expr_stmt|;
comment|// check all the final index contents match our expectations
name|int
name|incorrectDocs
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|id
init|=
literal|0
init|;
name|id
operator|<
name|numDocsInIndex
condition|;
name|id
operator|+=
name|DOC_ID_INCR
control|)
block|{
assert|assert
literal|0
operator|==
name|id
operator|%
name|DOC_ID_INCR
operator|:
literal|"WTF? "
operator|+
name|id
assert|;
specifier|final
name|long
name|expect
init|=
name|expected
index|[
call|(
name|int
call|)
argument_list|(
name|id
operator|/
name|DOC_ID_INCR
argument_list|)
index|]
operator|.
name|longValue
argument_list|()
decl_stmt|;
specifier|final
name|String
name|docId
init|=
literal|""
operator|+
name|id
decl_stmt|;
comment|// sometimes include an fq on the expected value to ensure the updated values
comment|// are "visible" for searching
specifier|final
name|SolrParams
name|p
init|=
operator|(
literal|0
operator|!=
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|random
argument_list|()
argument_list|,
literal|0
argument_list|,
literal|15
argument_list|)
operator|)
condition|?
name|params
argument_list|()
else|:
name|params
argument_list|(
literal|"fq"
argument_list|,
name|numericFieldName
operator|+
literal|":"
operator|+
name|expect
argument_list|)
decl_stmt|;
name|SolrDocument
name|doc
init|=
name|getRandClient
argument_list|(
name|random
argument_list|()
argument_list|)
operator|.
name|getById
argument_list|(
name|docId
argument_list|,
name|p
argument_list|)
decl_stmt|;
specifier|final
name|boolean
name|foundWithFilter
init|=
operator|(
literal|null
operator|!=
name|doc
operator|)
decl_stmt|;
if|if
condition|(
operator|!
name|foundWithFilter
condition|)
block|{
comment|// try again w/o fq to see what it does have
name|doc
operator|=
name|getRandClient
argument_list|(
name|random
argument_list|()
argument_list|)
operator|.
name|getById
argument_list|(
name|docId
argument_list|)
expr_stmt|;
block|}
name|Long
name|actual
init|=
operator|(
literal|null
operator|==
name|doc
operator|)
condition|?
literal|null
else|:
operator|(
name|Long
operator|)
name|doc
operator|.
name|getFirstValue
argument_list|(
name|numericFieldName
argument_list|)
decl_stmt|;
if|if
condition|(
name|actual
operator|==
literal|null
operator|||
name|expect
operator|!=
name|actual
operator|.
name|longValue
argument_list|()
operator|||
operator|!
name|foundWithFilter
condition|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"docId={}, foundWithFilter={}, expected={}, actual={}"
argument_list|,
name|docId
argument_list|,
name|foundWithFilter
argument_list|,
name|expect
argument_list|,
name|actual
argument_list|)
expr_stmt|;
name|incorrectDocs
operator|++
expr_stmt|;
block|}
block|}
name|assertEquals
argument_list|(
literal|"Some docs had errors -- check logs"
argument_list|,
literal|0
argument_list|,
name|incorrectDocs
argument_list|)
expr_stmt|;
block|}
DECL|class|Worker
specifier|public
specifier|static
specifier|final
class|class
name|Worker
implements|implements
name|Runnable
block|{
DECL|field|workerId
specifier|public
specifier|final
name|int
name|workerId
decl_stmt|;
DECL|field|expected
specifier|final
name|AtomicLong
index|[]
name|expected
decl_stmt|;
DECL|field|abortLatch
specifier|final
name|CountDownLatch
name|abortLatch
decl_stmt|;
DECL|field|rand
specifier|final
name|Random
name|rand
decl_stmt|;
DECL|field|updateField
specifier|final
name|String
name|updateField
decl_stmt|;
DECL|field|numDocsToUpdate
specifier|final
name|int
name|numDocsToUpdate
decl_stmt|;
DECL|field|ok
name|boolean
name|ok
init|=
literal|false
decl_stmt|;
comment|// set to true only on successful completion
DECL|method|Worker
specifier|public
name|Worker
parameter_list|(
name|int
name|workerId
parameter_list|,
name|AtomicLong
index|[]
name|expected
parameter_list|,
name|CountDownLatch
name|abortLatch
parameter_list|,
name|Random
name|rand
parameter_list|,
name|String
name|updateField
parameter_list|)
block|{
name|this
operator|.
name|workerId
operator|=
name|workerId
expr_stmt|;
name|this
operator|.
name|expected
operator|=
name|expected
expr_stmt|;
name|this
operator|.
name|abortLatch
operator|=
name|abortLatch
expr_stmt|;
name|this
operator|.
name|rand
operator|=
name|rand
expr_stmt|;
name|this
operator|.
name|updateField
operator|=
name|updateField
expr_stmt|;
name|this
operator|.
name|numDocsToUpdate
operator|=
name|atLeast
argument_list|(
name|rand
argument_list|,
literal|25
argument_list|)
expr_stmt|;
block|}
DECL|method|getFinishedOk
specifier|public
name|boolean
name|getFinishedOk
parameter_list|()
block|{
return|return
name|ok
return|;
block|}
DECL|method|doRandomAtomicUpdate
specifier|private
name|void
name|doRandomAtomicUpdate
parameter_list|(
name|int
name|docId
parameter_list|)
throws|throws
name|Exception
block|{
assert|assert
literal|0
operator|==
name|docId
operator|%
name|DOC_ID_INCR
operator|:
literal|"WTF? "
operator|+
name|docId
assert|;
specifier|final
name|int
name|delta
init|=
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|rand
argument_list|,
operator|-
literal|1000
argument_list|,
literal|1000
argument_list|)
decl_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"worker={}, docId={}, delta={}"
argument_list|,
name|workerId
argument_list|,
name|docId
argument_list|,
name|delta
argument_list|)
expr_stmt|;
name|SolrClient
name|client
init|=
name|getRandClient
argument_list|(
name|rand
argument_list|)
decl_stmt|;
name|SolrInputDocument
name|doc
init|=
name|doc
argument_list|(
name|f
argument_list|(
literal|"id"
argument_list|,
literal|""
operator|+
name|docId
argument_list|)
argument_list|,
name|f
argument_list|(
name|updateField
argument_list|,
name|Collections
operator|.
name|singletonMap
argument_list|(
literal|"inc"
argument_list|,
name|delta
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|UpdateResponse
name|rsp
init|=
name|update
argument_list|(
name|doc
argument_list|)
operator|.
name|process
argument_list|(
name|client
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|doc
operator|+
literal|" => "
operator|+
name|rsp
argument_list|,
literal|0
argument_list|,
name|rsp
operator|.
name|getStatus
argument_list|()
argument_list|)
expr_stmt|;
name|AtomicLong
name|counter
init|=
name|expected
index|[
call|(
name|int
call|)
argument_list|(
name|docId
operator|/
name|DOC_ID_INCR
argument_list|)
index|]
decl_stmt|;
name|assertNotNull
argument_list|(
literal|"null counter for "
operator|+
name|docId
operator|+
literal|"/"
operator|+
name|DOC_ID_INCR
argument_list|,
name|counter
argument_list|)
expr_stmt|;
name|counter
operator|.
name|getAndAdd
argument_list|(
name|delta
argument_list|)
expr_stmt|;
block|}
DECL|method|run
specifier|public
name|void
name|run
parameter_list|()
block|{
specifier|final
name|String
name|origThreadName
init|=
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|getName
argument_list|()
decl_stmt|;
try|try
block|{
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|setName
argument_list|(
name|origThreadName
operator|+
literal|"-w"
operator|+
name|workerId
argument_list|)
expr_stmt|;
specifier|final
name|int
name|maxDocMultiplier
init|=
name|expected
operator|.
name|length
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|int
name|docIter
init|=
literal|0
init|;
name|docIter
operator|<
name|numDocsToUpdate
condition|;
name|docIter
operator|++
control|)
block|{
specifier|final
name|int
name|docId
init|=
name|DOC_ID_INCR
operator|*
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|rand
argument_list|,
literal|0
argument_list|,
name|maxDocMultiplier
argument_list|)
decl_stmt|;
comment|// tweak our thread name to keep track of what we're up to
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|setName
argument_list|(
name|origThreadName
operator|+
literal|"-w"
operator|+
name|workerId
operator|+
literal|"-d"
operator|+
name|docId
argument_list|)
expr_stmt|;
comment|// no matter how random the doc selection may be per thread, ensure
comment|// every doc that is selected by *a* thread gets at least a couple rapid fire updates
specifier|final
name|int
name|itersPerDoc
init|=
name|atLeast
argument_list|(
name|rand
argument_list|,
literal|2
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|updateIter
init|=
literal|0
init|;
name|updateIter
operator|<
name|itersPerDoc
condition|;
name|updateIter
operator|++
control|)
block|{
if|if
condition|(
literal|0
operator|==
name|abortLatch
operator|.
name|getCount
argument_list|()
condition|)
block|{
return|return;
block|}
name|doRandomAtomicUpdate
argument_list|(
name|docId
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rand
operator|.
name|nextBoolean
argument_list|()
condition|)
block|{
name|Thread
operator|.
name|yield
argument_list|()
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|Error
name|err
parameter_list|)
block|{
name|log
operator|.
name|error
argument_list|(
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|abortLatch
operator|.
name|countDown
argument_list|()
expr_stmt|;
throw|throw
name|err
throw|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
name|log
operator|.
name|error
argument_list|(
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|ex
argument_list|)
expr_stmt|;
name|abortLatch
operator|.
name|countDown
argument_list|()
expr_stmt|;
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|ex
operator|.
name|getMessage
argument_list|()
argument_list|,
name|ex
argument_list|)
throw|;
block|}
finally|finally
block|{
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|setName
argument_list|(
name|origThreadName
argument_list|)
expr_stmt|;
block|}
name|ok
operator|=
literal|true
expr_stmt|;
block|}
block|}
DECL|method|update
specifier|public
specifier|static
name|UpdateRequest
name|update
parameter_list|(
name|SolrInputDocument
modifier|...
name|docs
parameter_list|)
block|{
return|return
name|update
argument_list|(
literal|null
argument_list|,
name|docs
argument_list|)
return|;
block|}
DECL|method|update
specifier|public
specifier|static
name|UpdateRequest
name|update
parameter_list|(
name|SolrParams
name|params
parameter_list|,
name|SolrInputDocument
modifier|...
name|docs
parameter_list|)
block|{
name|UpdateRequest
name|r
init|=
operator|new
name|UpdateRequest
argument_list|()
decl_stmt|;
if|if
condition|(
literal|null
operator|!=
name|params
condition|)
block|{
name|r
operator|.
name|setParams
argument_list|(
operator|new
name|ModifiableSolrParams
argument_list|(
name|params
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|r
operator|.
name|add
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|docs
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
DECL|method|doc
specifier|public
specifier|static
name|SolrInputDocument
name|doc
parameter_list|(
name|SolrInputField
modifier|...
name|fields
parameter_list|)
block|{
name|SolrInputDocument
name|doc
init|=
operator|new
name|SolrInputDocument
argument_list|()
decl_stmt|;
for|for
control|(
name|SolrInputField
name|f
range|:
name|fields
control|)
block|{
name|doc
operator|.
name|put
argument_list|(
name|f
operator|.
name|getName
argument_list|()
argument_list|,
name|f
argument_list|)
expr_stmt|;
block|}
return|return
name|doc
return|;
block|}
DECL|method|f
specifier|public
specifier|static
name|SolrInputField
name|f
parameter_list|(
name|String
name|fieldName
parameter_list|,
name|Object
modifier|...
name|values
parameter_list|)
block|{
name|SolrInputField
name|f
init|=
operator|new
name|SolrInputField
argument_list|(
name|fieldName
argument_list|)
decl_stmt|;
name|f
operator|.
name|setValue
argument_list|(
name|values
argument_list|,
literal|1.0F
argument_list|)
expr_stmt|;
comment|// TODO: soooooooooo stupid (but currently neccessary because atomic updates freak out
comment|// if the Map with the "inc" operation is inside of a collection - even if it's the only "value") ...
if|if
condition|(
literal|1
operator|==
name|values
operator|.
name|length
condition|)
block|{
name|f
operator|.
name|setValue
argument_list|(
name|values
index|[
literal|0
index|]
argument_list|,
literal|1.0F
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|f
operator|.
name|setValue
argument_list|(
name|values
argument_list|,
literal|1.0F
argument_list|)
expr_stmt|;
block|}
return|return
name|f
return|;
block|}
DECL|method|getRandClient
specifier|public
specifier|static
name|SolrClient
name|getRandClient
parameter_list|(
name|Random
name|rand
parameter_list|)
block|{
name|int
name|numClients
init|=
name|CLIENTS
operator|.
name|size
argument_list|()
decl_stmt|;
name|int
name|idx
init|=
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|rand
argument_list|,
literal|0
argument_list|,
name|numClients
argument_list|)
decl_stmt|;
return|return
operator|(
name|idx
operator|==
name|numClients
operator|)
condition|?
name|CLOUD_CLIENT
else|:
name|CLIENTS
operator|.
name|get
argument_list|(
name|idx
argument_list|)
return|;
block|}
DECL|method|waitForRecoveriesToFinish
specifier|public
specifier|static
name|void
name|waitForRecoveriesToFinish
parameter_list|(
name|CloudSolrClient
name|client
parameter_list|)
throws|throws
name|Exception
block|{
assert|assert
literal|null
operator|!=
name|client
operator|.
name|getDefaultCollection
argument_list|()
assert|;
name|AbstractDistribZkTestBase
operator|.
name|waitForRecoveriesToFinish
argument_list|(
name|client
operator|.
name|getDefaultCollection
argument_list|()
argument_list|,
name|client
operator|.
name|getZkStateReader
argument_list|()
argument_list|,
literal|true
argument_list|,
literal|true
argument_list|,
literal|330
argument_list|)
expr_stmt|;
block|}
comment|/**    * Use the schema API to verify that the specified expected Field exists with those exact attributes.     * @see #CLOUD_CLIENT    */
DECL|method|checkExpectedSchemaField
specifier|public
specifier|static
name|void
name|checkExpectedSchemaField
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|expected
parameter_list|)
throws|throws
name|Exception
block|{
name|String
name|fieldName
init|=
operator|(
name|String
operator|)
name|expected
operator|.
name|get
argument_list|(
literal|"name"
argument_list|)
decl_stmt|;
name|assertNotNull
argument_list|(
literal|"expected contains no name: "
operator|+
name|expected
argument_list|,
name|fieldName
argument_list|)
expr_stmt|;
name|FieldResponse
name|rsp
init|=
operator|new
name|Field
argument_list|(
name|fieldName
argument_list|)
operator|.
name|process
argument_list|(
name|CLOUD_CLIENT
argument_list|)
decl_stmt|;
name|assertNotNull
argument_list|(
literal|"Field Null Response: "
operator|+
name|fieldName
argument_list|,
name|rsp
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Field Status: "
operator|+
name|fieldName
operator|+
literal|" => "
operator|+
name|rsp
operator|.
name|toString
argument_list|()
argument_list|,
literal|0
argument_list|,
name|rsp
operator|.
name|getStatus
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Field: "
operator|+
name|fieldName
argument_list|,
name|expected
argument_list|,
name|rsp
operator|.
name|getField
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * Use the schema API to verify that the specified expected FieldType exists with those exact attributes.     * @see #CLOUD_CLIENT    */
DECL|method|checkExpectedSchemaType
specifier|public
specifier|static
name|void
name|checkExpectedSchemaType
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|expected
parameter_list|)
throws|throws
name|Exception
block|{
name|String
name|typeName
init|=
operator|(
name|String
operator|)
name|expected
operator|.
name|get
argument_list|(
literal|"name"
argument_list|)
decl_stmt|;
name|assertNotNull
argument_list|(
literal|"expected contains no type: "
operator|+
name|expected
argument_list|,
name|typeName
argument_list|)
expr_stmt|;
name|FieldTypeResponse
name|rsp
init|=
operator|new
name|FieldType
argument_list|(
name|typeName
argument_list|)
operator|.
name|process
argument_list|(
name|CLOUD_CLIENT
argument_list|)
decl_stmt|;
name|assertNotNull
argument_list|(
literal|"FieldType Null Response: "
operator|+
name|typeName
argument_list|,
name|rsp
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"FieldType Status: "
operator|+
name|typeName
operator|+
literal|" => "
operator|+
name|rsp
operator|.
name|toString
argument_list|()
argument_list|,
literal|0
argument_list|,
name|rsp
operator|.
name|getStatus
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"FieldType: "
operator|+
name|typeName
argument_list|,
name|expected
argument_list|,
name|rsp
operator|.
name|getFieldType
argument_list|()
operator|.
name|getAttributes
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
end_class
end_unit
