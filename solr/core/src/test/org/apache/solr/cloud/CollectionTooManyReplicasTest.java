begin_unit
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_package
DECL|package|org.apache.solr.cloud
package|package
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|cloud
package|;
end_package
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Properties
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|lang
operator|.
name|StringUtils
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|LuceneTestCase
operator|.
name|Slow
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|client
operator|.
name|solrj
operator|.
name|embedded
operator|.
name|JettySolrRunner
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|client
operator|.
name|solrj
operator|.
name|impl
operator|.
name|HttpSolrClient
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|client
operator|.
name|solrj
operator|.
name|request
operator|.
name|CollectionAdminRequest
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|client
operator|.
name|solrj
operator|.
name|response
operator|.
name|CollectionAdminResponse
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|cloud
operator|.
name|Replica
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|cloud
operator|.
name|Slice
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|cloud
operator|.
name|SolrZkClient
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|cloud
operator|.
name|ZkStateReader
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|util
operator|.
name|NamedList
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|KeeperException
import|;
end_import
begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Test
import|;
end_import
begin_class
annotation|@
name|Slow
DECL|class|CollectionTooManyReplicasTest
specifier|public
class|class
name|CollectionTooManyReplicasTest
extends|extends
name|AbstractFullDistribZkTestBase
block|{
DECL|method|CollectionTooManyReplicasTest
specifier|public
name|CollectionTooManyReplicasTest
parameter_list|()
block|{
name|sliceCount
operator|=
literal|1
expr_stmt|;
block|}
annotation|@
name|Test
annotation|@
name|ShardsFixed
argument_list|(
name|num
operator|=
literal|1
argument_list|)
DECL|method|testAddTooManyReplicas
specifier|public
name|void
name|testAddTooManyReplicas
parameter_list|()
throws|throws
name|Exception
block|{
name|String
name|collectionName
init|=
literal|"TooManyReplicasInSeveralFlavors"
decl_stmt|;
name|CollectionAdminRequest
operator|.
name|Create
name|create
init|=
operator|new
name|CollectionAdminRequest
operator|.
name|Create
argument_list|()
operator|.
name|setCollectionName
argument_list|(
name|collectionName
argument_list|)
operator|.
name|setNumShards
argument_list|(
literal|2
argument_list|)
operator|.
name|setReplicationFactor
argument_list|(
literal|1
argument_list|)
operator|.
name|setMaxShardsPerNode
argument_list|(
literal|2
argument_list|)
operator|.
name|setStateFormat
argument_list|(
literal|2
argument_list|)
decl_stmt|;
name|CollectionAdminResponse
name|response
init|=
name|create
operator|.
name|process
argument_list|(
name|cloudClient
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|response
operator|.
name|getStatus
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|response
operator|.
name|isSuccess
argument_list|()
argument_list|)
expr_stmt|;
comment|// Now I have the fixed Jetty plus the control instnace, I have two replicas, one for each shard
comment|// Curiously, I should be able to add a bunch of replicas if I specify the node, even more than maxShardsPerNode
comment|// Just get the first node any way we can.
comment|// Get a node to use for the "node" parameter.
name|String
name|nodeName
init|=
name|getAllNodeNames
argument_list|(
name|collectionName
argument_list|)
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
comment|// Add a replica using the "node" parameter (no "too many replicas check")
comment|// this node should have 2 replicas on it
name|CollectionAdminRequest
operator|.
name|AddReplica
name|addReplicaNode
init|=
operator|new
name|CollectionAdminRequest
operator|.
name|AddReplica
argument_list|()
operator|.
name|setCollectionName
argument_list|(
name|collectionName
argument_list|)
operator|.
name|setShardName
argument_list|(
literal|"shard1"
argument_list|)
operator|.
name|setNode
argument_list|(
name|nodeName
argument_list|)
decl_stmt|;
name|response
operator|=
name|addReplicaNode
operator|.
name|process
argument_list|(
name|cloudClient
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|response
operator|.
name|getStatus
argument_list|()
argument_list|)
expr_stmt|;
comment|// Three replicas so far, should be able to create another one "normally"
name|CollectionAdminRequest
operator|.
name|AddReplica
name|addReplica
init|=
operator|new
name|CollectionAdminRequest
operator|.
name|AddReplica
argument_list|()
operator|.
name|setCollectionName
argument_list|(
name|collectionName
argument_list|)
operator|.
name|setShardName
argument_list|(
literal|"shard1"
argument_list|)
decl_stmt|;
name|response
operator|=
name|addReplica
operator|.
name|process
argument_list|(
name|cloudClient
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|response
operator|.
name|getStatus
argument_list|()
argument_list|)
expr_stmt|;
comment|// This one should fail though, no "node" parameter specified
try|try
block|{
name|addReplica
operator|.
name|process
argument_list|(
name|cloudClient
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"Should have thrown an error because the nodes are full"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|HttpSolrClient
operator|.
name|RemoteSolrException
name|se
parameter_list|)
block|{
name|assertTrue
argument_list|(
literal|"Should have gotten the right error message back"
argument_list|,
name|se
operator|.
name|getMessage
argument_list|()
operator|.
name|contains
argument_list|(
literal|"given the current number of live nodes and a maxShardsPerNode of"
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// Oddly, we should succeed next just because setting property.name will not check for nodes being "full up"
name|Properties
name|props
init|=
operator|new
name|Properties
argument_list|()
decl_stmt|;
name|props
operator|.
name|setProperty
argument_list|(
literal|"name"
argument_list|,
literal|"bogus2"
argument_list|)
expr_stmt|;
name|addReplicaNode
operator|.
name|setProperties
argument_list|(
name|props
argument_list|)
expr_stmt|;
name|response
operator|=
name|addReplicaNode
operator|.
name|process
argument_list|(
name|cloudClient
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|response
operator|.
name|getStatus
argument_list|()
argument_list|)
expr_stmt|;
name|ZkStateReader
name|zkStateReader
init|=
name|getCommonCloudSolrClient
argument_list|()
operator|.
name|getZkStateReader
argument_list|()
decl_stmt|;
name|zkStateReader
operator|.
name|forceUpdateCollection
argument_list|(
name|collectionName
argument_list|)
expr_stmt|;
name|Slice
name|slice
init|=
name|zkStateReader
operator|.
name|getClusterState
argument_list|()
operator|.
name|getSlicesMap
argument_list|(
name|collectionName
argument_list|)
operator|.
name|get
argument_list|(
literal|"shard1"
argument_list|)
decl_stmt|;
name|Replica
name|rep
init|=
literal|null
decl_stmt|;
for|for
control|(
name|Replica
name|rep1
range|:
name|slice
operator|.
name|getReplicas
argument_list|()
control|)
block|{
comment|// Silly compiler
if|if
condition|(
name|rep1
operator|.
name|get
argument_list|(
literal|"core"
argument_list|)
operator|.
name|equals
argument_list|(
literal|"bogus2"
argument_list|)
condition|)
block|{
name|rep
operator|=
name|rep1
expr_stmt|;
break|break;
block|}
block|}
name|assertNotNull
argument_list|(
literal|"Should have found a replica named 'bogus2'"
argument_list|,
name|rep
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Replica should have been put on correct core"
argument_list|,
name|nodeName
argument_list|,
name|rep
operator|.
name|getNodeName
argument_list|()
argument_list|)
expr_stmt|;
comment|// Shard1 should have 4 replicas
name|assertEquals
argument_list|(
literal|"There should be 4 replicas for shard 1"
argument_list|,
literal|4
argument_list|,
name|slice
operator|.
name|getReplicas
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
comment|// And let's fail one more time because to insure that the math doesn't do weird stuff it we have more replicas
comment|// than simple calcs would indicate.
try|try
block|{
name|addReplica
operator|.
name|process
argument_list|(
name|cloudClient
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"Should have thrown an error because the nodes are full"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|HttpSolrClient
operator|.
name|RemoteSolrException
name|se
parameter_list|)
block|{
name|assertTrue
argument_list|(
literal|"Should have gotten the right error message back"
argument_list|,
name|se
operator|.
name|getMessage
argument_list|()
operator|.
name|contains
argument_list|(
literal|"given the current number of live nodes and a maxShardsPerNode of"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Test
annotation|@
name|ShardsFixed
argument_list|(
name|num
operator|=
literal|2
argument_list|)
DECL|method|testAddShard
specifier|public
name|void
name|testAddShard
parameter_list|()
throws|throws
name|Exception
block|{
name|String
name|collectionName
init|=
literal|"TooManyReplicasWhenAddingShards"
decl_stmt|;
name|CollectionAdminRequest
operator|.
name|Create
name|create
init|=
operator|new
name|CollectionAdminRequest
operator|.
name|Create
argument_list|()
operator|.
name|setCollectionName
argument_list|(
name|collectionName
argument_list|)
operator|.
name|setReplicationFactor
argument_list|(
literal|2
argument_list|)
operator|.
name|setMaxShardsPerNode
argument_list|(
literal|2
argument_list|)
operator|.
name|setStateFormat
argument_list|(
literal|2
argument_list|)
operator|.
name|setRouterName
argument_list|(
literal|"implicit"
argument_list|)
operator|.
name|setShards
argument_list|(
literal|"shardstart"
argument_list|)
decl_stmt|;
name|NamedList
argument_list|<
name|Object
argument_list|>
name|request
init|=
name|create
operator|.
name|process
argument_list|(
name|cloudClient
argument_list|)
operator|.
name|getResponse
argument_list|()
decl_stmt|;
name|assertTrue
argument_list|(
literal|"Could not create the collection"
argument_list|,
name|request
operator|.
name|get
argument_list|(
literal|"success"
argument_list|)
operator|!=
literal|null
argument_list|)
expr_stmt|;
comment|// We have two nodes, maxShardsPerNode is set to 2. Therefore, we should be able to add 2 shards each with
comment|// two replicas, but fail on the third.
name|CollectionAdminRequest
operator|.
name|CreateShard
name|createShard
init|=
operator|new
name|CollectionAdminRequest
operator|.
name|CreateShard
argument_list|()
operator|.
name|setCollectionName
argument_list|(
name|collectionName
argument_list|)
operator|.
name|setShardName
argument_list|(
literal|"shard1"
argument_list|)
decl_stmt|;
name|CollectionAdminResponse
name|resp
init|=
name|createShard
operator|.
name|process
argument_list|(
name|cloudClient
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|resp
operator|.
name|getStatus
argument_list|()
argument_list|)
expr_stmt|;
comment|// Now we should have one replica on each Jetty, add another to reach maxShardsPerNode
name|createShard
operator|=
operator|new
name|CollectionAdminRequest
operator|.
name|CreateShard
argument_list|()
operator|.
name|setCollectionName
argument_list|(
name|collectionName
argument_list|)
operator|.
name|setShardName
argument_list|(
literal|"shard2"
argument_list|)
expr_stmt|;
name|resp
operator|=
name|createShard
operator|.
name|process
argument_list|(
name|cloudClient
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|resp
operator|.
name|getStatus
argument_list|()
argument_list|)
expr_stmt|;
comment|// Now fail to add the third as it should exceed maxShardsPerNode
name|createShard
operator|=
operator|new
name|CollectionAdminRequest
operator|.
name|CreateShard
argument_list|()
operator|.
name|setCollectionName
argument_list|(
name|collectionName
argument_list|)
operator|.
name|setShardName
argument_list|(
literal|"shard3"
argument_list|)
expr_stmt|;
try|try
block|{
name|createShard
operator|.
name|process
argument_list|(
name|cloudClient
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"Should have exceeded the max number of replicas allowed"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|HttpSolrClient
operator|.
name|RemoteSolrException
name|se
parameter_list|)
block|{
name|assertTrue
argument_list|(
literal|"Should have gotten the right error message back"
argument_list|,
name|se
operator|.
name|getMessage
argument_list|()
operator|.
name|contains
argument_list|(
literal|"given the current number of live nodes and a maxShardsPerNode of"
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// Hmmm, providing a nodeset also overrides the checks for max replicas, so prove it.
name|List
argument_list|<
name|String
argument_list|>
name|nodes
init|=
name|getAllNodeNames
argument_list|(
name|collectionName
argument_list|)
decl_stmt|;
name|createShard
operator|=
operator|new
name|CollectionAdminRequest
operator|.
name|CreateShard
argument_list|()
operator|.
name|setCollectionName
argument_list|(
name|collectionName
argument_list|)
operator|.
name|setShardName
argument_list|(
literal|"shard4"
argument_list|)
operator|.
name|setNodeSet
argument_list|(
name|StringUtils
operator|.
name|join
argument_list|(
name|nodes
argument_list|,
literal|","
argument_list|)
argument_list|)
expr_stmt|;
name|resp
operator|=
name|createShard
operator|.
name|process
argument_list|(
name|cloudClient
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|resp
operator|.
name|getStatus
argument_list|()
argument_list|)
expr_stmt|;
comment|// And just for yucks, insure we fail the "regular" one again.
name|createShard
operator|=
operator|new
name|CollectionAdminRequest
operator|.
name|CreateShard
argument_list|()
operator|.
name|setCollectionName
argument_list|(
name|collectionName
argument_list|)
operator|.
name|setShardName
argument_list|(
literal|"shard5"
argument_list|)
expr_stmt|;
try|try
block|{
name|createShard
operator|.
name|process
argument_list|(
name|cloudClient
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"Should have exceeded the max number of replicas allowed"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|HttpSolrClient
operator|.
name|RemoteSolrException
name|se
parameter_list|)
block|{
name|assertTrue
argument_list|(
literal|"Should have gotten the right error message back"
argument_list|,
name|se
operator|.
name|getMessage
argument_list|()
operator|.
name|contains
argument_list|(
literal|"given the current number of live nodes and a maxShardsPerNode of"
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// And finally, insure that there are all the replcias we expect. We should have shards 1, 2 and 4 and each
comment|// should have exactly two replicas
name|ZkStateReader
name|zkStateReader
init|=
name|getCommonCloudSolrClient
argument_list|()
operator|.
name|getZkStateReader
argument_list|()
decl_stmt|;
name|zkStateReader
operator|.
name|forceUpdateCollection
argument_list|(
name|collectionName
argument_list|)
expr_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|Slice
argument_list|>
name|slices
init|=
name|zkStateReader
operator|.
name|getClusterState
argument_list|()
operator|.
name|getSlicesMap
argument_list|(
name|collectionName
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|"There should be exaclty four slices"
argument_list|,
name|slices
operator|.
name|size
argument_list|()
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|assertNotNull
argument_list|(
literal|"shardstart should exist"
argument_list|,
name|slices
operator|.
name|get
argument_list|(
literal|"shardstart"
argument_list|)
argument_list|)
expr_stmt|;
name|assertNotNull
argument_list|(
literal|"shard1 should exist"
argument_list|,
name|slices
operator|.
name|get
argument_list|(
literal|"shard1"
argument_list|)
argument_list|)
expr_stmt|;
name|assertNotNull
argument_list|(
literal|"shard2 should exist"
argument_list|,
name|slices
operator|.
name|get
argument_list|(
literal|"shard2"
argument_list|)
argument_list|)
expr_stmt|;
name|assertNotNull
argument_list|(
literal|"shard4 should exist"
argument_list|,
name|slices
operator|.
name|get
argument_list|(
literal|"shard4"
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Shardstart should have exactly 2 replicas"
argument_list|,
literal|2
argument_list|,
name|slices
operator|.
name|get
argument_list|(
literal|"shardstart"
argument_list|)
operator|.
name|getReplicas
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Shard1 should have exactly 2 replicas"
argument_list|,
literal|2
argument_list|,
name|slices
operator|.
name|get
argument_list|(
literal|"shard1"
argument_list|)
operator|.
name|getReplicas
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Shard2 should have exactly 2 replicas"
argument_list|,
literal|2
argument_list|,
name|slices
operator|.
name|get
argument_list|(
literal|"shard2"
argument_list|)
operator|.
name|getReplicas
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Shard4 should have exactly 2 replicas"
argument_list|,
literal|2
argument_list|,
name|slices
operator|.
name|get
argument_list|(
literal|"shard4"
argument_list|)
operator|.
name|getReplicas
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
annotation|@
name|ShardsFixed
argument_list|(
name|num
operator|=
literal|2
argument_list|)
DECL|method|testDownedShards
specifier|public
name|void
name|testDownedShards
parameter_list|()
throws|throws
name|Exception
block|{
name|String
name|collectionName
init|=
literal|"TooManyReplicasWhenAddingDownedNode"
decl_stmt|;
name|CollectionAdminRequest
operator|.
name|Create
name|create
init|=
operator|new
name|CollectionAdminRequest
operator|.
name|Create
argument_list|()
operator|.
name|setCollectionName
argument_list|(
name|collectionName
argument_list|)
operator|.
name|setReplicationFactor
argument_list|(
literal|1
argument_list|)
operator|.
name|setMaxShardsPerNode
argument_list|(
literal|2
argument_list|)
operator|.
name|setStateFormat
argument_list|(
literal|2
argument_list|)
operator|.
name|setRouterName
argument_list|(
literal|"implicit"
argument_list|)
operator|.
name|setShards
argument_list|(
literal|"shardstart"
argument_list|)
decl_stmt|;
name|NamedList
argument_list|<
name|Object
argument_list|>
name|request
init|=
name|create
operator|.
name|process
argument_list|(
name|cloudClient
argument_list|)
operator|.
name|getResponse
argument_list|()
decl_stmt|;
name|assertTrue
argument_list|(
literal|"Could not create the collection"
argument_list|,
name|request
operator|.
name|get
argument_list|(
literal|"success"
argument_list|)
operator|!=
literal|null
argument_list|)
expr_stmt|;
try|try
init|(
name|SolrZkClient
name|zkClient
init|=
operator|new
name|SolrZkClient
argument_list|(
name|zkServer
operator|.
name|getZkAddress
argument_list|()
argument_list|,
name|AbstractZkTestCase
operator|.
name|TIMEOUT
argument_list|)
init|)
block|{
name|List
argument_list|<
name|String
argument_list|>
name|liveNodes
init|=
name|zkClient
operator|.
name|getChildren
argument_list|(
literal|"/live_nodes"
argument_list|,
literal|null
argument_list|,
literal|true
argument_list|)
decl_stmt|;
comment|// Shut down a Jetty, I really don't care which
name|JettySolrRunner
name|downJetty
init|=
name|jettys
operator|.
name|get
argument_list|(
name|r
operator|.
name|nextInt
argument_list|(
literal|2
argument_list|)
argument_list|)
decl_stmt|;
name|downJetty
operator|.
name|stop
argument_list|()
expr_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|liveNodesNow
init|=
literal|null
decl_stmt|;
for|for
control|(
name|int
name|idx
init|=
literal|0
init|;
name|idx
operator|<
literal|150
condition|;
operator|++
name|idx
control|)
block|{
name|liveNodesNow
operator|=
name|zkClient
operator|.
name|getChildren
argument_list|(
literal|"/live_nodes"
argument_list|,
literal|null
argument_list|,
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|liveNodesNow
operator|.
name|size
argument_list|()
operator|!=
name|liveNodes
operator|.
name|size
argument_list|()
condition|)
break|break;
name|Thread
operator|.
name|sleep
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
name|List
argument_list|<
name|String
argument_list|>
name|deadNodes
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|liveNodes
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
literal|"Should be a downed node"
argument_list|,
name|deadNodes
operator|.
name|removeAll
argument_list|(
name|liveNodesNow
argument_list|)
argument_list|)
expr_stmt|;
name|liveNodes
operator|.
name|removeAll
argument_list|(
name|deadNodes
argument_list|)
expr_stmt|;
comment|//OK, we've killed a node. Insure we get errors when we ask to create a replica or shard that involves it.
comment|// First try adding a  replica to the downed node.
name|CollectionAdminRequest
operator|.
name|AddReplica
name|addReplicaNode
init|=
operator|new
name|CollectionAdminRequest
operator|.
name|AddReplica
argument_list|()
operator|.
name|setCollectionName
argument_list|(
name|collectionName
argument_list|)
operator|.
name|setShardName
argument_list|(
literal|"shardstart"
argument_list|)
operator|.
name|setNode
argument_list|(
name|deadNodes
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
try|try
block|{
name|addReplicaNode
operator|.
name|process
argument_list|(
name|cloudClient
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"Should have gotten an exception"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|HttpSolrClient
operator|.
name|RemoteSolrException
name|se
parameter_list|)
block|{
name|assertTrue
argument_list|(
literal|"Should have gotten a message about shard not "
argument_list|,
name|se
operator|.
name|getMessage
argument_list|()
operator|.
name|contains
argument_list|(
literal|"At least one of the node(s) specified are not currently active, no action taken."
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// Should also die if we just add a shard
name|CollectionAdminRequest
operator|.
name|CreateShard
name|createShard
init|=
operator|new
name|CollectionAdminRequest
operator|.
name|CreateShard
argument_list|()
operator|.
name|setCollectionName
argument_list|(
name|collectionName
argument_list|)
operator|.
name|setShardName
argument_list|(
literal|"shard1"
argument_list|)
operator|.
name|setNodeSet
argument_list|(
name|deadNodes
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
try|try
block|{
name|createShard
operator|.
name|process
argument_list|(
name|cloudClient
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"Should have gotten an exception"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|HttpSolrClient
operator|.
name|RemoteSolrException
name|se
parameter_list|)
block|{
name|assertTrue
argument_list|(
literal|"Should have gotten a message about shard not "
argument_list|,
name|se
operator|.
name|getMessage
argument_list|()
operator|.
name|contains
argument_list|(
literal|"At least one of the node(s) specified are not currently active, no action taken."
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|//downJetty.start();
block|}
block|}
DECL|method|getAllNodeNames
specifier|private
name|List
argument_list|<
name|String
argument_list|>
name|getAllNodeNames
parameter_list|(
name|String
name|collectionName
parameter_list|)
throws|throws
name|KeeperException
throws|,
name|InterruptedException
block|{
name|ZkStateReader
name|zkStateReader
init|=
name|getCommonCloudSolrClient
argument_list|()
operator|.
name|getZkStateReader
argument_list|()
decl_stmt|;
name|zkStateReader
operator|.
name|forceUpdateCollection
argument_list|(
name|collectionName
argument_list|)
expr_stmt|;
name|Slice
name|slice
init|=
name|zkStateReader
operator|.
name|getClusterState
argument_list|()
operator|.
name|getSlicesMap
argument_list|(
name|collectionName
argument_list|)
operator|.
name|get
argument_list|(
literal|"shard1"
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|nodes
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|Replica
name|rep
range|:
name|slice
operator|.
name|getReplicas
argument_list|()
control|)
block|{
name|nodes
operator|.
name|add
argument_list|(
name|rep
operator|.
name|getNodeName
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|assertTrue
argument_list|(
literal|"Should have some nodes!"
argument_list|,
name|nodes
operator|.
name|size
argument_list|()
operator|>
literal|0
argument_list|)
expr_stmt|;
return|return
name|nodes
return|;
block|}
block|}
end_class
end_unit
