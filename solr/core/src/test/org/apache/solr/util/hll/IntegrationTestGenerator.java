begin_unit
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_package
DECL|package|org.apache.solr.util.hll
package|package
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|util
operator|.
name|hll
package|;
end_package
begin_import
import|import static
name|com
operator|.
name|carrotsearch
operator|.
name|randomizedtesting
operator|.
name|RandomizedTest
operator|.
name|*
import|;
end_import
begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|util
operator|.
name|hll
operator|.
name|ProbabilisticTestUtil
operator|.
name|*
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileWriter
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Random
import|;
end_import
begin_comment
comment|/**  * Generates test files for testing other implementations of HLL  * serialization/deserialization, namely the PostgreSQL implementation.  */
end_comment
begin_class
DECL|class|IntegrationTestGenerator
specifier|public
class|class
name|IntegrationTestGenerator
block|{
comment|// ************************************************************************
comment|// directory to output the generated tests
DECL|field|OUTPUT_DIRECTORY
specifier|private
specifier|static
specifier|final
name|String
name|OUTPUT_DIRECTORY
init|=
literal|"/tmp/hll_test/"
decl_stmt|;
comment|// ------------------------------------------------------------------------
comment|// configurations for HLLs, should mirror settings in PostgreSQL impl. tests
DECL|field|REGWIDTH
specifier|private
specifier|static
specifier|final
name|int
name|REGWIDTH
init|=
literal|5
decl_stmt|;
DECL|field|LOG2M
specifier|private
specifier|static
specifier|final
name|int
name|LOG2M
init|=
literal|11
decl_stmt|;
comment|// NOTE:  This differs from the PostgreSQL impl. parameter 'expthresh'. This
comment|//        is a literal threshold to use in the promotion hierarchy, implying
comment|//        that both EXPLICIT representation should be used and it should
comment|//        NOT be automatically computed. This is done to ensure that the
comment|//        parameters of the test are very explicitly defined.
DECL|field|EXPLICIT_THRESHOLD
specifier|private
specifier|static
specifier|final
name|int
name|EXPLICIT_THRESHOLD
init|=
literal|256
decl_stmt|;
comment|// NOTE:  This is not the PostgreSQL impl. parameter 'sparseon'. 'sparseon'
comment|//        is assumed to be true and this is a literal register-count threshold
comment|//        to use in the promotion hierarchy. This is done to ensure that the
comment|//        parameters of the test are very explicitly defined.
DECL|field|SPARSE_THRESHOLD
specifier|private
specifier|static
specifier|final
name|int
name|SPARSE_THRESHOLD
init|=
literal|850
decl_stmt|;
comment|// ------------------------------------------------------------------------
comment|// computed constants
DECL|field|REGISTER_COUNT
specifier|private
specifier|static
specifier|final
name|int
name|REGISTER_COUNT
init|=
operator|(
literal|1
operator|<<
name|LOG2M
operator|)
decl_stmt|;
DECL|field|REGISTER_MAX_VALUE
specifier|private
specifier|static
specifier|final
name|int
name|REGISTER_MAX_VALUE
init|=
operator|(
literal|1
operator|<<
name|REGWIDTH
operator|)
operator|-
literal|1
decl_stmt|;
comment|// ========================================================================
comment|// Tests
comment|/**      * Cumulatively adds random values to a FULL HLL through the small range      * correction, uncorrected range, and large range correction of the HLL's      * cardinality estimator.      *      * Format: cumulative add      * Tests:      * - FULL cardinality computation      */
DECL|method|fullCardinalityCorrectionTest
specifier|private
specifier|static
name|void
name|fullCardinalityCorrectionTest
parameter_list|(
specifier|final
name|ISchemaVersion
name|schemaVersion
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|FileWriter
name|output
init|=
name|openOutput
argument_list|(
name|schemaVersion
argument_list|,
literal|"cardinality_correction"
argument_list|,
name|TestType
operator|.
name|ADD
argument_list|)
decl_stmt|;
comment|// the accumulator, starts empty
specifier|final
name|HLL
name|hll
init|=
name|newHLL
argument_list|(
name|HLLType
operator|.
name|FULL
argument_list|)
decl_stmt|;
name|initLineAdd
argument_list|(
name|output
argument_list|,
name|hll
argument_list|,
name|schemaVersion
argument_list|)
expr_stmt|;
comment|// run through some values in the small range correction
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
operator|(
operator|(
literal|1
operator|<<
name|LOG2M
operator|)
operator|-
literal|1
operator|)
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|long
name|rawValue
init|=
name|constructHLLValue
argument_list|(
name|LOG2M
argument_list|,
name|i
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|cumulativeAddLine
argument_list|(
name|output
argument_list|,
name|hll
argument_list|,
name|rawValue
argument_list|,
name|schemaVersion
argument_list|)
expr_stmt|;
block|}
comment|// run up past some values in the uncorrected range
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
operator|(
literal|1
operator|<<
name|LOG2M
operator|)
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|long
name|rawValue
init|=
name|constructHLLValue
argument_list|(
name|LOG2M
argument_list|,
name|i
argument_list|,
literal|7
argument_list|)
decl_stmt|;
name|cumulativeAddLine
argument_list|(
name|output
argument_list|,
name|hll
argument_list|,
name|rawValue
argument_list|,
name|schemaVersion
argument_list|)
expr_stmt|;
block|}
comment|// run through some values in the large range correction
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
operator|(
literal|1
operator|<<
name|LOG2M
operator|)
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|long
name|rawValue
init|=
name|constructHLLValue
argument_list|(
name|LOG2M
argument_list|,
name|i
argument_list|,
literal|30
argument_list|)
decl_stmt|;
name|cumulativeAddLine
argument_list|(
name|output
argument_list|,
name|hll
argument_list|,
name|rawValue
argument_list|,
name|schemaVersion
argument_list|)
expr_stmt|;
block|}
name|output
operator|.
name|flush
argument_list|()
expr_stmt|;
name|output
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
comment|/**      * Cumulatively adds random values to an EMPTY HLL.      *      * Format: cumulative add      * Tests:      * - EMPTY, EXPLICIT, SPARSE, PROBABILSTIC addition      * - EMPTY to EXPLICIT promotion      * - EXPLICIT to SPARSE promotion      * - SPARSE to FULL promotion      */
DECL|method|globalStepTest
specifier|private
specifier|static
name|void
name|globalStepTest
parameter_list|(
specifier|final
name|ISchemaVersion
name|schemaVersion
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|FileWriter
name|output
init|=
name|openOutput
argument_list|(
name|schemaVersion
argument_list|,
literal|"comprehensive_promotion"
argument_list|,
name|TestType
operator|.
name|ADD
argument_list|)
decl_stmt|;
comment|// the accumulator, starts empty
specifier|final
name|HLL
name|hll
init|=
name|newHLL
argument_list|(
name|HLLType
operator|.
name|EMPTY
argument_list|)
decl_stmt|;
name|initLineAdd
argument_list|(
name|output
argument_list|,
name|hll
argument_list|,
name|schemaVersion
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|10000
comment|/*arbitrary*/
condition|;
name|i
operator|++
control|)
block|{
name|cumulativeAddLine
argument_list|(
name|output
argument_list|,
name|hll
argument_list|,
name|randomLong
argument_list|()
argument_list|,
name|schemaVersion
argument_list|)
expr_stmt|;
block|}
name|output
operator|.
name|flush
argument_list|()
expr_stmt|;
name|output
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
comment|/**      * Cumulatively unions "underpopulated" FULL HLLs into the      * accumulator to verify the correct behavior from the PostgreSQL implementation.      * The PostgreSQL implementation's representations of probabilistic HLLs should      * depend exclusively on the chosen SPARSE-to-FULL cutoff.      *      * Format: cumulative union      * Tests:      * - EMPTY U "underpopulated" FULL => SPARSE      * - SPARSE U "underpopulated" FULL => SPARSE      * - SPARSE U "barely underpopulated" FULL => FULL      */
DECL|method|sparseFullRepresentationTest
specifier|private
specifier|static
name|void
name|sparseFullRepresentationTest
parameter_list|(
specifier|final
name|ISchemaVersion
name|schemaVersion
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|FileWriter
name|output
init|=
name|openOutput
argument_list|(
name|schemaVersion
argument_list|,
literal|"sparse_full_representation"
argument_list|,
name|TestType
operator|.
name|UNION
argument_list|)
decl_stmt|;
specifier|final
name|HLL
name|emptyHLL1
init|=
name|newHLL
argument_list|(
name|HLLType
operator|.
name|EMPTY
argument_list|)
decl_stmt|;
specifier|final
name|HLL
name|emptyHLL2
init|=
name|newHLL
argument_list|(
name|HLLType
operator|.
name|EMPTY
argument_list|)
decl_stmt|;
name|cumulativeUnionLine
argument_list|(
name|output
argument_list|,
name|emptyHLL1
argument_list|,
name|emptyHLL2
argument_list|,
name|schemaVersion
argument_list|)
expr_stmt|;
comment|// NOTE:  In this test the sparseReference will be the "expected" value
comment|//        from the C representation, since it doesn't choose representation
comment|//        based on original encoding, but rather on the promotion rules
comment|//        and the declared type of the "receiving" field.
comment|//        It is the manually-constructed union result.
comment|// "underpopulated" FULL U EMPTY => SPARSE
specifier|final
name|HLL
name|fullHLL
init|=
name|newHLL
argument_list|(
name|HLLType
operator|.
name|FULL
argument_list|)
decl_stmt|;
name|fullHLL
operator|.
name|addRaw
argument_list|(
name|constructHLLValue
argument_list|(
name|LOG2M
argument_list|,
literal|0
comment|/*ix*/
argument_list|,
literal|1
comment|/*val*/
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|HLL
name|sparseHLL
init|=
name|newHLL
argument_list|(
name|HLLType
operator|.
name|SPARSE
argument_list|)
decl_stmt|;
name|sparseHLL
operator|.
name|addRaw
argument_list|(
name|constructHLLValue
argument_list|(
name|LOG2M
argument_list|,
literal|0
comment|/*ix*/
argument_list|,
literal|1
comment|/*val*/
argument_list|)
argument_list|)
expr_stmt|;
name|output
operator|.
name|write
argument_list|(
name|stringCardinality
argument_list|(
name|fullHLL
argument_list|)
operator|+
literal|","
operator|+
name|toByteA
argument_list|(
name|fullHLL
argument_list|,
name|schemaVersion
argument_list|)
operator|+
literal|","
operator|+
name|stringCardinality
argument_list|(
name|sparseHLL
argument_list|)
operator|+
literal|","
operator|+
name|toByteA
argument_list|(
name|sparseHLL
argument_list|,
name|schemaVersion
argument_list|)
operator|+
literal|"\n"
argument_list|)
expr_stmt|;
name|output
operator|.
name|flush
argument_list|()
expr_stmt|;
comment|// "underpopulated" FULL (small) U SPARSE (small) => SPARSE
specifier|final
name|HLL
name|fullHLL2
init|=
name|newHLL
argument_list|(
name|HLLType
operator|.
name|FULL
argument_list|)
decl_stmt|;
name|fullHLL2
operator|.
name|addRaw
argument_list|(
name|constructHLLValue
argument_list|(
name|LOG2M
argument_list|,
literal|1
comment|/*ix*/
argument_list|,
literal|1
comment|/*val*/
argument_list|)
argument_list|)
expr_stmt|;
name|sparseHLL
operator|.
name|addRaw
argument_list|(
name|constructHLLValue
argument_list|(
name|LOG2M
argument_list|,
literal|1
comment|/*ix*/
argument_list|,
literal|1
comment|/*val*/
argument_list|)
argument_list|)
expr_stmt|;
name|output
operator|.
name|write
argument_list|(
name|stringCardinality
argument_list|(
name|fullHLL2
argument_list|)
operator|+
literal|","
operator|+
name|toByteA
argument_list|(
name|fullHLL2
argument_list|,
name|schemaVersion
argument_list|)
operator|+
literal|","
operator|+
name|stringCardinality
argument_list|(
name|sparseHLL
argument_list|)
operator|+
literal|","
operator|+
name|toByteA
argument_list|(
name|sparseHLL
argument_list|,
name|schemaVersion
argument_list|)
operator|+
literal|"\n"
argument_list|)
expr_stmt|;
name|output
operator|.
name|flush
argument_list|()
expr_stmt|;
comment|// "underpopulated" FULL (just on edge) U SPARSE (small) => FULL
specifier|final
name|HLL
name|fullHLL3
init|=
name|newHLL
argument_list|(
name|HLLType
operator|.
name|FULL
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|2
init|;
name|i
operator|<
operator|(
name|SPARSE_THRESHOLD
operator|+
literal|1
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|fullHLL3
operator|.
name|addRaw
argument_list|(
name|constructHLLValue
argument_list|(
name|LOG2M
argument_list|,
name|i
comment|/*ix*/
argument_list|,
literal|1
comment|/*val*/
argument_list|)
argument_list|)
expr_stmt|;
name|sparseHLL
operator|.
name|addRaw
argument_list|(
name|constructHLLValue
argument_list|(
name|LOG2M
argument_list|,
name|i
comment|/*ix*/
argument_list|,
literal|1
comment|/*val*/
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|output
operator|.
name|write
argument_list|(
name|stringCardinality
argument_list|(
name|fullHLL3
argument_list|)
operator|+
literal|","
operator|+
name|toByteA
argument_list|(
name|fullHLL3
argument_list|,
name|schemaVersion
argument_list|)
operator|+
literal|","
operator|+
name|stringCardinality
argument_list|(
name|sparseHLL
argument_list|)
operator|+
literal|","
operator|+
name|toByteA
argument_list|(
name|sparseHLL
argument_list|,
name|schemaVersion
argument_list|)
operator|+
literal|"\n"
argument_list|)
expr_stmt|;
name|output
operator|.
name|flush
argument_list|()
expr_stmt|;
block|}
comment|/**      * Cumulatively sets successive registers to:      *      *<code>(registerIndex % REGISTER_MAX_VALUE) + 1</code>      *      * by adding specifically constructed values to a SPARSE HLL.      * Does not induce promotion.      *      * Format: cumulative add      * Tests:      * - SPARSE addition (predictable)      */
DECL|method|sparseStepTest
specifier|private
specifier|static
name|void
name|sparseStepTest
parameter_list|(
specifier|final
name|ISchemaVersion
name|schemaVersion
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|FileWriter
name|output
init|=
name|openOutput
argument_list|(
name|schemaVersion
argument_list|,
literal|"sparse_step"
argument_list|,
name|TestType
operator|.
name|ADD
argument_list|)
decl_stmt|;
comment|// the accumulator, starts empty sparse probabilistic
specifier|final
name|HLL
name|hll
init|=
name|newHLL
argument_list|(
name|HLLType
operator|.
name|SPARSE
argument_list|)
decl_stmt|;
name|initLineAdd
argument_list|(
name|output
argument_list|,
name|hll
argument_list|,
name|schemaVersion
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|SPARSE_THRESHOLD
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|long
name|rawValue
init|=
name|constructHLLValue
argument_list|(
name|LOG2M
argument_list|,
name|i
argument_list|,
operator|(
operator|(
name|i
operator|%
name|REGISTER_MAX_VALUE
operator|)
operator|+
literal|1
operator|)
argument_list|)
decl_stmt|;
name|cumulativeAddLine
argument_list|(
name|output
argument_list|,
name|hll
argument_list|,
name|rawValue
argument_list|,
name|schemaVersion
argument_list|)
expr_stmt|;
block|}
name|output
operator|.
name|flush
argument_list|()
expr_stmt|;
name|output
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
comment|/**      * Cumulatively sets random registers of a SPARSE HLL to      * random values by adding random values. Does not induce promotion.      *      * Format: cumulative add      * Tests:      * - SPARSE addition (random)      */
DECL|method|sparseRandomTest
specifier|private
specifier|static
name|void
name|sparseRandomTest
parameter_list|(
specifier|final
name|ISchemaVersion
name|schemaVersion
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|FileWriter
name|output
init|=
name|openOutput
argument_list|(
name|schemaVersion
argument_list|,
literal|"sparse_random"
argument_list|,
name|TestType
operator|.
name|ADD
argument_list|)
decl_stmt|;
specifier|final
name|Random
name|random
init|=
operator|new
name|Random
argument_list|(
name|randomLong
argument_list|()
argument_list|)
decl_stmt|;
comment|// the accumulator, starts empty
specifier|final
name|HLL
name|hll
init|=
name|newHLL
argument_list|(
name|HLLType
operator|.
name|SPARSE
argument_list|)
decl_stmt|;
name|initLineAdd
argument_list|(
name|output
argument_list|,
name|hll
argument_list|,
name|schemaVersion
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|SPARSE_THRESHOLD
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|int
name|registerIndex
init|=
name|Math
operator|.
name|abs
argument_list|(
name|random
operator|.
name|nextInt
argument_list|()
argument_list|)
operator|%
name|REGISTER_COUNT
decl_stmt|;
specifier|final
name|int
name|registerValue
init|=
operator|(
operator|(
name|Math
operator|.
name|abs
argument_list|(
name|random
operator|.
name|nextInt
argument_list|()
argument_list|)
operator|%
name|REGISTER_MAX_VALUE
operator|)
operator|+
literal|1
operator|)
decl_stmt|;
specifier|final
name|long
name|rawValue
init|=
name|constructHLLValue
argument_list|(
name|LOG2M
argument_list|,
name|registerIndex
argument_list|,
name|registerValue
argument_list|)
decl_stmt|;
name|cumulativeAddLine
argument_list|(
name|output
argument_list|,
name|hll
argument_list|,
name|rawValue
argument_list|,
name|schemaVersion
argument_list|)
expr_stmt|;
block|}
name|output
operator|.
name|flush
argument_list|()
expr_stmt|;
name|output
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
comment|/**      * Cumulatively sets the first register (index 0) to value 2, the last      * register (index m-1) to value 2, and then sets registers with indices in      * the range 2 to (sparseCutoff + 2) to value 1 to trigger promotion.      *      * This tests for register alignment in the promotion from SPARSE      * to FULL.      *      * Format: cumulative add      * Tests:      * - SPARSE addition      * - SPARSE to FULL promotion      */
DECL|method|sparseEdgeTest
specifier|private
specifier|static
name|void
name|sparseEdgeTest
parameter_list|(
specifier|final
name|ISchemaVersion
name|schemaVersion
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|FileWriter
name|output
init|=
name|openOutput
argument_list|(
name|schemaVersion
argument_list|,
literal|"sparse_edge"
argument_list|,
name|TestType
operator|.
name|ADD
argument_list|)
decl_stmt|;
comment|// the accumulator, starts empty
specifier|final
name|HLL
name|hll
init|=
name|newHLL
argument_list|(
name|HLLType
operator|.
name|SPARSE
argument_list|)
decl_stmt|;
name|initLineAdd
argument_list|(
name|output
argument_list|,
name|hll
argument_list|,
name|schemaVersion
argument_list|)
expr_stmt|;
specifier|final
name|long
name|firstValue
init|=
name|constructHLLValue
argument_list|(
name|LOG2M
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|)
decl_stmt|;
name|cumulativeAddLine
argument_list|(
name|output
argument_list|,
name|hll
argument_list|,
name|firstValue
argument_list|,
name|schemaVersion
argument_list|)
expr_stmt|;
specifier|final
name|long
name|lastValue
init|=
name|constructHLLValue
argument_list|(
name|LOG2M
argument_list|,
operator|(
literal|1
operator|<<
name|LOG2M
operator|)
operator|-
literal|1
argument_list|,
literal|2
argument_list|)
decl_stmt|;
name|cumulativeAddLine
argument_list|(
name|output
argument_list|,
name|hll
argument_list|,
name|lastValue
argument_list|,
name|schemaVersion
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|2
init|;
name|i
operator|<
operator|(
name|SPARSE_THRESHOLD
operator|+
literal|2
operator|)
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|long
name|middleValue
init|=
name|constructHLLValue
argument_list|(
name|LOG2M
argument_list|,
name|i
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|cumulativeAddLine
argument_list|(
name|output
argument_list|,
name|hll
argument_list|,
name|middleValue
argument_list|,
name|schemaVersion
argument_list|)
expr_stmt|;
block|}
name|output
operator|.
name|flush
argument_list|()
expr_stmt|;
name|output
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
comment|/**      * Unions an EMPTY accumulator with EXPLICIT HLLs, each containing a      * single random value.      *      * Format: cumulative union      * Tests:      * - EMPTY U EXPLICIT      * - EXPLICIT U EXPLICIT      * - EXPLICIT to SPARSE promotion      * - SPARSE U EXPLICIT      */
DECL|method|explicitPromotionTest
specifier|private
specifier|static
name|void
name|explicitPromotionTest
parameter_list|(
specifier|final
name|ISchemaVersion
name|schemaVersion
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|FileWriter
name|output
init|=
name|openOutput
argument_list|(
name|schemaVersion
argument_list|,
literal|"explicit_promotion"
argument_list|,
name|TestType
operator|.
name|UNION
argument_list|)
decl_stmt|;
specifier|final
name|Random
name|random
init|=
operator|new
name|Random
argument_list|(
name|randomLong
argument_list|()
argument_list|)
decl_stmt|;
comment|// the accumulator, starts empty
specifier|final
name|HLL
name|hll
init|=
name|newHLL
argument_list|(
name|HLLType
operator|.
name|EMPTY
argument_list|)
decl_stmt|;
specifier|final
name|HLL
name|emptyHLL
init|=
name|newHLL
argument_list|(
name|HLLType
operator|.
name|EMPTY
argument_list|)
decl_stmt|;
name|cumulativeUnionLine
argument_list|(
name|output
argument_list|,
name|hll
argument_list|,
name|emptyHLL
argument_list|,
name|schemaVersion
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
operator|(
name|EXPLICIT_THRESHOLD
operator|+
literal|500
operator|)
comment|/*should be greater than promotion cutoff*/
condition|;
name|i
operator|++
control|)
block|{
comment|// make an EXPLICIT set and populate with cardinality 1
specifier|final
name|HLL
name|explicitHLL
init|=
name|newHLL
argument_list|(
name|HLLType
operator|.
name|EXPLICIT
argument_list|)
decl_stmt|;
name|explicitHLL
operator|.
name|addRaw
argument_list|(
name|random
operator|.
name|nextLong
argument_list|()
argument_list|)
expr_stmt|;
name|cumulativeUnionLine
argument_list|(
name|output
argument_list|,
name|hll
argument_list|,
name|explicitHLL
argument_list|,
name|schemaVersion
argument_list|)
expr_stmt|;
block|}
name|output
operator|.
name|flush
argument_list|()
expr_stmt|;
name|output
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
comment|/**      * Unions an EMPTY accumulator with SPARSE HLLs, each      * having one register set.      *      * Format: cumulative union      * Tests:      * - EMPTY U SPARSE      * - SPARSE U SPARSE      * - SPARSE promotion      * - SPARSE U FULL      */
DECL|method|sparseProbabilisticPromotionTest
specifier|private
specifier|static
name|void
name|sparseProbabilisticPromotionTest
parameter_list|(
specifier|final
name|ISchemaVersion
name|schemaVersion
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|FileWriter
name|output
init|=
name|openOutput
argument_list|(
name|schemaVersion
argument_list|,
literal|"sparse_promotion"
argument_list|,
name|TestType
operator|.
name|UNION
argument_list|)
decl_stmt|;
specifier|final
name|Random
name|random
init|=
operator|new
name|Random
argument_list|(
name|randomLong
argument_list|()
argument_list|)
decl_stmt|;
comment|// the accumulator, starts empty
specifier|final
name|HLL
name|hll
init|=
name|newHLL
argument_list|(
name|HLLType
operator|.
name|EMPTY
argument_list|)
decl_stmt|;
specifier|final
name|HLL
name|emptyHLL
init|=
name|newHLL
argument_list|(
name|HLLType
operator|.
name|EMPTY
argument_list|)
decl_stmt|;
name|cumulativeUnionLine
argument_list|(
name|output
argument_list|,
name|hll
argument_list|,
name|emptyHLL
argument_list|,
name|schemaVersion
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
operator|(
name|SPARSE_THRESHOLD
operator|+
literal|1000
operator|)
comment|/*should be greater than promotion cutoff*/
condition|;
name|i
operator|++
control|)
block|{
comment|// make a SPARSE set and populate with cardinality 1
specifier|final
name|HLL
name|sparseHLL
init|=
name|newHLL
argument_list|(
name|HLLType
operator|.
name|SPARSE
argument_list|)
decl_stmt|;
specifier|final
name|int
name|registerIndex
init|=
name|Math
operator|.
name|abs
argument_list|(
name|random
operator|.
name|nextInt
argument_list|()
argument_list|)
operator|%
name|REGISTER_COUNT
decl_stmt|;
specifier|final
name|int
name|registerValue
init|=
operator|(
operator|(
name|Math
operator|.
name|abs
argument_list|(
name|random
operator|.
name|nextInt
argument_list|()
argument_list|)
operator|%
name|REGISTER_MAX_VALUE
operator|)
operator|+
literal|1
operator|)
decl_stmt|;
specifier|final
name|long
name|rawValue
init|=
name|constructHLLValue
argument_list|(
name|LOG2M
argument_list|,
name|registerIndex
argument_list|,
name|registerValue
argument_list|)
decl_stmt|;
name|sparseHLL
operator|.
name|addRaw
argument_list|(
name|rawValue
argument_list|)
expr_stmt|;
name|cumulativeUnionLine
argument_list|(
name|output
argument_list|,
name|hll
argument_list|,
name|sparseHLL
argument_list|,
name|schemaVersion
argument_list|)
expr_stmt|;
block|}
name|output
operator|.
name|flush
argument_list|()
expr_stmt|;
name|output
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
comment|/**      * Unions an EMPTY accumulator with EXPLICIT HLLs, each having a single      * random value, twice in a row to verify that the set properties are      * satisfied.      *      * Format: cumulative union      * Tests:      * - EMPTY U EXPLICIT      * - EXPLICIT U EXPLICIT      */
DECL|method|explicitOverlapTest
specifier|private
specifier|static
name|void
name|explicitOverlapTest
parameter_list|(
specifier|final
name|ISchemaVersion
name|schemaVersion
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|FileWriter
name|output
init|=
name|openOutput
argument_list|(
name|schemaVersion
argument_list|,
literal|"explicit_explicit"
argument_list|,
name|TestType
operator|.
name|UNION
argument_list|)
decl_stmt|;
specifier|final
name|Random
name|random
init|=
operator|new
name|Random
argument_list|(
name|randomLong
argument_list|()
argument_list|)
decl_stmt|;
comment|// the accumulator, starts empty
specifier|final
name|HLL
name|hll
init|=
name|newHLL
argument_list|(
name|HLLType
operator|.
name|EMPTY
argument_list|)
decl_stmt|;
specifier|final
name|HLL
name|emptyHLL
init|=
name|newHLL
argument_list|(
name|HLLType
operator|.
name|EMPTY
argument_list|)
decl_stmt|;
name|cumulativeUnionLine
argument_list|(
name|output
argument_list|,
name|hll
argument_list|,
name|emptyHLL
argument_list|,
name|schemaVersion
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|EXPLICIT_THRESHOLD
condition|;
name|i
operator|++
control|)
block|{
comment|// make an EXPLICIT set and populate with cardinality 1
specifier|final
name|HLL
name|explicitHLL
init|=
name|newHLL
argument_list|(
name|HLLType
operator|.
name|EXPLICIT
argument_list|)
decl_stmt|;
name|explicitHLL
operator|.
name|addRaw
argument_list|(
name|random
operator|.
name|nextLong
argument_list|()
argument_list|)
expr_stmt|;
comment|// union it into the accumulator twice, to test overlap (cardinality should not change)
name|cumulativeUnionLine
argument_list|(
name|output
argument_list|,
name|hll
argument_list|,
name|explicitHLL
argument_list|,
name|schemaVersion
argument_list|)
expr_stmt|;
name|cumulativeUnionLine
argument_list|(
name|output
argument_list|,
name|hll
argument_list|,
name|explicitHLL
argument_list|,
name|schemaVersion
argument_list|)
expr_stmt|;
block|}
name|output
operator|.
name|flush
argument_list|()
expr_stmt|;
name|output
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
comment|/**      * Unions an EMPTY accumulator with SPARSE HLLs, each      * having a single register set, twice in a row to verify that the set      * properties are satisfied.      *      * Format: cumulative union      * Tests:      * - EMPTY U SPARSE      * - SPARSE U SPARSE      */
DECL|method|sparseProbabilisticOverlapTest
specifier|private
specifier|static
name|void
name|sparseProbabilisticOverlapTest
parameter_list|(
specifier|final
name|ISchemaVersion
name|schemaVersion
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|FileWriter
name|output
init|=
name|openOutput
argument_list|(
name|schemaVersion
argument_list|,
literal|"sparse_sparse"
argument_list|,
name|TestType
operator|.
name|UNION
argument_list|)
decl_stmt|;
specifier|final
name|Random
name|random
init|=
operator|new
name|Random
argument_list|(
name|randomLong
argument_list|()
argument_list|)
decl_stmt|;
comment|// the accumulator, starts empty
specifier|final
name|HLL
name|hll
init|=
name|newHLL
argument_list|(
name|HLLType
operator|.
name|EMPTY
argument_list|)
decl_stmt|;
specifier|final
name|HLL
name|emptyHLL
init|=
name|newHLL
argument_list|(
name|HLLType
operator|.
name|EMPTY
argument_list|)
decl_stmt|;
name|cumulativeUnionLine
argument_list|(
name|output
argument_list|,
name|hll
argument_list|,
name|emptyHLL
argument_list|,
name|schemaVersion
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|SPARSE_THRESHOLD
condition|;
name|i
operator|++
control|)
block|{
comment|// make a SPARSE set and populate with cardinality 1
specifier|final
name|HLL
name|sparseHLL
init|=
name|newHLL
argument_list|(
name|HLLType
operator|.
name|SPARSE
argument_list|)
decl_stmt|;
specifier|final
name|int
name|registerIndex
init|=
name|Math
operator|.
name|abs
argument_list|(
name|random
operator|.
name|nextInt
argument_list|()
argument_list|)
operator|%
name|REGISTER_COUNT
decl_stmt|;
specifier|final
name|int
name|registerValue
init|=
operator|(
operator|(
name|Math
operator|.
name|abs
argument_list|(
name|random
operator|.
name|nextInt
argument_list|()
argument_list|)
operator|%
name|REGISTER_MAX_VALUE
operator|)
operator|+
literal|1
operator|)
decl_stmt|;
specifier|final
name|long
name|rawValue
init|=
name|constructHLLValue
argument_list|(
name|LOG2M
argument_list|,
name|registerIndex
argument_list|,
name|registerValue
argument_list|)
decl_stmt|;
name|sparseHLL
operator|.
name|addRaw
argument_list|(
name|rawValue
argument_list|)
expr_stmt|;
name|cumulativeUnionLine
argument_list|(
name|output
argument_list|,
name|hll
argument_list|,
name|sparseHLL
argument_list|,
name|schemaVersion
argument_list|)
expr_stmt|;
block|}
name|output
operator|.
name|flush
argument_list|()
expr_stmt|;
name|output
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
comment|/**      * Unions an EMPTY accumulator with FULL HLLs, each having      * many registers set, twice in a row to verify that the set properties are      * satisfied.      *      * Format: cumulative union      * Tests:      * - EMPTY U FULL      * - FULL U FULL      */
DECL|method|probabilisticUnionTest
specifier|private
specifier|static
name|void
name|probabilisticUnionTest
parameter_list|(
specifier|final
name|ISchemaVersion
name|schemaVersion
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|FileWriter
name|output
init|=
name|openOutput
argument_list|(
name|schemaVersion
argument_list|,
literal|"probabilistic_probabilistic"
argument_list|,
name|TestType
operator|.
name|UNION
argument_list|)
decl_stmt|;
specifier|final
name|Random
name|random
init|=
operator|new
name|Random
argument_list|(
name|randomLong
argument_list|()
argument_list|)
decl_stmt|;
comment|// the accumulator, starts empty
specifier|final
name|HLL
name|hll
init|=
name|newHLL
argument_list|(
name|HLLType
operator|.
name|EMPTY
argument_list|)
decl_stmt|;
specifier|final
name|HLL
name|emptyHLL
init|=
name|newHLL
argument_list|(
name|HLLType
operator|.
name|EMPTY
argument_list|)
decl_stmt|;
name|cumulativeUnionLine
argument_list|(
name|output
argument_list|,
name|hll
argument_list|,
name|emptyHLL
argument_list|,
name|schemaVersion
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|1000
comment|/*number of rows to generate*/
condition|;
name|i
operator|++
control|)
block|{
comment|// make a FULL set and populate with
specifier|final
name|HLL
name|fullHLL
init|=
name|newHLL
argument_list|(
name|HLLType
operator|.
name|FULL
argument_list|)
decl_stmt|;
specifier|final
name|int
name|elementCount
init|=
name|random
operator|.
name|nextInt
argument_list|(
literal|10000
comment|/*arbitrary maximum cardinality*/
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|elementCount
condition|;
name|j
operator|++
control|)
block|{
name|fullHLL
operator|.
name|addRaw
argument_list|(
name|random
operator|.
name|nextLong
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|cumulativeUnionLine
argument_list|(
name|output
argument_list|,
name|hll
argument_list|,
name|fullHLL
argument_list|,
name|schemaVersion
argument_list|)
expr_stmt|;
block|}
name|output
operator|.
name|flush
argument_list|()
expr_stmt|;
name|output
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
comment|/**      * Unions an EMPTY accumulator with random HLLs.      *      * Format: cumulative union      * Tests:      * - hopefully all union possibilities      */
DECL|method|globalUnionTest
specifier|private
specifier|static
name|void
name|globalUnionTest
parameter_list|(
specifier|final
name|ISchemaVersion
name|schemaVersion
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|FileWriter
name|output
init|=
name|openOutput
argument_list|(
name|schemaVersion
argument_list|,
literal|"comprehensive"
argument_list|,
name|TestType
operator|.
name|UNION
argument_list|)
decl_stmt|;
comment|// the accumulator, starts empty
specifier|final
name|HLL
name|hll
init|=
name|newHLL
argument_list|(
name|HLLType
operator|.
name|EMPTY
argument_list|)
decl_stmt|;
specifier|final
name|HLL
name|emptyHLL
init|=
name|newHLL
argument_list|(
name|HLLType
operator|.
name|EMPTY
argument_list|)
decl_stmt|;
name|cumulativeUnionLine
argument_list|(
name|output
argument_list|,
name|hll
argument_list|,
name|emptyHLL
argument_list|,
name|schemaVersion
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|1000
comment|/*number of rows to generate*/
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|HLL
name|randomHLL
init|=
name|generateRandomHLL
argument_list|()
decl_stmt|;
name|cumulativeUnionLine
argument_list|(
name|output
argument_list|,
name|hll
argument_list|,
name|randomHLL
argument_list|,
name|schemaVersion
argument_list|)
expr_stmt|;
block|}
name|output
operator|.
name|flush
argument_list|()
expr_stmt|;
name|output
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
comment|// ========================================================================
comment|// Main
DECL|method|fullSuite
specifier|public
specifier|static
name|void
name|fullSuite
parameter_list|(
specifier|final
name|ISchemaVersion
name|schemaVersion
parameter_list|)
throws|throws
name|IOException
block|{
name|fullCardinalityCorrectionTest
argument_list|(
name|schemaVersion
argument_list|)
expr_stmt|;
name|globalUnionTest
argument_list|(
name|schemaVersion
argument_list|)
expr_stmt|;
name|globalStepTest
argument_list|(
name|schemaVersion
argument_list|)
expr_stmt|;
name|probabilisticUnionTest
argument_list|(
name|schemaVersion
argument_list|)
expr_stmt|;
name|explicitPromotionTest
argument_list|(
name|schemaVersion
argument_list|)
expr_stmt|;
name|explicitOverlapTest
argument_list|(
name|schemaVersion
argument_list|)
expr_stmt|;
name|sparseFullRepresentationTest
argument_list|(
name|schemaVersion
argument_list|)
expr_stmt|;
name|sparseStepTest
argument_list|(
name|schemaVersion
argument_list|)
expr_stmt|;
name|sparseRandomTest
argument_list|(
name|schemaVersion
argument_list|)
expr_stmt|;
name|sparseEdgeTest
argument_list|(
name|schemaVersion
argument_list|)
expr_stmt|;
name|sparseProbabilisticPromotionTest
argument_list|(
name|schemaVersion
argument_list|)
expr_stmt|;
name|sparseProbabilisticOverlapTest
argument_list|(
name|schemaVersion
argument_list|)
expr_stmt|;
block|}
DECL|method|main
specifier|public
specifier|static
name|void
name|main
parameter_list|(
name|String
index|[]
name|args
parameter_list|)
throws|throws
name|IOException
block|{
name|fullSuite
argument_list|(
name|SerializationUtil
operator|.
name|VERSION_ONE
argument_list|)
expr_stmt|;
block|}
comment|// ************************************************************************
comment|// Helpers
comment|/**      * Shortcut for testing constructor, which uses the constants defined at      * the top of the file as default parameters.      *      * @return a new {@link HLL} of specified type, which uses the parameters      *         ({@link #LOG2M}, {@link #REGWIDTH}, {@link #EXPLICIT_THRESHOLD},      *         and {@link #SPARSE_THRESHOLD}) specified above.      */
DECL|method|newHLL
specifier|private
specifier|static
name|HLL
name|newHLL
parameter_list|(
specifier|final
name|HLLType
name|type
parameter_list|)
block|{
return|return
name|newHLL
argument_list|(
name|type
argument_list|)
return|;
block|}
comment|/**      * Returns the algorithm-specific cardinality of the specified {@link HLL}      * as a {@link String} appropriate for comparison with the algorithm-specific      * cardinality provided by the PostgreSQL implementation.      *      * @param  hll the HLL whose algorithm-specific cardinality is to be printed.      *         This cannot be<code>null</code>.      * @return the algorithm-specific cardinality of the instance as a PostgreSQL-      *         compatible String. This will never be<code>null</code>      */
DECL|method|stringCardinality
specifier|private
specifier|static
name|String
name|stringCardinality
parameter_list|(
specifier|final
name|HLL
name|hll
parameter_list|)
block|{
switch|switch
condition|(
name|hll
operator|.
name|getType
argument_list|()
condition|)
block|{
case|case
name|EMPTY
case|:
return|return
literal|"0"
return|;
case|case
name|EXPLICIT
case|:
comment|/*promotion has not yet occurred*/
return|return
name|Long
operator|.
name|toString
argument_list|(
name|hll
operator|.
name|cardinality
argument_list|()
argument_list|)
return|;
case|case
name|SPARSE
case|:
return|return
name|Double
operator|.
name|toString
argument_list|(
name|hll
operator|.
name|sparseProbabilisticAlgorithmCardinality
argument_list|()
argument_list|)
return|;
case|case
name|FULL
case|:
return|return
name|Double
operator|.
name|toString
argument_list|(
name|hll
operator|.
name|fullProbabilisticAlgorithmCardinality
argument_list|()
argument_list|)
return|;
default|default:
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Unknown HLL type "
operator|+
name|hll
operator|.
name|getType
argument_list|()
argument_list|)
throw|;
block|}
block|}
comment|/**      * Generates a random HLL and populates it with random values.      *      * @return the populated HLL. This will never be<code>null</code>.      */
DECL|method|generateRandomHLL
specifier|public
specifier|static
name|HLL
name|generateRandomHLL
parameter_list|()
block|{
specifier|final
name|int
name|randomTypeInt
init|=
name|randomIntBetween
argument_list|(
literal|0
argument_list|,
name|HLLType
operator|.
name|values
argument_list|()
operator|.
name|length
operator|-
literal|1
argument_list|)
decl_stmt|;
specifier|final
name|HLLType
name|type
decl_stmt|;
switch|switch
condition|(
name|randomTypeInt
condition|)
block|{
case|case
literal|0
case|:
name|type
operator|=
name|HLLType
operator|.
name|EMPTY
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|type
operator|=
name|HLLType
operator|.
name|EXPLICIT
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|type
operator|=
name|HLLType
operator|.
name|FULL
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|type
operator|=
name|HLLType
operator|.
name|EMPTY
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|type
operator|=
name|HLLType
operator|.
name|SPARSE
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Unassigned type int "
operator|+
name|randomTypeInt
argument_list|)
throw|;
block|}
specifier|final
name|int
name|cardinalityCap
decl_stmt|;
specifier|final
name|int
name|cardinalityBaseline
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|EMPTY
case|:
return|return
name|newHLL
argument_list|(
name|HLLType
operator|.
name|EMPTY
argument_list|)
return|;
case|case
name|EXPLICIT
case|:
name|cardinalityCap
operator|=
name|EXPLICIT_THRESHOLD
expr_stmt|;
name|cardinalityBaseline
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|SPARSE
case|:
name|cardinalityCap
operator|=
name|SPARSE_THRESHOLD
expr_stmt|;
name|cardinalityBaseline
operator|=
operator|(
name|EXPLICIT_THRESHOLD
operator|+
literal|1
operator|)
expr_stmt|;
break|break;
case|case
name|FULL
case|:
name|cardinalityCap
operator|=
literal|100000
expr_stmt|;
name|cardinalityBaseline
operator|=
operator|(
name|SPARSE_THRESHOLD
operator|*
literal|10
operator|)
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"We should never be here."
argument_list|)
throw|;
block|}
specifier|final
name|HLL
name|hll
init|=
name|newHLL
argument_list|(
name|HLLType
operator|.
name|EMPTY
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|cardinalityBaseline
condition|;
name|i
operator|++
control|)
block|{
name|hll
operator|.
name|addRaw
argument_list|(
name|randomLong
argument_list|()
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|randomInt
argument_list|(
name|cardinalityCap
operator|-
name|cardinalityBaseline
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|hll
operator|.
name|addRaw
argument_list|(
name|randomLong
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|hll
return|;
block|}
comment|/**      * Opens a {@link FileWriter} and writes out an appropriate CSV header.      *      * @param  schemaVersion Schema version of the output. This cannot be      *<code>null</code>.      * @param  description Description string used to build the filename.      *         This cannot be<code>null</code>.      * @param  type {@link TestType type} of the test file to be written.      *         This cannot be<code>null</code>.      * @return The opened {@link FileWriter writer}. This will never be<code>null</code>.      */
DECL|method|openOutput
specifier|private
specifier|static
name|FileWriter
name|openOutput
parameter_list|(
specifier|final
name|ISchemaVersion
name|schemaVersion
parameter_list|,
specifier|final
name|String
name|description
parameter_list|,
specifier|final
name|TestType
name|type
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|String
name|schemaVersionPrefix
init|=
literal|"v"
operator|+
name|schemaVersion
operator|.
name|schemaVersionNumber
argument_list|()
operator|+
literal|"_"
decl_stmt|;
specifier|final
name|String
name|header
decl_stmt|;
specifier|final
name|String
name|filename
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|ADD
case|:
name|header
operator|=
literal|"cardinality,raw_value,HLL\n"
expr_stmt|;
name|filename
operator|=
name|schemaVersionPrefix
operator|+
literal|"cumulative_add_"
operator|+
name|description
operator|+
literal|".csv"
expr_stmt|;
break|break;
case|case
name|UNION
case|:
name|header
operator|=
literal|"cardinality,HLL,union_cardinality,union_HLL\n"
expr_stmt|;
name|filename
operator|=
name|schemaVersionPrefix
operator|+
literal|"cumulative_union_"
operator|+
name|description
operator|+
literal|".csv"
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Unknown test type "
operator|+
name|type
argument_list|)
throw|;
block|}
specifier|final
name|FileWriter
name|output
init|=
operator|new
name|FileWriter
argument_list|(
name|OUTPUT_DIRECTORY
operator|+
name|filename
argument_list|)
decl_stmt|;
name|output
operator|.
name|write
argument_list|(
name|header
argument_list|)
expr_stmt|;
name|output
operator|.
name|flush
argument_list|()
expr_stmt|;
return|return
name|output
return|;
block|}
comment|/**      * Writes out a {@link TestType#ADD}-formatted test line.      *      * @param  output The output {@link FileWriter writer}. This cannot be<code>null</code>.      * @param  hll The "accumulator" HLL instance. This cannot be<code>null</code>.      * @param  rawValue The raw value added to the HLL.      * @param  schemaVersion the schema with which to serialize the HLLs. This cannot      *         be<code>null</code>.      */
DECL|method|cumulativeAddLine
specifier|private
specifier|static
name|void
name|cumulativeAddLine
parameter_list|(
specifier|final
name|FileWriter
name|output
parameter_list|,
specifier|final
name|HLL
name|hll
parameter_list|,
specifier|final
name|long
name|rawValue
parameter_list|,
specifier|final
name|ISchemaVersion
name|schemaVersion
parameter_list|)
throws|throws
name|IOException
block|{
name|hll
operator|.
name|addRaw
argument_list|(
name|rawValue
argument_list|)
expr_stmt|;
specifier|final
name|String
name|accumulatorCardinality
init|=
name|stringCardinality
argument_list|(
name|hll
argument_list|)
decl_stmt|;
name|output
operator|.
name|write
argument_list|(
name|accumulatorCardinality
operator|+
literal|","
operator|+
name|rawValue
operator|+
literal|","
operator|+
name|toByteA
argument_list|(
name|hll
argument_list|,
name|schemaVersion
argument_list|)
operator|+
literal|"\n"
argument_list|)
expr_stmt|;
name|output
operator|.
name|flush
argument_list|()
expr_stmt|;
block|}
comment|/**      * Writes an initial line for a {@link TestType#ADD}-formatted test.      *      * @param  output The output {@link FileWriter writer}. This cannot be<code>null</code>.      * @param  hll The "accumulator" HLL instance. This cannot be<code>null</code>.      * @param  schemaVersion the schema with which to serialize the HLLs. This cannot      *         be<code>null</code>.      */
DECL|method|initLineAdd
specifier|private
specifier|static
name|void
name|initLineAdd
parameter_list|(
specifier|final
name|FileWriter
name|output
parameter_list|,
specifier|final
name|HLL
name|hll
parameter_list|,
specifier|final
name|ISchemaVersion
name|schemaVersion
parameter_list|)
throws|throws
name|IOException
block|{
name|output
operator|.
name|write
argument_list|(
literal|0
operator|+
literal|","
operator|+
literal|0
operator|+
literal|","
operator|+
name|toByteA
argument_list|(
name|hll
argument_list|,
name|schemaVersion
argument_list|)
operator|+
literal|"\n"
argument_list|)
expr_stmt|;
name|output
operator|.
name|flush
argument_list|()
expr_stmt|;
block|}
comment|/**      * Writes out a {@link TestType#UNION}-formatted test line.      *      * @param  output The output {@link FileWriter writer}. This cannot be<code>null</code>.      * @param  hll The "accumulator" HLL instance. This cannot be<code>null</code>.      * @param  increment The "increment" HLL instance which will be unioned into      *         the accumulator. This cannot be<code>null</code>.      * @param  schemaVersion the schema with which to serialize the HLLs. This cannot      *         be<code>null</code>.      */
DECL|method|cumulativeUnionLine
specifier|private
specifier|static
name|void
name|cumulativeUnionLine
parameter_list|(
specifier|final
name|FileWriter
name|output
parameter_list|,
specifier|final
name|HLL
name|hll
parameter_list|,
specifier|final
name|HLL
name|increment
parameter_list|,
specifier|final
name|ISchemaVersion
name|schemaVersion
parameter_list|)
throws|throws
name|IOException
block|{
name|hll
operator|.
name|union
argument_list|(
name|increment
argument_list|)
expr_stmt|;
specifier|final
name|String
name|incrementCardinality
init|=
name|stringCardinality
argument_list|(
name|increment
argument_list|)
decl_stmt|;
specifier|final
name|String
name|accumulatorCardinality
init|=
name|stringCardinality
argument_list|(
name|hll
argument_list|)
decl_stmt|;
name|output
operator|.
name|write
argument_list|(
name|incrementCardinality
operator|+
literal|","
operator|+
name|toByteA
argument_list|(
name|increment
argument_list|,
name|schemaVersion
argument_list|)
operator|+
literal|","
operator|+
name|accumulatorCardinality
operator|+
literal|","
operator|+
name|toByteA
argument_list|(
name|hll
argument_list|,
name|schemaVersion
argument_list|)
operator|+
literal|"\n"
argument_list|)
expr_stmt|;
name|output
operator|.
name|flush
argument_list|()
expr_stmt|;
block|}
comment|/**      * Serializes a HLL to Postgres 9 'bytea' hex-format, for CSV ingest.      *      * @param  hll the HLL to serialize. This cannot be<code>null</code>.      * @param  schemaVersion the schema with which to serialize the HLLs. This cannot      *         be<code>null</code>.      * @return a PostgreSQL 'bytea' string representing the HLL.      */
DECL|method|toByteA
specifier|private
specifier|static
name|String
name|toByteA
parameter_list|(
specifier|final
name|HLL
name|hll
parameter_list|,
specifier|final
name|ISchemaVersion
name|schemaVersion
parameter_list|)
block|{
specifier|final
name|byte
index|[]
name|bytes
init|=
name|hll
operator|.
name|toBytes
argument_list|(
name|schemaVersion
argument_list|)
decl_stmt|;
return|return
operator|(
literal|"\\x"
operator|+
name|NumberUtil
operator|.
name|toHex
argument_list|(
name|bytes
argument_list|,
literal|0
argument_list|,
name|bytes
operator|.
name|length
argument_list|)
operator|)
return|;
block|}
comment|/**      * Indicates what kind of test output a test will generate.      */
DECL|enum|TestType
specifier|private
specifier|static
enum|enum
name|TestType
block|{
comment|/**          * This type of test is characterized by values being added to an          * accumulator HLL whose serialized representation (after the value is added)          * is printed to each line along with the cardinality and added value.          */
DECL|enum constant|ADD
name|ADD
block|,
comment|/**          * This type of test is characterized by HLLs being unioned into an          * accumulator HLL whose serialized representation (after the HLL is          * union'd) is printed to each line along with the cardinalities and the          * serialized representation of the HLL union'd in.          */
DECL|enum constant|UNION
name|UNION
block|;     }
block|}
end_class
end_unit
