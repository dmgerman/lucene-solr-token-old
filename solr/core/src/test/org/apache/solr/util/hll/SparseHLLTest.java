begin_unit
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_package
DECL|package|org.apache.solr.util.hll
package|package
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|util
operator|.
name|hll
package|;
end_package
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|LuceneTestCase
import|;
end_import
begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Test
import|;
end_import
begin_import
import|import
name|com
operator|.
name|carrotsearch
operator|.
name|hppc
operator|.
name|IntByteHashMap
import|;
end_import
begin_import
import|import
name|com
operator|.
name|carrotsearch
operator|.
name|hppc
operator|.
name|cursors
operator|.
name|IntByteCursor
import|;
end_import
begin_import
import|import
name|com
operator|.
name|carrotsearch
operator|.
name|randomizedtesting
operator|.
name|RandomizedTest
import|;
end_import
begin_comment
comment|/**  * Tests {@link HLL} of type {@link HLLType#SPARSE}.  */
end_comment
begin_class
DECL|class|SparseHLLTest
specifier|public
class|class
name|SparseHLLTest
extends|extends
name|LuceneTestCase
block|{
DECL|field|log2m
specifier|private
specifier|static
specifier|final
name|int
name|log2m
init|=
literal|11
decl_stmt|;
comment|/**      * Tests {@link HLL#addRaw(long)}.      */
annotation|@
name|Test
DECL|method|addTest
specifier|public
name|void
name|addTest
parameter_list|()
block|{
block|{
comment|// insert an element with register value 1 (minimum set value)
specifier|final
name|int
name|registerIndex
init|=
literal|0
decl_stmt|;
specifier|final
name|int
name|registerValue
init|=
literal|1
decl_stmt|;
specifier|final
name|long
name|rawValue
init|=
name|ProbabilisticTestUtil
operator|.
name|constructHLLValue
argument_list|(
name|log2m
argument_list|,
name|registerIndex
argument_list|,
name|registerValue
argument_list|)
decl_stmt|;
specifier|final
name|HLL
name|hll
init|=
operator|new
name|HLL
argument_list|(
name|log2m
argument_list|,
literal|5
comment|/*regwidth*/
argument_list|,
literal|128
comment|/*explicitThreshold, arbitrary, unused*/
argument_list|,
literal|256
comment|/*sparseThreshold, arbitrary*/
argument_list|,
name|HLLType
operator|.
name|SPARSE
argument_list|)
decl_stmt|;
name|hll
operator|.
name|addRaw
argument_list|(
name|rawValue
argument_list|)
expr_stmt|;
name|assertOneRegisterSet
argument_list|(
name|hll
argument_list|,
name|registerIndex
argument_list|,
operator|(
name|byte
operator|)
name|registerValue
argument_list|)
expr_stmt|;
block|}
block|{
comment|// insert an element with register value 31 (maximum set value)
specifier|final
name|int
name|registerIndex
init|=
literal|0
decl_stmt|;
specifier|final
name|int
name|registerValue
init|=
literal|31
decl_stmt|;
specifier|final
name|long
name|rawValue
init|=
name|ProbabilisticTestUtil
operator|.
name|constructHLLValue
argument_list|(
name|log2m
argument_list|,
name|registerIndex
argument_list|,
name|registerValue
argument_list|)
decl_stmt|;
specifier|final
name|HLL
name|hll
init|=
operator|new
name|HLL
argument_list|(
name|log2m
argument_list|,
literal|5
comment|/*regwidth*/
argument_list|,
literal|128
comment|/*explicitThreshold, arbitrary, unused*/
argument_list|,
literal|256
comment|/*sparseThreshold, arbitrary*/
argument_list|,
name|HLLType
operator|.
name|SPARSE
argument_list|)
decl_stmt|;
name|hll
operator|.
name|addRaw
argument_list|(
name|rawValue
argument_list|)
expr_stmt|;
name|assertOneRegisterSet
argument_list|(
name|hll
argument_list|,
name|registerIndex
argument_list|,
operator|(
name|byte
operator|)
name|registerValue
argument_list|)
expr_stmt|;
block|}
block|{
comment|// insert an element that could overflow the register (past 31)
specifier|final
name|int
name|registerIndex
init|=
literal|0
decl_stmt|;
specifier|final
name|int
name|registerValue
init|=
literal|36
decl_stmt|;
specifier|final
name|long
name|rawValue
init|=
name|ProbabilisticTestUtil
operator|.
name|constructHLLValue
argument_list|(
name|log2m
argument_list|,
name|registerIndex
argument_list|,
name|registerValue
argument_list|)
decl_stmt|;
specifier|final
name|HLL
name|hll
init|=
operator|new
name|HLL
argument_list|(
name|log2m
argument_list|,
literal|5
comment|/*regwidth*/
argument_list|,
literal|128
comment|/*explicitThreshold, arbitrary, unused*/
argument_list|,
literal|256
comment|/*sparseThreshold, arbitrary*/
argument_list|,
name|HLLType
operator|.
name|SPARSE
argument_list|)
decl_stmt|;
name|hll
operator|.
name|addRaw
argument_list|(
name|rawValue
argument_list|)
expr_stmt|;
name|assertOneRegisterSet
argument_list|(
name|hll
argument_list|,
operator|(
name|short
operator|)
name|registerIndex
argument_list|,
operator|(
name|byte
operator|)
literal|31
comment|/*register max*/
argument_list|)
expr_stmt|;
block|}
block|{
comment|// insert duplicate elements, observe no change
specifier|final
name|int
name|registerIndex
init|=
literal|0
decl_stmt|;
specifier|final
name|int
name|registerValue
init|=
literal|1
decl_stmt|;
specifier|final
name|long
name|rawValue
init|=
name|ProbabilisticTestUtil
operator|.
name|constructHLLValue
argument_list|(
name|log2m
argument_list|,
name|registerIndex
argument_list|,
name|registerValue
argument_list|)
decl_stmt|;
specifier|final
name|HLL
name|hll
init|=
operator|new
name|HLL
argument_list|(
name|log2m
argument_list|,
literal|5
comment|/*regwidth*/
argument_list|,
literal|128
comment|/*explicitThreshold, arbitrary, unused*/
argument_list|,
literal|256
comment|/*sparseThreshold, arbitrary*/
argument_list|,
name|HLLType
operator|.
name|SPARSE
argument_list|)
decl_stmt|;
name|hll
operator|.
name|addRaw
argument_list|(
name|rawValue
argument_list|)
expr_stmt|;
name|hll
operator|.
name|addRaw
argument_list|(
name|rawValue
argument_list|)
expr_stmt|;
name|assertOneRegisterSet
argument_list|(
name|hll
argument_list|,
name|registerIndex
argument_list|,
operator|(
name|byte
operator|)
name|registerValue
argument_list|)
expr_stmt|;
block|}
block|{
comment|// insert elements that increase a register's value
specifier|final
name|int
name|registerIndex
init|=
literal|0
decl_stmt|;
specifier|final
name|int
name|registerValue
init|=
literal|1
decl_stmt|;
specifier|final
name|long
name|rawValue
init|=
name|ProbabilisticTestUtil
operator|.
name|constructHLLValue
argument_list|(
name|log2m
argument_list|,
name|registerIndex
argument_list|,
name|registerValue
argument_list|)
decl_stmt|;
specifier|final
name|HLL
name|hll
init|=
operator|new
name|HLL
argument_list|(
name|log2m
argument_list|,
literal|5
comment|/*regwidth*/
argument_list|,
literal|128
comment|/*explicitThreshold, arbitrary, unused*/
argument_list|,
literal|256
comment|/*sparseThreshold, arbitrary*/
argument_list|,
name|HLLType
operator|.
name|SPARSE
argument_list|)
decl_stmt|;
name|hll
operator|.
name|addRaw
argument_list|(
name|rawValue
argument_list|)
expr_stmt|;
specifier|final
name|int
name|registerValue2
init|=
literal|2
decl_stmt|;
specifier|final
name|long
name|rawValue2
init|=
name|ProbabilisticTestUtil
operator|.
name|constructHLLValue
argument_list|(
name|log2m
argument_list|,
name|registerIndex
argument_list|,
name|registerValue2
argument_list|)
decl_stmt|;
name|hll
operator|.
name|addRaw
argument_list|(
name|rawValue2
argument_list|)
expr_stmt|;
name|assertOneRegisterSet
argument_list|(
name|hll
argument_list|,
name|registerIndex
argument_list|,
operator|(
name|byte
operator|)
name|registerValue2
argument_list|)
expr_stmt|;
block|}
block|{
comment|// insert elements that have lower register values, observe no change
specifier|final
name|int
name|registerIndex
init|=
literal|0
decl_stmt|;
specifier|final
name|int
name|registerValue
init|=
literal|2
decl_stmt|;
specifier|final
name|long
name|rawValue
init|=
name|ProbabilisticTestUtil
operator|.
name|constructHLLValue
argument_list|(
name|log2m
argument_list|,
name|registerIndex
argument_list|,
name|registerValue
argument_list|)
decl_stmt|;
specifier|final
name|HLL
name|hll
init|=
operator|new
name|HLL
argument_list|(
name|log2m
argument_list|,
literal|5
comment|/*regwidth*/
argument_list|,
literal|128
comment|/*explicitThreshold, arbitrary, unused*/
argument_list|,
literal|256
comment|/*sparseThreshold, arbitrary*/
argument_list|,
name|HLLType
operator|.
name|SPARSE
argument_list|)
decl_stmt|;
name|hll
operator|.
name|addRaw
argument_list|(
name|rawValue
argument_list|)
expr_stmt|;
specifier|final
name|int
name|registerValue2
init|=
literal|1
decl_stmt|;
specifier|final
name|long
name|rawValue2
init|=
name|ProbabilisticTestUtil
operator|.
name|constructHLLValue
argument_list|(
name|log2m
argument_list|,
name|registerIndex
argument_list|,
name|registerValue2
argument_list|)
decl_stmt|;
name|hll
operator|.
name|addRaw
argument_list|(
name|rawValue2
argument_list|)
expr_stmt|;
name|assertOneRegisterSet
argument_list|(
name|hll
argument_list|,
name|registerIndex
argument_list|,
operator|(
name|byte
operator|)
name|registerValue
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Smoke test for {@link HLL#cardinality()} and the proper use of the small      * range correction.      */
annotation|@
name|Test
DECL|method|smallRangeSmokeTest
specifier|public
name|void
name|smallRangeSmokeTest
parameter_list|()
block|{
specifier|final
name|int
name|log2m
init|=
literal|11
decl_stmt|;
specifier|final
name|int
name|m
init|=
operator|(
literal|1
operator|<<
name|log2m
operator|)
decl_stmt|;
specifier|final
name|int
name|regwidth
init|=
literal|5
decl_stmt|;
comment|// only one register set
block|{
specifier|final
name|HLL
name|hll
init|=
operator|new
name|HLL
argument_list|(
name|log2m
argument_list|,
name|regwidth
argument_list|,
literal|128
comment|/*explicitThreshold, arbitrary, unused*/
argument_list|,
literal|256
comment|/*sparseThreshold, arbitrary*/
argument_list|,
name|HLLType
operator|.
name|SPARSE
argument_list|)
decl_stmt|;
name|hll
operator|.
name|addRaw
argument_list|(
name|ProbabilisticTestUtil
operator|.
name|constructHLLValue
argument_list|(
name|log2m
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|long
name|cardinality
init|=
name|hll
operator|.
name|cardinality
argument_list|()
decl_stmt|;
comment|// Trivially true that small correction conditions hold: one register
comment|// set implies zeroes exist, and estimator trivially smaller than 5m/2.
comment|// Small range correction: m * log(m/V)
specifier|final
name|long
name|expected
init|=
operator|(
name|long
operator|)
name|Math
operator|.
name|ceil
argument_list|(
name|m
operator|*
name|Math
operator|.
name|log
argument_list|(
operator|(
name|double
operator|)
name|m
operator|/
operator|(
name|m
operator|-
literal|1
operator|)
comment|/*# of zeroes*/
argument_list|)
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|cardinality
argument_list|,
name|expected
argument_list|)
expr_stmt|;
block|}
comment|// all but one register set
block|{
specifier|final
name|HLL
name|hll
init|=
operator|new
name|HLL
argument_list|(
name|log2m
argument_list|,
name|regwidth
argument_list|,
literal|128
comment|/*explicitThreshold, arbitrary, unused*/
argument_list|,
literal|256
comment|/*sparseThreshold, arbitrary*/
argument_list|,
name|HLLType
operator|.
name|SPARSE
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
operator|(
name|m
operator|-
literal|1
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|hll
operator|.
name|addRaw
argument_list|(
name|ProbabilisticTestUtil
operator|.
name|constructHLLValue
argument_list|(
name|log2m
argument_list|,
name|i
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// Trivially true that small correction conditions hold: all but
comment|// one register set implies a zero exists, and estimator trivially
comment|// smaller than 5m/2 since it's alpha / ((m-1)/2)
specifier|final
name|long
name|cardinality
init|=
name|hll
operator|.
name|cardinality
argument_list|()
decl_stmt|;
comment|// Small range correction: m * log(m/V)
specifier|final
name|long
name|expected
init|=
operator|(
name|long
operator|)
name|Math
operator|.
name|ceil
argument_list|(
name|m
operator|*
name|Math
operator|.
name|log
argument_list|(
operator|(
name|double
operator|)
name|m
operator|/
literal|1
comment|/*# of zeroes*/
argument_list|)
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|cardinality
argument_list|,
name|expected
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Smoke test for {@link HLL#cardinality()} and the proper use of the      * uncorrected estimator.      */
annotation|@
name|Test
DECL|method|normalRangeSmokeTest
specifier|public
name|void
name|normalRangeSmokeTest
parameter_list|()
block|{
specifier|final
name|int
name|log2m
init|=
literal|11
decl_stmt|;
specifier|final
name|int
name|m
init|=
operator|(
literal|1
operator|<<
name|log2m
operator|)
decl_stmt|;
specifier|final
name|int
name|regwidth
init|=
literal|5
decl_stmt|;
comment|// regwidth = 5, so hash space is
comment|// log2m + (2^5 - 1 - 1), so L = log2m + 30
specifier|final
name|int
name|l
init|=
name|log2m
operator|+
literal|30
decl_stmt|;
comment|// all registers at 'medium' value
block|{
specifier|final
name|HLL
name|hll
init|=
operator|new
name|HLL
argument_list|(
name|log2m
argument_list|,
name|regwidth
argument_list|,
literal|128
comment|/*explicitThreshold, arbitrary, unused*/
argument_list|,
name|m
comment|/*sparseThreshold*/
argument_list|,
name|HLLType
operator|.
name|SPARSE
argument_list|)
decl_stmt|;
specifier|final
name|int
name|registerValue
init|=
literal|7
comment|/*chosen to ensure neither correction kicks in*/
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|m
condition|;
name|i
operator|++
control|)
block|{
name|hll
operator|.
name|addRaw
argument_list|(
name|ProbabilisticTestUtil
operator|.
name|constructHLLValue
argument_list|(
name|log2m
argument_list|,
name|i
argument_list|,
name|registerValue
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|final
name|long
name|cardinality
init|=
name|hll
operator|.
name|cardinality
argument_list|()
decl_stmt|;
comment|// Simplified estimator when all registers take same value: alpha / (m/2^val)
specifier|final
name|double
name|estimator
init|=
name|HLLUtil
operator|.
name|alphaMSquared
argument_list|(
name|m
argument_list|)
operator|/
operator|(
operator|(
name|double
operator|)
name|m
operator|/
name|Math
operator|.
name|pow
argument_list|(
literal|2
argument_list|,
name|registerValue
argument_list|)
operator|)
decl_stmt|;
comment|// Assert conditions for uncorrected range
name|assertTrue
argument_list|(
name|estimator
operator|<=
name|Math
operator|.
name|pow
argument_list|(
literal|2
argument_list|,
name|l
argument_list|)
operator|/
literal|30
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|estimator
operator|>
operator|(
literal|5
operator|*
name|m
operator|/
operator|(
name|double
operator|)
literal|2
operator|)
argument_list|)
expr_stmt|;
specifier|final
name|long
name|expected
init|=
operator|(
name|long
operator|)
name|Math
operator|.
name|ceil
argument_list|(
name|estimator
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|cardinality
argument_list|,
name|expected
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Smoke test for {@link HLL#cardinality()} and the proper use of the large      * range correction.      */
annotation|@
name|Test
DECL|method|largeRangeSmokeTest
specifier|public
name|void
name|largeRangeSmokeTest
parameter_list|()
block|{
specifier|final
name|int
name|log2m
init|=
literal|11
decl_stmt|;
specifier|final
name|int
name|m
init|=
operator|(
literal|1
operator|<<
name|log2m
operator|)
decl_stmt|;
specifier|final
name|int
name|regwidth
init|=
literal|5
decl_stmt|;
comment|// regwidth = 5, so hash space is
comment|// log2m + (2^5 - 1 - 1), so L = log2m + 30
specifier|final
name|int
name|l
init|=
name|log2m
operator|+
literal|30
decl_stmt|;
comment|// all registers at large value
block|{
specifier|final
name|HLL
name|hll
init|=
operator|new
name|HLL
argument_list|(
name|log2m
argument_list|,
name|regwidth
argument_list|,
literal|128
comment|/*explicitThreshold, arbitrary, unused*/
argument_list|,
name|m
comment|/*sparseThreshold*/
argument_list|,
name|HLLType
operator|.
name|SPARSE
argument_list|)
decl_stmt|;
specifier|final
name|int
name|registerValue
init|=
literal|31
comment|/*chosen to ensure large correction kicks in*/
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|m
condition|;
name|i
operator|++
control|)
block|{
name|hll
operator|.
name|addRaw
argument_list|(
name|ProbabilisticTestUtil
operator|.
name|constructHLLValue
argument_list|(
name|log2m
argument_list|,
name|i
argument_list|,
name|registerValue
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|final
name|long
name|cardinality
init|=
name|hll
operator|.
name|cardinality
argument_list|()
decl_stmt|;
comment|// Simplified estimator when all registers take same value: alpha / (m/2^val)
specifier|final
name|double
name|estimator
init|=
name|HLLUtil
operator|.
name|alphaMSquared
argument_list|(
name|m
argument_list|)
operator|/
operator|(
operator|(
name|double
operator|)
name|m
operator|/
name|Math
operator|.
name|pow
argument_list|(
literal|2
argument_list|,
name|registerValue
argument_list|)
operator|)
decl_stmt|;
comment|// Assert conditions for large range
name|assertTrue
argument_list|(
name|estimator
operator|>
name|Math
operator|.
name|pow
argument_list|(
literal|2
argument_list|,
name|l
argument_list|)
operator|/
literal|30
argument_list|)
expr_stmt|;
comment|// Large range correction: -2^32 * log(1 - E/2^32)
specifier|final
name|long
name|expected
init|=
operator|(
name|long
operator|)
name|Math
operator|.
name|ceil
argument_list|(
operator|-
literal|1.0
operator|*
name|Math
operator|.
name|pow
argument_list|(
literal|2
argument_list|,
name|l
argument_list|)
operator|*
name|Math
operator|.
name|log
argument_list|(
literal|1.0
operator|-
name|estimator
operator|/
name|Math
operator|.
name|pow
argument_list|(
literal|2
argument_list|,
name|l
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|cardinality
argument_list|,
name|expected
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Tests {@link HLL#union(HLL)}.      */
annotation|@
name|Test
DECL|method|unionTest
specifier|public
name|void
name|unionTest
parameter_list|()
block|{
specifier|final
name|int
name|log2m
init|=
literal|11
comment|/*arbitrary*/
decl_stmt|;
specifier|final
name|int
name|sparseThreshold
init|=
literal|256
comment|/*arbitrary*/
decl_stmt|;
block|{
comment|// two empty multisets should union to an empty set
specifier|final
name|HLL
name|hllA
init|=
operator|new
name|HLL
argument_list|(
name|log2m
argument_list|,
literal|5
comment|/*regwidth*/
argument_list|,
literal|128
comment|/*explicitThreshold, arbitrary, unused*/
argument_list|,
name|sparseThreshold
argument_list|,
name|HLLType
operator|.
name|SPARSE
argument_list|)
decl_stmt|;
specifier|final
name|HLL
name|hllB
init|=
operator|new
name|HLL
argument_list|(
name|log2m
argument_list|,
literal|5
comment|/*regwidth*/
argument_list|,
literal|128
comment|/*explicitThreshold, arbitrary, unused*/
argument_list|,
name|sparseThreshold
argument_list|,
name|HLLType
operator|.
name|SPARSE
argument_list|)
decl_stmt|;
name|hllA
operator|.
name|union
argument_list|(
name|hllB
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|hllA
operator|.
name|getType
argument_list|()
argument_list|,
name|HLLType
operator|.
name|SPARSE
comment|/*unchanged*/
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|hllA
operator|.
name|cardinality
argument_list|()
argument_list|,
literal|0L
argument_list|)
expr_stmt|;
block|}
block|{
comment|// two disjoint multisets should union properly
specifier|final
name|HLL
name|hllA
init|=
operator|new
name|HLL
argument_list|(
name|log2m
argument_list|,
literal|5
comment|/*regwidth*/
argument_list|,
literal|128
comment|/*explicitThreshold, arbitrary, unused*/
argument_list|,
name|sparseThreshold
argument_list|,
name|HLLType
operator|.
name|SPARSE
argument_list|)
decl_stmt|;
name|hllA
operator|.
name|addRaw
argument_list|(
name|ProbabilisticTestUtil
operator|.
name|constructHLLValue
argument_list|(
name|log2m
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|HLL
name|hllB
init|=
operator|new
name|HLL
argument_list|(
name|log2m
argument_list|,
literal|5
comment|/*regwidth*/
argument_list|,
literal|128
comment|/*explicitThreshold, arbitrary, unused*/
argument_list|,
name|sparseThreshold
argument_list|,
name|HLLType
operator|.
name|SPARSE
argument_list|)
decl_stmt|;
name|hllB
operator|.
name|addRaw
argument_list|(
name|ProbabilisticTestUtil
operator|.
name|constructHLLValue
argument_list|(
name|log2m
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|hllA
operator|.
name|union
argument_list|(
name|hllB
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|hllA
operator|.
name|getType
argument_list|()
argument_list|,
name|HLLType
operator|.
name|SPARSE
comment|/*unchanged*/
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|hllA
operator|.
name|cardinality
argument_list|()
argument_list|,
literal|3L
comment|/*precomputed*/
argument_list|)
expr_stmt|;
name|assertRegisterPresent
argument_list|(
name|hllA
argument_list|,
literal|1
argument_list|,
operator|(
name|byte
operator|)
literal|1
argument_list|)
expr_stmt|;
name|assertRegisterPresent
argument_list|(
name|hllA
argument_list|,
literal|2
argument_list|,
operator|(
name|byte
operator|)
literal|1
argument_list|)
expr_stmt|;
block|}
block|{
comment|// two exactly overlapping multisets should union properly
specifier|final
name|HLL
name|hllA
init|=
operator|new
name|HLL
argument_list|(
name|log2m
argument_list|,
literal|5
comment|/*regwidth*/
argument_list|,
literal|128
comment|/*explicitThreshold, arbitrary, unused*/
argument_list|,
name|sparseThreshold
argument_list|,
name|HLLType
operator|.
name|SPARSE
argument_list|)
decl_stmt|;
name|hllA
operator|.
name|addRaw
argument_list|(
name|ProbabilisticTestUtil
operator|.
name|constructHLLValue
argument_list|(
name|log2m
argument_list|,
literal|1
argument_list|,
literal|10
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|HLL
name|hllB
init|=
operator|new
name|HLL
argument_list|(
name|log2m
argument_list|,
literal|5
comment|/*regwidth*/
argument_list|,
literal|128
comment|/*explicitThreshold, arbitrary, unused*/
argument_list|,
name|sparseThreshold
argument_list|,
name|HLLType
operator|.
name|SPARSE
argument_list|)
decl_stmt|;
name|hllB
operator|.
name|addRaw
argument_list|(
name|ProbabilisticTestUtil
operator|.
name|constructHLLValue
argument_list|(
name|log2m
argument_list|,
literal|1
argument_list|,
literal|13
argument_list|)
argument_list|)
expr_stmt|;
name|hllA
operator|.
name|union
argument_list|(
name|hllB
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|hllA
operator|.
name|getType
argument_list|()
argument_list|,
name|HLLType
operator|.
name|SPARSE
comment|/*unchanged*/
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|hllA
operator|.
name|cardinality
argument_list|()
argument_list|,
literal|2L
comment|/*precomputed*/
argument_list|)
expr_stmt|;
name|assertOneRegisterSet
argument_list|(
name|hllA
argument_list|,
literal|1
argument_list|,
operator|(
name|byte
operator|)
literal|13
comment|/*max(10,13)*/
argument_list|)
expr_stmt|;
block|}
block|{
comment|// overlapping multisets should union properly
specifier|final
name|HLL
name|hllA
init|=
operator|new
name|HLL
argument_list|(
name|log2m
argument_list|,
literal|5
comment|/*regwidth*/
argument_list|,
literal|128
comment|/*explicitThreshold, arbitrary, unused*/
argument_list|,
name|sparseThreshold
argument_list|,
name|HLLType
operator|.
name|SPARSE
argument_list|)
decl_stmt|;
specifier|final
name|HLL
name|hllB
init|=
operator|new
name|HLL
argument_list|(
name|log2m
argument_list|,
literal|5
comment|/*regwidth*/
argument_list|,
literal|128
comment|/*explicitThreshold, arbitrary, unused*/
argument_list|,
name|sparseThreshold
argument_list|,
name|HLLType
operator|.
name|SPARSE
argument_list|)
decl_stmt|;
comment|// register index = 3
specifier|final
name|long
name|rawValueA
init|=
name|ProbabilisticTestUtil
operator|.
name|constructHLLValue
argument_list|(
name|log2m
argument_list|,
literal|3
argument_list|,
literal|11
argument_list|)
decl_stmt|;
comment|// register index = 4
specifier|final
name|long
name|rawValueB
init|=
name|ProbabilisticTestUtil
operator|.
name|constructHLLValue
argument_list|(
name|log2m
argument_list|,
literal|4
argument_list|,
literal|13
argument_list|)
decl_stmt|;
specifier|final
name|long
name|rawValueBPrime
init|=
name|ProbabilisticTestUtil
operator|.
name|constructHLLValue
argument_list|(
name|log2m
argument_list|,
literal|4
argument_list|,
literal|21
argument_list|)
decl_stmt|;
comment|// register index = 5
specifier|final
name|long
name|rawValueC
init|=
name|ProbabilisticTestUtil
operator|.
name|constructHLLValue
argument_list|(
name|log2m
argument_list|,
literal|5
argument_list|,
literal|14
argument_list|)
decl_stmt|;
name|hllA
operator|.
name|addRaw
argument_list|(
name|rawValueA
argument_list|)
expr_stmt|;
name|hllA
operator|.
name|addRaw
argument_list|(
name|rawValueB
argument_list|)
expr_stmt|;
name|hllB
operator|.
name|addRaw
argument_list|(
name|rawValueBPrime
argument_list|)
expr_stmt|;
name|hllB
operator|.
name|addRaw
argument_list|(
name|rawValueC
argument_list|)
expr_stmt|;
name|hllA
operator|.
name|union
argument_list|(
name|hllB
argument_list|)
expr_stmt|;
comment|// union should have three registers set, with partition B set to the
comment|// max of the two registers
name|assertRegisterPresent
argument_list|(
name|hllA
argument_list|,
literal|3
argument_list|,
operator|(
name|byte
operator|)
literal|11
argument_list|)
expr_stmt|;
name|assertRegisterPresent
argument_list|(
name|hllA
argument_list|,
literal|4
argument_list|,
operator|(
name|byte
operator|)
literal|21
comment|/*max(21,13)*/
argument_list|)
expr_stmt|;
name|assertRegisterPresent
argument_list|(
name|hllA
argument_list|,
literal|5
argument_list|,
operator|(
name|byte
operator|)
literal|14
argument_list|)
expr_stmt|;
block|}
block|{
comment|// too-large unions should promote
specifier|final
name|HLL
name|hllA
init|=
operator|new
name|HLL
argument_list|(
name|log2m
argument_list|,
literal|5
comment|/*regwidth*/
argument_list|,
literal|128
comment|/*explicitThreshold, arbitrary, unused*/
argument_list|,
name|sparseThreshold
argument_list|,
name|HLLType
operator|.
name|SPARSE
argument_list|)
decl_stmt|;
specifier|final
name|HLL
name|hllB
init|=
operator|new
name|HLL
argument_list|(
name|log2m
argument_list|,
literal|5
comment|/*regwidth*/
argument_list|,
literal|128
comment|/*explicitThreshold, arbitrary, unused*/
argument_list|,
name|sparseThreshold
argument_list|,
name|HLLType
operator|.
name|SPARSE
argument_list|)
decl_stmt|;
comment|// fill up sets to maxCapacity
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|sparseThreshold
condition|;
name|i
operator|++
control|)
block|{
name|hllA
operator|.
name|addRaw
argument_list|(
name|ProbabilisticTestUtil
operator|.
name|constructHLLValue
argument_list|(
name|log2m
argument_list|,
name|i
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|hllB
operator|.
name|addRaw
argument_list|(
name|ProbabilisticTestUtil
operator|.
name|constructHLLValue
argument_list|(
name|log2m
argument_list|,
operator|(
name|i
operator|+
name|sparseThreshold
operator|)
comment|/*non-overlapping*/
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|hllA
operator|.
name|union
argument_list|(
name|hllB
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|hllA
operator|.
name|getType
argument_list|()
argument_list|,
name|HLLType
operator|.
name|FULL
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Tests {@link HLL#clear()}.      */
annotation|@
name|Test
DECL|method|clearTest
specifier|public
name|void
name|clearTest
parameter_list|()
block|{
specifier|final
name|HLL
name|hll
init|=
operator|new
name|HLL
argument_list|(
name|log2m
argument_list|,
literal|5
comment|/*regwidth*/
argument_list|,
literal|128
comment|/*explicitThreshold, arbitrary, unused*/
argument_list|,
literal|256
comment|/*sparseThreshold, arbitrary, unused*/
argument_list|,
name|HLLType
operator|.
name|SPARSE
argument_list|)
decl_stmt|;
name|hll
operator|.
name|addRaw
argument_list|(
literal|1L
argument_list|)
expr_stmt|;
name|hll
operator|.
name|clear
argument_list|()
expr_stmt|;
name|assertEquals
argument_list|(
name|hll
operator|.
name|cardinality
argument_list|()
argument_list|,
literal|0L
argument_list|)
expr_stmt|;
block|}
comment|/**      * Tests {@link HLL#toBytes(ISchemaVersion)} and      * {@link HLL#fromBytes(byte[])}.      */
annotation|@
name|Test
DECL|method|toFromBytesTest
specifier|public
name|void
name|toFromBytesTest
parameter_list|()
block|{
specifier|final
name|int
name|log2m
init|=
literal|11
comment|/*arbitrary*/
decl_stmt|;
specifier|final
name|int
name|regwidth
init|=
literal|5
comment|/*arbitrary*/
decl_stmt|;
specifier|final
name|int
name|sparseThreshold
init|=
literal|256
comment|/*arbitrary*/
decl_stmt|;
specifier|final
name|int
name|shortWordLength
init|=
literal|16
comment|/*log2m + regwidth = 11 + 5*/
decl_stmt|;
specifier|final
name|ISchemaVersion
name|schemaVersion
init|=
name|SerializationUtil
operator|.
name|DEFAULT_SCHEMA_VERSION
decl_stmt|;
specifier|final
name|HLLType
name|type
init|=
name|HLLType
operator|.
name|SPARSE
decl_stmt|;
specifier|final
name|int
name|padding
init|=
name|schemaVersion
operator|.
name|paddingBytes
argument_list|(
name|type
argument_list|)
decl_stmt|;
block|{
comment|// Should work on an empty element
specifier|final
name|HLL
name|hll
init|=
operator|new
name|HLL
argument_list|(
name|log2m
argument_list|,
name|regwidth
argument_list|,
literal|128
comment|/*explicitThreshold, arbitrary, unused*/
argument_list|,
name|sparseThreshold
argument_list|,
name|HLLType
operator|.
name|SPARSE
argument_list|)
decl_stmt|;
specifier|final
name|byte
index|[]
name|bytes
init|=
name|hll
operator|.
name|toBytes
argument_list|(
name|schemaVersion
argument_list|)
decl_stmt|;
comment|// output should just be padding since no registers are used
name|assertEquals
argument_list|(
name|bytes
operator|.
name|length
argument_list|,
name|padding
argument_list|)
expr_stmt|;
specifier|final
name|HLL
name|inHLL
init|=
name|HLL
operator|.
name|fromBytes
argument_list|(
name|bytes
argument_list|)
decl_stmt|;
comment|// assert register values correct
name|assertElementsEqual
argument_list|(
name|hll
argument_list|,
name|inHLL
argument_list|)
expr_stmt|;
block|}
block|{
comment|// Should work on a partially filled element
specifier|final
name|HLL
name|hll
init|=
operator|new
name|HLL
argument_list|(
name|log2m
argument_list|,
name|regwidth
argument_list|,
literal|128
comment|/*explicitThreshold, arbitrary, unused*/
argument_list|,
name|sparseThreshold
argument_list|,
name|HLLType
operator|.
name|SPARSE
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|long
name|rawValue
init|=
name|ProbabilisticTestUtil
operator|.
name|constructHLLValue
argument_list|(
name|log2m
argument_list|,
name|i
argument_list|,
operator|(
name|i
operator|+
literal|9
operator|)
argument_list|)
decl_stmt|;
name|hll
operator|.
name|addRaw
argument_list|(
name|rawValue
argument_list|)
expr_stmt|;
block|}
specifier|final
name|byte
index|[]
name|bytes
init|=
name|hll
operator|.
name|toBytes
argument_list|(
name|schemaVersion
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|bytes
operator|.
name|length
argument_list|,
name|padding
operator|+
name|ProbabilisticTestUtil
operator|.
name|getRequiredBytes
argument_list|(
name|shortWordLength
argument_list|,
literal|3
comment|/*registerCount*/
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|HLL
name|inHLL
init|=
name|HLL
operator|.
name|fromBytes
argument_list|(
name|bytes
argument_list|)
decl_stmt|;
comment|// assert register values correct
name|assertElementsEqual
argument_list|(
name|hll
argument_list|,
name|inHLL
argument_list|)
expr_stmt|;
block|}
block|{
comment|// Should work on a full set
specifier|final
name|HLL
name|hll
init|=
operator|new
name|HLL
argument_list|(
name|log2m
argument_list|,
name|regwidth
argument_list|,
literal|128
comment|/*explicitThreshold, arbitrary, unused*/
argument_list|,
name|sparseThreshold
argument_list|,
name|HLLType
operator|.
name|SPARSE
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|sparseThreshold
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|long
name|rawValue
init|=
name|ProbabilisticTestUtil
operator|.
name|constructHLLValue
argument_list|(
name|log2m
argument_list|,
name|i
argument_list|,
operator|(
name|i
operator|%
literal|9
operator|)
operator|+
literal|1
argument_list|)
decl_stmt|;
name|hll
operator|.
name|addRaw
argument_list|(
name|rawValue
argument_list|)
expr_stmt|;
block|}
specifier|final
name|byte
index|[]
name|bytes
init|=
name|hll
operator|.
name|toBytes
argument_list|(
name|schemaVersion
argument_list|)
decl_stmt|;
comment|// 'short words' should be 12 bits + 5 bits = 17 bits long
name|assertEquals
argument_list|(
name|bytes
operator|.
name|length
argument_list|,
name|padding
operator|+
name|ProbabilisticTestUtil
operator|.
name|getRequiredBytes
argument_list|(
name|shortWordLength
argument_list|,
name|sparseThreshold
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|HLL
name|inHLL
init|=
name|HLL
operator|.
name|fromBytes
argument_list|(
name|bytes
argument_list|)
decl_stmt|;
comment|// assert register values correct
name|assertElementsEqual
argument_list|(
name|hll
argument_list|,
name|inHLL
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Smoke tests the multisets by adding random values.      */
annotation|@
name|Test
DECL|method|randomValuesTest
specifier|public
name|void
name|randomValuesTest
parameter_list|()
block|{
specifier|final
name|int
name|log2m
init|=
literal|11
comment|/*arbitrary*/
decl_stmt|;
specifier|final
name|int
name|regwidth
init|=
literal|5
comment|/*arbitrary*/
decl_stmt|;
specifier|final
name|int
name|sparseThreshold
init|=
literal|256
comment|/*arbitrary*/
decl_stmt|;
for|for
control|(
name|int
name|run
init|=
literal|0
init|;
name|run
operator|<
literal|100
condition|;
name|run
operator|++
control|)
block|{
specifier|final
name|HLL
name|hll
init|=
operator|new
name|HLL
argument_list|(
name|log2m
argument_list|,
name|regwidth
argument_list|,
literal|128
comment|/*explicitThreshold, arbitrary, unused*/
argument_list|,
name|sparseThreshold
argument_list|,
name|HLLType
operator|.
name|SPARSE
argument_list|)
decl_stmt|;
specifier|final
name|IntByteHashMap
name|map
init|=
operator|new
name|IntByteHashMap
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|sparseThreshold
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|long
name|rawValue
init|=
name|RandomizedTest
operator|.
name|randomLong
argument_list|()
decl_stmt|;
specifier|final
name|short
name|registerIndex
init|=
name|ProbabilisticTestUtil
operator|.
name|getRegisterIndex
argument_list|(
name|rawValue
argument_list|,
name|log2m
argument_list|)
decl_stmt|;
specifier|final
name|byte
name|registerValue
init|=
name|ProbabilisticTestUtil
operator|.
name|getRegisterValue
argument_list|(
name|rawValue
argument_list|,
name|log2m
argument_list|)
decl_stmt|;
if|if
condition|(
name|map
operator|.
name|get
argument_list|(
name|registerIndex
argument_list|)
operator|<
name|registerValue
condition|)
block|{
name|map
operator|.
name|put
argument_list|(
name|registerIndex
argument_list|,
name|registerValue
argument_list|)
expr_stmt|;
block|}
name|hll
operator|.
name|addRaw
argument_list|(
name|rawValue
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|IntByteCursor
name|c
range|:
name|map
control|)
block|{
specifier|final
name|byte
name|expectedRegisterValue
init|=
name|map
operator|.
name|get
argument_list|(
name|c
operator|.
name|key
argument_list|)
decl_stmt|;
name|assertRegisterPresent
argument_list|(
name|hll
argument_list|,
name|c
operator|.
name|key
argument_list|,
name|expectedRegisterValue
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|//*************************************************************************
comment|// assertion helpers
comment|/**      * Asserts that the register at the specified index is set to the specified      * value.      */
DECL|method|assertRegisterPresent
specifier|private
specifier|static
name|void
name|assertRegisterPresent
parameter_list|(
specifier|final
name|HLL
name|hll
parameter_list|,
specifier|final
name|int
name|registerIndex
parameter_list|,
specifier|final
name|int
name|registerValue
parameter_list|)
block|{
specifier|final
name|IntByteHashMap
name|sparseProbabilisticStorage
init|=
name|hll
operator|.
name|sparseProbabilisticStorage
decl_stmt|;
name|assertEquals
argument_list|(
name|sparseProbabilisticStorage
operator|.
name|get
argument_list|(
name|registerIndex
argument_list|)
argument_list|,
name|registerValue
argument_list|)
expr_stmt|;
block|}
comment|/**      * Asserts that only the specified register is set and has the specified value.      */
DECL|method|assertOneRegisterSet
specifier|private
specifier|static
name|void
name|assertOneRegisterSet
parameter_list|(
specifier|final
name|HLL
name|hll
parameter_list|,
specifier|final
name|int
name|registerIndex
parameter_list|,
specifier|final
name|byte
name|registerValue
parameter_list|)
block|{
specifier|final
name|IntByteHashMap
name|sparseProbabilisticStorage
init|=
name|hll
operator|.
name|sparseProbabilisticStorage
decl_stmt|;
name|assertEquals
argument_list|(
name|sparseProbabilisticStorage
operator|.
name|size
argument_list|()
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|sparseProbabilisticStorage
operator|.
name|get
argument_list|(
name|registerIndex
argument_list|)
argument_list|,
name|registerValue
argument_list|)
expr_stmt|;
block|}
comment|/**      * Asserts that all registers in the two {@link HLL} instances are identical.      */
DECL|method|assertElementsEqual
specifier|private
specifier|static
name|void
name|assertElementsEqual
parameter_list|(
specifier|final
name|HLL
name|hllA
parameter_list|,
specifier|final
name|HLL
name|hllB
parameter_list|)
block|{
specifier|final
name|IntByteHashMap
name|sparseProbabilisticStorageA
init|=
name|hllA
operator|.
name|sparseProbabilisticStorage
decl_stmt|;
specifier|final
name|IntByteHashMap
name|sparseProbabilisticStorageB
init|=
name|hllB
operator|.
name|sparseProbabilisticStorage
decl_stmt|;
name|assertEquals
argument_list|(
name|sparseProbabilisticStorageA
operator|.
name|size
argument_list|()
argument_list|,
name|sparseProbabilisticStorageB
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|IntByteCursor
name|c
range|:
name|sparseProbabilisticStorageA
control|)
block|{
name|assertEquals
argument_list|(
name|sparseProbabilisticStorageA
operator|.
name|get
argument_list|(
name|c
operator|.
name|key
argument_list|)
argument_list|,
name|sparseProbabilisticStorageB
operator|.
name|get
argument_list|(
name|c
operator|.
name|key
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_class
end_unit
