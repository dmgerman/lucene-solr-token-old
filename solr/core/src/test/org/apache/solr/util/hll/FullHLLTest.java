begin_unit
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_package
DECL|package|org.apache.solr.util.hll
package|package
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|util
operator|.
name|hll
package|;
end_package
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|LuceneTestCase
import|;
end_import
begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Test
import|;
end_import
begin_comment
comment|/**  * Tests {@link HLL} of type {@link HLLType#FULL}.  */
end_comment
begin_class
DECL|class|FullHLLTest
specifier|public
class|class
name|FullHLLTest
extends|extends
name|LuceneTestCase
block|{
comment|// TODO union test
comment|/**      * Smoke test for {@link HLL#cardinality()} and the proper use of the      * small range correction.      */
annotation|@
name|Test
DECL|method|smallRangeSmokeTest
specifier|public
name|void
name|smallRangeSmokeTest
parameter_list|()
block|{
specifier|final
name|int
name|log2m
init|=
literal|11
decl_stmt|;
specifier|final
name|int
name|m
init|=
operator|(
literal|1
operator|<<
name|log2m
operator|)
decl_stmt|;
specifier|final
name|int
name|regwidth
init|=
literal|5
decl_stmt|;
comment|// only one register set
block|{
specifier|final
name|HLL
name|hll
init|=
operator|new
name|HLL
argument_list|(
name|log2m
argument_list|,
name|regwidth
argument_list|,
literal|128
comment|/*explicitThreshold, arbitrary, unused*/
argument_list|,
literal|256
comment|/*sparseThreshold, arbitrary, unused*/
argument_list|,
name|HLLType
operator|.
name|FULL
argument_list|)
decl_stmt|;
name|hll
operator|.
name|addRaw
argument_list|(
name|ProbabilisticTestUtil
operator|.
name|constructHLLValue
argument_list|(
name|log2m
argument_list|,
literal|0
comment|/*ix*/
argument_list|,
literal|1
comment|/*val*/
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|long
name|cardinality
init|=
name|hll
operator|.
name|cardinality
argument_list|()
decl_stmt|;
comment|// Trivially true that small correction conditions hold: one register
comment|// set implies zeroes exist, and estimator trivially smaller than 5m/2.
comment|// Small range correction: m * log(m/V)
specifier|final
name|long
name|expected
init|=
operator|(
name|long
operator|)
name|Math
operator|.
name|ceil
argument_list|(
name|m
operator|*
name|Math
operator|.
name|log
argument_list|(
operator|(
name|double
operator|)
name|m
operator|/
operator|(
name|m
operator|-
literal|1
operator|)
comment|/*# of zeroes*/
argument_list|)
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|cardinality
argument_list|,
name|expected
argument_list|)
expr_stmt|;
block|}
comment|// all but one register set
block|{
specifier|final
name|HLL
name|hll
init|=
operator|new
name|HLL
argument_list|(
name|log2m
argument_list|,
name|regwidth
argument_list|,
literal|128
comment|/*explicitThreshold, arbitrary, unused*/
argument_list|,
literal|256
comment|/*sparseThreshold, arbitrary, unused*/
argument_list|,
name|HLLType
operator|.
name|FULL
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
operator|(
name|m
operator|-
literal|1
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|hll
operator|.
name|addRaw
argument_list|(
name|ProbabilisticTestUtil
operator|.
name|constructHLLValue
argument_list|(
name|log2m
argument_list|,
name|i
comment|/*ix*/
argument_list|,
literal|1
comment|/*val*/
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// Trivially true that small correction conditions hold: all but
comment|// one register set implies a zero exists, and estimator trivially
comment|// smaller than 5m/2 since it's alpha / ((m-1)/2)
specifier|final
name|long
name|cardinality
init|=
name|hll
operator|.
name|cardinality
argument_list|()
decl_stmt|;
comment|// Small range correction: m * log(m/V)
specifier|final
name|long
name|expected
init|=
operator|(
name|long
operator|)
name|Math
operator|.
name|ceil
argument_list|(
name|m
operator|*
name|Math
operator|.
name|log
argument_list|(
operator|(
name|double
operator|)
name|m
operator|/
literal|1
comment|/*# of zeroes*/
argument_list|)
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|cardinality
argument_list|,
name|expected
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Smoke test for {@link HLL#cardinality()} and the proper use of the      * uncorrected estimator      */
annotation|@
name|Test
DECL|method|normalRangeSmokeTest
specifier|public
name|void
name|normalRangeSmokeTest
parameter_list|()
block|{
specifier|final
name|int
name|log2m
init|=
literal|11
decl_stmt|;
specifier|final
name|int
name|regwidth
init|=
literal|5
decl_stmt|;
comment|// regwidth = 5, so hash space is
comment|// log2m + (2^5 - 1 - 1), so L = log2m + 30
specifier|final
name|int
name|l
init|=
name|log2m
operator|+
literal|30
decl_stmt|;
specifier|final
name|int
name|m
init|=
operator|(
literal|1
operator|<<
name|log2m
operator|)
decl_stmt|;
specifier|final
name|HLL
name|hll
init|=
operator|new
name|HLL
argument_list|(
name|log2m
argument_list|,
name|regwidth
argument_list|,
literal|128
comment|/*explicitThreshold, arbitrary, unused*/
argument_list|,
literal|256
comment|/*sparseThreshold, arbitrary, unused*/
argument_list|,
name|HLLType
operator|.
name|FULL
argument_list|)
decl_stmt|;
comment|// all registers at 'medium' value
block|{
specifier|final
name|int
name|registerValue
init|=
literal|7
comment|/*chosen to ensure neither correction kicks in*/
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|m
condition|;
name|i
operator|++
control|)
block|{
name|hll
operator|.
name|addRaw
argument_list|(
name|ProbabilisticTestUtil
operator|.
name|constructHLLValue
argument_list|(
name|log2m
argument_list|,
name|i
argument_list|,
name|registerValue
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|final
name|long
name|cardinality
init|=
name|hll
operator|.
name|cardinality
argument_list|()
decl_stmt|;
comment|// Simplified estimator when all registers take same value: alpha / (m/2^val)
specifier|final
name|double
name|estimator
init|=
name|HLLUtil
operator|.
name|alphaMSquared
argument_list|(
name|m
argument_list|)
operator|/
operator|(
operator|(
name|double
operator|)
name|m
operator|/
name|Math
operator|.
name|pow
argument_list|(
literal|2
argument_list|,
name|registerValue
argument_list|)
operator|)
decl_stmt|;
comment|// Assert conditions for uncorrected range
name|assertTrue
argument_list|(
name|estimator
operator|<=
name|Math
operator|.
name|pow
argument_list|(
literal|2
argument_list|,
name|l
argument_list|)
operator|/
literal|30
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|estimator
operator|>
operator|(
literal|5
operator|*
name|m
operator|/
operator|(
name|double
operator|)
literal|2
operator|)
argument_list|)
expr_stmt|;
specifier|final
name|long
name|expected
init|=
operator|(
name|long
operator|)
name|Math
operator|.
name|ceil
argument_list|(
name|estimator
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|cardinality
argument_list|,
name|expected
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Smoke test for {@link HLL#cardinality()} and the proper use of the large      * range correction.      */
annotation|@
name|Test
DECL|method|largeRangeSmokeTest
specifier|public
name|void
name|largeRangeSmokeTest
parameter_list|()
block|{
specifier|final
name|int
name|log2m
init|=
literal|12
decl_stmt|;
specifier|final
name|int
name|regwidth
init|=
literal|5
decl_stmt|;
comment|// regwidth = 5, so hash space is
comment|// log2m + (2^5 - 1 - 1), so L = log2m + 30
specifier|final
name|int
name|l
init|=
name|log2m
operator|+
literal|30
decl_stmt|;
specifier|final
name|int
name|m
init|=
operator|(
literal|1
operator|<<
name|log2m
operator|)
decl_stmt|;
specifier|final
name|HLL
name|hll
init|=
operator|new
name|HLL
argument_list|(
name|log2m
argument_list|,
name|regwidth
argument_list|,
literal|128
comment|/*explicitThreshold, arbitrary, unused*/
argument_list|,
literal|256
comment|/*sparseThreshold, arbitrary, unused*/
argument_list|,
name|HLLType
operator|.
name|FULL
argument_list|)
decl_stmt|;
block|{
specifier|final
name|int
name|registerValue
init|=
literal|31
comment|/*chosen to ensure large correction kicks in*/
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|m
condition|;
name|i
operator|++
control|)
block|{
name|hll
operator|.
name|addRaw
argument_list|(
name|ProbabilisticTestUtil
operator|.
name|constructHLLValue
argument_list|(
name|log2m
argument_list|,
name|i
argument_list|,
name|registerValue
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|final
name|long
name|cardinality
init|=
name|hll
operator|.
name|cardinality
argument_list|()
decl_stmt|;
comment|// Simplified estimator when all registers take same value: alpha / (m/2^val)
specifier|final
name|double
name|estimator
init|=
name|HLLUtil
operator|.
name|alphaMSquared
argument_list|(
name|m
argument_list|)
operator|/
operator|(
operator|(
name|double
operator|)
name|m
operator|/
name|Math
operator|.
name|pow
argument_list|(
literal|2
argument_list|,
name|registerValue
argument_list|)
operator|)
decl_stmt|;
comment|// Assert conditions for large range
name|assertTrue
argument_list|(
name|estimator
operator|>
name|Math
operator|.
name|pow
argument_list|(
literal|2
argument_list|,
name|l
argument_list|)
operator|/
literal|30
argument_list|)
expr_stmt|;
comment|// Large range correction: -2^L * log(1 - E/2^L)
specifier|final
name|long
name|expected
init|=
operator|(
name|long
operator|)
name|Math
operator|.
name|ceil
argument_list|(
operator|-
literal|1.0
operator|*
name|Math
operator|.
name|pow
argument_list|(
literal|2
argument_list|,
name|l
argument_list|)
operator|*
name|Math
operator|.
name|log
argument_list|(
literal|1.0
operator|-
name|estimator
operator|/
name|Math
operator|.
name|pow
argument_list|(
literal|2
argument_list|,
name|l
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|cardinality
argument_list|,
name|expected
argument_list|)
expr_stmt|;
block|}
block|}
comment|// ========================================================================
comment|/**      * Tests the bounds on a register's value for a given raw input value.      */
annotation|@
name|Test
DECL|method|registerValueTest
specifier|public
name|void
name|registerValueTest
parameter_list|()
block|{
specifier|final
name|int
name|log2m
init|=
literal|4
comment|/*small enough to make testing easy (addRaw() shifts by one byte)*/
decl_stmt|;
comment|// register width 4 (the minimum size)
block|{
comment|// scoped locally for sanity
specifier|final
name|int
name|regwidth
init|=
literal|4
decl_stmt|;
specifier|final
name|HLL
name|hll
init|=
operator|new
name|HLL
argument_list|(
name|log2m
argument_list|,
name|regwidth
argument_list|,
literal|128
comment|/*explicitThreshold, arbitrary, unused*/
argument_list|,
literal|256
comment|/*sparseThreshold, arbitrary, unused*/
argument_list|,
name|HLLType
operator|.
name|FULL
argument_list|)
decl_stmt|;
specifier|final
name|BitVector
name|bitVector
init|=
name|hll
operator|.
name|probabilisticStorage
decl_stmt|;
comment|// lower-bounds of the register
name|hll
operator|.
name|addRaw
argument_list|(
literal|0x000000000000001L
comment|/*'j'=1*/
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|bitVector
operator|.
name|getRegister
argument_list|(
literal|1
comment|/*'j'*/
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|hll
operator|.
name|addRaw
argument_list|(
literal|0x0000000000000012L
comment|/*'j'=2*/
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|bitVector
operator|.
name|getRegister
argument_list|(
literal|2
comment|/*'j'*/
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|hll
operator|.
name|addRaw
argument_list|(
literal|0x0000000000000023L
comment|/*'j'=3*/
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|bitVector
operator|.
name|getRegister
argument_list|(
literal|3
comment|/*'j'*/
argument_list|)
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|hll
operator|.
name|addRaw
argument_list|(
literal|0x0000000000000044L
comment|/*'j'=4*/
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|bitVector
operator|.
name|getRegister
argument_list|(
literal|4
comment|/*'j'*/
argument_list|)
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|hll
operator|.
name|addRaw
argument_list|(
literal|0x0000000000000085L
comment|/*'j'=5*/
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|bitVector
operator|.
name|getRegister
argument_list|(
literal|5
comment|/*'j'*/
argument_list|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|// upper-bounds of the register
comment|// NOTE:  bear in mind that BitVector itself does ensure that
comment|//        overflow of a register is prevented
name|hll
operator|.
name|addRaw
argument_list|(
literal|0x0000000000010006L
comment|/*'j'=6*/
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|bitVector
operator|.
name|getRegister
argument_list|(
literal|6
comment|/*'j'*/
argument_list|)
argument_list|,
literal|13
argument_list|)
expr_stmt|;
name|hll
operator|.
name|addRaw
argument_list|(
literal|0x0000000000020007L
comment|/*'j'=7*/
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|bitVector
operator|.
name|getRegister
argument_list|(
literal|7
comment|/*'j'*/
argument_list|)
argument_list|,
literal|14
argument_list|)
expr_stmt|;
name|hll
operator|.
name|addRaw
argument_list|(
literal|0x0000000000040008L
comment|/*'j'=8*/
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|bitVector
operator|.
name|getRegister
argument_list|(
literal|8
comment|/*'j'*/
argument_list|)
argument_list|,
literal|15
argument_list|)
expr_stmt|;
name|hll
operator|.
name|addRaw
argument_list|(
literal|0x0000000000080009L
comment|/*'j'=9*/
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|bitVector
operator|.
name|getRegister
argument_list|(
literal|9
comment|/*'j'*/
argument_list|)
argument_list|,
literal|15
comment|/*overflow*/
argument_list|)
expr_stmt|;
comment|// sanity checks to ensure that no other bits above the lowest-set
comment|// bit matters
comment|// NOTE:  same as case 'j = 6' above
name|hll
operator|.
name|addRaw
argument_list|(
literal|0x000000000003000AL
comment|/*'j'=10*/
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|bitVector
operator|.
name|getRegister
argument_list|(
literal|10
comment|/*'j'*/
argument_list|)
argument_list|,
literal|13
argument_list|)
expr_stmt|;
name|hll
operator|.
name|addRaw
argument_list|(
literal|0x000000000011000BL
comment|/*'j'=11*/
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|bitVector
operator|.
name|getRegister
argument_list|(
literal|11
comment|/*'j'*/
argument_list|)
argument_list|,
literal|13
argument_list|)
expr_stmt|;
block|}
comment|// register width 5
block|{
comment|// scoped locally for sanity
specifier|final
name|int
name|regwidth
init|=
literal|5
decl_stmt|;
specifier|final
name|HLL
name|hll
init|=
operator|new
name|HLL
argument_list|(
name|log2m
argument_list|,
name|regwidth
argument_list|,
literal|128
comment|/*explicitThreshold, arbitrary, unused*/
argument_list|,
literal|256
comment|/*sparseThreshold, arbitrary, unused*/
argument_list|,
name|HLLType
operator|.
name|FULL
argument_list|)
decl_stmt|;
specifier|final
name|BitVector
name|bitVector
init|=
name|hll
operator|.
name|probabilisticStorage
decl_stmt|;
comment|// lower-bounds of the register
name|hll
operator|.
name|addRaw
argument_list|(
literal|0x0000000000000001L
comment|/*'j'=1*/
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|bitVector
operator|.
name|getRegister
argument_list|(
literal|1
comment|/*'j'*/
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|hll
operator|.
name|addRaw
argument_list|(
literal|0x0000000000000012L
comment|/*'j'=2*/
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|bitVector
operator|.
name|getRegister
argument_list|(
literal|2
comment|/*'j'*/
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|hll
operator|.
name|addRaw
argument_list|(
literal|0x0000000000000023L
comment|/*'j'=3*/
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|bitVector
operator|.
name|getRegister
argument_list|(
literal|3
comment|/*'j'*/
argument_list|)
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|hll
operator|.
name|addRaw
argument_list|(
literal|0x0000000000000044L
comment|/*'j'=4*/
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|bitVector
operator|.
name|getRegister
argument_list|(
literal|4
comment|/*'j'*/
argument_list|)
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|hll
operator|.
name|addRaw
argument_list|(
literal|0x0000000000000085L
comment|/*'j'=5*/
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|bitVector
operator|.
name|getRegister
argument_list|(
literal|5
comment|/*'j'*/
argument_list|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|// upper-bounds of the register
comment|// NOTE:  bear in mind that BitVector itself does ensure that
comment|//        overflow of a register is prevented
name|hll
operator|.
name|addRaw
argument_list|(
literal|0x0000000100000006L
comment|/*'j'=6*/
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|bitVector
operator|.
name|getRegister
argument_list|(
literal|6
comment|/*'j'*/
argument_list|)
argument_list|,
literal|29
argument_list|)
expr_stmt|;
name|hll
operator|.
name|addRaw
argument_list|(
literal|0x0000000200000007L
comment|/*'j'=7*/
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|bitVector
operator|.
name|getRegister
argument_list|(
literal|7
comment|/*'j'*/
argument_list|)
argument_list|,
literal|30
argument_list|)
expr_stmt|;
name|hll
operator|.
name|addRaw
argument_list|(
literal|0x0000000400000008L
comment|/*'j'=8*/
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|bitVector
operator|.
name|getRegister
argument_list|(
literal|8
comment|/*'j'*/
argument_list|)
argument_list|,
literal|31
argument_list|)
expr_stmt|;
name|hll
operator|.
name|addRaw
argument_list|(
literal|0x0000000800000009L
comment|/*'j'=9*/
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|bitVector
operator|.
name|getRegister
argument_list|(
literal|9
comment|/*'j'*/
argument_list|)
argument_list|,
literal|31
comment|/*overflow*/
argument_list|)
expr_stmt|;
block|}
block|}
comment|// ========================================================================
comment|/**      * Tests {@link HLL#clear()}.      */
annotation|@
name|Test
DECL|method|clearTest
specifier|public
name|void
name|clearTest
parameter_list|()
block|{
specifier|final
name|int
name|regwidth
init|=
literal|5
decl_stmt|;
specifier|final
name|int
name|log2m
init|=
literal|4
comment|/*16 registers per counter*/
decl_stmt|;
specifier|final
name|int
name|m
init|=
literal|1
operator|<<
name|log2m
decl_stmt|;
specifier|final
name|HLL
name|hll
init|=
operator|new
name|HLL
argument_list|(
name|log2m
argument_list|,
name|regwidth
argument_list|,
literal|128
comment|/*explicitThreshold, arbitrary, unused*/
argument_list|,
literal|256
comment|/*sparseThreshold, arbitrary, unused*/
argument_list|,
name|HLLType
operator|.
name|FULL
argument_list|)
decl_stmt|;
specifier|final
name|BitVector
name|bitVector
init|=
name|hll
operator|.
name|probabilisticStorage
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|m
condition|;
name|i
operator|++
control|)
name|bitVector
operator|.
name|setRegister
argument_list|(
name|i
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|hll
operator|.
name|clear
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|m
condition|;
name|i
operator|++
control|)
block|{
name|assertEquals
argument_list|(
name|bitVector
operator|.
name|getRegister
argument_list|(
name|i
argument_list|)
argument_list|,
literal|0L
comment|/*default value of register*/
argument_list|)
expr_stmt|;
block|}
block|}
comment|// ========================================================================
comment|// Serialization
comment|/**      * Tests {@link HLL#toBytes(ISchemaVersion)} and {@link HLL#fromBytes(byte[])}.      */
annotation|@
name|Test
DECL|method|toFromBytesTest
specifier|public
name|void
name|toFromBytesTest
parameter_list|()
block|{
specifier|final
name|int
name|log2m
init|=
literal|11
comment|/*arbitrary*/
decl_stmt|;
specifier|final
name|int
name|regwidth
init|=
literal|5
decl_stmt|;
specifier|final
name|ISchemaVersion
name|schemaVersion
init|=
name|SerializationUtil
operator|.
name|DEFAULT_SCHEMA_VERSION
decl_stmt|;
specifier|final
name|HLLType
name|type
init|=
name|HLLType
operator|.
name|FULL
decl_stmt|;
specifier|final
name|int
name|padding
init|=
name|schemaVersion
operator|.
name|paddingBytes
argument_list|(
name|type
argument_list|)
decl_stmt|;
specifier|final
name|int
name|dataByteCount
init|=
name|ProbabilisticTestUtil
operator|.
name|getRequiredBytes
argument_list|(
name|regwidth
argument_list|,
operator|(
literal|1
operator|<<
name|log2m
operator|)
comment|/*aka 2^log2m = m*/
argument_list|)
decl_stmt|;
specifier|final
name|int
name|expectedByteCount
init|=
name|padding
operator|+
name|dataByteCount
decl_stmt|;
block|{
comment|// Should work on an empty element
specifier|final
name|HLL
name|hll
init|=
operator|new
name|HLL
argument_list|(
name|log2m
argument_list|,
name|regwidth
argument_list|,
literal|128
comment|/*explicitThreshold, arbitrary, unused*/
argument_list|,
literal|256
comment|/*sparseThreshold, arbitrary, unused*/
argument_list|,
name|HLLType
operator|.
name|FULL
argument_list|)
decl_stmt|;
specifier|final
name|byte
index|[]
name|bytes
init|=
name|hll
operator|.
name|toBytes
argument_list|(
name|schemaVersion
argument_list|)
decl_stmt|;
comment|// assert output length is correct
name|assertEquals
argument_list|(
name|bytes
operator|.
name|length
argument_list|,
name|expectedByteCount
argument_list|)
expr_stmt|;
specifier|final
name|HLL
name|inHLL
init|=
name|HLL
operator|.
name|fromBytes
argument_list|(
name|bytes
argument_list|)
decl_stmt|;
comment|// assert register values correct
name|assertElementsEqual
argument_list|(
name|hll
argument_list|,
name|inHLL
argument_list|)
expr_stmt|;
block|}
block|{
comment|// Should work on a partially filled element
specifier|final
name|HLL
name|hll
init|=
operator|new
name|HLL
argument_list|(
name|log2m
argument_list|,
name|regwidth
argument_list|,
literal|128
comment|/*explicitThreshold, arbitrary, unused*/
argument_list|,
literal|256
comment|/*sparseThreshold, arbitrary, unused*/
argument_list|,
name|HLLType
operator|.
name|FULL
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|long
name|rawValue
init|=
name|ProbabilisticTestUtil
operator|.
name|constructHLLValue
argument_list|(
name|log2m
argument_list|,
name|i
argument_list|,
operator|(
name|i
operator|+
literal|9
operator|)
argument_list|)
decl_stmt|;
name|hll
operator|.
name|addRaw
argument_list|(
name|rawValue
argument_list|)
expr_stmt|;
block|}
specifier|final
name|byte
index|[]
name|bytes
init|=
name|hll
operator|.
name|toBytes
argument_list|(
name|schemaVersion
argument_list|)
decl_stmt|;
comment|// assert output length is correct
name|assertEquals
argument_list|(
name|bytes
operator|.
name|length
argument_list|,
name|expectedByteCount
argument_list|)
expr_stmt|;
specifier|final
name|HLL
name|inHLL
init|=
name|HLL
operator|.
name|fromBytes
argument_list|(
name|bytes
argument_list|)
decl_stmt|;
comment|// assert register values correct
name|assertElementsEqual
argument_list|(
name|hll
argument_list|,
name|inHLL
argument_list|)
expr_stmt|;
block|}
block|{
comment|// Should work on a full set
specifier|final
name|HLL
name|hll
init|=
operator|new
name|HLL
argument_list|(
name|log2m
argument_list|,
name|regwidth
argument_list|,
literal|128
comment|/*explicitThreshold, arbitrary, unused*/
argument_list|,
literal|256
comment|/*sparseThreshold, arbitrary, unused*/
argument_list|,
name|HLLType
operator|.
name|FULL
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
operator|(
literal|1
operator|<<
name|log2m
operator|)
comment|/*aka 2^log2m*/
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|long
name|rawValue
init|=
name|ProbabilisticTestUtil
operator|.
name|constructHLLValue
argument_list|(
name|log2m
argument_list|,
name|i
argument_list|,
operator|(
name|i
operator|%
literal|9
operator|)
operator|+
literal|1
argument_list|)
decl_stmt|;
name|hll
operator|.
name|addRaw
argument_list|(
name|rawValue
argument_list|)
expr_stmt|;
block|}
specifier|final
name|byte
index|[]
name|bytes
init|=
name|hll
operator|.
name|toBytes
argument_list|(
name|schemaVersion
argument_list|)
decl_stmt|;
comment|// assert output length is correct
name|assertEquals
argument_list|(
name|bytes
operator|.
name|length
argument_list|,
name|expectedByteCount
argument_list|)
expr_stmt|;
specifier|final
name|HLL
name|inHLL
init|=
name|HLL
operator|.
name|fromBytes
argument_list|(
name|bytes
argument_list|)
decl_stmt|;
comment|// assert register values correct
name|assertElementsEqual
argument_list|(
name|hll
argument_list|,
name|inHLL
argument_list|)
expr_stmt|;
block|}
block|}
comment|// ************************************************************************
comment|// Assertion Helpers
comment|/**      * Asserts that the two HLLs are register-wise equal.      */
DECL|method|assertElementsEqual
specifier|private
specifier|static
name|void
name|assertElementsEqual
parameter_list|(
specifier|final
name|HLL
name|hllA
parameter_list|,
specifier|final
name|HLL
name|hllB
parameter_list|)
block|{
specifier|final
name|BitVector
name|bitVectorA
init|=
name|hllA
operator|.
name|probabilisticStorage
decl_stmt|;
specifier|final
name|BitVector
name|bitVectorB
init|=
name|hllA
operator|.
name|probabilisticStorage
decl_stmt|;
specifier|final
name|LongIterator
name|iterA
init|=
name|bitVectorA
operator|.
name|registerIterator
argument_list|()
decl_stmt|;
specifier|final
name|LongIterator
name|iterB
init|=
name|bitVectorB
operator|.
name|registerIterator
argument_list|()
decl_stmt|;
for|for
control|(
init|;
name|iterA
operator|.
name|hasNext
argument_list|()
operator|&&
name|iterB
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|assertEquals
argument_list|(
name|iterA
operator|.
name|next
argument_list|()
argument_list|,
name|iterB
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|assertFalse
argument_list|(
name|iterA
operator|.
name|hasNext
argument_list|()
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|iterB
operator|.
name|hasNext
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
end_class
end_unit
