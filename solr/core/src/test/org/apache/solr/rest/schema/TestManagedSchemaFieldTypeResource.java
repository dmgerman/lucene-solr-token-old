begin_unit
begin_package
DECL|package|org.apache.solr.rest.schema
package|package
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|rest
operator|.
name|schema
package|;
end_package
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|SortedMap
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeMap
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|io
operator|.
name|FileUtils
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|util
operator|.
name|RestTestBase
import|;
end_import
begin_import
import|import
name|org
operator|.
name|eclipse
operator|.
name|jetty
operator|.
name|servlet
operator|.
name|ServletHolder
import|;
end_import
begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|After
import|;
end_import
begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Before
import|;
end_import
begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Test
import|;
end_import
begin_import
import|import
name|org
operator|.
name|noggit
operator|.
name|JSONUtil
import|;
end_import
begin_import
import|import
name|org
operator|.
name|restlet
operator|.
name|ext
operator|.
name|servlet
operator|.
name|ServerServlet
import|;
end_import
begin_class
DECL|class|TestManagedSchemaFieldTypeResource
specifier|public
class|class
name|TestManagedSchemaFieldTypeResource
extends|extends
name|RestTestBase
block|{
DECL|field|tmpSolrHome
specifier|private
specifier|static
name|File
name|tmpSolrHome
decl_stmt|;
DECL|field|tmpConfDir
specifier|private
specifier|static
name|File
name|tmpConfDir
decl_stmt|;
DECL|field|collection
specifier|private
specifier|static
specifier|final
name|String
name|collection
init|=
literal|"collection1"
decl_stmt|;
DECL|field|confDir
specifier|private
specifier|static
specifier|final
name|String
name|confDir
init|=
name|collection
operator|+
literal|"/conf"
decl_stmt|;
annotation|@
name|Before
DECL|method|before
specifier|public
name|void
name|before
parameter_list|()
throws|throws
name|Exception
block|{
name|tmpSolrHome
operator|=
name|createTempDir
argument_list|()
operator|.
name|toFile
argument_list|()
expr_stmt|;
name|tmpConfDir
operator|=
operator|new
name|File
argument_list|(
name|tmpSolrHome
argument_list|,
name|confDir
argument_list|)
expr_stmt|;
name|FileUtils
operator|.
name|copyDirectory
argument_list|(
operator|new
name|File
argument_list|(
name|TEST_HOME
argument_list|()
argument_list|)
argument_list|,
name|tmpSolrHome
operator|.
name|getAbsoluteFile
argument_list|()
argument_list|)
expr_stmt|;
specifier|final
name|SortedMap
argument_list|<
name|ServletHolder
argument_list|,
name|String
argument_list|>
name|extraServlets
init|=
operator|new
name|TreeMap
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|ServletHolder
name|solrRestApi
init|=
operator|new
name|ServletHolder
argument_list|(
literal|"SolrSchemaRestApi"
argument_list|,
name|ServerServlet
operator|.
name|class
argument_list|)
decl_stmt|;
name|solrRestApi
operator|.
name|setInitParameter
argument_list|(
literal|"org.restlet.application"
argument_list|,
literal|"org.apache.solr.rest.SolrSchemaRestApi"
argument_list|)
expr_stmt|;
name|extraServlets
operator|.
name|put
argument_list|(
name|solrRestApi
argument_list|,
literal|"/schema/*"
argument_list|)
expr_stmt|;
comment|// '/schema/*' matches '/schema', '/schema/', and '/schema/whatever...'
name|System
operator|.
name|setProperty
argument_list|(
literal|"managed.schema.mutable"
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
name|System
operator|.
name|setProperty
argument_list|(
literal|"enable.update.log"
argument_list|,
literal|"false"
argument_list|)
expr_stmt|;
name|createJettyAndHarness
argument_list|(
name|tmpSolrHome
operator|.
name|getAbsolutePath
argument_list|()
argument_list|,
literal|"solrconfig-managed-schema.xml"
argument_list|,
literal|"schema-rest.xml"
argument_list|,
literal|"/solr"
argument_list|,
literal|true
argument_list|,
name|extraServlets
argument_list|)
expr_stmt|;
block|}
annotation|@
name|After
DECL|method|after
specifier|private
name|void
name|after
parameter_list|()
throws|throws
name|Exception
block|{
name|jetty
operator|.
name|stop
argument_list|()
expr_stmt|;
name|jetty
operator|=
literal|null
expr_stmt|;
name|System
operator|.
name|clearProperty
argument_list|(
literal|"managed.schema.mutable"
argument_list|)
expr_stmt|;
name|System
operator|.
name|clearProperty
argument_list|(
literal|"enable.update.log"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testAddFieldTypes
specifier|public
name|void
name|testAddFieldTypes
parameter_list|()
throws|throws
name|Exception
block|{
comment|// name mismatch
name|assertJPut
argument_list|(
literal|"/schema/fieldtypes/myIntFieldType"
argument_list|,
name|json
argument_list|(
literal|"{'name':'badNameEh','class':'solr.TrieIntField','stored':false}"
argument_list|)
argument_list|,
literal|"/responseHeader/status==400"
argument_list|)
expr_stmt|;
comment|// no class
name|assertJPut
argument_list|(
literal|"/schema/fieldtypes/myIntFieldType"
argument_list|,
name|json
argument_list|(
literal|"{'stored':false}"
argument_list|)
argument_list|,
literal|"/responseHeader/status==400"
argument_list|)
expr_stmt|;
comment|// invalid attribute
name|assertJPut
argument_list|(
literal|"/schema/fieldtypes/myIntFieldType"
argument_list|,
name|json
argument_list|(
literal|"{'foo':'bar'}"
argument_list|)
argument_list|,
literal|"/responseHeader/status==400"
argument_list|)
expr_stmt|;
comment|// empty analyzer
name|String
name|ftdef
init|=
literal|""
decl_stmt|;
name|ftdef
operator|+=
literal|"{"
expr_stmt|;
name|ftdef
operator|+=
literal|"  'class':'solr.TextField','positionIncrementGap':'100',"
expr_stmt|;
name|ftdef
operator|+=
literal|"  'analyzer':''"
expr_stmt|;
name|ftdef
operator|+=
literal|"}"
expr_stmt|;
name|assertJPut
argument_list|(
literal|"/schema/fieldtypes/emptyAnalyzerFieldType"
argument_list|,
name|json
argument_list|(
name|ftdef
argument_list|)
argument_list|,
literal|"/responseHeader/status==400"
argument_list|)
expr_stmt|;
comment|// basic field types
name|assertJPut
argument_list|(
literal|"/schema/fieldtypes/myIntFieldType"
argument_list|,
name|json
argument_list|(
literal|"{'name':'myIntFieldType','class':'solr.TrieIntField','stored':false}"
argument_list|)
argument_list|,
literal|"/responseHeader/status==0"
argument_list|)
expr_stmt|;
name|checkFieldTypeProps
argument_list|(
name|getExpectedProps
argument_list|(
literal|"myIntFieldType"
argument_list|,
literal|"solr.TrieIntField"
argument_list|,
literal|true
argument_list|,
literal|false
argument_list|)
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|assertJPut
argument_list|(
literal|"/schema/fieldtypes/myDoubleFieldType"
argument_list|,
name|json
argument_list|(
literal|"{'class':'solr.TrieDoubleField','precisionStep':'0','positionIncrementGap':'0'}"
argument_list|)
argument_list|,
literal|"/responseHeader/status==0"
argument_list|)
expr_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|expProps
init|=
name|getExpectedProps
argument_list|(
literal|"myDoubleFieldType"
argument_list|,
literal|"solr.TrieDoubleField"
argument_list|,
literal|true
argument_list|,
literal|true
argument_list|)
decl_stmt|;
comment|// add some additional expected props for this type
name|expProps
operator|.
name|put
argument_list|(
literal|"precisionStep"
argument_list|,
literal|"0"
argument_list|)
expr_stmt|;
name|expProps
operator|.
name|put
argument_list|(
literal|"positionIncrementGap"
argument_list|,
literal|"0"
argument_list|)
expr_stmt|;
name|checkFieldTypeProps
argument_list|(
name|expProps
argument_list|,
literal|18
argument_list|)
expr_stmt|;
name|assertJPut
argument_list|(
literal|"/schema/fieldtypes/myBoolFieldType"
argument_list|,
name|json
argument_list|(
literal|"{'class':'solr.BoolField','sortMissingLast':true}"
argument_list|)
argument_list|,
literal|"/responseHeader/status==0"
argument_list|)
expr_stmt|;
name|expProps
operator|=
name|getExpectedProps
argument_list|(
literal|"myBoolFieldType"
argument_list|,
literal|"solr.BoolField"
argument_list|,
literal|true
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|expProps
operator|.
name|put
argument_list|(
literal|"sortMissingLast"
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|checkFieldTypeProps
argument_list|(
name|expProps
argument_list|,
literal|17
argument_list|)
expr_stmt|;
comment|// a text analyzing field type
name|ftdef
operator|=
literal|"{"
expr_stmt|;
name|ftdef
operator|+=
literal|"  'class':'solr.TextField','positionIncrementGap':'100',"
expr_stmt|;
name|ftdef
operator|+=
literal|"  'analyzer':{"
expr_stmt|;
name|ftdef
operator|+=
literal|"    'charFilters':["
expr_stmt|;
name|ftdef
operator|+=
literal|"       {'class':'solr.PatternReplaceCharFilterFactory','replacement':'$1$1','pattern':'([a-zA-Z])\\\\1+'}"
expr_stmt|;
name|ftdef
operator|+=
literal|"    ],"
expr_stmt|;
name|ftdef
operator|+=
literal|"    'tokenizer':{'class':'solr.WhitespaceTokenizerFactory'},"
expr_stmt|;
name|ftdef
operator|+=
literal|"    'filters':["
expr_stmt|;
name|ftdef
operator|+=
literal|"       {'class':'solr.WordDelimiterFilterFactory','preserveOriginal':'0'},"
expr_stmt|;
name|ftdef
operator|+=
literal|"       {'class':'solr.StopFilterFactory','words':'stopwords.txt','ignoreCase':'true'},"
expr_stmt|;
name|ftdef
operator|+=
literal|"       {'class':'solr.LowerCaseFilterFactory'},"
expr_stmt|;
name|ftdef
operator|+=
literal|"       {'class':'solr.ASCIIFoldingFilterFactory'},"
expr_stmt|;
name|ftdef
operator|+=
literal|"       {'class':'solr.KStemFilterFactory'}"
expr_stmt|;
name|ftdef
operator|+=
literal|"    ]"
expr_stmt|;
name|ftdef
operator|+=
literal|"  }"
expr_stmt|;
name|ftdef
operator|+=
literal|"}"
expr_stmt|;
name|assertJPut
argument_list|(
literal|"/schema/fieldtypes/myTextFieldType"
argument_list|,
name|json
argument_list|(
name|ftdef
argument_list|)
argument_list|,
literal|"/responseHeader/status==0"
argument_list|)
expr_stmt|;
name|expProps
operator|=
name|getExpectedProps
argument_list|(
literal|"myTextFieldType"
argument_list|,
literal|"solr.TextField"
argument_list|,
literal|true
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|expProps
operator|.
name|put
argument_list|(
literal|"autoGeneratePhraseQueries"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|expProps
operator|.
name|put
argument_list|(
literal|"omitNorms"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|expProps
operator|.
name|put
argument_list|(
literal|"omitTermFreqAndPositions"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|expProps
operator|.
name|put
argument_list|(
literal|"omitPositions"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|expProps
operator|.
name|put
argument_list|(
literal|"storeOffsetsWithPositions"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|expProps
operator|.
name|put
argument_list|(
literal|"tokenized"
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|analyzerTests
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|analyzerTests
operator|.
name|add
argument_list|(
literal|"/response/lst[@name='fieldType']/lst[@name='analyzer']/arr[@name='charFilters']/lst[1]/str[@name='class'] = 'solr.PatternReplaceCharFilterFactory'"
argument_list|)
expr_stmt|;
name|analyzerTests
operator|.
name|add
argument_list|(
literal|"/response/lst[@name='fieldType']/lst[@name='analyzer']/lst[@name='tokenizer']/str[@name='class'] = 'solr.WhitespaceTokenizerFactory'"
argument_list|)
expr_stmt|;
name|analyzerTests
operator|.
name|add
argument_list|(
literal|"/response/lst[@name='fieldType']/lst[@name='analyzer']/arr[@name='filters']/lst[1]/str[@name='class'] = 'solr.WordDelimiterFilterFactory'"
argument_list|)
expr_stmt|;
name|analyzerTests
operator|.
name|add
argument_list|(
literal|"/response/lst[@name='fieldType']/lst[@name='analyzer']/arr[@name='filters']/lst[2]/str[@name='class'] = 'solr.StopFilterFactory'"
argument_list|)
expr_stmt|;
name|analyzerTests
operator|.
name|add
argument_list|(
literal|"/response/lst[@name='fieldType']/lst[@name='analyzer']/arr[@name='filters']/lst[3]/str[@name='class'] = 'solr.LowerCaseFilterFactory'"
argument_list|)
expr_stmt|;
name|analyzerTests
operator|.
name|add
argument_list|(
literal|"/response/lst[@name='fieldType']/lst[@name='analyzer']/arr[@name='filters']/lst[4]/str[@name='class'] = 'solr.ASCIIFoldingFilterFactory'"
argument_list|)
expr_stmt|;
name|analyzerTests
operator|.
name|add
argument_list|(
literal|"/response/lst[@name='fieldType']/lst[@name='analyzer']/arr[@name='filters']/lst[5]/str[@name='class'] = 'solr.KStemFilterFactory'"
argument_list|)
expr_stmt|;
name|checkFieldTypeProps
argument_list|(
name|expProps
argument_list|,
literal|19
argument_list|,
name|analyzerTests
argument_list|)
expr_stmt|;
comment|// now add a field type that uses managed resources and a field that uses that type
name|String
name|piglatinStopWordEndpoint
init|=
literal|"/schema/analysis/stopwords/piglatin"
decl_stmt|;
name|String
name|piglatinSynonymEndpoint
init|=
literal|"/schema/analysis/synonyms/piglatin"
decl_stmt|;
comment|// now define a new FieldType that uses the managed piglatin endpoints
comment|// the managed endpoints will be autovivified as needed
name|ftdef
operator|=
literal|"{"
expr_stmt|;
name|ftdef
operator|+=
literal|"  'class':'solr.TextField',"
expr_stmt|;
name|ftdef
operator|+=
literal|"  'analyzer':{"
expr_stmt|;
name|ftdef
operator|+=
literal|"    'tokenizer':{'class':'solr.StandardTokenizerFactory'},"
expr_stmt|;
name|ftdef
operator|+=
literal|"    'filters':["
expr_stmt|;
name|ftdef
operator|+=
literal|"       {'class':'solr.ManagedStopFilterFactory','managed':'piglatin'},"
expr_stmt|;
name|ftdef
operator|+=
literal|"       {'class':'solr.ManagedSynonymFilterFactory','managed':'piglatin'}"
expr_stmt|;
name|ftdef
operator|+=
literal|"    ]"
expr_stmt|;
name|ftdef
operator|+=
literal|"  }"
expr_stmt|;
name|ftdef
operator|+=
literal|"}"
expr_stmt|;
name|assertJPut
argument_list|(
literal|"/schema/fieldtypes/piglatinFieldType"
argument_list|,
name|json
argument_list|(
name|ftdef
argument_list|)
argument_list|,
literal|"/responseHeader/status==0"
argument_list|)
expr_stmt|;
name|expProps
operator|=
name|getExpectedProps
argument_list|(
literal|"piglatinFieldType"
argument_list|,
literal|"solr.TextField"
argument_list|,
literal|true
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|expProps
operator|.
name|put
argument_list|(
literal|"autoGeneratePhraseQueries"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|expProps
operator|.
name|put
argument_list|(
literal|"omitNorms"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|expProps
operator|.
name|put
argument_list|(
literal|"omitTermFreqAndPositions"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|expProps
operator|.
name|put
argument_list|(
literal|"omitPositions"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|expProps
operator|.
name|put
argument_list|(
literal|"storeOffsetsWithPositions"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|expProps
operator|.
name|put
argument_list|(
literal|"tokenized"
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|analyzerTests
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
expr_stmt|;
name|analyzerTests
operator|.
name|add
argument_list|(
literal|"/response/lst[@name='fieldType']/lst[@name='analyzer']/lst[@name='tokenizer']/str[@name='class'] = 'solr.StandardTokenizerFactory'"
argument_list|)
expr_stmt|;
name|analyzerTests
operator|.
name|add
argument_list|(
literal|"/response/lst[@name='fieldType']/lst[@name='analyzer']/arr[@name='filters']/lst[1]/str[@name='class'] = 'solr.ManagedStopFilterFactory'"
argument_list|)
expr_stmt|;
name|analyzerTests
operator|.
name|add
argument_list|(
literal|"/response/lst[@name='fieldType']/lst[@name='analyzer']/arr[@name='filters']/lst[2]/str[@name='class'] = 'solr.ManagedSynonymFilterFactory'"
argument_list|)
expr_stmt|;
name|checkFieldTypeProps
argument_list|(
name|expProps
argument_list|,
literal|18
argument_list|,
name|analyzerTests
argument_list|)
expr_stmt|;
name|assertJQ
argument_list|(
name|piglatinSynonymEndpoint
argument_list|,
literal|"/synonymMappings/initArgs/ignoreCase==false"
argument_list|,
literal|"/synonymMappings/managedMap=={}"
argument_list|)
expr_stmt|;
comment|// add some piglatin synonyms
name|Map
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|syns
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|syns
operator|.
name|put
argument_list|(
literal|"appyhay"
argument_list|,
name|Arrays
operator|.
name|asList
argument_list|(
literal|"ladgay"
argument_list|,
literal|"oyfuljay"
argument_list|)
argument_list|)
expr_stmt|;
name|assertJPut
argument_list|(
name|piglatinSynonymEndpoint
argument_list|,
name|JSONUtil
operator|.
name|toJSON
argument_list|(
name|syns
argument_list|)
argument_list|,
literal|"/responseHeader/status==0"
argument_list|)
expr_stmt|;
name|assertJQ
argument_list|(
name|piglatinSynonymEndpoint
argument_list|,
literal|"/synonymMappings/managedMap/appyhay==['ladgay','oyfuljay']"
argument_list|)
expr_stmt|;
comment|// add some piglatin stopwords
name|assertJPut
argument_list|(
name|piglatinStopWordEndpoint
argument_list|,
name|JSONUtil
operator|.
name|toJSON
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
literal|"hetay"
argument_list|)
argument_list|)
argument_list|,
literal|"/responseHeader/status==0"
argument_list|)
expr_stmt|;
name|assertJQ
argument_list|(
name|piglatinStopWordEndpoint
operator|+
literal|"/hetay"
argument_list|,
literal|"/hetay=='hetay'"
argument_list|)
expr_stmt|;
comment|// add a field that uses our new type
name|assertJPut
argument_list|(
literal|"/schema/fields/newManagedField"
argument_list|,
name|json
argument_list|(
literal|"{'type':'piglatinFieldType','stored':false}"
argument_list|)
argument_list|,
literal|"/responseHeader/status==0"
argument_list|)
expr_stmt|;
name|assertQ
argument_list|(
literal|"/schema/fields/newManagedField?indent=on&wt=xml"
argument_list|,
literal|"count(/response/lst[@name='field']) = 1"
argument_list|,
literal|"/response/lst[@name='responseHeader']/int[@name='status'] = '0'"
argument_list|)
expr_stmt|;
comment|// try to delete the managed synonyms endpoint, which should fail because it is being used
name|assertJDelete
argument_list|(
name|piglatinSynonymEndpoint
argument_list|,
literal|"/responseHeader/status==403"
argument_list|)
expr_stmt|;
comment|// test adding multiple field types at once
name|ftdef
operator|=
literal|"["
expr_stmt|;
name|ftdef
operator|+=
literal|"{"
expr_stmt|;
name|ftdef
operator|+=
literal|"  'name':'textFieldType1',"
expr_stmt|;
name|ftdef
operator|+=
literal|"  'class':'solr.TextField','positionIncrementGap':'100',"
expr_stmt|;
name|ftdef
operator|+=
literal|"  'analyzer':{"
expr_stmt|;
name|ftdef
operator|+=
literal|"    'tokenizer':{'class':'solr.WhitespaceTokenizerFactory'},"
expr_stmt|;
name|ftdef
operator|+=
literal|"    'filters':["
expr_stmt|;
name|ftdef
operator|+=
literal|"       {'class':'solr.WordDelimiterFilterFactory','preserveOriginal':'0'},"
expr_stmt|;
name|ftdef
operator|+=
literal|"       {'class':'solr.StopFilterFactory','words':'stopwords.txt','ignoreCase':'true'},"
expr_stmt|;
name|ftdef
operator|+=
literal|"       {'class':'solr.LowerCaseFilterFactory'}"
expr_stmt|;
name|ftdef
operator|+=
literal|"    ]"
expr_stmt|;
name|ftdef
operator|+=
literal|"  }"
expr_stmt|;
name|ftdef
operator|+=
literal|"},{"
expr_stmt|;
name|ftdef
operator|+=
literal|"  'name':'textFieldType2',"
expr_stmt|;
name|ftdef
operator|+=
literal|"  'class':'solr.TextField','positionIncrementGap':'100',"
expr_stmt|;
name|ftdef
operator|+=
literal|"  'analyzer':{"
expr_stmt|;
name|ftdef
operator|+=
literal|"    'tokenizer':{'class':'solr.WhitespaceTokenizerFactory'},"
expr_stmt|;
name|ftdef
operator|+=
literal|"    'filters':["
expr_stmt|;
name|ftdef
operator|+=
literal|"       {'class':'solr.WordDelimiterFilterFactory','preserveOriginal':'0'},"
expr_stmt|;
name|ftdef
operator|+=
literal|"       {'class':'solr.StopFilterFactory','words':'stopwords.txt','ignoreCase':'true'},"
expr_stmt|;
name|ftdef
operator|+=
literal|"       {'class':'solr.LowerCaseFilterFactory'},"
expr_stmt|;
name|ftdef
operator|+=
literal|"       {'class':'solr.ASCIIFoldingFilterFactory'}"
expr_stmt|;
name|ftdef
operator|+=
literal|"    ]"
expr_stmt|;
name|ftdef
operator|+=
literal|"  }"
expr_stmt|;
name|ftdef
operator|+=
literal|"}"
expr_stmt|;
name|ftdef
operator|+=
literal|"]"
expr_stmt|;
name|assertJPost
argument_list|(
literal|"/schema/fieldtypes"
argument_list|,
name|json
argument_list|(
name|ftdef
argument_list|)
argument_list|,
literal|"/responseHeader/status==0"
argument_list|)
expr_stmt|;
name|expProps
operator|=
name|getExpectedProps
argument_list|(
literal|"textFieldType1"
argument_list|,
literal|"solr.TextField"
argument_list|,
literal|true
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|expProps
operator|.
name|put
argument_list|(
literal|"autoGeneratePhraseQueries"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|expProps
operator|.
name|put
argument_list|(
literal|"omitNorms"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|expProps
operator|.
name|put
argument_list|(
literal|"omitTermFreqAndPositions"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|expProps
operator|.
name|put
argument_list|(
literal|"omitPositions"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|expProps
operator|.
name|put
argument_list|(
literal|"storeOffsetsWithPositions"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|expProps
operator|.
name|put
argument_list|(
literal|"tokenized"
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|analyzerTests
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
expr_stmt|;
name|analyzerTests
operator|.
name|add
argument_list|(
literal|"/response/lst[@name='fieldType']/lst[@name='analyzer']/lst[@name='tokenizer']/str[@name='class'] = 'solr.WhitespaceTokenizerFactory'"
argument_list|)
expr_stmt|;
name|analyzerTests
operator|.
name|add
argument_list|(
literal|"/response/lst[@name='fieldType']/lst[@name='analyzer']/arr[@name='filters']/lst[1]/str[@name='class'] = 'solr.WordDelimiterFilterFactory'"
argument_list|)
expr_stmt|;
name|analyzerTests
operator|.
name|add
argument_list|(
literal|"/response/lst[@name='fieldType']/lst[@name='analyzer']/arr[@name='filters']/lst[2]/str[@name='class'] = 'solr.StopFilterFactory'"
argument_list|)
expr_stmt|;
name|analyzerTests
operator|.
name|add
argument_list|(
literal|"/response/lst[@name='fieldType']/lst[@name='analyzer']/arr[@name='filters']/lst[3]/str[@name='class'] = 'solr.LowerCaseFilterFactory'"
argument_list|)
expr_stmt|;
name|checkFieldTypeProps
argument_list|(
name|expProps
argument_list|,
literal|19
argument_list|,
name|analyzerTests
argument_list|)
expr_stmt|;
name|expProps
operator|=
name|getExpectedProps
argument_list|(
literal|"textFieldType2"
argument_list|,
literal|"solr.TextField"
argument_list|,
literal|true
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|expProps
operator|.
name|put
argument_list|(
literal|"autoGeneratePhraseQueries"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|expProps
operator|.
name|put
argument_list|(
literal|"omitNorms"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|expProps
operator|.
name|put
argument_list|(
literal|"omitTermFreqAndPositions"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|expProps
operator|.
name|put
argument_list|(
literal|"omitPositions"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|expProps
operator|.
name|put
argument_list|(
literal|"storeOffsetsWithPositions"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|expProps
operator|.
name|put
argument_list|(
literal|"tokenized"
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|analyzerTests
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
expr_stmt|;
name|analyzerTests
operator|.
name|add
argument_list|(
literal|"/response/lst[@name='fieldType']/lst[@name='analyzer']/lst[@name='tokenizer']/str[@name='class'] = 'solr.WhitespaceTokenizerFactory'"
argument_list|)
expr_stmt|;
name|analyzerTests
operator|.
name|add
argument_list|(
literal|"/response/lst[@name='fieldType']/lst[@name='analyzer']/arr[@name='filters']/lst[1]/str[@name='class'] = 'solr.WordDelimiterFilterFactory'"
argument_list|)
expr_stmt|;
name|analyzerTests
operator|.
name|add
argument_list|(
literal|"/response/lst[@name='fieldType']/lst[@name='analyzer']/arr[@name='filters']/lst[2]/str[@name='class'] = 'solr.StopFilterFactory'"
argument_list|)
expr_stmt|;
name|analyzerTests
operator|.
name|add
argument_list|(
literal|"/response/lst[@name='fieldType']/lst[@name='analyzer']/arr[@name='filters']/lst[3]/str[@name='class'] = 'solr.LowerCaseFilterFactory'"
argument_list|)
expr_stmt|;
name|analyzerTests
operator|.
name|add
argument_list|(
literal|"/response/lst[@name='fieldType']/lst[@name='analyzer']/arr[@name='filters']/lst[4]/str[@name='class'] = 'solr.ASCIIFoldingFilterFactory'"
argument_list|)
expr_stmt|;
name|checkFieldTypeProps
argument_list|(
name|expProps
argument_list|,
literal|19
argument_list|,
name|analyzerTests
argument_list|)
expr_stmt|;
block|}
comment|/**    * Helper function to check fieldType settings against a set of expected values.    */
DECL|method|checkFieldTypeProps
specifier|protected
name|void
name|checkFieldTypeProps
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|expected
parameter_list|,
name|int
name|expectedChildCount
parameter_list|)
block|{
name|checkFieldTypeProps
argument_list|(
name|expected
argument_list|,
name|expectedChildCount
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
DECL|method|checkFieldTypeProps
specifier|protected
name|void
name|checkFieldTypeProps
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|expected
parameter_list|,
name|int
name|expectedChildCount
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|addlTests
parameter_list|)
block|{
name|String
name|fieldTypeName
init|=
operator|(
name|String
operator|)
name|expected
operator|.
name|get
argument_list|(
literal|"name"
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|tests
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|tests
operator|.
name|add
argument_list|(
literal|"count(/response/lst[@name='fieldType']) = 1"
argument_list|)
expr_stmt|;
name|tests
operator|.
name|add
argument_list|(
literal|"count(/response/lst[@name='fieldType']/*) = "
operator|+
name|expectedChildCount
argument_list|)
expr_stmt|;
name|tests
operator|.
name|add
argument_list|(
literal|"count(/response/lst[@name='fieldType']/arr[@name='fields']/*) = 0"
argument_list|)
expr_stmt|;
name|tests
operator|.
name|add
argument_list|(
literal|"count(/response/lst[@name='fieldType']/arr[@name='dynamicFields']/*) = 0"
argument_list|)
expr_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|next
range|:
name|expected
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|Object
name|val
init|=
name|next
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|String
name|pathType
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|val
operator|instanceof
name|Boolean
condition|)
name|pathType
operator|=
literal|"bool"
expr_stmt|;
elseif|else
if|if
condition|(
name|val
operator|instanceof
name|String
condition|)
name|pathType
operator|=
literal|"str"
expr_stmt|;
else|else
name|fail
argument_list|(
literal|"Unexpected value type "
operator|+
name|val
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
comment|// NOTE: it seems like the fieldtypes endpoint only returns strings or booleans
name|String
name|xpath
init|=
literal|"/response/lst[@name='fieldType']/"
operator|+
name|pathType
operator|+
literal|"[@name='"
operator|+
name|next
operator|.
name|getKey
argument_list|()
operator|+
literal|"']"
decl_stmt|;
name|tests
operator|.
name|add
argument_list|(
name|xpath
operator|+
literal|" = '"
operator|+
name|val
operator|+
literal|"'"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|addlTests
operator|!=
literal|null
condition|)
name|tests
operator|.
name|addAll
argument_list|(
name|addlTests
argument_list|)
expr_stmt|;
name|assertQ
argument_list|(
literal|"/schema/fieldtypes/"
operator|+
name|fieldTypeName
operator|+
literal|"?indent=on&wt=xml&showDefaults=true"
argument_list|,
name|tests
operator|.
name|toArray
argument_list|(
operator|new
name|String
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Builds a map containing expected values for a field type created by this test.     */
DECL|method|getExpectedProps
specifier|protected
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|getExpectedProps
parameter_list|(
name|String
name|name
parameter_list|,
name|String
name|className
parameter_list|,
name|boolean
name|indexed
parameter_list|,
name|boolean
name|stored
parameter_list|)
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|map
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|map
operator|.
name|put
argument_list|(
literal|"name"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
literal|"class"
argument_list|,
name|className
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
literal|"indexed"
argument_list|,
name|indexed
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
literal|"stored"
argument_list|,
name|stored
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
literal|"docValues"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
literal|"termVectors"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
literal|"termPositions"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
literal|"termOffsets"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
literal|"omitNorms"
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
literal|"omitTermFreqAndPositions"
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
literal|"omitPositions"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
literal|"storeOffsetsWithPositions"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
literal|"multiValued"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
literal|"tokenized"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
return|return
name|map
return|;
block|}
block|}
end_class
end_unit
