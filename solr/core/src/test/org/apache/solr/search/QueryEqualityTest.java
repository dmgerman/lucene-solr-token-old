begin_unit
begin_package
DECL|package|org.apache.solr.search
package|package
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|search
package|;
end_package
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|Query
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|QueryUtils
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|SolrTestCaseJ4
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|request
operator|.
name|SolrQueryRequest
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|request
operator|.
name|SolrRequestInfo
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|response
operator|.
name|SolrQueryResponse
import|;
end_import
begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|AfterClass
import|;
end_import
begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|BeforeClass
import|;
end_import
begin_comment
comment|/**  * Sanity checks that queries (generated by the QParser and ValueSourceParser   * framework) are appropriately {@link Object#equals} and   * {@link Object#hashCode()} equivalent.  If you are adding a new default   * QParser or ValueSourceParser, you will most likely get a failure from  * {@link #testParserCoverage} until you add a new test method to this class.  *  * @see ValueSourceParser#standardValueSourceParsers  * @see QParserPlugin#standardPlugins  * @see QueryUtils  **/
end_comment
begin_class
DECL|class|QueryEqualityTest
specifier|public
class|class
name|QueryEqualityTest
extends|extends
name|SolrTestCaseJ4
block|{
annotation|@
name|BeforeClass
DECL|method|beforeClass
specifier|public
specifier|static
name|void
name|beforeClass
parameter_list|()
throws|throws
name|Exception
block|{
name|initCore
argument_list|(
literal|"solrconfig.xml"
argument_list|,
literal|"schema15.xml"
argument_list|)
expr_stmt|;
block|}
comment|/** @see #testParserCoverage */
annotation|@
name|AfterClass
DECL|method|afterClassParserCoverageTest
specifier|public
specifier|static
name|void
name|afterClassParserCoverageTest
parameter_list|()
block|{
if|if
condition|(
operator|!
name|doAssertParserCoverage
condition|)
return|return;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|QParserPlugin
operator|.
name|standardPlugins
operator|.
name|length
condition|;
name|i
operator|+=
literal|2
control|)
block|{
name|assertTrue
argument_list|(
literal|"qparser #"
operator|+
name|i
operator|+
literal|" name not a string"
argument_list|,
name|QParserPlugin
operator|.
name|standardPlugins
index|[
name|i
index|]
operator|instanceof
name|String
argument_list|)
expr_stmt|;
specifier|final
name|String
name|name
init|=
operator|(
name|String
operator|)
name|QParserPlugin
operator|.
name|standardPlugins
index|[
name|i
index|]
decl_stmt|;
name|assertTrue
argument_list|(
literal|"testParserCoverage was run w/o any other method explicitly testing qparser: "
operator|+
name|name
argument_list|,
name|qParsersTested
operator|.
name|contains
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
specifier|final
name|String
name|name
range|:
name|ValueSourceParser
operator|.
name|standardValueSourceParsers
operator|.
name|keySet
argument_list|()
control|)
block|{
name|assertTrue
argument_list|(
literal|"testParserCoverage was run w/o any other method explicitly testing val parser: "
operator|+
name|name
argument_list|,
name|valParsersTested
operator|.
name|contains
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** @see #testParserCoverage */
DECL|field|doAssertParserCoverage
specifier|private
specifier|static
name|boolean
name|doAssertParserCoverage
init|=
literal|false
decl_stmt|;
comment|/** @see #testParserCoverage */
DECL|field|qParsersTested
specifier|private
specifier|static
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|qParsersTested
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
comment|/** @see #testParserCoverage */
DECL|field|valParsersTested
specifier|private
specifier|static
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|valParsersTested
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
DECL|method|testDateMathParsingEquality
specifier|public
name|void
name|testDateMathParsingEquality
parameter_list|()
throws|throws
name|Exception
block|{
comment|// regardless of parser, these should all be equivalent queries
name|assertQueryEquals
argument_list|(
literal|null
argument_list|,
literal|"{!lucene}f_tdt:2013-09-11T00\\:00\\:00Z"
argument_list|,
literal|"{!lucene}f_tdt:2013-03-08T00\\:46\\:15Z/DAY+6MONTHS+3DAYS"
argument_list|,
literal|"{!lucene}f_tdt:\"2013-03-08T00:46:15Z/DAY+6MONTHS+3DAYS\""
argument_list|,
literal|"{!field f=f_tdt}2013-03-08T00:46:15Z/DAY+6MONTHS+3DAYS"
argument_list|,
literal|"{!field f=f_tdt}2013-09-11T00:00:00Z"
argument_list|,
literal|"{!term f=f_tdt}2013-03-08T00:46:15Z/DAY+6MONTHS+3DAYS"
argument_list|,
literal|"{!term f=f_tdt}2013-09-11T00:00:00Z"
argument_list|)
expr_stmt|;
block|}
DECL|method|testQueryLucene
specifier|public
name|void
name|testQueryLucene
parameter_list|()
throws|throws
name|Exception
block|{
name|assertQueryEquals
argument_list|(
literal|"lucene"
argument_list|,
literal|"{!lucene}apache solr"
argument_list|,
literal|"apache  solr"
argument_list|,
literal|"apache solr "
argument_list|)
expr_stmt|;
name|assertQueryEquals
argument_list|(
literal|"lucene"
argument_list|,
literal|"+apache +solr"
argument_list|,
literal|"apache AND solr"
argument_list|,
literal|" +apache +solr"
argument_list|)
expr_stmt|;
block|}
DECL|method|testQueryLucenePlusSort
specifier|public
name|void
name|testQueryLucenePlusSort
parameter_list|()
throws|throws
name|Exception
block|{
name|assertQueryEquals
argument_list|(
literal|"lucenePlusSort"
argument_list|,
literal|"apache solr"
argument_list|,
literal|"apache  solr"
argument_list|,
literal|"apache solr ; score desc"
argument_list|)
expr_stmt|;
name|assertQueryEquals
argument_list|(
literal|"lucenePlusSort"
argument_list|,
literal|"+apache +solr"
argument_list|,
literal|"apache AND solr"
argument_list|,
literal|" +apache +solr; score desc"
argument_list|)
expr_stmt|;
block|}
DECL|method|testQueryPrefix
specifier|public
name|void
name|testQueryPrefix
parameter_list|()
throws|throws
name|Exception
block|{
name|SolrQueryRequest
name|req
init|=
name|req
argument_list|(
literal|"myField"
argument_list|,
literal|"foo_s"
argument_list|)
decl_stmt|;
try|try
block|{
name|assertQueryEquals
argument_list|(
literal|"prefix"
argument_list|,
name|req
argument_list|,
literal|"{!prefix f=$myField}asdf"
argument_list|,
literal|"{!prefix f=foo_s}asdf"
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|req
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|testQueryBoost
specifier|public
name|void
name|testQueryBoost
parameter_list|()
throws|throws
name|Exception
block|{
name|SolrQueryRequest
name|req
init|=
name|req
argument_list|(
literal|"df"
argument_list|,
literal|"foo_s"
argument_list|,
literal|"myBoost"
argument_list|,
literal|"sum(3,foo_i)"
argument_list|)
decl_stmt|;
try|try
block|{
name|assertQueryEquals
argument_list|(
literal|"boost"
argument_list|,
name|req
argument_list|,
literal|"{!boost b=$myBoost}asdf"
argument_list|,
literal|"{!boost b=$myBoost v=asdf}"
argument_list|,
literal|"{!boost b=sum(3,foo_i)}foo_s:asdf"
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|req
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|testQuerySwitch
specifier|public
name|void
name|testQuerySwitch
parameter_list|()
throws|throws
name|Exception
block|{
name|SolrQueryRequest
name|req
init|=
name|req
argument_list|(
literal|"myXXX"
argument_list|,
literal|"XXX"
argument_list|,
literal|"myField"
argument_list|,
literal|"foo_s"
argument_list|,
literal|"myQ"
argument_list|,
literal|"{!prefix f=$myField}asdf"
argument_list|)
decl_stmt|;
try|try
block|{
name|assertQueryEquals
argument_list|(
literal|"switch"
argument_list|,
name|req
argument_list|,
literal|"{!switch case.foo=XXX case.bar=zzz case.yak=qqq}foo"
argument_list|,
literal|"{!switch case.foo=qqq case.bar=XXX case.yak=zzz} bar "
argument_list|,
literal|"{!switch case.foo=qqq case.bar=XXX case.yak=zzz v='  bar '}"
argument_list|,
literal|"{!switch default=XXX case.foo=qqq case.bar=zzz}asdf"
argument_list|,
literal|"{!switch default=$myXXX case.foo=qqq case.bar=zzz}asdf"
argument_list|,
literal|"{!switch case=XXX case.bar=zzz case.yak=qqq v=''}"
argument_list|,
literal|"{!switch case.bar=zzz case=XXX case.yak=qqq v=''}"
argument_list|,
literal|"{!switch case=XXX case.bar=zzz case.yak=qqq}"
argument_list|,
literal|"{!switch case=XXX case.bar=zzz case.yak=qqq}   "
argument_list|,
literal|"{!switch case=$myXXX case.bar=zzz case.yak=qqq}   "
argument_list|)
expr_stmt|;
name|assertQueryEquals
argument_list|(
literal|"switch"
argument_list|,
name|req
argument_list|,
literal|"{!switch case.foo=$myQ case.bar=zzz case.yak=qqq}foo"
argument_list|,
literal|"{!query v=$myQ}"
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|req
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|testQueryDismax
specifier|public
name|void
name|testQueryDismax
parameter_list|()
throws|throws
name|Exception
block|{
for|for
control|(
specifier|final
name|String
name|type
range|:
operator|new
name|String
index|[]
block|{
literal|"dismax"
block|,
literal|"edismax"
block|}
control|)
block|{
name|assertQueryEquals
argument_list|(
name|type
argument_list|,
literal|"{!"
operator|+
name|type
operator|+
literal|"}apache solr"
argument_list|,
literal|"apache solr"
argument_list|,
literal|"apache  solr"
argument_list|,
literal|"apache solr "
argument_list|)
expr_stmt|;
name|assertQueryEquals
argument_list|(
name|type
argument_list|,
literal|"+apache +solr"
argument_list|,
literal|"apache AND solr"
argument_list|,
literal|" +apache +solr"
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|testField
specifier|public
name|void
name|testField
parameter_list|()
throws|throws
name|Exception
block|{
name|SolrQueryRequest
name|req
init|=
name|req
argument_list|(
literal|"myField"
argument_list|,
literal|"foo_s"
argument_list|)
decl_stmt|;
try|try
block|{
name|assertQueryEquals
argument_list|(
literal|"field"
argument_list|,
name|req
argument_list|,
literal|"{!field f=$myField}asdf"
argument_list|,
literal|"{!field f=$myField v=asdf}"
argument_list|,
literal|"{!field f=foo_s}asdf"
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|req
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|testQueryRaw
specifier|public
name|void
name|testQueryRaw
parameter_list|()
throws|throws
name|Exception
block|{
name|SolrQueryRequest
name|req
init|=
name|req
argument_list|(
literal|"myField"
argument_list|,
literal|"foo_s"
argument_list|)
decl_stmt|;
try|try
block|{
name|assertQueryEquals
argument_list|(
literal|"raw"
argument_list|,
name|req
argument_list|,
literal|"{!raw f=$myField}asdf"
argument_list|,
literal|"{!raw f=$myField v=asdf}"
argument_list|,
literal|"{!raw f=foo_s}asdf"
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|req
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|testQueryTerm
specifier|public
name|void
name|testQueryTerm
parameter_list|()
throws|throws
name|Exception
block|{
name|SolrQueryRequest
name|req
init|=
name|req
argument_list|(
literal|"myField"
argument_list|,
literal|"foo_s"
argument_list|)
decl_stmt|;
try|try
block|{
name|assertQueryEquals
argument_list|(
literal|"term"
argument_list|,
name|req
argument_list|,
literal|"{!term f=$myField}asdf"
argument_list|,
literal|"{!term f=$myField v=asdf}"
argument_list|,
literal|"{!term f=foo_s}asdf"
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|req
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|testQueryCollapse
specifier|public
name|void
name|testQueryCollapse
parameter_list|()
throws|throws
name|Exception
block|{
name|SolrQueryRequest
name|req
init|=
name|req
argument_list|(
literal|"myField"
argument_list|,
literal|"foo_s"
argument_list|)
decl_stmt|;
try|try
block|{
name|assertQueryEquals
argument_list|(
literal|"collapse"
argument_list|,
name|req
argument_list|,
literal|"{!collapse field=$myField}"
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|req
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|testQueryNested
specifier|public
name|void
name|testQueryNested
parameter_list|()
throws|throws
name|Exception
block|{
name|SolrQueryRequest
name|req
init|=
name|req
argument_list|(
literal|"df"
argument_list|,
literal|"foo_s"
argument_list|)
decl_stmt|;
try|try
block|{
name|assertQueryEquals
argument_list|(
literal|"query"
argument_list|,
name|req
argument_list|,
literal|"{!query defType=lucene}asdf"
argument_list|,
literal|"{!query v='foo_s:asdf'}"
argument_list|,
literal|"{!query}foo_s:asdf"
argument_list|,
literal|"{!query}asdf"
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|req
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|testQueryFunc
specifier|public
name|void
name|testQueryFunc
parameter_list|()
throws|throws
name|Exception
block|{
comment|// more involved tests of specific functions in other methods
name|SolrQueryRequest
name|req
init|=
name|req
argument_list|(
literal|"myVar"
argument_list|,
literal|"5"
argument_list|,
literal|"myField"
argument_list|,
literal|"foo_i"
argument_list|,
literal|"myInner"
argument_list|,
literal|"product(4,foo_i)"
argument_list|)
decl_stmt|;
try|try
block|{
name|assertQueryEquals
argument_list|(
literal|"func"
argument_list|,
name|req
argument_list|,
literal|"{!func}sum(4,5)"
argument_list|,
literal|"{!func}sum(4,$myVar)"
argument_list|,
literal|"sum(4,5)"
argument_list|)
expr_stmt|;
name|assertQueryEquals
argument_list|(
literal|"func"
argument_list|,
name|req
argument_list|,
literal|"{!func}sum(1,2,3,4,5)"
argument_list|,
literal|"{!func}sum(1,2,3,4,$myVar)"
argument_list|,
literal|"sum(1,2,3,4,5)"
argument_list|)
expr_stmt|;
name|assertQueryEquals
argument_list|(
literal|"func"
argument_list|,
name|req
argument_list|,
literal|"{!func}sum(4,$myInner)"
argument_list|,
literal|"{!func}sum(4,product(4,foo_i))"
argument_list|,
literal|"{!func}sum(4,product(4,$myField))"
argument_list|,
literal|"{!func}sum(4,product(4,field(foo_i)))"
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|req
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|testQueryFrange
specifier|public
name|void
name|testQueryFrange
parameter_list|()
throws|throws
name|Exception
block|{
name|SolrQueryRequest
name|req
init|=
name|req
argument_list|(
literal|"myVar"
argument_list|,
literal|"5"
argument_list|,
literal|"low"
argument_list|,
literal|"0.2"
argument_list|,
literal|"high"
argument_list|,
literal|"20.4"
argument_list|,
literal|"myField"
argument_list|,
literal|"foo_i"
argument_list|,
literal|"myInner"
argument_list|,
literal|"product(4,foo_i)"
argument_list|)
decl_stmt|;
try|try
block|{
name|assertQueryEquals
argument_list|(
literal|"frange"
argument_list|,
name|req
argument_list|,
literal|"{!frange l=0.2 h=20.4}sum(4,5)"
argument_list|,
literal|"{!frange l=$low h=$high}sum(4,$myVar)"
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|req
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|testQueryGeofilt
specifier|public
name|void
name|testQueryGeofilt
parameter_list|()
throws|throws
name|Exception
block|{
name|checkQuerySpatial
argument_list|(
literal|"geofilt"
argument_list|)
expr_stmt|;
block|}
DECL|method|testQueryBbox
specifier|public
name|void
name|testQueryBbox
parameter_list|()
throws|throws
name|Exception
block|{
name|checkQuerySpatial
argument_list|(
literal|"bbox"
argument_list|)
expr_stmt|;
block|}
DECL|method|checkQuerySpatial
specifier|private
name|void
name|checkQuerySpatial
parameter_list|(
specifier|final
name|String
name|type
parameter_list|)
throws|throws
name|Exception
block|{
name|SolrQueryRequest
name|req
init|=
name|req
argument_list|(
literal|"myVar"
argument_list|,
literal|"5"
argument_list|,
literal|"d"
argument_list|,
literal|"109"
argument_list|,
literal|"pt"
argument_list|,
literal|"10.312,-20.556"
argument_list|,
literal|"sfield"
argument_list|,
literal|"store"
argument_list|)
decl_stmt|;
try|try
block|{
name|assertQueryEquals
argument_list|(
name|type
argument_list|,
name|req
argument_list|,
literal|"{!"
operator|+
name|type
operator|+
literal|" d=109}"
argument_list|,
literal|"{!"
operator|+
name|type
operator|+
literal|" sfield=$sfield}"
argument_list|,
literal|"{!"
operator|+
name|type
operator|+
literal|" sfield=store d=109}"
argument_list|,
literal|"{!"
operator|+
name|type
operator|+
literal|" sfield=store d=$d pt=$pt}"
argument_list|,
literal|"{!"
operator|+
name|type
operator|+
literal|" sfield=store d=$d pt=10.312,-20.556}"
argument_list|,
literal|"{!"
operator|+
name|type
operator|+
literal|"}"
argument_list|)
expr_stmt|;
comment|// diff SpatialQueryable FieldTypes matter for determining final query
name|assertQueryEquals
argument_list|(
name|type
argument_list|,
name|req
argument_list|,
literal|"{!"
operator|+
name|type
operator|+
literal|" sfield=point_hash}"
argument_list|,
literal|"{!"
operator|+
name|type
operator|+
literal|" sfield=point_hash d=109}"
argument_list|,
literal|"{!"
operator|+
name|type
operator|+
literal|" sfield=point_hash d=$d pt=$pt}"
argument_list|,
literal|"{!"
operator|+
name|type
operator|+
literal|" sfield=point_hash d=$d pt=10.312,-20.556}"
argument_list|)
expr_stmt|;
name|assertQueryEquals
argument_list|(
name|type
argument_list|,
name|req
argument_list|,
literal|"{!"
operator|+
name|type
operator|+
literal|" sfield=point}"
argument_list|,
literal|"{!"
operator|+
name|type
operator|+
literal|" sfield=point d=109}"
argument_list|,
literal|"{!"
operator|+
name|type
operator|+
literal|" sfield=point d=$d pt=$pt}"
argument_list|,
literal|"{!"
operator|+
name|type
operator|+
literal|" sfield=point d=$d pt=10.312,-20.556}"
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|req
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|testQueryJoin
specifier|public
name|void
name|testQueryJoin
parameter_list|()
throws|throws
name|Exception
block|{
name|SolrQueryRequest
name|req
init|=
name|req
argument_list|(
literal|"myVar"
argument_list|,
literal|"5"
argument_list|,
literal|"df"
argument_list|,
literal|"text"
argument_list|,
literal|"ff"
argument_list|,
literal|"foo_s"
argument_list|,
literal|"tt"
argument_list|,
literal|"bar_s"
argument_list|)
decl_stmt|;
try|try
block|{
name|assertQueryEquals
argument_list|(
literal|"join"
argument_list|,
name|req
argument_list|,
literal|"{!join from=foo_s to=bar_s}asdf"
argument_list|,
literal|"{!join from=$ff to=$tt}asdf"
argument_list|,
literal|"{!join from=$ff to='bar_s'}text:asdf"
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|req
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|testBlockJoin
specifier|public
name|void
name|testBlockJoin
parameter_list|()
throws|throws
name|Exception
block|{
name|assertQueryEquals
argument_list|(
literal|"parent"
argument_list|,
literal|"{!parent which=foo_s:parent}dude"
argument_list|,
literal|"{!parent which=foo_s:parent}dude"
argument_list|)
expr_stmt|;
name|assertQueryEquals
argument_list|(
literal|"child"
argument_list|,
literal|"{!child of=foo_s:parent}dude"
argument_list|,
literal|"{!child of=foo_s:parent}dude"
argument_list|)
expr_stmt|;
block|}
DECL|method|testQuerySurround
specifier|public
name|void
name|testQuerySurround
parameter_list|()
throws|throws
name|Exception
block|{
name|assertQueryEquals
argument_list|(
literal|"surround"
argument_list|,
literal|"{!surround}and(apache,solr)"
argument_list|,
literal|"and(apache,solr)"
argument_list|,
literal|"apache AND solr"
argument_list|)
expr_stmt|;
block|}
DECL|method|testFuncTestfunc
specifier|public
name|void
name|testFuncTestfunc
parameter_list|()
throws|throws
name|Exception
block|{
name|assertFuncEquals
argument_list|(
literal|"testfunc(foo_i)"
argument_list|,
literal|"testfunc(field(foo_i))"
argument_list|)
expr_stmt|;
name|assertFuncEquals
argument_list|(
literal|"testfunc(23)"
argument_list|)
expr_stmt|;
name|assertFuncEquals
argument_list|(
literal|"testfunc(sum(23,foo_i))"
argument_list|,
literal|"testfunc(sum(23,field(foo_i)))"
argument_list|)
expr_stmt|;
block|}
DECL|method|testFuncOrd
specifier|public
name|void
name|testFuncOrd
parameter_list|()
throws|throws
name|Exception
block|{
name|assertFuncEquals
argument_list|(
literal|"ord(foo_s)"
argument_list|,
literal|"ord(foo_s    )"
argument_list|)
expr_stmt|;
block|}
DECL|method|testFuncLiteral
specifier|public
name|void
name|testFuncLiteral
parameter_list|()
throws|throws
name|Exception
block|{
name|SolrQueryRequest
name|req
init|=
name|req
argument_list|(
literal|"someVar"
argument_list|,
literal|"a string"
argument_list|)
decl_stmt|;
try|try
block|{
name|assertFuncEquals
argument_list|(
name|req
argument_list|,
literal|"literal('a string')"
argument_list|,
literal|"literal(\"a string\")"
argument_list|,
literal|"literal($someVar)"
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|req
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|testFuncRord
specifier|public
name|void
name|testFuncRord
parameter_list|()
throws|throws
name|Exception
block|{
name|assertFuncEquals
argument_list|(
literal|"rord(foo_s)"
argument_list|,
literal|"rord(foo_s    )"
argument_list|)
expr_stmt|;
block|}
DECL|method|testFuncTop
specifier|public
name|void
name|testFuncTop
parameter_list|()
throws|throws
name|Exception
block|{
name|assertFuncEquals
argument_list|(
literal|"top(sum(3,foo_i))"
argument_list|)
expr_stmt|;
block|}
DECL|method|testFuncLinear
specifier|public
name|void
name|testFuncLinear
parameter_list|()
throws|throws
name|Exception
block|{
name|SolrQueryRequest
name|req
init|=
name|req
argument_list|(
literal|"someVar"
argument_list|,
literal|"27"
argument_list|)
decl_stmt|;
try|try
block|{
name|assertFuncEquals
argument_list|(
name|req
argument_list|,
literal|"linear(foo_i,$someVar,42)"
argument_list|,
literal|"linear(foo_i,   27,   42)"
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|req
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|testFuncRecip
specifier|public
name|void
name|testFuncRecip
parameter_list|()
throws|throws
name|Exception
block|{
name|SolrQueryRequest
name|req
init|=
name|req
argument_list|(
literal|"someVar"
argument_list|,
literal|"27"
argument_list|)
decl_stmt|;
try|try
block|{
name|assertFuncEquals
argument_list|(
name|req
argument_list|,
literal|"recip(foo_i,$someVar,42,   27   )"
argument_list|,
literal|"recip(foo_i,   27,   42,$someVar)"
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|req
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|testFuncScale
specifier|public
name|void
name|testFuncScale
parameter_list|()
throws|throws
name|Exception
block|{
name|SolrQueryRequest
name|req
init|=
name|req
argument_list|(
literal|"someVar"
argument_list|,
literal|"27"
argument_list|)
decl_stmt|;
try|try
block|{
name|assertFuncEquals
argument_list|(
name|req
argument_list|,
literal|"scale(field(foo_i),$someVar,42)"
argument_list|,
literal|"scale(foo_i, 27, 42)"
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|req
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|testFuncDiv
specifier|public
name|void
name|testFuncDiv
parameter_list|()
throws|throws
name|Exception
block|{
name|assertFuncEquals
argument_list|(
literal|"div(5,4)"
argument_list|,
literal|"div(5, 4)"
argument_list|)
expr_stmt|;
name|assertFuncEquals
argument_list|(
literal|"div(foo_i,4)"
argument_list|,
literal|"div(foo_i, 4)"
argument_list|,
literal|"div(field('foo_i'), 4)"
argument_list|)
expr_stmt|;
name|assertFuncEquals
argument_list|(
literal|"div(foo_i,sub(4,field('bar_i')))"
argument_list|,
literal|"div(field(foo_i), sub(4,bar_i))"
argument_list|)
expr_stmt|;
block|}
DECL|method|testFuncMod
specifier|public
name|void
name|testFuncMod
parameter_list|()
throws|throws
name|Exception
block|{
name|assertFuncEquals
argument_list|(
literal|"mod(5,4)"
argument_list|,
literal|"mod(5, 4)"
argument_list|)
expr_stmt|;
name|assertFuncEquals
argument_list|(
literal|"mod(foo_i,4)"
argument_list|,
literal|"mod(foo_i, 4)"
argument_list|,
literal|"mod(field('foo_i'), 4)"
argument_list|)
expr_stmt|;
name|assertFuncEquals
argument_list|(
literal|"mod(foo_i,sub(4,field('bar_i')))"
argument_list|,
literal|"mod(field(foo_i), sub(4,bar_i))"
argument_list|)
expr_stmt|;
block|}
DECL|method|testFuncMap
specifier|public
name|void
name|testFuncMap
parameter_list|()
throws|throws
name|Exception
block|{
name|assertFuncEquals
argument_list|(
literal|"map(field(foo_i), 0, 45, 100)"
argument_list|,
literal|"map(foo_i, 0.0, 45, 100)"
argument_list|)
expr_stmt|;
block|}
DECL|method|testFuncSum
specifier|public
name|void
name|testFuncSum
parameter_list|()
throws|throws
name|Exception
block|{
name|assertFuncEquals
argument_list|(
literal|"sum(5,4)"
argument_list|,
literal|"add(5, 4)"
argument_list|)
expr_stmt|;
name|assertFuncEquals
argument_list|(
literal|"sum(5,4,3,2,1)"
argument_list|,
literal|"add(5, 4, 3, 2, 1)"
argument_list|)
expr_stmt|;
name|assertFuncEquals
argument_list|(
literal|"sum(foo_i,4)"
argument_list|,
literal|"sum(foo_i, 4)"
argument_list|,
literal|"sum(field('foo_i'), 4)"
argument_list|)
expr_stmt|;
name|assertFuncEquals
argument_list|(
literal|"add(foo_i,sub(4,field('bar_i')))"
argument_list|,
literal|"sum(field(foo_i), sub(4,bar_i))"
argument_list|)
expr_stmt|;
block|}
DECL|method|testFuncProduct
specifier|public
name|void
name|testFuncProduct
parameter_list|()
throws|throws
name|Exception
block|{
name|assertFuncEquals
argument_list|(
literal|"product(5,4,3,2,1)"
argument_list|,
literal|"mul(5, 4, 3, 2, 1)"
argument_list|)
expr_stmt|;
name|assertFuncEquals
argument_list|(
literal|"product(5,4)"
argument_list|,
literal|"mul(5, 4)"
argument_list|)
expr_stmt|;
name|assertFuncEquals
argument_list|(
literal|"product(foo_i,4)"
argument_list|,
literal|"product(foo_i, 4)"
argument_list|,
literal|"product(field('foo_i'), 4)"
argument_list|)
expr_stmt|;
name|assertFuncEquals
argument_list|(
literal|"mul(foo_i,sub(4,field('bar_i')))"
argument_list|,
literal|"product(field(foo_i), sub(4,bar_i))"
argument_list|)
expr_stmt|;
block|}
DECL|method|testFuncSub
specifier|public
name|void
name|testFuncSub
parameter_list|()
throws|throws
name|Exception
block|{
name|assertFuncEquals
argument_list|(
literal|"sub(5,4)"
argument_list|,
literal|"sub(5, 4)"
argument_list|)
expr_stmt|;
name|assertFuncEquals
argument_list|(
literal|"sub(foo_i,4)"
argument_list|,
literal|"sub(foo_i, 4)"
argument_list|)
expr_stmt|;
name|assertFuncEquals
argument_list|(
literal|"sub(foo_i,sum(4,bar_i))"
argument_list|,
literal|"sub(foo_i, sum(4,bar_i))"
argument_list|)
expr_stmt|;
block|}
DECL|method|testFuncVector
specifier|public
name|void
name|testFuncVector
parameter_list|()
throws|throws
name|Exception
block|{
name|assertFuncEquals
argument_list|(
literal|"vector(5,4, field(foo_i))"
argument_list|,
literal|"vector(5, 4, foo_i)"
argument_list|)
expr_stmt|;
name|assertFuncEquals
argument_list|(
literal|"vector(foo_i,4)"
argument_list|,
literal|"vector(foo_i, 4)"
argument_list|)
expr_stmt|;
name|assertFuncEquals
argument_list|(
literal|"vector(foo_i,sum(4,bar_i))"
argument_list|,
literal|"vector(foo_i, sum(4,bar_i))"
argument_list|)
expr_stmt|;
block|}
DECL|method|testFuncQuery
specifier|public
name|void
name|testFuncQuery
parameter_list|()
throws|throws
name|Exception
block|{
name|SolrQueryRequest
name|req
init|=
name|req
argument_list|(
literal|"myQ"
argument_list|,
literal|"asdf"
argument_list|)
decl_stmt|;
try|try
block|{
name|assertFuncEquals
argument_list|(
name|req
argument_list|,
literal|"query($myQ)"
argument_list|,
literal|"query($myQ,0)"
argument_list|,
literal|"query({!lucene v=$myQ},0)"
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|req
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|testFuncBoost
specifier|public
name|void
name|testFuncBoost
parameter_list|()
throws|throws
name|Exception
block|{
name|SolrQueryRequest
name|req
init|=
name|req
argument_list|(
literal|"myQ"
argument_list|,
literal|"asdf"
argument_list|)
decl_stmt|;
try|try
block|{
name|assertFuncEquals
argument_list|(
name|req
argument_list|,
literal|"boost($myQ,sum(4,5))"
argument_list|,
literal|"boost({!lucene v=$myQ},sum(4,5))"
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|req
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|testFuncJoindf
specifier|public
name|void
name|testFuncJoindf
parameter_list|()
throws|throws
name|Exception
block|{
name|assertFuncEquals
argument_list|(
literal|"joindf(foo,bar)"
argument_list|)
expr_stmt|;
block|}
DECL|method|testFuncGeodist
specifier|public
name|void
name|testFuncGeodist
parameter_list|()
throws|throws
name|Exception
block|{
name|SolrQueryRequest
name|req
init|=
name|req
argument_list|(
literal|"pt"
argument_list|,
literal|"10.312,-20.556"
argument_list|,
literal|"sfield"
argument_list|,
literal|"store"
argument_list|)
decl_stmt|;
try|try
block|{
name|assertFuncEquals
argument_list|(
name|req
argument_list|,
literal|"geodist()"
argument_list|,
literal|"geodist($sfield,$pt)"
argument_list|,
literal|"geodist(store,$pt)"
argument_list|,
literal|"geodist(field(store),$pt)"
argument_list|,
literal|"geodist(store,10.312,-20.556)"
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|req
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|testFuncHsin
specifier|public
name|void
name|testFuncHsin
parameter_list|()
throws|throws
name|Exception
block|{
name|assertFuncEquals
argument_list|(
literal|"hsin(45,true,0,0,45,45)"
argument_list|)
expr_stmt|;
block|}
DECL|method|testFuncGhhsin
specifier|public
name|void
name|testFuncGhhsin
parameter_list|()
throws|throws
name|Exception
block|{
name|assertFuncEquals
argument_list|(
literal|"ghhsin(45,point_hash,'asdf')"
argument_list|,
literal|"ghhsin(45,field(point_hash),'asdf')"
argument_list|)
expr_stmt|;
block|}
DECL|method|testFuncGeohash
specifier|public
name|void
name|testFuncGeohash
parameter_list|()
throws|throws
name|Exception
block|{
name|assertFuncEquals
argument_list|(
literal|"geohash(45,99)"
argument_list|)
expr_stmt|;
block|}
DECL|method|testFuncDist
specifier|public
name|void
name|testFuncDist
parameter_list|()
throws|throws
name|Exception
block|{
name|assertFuncEquals
argument_list|(
literal|"dist(2,45,99,101,111)"
argument_list|,
literal|"dist(2,vector(45,99),vector(101,111))"
argument_list|)
expr_stmt|;
block|}
DECL|method|testFuncSqedist
specifier|public
name|void
name|testFuncSqedist
parameter_list|()
throws|throws
name|Exception
block|{
name|assertFuncEquals
argument_list|(
literal|"sqedist(45,99,101,111)"
argument_list|,
literal|"sqedist(vector(45,99),vector(101,111))"
argument_list|)
expr_stmt|;
block|}
DECL|method|testFuncMin
specifier|public
name|void
name|testFuncMin
parameter_list|()
throws|throws
name|Exception
block|{
name|assertFuncEquals
argument_list|(
literal|"min(5,4,3,2,1)"
argument_list|,
literal|"min(5, 4, 3, 2, 1)"
argument_list|)
expr_stmt|;
name|assertFuncEquals
argument_list|(
literal|"min(foo_i,4)"
argument_list|,
literal|"min(field('foo_i'), 4)"
argument_list|)
expr_stmt|;
name|assertFuncEquals
argument_list|(
literal|"min(foo_i,sub(4,field('bar_i')))"
argument_list|,
literal|"min(field(foo_i), sub(4,bar_i))"
argument_list|)
expr_stmt|;
block|}
DECL|method|testFuncMax
specifier|public
name|void
name|testFuncMax
parameter_list|()
throws|throws
name|Exception
block|{
name|assertFuncEquals
argument_list|(
literal|"max(5,4,3,2,1)"
argument_list|,
literal|"max(5, 4, 3, 2, 1)"
argument_list|)
expr_stmt|;
name|assertFuncEquals
argument_list|(
literal|"max(foo_i,4)"
argument_list|,
literal|"max(field('foo_i'), 4)"
argument_list|)
expr_stmt|;
name|assertFuncEquals
argument_list|(
literal|"max(foo_i,sub(4,field('bar_i')))"
argument_list|,
literal|"max(field(foo_i), sub(4,bar_i))"
argument_list|)
expr_stmt|;
block|}
DECL|method|testFuncMs
specifier|public
name|void
name|testFuncMs
parameter_list|()
throws|throws
name|Exception
block|{
comment|// Note ms() takes in field name, not field(...)
name|assertFuncEquals
argument_list|(
literal|"ms()"
argument_list|,
literal|"ms(NOW)"
argument_list|)
expr_stmt|;
name|assertFuncEquals
argument_list|(
literal|"ms(2000-01-01T00:00:00Z)"
argument_list|,
literal|"ms('2000-01-01T00:00:00Z')"
argument_list|)
expr_stmt|;
name|assertFuncEquals
argument_list|(
literal|"ms(myDateField_dt)"
argument_list|,
literal|"ms('myDateField_dt')"
argument_list|)
expr_stmt|;
name|assertFuncEquals
argument_list|(
literal|"ms(2000-01-01T00:00:00Z,myDateField_dt)"
argument_list|,
literal|"ms('2000-01-01T00:00:00Z','myDateField_dt')"
argument_list|)
expr_stmt|;
name|assertFuncEquals
argument_list|(
literal|"ms(myDateField_dt, NOW)"
argument_list|,
literal|"ms('myDateField_dt', NOW)"
argument_list|)
expr_stmt|;
block|}
DECL|method|testFuncMathConsts
specifier|public
name|void
name|testFuncMathConsts
parameter_list|()
throws|throws
name|Exception
block|{
name|assertFuncEquals
argument_list|(
literal|"pi()"
argument_list|)
expr_stmt|;
name|assertFuncEquals
argument_list|(
literal|"e()"
argument_list|)
expr_stmt|;
block|}
DECL|method|testFuncTerms
specifier|public
name|void
name|testFuncTerms
parameter_list|()
throws|throws
name|Exception
block|{
name|SolrQueryRequest
name|req
init|=
name|req
argument_list|(
literal|"myField"
argument_list|,
literal|"field_t"
argument_list|,
literal|"myTerm"
argument_list|,
literal|"my term"
argument_list|)
decl_stmt|;
try|try
block|{
for|for
control|(
specifier|final
name|String
name|type
range|:
operator|new
name|String
index|[]
block|{
literal|"docfreq"
block|,
literal|"termfreq"
block|,
literal|"totaltermfreq"
block|,
literal|"ttf"
block|,
literal|"idf"
block|,
literal|"tf"
block|}
control|)
block|{
comment|// NOTE: these functions takes a field *name* not a field(..) source
name|assertFuncEquals
argument_list|(
name|req
argument_list|,
name|type
operator|+
literal|"('field_t','my term')"
argument_list|,
name|type
operator|+
literal|"(field_t,'my term')"
argument_list|,
name|type
operator|+
literal|"(field_t,$myTerm)"
argument_list|,
name|type
operator|+
literal|"(field_t,$myTerm)"
argument_list|,
name|type
operator|+
literal|"($myField,$myTerm)"
argument_list|)
expr_stmt|;
block|}
comment|// ttf is an alias for totaltermfreq
name|assertFuncEquals
argument_list|(
name|req
argument_list|,
literal|"ttf(field_t,'my term')"
argument_list|,
literal|"ttf('field_t','my term')"
argument_list|,
literal|"totaltermfreq(field_t,'my term')"
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|req
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|testFuncSttf
specifier|public
name|void
name|testFuncSttf
parameter_list|()
throws|throws
name|Exception
block|{
comment|// sttf is an alias for sumtotaltermfreq
name|assertFuncEquals
argument_list|(
literal|"sttf(foo_t)"
argument_list|,
literal|"sttf('foo_t')"
argument_list|,
literal|"sumtotaltermfreq(foo_t)"
argument_list|,
literal|"sumtotaltermfreq('foo_t')"
argument_list|)
expr_stmt|;
name|assertFuncEquals
argument_list|(
literal|"sumtotaltermfreq('foo_t')"
argument_list|)
expr_stmt|;
block|}
DECL|method|testFuncNorm
specifier|public
name|void
name|testFuncNorm
parameter_list|()
throws|throws
name|Exception
block|{
name|assertFuncEquals
argument_list|(
literal|"norm(foo_t)"
argument_list|,
literal|"norm('foo_t')"
argument_list|)
expr_stmt|;
block|}
DECL|method|testFuncMaxdoc
specifier|public
name|void
name|testFuncMaxdoc
parameter_list|()
throws|throws
name|Exception
block|{
name|assertFuncEquals
argument_list|(
literal|"maxdoc()"
argument_list|)
expr_stmt|;
block|}
DECL|method|testFuncNumdocs
specifier|public
name|void
name|testFuncNumdocs
parameter_list|()
throws|throws
name|Exception
block|{
name|assertFuncEquals
argument_list|(
literal|"numdocs()"
argument_list|)
expr_stmt|;
block|}
DECL|method|testFuncBools
specifier|public
name|void
name|testFuncBools
parameter_list|()
throws|throws
name|Exception
block|{
name|SolrQueryRequest
name|req
init|=
name|req
argument_list|(
literal|"myTrue"
argument_list|,
literal|"true"
argument_list|,
literal|"myFalse"
argument_list|,
literal|"false"
argument_list|)
decl_stmt|;
try|try
block|{
name|assertFuncEquals
argument_list|(
name|req
argument_list|,
literal|"true"
argument_list|,
literal|"$myTrue"
argument_list|)
expr_stmt|;
name|assertFuncEquals
argument_list|(
name|req
argument_list|,
literal|"false"
argument_list|,
literal|"$myFalse"
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|req
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|testFuncExists
specifier|public
name|void
name|testFuncExists
parameter_list|()
throws|throws
name|Exception
block|{
name|SolrQueryRequest
name|req
init|=
name|req
argument_list|(
literal|"myField"
argument_list|,
literal|"field_t"
argument_list|,
literal|"myQ"
argument_list|,
literal|"asdf"
argument_list|)
decl_stmt|;
try|try
block|{
name|assertFuncEquals
argument_list|(
name|req
argument_list|,
literal|"exists(field_t)"
argument_list|,
literal|"exists($myField)"
argument_list|,
literal|"exists(field('field_t'))"
argument_list|,
literal|"exists(field($myField))"
argument_list|)
expr_stmt|;
name|assertFuncEquals
argument_list|(
name|req
argument_list|,
literal|"exists(query($myQ))"
argument_list|,
literal|"exists(query({!lucene v=$myQ}))"
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|req
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|testFuncNot
specifier|public
name|void
name|testFuncNot
parameter_list|()
throws|throws
name|Exception
block|{
name|SolrQueryRequest
name|req
init|=
name|req
argument_list|(
literal|"myField"
argument_list|,
literal|"field_b"
argument_list|,
literal|"myTrue"
argument_list|,
literal|"true"
argument_list|)
decl_stmt|;
try|try
block|{
name|assertFuncEquals
argument_list|(
name|req
argument_list|,
literal|"not(true)"
argument_list|,
literal|"not($myTrue)"
argument_list|)
expr_stmt|;
name|assertFuncEquals
argument_list|(
name|req
argument_list|,
literal|"not(not(true))"
argument_list|,
literal|"not(not($myTrue))"
argument_list|)
expr_stmt|;
name|assertFuncEquals
argument_list|(
name|req
argument_list|,
literal|"not(field_b)"
argument_list|,
literal|"not($myField)"
argument_list|,
literal|"not(field('field_b'))"
argument_list|,
literal|"not(field($myField))"
argument_list|)
expr_stmt|;
name|assertFuncEquals
argument_list|(
name|req
argument_list|,
literal|"not(exists(field_b))"
argument_list|,
literal|"not(exists($myField))"
argument_list|,
literal|"not(exists(field('field_b')))"
argument_list|,
literal|"not(exists(field($myField)))"
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|req
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|testFuncDoubleValueBools
specifier|public
name|void
name|testFuncDoubleValueBools
parameter_list|()
throws|throws
name|Exception
block|{
name|SolrQueryRequest
name|req
init|=
name|req
argument_list|(
literal|"myField"
argument_list|,
literal|"field_b"
argument_list|,
literal|"myTrue"
argument_list|,
literal|"true"
argument_list|)
decl_stmt|;
try|try
block|{
for|for
control|(
specifier|final
name|String
name|type
range|:
operator|new
name|String
index|[]
block|{
literal|"and"
block|,
literal|"or"
block|,
literal|"xor"
block|}
control|)
block|{
name|assertFuncEquals
argument_list|(
name|req
argument_list|,
name|type
operator|+
literal|"(field_b,true)"
argument_list|,
name|type
operator|+
literal|"(field_b,$myTrue)"
argument_list|,
name|type
operator|+
literal|"(field('field_b'),true)"
argument_list|,
name|type
operator|+
literal|"(field($myField),$myTrue)"
argument_list|,
name|type
operator|+
literal|"($myField,$myTrue)"
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|req
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|testFuncIf
specifier|public
name|void
name|testFuncIf
parameter_list|()
throws|throws
name|Exception
block|{
name|SolrQueryRequest
name|req
init|=
name|req
argument_list|(
literal|"myBoolField"
argument_list|,
literal|"foo_b"
argument_list|,
literal|"myIntField"
argument_list|,
literal|"bar_i"
argument_list|,
literal|"myTrue"
argument_list|,
literal|"true"
argument_list|)
decl_stmt|;
try|try
block|{
name|assertFuncEquals
argument_list|(
name|req
argument_list|,
literal|"if(foo_b,bar_i,25)"
argument_list|,
literal|"if($myBoolField,bar_i,25)"
argument_list|,
literal|"if(field('foo_b'),$myIntField,25)"
argument_list|,
literal|"if(field($myBoolField),field('bar_i'),25)"
argument_list|)
expr_stmt|;
name|assertFuncEquals
argument_list|(
name|req
argument_list|,
literal|"if(true,37,field($myIntField))"
argument_list|,
literal|"if($myTrue,37,$myIntField)"
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|req
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|testFuncDef
specifier|public
name|void
name|testFuncDef
parameter_list|()
throws|throws
name|Exception
block|{
name|SolrQueryRequest
name|req
init|=
name|req
argument_list|(
literal|"myField"
argument_list|,
literal|"bar_f"
argument_list|)
decl_stmt|;
try|try
block|{
name|assertFuncEquals
argument_list|(
name|req
argument_list|,
literal|"def(bar_f,25)"
argument_list|,
literal|"def($myField,25)"
argument_list|,
literal|"def(field('bar_f'),25)"
argument_list|)
expr_stmt|;
name|assertFuncEquals
argument_list|(
name|req
argument_list|,
literal|"def(ceil(bar_f),25)"
argument_list|,
literal|"def(ceil($myField),25)"
argument_list|,
literal|"def(ceil(field('bar_f')),25)"
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|req
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|testFuncSingleValueMathFuncs
specifier|public
name|void
name|testFuncSingleValueMathFuncs
parameter_list|()
throws|throws
name|Exception
block|{
name|SolrQueryRequest
name|req
init|=
name|req
argument_list|(
literal|"myVal"
argument_list|,
literal|"45"
argument_list|,
literal|"myField"
argument_list|,
literal|"foo_i"
argument_list|)
decl_stmt|;
for|for
control|(
specifier|final
name|String
name|func
range|:
operator|new
name|String
index|[]
block|{
literal|"abs"
block|,
literal|"rad"
block|,
literal|"deg"
block|,
literal|"sqrt"
block|,
literal|"cbrt"
block|,
literal|"log"
block|,
literal|"ln"
block|,
literal|"exp"
block|,
literal|"sin"
block|,
literal|"cos"
block|,
literal|"tan"
block|,
literal|"asin"
block|,
literal|"acos"
block|,
literal|"atan"
block|,
literal|"sinh"
block|,
literal|"cosh"
block|,
literal|"tanh"
block|,
literal|"ceil"
block|,
literal|"floor"
block|,
literal|"rint"
block|}
control|)
block|{
try|try
block|{
name|assertFuncEquals
argument_list|(
name|req
argument_list|,
name|func
operator|+
literal|"(field(foo_i))"
argument_list|,
name|func
operator|+
literal|"(foo_i)"
argument_list|,
name|func
operator|+
literal|"($myField)"
argument_list|)
expr_stmt|;
name|assertFuncEquals
argument_list|(
name|req
argument_list|,
name|func
operator|+
literal|"(45)"
argument_list|,
name|func
operator|+
literal|"($myVal)"
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|req
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
block|}
DECL|method|testFuncDoubleValueMathFuncs
specifier|public
name|void
name|testFuncDoubleValueMathFuncs
parameter_list|()
throws|throws
name|Exception
block|{
name|SolrQueryRequest
name|req
init|=
name|req
argument_list|(
literal|"myVal"
argument_list|,
literal|"45"
argument_list|,
literal|"myOtherVal"
argument_list|,
literal|"27"
argument_list|,
literal|"myField"
argument_list|,
literal|"foo_i"
argument_list|)
decl_stmt|;
for|for
control|(
specifier|final
name|String
name|func
range|:
operator|new
name|String
index|[]
block|{
literal|"pow"
block|,
literal|"hypot"
block|,
literal|"atan2"
block|}
control|)
block|{
try|try
block|{
name|assertFuncEquals
argument_list|(
name|req
argument_list|,
name|func
operator|+
literal|"(field(foo_i),$myVal)"
argument_list|,
name|func
operator|+
literal|"(foo_i,$myVal)"
argument_list|,
name|func
operator|+
literal|"($myField,45)"
argument_list|)
expr_stmt|;
name|assertFuncEquals
argument_list|(
name|req
argument_list|,
name|func
operator|+
literal|"(45,$myOtherVal)"
argument_list|,
name|func
operator|+
literal|"($myVal,27)"
argument_list|,
name|func
operator|+
literal|"($myVal,$myOtherVal)"
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|req
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
block|}
DECL|method|testFuncStrdist
specifier|public
name|void
name|testFuncStrdist
parameter_list|()
throws|throws
name|Exception
block|{
name|SolrQueryRequest
name|req
init|=
name|req
argument_list|(
literal|"myVal"
argument_list|,
literal|"zot"
argument_list|,
literal|"myOtherVal"
argument_list|,
literal|"yak"
argument_list|,
literal|"myField"
argument_list|,
literal|"foo_s1"
argument_list|)
decl_stmt|;
try|try
block|{
name|assertFuncEquals
argument_list|(
name|req
argument_list|,
literal|"strdist(\"zot\",literal('yak'),edit)"
argument_list|,
literal|"strdist(literal(\"zot\"),'yak',   edit  )"
argument_list|,
literal|"strdist(literal($myVal),literal($myOtherVal),edit)"
argument_list|)
expr_stmt|;
name|assertFuncEquals
argument_list|(
name|req
argument_list|,
literal|"strdist(\"zot\",literal($myOtherVal),ngram)"
argument_list|,
literal|"strdist(\"zot\",'yak', ngram, 2)"
argument_list|)
expr_stmt|;
name|assertFuncEquals
argument_list|(
name|req
argument_list|,
literal|"strdist(field('foo_s1'),literal($myOtherVal),jw)"
argument_list|,
literal|"strdist(field($myField),\"yak\",jw)"
argument_list|,
literal|"strdist($myField,'yak', jw)"
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|req
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|testFuncField
specifier|public
name|void
name|testFuncField
parameter_list|()
throws|throws
name|Exception
block|{
name|assertFuncEquals
argument_list|(
literal|"field(\"foo_i\")"
argument_list|,
literal|"field('foo_i\')"
argument_list|,
literal|"foo_i"
argument_list|)
expr_stmt|;
block|}
DECL|method|testFuncCurrency
specifier|public
name|void
name|testFuncCurrency
parameter_list|()
throws|throws
name|Exception
block|{
name|assertFuncEquals
argument_list|(
literal|"currency(\"amount\")"
argument_list|,
literal|"currency('amount\')"
argument_list|,
literal|"currency(amount)"
argument_list|,
literal|"currency(amount,USD)"
argument_list|,
literal|"currency('amount',USD)"
argument_list|)
expr_stmt|;
block|}
DECL|method|testTestFuncs
specifier|public
name|void
name|testTestFuncs
parameter_list|()
throws|throws
name|Exception
block|{
name|assertFuncEquals
argument_list|(
literal|"sleep(1,5)"
argument_list|,
literal|"sleep(1,5)"
argument_list|)
expr_stmt|;
name|assertFuncEquals
argument_list|(
literal|"threadid()"
argument_list|,
literal|"threadid()"
argument_list|)
expr_stmt|;
block|}
comment|// TODO: more tests
DECL|method|testQueryMaxScore
specifier|public
name|void
name|testQueryMaxScore
parameter_list|()
throws|throws
name|Exception
block|{
name|assertQueryEquals
argument_list|(
literal|"maxscore"
argument_list|,
literal|"{!maxscore}A OR B OR C"
argument_list|,
literal|"A OR B OR C"
argument_list|)
expr_stmt|;
name|assertQueryEquals
argument_list|(
literal|"maxscore"
argument_list|,
literal|"{!maxscore}A AND B"
argument_list|,
literal|"A AND B"
argument_list|)
expr_stmt|;
name|assertQueryEquals
argument_list|(
literal|"maxscore"
argument_list|,
literal|"{!maxscore}apache -solr"
argument_list|,
literal|"apache  -solr"
argument_list|,
literal|"apache -solr "
argument_list|)
expr_stmt|;
name|assertQueryEquals
argument_list|(
literal|"maxscore"
argument_list|,
literal|"+apache +solr"
argument_list|,
literal|"apache AND solr"
argument_list|,
literal|"+apache +solr"
argument_list|)
expr_stmt|;
block|}
comment|/**    * this test does not assert anything itself, it simply toggles a static     * boolean informing an @AfterClass method to assert that every default     * qparser and valuesource parser configured was recorded by     * assertQueryEquals and assertFuncEquals.    */
DECL|method|testParserCoverage
specifier|public
name|void
name|testParserCoverage
parameter_list|()
block|{
name|doAssertParserCoverage
operator|=
literal|true
expr_stmt|;
block|}
comment|/**    * NOTE: defType is not only used to pick the parser, but also to record     * the parser being tested for coverage sanity checking    * @see #testParserCoverage    * @see #assertQueryEquals    */
DECL|method|assertQueryEquals
specifier|protected
name|void
name|assertQueryEquals
parameter_list|(
specifier|final
name|String
name|defType
parameter_list|,
specifier|final
name|String
modifier|...
name|inputs
parameter_list|)
throws|throws
name|Exception
block|{
name|SolrQueryRequest
name|req
init|=
name|req
argument_list|()
decl_stmt|;
try|try
block|{
name|assertQueryEquals
argument_list|(
name|defType
argument_list|,
name|req
argument_list|,
name|inputs
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|req
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * NOTE: defType is not only used to pick the parser, but, if non-null it is     * also to record the parser being tested for coverage sanity checking    *    * @see QueryUtils#check    * @see QueryUtils#checkEqual    * @see #testParserCoverage    */
DECL|method|assertQueryEquals
specifier|protected
name|void
name|assertQueryEquals
parameter_list|(
specifier|final
name|String
name|defType
parameter_list|,
specifier|final
name|SolrQueryRequest
name|req
parameter_list|,
specifier|final
name|String
modifier|...
name|inputs
parameter_list|)
throws|throws
name|Exception
block|{
if|if
condition|(
literal|null
operator|!=
name|defType
condition|)
name|qParsersTested
operator|.
name|add
argument_list|(
name|defType
argument_list|)
expr_stmt|;
specifier|final
name|Query
index|[]
name|queries
init|=
operator|new
name|Query
index|[
name|inputs
operator|.
name|length
index|]
decl_stmt|;
try|try
block|{
name|SolrQueryResponse
name|rsp
init|=
operator|new
name|SolrQueryResponse
argument_list|()
decl_stmt|;
name|SolrRequestInfo
operator|.
name|setRequestInfo
argument_list|(
operator|new
name|SolrRequestInfo
argument_list|(
name|req
argument_list|,
name|rsp
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|inputs
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|queries
index|[
name|i
index|]
operator|=
operator|(
name|QParser
operator|.
name|getParser
argument_list|(
name|inputs
index|[
name|i
index|]
argument_list|,
name|defType
argument_list|,
name|req
argument_list|)
operator|.
name|getQuery
argument_list|()
operator|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|SolrRequestInfo
operator|.
name|clearRequestInfo
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|queries
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|QueryUtils
operator|.
name|check
argument_list|(
name|queries
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|// yes starting j=0 is redundent, we're making sure every query
comment|// is equal to itself, and that the quality checks work regardless
comment|// of which caller/callee is used.
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|queries
operator|.
name|length
condition|;
name|j
operator|++
control|)
block|{
name|QueryUtils
operator|.
name|checkEqual
argument_list|(
name|queries
index|[
name|i
index|]
argument_list|,
name|queries
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * the function name for val parser coverage checking is extracted from    * the first input    * @see #assertQueryEquals    * @see #testParserCoverage    */
DECL|method|assertFuncEquals
specifier|protected
name|void
name|assertFuncEquals
parameter_list|(
specifier|final
name|String
modifier|...
name|inputs
parameter_list|)
throws|throws
name|Exception
block|{
name|SolrQueryRequest
name|req
init|=
name|req
argument_list|()
decl_stmt|;
try|try
block|{
name|assertFuncEquals
argument_list|(
name|req
argument_list|,
name|inputs
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|req
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * the function name for val parser coverage checking is extracted from    * the first input    * @see #assertQueryEquals    * @see #testParserCoverage    */
DECL|method|assertFuncEquals
specifier|protected
name|void
name|assertFuncEquals
parameter_list|(
specifier|final
name|SolrQueryRequest
name|req
parameter_list|,
specifier|final
name|String
modifier|...
name|inputs
parameter_list|)
throws|throws
name|Exception
block|{
comment|// pull out the function name
specifier|final
name|String
name|funcName
init|=
operator|(
operator|new
name|QueryParsing
operator|.
name|StrParser
argument_list|(
name|inputs
index|[
literal|0
index|]
argument_list|)
operator|)
operator|.
name|getId
argument_list|()
decl_stmt|;
name|valParsersTested
operator|.
name|add
argument_list|(
name|funcName
argument_list|)
expr_stmt|;
name|assertQueryEquals
argument_list|(
name|FunctionQParserPlugin
operator|.
name|NAME
argument_list|,
name|req
argument_list|,
name|inputs
argument_list|)
expr_stmt|;
block|}
block|}
end_class
end_unit
