begin_unit
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_package
DECL|package|org.apache.solr.search
package|package
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|search
package|;
end_package
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Random
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|BooleanClause
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|BooleanQuery
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|BoostQuery
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|DisjunctionMaxQuery
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|FuzzyQuery
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|Query
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|TermQuery
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|SolrTestCaseJ4
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|SolrException
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|params
operator|.
name|ModifiableSolrParams
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|params
operator|.
name|SolrParams
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|request
operator|.
name|SolrQueryRequest
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|util
operator|.
name|SolrPluginUtils
import|;
end_import
begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|BeforeClass
import|;
end_import
begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Test
import|;
end_import
begin_class
DECL|class|TestExtendedDismaxParser
specifier|public
class|class
name|TestExtendedDismaxParser
extends|extends
name|SolrTestCaseJ4
block|{
annotation|@
name|BeforeClass
DECL|method|beforeClass
specifier|public
specifier|static
name|void
name|beforeClass
parameter_list|()
throws|throws
name|Exception
block|{
name|System
operator|.
name|setProperty
argument_list|(
literal|"enable.update.log"
argument_list|,
literal|"false"
argument_list|)
expr_stmt|;
comment|// schema12 doesn't support _version_
name|initCore
argument_list|(
literal|"solrconfig.xml"
argument_list|,
literal|"schema12.xml"
argument_list|)
expr_stmt|;
name|index
argument_list|()
expr_stmt|;
block|}
DECL|method|index
specifier|public
specifier|static
name|void
name|index
parameter_list|()
throws|throws
name|Exception
block|{
name|assertU
argument_list|(
name|adoc
argument_list|(
literal|"id"
argument_list|,
literal|"42"
argument_list|,
literal|"trait_ss"
argument_list|,
literal|"Tool"
argument_list|,
literal|"trait_ss"
argument_list|,
literal|"Obnoxious"
argument_list|,
literal|"name"
argument_list|,
literal|"Zapp Brannigan"
argument_list|)
argument_list|)
expr_stmt|;
name|assertU
argument_list|(
name|adoc
argument_list|(
literal|"id"
argument_list|,
literal|"43"
argument_list|,
literal|"title"
argument_list|,
literal|"Democratic Order op Planets"
argument_list|)
argument_list|)
expr_stmt|;
name|assertU
argument_list|(
name|adoc
argument_list|(
literal|"id"
argument_list|,
literal|"44"
argument_list|,
literal|"trait_ss"
argument_list|,
literal|"Tool"
argument_list|,
literal|"name"
argument_list|,
literal|"The Zapper"
argument_list|)
argument_list|)
expr_stmt|;
name|assertU
argument_list|(
name|adoc
argument_list|(
literal|"id"
argument_list|,
literal|"45"
argument_list|,
literal|"trait_ss"
argument_list|,
literal|"Chauvinist"
argument_list|,
literal|"title"
argument_list|,
literal|"25 star General"
argument_list|)
argument_list|)
expr_stmt|;
name|assertU
argument_list|(
name|adoc
argument_list|(
literal|"id"
argument_list|,
literal|"46"
argument_list|,
literal|"trait_ss"
argument_list|,
literal|"Obnoxious"
argument_list|,
literal|"subject"
argument_list|,
literal|"Defeated the pacifists op the Gandhi nebula"
argument_list|,
literal|"t_special"
argument_list|,
literal|"literal:colon value"
argument_list|,
literal|"movies_t"
argument_list|,
literal|"first is Mission: Impossible, second is Terminator 2: Judgement Day.  Terminator:3 ok..."
argument_list|,
literal|"foo_i"
argument_list|,
literal|"8"
argument_list|)
argument_list|)
expr_stmt|;
name|assertU
argument_list|(
name|adoc
argument_list|(
literal|"id"
argument_list|,
literal|"47"
argument_list|,
literal|"trait_ss"
argument_list|,
literal|"Pig"
argument_list|,
literal|"text"
argument_list|,
literal|"line up and fly directly at the enemy death cannons, clogging them with wreckage!"
argument_list|)
argument_list|)
expr_stmt|;
name|assertU
argument_list|(
name|adoc
argument_list|(
literal|"id"
argument_list|,
literal|"48"
argument_list|,
literal|"text_sw"
argument_list|,
literal|"this has gigabyte potential"
argument_list|,
literal|"foo_i"
argument_list|,
literal|"100"
argument_list|)
argument_list|)
expr_stmt|;
name|assertU
argument_list|(
name|adoc
argument_list|(
literal|"id"
argument_list|,
literal|"49"
argument_list|,
literal|"text_sw"
argument_list|,
literal|"start the big apple end"
argument_list|,
literal|"foo_i"
argument_list|,
literal|"-100"
argument_list|)
argument_list|)
expr_stmt|;
name|assertU
argument_list|(
name|adoc
argument_list|(
literal|"id"
argument_list|,
literal|"50"
argument_list|,
literal|"text_sw"
argument_list|,
literal|"start new big city end"
argument_list|)
argument_list|)
expr_stmt|;
name|assertU
argument_list|(
name|adoc
argument_list|(
literal|"id"
argument_list|,
literal|"51"
argument_list|,
literal|"store"
argument_list|,
literal|"12.34,-56.78"
argument_list|)
argument_list|)
expr_stmt|;
name|assertU
argument_list|(
name|adoc
argument_list|(
literal|"id"
argument_list|,
literal|"52"
argument_list|,
literal|"text_sw"
argument_list|,
literal|"tekna theou klethomen"
argument_list|)
argument_list|)
expr_stmt|;
name|assertU
argument_list|(
name|adoc
argument_list|(
literal|"id"
argument_list|,
literal|"53"
argument_list|,
literal|"text_sw"
argument_list|,
literal|"nun tekna theou esmen"
argument_list|)
argument_list|)
expr_stmt|;
name|assertU
argument_list|(
name|adoc
argument_list|(
literal|"id"
argument_list|,
literal|"54"
argument_list|,
literal|"text_sw"
argument_list|,
literal|"phanera estin ta tekna tou theou"
argument_list|)
argument_list|)
expr_stmt|;
name|assertU
argument_list|(
name|adoc
argument_list|(
literal|"id"
argument_list|,
literal|"55"
argument_list|,
literal|"standardtok"
argument_list|,
literal|"å¤§"
argument_list|)
argument_list|)
expr_stmt|;
name|assertU
argument_list|(
name|adoc
argument_list|(
literal|"id"
argument_list|,
literal|"56"
argument_list|,
literal|"standardtok"
argument_list|,
literal|"å¤§äº"
argument_list|)
argument_list|)
expr_stmt|;
name|assertU
argument_list|(
name|adoc
argument_list|(
literal|"id"
argument_list|,
literal|"57"
argument_list|,
literal|"standardtok"
argument_list|,
literal|"å¤§äºæ¹¾"
argument_list|)
argument_list|)
expr_stmt|;
name|assertU
argument_list|(
name|adoc
argument_list|(
literal|"id"
argument_list|,
literal|"58"
argument_list|,
literal|"HTMLstandardtok"
argument_list|,
literal|"å¤§"
argument_list|)
argument_list|)
expr_stmt|;
name|assertU
argument_list|(
name|adoc
argument_list|(
literal|"id"
argument_list|,
literal|"59"
argument_list|,
literal|"HTMLstandardtok"
argument_list|,
literal|"å¤§äº"
argument_list|)
argument_list|)
expr_stmt|;
name|assertU
argument_list|(
name|adoc
argument_list|(
literal|"id"
argument_list|,
literal|"60"
argument_list|,
literal|"HTMLstandardtok"
argument_list|,
literal|"å¤§äºæ¹¾"
argument_list|)
argument_list|)
expr_stmt|;
name|assertU
argument_list|(
name|adoc
argument_list|(
literal|"id"
argument_list|,
literal|"61"
argument_list|,
literal|"text_sw"
argument_list|,
literal|"bazaaa"
argument_list|)
argument_list|)
expr_stmt|;
comment|// synonyms in an expansion group
name|assertU
argument_list|(
name|commit
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testSyntax
specifier|public
name|void
name|testSyntax
parameter_list|()
throws|throws
name|Exception
block|{
comment|// a bare * should be treated as *:*
name|assertJQ
argument_list|(
name|req
argument_list|(
literal|"defType"
argument_list|,
literal|"edismax"
argument_list|,
literal|"q"
argument_list|,
literal|"*"
argument_list|,
literal|"df"
argument_list|,
literal|"doesnotexist_s"
argument_list|)
argument_list|,
literal|"/response/docs/[0]=="
comment|// make sure we get something...
argument_list|)
expr_stmt|;
name|assertJQ
argument_list|(
name|req
argument_list|(
literal|"defType"
argument_list|,
literal|"edismax"
argument_list|,
literal|"q"
argument_list|,
literal|"doesnotexist_s:*"
argument_list|)
argument_list|,
literal|"/response/numFound==0"
comment|// nothing should be found
argument_list|)
expr_stmt|;
name|assertJQ
argument_list|(
name|req
argument_list|(
literal|"defType"
argument_list|,
literal|"edismax"
argument_list|,
literal|"q"
argument_list|,
literal|"doesnotexist_s:*"
argument_list|)
argument_list|,
literal|"/response/numFound==0"
comment|// nothing should be found
argument_list|)
expr_stmt|;
name|assertJQ
argument_list|(
name|req
argument_list|(
literal|"defType"
argument_list|,
literal|"edismax"
argument_list|,
literal|"q"
argument_list|,
literal|"doesnotexist_s:( * * * )"
argument_list|)
argument_list|,
literal|"/response/numFound==0"
comment|// nothing should be found
argument_list|)
expr_stmt|;
block|}
DECL|method|testTrailingOperators
specifier|public
name|void
name|testTrailingOperators
parameter_list|()
throws|throws
name|Exception
block|{
comment|// really just test that exceptions aren't thrown by
comment|// single + -
name|assertJQ
argument_list|(
name|req
argument_list|(
literal|"defType"
argument_list|,
literal|"edismax"
argument_list|,
literal|"q"
argument_list|,
literal|"-"
argument_list|)
argument_list|,
literal|"/response=="
argument_list|)
expr_stmt|;
name|assertJQ
argument_list|(
name|req
argument_list|(
literal|"defType"
argument_list|,
literal|"edismax"
argument_list|,
literal|"q"
argument_list|,
literal|"+"
argument_list|)
argument_list|,
literal|"/response=="
argument_list|)
expr_stmt|;
name|assertJQ
argument_list|(
name|req
argument_list|(
literal|"defType"
argument_list|,
literal|"edismax"
argument_list|,
literal|"q"
argument_list|,
literal|"+ - +"
argument_list|)
argument_list|,
literal|"/response=="
argument_list|)
expr_stmt|;
name|assertJQ
argument_list|(
name|req
argument_list|(
literal|"defType"
argument_list|,
literal|"edismax"
argument_list|,
literal|"q"
argument_list|,
literal|"- + -"
argument_list|)
argument_list|,
literal|"/response=="
argument_list|)
expr_stmt|;
name|assertJQ
argument_list|(
name|req
argument_list|(
literal|"defType"
argument_list|,
literal|"edismax"
argument_list|,
literal|"q"
argument_list|,
literal|"id:47 +"
argument_list|)
argument_list|,
literal|"/response/numFound==1"
argument_list|)
expr_stmt|;
name|assertJQ
argument_list|(
name|req
argument_list|(
literal|"defType"
argument_list|,
literal|"edismax"
argument_list|,
literal|"q"
argument_list|,
literal|"id:47 -"
argument_list|)
argument_list|,
literal|"/response/numFound==1"
argument_list|)
expr_stmt|;
name|Random
name|r
init|=
name|random
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|100
condition|;
name|i
operator|++
control|)
block|{
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|r
operator|.
name|nextInt
argument_list|(
literal|10
argument_list|)
condition|;
name|j
operator|++
control|)
block|{
switch|switch
condition|(
name|r
operator|.
name|nextInt
argument_list|(
literal|3
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
name|sb
operator|.
name|append
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|sb
operator|.
name|append
argument_list|(
literal|'+'
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|sb
operator|.
name|append
argument_list|(
literal|'-'
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|sb
operator|.
name|append
argument_list|(
operator|(
name|char
operator|)
name|r
operator|.
name|nextInt
argument_list|(
literal|127
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|String
name|q
init|=
name|sb
operator|.
name|toString
argument_list|()
decl_stmt|;
name|assertJQ
argument_list|(
name|req
argument_list|(
literal|"defType"
argument_list|,
literal|"edismax"
argument_list|,
literal|"q"
argument_list|,
name|q
argument_list|)
argument_list|,
literal|"/response=="
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|testLowercaseOperators
specifier|public
name|void
name|testLowercaseOperators
parameter_list|()
block|{
name|assertQ
argument_list|(
literal|"Upper case operator"
argument_list|,
name|req
argument_list|(
literal|"q"
argument_list|,
literal|"Zapp AND Brannigan"
argument_list|,
literal|"qf"
argument_list|,
literal|"name"
argument_list|,
literal|"lowercaseOperators"
argument_list|,
literal|"false"
argument_list|,
literal|"defType"
argument_list|,
literal|"edismax"
argument_list|)
argument_list|,
literal|"*[count(//doc)=1]"
argument_list|)
expr_stmt|;
name|assertQ
argument_list|(
literal|"Upper case operator, allow lowercase"
argument_list|,
name|req
argument_list|(
literal|"q"
argument_list|,
literal|"Zapp AND Brannigan"
argument_list|,
literal|"qf"
argument_list|,
literal|"name"
argument_list|,
literal|"lowercaseOperators"
argument_list|,
literal|"true"
argument_list|,
literal|"defType"
argument_list|,
literal|"edismax"
argument_list|)
argument_list|,
literal|"*[count(//doc)=1]"
argument_list|)
expr_stmt|;
name|assertQ
argument_list|(
literal|"Lower case operator, don't allow lowercase operators"
argument_list|,
name|req
argument_list|(
literal|"q"
argument_list|,
literal|"Zapp and Brannigan"
argument_list|,
literal|"qf"
argument_list|,
literal|"name"
argument_list|,
literal|"q.op"
argument_list|,
literal|"AND"
argument_list|,
literal|"lowercaseOperators"
argument_list|,
literal|"false"
argument_list|,
literal|"defType"
argument_list|,
literal|"edismax"
argument_list|)
argument_list|,
literal|"*[count(//doc)=0]"
argument_list|)
expr_stmt|;
name|assertQ
argument_list|(
literal|"Lower case operator, allow lower case operators"
argument_list|,
name|req
argument_list|(
literal|"q"
argument_list|,
literal|"Zapp and Brannigan"
argument_list|,
literal|"qf"
argument_list|,
literal|"name"
argument_list|,
literal|"q.op"
argument_list|,
literal|"AND"
argument_list|,
literal|"lowercaseOperators"
argument_list|,
literal|"true"
argument_list|,
literal|"defType"
argument_list|,
literal|"edismax"
argument_list|)
argument_list|,
literal|"*[count(//doc)=1]"
argument_list|)
expr_stmt|;
block|}
comment|// test the edismax query parser based on the dismax parser
DECL|method|testFocusQueryParser
specifier|public
name|void
name|testFocusQueryParser
parameter_list|()
block|{
name|String
name|allq
init|=
literal|"id:[42 TO 51]"
decl_stmt|;
name|String
name|allr
init|=
literal|"*[count(//doc)=10]"
decl_stmt|;
name|String
name|oner
init|=
literal|"*[count(//doc)=1]"
decl_stmt|;
name|String
name|twor
init|=
literal|"*[count(//doc)=2]"
decl_stmt|;
name|String
name|nor
init|=
literal|"*[count(//doc)=0]"
decl_stmt|;
name|assertQ
argument_list|(
literal|"blank q"
argument_list|,
name|req
argument_list|(
literal|"q"
argument_list|,
literal|" "
argument_list|,
literal|"q.alt"
argument_list|,
name|allq
argument_list|,
literal|"defType"
argument_list|,
literal|"edismax"
argument_list|)
argument_list|,
name|allr
argument_list|)
expr_stmt|;
name|assertQ
argument_list|(
literal|"expected doc is missing (using un-escaped edismax w/qf)"
argument_list|,
name|req
argument_list|(
literal|"q"
argument_list|,
literal|"literal:colon"
argument_list|,
literal|"qf"
argument_list|,
literal|"t_special"
argument_list|,
literal|"defType"
argument_list|,
literal|"edismax"
argument_list|)
argument_list|,
literal|"//doc[1]/str[@name='id'][.='46']"
argument_list|)
expr_stmt|;
name|assertQ
argument_list|(
literal|"standard request handler returns all matches"
argument_list|,
name|req
argument_list|(
name|allq
argument_list|)
argument_list|,
name|allr
argument_list|)
expr_stmt|;
name|assertQ
argument_list|(
literal|"edismax query parser returns all matches"
argument_list|,
name|req
argument_list|(
literal|"q"
argument_list|,
name|allq
argument_list|,
literal|"defType"
argument_list|,
literal|"edismax"
argument_list|)
argument_list|,
name|allr
argument_list|)
expr_stmt|;
name|assertQ
argument_list|(
name|req
argument_list|(
literal|"defType"
argument_list|,
literal|"edismax"
argument_list|,
literal|"qf"
argument_list|,
literal|"trait_ss"
argument_list|,
literal|"q"
argument_list|,
literal|"Tool"
argument_list|)
argument_list|,
name|twor
argument_list|)
expr_stmt|;
comment|// test that field types that aren't applicable don't cause an exception to be thrown
name|assertQ
argument_list|(
name|req
argument_list|(
literal|"defType"
argument_list|,
literal|"edismax"
argument_list|,
literal|"qf"
argument_list|,
literal|"trait_ss foo_i foo_f foo_dt foo_l foo_d foo_b"
argument_list|,
literal|"q"
argument_list|,
literal|"Tool"
argument_list|)
argument_list|,
name|twor
argument_list|)
expr_stmt|;
comment|// test that numeric field types can be queried
name|assertQ
argument_list|(
name|req
argument_list|(
literal|"defType"
argument_list|,
literal|"edismax"
argument_list|,
literal|"qf"
argument_list|,
literal|"text_sw"
argument_list|,
literal|"q"
argument_list|,
literal|"foo_i:100"
argument_list|)
argument_list|,
name|oner
argument_list|)
expr_stmt|;
comment|// test that numeric field types can be queried
name|assertQ
argument_list|(
name|req
argument_list|(
literal|"defType"
argument_list|,
literal|"edismax"
argument_list|,
literal|"qf"
argument_list|,
literal|"text_sw"
argument_list|,
literal|"q"
argument_list|,
literal|"foo_i:-100"
argument_list|)
argument_list|,
name|oner
argument_list|)
expr_stmt|;
comment|// test that numeric field types can be queried  via qf
name|assertQ
argument_list|(
name|req
argument_list|(
literal|"defType"
argument_list|,
literal|"edismax"
argument_list|,
literal|"qf"
argument_list|,
literal|"text_sw foo_i"
argument_list|,
literal|"q"
argument_list|,
literal|"100"
argument_list|)
argument_list|,
name|oner
argument_list|)
expr_stmt|;
name|assertQ
argument_list|(
literal|"qf defaults to df"
argument_list|,
name|req
argument_list|(
literal|"defType"
argument_list|,
literal|"edismax"
argument_list|,
literal|"df"
argument_list|,
literal|"trait_ss"
argument_list|,
literal|"q"
argument_list|,
literal|"Tool"
argument_list|)
argument_list|,
name|twor
argument_list|)
expr_stmt|;
name|assertQ
argument_list|(
literal|"qf defaults to defaultSearchField"
argument_list|,
name|req
argument_list|(
literal|"defType"
argument_list|,
literal|"edismax"
argument_list|,
literal|"q"
argument_list|,
literal|"op"
argument_list|)
argument_list|,
name|twor
argument_list|)
expr_stmt|;
name|assertQ
argument_list|(
name|req
argument_list|(
literal|"defType"
argument_list|,
literal|"edismax"
argument_list|,
literal|"qf"
argument_list|,
literal|"name title subject text"
argument_list|,
literal|"q"
argument_list|,
literal|"op"
argument_list|)
argument_list|,
name|twor
argument_list|)
expr_stmt|;
name|assertQ
argument_list|(
name|req
argument_list|(
literal|"defType"
argument_list|,
literal|"edismax"
argument_list|,
literal|"qf"
argument_list|,
literal|"name title subject text"
argument_list|,
literal|"q.op"
argument_list|,
literal|"AND"
argument_list|,
literal|"q"
argument_list|,
literal|"Order op"
argument_list|)
argument_list|,
name|oner
argument_list|)
expr_stmt|;
name|assertQ
argument_list|(
name|req
argument_list|(
literal|"defType"
argument_list|,
literal|"edismax"
argument_list|,
literal|"qf"
argument_list|,
literal|"name title subject text"
argument_list|,
literal|"q.op"
argument_list|,
literal|"OR"
argument_list|,
literal|"q"
argument_list|,
literal|"Order op"
argument_list|)
argument_list|,
name|twor
argument_list|)
expr_stmt|;
name|assertQ
argument_list|(
name|req
argument_list|(
literal|"defType"
argument_list|,
literal|"edismax"
argument_list|,
literal|"qf"
argument_list|,
literal|"name title subject text"
argument_list|,
literal|"q"
argument_list|,
literal|"Order AND op"
argument_list|)
argument_list|,
name|oner
argument_list|)
expr_stmt|;
name|assertQ
argument_list|(
name|req
argument_list|(
literal|"defType"
argument_list|,
literal|"edismax"
argument_list|,
literal|"qf"
argument_list|,
literal|"name title subject text"
argument_list|,
literal|"q"
argument_list|,
literal|"Order and op"
argument_list|)
argument_list|,
name|oner
argument_list|)
expr_stmt|;
name|assertQ
argument_list|(
name|req
argument_list|(
literal|"defType"
argument_list|,
literal|"edismax"
argument_list|,
literal|"qf"
argument_list|,
literal|"name title subject text"
argument_list|,
literal|"q"
argument_list|,
literal|"+Order op"
argument_list|)
argument_list|,
name|oner
argument_list|)
expr_stmt|;
name|assertQ
argument_list|(
name|req
argument_list|(
literal|"defType"
argument_list|,
literal|"edismax"
argument_list|,
literal|"qf"
argument_list|,
literal|"name title subject text"
argument_list|,
literal|"q"
argument_list|,
literal|"Order OR op"
argument_list|)
argument_list|,
name|twor
argument_list|)
expr_stmt|;
name|assertQ
argument_list|(
name|req
argument_list|(
literal|"defType"
argument_list|,
literal|"edismax"
argument_list|,
literal|"qf"
argument_list|,
literal|"name title subject text"
argument_list|,
literal|"q"
argument_list|,
literal|"Order or op"
argument_list|)
argument_list|,
name|twor
argument_list|)
expr_stmt|;
name|assertQ
argument_list|(
name|req
argument_list|(
literal|"defType"
argument_list|,
literal|"edismax"
argument_list|,
literal|"qf"
argument_list|,
literal|"name title subject text"
argument_list|,
literal|"q"
argument_list|,
literal|"*:*"
argument_list|)
argument_list|,
name|allr
argument_list|)
expr_stmt|;
name|assertQ
argument_list|(
name|req
argument_list|(
literal|"defType"
argument_list|,
literal|"edismax"
argument_list|,
literal|"qf"
argument_list|,
literal|"name title subject text"
argument_list|,
literal|"q"
argument_list|,
literal|"star OR (-star)"
argument_list|)
argument_list|,
name|allr
argument_list|)
expr_stmt|;
name|assertQ
argument_list|(
name|req
argument_list|(
literal|"defType"
argument_list|,
literal|"edismax"
argument_list|,
literal|"qf"
argument_list|,
literal|"name title subject text"
argument_list|,
literal|"q"
argument_list|,
literal|"id:42 OR (-id:42)"
argument_list|)
argument_list|,
name|allr
argument_list|)
expr_stmt|;
comment|// test that basic synonyms work
name|assertQ
argument_list|(
name|req
argument_list|(
literal|"defType"
argument_list|,
literal|"edismax"
argument_list|,
literal|"qf"
argument_list|,
literal|"text_sw"
argument_list|,
literal|"q"
argument_list|,
literal|"GB"
argument_list|)
argument_list|,
name|oner
argument_list|)
expr_stmt|;
comment|// test for stopword removal in main query part
name|assertQ
argument_list|(
name|req
argument_list|(
literal|"defType"
argument_list|,
literal|"edismax"
argument_list|,
literal|"qf"
argument_list|,
literal|"text_sw"
argument_list|,
literal|"q"
argument_list|,
literal|"the big"
argument_list|)
argument_list|,
name|twor
argument_list|)
expr_stmt|;
comment|// test for stopwords not removed
name|assertQ
argument_list|(
name|req
argument_list|(
literal|"defType"
argument_list|,
literal|"edismax"
argument_list|,
literal|"qf"
argument_list|,
literal|"text_sw"
argument_list|,
literal|"stopwords"
argument_list|,
literal|"false"
argument_list|,
literal|"q.op"
argument_list|,
literal|"AND"
argument_list|,
literal|"q"
argument_list|,
literal|"the big"
argument_list|)
argument_list|,
name|oner
argument_list|)
expr_stmt|;
comment|// searching for a literal colon value when clearly not used for a field
name|assertQ
argument_list|(
literal|"expected doc is missing (using standard)"
argument_list|,
name|req
argument_list|(
literal|"q"
argument_list|,
literal|"t_special:literal\\:colon"
argument_list|)
argument_list|,
literal|"//doc[1]/str[@name='id'][.='46']"
argument_list|)
expr_stmt|;
name|assertQ
argument_list|(
literal|"expected doc is missing (using escaped edismax w/field)"
argument_list|,
name|req
argument_list|(
literal|"q"
argument_list|,
literal|"t_special:literal\\:colon"
argument_list|,
literal|"defType"
argument_list|,
literal|"edismax"
argument_list|)
argument_list|,
literal|"//doc[1]/str[@name='id'][.='46']"
argument_list|)
expr_stmt|;
name|assertQ
argument_list|(
literal|"expected doc is missing (using un-escaped edismax w/field)"
argument_list|,
name|req
argument_list|(
literal|"q"
argument_list|,
literal|"t_special:literal:colon"
argument_list|,
literal|"defType"
argument_list|,
literal|"edismax"
argument_list|)
argument_list|,
literal|"//doc[1]/str[@name='id'][.='46']"
argument_list|)
expr_stmt|;
name|assertQ
argument_list|(
literal|"expected doc is missing (using escaped edismax w/qf)"
argument_list|,
name|req
argument_list|(
literal|"q"
argument_list|,
literal|"literal\\:colon"
argument_list|,
literal|"qf"
argument_list|,
literal|"t_special"
argument_list|,
literal|"defType"
argument_list|,
literal|"edismax"
argument_list|)
argument_list|,
literal|"//doc[1]/str[@name='id'][.='46']"
argument_list|)
expr_stmt|;
name|assertQ
argument_list|(
literal|"expected doc is missing (using un-escaped edismax w/qf)"
argument_list|,
name|req
argument_list|(
literal|"q"
argument_list|,
literal|"literal:colon"
argument_list|,
literal|"qf"
argument_list|,
literal|"t_special"
argument_list|,
literal|"defType"
argument_list|,
literal|"edismax"
argument_list|)
argument_list|,
literal|"//doc[1]/str[@name='id'][.='46']"
argument_list|)
expr_stmt|;
name|assertQ
argument_list|(
name|req
argument_list|(
literal|"defType"
argument_list|,
literal|"edismax"
argument_list|,
literal|"mm"
argument_list|,
literal|"100%"
argument_list|,
literal|"q"
argument_list|,
literal|"terminator:3"
argument_list|,
literal|"qf"
argument_list|,
literal|"movies_t"
argument_list|)
argument_list|,
name|oner
argument_list|)
expr_stmt|;
name|assertQ
argument_list|(
name|req
argument_list|(
literal|"defType"
argument_list|,
literal|"edismax"
argument_list|,
literal|"mm"
argument_list|,
literal|"100%"
argument_list|,
literal|"q"
argument_list|,
literal|"Mission:Impossible"
argument_list|,
literal|"qf"
argument_list|,
literal|"movies_t"
argument_list|)
argument_list|,
name|oner
argument_list|)
expr_stmt|;
name|assertQ
argument_list|(
name|req
argument_list|(
literal|"defType"
argument_list|,
literal|"edismax"
argument_list|,
literal|"mm"
argument_list|,
literal|"100%"
argument_list|,
literal|"q"
argument_list|,
literal|"Mission : Impossible"
argument_list|,
literal|"qf"
argument_list|,
literal|"movies_t"
argument_list|)
argument_list|,
name|oner
argument_list|)
expr_stmt|;
name|assertQ
argument_list|(
name|req
argument_list|(
literal|"defType"
argument_list|,
literal|"edismax"
argument_list|,
literal|"mm"
argument_list|,
literal|"100%"
argument_list|,
literal|"q"
argument_list|,
literal|"Mission: Impossible"
argument_list|,
literal|"qf"
argument_list|,
literal|"movies_t"
argument_list|)
argument_list|,
name|oner
argument_list|)
expr_stmt|;
name|assertQ
argument_list|(
name|req
argument_list|(
literal|"defType"
argument_list|,
literal|"edismax"
argument_list|,
literal|"mm"
argument_list|,
literal|"100%"
argument_list|,
literal|"q"
argument_list|,
literal|"Terminator 2: Judgement Day"
argument_list|,
literal|"qf"
argument_list|,
literal|"movies_t"
argument_list|)
argument_list|,
name|oner
argument_list|)
expr_stmt|;
comment|// make sure the clause wasn't eliminated
name|assertQ
argument_list|(
name|req
argument_list|(
literal|"defType"
argument_list|,
literal|"edismax"
argument_list|,
literal|"mm"
argument_list|,
literal|"100%"
argument_list|,
literal|"q"
argument_list|,
literal|"Terminator 10: Judgement Day"
argument_list|,
literal|"qf"
argument_list|,
literal|"movies_t"
argument_list|)
argument_list|,
name|nor
argument_list|)
expr_stmt|;
comment|// throw in a numeric field
name|assertQ
argument_list|(
name|req
argument_list|(
literal|"defType"
argument_list|,
literal|"edismax"
argument_list|,
literal|"mm"
argument_list|,
literal|"0"
argument_list|,
literal|"q"
argument_list|,
literal|"Terminator: 100"
argument_list|,
literal|"qf"
argument_list|,
literal|"movies_t foo_i"
argument_list|)
argument_list|,
name|twor
argument_list|)
expr_stmt|;
name|assertQ
argument_list|(
name|req
argument_list|(
literal|"defType"
argument_list|,
literal|"edismax"
argument_list|,
literal|"mm"
argument_list|,
literal|"100%"
argument_list|,
literal|"q"
argument_list|,
literal|"Terminator: 100"
argument_list|,
literal|"qf"
argument_list|,
literal|"movies_t foo_i"
argument_list|)
argument_list|,
name|nor
argument_list|)
expr_stmt|;
name|assertQ
argument_list|(
name|req
argument_list|(
literal|"defType"
argument_list|,
literal|"edismax"
argument_list|,
literal|"mm"
argument_list|,
literal|"100%"
argument_list|,
literal|"q"
argument_list|,
literal|"Terminator: 8"
argument_list|,
literal|"qf"
argument_list|,
literal|"movies_t foo_i"
argument_list|)
argument_list|,
name|oner
argument_list|)
expr_stmt|;
name|assertQ
argument_list|(
name|req
argument_list|(
literal|"defType"
argument_list|,
literal|"edismax"
argument_list|,
literal|"mm"
argument_list|,
literal|"0"
argument_list|,
literal|"q"
argument_list|,
literal|"movies_t:Terminator 100"
argument_list|,
literal|"qf"
argument_list|,
literal|"movies_t foo_i"
argument_list|)
argument_list|,
name|twor
argument_list|)
expr_stmt|;
comment|// special psuedo-fields like _query_ and _val_
comment|// special fields (and real field id) should be included by default
name|assertQ
argument_list|(
name|req
argument_list|(
literal|"defType"
argument_list|,
literal|"edismax"
argument_list|,
literal|"mm"
argument_list|,
literal|"100%"
argument_list|,
literal|"fq"
argument_list|,
literal|"id:51"
argument_list|,
literal|"q"
argument_list|,
literal|"_query_:\"{!geofilt d=20 sfield=store pt=12.34,-56.78}\""
argument_list|)
argument_list|,
name|oner
argument_list|)
expr_stmt|;
comment|// should also work when explicitly allowed
name|assertQ
argument_list|(
name|req
argument_list|(
literal|"defType"
argument_list|,
literal|"edismax"
argument_list|,
literal|"mm"
argument_list|,
literal|"100%"
argument_list|,
literal|"fq"
argument_list|,
literal|"id:51"
argument_list|,
literal|"uf"
argument_list|,
literal|"id _query_"
argument_list|,
literal|"q"
argument_list|,
literal|"_query_:\"{!geofilt d=20 sfield=store pt=12.34,-56.78}\""
argument_list|)
argument_list|,
name|oner
argument_list|)
expr_stmt|;
name|assertQ
argument_list|(
name|req
argument_list|(
literal|"defType"
argument_list|,
literal|"edismax"
argument_list|,
literal|"mm"
argument_list|,
literal|"100%"
argument_list|,
literal|"fq"
argument_list|,
literal|"id:51"
argument_list|,
literal|"uf"
argument_list|,
literal|"id"
argument_list|,
literal|"uf"
argument_list|,
literal|"_query_"
argument_list|,
literal|"q"
argument_list|,
literal|"_query_:\"{!geofilt d=20 sfield=store pt=12.34,-56.78}\""
argument_list|)
argument_list|,
name|oner
argument_list|)
expr_stmt|;
comment|// should fail when prohibited
name|assertQ
argument_list|(
name|req
argument_list|(
literal|"defType"
argument_list|,
literal|"edismax"
argument_list|,
literal|"mm"
argument_list|,
literal|"100%"
argument_list|,
literal|"fq"
argument_list|,
literal|"id:51"
argument_list|,
literal|"uf"
argument_list|,
literal|"* -_query_"
argument_list|,
comment|// explicitly excluded
literal|"q"
argument_list|,
literal|"_query_:\"{!geofilt d=20 sfield=store pt=12.34,-56.78}\""
argument_list|)
argument_list|,
name|nor
argument_list|)
expr_stmt|;
name|assertQ
argument_list|(
name|req
argument_list|(
literal|"defType"
argument_list|,
literal|"edismax"
argument_list|,
literal|"mm"
argument_list|,
literal|"100%"
argument_list|,
literal|"fq"
argument_list|,
literal|"id:51"
argument_list|,
literal|"uf"
argument_list|,
literal|"id"
argument_list|,
comment|// excluded by ommision
literal|"q"
argument_list|,
literal|"_query_:\"{!geofilt d=20 sfield=store pt=12.34,-56.78}\""
argument_list|)
argument_list|,
name|nor
argument_list|)
expr_stmt|;
comment|/** stopword removal in conjunction with multi-word synonyms at query time      * break this test.      // multi-word synonyms      // remove id:50 which contans the false match           assertQ(req("defType", "edismax", "qf", "text_t", "indent","true", "debugQuery","true",            "q","-id:50 nyc"), oner     );     **/
comment|/*** these fail because multi-word synonyms are being used at query time     // this will incorrectly match "new big city"     assertQ(req("defType", "edismax", "qf", "id title",            "q","nyc"), oner     );      // this will incorrectly match "new big city"     assertQ(req("defType", "edismax", "qf", "title",            "q","the big apple"), nor     );     ***/
block|}
DECL|method|testBoostQuery
specifier|public
name|void
name|testBoostQuery
parameter_list|()
block|{
name|assertQ
argument_list|(
name|req
argument_list|(
literal|"q"
argument_list|,
literal|"tekna"
argument_list|,
literal|"qf"
argument_list|,
literal|"text_sw"
argument_list|,
literal|"defType"
argument_list|,
literal|"edismax"
argument_list|,
literal|"bq"
argument_list|,
literal|"id:54^100"
argument_list|,
literal|"bq"
argument_list|,
literal|"id:53^10"
argument_list|,
literal|"fq"
argument_list|,
literal|"id:[52 TO 54]"
argument_list|,
literal|"fl"
argument_list|,
literal|"id,score"
argument_list|)
argument_list|,
literal|"//doc[1]/str[@name='id'][.='54']"
argument_list|,
literal|"//doc[2]/str[@name='id'][.='53']"
argument_list|,
literal|"//doc[3]/str[@name='id'][.='52']"
argument_list|)
expr_stmt|;
comment|// non-trivial bqs
name|assertQ
argument_list|(
name|req
argument_list|(
literal|"q"
argument_list|,
literal|"tekna"
argument_list|,
literal|"qf"
argument_list|,
literal|"text_sw"
argument_list|,
literal|"defType"
argument_list|,
literal|"edismax"
argument_list|,
literal|"bq"
argument_list|,
literal|"(text_sw:blasdfadsf id:54)^100"
argument_list|,
literal|"bq"
argument_list|,
literal|"id:[53 TO 53]^10"
argument_list|,
literal|"fq"
argument_list|,
literal|"id:[52 TO 54]"
argument_list|,
literal|"fl"
argument_list|,
literal|"id,score"
argument_list|)
argument_list|,
literal|"//doc[1]/str[@name='id'][.='54']"
argument_list|,
literal|"//doc[2]/str[@name='id'][.='53']"
argument_list|,
literal|"//doc[3]/str[@name='id'][.='52']"
argument_list|)
expr_stmt|;
comment|// genuine negative boosts are not legal
comment|// see SOLR-3823, SOLR-3278, LUCENE-4378 and
comment|// https://wiki.apache.org/solr/SolrRelevancyFAQ#How_do_I_give_a_negative_.28or_very_low.29_boost_to_documents_that_match_a_query.3F
name|assertQ
argument_list|(
name|req
argument_list|(
literal|"q"
argument_list|,
literal|"tekna"
argument_list|,
literal|"qf"
argument_list|,
literal|"text_sw"
argument_list|,
literal|"defType"
argument_list|,
literal|"edismax"
argument_list|,
literal|"bq"
argument_list|,
literal|"(*:* -id:54)^100"
argument_list|,
literal|"bq"
argument_list|,
literal|"id:53^10"
argument_list|,
literal|"bq"
argument_list|,
literal|"id:52"
argument_list|,
literal|"fq"
argument_list|,
literal|"id:[52 TO 54]"
argument_list|,
literal|"fl"
argument_list|,
literal|"id,score"
argument_list|)
argument_list|,
literal|"//doc[1]/str[@name='id'][.='53']"
argument_list|,
literal|"//doc[2]/str[@name='id'][.='52']"
argument_list|,
literal|"//doc[3]/str[@name='id'][.='54']"
argument_list|)
expr_stmt|;
block|}
DECL|method|testUserFields
specifier|public
name|void
name|testUserFields
parameter_list|()
block|{
name|String
name|allr
init|=
literal|"*[count(//doc)=10]"
decl_stmt|;
name|String
name|oner
init|=
literal|"*[count(//doc)=1]"
decl_stmt|;
name|String
name|nor
init|=
literal|"*[count(//doc)=0]"
decl_stmt|;
comment|// User fields
comment|// Default is allow all "*"
comment|// If a list of fields are given, only those are allowed "foo bar"
comment|// Possible to invert with "-" syntax:
comment|//   Disallow all: "-*"
comment|//   Allow all but id: "* -id"
comment|// Also supports "dynamic" field name wildcarding
name|assertQ
argument_list|(
name|req
argument_list|(
literal|"defType"
argument_list|,
literal|"edismax"
argument_list|,
literal|"q"
argument_list|,
literal|"id:42"
argument_list|)
argument_list|,
name|oner
argument_list|)
expr_stmt|;
comment|// SOLR-3377 - parens should be allowed immediately before field name
name|assertQ
argument_list|(
name|req
argument_list|(
literal|"defType"
argument_list|,
literal|"edismax"
argument_list|,
literal|"q"
argument_list|,
literal|"( id:42 )"
argument_list|)
argument_list|,
name|oner
argument_list|)
expr_stmt|;
name|assertQ
argument_list|(
name|req
argument_list|(
literal|"defType"
argument_list|,
literal|"edismax"
argument_list|,
literal|"q"
argument_list|,
literal|"(id:42)"
argument_list|)
argument_list|,
name|oner
argument_list|)
expr_stmt|;
name|assertQ
argument_list|(
name|req
argument_list|(
literal|"defType"
argument_list|,
literal|"edismax"
argument_list|,
literal|"q"
argument_list|,
literal|"(+id:42)"
argument_list|)
argument_list|,
name|oner
argument_list|)
expr_stmt|;
name|assertQ
argument_list|(
name|req
argument_list|(
literal|"defType"
argument_list|,
literal|"edismax"
argument_list|,
literal|"q"
argument_list|,
literal|"+(+id:42)"
argument_list|)
argument_list|,
name|oner
argument_list|)
expr_stmt|;
name|assertQ
argument_list|(
name|req
argument_list|(
literal|"defType"
argument_list|,
literal|"edismax"
argument_list|,
literal|"q"
argument_list|,
literal|"+(+((id:42)))"
argument_list|)
argument_list|,
name|oner
argument_list|)
expr_stmt|;
name|assertQ
argument_list|(
name|req
argument_list|(
literal|"defType"
argument_list|,
literal|"edismax"
argument_list|,
literal|"q"
argument_list|,
literal|"+(+((+id:42)))"
argument_list|)
argument_list|,
name|oner
argument_list|)
expr_stmt|;
name|assertQ
argument_list|(
name|req
argument_list|(
literal|"defType"
argument_list|,
literal|"edismax"
argument_list|,
literal|"q"
argument_list|,
literal|" +( +( ( +id:42) ) ) "
argument_list|)
argument_list|,
name|oner
argument_list|)
expr_stmt|;
name|assertQ
argument_list|(
name|req
argument_list|(
literal|"defType"
argument_list|,
literal|"edismax"
argument_list|,
literal|"q"
argument_list|,
literal|"(id:(*:*)^200)"
argument_list|)
argument_list|,
name|allr
argument_list|)
expr_stmt|;
name|assertQ
argument_list|(
name|req
argument_list|(
literal|"defType"
argument_list|,
literal|"edismax"
argument_list|,
literal|"uf"
argument_list|,
literal|"id"
argument_list|,
literal|"q"
argument_list|,
literal|"id:42"
argument_list|)
argument_list|,
name|oner
argument_list|)
expr_stmt|;
name|assertQ
argument_list|(
name|req
argument_list|(
literal|"defType"
argument_list|,
literal|"edismax"
argument_list|,
literal|"uf"
argument_list|,
literal|"-*"
argument_list|,
literal|"q"
argument_list|,
literal|"id:42"
argument_list|)
argument_list|,
name|nor
argument_list|)
expr_stmt|;
name|assertQ
argument_list|(
name|req
argument_list|(
literal|"defType"
argument_list|,
literal|"edismax"
argument_list|,
literal|"uf"
argument_list|,
literal|"loremipsum"
argument_list|,
literal|"q"
argument_list|,
literal|"id:42"
argument_list|)
argument_list|,
name|nor
argument_list|)
expr_stmt|;
name|assertQ
argument_list|(
name|req
argument_list|(
literal|"defType"
argument_list|,
literal|"edismax"
argument_list|,
literal|"uf"
argument_list|,
literal|"* -id"
argument_list|,
literal|"q"
argument_list|,
literal|"id:42"
argument_list|)
argument_list|,
name|nor
argument_list|)
expr_stmt|;
name|assertQ
argument_list|(
name|req
argument_list|(
literal|"defType"
argument_list|,
literal|"edismax"
argument_list|,
literal|"uf"
argument_list|,
literal|"* -loremipsum"
argument_list|,
literal|"q"
argument_list|,
literal|"id:42"
argument_list|)
argument_list|,
name|oner
argument_list|)
expr_stmt|;
name|assertQ
argument_list|(
name|req
argument_list|(
literal|"defType"
argument_list|,
literal|"edismax"
argument_list|,
literal|"uf"
argument_list|,
literal|"id^5.0"
argument_list|,
literal|"q"
argument_list|,
literal|"id:42"
argument_list|)
argument_list|,
name|oner
argument_list|)
expr_stmt|;
name|assertQ
argument_list|(
name|req
argument_list|(
literal|"defType"
argument_list|,
literal|"edismax"
argument_list|,
literal|"uf"
argument_list|,
literal|"*^5.0"
argument_list|,
literal|"q"
argument_list|,
literal|"id:42"
argument_list|)
argument_list|,
name|oner
argument_list|)
expr_stmt|;
name|assertQ
argument_list|(
name|req
argument_list|(
literal|"defType"
argument_list|,
literal|"edismax"
argument_list|,
literal|"uf"
argument_list|,
literal|"id^5.0"
argument_list|,
literal|"q"
argument_list|,
literal|"id:42^10.0"
argument_list|)
argument_list|,
name|oner
argument_list|)
expr_stmt|;
name|assertQ
argument_list|(
name|req
argument_list|(
literal|"defType"
argument_list|,
literal|"edismax"
argument_list|,
literal|"uf"
argument_list|,
literal|"na*"
argument_list|,
literal|"q"
argument_list|,
literal|"name:Zapp"
argument_list|)
argument_list|,
name|oner
argument_list|)
expr_stmt|;
name|assertQ
argument_list|(
name|req
argument_list|(
literal|"defType"
argument_list|,
literal|"edismax"
argument_list|,
literal|"uf"
argument_list|,
literal|"*me"
argument_list|,
literal|"q"
argument_list|,
literal|"name:Zapp"
argument_list|)
argument_list|,
name|oner
argument_list|)
expr_stmt|;
name|assertQ
argument_list|(
name|req
argument_list|(
literal|"defType"
argument_list|,
literal|"edismax"
argument_list|,
literal|"uf"
argument_list|,
literal|"* -na*"
argument_list|,
literal|"q"
argument_list|,
literal|"name:Zapp"
argument_list|)
argument_list|,
name|nor
argument_list|)
expr_stmt|;
name|assertQ
argument_list|(
name|req
argument_list|(
literal|"defType"
argument_list|,
literal|"edismax"
argument_list|,
literal|"uf"
argument_list|,
literal|"*me -name"
argument_list|,
literal|"q"
argument_list|,
literal|"name:Zapp"
argument_list|)
argument_list|,
name|nor
argument_list|)
expr_stmt|;
name|assertQ
argument_list|(
name|req
argument_list|(
literal|"defType"
argument_list|,
literal|"edismax"
argument_list|,
literal|"uf"
argument_list|,
literal|"*ame -*e"
argument_list|,
literal|"q"
argument_list|,
literal|"name:Zapp"
argument_list|)
argument_list|,
name|nor
argument_list|)
expr_stmt|;
comment|// Boosts from user fields
name|assertQ
argument_list|(
name|req
argument_list|(
literal|"defType"
argument_list|,
literal|"edismax"
argument_list|,
literal|"debugQuery"
argument_list|,
literal|"true"
argument_list|,
literal|"rows"
argument_list|,
literal|"0"
argument_list|,
literal|"q"
argument_list|,
literal|"id:42"
argument_list|)
argument_list|,
literal|"//str[@name='parsedquery_toString'][.='+id:42']"
argument_list|)
expr_stmt|;
name|assertQ
argument_list|(
name|req
argument_list|(
literal|"defType"
argument_list|,
literal|"edismax"
argument_list|,
literal|"debugQuery"
argument_list|,
literal|"true"
argument_list|,
literal|"rows"
argument_list|,
literal|"0"
argument_list|,
literal|"uf"
argument_list|,
literal|"*^5.0"
argument_list|,
literal|"q"
argument_list|,
literal|"id:42"
argument_list|)
argument_list|,
literal|"//str[@name='parsedquery_toString'][.='+(id:42)^5.0']"
argument_list|)
expr_stmt|;
name|assertQ
argument_list|(
name|req
argument_list|(
literal|"defType"
argument_list|,
literal|"edismax"
argument_list|,
literal|"debugQuery"
argument_list|,
literal|"true"
argument_list|,
literal|"rows"
argument_list|,
literal|"0"
argument_list|,
literal|"uf"
argument_list|,
literal|"*^2.0 id^5.0 -xyz"
argument_list|,
literal|"q"
argument_list|,
literal|"name:foo"
argument_list|)
argument_list|,
literal|"//str[@name='parsedquery_toString'][.='+(name:foo)^2.0']"
argument_list|)
expr_stmt|;
name|assertQ
argument_list|(
name|req
argument_list|(
literal|"defType"
argument_list|,
literal|"edismax"
argument_list|,
literal|"debugQuery"
argument_list|,
literal|"true"
argument_list|,
literal|"rows"
argument_list|,
literal|"0"
argument_list|,
literal|"uf"
argument_list|,
literal|"i*^5.0"
argument_list|,
literal|"q"
argument_list|,
literal|"id:42"
argument_list|)
argument_list|,
literal|"//str[@name='parsedquery_toString'][.='+(id:42)^5.0']"
argument_list|)
expr_stmt|;
name|assertQ
argument_list|(
name|req
argument_list|(
literal|"defType"
argument_list|,
literal|"edismax"
argument_list|,
literal|"uf"
argument_list|,
literal|"-*"
argument_list|,
literal|"q"
argument_list|,
literal|"cannons"
argument_list|)
argument_list|,
name|oner
argument_list|)
expr_stmt|;
name|assertQ
argument_list|(
name|req
argument_list|(
literal|"defType"
argument_list|,
literal|"edismax"
argument_list|,
literal|"uf"
argument_list|,
literal|"* -id"
argument_list|,
literal|"q"
argument_list|,
literal|"42"
argument_list|,
literal|"qf"
argument_list|,
literal|"id"
argument_list|)
argument_list|,
name|oner
argument_list|)
expr_stmt|;
block|}
DECL|method|testAliasing
specifier|public
name|void
name|testAliasing
parameter_list|()
throws|throws
name|Exception
block|{
name|String
name|oner
init|=
literal|"*[count(//doc)=1]"
decl_stmt|;
name|String
name|twor
init|=
literal|"*[count(//doc)=2]"
decl_stmt|;
name|String
name|nor
init|=
literal|"*[count(//doc)=0]"
decl_stmt|;
comment|// Aliasing
comment|// Single field
name|assertQ
argument_list|(
name|req
argument_list|(
literal|"defType"
argument_list|,
literal|"edismax"
argument_list|,
literal|"q"
argument_list|,
literal|"myalias:Zapp"
argument_list|)
argument_list|,
name|nor
argument_list|)
expr_stmt|;
name|assertQ
argument_list|(
name|req
argument_list|(
literal|"defType"
argument_list|,
literal|"edismax"
argument_list|,
literal|"q"
argument_list|,
literal|"myalias:Zapp"
argument_list|,
literal|"f.myalias.qf"
argument_list|,
literal|"name"
argument_list|)
argument_list|,
name|oner
argument_list|)
expr_stmt|;
comment|// Multi field
name|assertQ
argument_list|(
name|req
argument_list|(
literal|"defType"
argument_list|,
literal|"edismax"
argument_list|,
literal|"uf"
argument_list|,
literal|"myalias"
argument_list|,
literal|"q"
argument_list|,
literal|"myalias:(Zapp Obnoxious)"
argument_list|,
literal|"f.myalias.qf"
argument_list|,
literal|"name^2.0 mytrait_ss^5.0"
argument_list|,
literal|"mm"
argument_list|,
literal|"50%"
argument_list|)
argument_list|,
name|oner
argument_list|)
expr_stmt|;
comment|// Multi field
name|assertQ
argument_list|(
name|req
argument_list|(
literal|"defType"
argument_list|,
literal|"edismax"
argument_list|,
literal|"q"
argument_list|,
literal|"Zapp Obnoxious"
argument_list|,
literal|"f.myalias.qf"
argument_list|,
literal|"name^2.0 mytrait_ss^5.0"
argument_list|)
argument_list|,
name|nor
argument_list|)
expr_stmt|;
name|assertQ
argument_list|(
name|req
argument_list|(
literal|"defType"
argument_list|,
literal|"edismax"
argument_list|,
literal|"q"
argument_list|,
literal|"Zapp Obnoxious"
argument_list|,
literal|"qf"
argument_list|,
literal|"myalias^10.0"
argument_list|,
literal|"f.myalias.qf"
argument_list|,
literal|"name^2.0 mytrait_ss^5.0"
argument_list|)
argument_list|,
name|oner
argument_list|)
expr_stmt|;
name|assertQ
argument_list|(
name|req
argument_list|(
literal|"defType"
argument_list|,
literal|"edismax"
argument_list|,
literal|"q"
argument_list|,
literal|"Zapp Obnoxious"
argument_list|,
literal|"qf"
argument_list|,
literal|"myalias^10.0"
argument_list|,
literal|"f.myalias.qf"
argument_list|,
literal|"name^2.0 trait_ss^5.0"
argument_list|)
argument_list|,
name|twor
argument_list|)
expr_stmt|;
name|assertQ
argument_list|(
name|req
argument_list|(
literal|"defType"
argument_list|,
literal|"edismax"
argument_list|,
literal|"q"
argument_list|,
literal|"Zapp Obnoxious"
argument_list|,
literal|"qf"
argument_list|,
literal|"myalias^10.0"
argument_list|,
literal|"f.myalias.qf"
argument_list|,
literal|"name^2.0 trait_ss^5.0"
argument_list|,
literal|"mm"
argument_list|,
literal|"100%"
argument_list|)
argument_list|,
name|oner
argument_list|)
expr_stmt|;
name|assertQ
argument_list|(
name|req
argument_list|(
literal|"defType"
argument_list|,
literal|"edismax"
argument_list|,
literal|"q"
argument_list|,
literal|"Zapp Obnoxious"
argument_list|,
literal|"qf"
argument_list|,
literal|"who^10.0 where^3.0"
argument_list|,
literal|"f.who.qf"
argument_list|,
literal|"name^2.0"
argument_list|,
literal|"f.where.qf"
argument_list|,
literal|"mytrait_ss^5.0"
argument_list|)
argument_list|,
name|oner
argument_list|)
expr_stmt|;
name|assertQ
argument_list|(
name|req
argument_list|(
literal|"defType"
argument_list|,
literal|"edismax"
argument_list|,
literal|"q"
argument_list|,
literal|"Zapp Obnoxious"
argument_list|,
literal|"qf"
argument_list|,
literal|"myalias"
argument_list|,
literal|"f.myalias.qf"
argument_list|,
literal|"name mytrait_ss"
argument_list|,
literal|"uf"
argument_list|,
literal|"myalias"
argument_list|)
argument_list|,
name|oner
argument_list|)
expr_stmt|;
name|assertQ
argument_list|(
name|req
argument_list|(
literal|"defType"
argument_list|,
literal|"edismax"
argument_list|,
literal|"uf"
argument_list|,
literal|"who"
argument_list|,
literal|"q"
argument_list|,
literal|"who:(Zapp Obnoxious)"
argument_list|,
literal|"f.who.qf"
argument_list|,
literal|"name^2.0 trait_ss^5.0"
argument_list|,
literal|"qf"
argument_list|,
literal|"id"
argument_list|)
argument_list|,
name|twor
argument_list|)
expr_stmt|;
name|assertQ
argument_list|(
name|req
argument_list|(
literal|"defType"
argument_list|,
literal|"edismax"
argument_list|,
literal|"uf"
argument_list|,
literal|"* -name"
argument_list|,
literal|"q"
argument_list|,
literal|"who:(Zapp Obnoxious)"
argument_list|,
literal|"f.who.qf"
argument_list|,
literal|"name^2.0 trait_ss^5.0"
argument_list|)
argument_list|,
name|twor
argument_list|)
expr_stmt|;
block|}
DECL|method|testAliasingBoost
specifier|public
name|void
name|testAliasingBoost
parameter_list|()
throws|throws
name|Exception
block|{
name|assertQ
argument_list|(
name|req
argument_list|(
literal|"defType"
argument_list|,
literal|"edismax"
argument_list|,
literal|"q"
argument_list|,
literal|"Zapp Pig"
argument_list|,
literal|"qf"
argument_list|,
literal|"myalias"
argument_list|,
literal|"f.myalias.qf"
argument_list|,
literal|"name trait_ss^0.1"
argument_list|)
argument_list|,
literal|"//result/doc[1]/str[@name='id']=42"
argument_list|,
literal|"//result/doc[2]/str[@name='id']=47"
argument_list|)
expr_stmt|;
comment|//doc 42 should score higher than 46
name|assertQ
argument_list|(
name|req
argument_list|(
literal|"defType"
argument_list|,
literal|"edismax"
argument_list|,
literal|"q"
argument_list|,
literal|"Zapp Pig"
argument_list|,
literal|"qf"
argument_list|,
literal|"myalias^100 name"
argument_list|,
literal|"f.myalias.qf"
argument_list|,
literal|"trait_ss^0.1"
argument_list|)
argument_list|,
literal|"//result/doc[1]/str[@name='id']=47"
argument_list|,
literal|"//result/doc[2]/str[@name='id']=42"
argument_list|)
expr_stmt|;
comment|//Now the order should be inverse
block|}
DECL|method|testCyclicAliasing
specifier|public
name|void
name|testCyclicAliasing
parameter_list|()
throws|throws
name|Exception
block|{
try|try
block|{
name|ignoreException
argument_list|(
literal|".*Field aliases lead to a cycle.*"
argument_list|)
expr_stmt|;
try|try
block|{
name|h
operator|.
name|query
argument_list|(
name|req
argument_list|(
literal|"defType"
argument_list|,
literal|"edismax"
argument_list|,
literal|"q"
argument_list|,
literal|"blarg"
argument_list|,
literal|"qf"
argument_list|,
literal|"who"
argument_list|,
literal|"f.who.qf"
argument_list|,
literal|"name"
argument_list|,
literal|"f.name.qf"
argument_list|,
literal|"who"
argument_list|)
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"Simple cyclic alising not detected"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SolrException
name|e
parameter_list|)
block|{
name|assertTrue
argument_list|(
name|e
operator|.
name|getCause
argument_list|()
operator|.
name|getMessage
argument_list|()
operator|.
name|contains
argument_list|(
literal|"Field aliases lead to a cycle"
argument_list|)
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|h
operator|.
name|query
argument_list|(
name|req
argument_list|(
literal|"defType"
argument_list|,
literal|"edismax"
argument_list|,
literal|"q"
argument_list|,
literal|"blarg"
argument_list|,
literal|"qf"
argument_list|,
literal|"who"
argument_list|,
literal|"f.who.qf"
argument_list|,
literal|"name"
argument_list|,
literal|"f.name.qf"
argument_list|,
literal|"myalias"
argument_list|,
literal|"f.myalias.qf"
argument_list|,
literal|"who"
argument_list|)
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"Cyclic alising not detected"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SolrException
name|e
parameter_list|)
block|{
name|assertTrue
argument_list|(
name|e
operator|.
name|getCause
argument_list|()
operator|.
name|getMessage
argument_list|()
operator|.
name|contains
argument_list|(
literal|"Field aliases lead to a cycle"
argument_list|)
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|h
operator|.
name|query
argument_list|(
name|req
argument_list|(
literal|"defType"
argument_list|,
literal|"edismax"
argument_list|,
literal|"q"
argument_list|,
literal|"blarg"
argument_list|,
literal|"qf"
argument_list|,
literal|"field1"
argument_list|,
literal|"f.field1.qf"
argument_list|,
literal|"field2 field3"
argument_list|,
literal|"f.field2.qf"
argument_list|,
literal|"field4 field5"
argument_list|,
literal|"f.field4.qf"
argument_list|,
literal|"field5"
argument_list|,
literal|"f.field5.qf"
argument_list|,
literal|"field6"
argument_list|,
literal|"f.field3.qf"
argument_list|,
literal|"field6"
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SolrException
name|e
parameter_list|)
block|{
name|fail
argument_list|(
literal|"This is not cyclic alising"
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|h
operator|.
name|query
argument_list|(
name|req
argument_list|(
literal|"defType"
argument_list|,
literal|"edismax"
argument_list|,
literal|"q"
argument_list|,
literal|"blarg"
argument_list|,
literal|"qf"
argument_list|,
literal|"field1"
argument_list|,
literal|"f.field1.qf"
argument_list|,
literal|"field2 field3"
argument_list|,
literal|"f.field2.qf"
argument_list|,
literal|"field4 field5"
argument_list|,
literal|"f.field4.qf"
argument_list|,
literal|"field5"
argument_list|,
literal|"f.field5.qf"
argument_list|,
literal|"field4"
argument_list|)
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"Cyclic alising not detected"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SolrException
name|e
parameter_list|)
block|{
name|assertTrue
argument_list|(
name|e
operator|.
name|getCause
argument_list|()
operator|.
name|getMessage
argument_list|()
operator|.
name|contains
argument_list|(
literal|"Field aliases lead to a cycle"
argument_list|)
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|h
operator|.
name|query
argument_list|(
name|req
argument_list|(
literal|"defType"
argument_list|,
literal|"edismax"
argument_list|,
literal|"q"
argument_list|,
literal|"who:(Zapp Pig)"
argument_list|,
literal|"qf"
argument_list|,
literal|"field1"
argument_list|,
literal|"f.who.qf"
argument_list|,
literal|"name"
argument_list|,
literal|"f.name.qf"
argument_list|,
literal|"myalias"
argument_list|,
literal|"f.myalias.qf"
argument_list|,
literal|"who"
argument_list|)
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"Cyclic alising not detected"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SolrException
name|e
parameter_list|)
block|{
name|assertTrue
argument_list|(
name|e
operator|.
name|getCause
argument_list|()
operator|.
name|getMessage
argument_list|()
operator|.
name|contains
argument_list|(
literal|"Field aliases lead to a cycle"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|resetExceptionIgnores
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|testOperatorsWithLiteralColons
specifier|public
name|void
name|testOperatorsWithLiteralColons
parameter_list|()
block|{
name|assertU
argument_list|(
name|adoc
argument_list|(
literal|"id"
argument_list|,
literal|"142"
argument_list|,
literal|"a_s"
argument_list|,
literal|"bogus:xxx"
argument_list|,
literal|"text_s"
argument_list|,
literal|"yak"
argument_list|)
argument_list|)
expr_stmt|;
name|assertU
argument_list|(
name|adoc
argument_list|(
literal|"id"
argument_list|,
literal|"143"
argument_list|,
literal|"a_s"
argument_list|,
literal|"bogus:xxx"
argument_list|)
argument_list|)
expr_stmt|;
name|assertU
argument_list|(
name|adoc
argument_list|(
literal|"id"
argument_list|,
literal|"144"
argument_list|,
literal|"text_s"
argument_list|,
literal|"yak"
argument_list|)
argument_list|)
expr_stmt|;
name|assertU
argument_list|(
name|adoc
argument_list|(
literal|"id"
argument_list|,
literal|"145"
argument_list|,
literal|"a_s"
argument_list|,
literal|"a_s:xxx"
argument_list|,
literal|"text_s"
argument_list|,
literal|"yak"
argument_list|)
argument_list|)
expr_stmt|;
name|assertU
argument_list|(
name|adoc
argument_list|(
literal|"id"
argument_list|,
literal|"146"
argument_list|,
literal|"a_s"
argument_list|,
literal|"a_s:xxx"
argument_list|)
argument_list|)
expr_stmt|;
name|assertU
argument_list|(
name|adoc
argument_list|(
literal|"id"
argument_list|,
literal|"147"
argument_list|,
literal|"a_s"
argument_list|,
literal|"AND"
argument_list|,
literal|"a_s"
argument_list|,
literal|"NOT"
argument_list|)
argument_list|)
expr_stmt|;
name|assertU
argument_list|(
name|commit
argument_list|()
argument_list|)
expr_stmt|;
name|assertQ
argument_list|(
name|req
argument_list|(
literal|"q"
argument_list|,
literal|"bogus:xxx AND text_s:yak"
argument_list|,
literal|"fl"
argument_list|,
literal|"id"
argument_list|,
literal|"qf"
argument_list|,
literal|"a_s b_s"
argument_list|,
literal|"defType"
argument_list|,
literal|"edismax"
argument_list|,
literal|"mm"
argument_list|,
literal|"0"
argument_list|)
argument_list|,
literal|"//*[@numFound='1']"
argument_list|,
literal|"//str[@name='id'][.='142']"
argument_list|)
expr_stmt|;
name|assertQ
argument_list|(
name|req
argument_list|(
literal|"q"
argument_list|,
literal|"a_s:xxx AND text_s:yak"
argument_list|,
literal|"fl"
argument_list|,
literal|"id"
argument_list|,
literal|"qf"
argument_list|,
literal|"a_s b_s"
argument_list|,
literal|"defType"
argument_list|,
literal|"edismax"
argument_list|,
literal|"mm"
argument_list|,
literal|"0"
argument_list|,
literal|"uf"
argument_list|,
literal|"text_s"
argument_list|)
argument_list|,
literal|"//*[@numFound='1']"
argument_list|,
literal|"//str[@name='id'][.='145']"
argument_list|)
expr_stmt|;
name|assertQ
argument_list|(
name|req
argument_list|(
literal|"q"
argument_list|,
literal|"NOT bogus:xxx +text_s:yak"
argument_list|,
literal|"fl"
argument_list|,
literal|"id"
argument_list|,
literal|"qf"
argument_list|,
literal|"a_s b_s"
argument_list|,
literal|"defType"
argument_list|,
literal|"edismax"
argument_list|,
literal|"mm"
argument_list|,
literal|"0"
argument_list|,
literal|"debugQuery"
argument_list|,
literal|"true"
argument_list|)
argument_list|,
literal|"//*[@numFound='2']"
argument_list|,
literal|"//str[@name='id'][.='144']"
argument_list|,
literal|"//str[@name='id'][.='145']"
argument_list|)
expr_stmt|;
name|assertQ
argument_list|(
name|req
argument_list|(
literal|"q"
argument_list|,
literal|"NOT a_s:xxx +text_s:yak"
argument_list|,
literal|"fl"
argument_list|,
literal|"id"
argument_list|,
literal|"qf"
argument_list|,
literal|"a_s b_s"
argument_list|,
literal|"defType"
argument_list|,
literal|"edismax"
argument_list|,
literal|"mm"
argument_list|,
literal|"0"
argument_list|,
literal|"uf"
argument_list|,
literal|"text_s"
argument_list|)
argument_list|,
literal|"//*[@numFound='2']"
argument_list|,
literal|"//str[@name='id'][.='142']"
argument_list|,
literal|"//str[@name='id'][.='144']"
argument_list|)
expr_stmt|;
name|assertQ
argument_list|(
name|req
argument_list|(
literal|"q"
argument_list|,
literal|"+bogus:xxx yak"
argument_list|,
literal|"fl"
argument_list|,
literal|"id"
argument_list|,
literal|"qf"
argument_list|,
literal|"a_s b_s text_s"
argument_list|,
literal|"defType"
argument_list|,
literal|"edismax"
argument_list|,
literal|"mm"
argument_list|,
literal|"0"
argument_list|)
argument_list|,
literal|"//*[@numFound='2']"
argument_list|,
literal|"//str[@name='id'][.='142']"
argument_list|,
literal|"//str[@name='id'][.='143']"
argument_list|)
expr_stmt|;
name|assertQ
argument_list|(
name|req
argument_list|(
literal|"q"
argument_list|,
literal|"+a_s:xxx yak"
argument_list|,
literal|"fl"
argument_list|,
literal|"id"
argument_list|,
literal|"qf"
argument_list|,
literal|"a_s b_s text_s"
argument_list|,
literal|"defType"
argument_list|,
literal|"edismax"
argument_list|,
literal|"mm"
argument_list|,
literal|"0"
argument_list|,
literal|"uf"
argument_list|,
literal|"b_s"
argument_list|)
argument_list|,
literal|"//*[@numFound='2']"
argument_list|,
literal|"//str[@name='id'][.='145']"
argument_list|,
literal|"//str[@name='id'][.='146']"
argument_list|)
expr_stmt|;
block|}
comment|// test phrase fields including pf2 pf3 and phrase slop
DECL|method|testPfPs
specifier|public
name|void
name|testPfPs
parameter_list|()
block|{
name|assertU
argument_list|(
name|adoc
argument_list|(
literal|"id"
argument_list|,
literal|"s0"
argument_list|,
literal|"phrase_sw"
argument_list|,
literal|"foo bar a b c"
argument_list|,
literal|"boost_d"
argument_list|,
literal|"1.0"
argument_list|)
argument_list|)
expr_stmt|;
name|assertU
argument_list|(
name|adoc
argument_list|(
literal|"id"
argument_list|,
literal|"s1"
argument_list|,
literal|"phrase_sw"
argument_list|,
literal|"foo a bar b c"
argument_list|,
literal|"boost_d"
argument_list|,
literal|"2.0"
argument_list|)
argument_list|)
expr_stmt|;
name|assertU
argument_list|(
name|adoc
argument_list|(
literal|"id"
argument_list|,
literal|"s2"
argument_list|,
literal|"phrase_sw"
argument_list|,
literal|"foo a b bar c"
argument_list|,
literal|"boost_d"
argument_list|,
literal|"3.0"
argument_list|)
argument_list|)
expr_stmt|;
name|assertU
argument_list|(
name|adoc
argument_list|(
literal|"id"
argument_list|,
literal|"s3"
argument_list|,
literal|"phrase_sw"
argument_list|,
literal|"foo a b c bar"
argument_list|,
literal|"boost_d"
argument_list|,
literal|"4.0"
argument_list|)
argument_list|)
expr_stmt|;
name|assertU
argument_list|(
name|commit
argument_list|()
argument_list|)
expr_stmt|;
name|assertQ
argument_list|(
literal|"default order assumption wrong"
argument_list|,
name|req
argument_list|(
literal|"q"
argument_list|,
literal|"foo bar"
argument_list|,
literal|"qf"
argument_list|,
literal|"phrase_sw"
argument_list|,
literal|"bf"
argument_list|,
literal|"boost_d"
argument_list|,
literal|"fl"
argument_list|,
literal|"score,*"
argument_list|,
literal|"defType"
argument_list|,
literal|"edismax"
argument_list|)
argument_list|,
literal|"//doc[1]/str[@name='id'][.='s3']"
argument_list|,
literal|"//doc[2]/str[@name='id'][.='s2']"
argument_list|,
literal|"//doc[3]/str[@name='id'][.='s1']"
argument_list|,
literal|"//doc[4]/str[@name='id'][.='s0']"
argument_list|)
expr_stmt|;
name|assertQ
argument_list|(
literal|"pf not working"
argument_list|,
name|req
argument_list|(
literal|"q"
argument_list|,
literal|"foo bar"
argument_list|,
literal|"qf"
argument_list|,
literal|"phrase_sw"
argument_list|,
literal|"pf"
argument_list|,
literal|"phrase_sw^10"
argument_list|,
literal|"bf"
argument_list|,
literal|"boost_d"
argument_list|,
literal|"fl"
argument_list|,
literal|"score,*"
argument_list|,
literal|"defType"
argument_list|,
literal|"edismax"
argument_list|)
argument_list|,
literal|"//doc[1]/str[@name='id'][.='s0']"
argument_list|)
expr_stmt|;
name|assertQ
argument_list|(
literal|"pf2 not working"
argument_list|,
name|req
argument_list|(
literal|"q"
argument_list|,
literal|"foo bar"
argument_list|,
literal|"qf"
argument_list|,
literal|"phrase_sw"
argument_list|,
literal|"pf2"
argument_list|,
literal|"phrase_sw^10"
argument_list|,
literal|"bf"
argument_list|,
literal|"boost_d"
argument_list|,
literal|"fl"
argument_list|,
literal|"score,*"
argument_list|,
literal|"defType"
argument_list|,
literal|"edismax"
argument_list|)
argument_list|,
literal|"//doc[1]/str[@name='id'][.='s0']"
argument_list|)
expr_stmt|;
name|assertQ
argument_list|(
literal|"pf3 not working"
argument_list|,
name|req
argument_list|(
literal|"q"
argument_list|,
literal|"a b bar"
argument_list|,
literal|"qf"
argument_list|,
literal|"phrase_sw"
argument_list|,
literal|"pf3"
argument_list|,
literal|"phrase_sw^10"
argument_list|,
literal|"bf"
argument_list|,
literal|"boost_d"
argument_list|,
literal|"fl"
argument_list|,
literal|"score,*"
argument_list|,
literal|"defType"
argument_list|,
literal|"edismax"
argument_list|)
argument_list|,
literal|"//doc[1]/str[@name='id'][.='s2']"
argument_list|)
expr_stmt|;
name|assertQ
argument_list|(
literal|"ps not working for pf2"
argument_list|,
name|req
argument_list|(
literal|"q"
argument_list|,
literal|"bar foo"
argument_list|,
literal|"qf"
argument_list|,
literal|"phrase_sw"
argument_list|,
literal|"pf2"
argument_list|,
literal|"phrase_sw^10"
argument_list|,
literal|"ps"
argument_list|,
literal|"2"
argument_list|,
literal|"bf"
argument_list|,
literal|"boost_d"
argument_list|,
literal|"fl"
argument_list|,
literal|"score,*"
argument_list|,
literal|"defType"
argument_list|,
literal|"edismax"
argument_list|)
argument_list|,
literal|"//doc[1]/str[@name='id'][.='s0']"
argument_list|)
expr_stmt|;
name|assertQ
argument_list|(
literal|"ps not working for pf3"
argument_list|,
name|req
argument_list|(
literal|"q"
argument_list|,
literal|"a bar foo"
argument_list|,
literal|"qf"
argument_list|,
literal|"phrase_sw"
argument_list|,
literal|"pf3"
argument_list|,
literal|"phrase_sw^10"
argument_list|,
literal|"ps"
argument_list|,
literal|"3"
argument_list|,
literal|"bf"
argument_list|,
literal|"boost_d"
argument_list|,
literal|"fl"
argument_list|,
literal|"score,*"
argument_list|,
literal|"debugQuery"
argument_list|,
literal|"true"
argument_list|,
literal|"defType"
argument_list|,
literal|"edismax"
argument_list|)
argument_list|,
literal|"//doc[1]/str[@name='id'][.='s1']"
argument_list|)
expr_stmt|;
name|assertQ
argument_list|(
literal|"ps/ps2/ps3 with default slop overrides not working"
argument_list|,
name|req
argument_list|(
literal|"q"
argument_list|,
literal|"zzzz xxxx cccc vvvv"
argument_list|,
literal|"qf"
argument_list|,
literal|"phrase_sw"
argument_list|,
literal|"pf"
argument_list|,
literal|"phrase_sw~1^10 phrase_sw~2^20 phrase_sw^30"
argument_list|,
literal|"pf2"
argument_list|,
literal|"phrase_sw~2^22 phrase_sw^33"
argument_list|,
literal|"pf3"
argument_list|,
literal|"phrase_sw~2^222 phrase_sw^333"
argument_list|,
literal|"ps"
argument_list|,
literal|"3"
argument_list|,
literal|"defType"
argument_list|,
literal|"edismax"
argument_list|,
literal|"debugQuery"
argument_list|,
literal|"true"
argument_list|)
argument_list|,
literal|"//str[@name='parsedquery'][contains(.,'(phrase_sw:\"zzzz xxxx cccc vvvv\"~1)^10.0')]"
argument_list|,
literal|"//str[@name='parsedquery'][contains(.,'(phrase_sw:\"zzzz xxxx cccc vvvv\"~2)^20.0')]"
argument_list|,
literal|"//str[@name='parsedquery'][contains(.,'(phrase_sw:\"zzzz xxxx cccc vvvv\"~3)^30.0')]"
argument_list|,
literal|"//str[@name='parsedquery'][contains(.,'(phrase_sw:\"zzzz xxxx\"~2)^22.0')]"
argument_list|,
literal|"//str[@name='parsedquery'][contains(.,'(phrase_sw:\"xxxx cccc\"~2)^22.0')]"
argument_list|,
literal|"//str[@name='parsedquery'][contains(.,'(phrase_sw:\"cccc vvvv\"~2)^22.0')]"
argument_list|,
literal|"//str[@name='parsedquery'][contains(.,'(phrase_sw:\"zzzz xxxx\"~3)^33.0')]"
argument_list|,
literal|"//str[@name='parsedquery'][contains(.,'(phrase_sw:\"xxxx cccc\"~3)^33.0')]"
argument_list|,
literal|"//str[@name='parsedquery'][contains(.,'(phrase_sw:\"cccc vvvv\"~3)^33.0')]"
argument_list|,
literal|"//str[@name='parsedquery'][contains(.,'(phrase_sw:\"zzzz xxxx cccc\"~2)^222.0')]"
argument_list|,
literal|"//str[@name='parsedquery'][contains(.,'(phrase_sw:\"xxxx cccc vvvv\"~2)^222.0')]"
argument_list|,
literal|"//str[@name='parsedquery'][contains(.,'(phrase_sw:\"zzzz xxxx cccc\"~3)^333.0')]"
argument_list|,
literal|"//str[@name='parsedquery'][contains(.,'(phrase_sw:\"xxxx cccc vvvv\"~3)^333.0')]"
argument_list|)
expr_stmt|;
name|assertQ
argument_list|(
literal|"ps2 not working"
argument_list|,
name|req
argument_list|(
literal|"q"
argument_list|,
literal|"bar foo"
argument_list|,
literal|"qf"
argument_list|,
literal|"phrase_sw"
argument_list|,
literal|"pf2"
argument_list|,
literal|"phrase_sw^10"
argument_list|,
literal|"ps2"
argument_list|,
literal|"2"
argument_list|,
literal|"bf"
argument_list|,
literal|"boost_d"
argument_list|,
literal|"fl"
argument_list|,
literal|"score,*"
argument_list|,
literal|"defType"
argument_list|,
literal|"edismax"
argument_list|)
argument_list|,
literal|"//doc[1]/str[@name='id'][.='s0']"
argument_list|)
expr_stmt|;
name|assertQ
argument_list|(
literal|"Specifying slop in pf2 param not working"
argument_list|,
name|req
argument_list|(
literal|"q"
argument_list|,
literal|"bar foo"
argument_list|,
literal|"qf"
argument_list|,
literal|"phrase_sw"
argument_list|,
literal|"pf2"
argument_list|,
literal|"phrase_sw~2^10"
argument_list|,
literal|"bf"
argument_list|,
literal|"boost_d"
argument_list|,
literal|"fl"
argument_list|,
literal|"score,*"
argument_list|,
literal|"defType"
argument_list|,
literal|"edismax"
argument_list|)
argument_list|,
literal|"//doc[1]/str[@name='id'][.='s0']"
argument_list|)
expr_stmt|;
name|assertQ
argument_list|(
literal|"Slop in ps2 parameter should override ps"
argument_list|,
name|req
argument_list|(
literal|"q"
argument_list|,
literal|"bar foo"
argument_list|,
literal|"qf"
argument_list|,
literal|"phrase_sw"
argument_list|,
literal|"pf2"
argument_list|,
literal|"phrase_sw^10"
argument_list|,
literal|"ps"
argument_list|,
literal|"0"
argument_list|,
literal|"ps2"
argument_list|,
literal|"2"
argument_list|,
literal|"bf"
argument_list|,
literal|"boost_d"
argument_list|,
literal|"fl"
argument_list|,
literal|"score,*"
argument_list|,
literal|"defType"
argument_list|,
literal|"edismax"
argument_list|)
argument_list|,
literal|"//doc[1]/str[@name='id'][.='s0']"
argument_list|)
expr_stmt|;
name|assertQ
argument_list|(
literal|"ps3 not working"
argument_list|,
name|req
argument_list|(
literal|"q"
argument_list|,
literal|"a bar foo"
argument_list|,
literal|"qf"
argument_list|,
literal|"phrase_sw"
argument_list|,
literal|"pf3"
argument_list|,
literal|"phrase_sw^10"
argument_list|,
literal|"ps3"
argument_list|,
literal|"3"
argument_list|,
literal|"bf"
argument_list|,
literal|"boost_d"
argument_list|,
literal|"fl"
argument_list|,
literal|"score,*"
argument_list|,
literal|"defType"
argument_list|,
literal|"edismax"
argument_list|)
argument_list|,
literal|"//doc[1]/str[@name='id'][.='s1']"
argument_list|)
expr_stmt|;
name|assertQ
argument_list|(
literal|"Specifying slop in pf3 param not working"
argument_list|,
name|req
argument_list|(
literal|"q"
argument_list|,
literal|"a bar foo"
argument_list|,
literal|"qf"
argument_list|,
literal|"phrase_sw"
argument_list|,
literal|"pf3"
argument_list|,
literal|"phrase_sw~3^10"
argument_list|,
literal|"bf"
argument_list|,
literal|"boost_d"
argument_list|,
literal|"fl"
argument_list|,
literal|"score,*"
argument_list|,
literal|"defType"
argument_list|,
literal|"edismax"
argument_list|)
argument_list|,
literal|"//doc[1]/str[@name='id'][.='s1']"
argument_list|)
expr_stmt|;
name|assertQ
argument_list|(
literal|"ps2 should not override slop specified inline in pf2"
argument_list|,
name|req
argument_list|(
literal|"q"
argument_list|,
literal|"zzzz xxxx cccc vvvv"
argument_list|,
literal|"qf"
argument_list|,
literal|"phrase_sw"
argument_list|,
literal|"pf2"
argument_list|,
literal|"phrase_sw~2^22"
argument_list|,
literal|"ps2"
argument_list|,
literal|"4"
argument_list|,
literal|"defType"
argument_list|,
literal|"edismax"
argument_list|,
literal|"debugQuery"
argument_list|,
literal|"true"
argument_list|)
argument_list|,
literal|"//str[@name='parsedquery'][contains(.,'(phrase_sw:\"zzzz xxxx\"~2)^22.0')]"
argument_list|)
expr_stmt|;
name|assertQ
argument_list|(
literal|"phrase field queries spanning multiple fields should be within their own dismax queries"
argument_list|,
name|req
argument_list|(
literal|"q"
argument_list|,
literal|"aaaa bbbb cccc"
argument_list|,
literal|"qf"
argument_list|,
literal|"phrase_sw phrase1_sw"
argument_list|,
literal|"pf2"
argument_list|,
literal|"phrase_sw phrase1_sw"
argument_list|,
literal|"pf3"
argument_list|,
literal|"phrase_sw phrase1_sw"
argument_list|,
literal|"defType"
argument_list|,
literal|"edismax"
argument_list|,
literal|"debugQuery"
argument_list|,
literal|"true"
argument_list|)
argument_list|,
literal|"//str[@name='parsedquery'][contains(.,'(phrase_sw:\"aaaa bbbb\" | phrase1_sw:\"aaaa bbbb\")')]"
argument_list|,
literal|"//str[@name='parsedquery'][contains(.,'(phrase_sw:\"bbbb cccc\" | phrase1_sw:\"bbbb cccc\")')]"
argument_list|,
literal|"//str[@name='parsedquery'][contains(.,'(phrase_sw:\"aaaa bbbb cccc\" | phrase1_sw:\"aaaa bbbb cccc\")')]"
argument_list|)
expr_stmt|;
block|}
comment|/**    * verify that all reserved characters are properly escaped when being set in    * {@link org.apache.solr.search.ExtendedDismaxQParser.Clause#val}.    *    * @see ExtendedDismaxQParser#splitIntoClauses(String, boolean)    */
annotation|@
name|Test
DECL|method|testEscapingOfReservedCharacters
specifier|public
name|void
name|testEscapingOfReservedCharacters
parameter_list|()
throws|throws
name|Exception
block|{
comment|// create a document that contains all reserved characters
name|String
name|allReservedCharacters
init|=
literal|"!():^[]{}~*?\"+-\\|&/"
decl_stmt|;
name|assertU
argument_list|(
name|adoc
argument_list|(
literal|"id"
argument_list|,
literal|"reservedChars"
argument_list|,
literal|"name"
argument_list|,
name|allReservedCharacters
argument_list|,
literal|"cat_s"
argument_list|,
literal|"foo/"
argument_list|)
argument_list|)
expr_stmt|;
name|assertU
argument_list|(
name|commit
argument_list|()
argument_list|)
expr_stmt|;
comment|// the backslash needs to be manually escaped (the query parser sees the raw backslash as an escape the subsequent
comment|// character)
name|String
name|query
init|=
name|allReservedCharacters
operator|.
name|replace
argument_list|(
literal|"\\"
argument_list|,
literal|"\\\\"
argument_list|)
decl_stmt|;
comment|// query for all those reserved characters. This will fail to parse in the initial parse, meaning that the escaped
comment|// query will then be used
name|assertQ
argument_list|(
literal|"Escaping reserved characters"
argument_list|,
name|req
argument_list|(
literal|"q"
argument_list|,
name|query
argument_list|,
literal|"qf"
argument_list|,
literal|"name"
argument_list|,
literal|"mm"
argument_list|,
literal|"100%"
argument_list|,
literal|"defType"
argument_list|,
literal|"edismax"
argument_list|)
argument_list|,
literal|"*[count(//doc)=1]"
argument_list|)
expr_stmt|;
comment|// Query string field 'cat_s' for special char / - causes SyntaxError without patch SOLR-3467
name|assertQ
argument_list|(
literal|"Escaping string with reserved / character"
argument_list|,
name|req
argument_list|(
literal|"q"
argument_list|,
literal|"foo/"
argument_list|,
literal|"qf"
argument_list|,
literal|"cat_s"
argument_list|,
literal|"mm"
argument_list|,
literal|"100%"
argument_list|,
literal|"defType"
argument_list|,
literal|"edismax"
argument_list|)
argument_list|,
literal|"*[count(//doc)=1]"
argument_list|)
expr_stmt|;
name|assertQ
argument_list|(
literal|"Might be double-escaping a client-escaped colon"
argument_list|,
name|req
argument_list|(
literal|"q"
argument_list|,
literal|"text_sw:(theos OR thistokenhasa\\:preescapedcolon OR theou)"
argument_list|,
literal|"defType"
argument_list|,
literal|"edismax"
argument_list|,
literal|"qf"
argument_list|,
literal|"id"
argument_list|)
argument_list|,
literal|"*[count(//doc)=3]"
argument_list|)
expr_stmt|;
name|assertQ
argument_list|(
literal|"Might be double-escaping a client-escaped colon"
argument_list|,
name|req
argument_list|(
literal|"q"
argument_list|,
literal|"text_sw:(theos OR thistokenhasa\\:preescapedcolon OR theou)"
argument_list|,
literal|"defType"
argument_list|,
literal|"edismax"
argument_list|,
literal|"qf"
argument_list|,
literal|"text"
argument_list|)
argument_list|,
literal|"*[count(//doc)=3]"
argument_list|)
expr_stmt|;
block|}
comment|/**    * SOLR-3589: Edismax parser does not honor mm parameter if analyzer splits a token    */
DECL|method|testCJK
specifier|public
name|void
name|testCJK
parameter_list|()
throws|throws
name|Exception
block|{
name|assertQ
argument_list|(
literal|"test cjk (disjunction)"
argument_list|,
name|req
argument_list|(
literal|"q"
argument_list|,
literal|"å¤§äºæ¹¾"
argument_list|,
literal|"qf"
argument_list|,
literal|"standardtok"
argument_list|,
literal|"mm"
argument_list|,
literal|"0%"
argument_list|,
literal|"defType"
argument_list|,
literal|"edismax"
argument_list|)
argument_list|,
literal|"*[count(//doc)=3]"
argument_list|)
expr_stmt|;
name|assertQ
argument_list|(
literal|"test cjk (minShouldMatch)"
argument_list|,
name|req
argument_list|(
literal|"q"
argument_list|,
literal|"å¤§äºæ¹¾"
argument_list|,
literal|"qf"
argument_list|,
literal|"standardtok"
argument_list|,
literal|"mm"
argument_list|,
literal|"67%"
argument_list|,
literal|"defType"
argument_list|,
literal|"edismax"
argument_list|)
argument_list|,
literal|"*[count(//doc)=2]"
argument_list|)
expr_stmt|;
name|assertQ
argument_list|(
literal|"test cjk (conjunction)"
argument_list|,
name|req
argument_list|(
literal|"q"
argument_list|,
literal|"å¤§äºæ¹¾"
argument_list|,
literal|"qf"
argument_list|,
literal|"standardtok"
argument_list|,
literal|"mm"
argument_list|,
literal|"100%"
argument_list|,
literal|"defType"
argument_list|,
literal|"edismax"
argument_list|)
argument_list|,
literal|"*[count(//doc)=1]"
argument_list|)
expr_stmt|;
block|}
comment|/**     * test that minShouldMatch works with aliasing    * for implicit boolean queries    */
DECL|method|testCJKAliasing
specifier|public
name|void
name|testCJKAliasing
parameter_list|()
throws|throws
name|Exception
block|{
comment|// single field
name|assertQ
argument_list|(
literal|"test cjk (aliasing+disjunction)"
argument_list|,
name|req
argument_list|(
literal|"q"
argument_list|,
literal|"myalias:å¤§äºæ¹¾"
argument_list|,
literal|"f.myalias.qf"
argument_list|,
literal|"standardtok"
argument_list|,
literal|"mm"
argument_list|,
literal|"0%"
argument_list|,
literal|"defType"
argument_list|,
literal|"edismax"
argument_list|)
argument_list|,
literal|"*[count(//doc)=3]"
argument_list|)
expr_stmt|;
name|assertQ
argument_list|(
literal|"test cjk (aliasing+minShouldMatch)"
argument_list|,
name|req
argument_list|(
literal|"q"
argument_list|,
literal|"myalias:å¤§äºæ¹¾"
argument_list|,
literal|"f.myalias.qf"
argument_list|,
literal|"standardtok"
argument_list|,
literal|"mm"
argument_list|,
literal|"67%"
argument_list|,
literal|"defType"
argument_list|,
literal|"edismax"
argument_list|)
argument_list|,
literal|"*[count(//doc)=2]"
argument_list|)
expr_stmt|;
name|assertQ
argument_list|(
literal|"test cjk (aliasing+conjunction)"
argument_list|,
name|req
argument_list|(
literal|"q"
argument_list|,
literal|"myalias:å¤§äºæ¹¾"
argument_list|,
literal|"f.myalias.qf"
argument_list|,
literal|"standardtok"
argument_list|,
literal|"mm"
argument_list|,
literal|"100%"
argument_list|,
literal|"defType"
argument_list|,
literal|"edismax"
argument_list|)
argument_list|,
literal|"*[count(//doc)=1]"
argument_list|)
expr_stmt|;
comment|// multifield
name|assertQ
argument_list|(
literal|"test cjk (aliasing+disjunction)"
argument_list|,
name|req
argument_list|(
literal|"q"
argument_list|,
literal|"myalias:å¤§äºæ¹¾"
argument_list|,
literal|"f.myalias.qf"
argument_list|,
literal|"standardtok HTMLstandardtok"
argument_list|,
literal|"mm"
argument_list|,
literal|"0%"
argument_list|,
literal|"defType"
argument_list|,
literal|"edismax"
argument_list|)
argument_list|,
literal|"*[count(//doc)=6]"
argument_list|)
expr_stmt|;
name|assertQ
argument_list|(
literal|"test cjk (aliasing+minShouldMatch)"
argument_list|,
name|req
argument_list|(
literal|"q"
argument_list|,
literal|"myalias:å¤§äºæ¹¾"
argument_list|,
literal|"f.myalias.qf"
argument_list|,
literal|"standardtok HTMLstandardtok"
argument_list|,
literal|"mm"
argument_list|,
literal|"67%"
argument_list|,
literal|"defType"
argument_list|,
literal|"edismax"
argument_list|)
argument_list|,
literal|"*[count(//doc)=4]"
argument_list|)
expr_stmt|;
name|assertQ
argument_list|(
literal|"test cjk (aliasing+conjunction)"
argument_list|,
name|req
argument_list|(
literal|"q"
argument_list|,
literal|"myalias:å¤§äºæ¹¾"
argument_list|,
literal|"f.myalias.qf"
argument_list|,
literal|"standardtok HTMLstandardtok"
argument_list|,
literal|"mm"
argument_list|,
literal|"100%"
argument_list|,
literal|"defType"
argument_list|,
literal|"edismax"
argument_list|)
argument_list|,
literal|"*[count(//doc)=2]"
argument_list|)
expr_stmt|;
block|}
comment|/** Test that we apply boosts correctly */
DECL|method|testCJKBoosts
specifier|public
name|void
name|testCJKBoosts
parameter_list|()
throws|throws
name|Exception
block|{
name|assertQ
argument_list|(
literal|"test cjk (disjunction)"
argument_list|,
name|req
argument_list|(
literal|"q"
argument_list|,
literal|"å¤§äºæ¹¾"
argument_list|,
literal|"qf"
argument_list|,
literal|"standardtok^2 HTMLstandardtok"
argument_list|,
literal|"mm"
argument_list|,
literal|"0%"
argument_list|,
literal|"defType"
argument_list|,
literal|"edismax"
argument_list|)
argument_list|,
literal|"*[count(//doc)=6]"
argument_list|,
literal|"//result/doc[1]/str[@name='id'][.='57']"
argument_list|)
expr_stmt|;
name|assertQ
argument_list|(
literal|"test cjk (minShouldMatch)"
argument_list|,
name|req
argument_list|(
literal|"q"
argument_list|,
literal|"å¤§äºæ¹¾"
argument_list|,
literal|"qf"
argument_list|,
literal|"standardtok^2 HTMLstandardtok"
argument_list|,
literal|"mm"
argument_list|,
literal|"67%"
argument_list|,
literal|"defType"
argument_list|,
literal|"edismax"
argument_list|)
argument_list|,
literal|"*[count(//doc)=4]"
argument_list|,
literal|"//result/doc[1]/str[@name='id'][.='57']"
argument_list|)
expr_stmt|;
name|assertQ
argument_list|(
literal|"test cjk (conjunction)"
argument_list|,
name|req
argument_list|(
literal|"q"
argument_list|,
literal|"å¤§äºæ¹¾"
argument_list|,
literal|"qf"
argument_list|,
literal|"standardtok^2 HTMLstandardtok"
argument_list|,
literal|"mm"
argument_list|,
literal|"100%"
argument_list|,
literal|"defType"
argument_list|,
literal|"edismax"
argument_list|)
argument_list|,
literal|"*[count(//doc)=2]"
argument_list|,
literal|"//result/doc[1]/str[@name='id'][.='57']"
argument_list|)
expr_stmt|;
comment|// now boost the other field
name|assertQ
argument_list|(
literal|"test cjk (disjunction)"
argument_list|,
name|req
argument_list|(
literal|"q"
argument_list|,
literal|"å¤§äºæ¹¾"
argument_list|,
literal|"qf"
argument_list|,
literal|"standardtok HTMLstandardtok^2"
argument_list|,
literal|"mm"
argument_list|,
literal|"0%"
argument_list|,
literal|"defType"
argument_list|,
literal|"edismax"
argument_list|)
argument_list|,
literal|"*[count(//doc)=6]"
argument_list|,
literal|"//result/doc[1]/str[@name='id'][.='60']"
argument_list|)
expr_stmt|;
name|assertQ
argument_list|(
literal|"test cjk (minShouldMatch)"
argument_list|,
name|req
argument_list|(
literal|"q"
argument_list|,
literal|"å¤§äºæ¹¾"
argument_list|,
literal|"qf"
argument_list|,
literal|"standardtok HTMLstandardtok^2"
argument_list|,
literal|"mm"
argument_list|,
literal|"67%"
argument_list|,
literal|"defType"
argument_list|,
literal|"edismax"
argument_list|)
argument_list|,
literal|"*[count(//doc)=4]"
argument_list|,
literal|"//result/doc[1]/str[@name='id'][.='60']"
argument_list|)
expr_stmt|;
name|assertQ
argument_list|(
literal|"test cjk (conjunction)"
argument_list|,
name|req
argument_list|(
literal|"q"
argument_list|,
literal|"å¤§äºæ¹¾"
argument_list|,
literal|"qf"
argument_list|,
literal|"standardtok HTMLstandardtok^2"
argument_list|,
literal|"mm"
argument_list|,
literal|"100%"
argument_list|,
literal|"defType"
argument_list|,
literal|"edismax"
argument_list|)
argument_list|,
literal|"*[count(//doc)=2]"
argument_list|,
literal|"//result/doc[1]/str[@name='id'][.='60']"
argument_list|)
expr_stmt|;
block|}
comment|/** always apply minShouldMatch to the inner booleanqueries    *  created from whitespace, as these are never structured lucene queries    *  but only come from unstructured text */
DECL|method|testCJKStructured
specifier|public
name|void
name|testCJKStructured
parameter_list|()
throws|throws
name|Exception
block|{
name|assertQ
argument_list|(
literal|"test cjk (disjunction)"
argument_list|,
name|req
argument_list|(
literal|"q"
argument_list|,
literal|"å¤§äºæ¹¾ OR bogus"
argument_list|,
literal|"qf"
argument_list|,
literal|"standardtok"
argument_list|,
literal|"mm"
argument_list|,
literal|"0%"
argument_list|,
literal|"defType"
argument_list|,
literal|"edismax"
argument_list|)
argument_list|,
literal|"*[count(//doc)=3]"
argument_list|)
expr_stmt|;
name|assertQ
argument_list|(
literal|"test cjk (minShouldMatch)"
argument_list|,
name|req
argument_list|(
literal|"q"
argument_list|,
literal|"å¤§äºæ¹¾ OR bogus"
argument_list|,
literal|"qf"
argument_list|,
literal|"standardtok"
argument_list|,
literal|"mm"
argument_list|,
literal|"67%"
argument_list|,
literal|"defType"
argument_list|,
literal|"edismax"
argument_list|)
argument_list|,
literal|"*[count(//doc)=2]"
argument_list|)
expr_stmt|;
name|assertQ
argument_list|(
literal|"test cjk (conjunction)"
argument_list|,
name|req
argument_list|(
literal|"q"
argument_list|,
literal|"å¤§äºæ¹¾ OR bogus"
argument_list|,
literal|"qf"
argument_list|,
literal|"standardtok"
argument_list|,
literal|"mm"
argument_list|,
literal|"100%"
argument_list|,
literal|"defType"
argument_list|,
literal|"edismax"
argument_list|)
argument_list|,
literal|"*[count(//doc)=1]"
argument_list|)
expr_stmt|;
block|}
comment|/**    * Test that we don't apply minShouldMatch to the inner boolean queries    * when there are synonyms (these are indicated by coordination factor)    */
DECL|method|testSynonyms
specifier|public
name|void
name|testSynonyms
parameter_list|()
throws|throws
name|Exception
block|{
comment|// document only contains baraaa, but should still match.
name|assertQ
argument_list|(
literal|"test synonyms"
argument_list|,
name|req
argument_list|(
literal|"q"
argument_list|,
literal|"fooaaa"
argument_list|,
literal|"qf"
argument_list|,
literal|"text_sw"
argument_list|,
literal|"mm"
argument_list|,
literal|"100%"
argument_list|,
literal|"defType"
argument_list|,
literal|"edismax"
argument_list|)
argument_list|,
literal|"*[count(//doc)=1]"
argument_list|)
expr_stmt|;
block|}
DECL|method|testEdismaxSimpleExtension
specifier|public
name|void
name|testEdismaxSimpleExtension
parameter_list|()
throws|throws
name|SyntaxError
block|{
name|ModifiableSolrParams
name|params
init|=
operator|new
name|ModifiableSolrParams
argument_list|()
decl_stmt|;
name|params
operator|.
name|set
argument_list|(
literal|"q"
argument_list|,
literal|"foo bar"
argument_list|)
expr_stmt|;
name|params
operator|.
name|set
argument_list|(
literal|"qf"
argument_list|,
literal|"subject title^5"
argument_list|)
expr_stmt|;
name|params
operator|.
name|set
argument_list|(
literal|"qf_fr"
argument_list|,
literal|"subject_fr title_fr^5"
argument_list|)
expr_stmt|;
name|params
operator|.
name|set
argument_list|(
literal|"qf_en"
argument_list|,
literal|"subject_en title_en^5"
argument_list|)
expr_stmt|;
name|params
operator|.
name|set
argument_list|(
literal|"qf_es"
argument_list|,
literal|"subject_es title_es^5"
argument_list|)
expr_stmt|;
name|MultilanguageQueryParser
name|parser
init|=
operator|new
name|MultilanguageQueryParser
argument_list|(
literal|"foo bar"
argument_list|,
operator|new
name|ModifiableSolrParams
argument_list|()
argument_list|,
name|params
argument_list|,
name|req
argument_list|(
name|params
argument_list|)
argument_list|)
decl_stmt|;
name|Query
name|query
init|=
name|parser
operator|.
name|parse
argument_list|()
decl_stmt|;
name|assertNotNull
argument_list|(
name|query
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|containsClause
argument_list|(
name|query
argument_list|,
literal|"title"
argument_list|,
literal|"foo"
argument_list|,
literal|5
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|containsClause
argument_list|(
name|query
argument_list|,
literal|"title"
argument_list|,
literal|"bar"
argument_list|,
literal|5
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|containsClause
argument_list|(
name|query
argument_list|,
literal|"subject"
argument_list|,
literal|"foo"
argument_list|,
literal|1
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|containsClause
argument_list|(
name|query
argument_list|,
literal|"subject"
argument_list|,
literal|"bar"
argument_list|,
literal|1
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|params
operator|.
name|set
argument_list|(
literal|"language"
argument_list|,
literal|"es"
argument_list|)
expr_stmt|;
name|parser
operator|=
operator|new
name|MultilanguageQueryParser
argument_list|(
literal|"foo bar"
argument_list|,
operator|new
name|ModifiableSolrParams
argument_list|()
argument_list|,
name|params
argument_list|,
name|req
argument_list|(
name|params
argument_list|)
argument_list|)
expr_stmt|;
name|query
operator|=
name|parser
operator|.
name|parse
argument_list|()
expr_stmt|;
name|assertNotNull
argument_list|(
name|query
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|containsClause
argument_list|(
name|query
argument_list|,
literal|"title_es"
argument_list|,
literal|"foo"
argument_list|,
literal|5
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|containsClause
argument_list|(
name|query
argument_list|,
literal|"title_es"
argument_list|,
literal|"bar"
argument_list|,
literal|5
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|containsClause
argument_list|(
name|query
argument_list|,
literal|"subject_es"
argument_list|,
literal|"foo"
argument_list|,
literal|1
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|containsClause
argument_list|(
name|query
argument_list|,
literal|"subject_es"
argument_list|,
literal|"bar"
argument_list|,
literal|1
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|FuzzyDismaxQParser
name|parser2
init|=
operator|new
name|FuzzyDismaxQParser
argument_list|(
literal|"foo bar absence"
argument_list|,
operator|new
name|ModifiableSolrParams
argument_list|()
argument_list|,
name|params
argument_list|,
name|req
argument_list|(
name|params
argument_list|)
argument_list|)
decl_stmt|;
name|query
operator|=
name|parser2
operator|.
name|parse
argument_list|()
expr_stmt|;
name|assertNotNull
argument_list|(
name|query
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|containsClause
argument_list|(
name|query
argument_list|,
literal|"title"
argument_list|,
literal|"foo"
argument_list|,
literal|5
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|containsClause
argument_list|(
name|query
argument_list|,
literal|"title"
argument_list|,
literal|"bar"
argument_list|,
literal|5
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|containsClause
argument_list|(
name|query
argument_list|,
literal|"title"
argument_list|,
literal|"absence"
argument_list|,
literal|5
argument_list|,
literal|true
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|containsClause
specifier|private
name|boolean
name|containsClause
parameter_list|(
name|Query
name|query
parameter_list|,
name|String
name|field
parameter_list|,
name|String
name|value
parameter_list|,
name|int
name|boost
parameter_list|,
name|boolean
name|fuzzy
parameter_list|)
block|{
name|float
name|queryBoost
init|=
literal|1f
decl_stmt|;
if|if
condition|(
name|query
operator|instanceof
name|BoostQuery
condition|)
block|{
name|BoostQuery
name|bq
init|=
operator|(
name|BoostQuery
operator|)
name|query
decl_stmt|;
name|query
operator|=
name|bq
operator|.
name|getQuery
argument_list|()
expr_stmt|;
name|queryBoost
operator|=
name|bq
operator|.
name|getBoost
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|query
operator|instanceof
name|BooleanQuery
condition|)
block|{
return|return
name|containsClause
argument_list|(
operator|(
name|BooleanQuery
operator|)
name|query
argument_list|,
name|field
argument_list|,
name|value
argument_list|,
name|boost
argument_list|,
name|fuzzy
argument_list|)
return|;
block|}
if|if
condition|(
name|query
operator|instanceof
name|DisjunctionMaxQuery
condition|)
block|{
return|return
name|containsClause
argument_list|(
operator|(
name|DisjunctionMaxQuery
operator|)
name|query
argument_list|,
name|field
argument_list|,
name|value
argument_list|,
name|boost
argument_list|,
name|fuzzy
argument_list|)
return|;
block|}
if|if
condition|(
name|boost
operator|!=
name|queryBoost
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|query
operator|instanceof
name|TermQuery
operator|&&
operator|!
name|fuzzy
condition|)
block|{
return|return
name|containsClause
argument_list|(
operator|(
name|TermQuery
operator|)
name|query
argument_list|,
name|field
argument_list|,
name|value
argument_list|)
return|;
block|}
if|if
condition|(
name|query
operator|instanceof
name|FuzzyQuery
operator|&&
name|fuzzy
condition|)
block|{
return|return
name|containsClause
argument_list|(
operator|(
name|FuzzyQuery
operator|)
name|query
argument_list|,
name|field
argument_list|,
name|value
argument_list|)
return|;
block|}
return|return
literal|false
return|;
block|}
DECL|method|containsClause
specifier|private
name|boolean
name|containsClause
parameter_list|(
name|FuzzyQuery
name|query
parameter_list|,
name|String
name|field
parameter_list|,
name|String
name|value
parameter_list|)
block|{
if|if
condition|(
name|query
operator|.
name|getTerm
argument_list|()
operator|.
name|field
argument_list|()
operator|.
name|equals
argument_list|(
name|field
argument_list|)
operator|&&
name|query
operator|.
name|getTerm
argument_list|()
operator|.
name|bytes
argument_list|()
operator|.
name|utf8ToString
argument_list|()
operator|.
name|equals
argument_list|(
name|value
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
DECL|method|containsClause
specifier|private
name|boolean
name|containsClause
parameter_list|(
name|BooleanQuery
name|query
parameter_list|,
name|String
name|field
parameter_list|,
name|String
name|value
parameter_list|,
name|int
name|boost
parameter_list|,
name|boolean
name|fuzzy
parameter_list|)
block|{
for|for
control|(
name|BooleanClause
name|clause
range|:
name|query
control|)
block|{
if|if
condition|(
name|containsClause
argument_list|(
name|clause
operator|.
name|getQuery
argument_list|()
argument_list|,
name|field
argument_list|,
name|value
argument_list|,
name|boost
argument_list|,
name|fuzzy
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
DECL|method|containsClause
specifier|private
name|boolean
name|containsClause
parameter_list|(
name|TermQuery
name|query
parameter_list|,
name|String
name|field
parameter_list|,
name|String
name|value
parameter_list|)
block|{
if|if
condition|(
name|query
operator|.
name|getTerm
argument_list|()
operator|.
name|field
argument_list|()
operator|.
name|equals
argument_list|(
name|field
argument_list|)
operator|&&
name|query
operator|.
name|getTerm
argument_list|()
operator|.
name|bytes
argument_list|()
operator|.
name|utf8ToString
argument_list|()
operator|.
name|equals
argument_list|(
name|value
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
DECL|method|containsClause
specifier|private
name|boolean
name|containsClause
parameter_list|(
name|DisjunctionMaxQuery
name|query
parameter_list|,
name|String
name|field
parameter_list|,
name|String
name|value
parameter_list|,
name|int
name|boost
parameter_list|,
name|boolean
name|fuzzy
parameter_list|)
block|{
for|for
control|(
name|Query
name|disjunct
range|:
name|query
operator|.
name|getDisjuncts
argument_list|()
control|)
block|{
if|if
condition|(
name|containsClause
argument_list|(
name|disjunct
argument_list|,
name|field
argument_list|,
name|value
argument_list|,
name|boost
argument_list|,
name|fuzzy
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
DECL|class|MultilanguageQueryParser
class|class
name|MultilanguageQueryParser
extends|extends
name|ExtendedDismaxQParser
block|{
DECL|method|MultilanguageQueryParser
specifier|public
name|MultilanguageQueryParser
parameter_list|(
name|String
name|qstr
parameter_list|,
name|SolrParams
name|localParams
parameter_list|,
name|SolrParams
name|params
parameter_list|,
name|SolrQueryRequest
name|req
parameter_list|)
block|{
name|super
argument_list|(
name|qstr
argument_list|,
name|localParams
argument_list|,
name|params
argument_list|,
name|req
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|createConfiguration
specifier|protected
name|ExtendedDismaxConfiguration
name|createConfiguration
parameter_list|(
name|String
name|qstr
parameter_list|,
name|SolrParams
name|localParams
parameter_list|,
name|SolrParams
name|params
parameter_list|,
name|SolrQueryRequest
name|req
parameter_list|)
block|{
return|return
operator|new
name|MultilanguageDismaxConfiguration
argument_list|(
name|localParams
argument_list|,
name|params
argument_list|,
name|req
argument_list|)
return|;
block|}
DECL|class|MultilanguageDismaxConfiguration
class|class
name|MultilanguageDismaxConfiguration
extends|extends
name|ExtendedDismaxConfiguration
block|{
DECL|method|MultilanguageDismaxConfiguration
specifier|public
name|MultilanguageDismaxConfiguration
parameter_list|(
name|SolrParams
name|localParams
parameter_list|,
name|SolrParams
name|params
parameter_list|,
name|SolrQueryRequest
name|req
parameter_list|)
block|{
name|super
argument_list|(
name|localParams
argument_list|,
name|params
argument_list|,
name|req
argument_list|)
expr_stmt|;
name|String
name|language
init|=
name|params
operator|.
name|get
argument_list|(
literal|"language"
argument_list|)
decl_stmt|;
if|if
condition|(
name|language
operator|!=
literal|null
condition|)
block|{
name|super
operator|.
name|queryFields
operator|=
name|SolrPluginUtils
operator|.
name|parseFieldBoosts
argument_list|(
name|solrParams
operator|.
name|getParams
argument_list|(
literal|"qf_"
operator|+
name|language
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
DECL|class|FuzzyDismaxQParser
class|class
name|FuzzyDismaxQParser
extends|extends
name|ExtendedDismaxQParser
block|{
DECL|method|FuzzyDismaxQParser
specifier|public
name|FuzzyDismaxQParser
parameter_list|(
name|String
name|qstr
parameter_list|,
name|SolrParams
name|localParams
parameter_list|,
name|SolrParams
name|params
parameter_list|,
name|SolrQueryRequest
name|req
parameter_list|)
block|{
name|super
argument_list|(
name|qstr
argument_list|,
name|localParams
argument_list|,
name|params
argument_list|,
name|req
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|createEdismaxQueryParser
specifier|protected
name|ExtendedSolrQueryParser
name|createEdismaxQueryParser
parameter_list|(
name|QParser
name|qParser
parameter_list|,
name|String
name|field
parameter_list|)
block|{
return|return
operator|new
name|FuzzyQueryParser
argument_list|(
name|qParser
argument_list|,
name|field
argument_list|)
return|;
block|}
DECL|class|FuzzyQueryParser
class|class
name|FuzzyQueryParser
extends|extends
name|ExtendedSolrQueryParser
block|{
DECL|field|frequentlyMisspelledWords
specifier|private
name|Set
argument_list|<
name|String
argument_list|>
name|frequentlyMisspelledWords
decl_stmt|;
DECL|method|FuzzyQueryParser
specifier|public
name|FuzzyQueryParser
parameter_list|(
name|QParser
name|parser
parameter_list|,
name|String
name|defaultField
parameter_list|)
block|{
name|super
argument_list|(
name|parser
argument_list|,
name|defaultField
argument_list|)
expr_stmt|;
name|frequentlyMisspelledWords
operator|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
expr_stmt|;
name|frequentlyMisspelledWords
operator|.
name|add
argument_list|(
literal|"absence"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|getFieldQuery
specifier|protected
name|Query
name|getFieldQuery
parameter_list|(
name|String
name|field
parameter_list|,
name|String
name|val
parameter_list|,
name|boolean
name|quoted
parameter_list|)
throws|throws
name|SyntaxError
block|{
if|if
condition|(
name|frequentlyMisspelledWords
operator|.
name|contains
argument_list|(
name|val
argument_list|)
condition|)
block|{
return|return
name|getFuzzyQuery
argument_list|(
name|field
argument_list|,
name|val
argument_list|,
literal|0.75F
argument_list|)
return|;
block|}
return|return
name|super
operator|.
name|getFieldQuery
argument_list|(
name|field
argument_list|,
name|val
argument_list|,
name|quoted
argument_list|)
return|;
block|}
block|}
block|}
block|}
end_class
end_unit
