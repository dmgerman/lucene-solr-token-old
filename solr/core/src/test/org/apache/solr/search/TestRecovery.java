begin_unit
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_package
DECL|package|org.apache.solr.search
package|package
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|search
package|;
end_package
begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|update
operator|.
name|processor
operator|.
name|DistributingUpdateProcessorFactory
operator|.
name|DISTRIB_UPDATE_PARAM
import|;
end_import
begin_import
import|import
name|org
operator|.
name|noggit
operator|.
name|ObjectBuilder
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|SolrTestCaseJ4
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|request
operator|.
name|SolrQueryRequest
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|update
operator|.
name|DirectUpdateHandler2
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|update
operator|.
name|UpdateLog
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|update
operator|.
name|UpdateHandler
import|;
end_import
begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|AfterClass
import|;
end_import
begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|BeforeClass
import|;
end_import
begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Test
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|RandomAccessFile
import|;
end_import
begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|charset
operator|.
name|StandardCharsets
import|;
end_import
begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|Files
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayDeque
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Deque
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedList
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Locale
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Future
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Semaphore
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|update
operator|.
name|processor
operator|.
name|DistributedUpdateProcessor
operator|.
name|DistribPhase
import|;
end_import
begin_class
DECL|class|TestRecovery
specifier|public
class|class
name|TestRecovery
extends|extends
name|SolrTestCaseJ4
block|{
comment|// means that we've seen the leader and have version info (i.e. we are a non-leader replica)
DECL|field|FROM_LEADER
specifier|private
specifier|static
name|String
name|FROM_LEADER
init|=
name|DistribPhase
operator|.
name|FROMLEADER
operator|.
name|toString
argument_list|()
decl_stmt|;
DECL|field|timeout
specifier|private
specifier|static
name|int
name|timeout
init|=
literal|60
decl_stmt|;
comment|// acquire timeout in seconds.  change this to a huge number when debugging to prevent threads from advancing.
comment|// TODO: fix this test to not require FSDirectory
DECL|field|savedFactory
specifier|static
name|String
name|savedFactory
decl_stmt|;
annotation|@
name|BeforeClass
DECL|method|beforeClass
specifier|public
specifier|static
name|void
name|beforeClass
parameter_list|()
throws|throws
name|Exception
block|{
name|savedFactory
operator|=
name|System
operator|.
name|getProperty
argument_list|(
literal|"solr.DirectoryFactory"
argument_list|)
expr_stmt|;
name|System
operator|.
name|setProperty
argument_list|(
literal|"solr.directoryFactory"
argument_list|,
literal|"org.apache.solr.core.MockFSDirectoryFactory"
argument_list|)
expr_stmt|;
name|initCore
argument_list|(
literal|"solrconfig-tlog.xml"
argument_list|,
literal|"schema15.xml"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|AfterClass
DECL|method|afterClass
specifier|public
specifier|static
name|void
name|afterClass
parameter_list|()
block|{
if|if
condition|(
name|savedFactory
operator|==
literal|null
condition|)
block|{
name|System
operator|.
name|clearProperty
argument_list|(
literal|"solr.directoryFactory"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|System
operator|.
name|setProperty
argument_list|(
literal|"solr.directoryFactory"
argument_list|,
name|savedFactory
argument_list|)
expr_stmt|;
block|}
block|}
comment|// since we make up fake versions in these tests, we can get messed up by a DBQ with a real version
comment|// since Solr can think following updates were reordered.
annotation|@
name|Override
DECL|method|clearIndex
specifier|public
name|void
name|clearIndex
parameter_list|()
block|{
try|try
block|{
name|deleteByQueryAndGetVersion
argument_list|(
literal|"*:*"
argument_list|,
name|params
argument_list|(
literal|"_version_"
argument_list|,
name|Long
operator|.
name|toString
argument_list|(
operator|-
name|Long
operator|.
name|MAX_VALUE
argument_list|)
argument_list|,
name|DISTRIB_UPDATE_PARAM
argument_list|,
name|FROM_LEADER
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Test
DECL|method|testLogReplay
specifier|public
name|void
name|testLogReplay
parameter_list|()
throws|throws
name|Exception
block|{
try|try
block|{
name|DirectUpdateHandler2
operator|.
name|commitOnClose
operator|=
literal|false
expr_stmt|;
specifier|final
name|Semaphore
name|logReplay
init|=
operator|new
name|Semaphore
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|Semaphore
name|logReplayFinish
init|=
operator|new
name|Semaphore
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|UpdateLog
operator|.
name|testing_logReplayHook
operator|=
parameter_list|()
lambda|->
block|{
try|try
block|{
name|assertTrue
argument_list|(
name|logReplay
operator|.
name|tryAcquire
argument_list|(
name|timeout
argument_list|,
name|TimeUnit
operator|.
name|SECONDS
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
expr_stmt|;
name|UpdateLog
operator|.
name|testing_logReplayFinishHook
operator|=
parameter_list|()
lambda|->
name|logReplayFinish
operator|.
name|release
argument_list|()
expr_stmt|;
name|clearIndex
argument_list|()
expr_stmt|;
name|assertU
argument_list|(
name|commit
argument_list|()
argument_list|)
expr_stmt|;
name|Deque
argument_list|<
name|Long
argument_list|>
name|versions
init|=
operator|new
name|ArrayDeque
argument_list|<>
argument_list|()
decl_stmt|;
name|versions
operator|.
name|addFirst
argument_list|(
name|addAndGetVersion
argument_list|(
name|sdoc
argument_list|(
literal|"id"
argument_list|,
literal|"A1"
argument_list|)
argument_list|,
literal|null
argument_list|)
argument_list|)
expr_stmt|;
name|versions
operator|.
name|addFirst
argument_list|(
name|addAndGetVersion
argument_list|(
name|sdoc
argument_list|(
literal|"id"
argument_list|,
literal|"A11"
argument_list|)
argument_list|,
literal|null
argument_list|)
argument_list|)
expr_stmt|;
name|versions
operator|.
name|addFirst
argument_list|(
name|addAndGetVersion
argument_list|(
name|sdoc
argument_list|(
literal|"id"
argument_list|,
literal|"A12"
argument_list|)
argument_list|,
literal|null
argument_list|)
argument_list|)
expr_stmt|;
name|versions
operator|.
name|addFirst
argument_list|(
name|deleteByQueryAndGetVersion
argument_list|(
literal|"id:A11"
argument_list|,
literal|null
argument_list|)
argument_list|)
expr_stmt|;
name|versions
operator|.
name|addFirst
argument_list|(
name|addAndGetVersion
argument_list|(
name|sdoc
argument_list|(
literal|"id"
argument_list|,
literal|"A13"
argument_list|)
argument_list|,
literal|null
argument_list|)
argument_list|)
expr_stmt|;
name|assertJQ
argument_list|(
name|req
argument_list|(
literal|"q"
argument_list|,
literal|"*:*"
argument_list|)
argument_list|,
literal|"/response/numFound==0"
argument_list|)
expr_stmt|;
name|assertJQ
argument_list|(
name|req
argument_list|(
literal|"qt"
argument_list|,
literal|"/get"
argument_list|,
literal|"getVersions"
argument_list|,
literal|""
operator|+
name|versions
operator|.
name|size
argument_list|()
argument_list|)
argument_list|,
literal|"/versions=="
operator|+
name|versions
argument_list|)
expr_stmt|;
name|h
operator|.
name|close
argument_list|()
expr_stmt|;
name|createCore
argument_list|()
expr_stmt|;
comment|// Solr should kick this off now
comment|// h.getCore().getUpdateHandler().getUpdateLog().recoverFromLog();
comment|// verify that previous close didn't do a commit
comment|// recovery should be blocked by our hook
name|assertJQ
argument_list|(
name|req
argument_list|(
literal|"q"
argument_list|,
literal|"*:*"
argument_list|)
argument_list|,
literal|"/response/numFound==0"
argument_list|)
expr_stmt|;
comment|// make sure we can still access versions after a restart
name|assertJQ
argument_list|(
name|req
argument_list|(
literal|"qt"
argument_list|,
literal|"/get"
argument_list|,
literal|"getVersions"
argument_list|,
literal|""
operator|+
name|versions
operator|.
name|size
argument_list|()
argument_list|)
argument_list|,
literal|"/versions=="
operator|+
name|versions
argument_list|)
expr_stmt|;
comment|// unblock recovery
name|logReplay
operator|.
name|release
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
comment|// make sure we can still access versions during recovery
name|assertJQ
argument_list|(
name|req
argument_list|(
literal|"qt"
argument_list|,
literal|"/get"
argument_list|,
literal|"getVersions"
argument_list|,
literal|""
operator|+
name|versions
operator|.
name|size
argument_list|()
argument_list|)
argument_list|,
literal|"/versions=="
operator|+
name|versions
argument_list|)
expr_stmt|;
comment|// wait until recovery has finished
name|assertTrue
argument_list|(
name|logReplayFinish
operator|.
name|tryAcquire
argument_list|(
name|timeout
argument_list|,
name|TimeUnit
operator|.
name|SECONDS
argument_list|)
argument_list|)
expr_stmt|;
name|assertJQ
argument_list|(
name|req
argument_list|(
literal|"q"
argument_list|,
literal|"*:*"
argument_list|)
argument_list|,
literal|"/response/numFound==3"
argument_list|)
expr_stmt|;
comment|// make sure we can still access versions after recovery
name|assertJQ
argument_list|(
name|req
argument_list|(
literal|"qt"
argument_list|,
literal|"/get"
argument_list|,
literal|"getVersions"
argument_list|,
literal|""
operator|+
name|versions
operator|.
name|size
argument_list|()
argument_list|)
argument_list|,
literal|"/versions=="
operator|+
name|versions
argument_list|)
expr_stmt|;
name|assertU
argument_list|(
name|adoc
argument_list|(
literal|"id"
argument_list|,
literal|"A2"
argument_list|)
argument_list|)
expr_stmt|;
name|assertU
argument_list|(
name|adoc
argument_list|(
literal|"id"
argument_list|,
literal|"A3"
argument_list|)
argument_list|)
expr_stmt|;
name|assertU
argument_list|(
name|delI
argument_list|(
literal|"A2"
argument_list|)
argument_list|)
expr_stmt|;
name|assertU
argument_list|(
name|adoc
argument_list|(
literal|"id"
argument_list|,
literal|"A4"
argument_list|)
argument_list|)
expr_stmt|;
name|assertJQ
argument_list|(
name|req
argument_list|(
literal|"q"
argument_list|,
literal|"*:*"
argument_list|)
argument_list|,
literal|"/response/numFound==3"
argument_list|)
expr_stmt|;
name|h
operator|.
name|close
argument_list|()
expr_stmt|;
name|createCore
argument_list|()
expr_stmt|;
comment|// Solr should kick this off now
comment|// h.getCore().getUpdateHandler().getUpdateLog().recoverFromLog();
comment|// wait until recovery has finished
name|assertTrue
argument_list|(
name|logReplayFinish
operator|.
name|tryAcquire
argument_list|(
name|timeout
argument_list|,
name|TimeUnit
operator|.
name|SECONDS
argument_list|)
argument_list|)
expr_stmt|;
name|assertJQ
argument_list|(
name|req
argument_list|(
literal|"q"
argument_list|,
literal|"*:*"
argument_list|)
argument_list|,
literal|"/response/numFound==5"
argument_list|)
expr_stmt|;
name|assertJQ
argument_list|(
name|req
argument_list|(
literal|"q"
argument_list|,
literal|"id:A2"
argument_list|)
argument_list|,
literal|"/response/numFound==0"
argument_list|)
expr_stmt|;
comment|// no updates, so insure that recovery does not run
name|h
operator|.
name|close
argument_list|()
expr_stmt|;
name|int
name|permits
init|=
name|logReplay
operator|.
name|availablePermits
argument_list|()
decl_stmt|;
name|createCore
argument_list|()
expr_stmt|;
comment|// Solr should kick this off now
comment|// h.getCore().getUpdateHandler().getUpdateLog().recoverFromLog();
name|assertJQ
argument_list|(
name|req
argument_list|(
literal|"q"
argument_list|,
literal|"*:*"
argument_list|)
argument_list|,
literal|"/response/numFound==5"
argument_list|)
expr_stmt|;
name|Thread
operator|.
name|sleep
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|permits
argument_list|,
name|logReplay
operator|.
name|availablePermits
argument_list|()
argument_list|)
expr_stmt|;
comment|// no updates, so insure that recovery didn't run
name|assertEquals
argument_list|(
name|UpdateLog
operator|.
name|State
operator|.
name|ACTIVE
argument_list|,
name|h
operator|.
name|getCore
argument_list|()
operator|.
name|getUpdateHandler
argument_list|()
operator|.
name|getUpdateLog
argument_list|()
operator|.
name|getState
argument_list|()
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|DirectUpdateHandler2
operator|.
name|commitOnClose
operator|=
literal|true
expr_stmt|;
name|UpdateLog
operator|.
name|testing_logReplayHook
operator|=
literal|null
expr_stmt|;
name|UpdateLog
operator|.
name|testing_logReplayFinishHook
operator|=
literal|null
expr_stmt|;
block|}
block|}
annotation|@
name|Test
DECL|method|testBuffering
specifier|public
name|void
name|testBuffering
parameter_list|()
throws|throws
name|Exception
block|{
name|DirectUpdateHandler2
operator|.
name|commitOnClose
operator|=
literal|false
expr_stmt|;
specifier|final
name|Semaphore
name|logReplay
init|=
operator|new
name|Semaphore
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|Semaphore
name|logReplayFinish
init|=
operator|new
name|Semaphore
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|UpdateLog
operator|.
name|testing_logReplayHook
operator|=
parameter_list|()
lambda|->
block|{
try|try
block|{
name|assertTrue
argument_list|(
name|logReplay
operator|.
name|tryAcquire
argument_list|(
name|timeout
argument_list|,
name|TimeUnit
operator|.
name|SECONDS
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
expr_stmt|;
name|UpdateLog
operator|.
name|testing_logReplayFinishHook
operator|=
name|logReplayFinish
operator|::
name|release
expr_stmt|;
name|SolrQueryRequest
name|req
init|=
name|req
argument_list|()
decl_stmt|;
name|UpdateHandler
name|uhandler
init|=
name|req
operator|.
name|getCore
argument_list|()
operator|.
name|getUpdateHandler
argument_list|()
decl_stmt|;
name|UpdateLog
name|ulog
init|=
name|uhandler
operator|.
name|getUpdateLog
argument_list|()
decl_stmt|;
try|try
block|{
name|clearIndex
argument_list|()
expr_stmt|;
name|assertU
argument_list|(
name|commit
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|UpdateLog
operator|.
name|State
operator|.
name|ACTIVE
argument_list|,
name|ulog
operator|.
name|getState
argument_list|()
argument_list|)
expr_stmt|;
name|ulog
operator|.
name|bufferUpdates
argument_list|()
expr_stmt|;
name|assertEquals
argument_list|(
name|UpdateLog
operator|.
name|State
operator|.
name|BUFFERING
argument_list|,
name|ulog
operator|.
name|getState
argument_list|()
argument_list|)
expr_stmt|;
name|Future
argument_list|<
name|UpdateLog
operator|.
name|RecoveryInfo
argument_list|>
name|rinfoFuture
init|=
name|ulog
operator|.
name|applyBufferedUpdates
argument_list|()
decl_stmt|;
name|assertTrue
argument_list|(
name|rinfoFuture
operator|==
literal|null
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|UpdateLog
operator|.
name|State
operator|.
name|ACTIVE
argument_list|,
name|ulog
operator|.
name|getState
argument_list|()
argument_list|)
expr_stmt|;
name|ulog
operator|.
name|bufferUpdates
argument_list|()
expr_stmt|;
name|assertEquals
argument_list|(
name|UpdateLog
operator|.
name|State
operator|.
name|BUFFERING
argument_list|,
name|ulog
operator|.
name|getState
argument_list|()
argument_list|)
expr_stmt|;
comment|// simulate updates from a leader
name|updateJ
argument_list|(
name|jsonAdd
argument_list|(
name|sdoc
argument_list|(
literal|"id"
argument_list|,
literal|"B1"
argument_list|,
literal|"_version_"
argument_list|,
literal|"1010"
argument_list|)
argument_list|)
argument_list|,
name|params
argument_list|(
name|DISTRIB_UPDATE_PARAM
argument_list|,
name|FROM_LEADER
argument_list|)
argument_list|)
expr_stmt|;
name|updateJ
argument_list|(
name|jsonAdd
argument_list|(
name|sdoc
argument_list|(
literal|"id"
argument_list|,
literal|"B11"
argument_list|,
literal|"_version_"
argument_list|,
literal|"1015"
argument_list|)
argument_list|)
argument_list|,
name|params
argument_list|(
name|DISTRIB_UPDATE_PARAM
argument_list|,
name|FROM_LEADER
argument_list|)
argument_list|)
expr_stmt|;
name|updateJ
argument_list|(
name|jsonDelQ
argument_list|(
literal|"id:B1 id:B11 id:B2 id:B3"
argument_list|)
argument_list|,
name|params
argument_list|(
name|DISTRIB_UPDATE_PARAM
argument_list|,
name|FROM_LEADER
argument_list|,
literal|"_version_"
argument_list|,
literal|"-1017"
argument_list|)
argument_list|)
expr_stmt|;
name|updateJ
argument_list|(
name|jsonAdd
argument_list|(
name|sdoc
argument_list|(
literal|"id"
argument_list|,
literal|"B2"
argument_list|,
literal|"_version_"
argument_list|,
literal|"1020"
argument_list|)
argument_list|)
argument_list|,
name|params
argument_list|(
name|DISTRIB_UPDATE_PARAM
argument_list|,
name|FROM_LEADER
argument_list|)
argument_list|)
expr_stmt|;
name|updateJ
argument_list|(
name|jsonAdd
argument_list|(
name|sdoc
argument_list|(
literal|"id"
argument_list|,
literal|"B3"
argument_list|,
literal|"_version_"
argument_list|,
literal|"1030"
argument_list|)
argument_list|)
argument_list|,
name|params
argument_list|(
name|DISTRIB_UPDATE_PARAM
argument_list|,
name|FROM_LEADER
argument_list|)
argument_list|)
expr_stmt|;
name|deleteAndGetVersion
argument_list|(
literal|"B1"
argument_list|,
name|params
argument_list|(
name|DISTRIB_UPDATE_PARAM
argument_list|,
name|FROM_LEADER
argument_list|,
literal|"_version_"
argument_list|,
literal|"-2010"
argument_list|)
argument_list|)
expr_stmt|;
name|assertJQ
argument_list|(
name|req
argument_list|(
literal|"qt"
argument_list|,
literal|"/get"
argument_list|,
literal|"getVersions"
argument_list|,
literal|"6"
argument_list|)
argument_list|,
literal|"=={'versions':[-2010,1030,1020,-1017,1015,1010]}"
argument_list|)
expr_stmt|;
name|assertU
argument_list|(
name|commit
argument_list|()
argument_list|)
expr_stmt|;
name|assertJQ
argument_list|(
name|req
argument_list|(
literal|"qt"
argument_list|,
literal|"/get"
argument_list|,
literal|"getVersions"
argument_list|,
literal|"6"
argument_list|)
argument_list|,
literal|"=={'versions':[-2010,1030,1020,-1017,1015,1010]}"
argument_list|)
expr_stmt|;
comment|// updates should be buffered, so we should not see any results yet.
name|assertJQ
argument_list|(
name|req
argument_list|(
literal|"q"
argument_list|,
literal|"*:*"
argument_list|)
argument_list|,
literal|"/response/numFound==0"
argument_list|)
expr_stmt|;
comment|// real-time get should also not show anything (this could change in the future,
comment|// but it's currently used for validating version numbers too, so it would
comment|// be bad for updates to be visible if we're just buffering.
name|assertJQ
argument_list|(
name|req
argument_list|(
literal|"qt"
argument_list|,
literal|"/get"
argument_list|,
literal|"id"
argument_list|,
literal|"B3"
argument_list|)
argument_list|,
literal|"=={'doc':null}"
argument_list|)
expr_stmt|;
name|rinfoFuture
operator|=
name|ulog
operator|.
name|applyBufferedUpdates
argument_list|()
expr_stmt|;
name|assertTrue
argument_list|(
name|rinfoFuture
operator|!=
literal|null
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|UpdateLog
operator|.
name|State
operator|.
name|APPLYING_BUFFERED
argument_list|,
name|ulog
operator|.
name|getState
argument_list|()
argument_list|)
expr_stmt|;
name|logReplay
operator|.
name|release
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|UpdateLog
operator|.
name|RecoveryInfo
name|rinfo
init|=
name|rinfoFuture
operator|.
name|get
argument_list|()
decl_stmt|;
name|assertEquals
argument_list|(
name|UpdateLog
operator|.
name|State
operator|.
name|ACTIVE
argument_list|,
name|ulog
operator|.
name|getState
argument_list|()
argument_list|)
expr_stmt|;
name|assertJQ
argument_list|(
name|req
argument_list|(
literal|"qt"
argument_list|,
literal|"/get"
argument_list|,
literal|"getVersions"
argument_list|,
literal|"6"
argument_list|)
argument_list|,
literal|"=={'versions':[-2010,1030,1020,-1017,1015,1010]}"
argument_list|)
expr_stmt|;
name|assertJQ
argument_list|(
name|req
argument_list|(
literal|"q"
argument_list|,
literal|"*:*"
argument_list|)
argument_list|,
literal|"/response/numFound==2"
argument_list|)
expr_stmt|;
comment|// move back to recovering
name|ulog
operator|.
name|bufferUpdates
argument_list|()
expr_stmt|;
name|assertEquals
argument_list|(
name|UpdateLog
operator|.
name|State
operator|.
name|BUFFERING
argument_list|,
name|ulog
operator|.
name|getState
argument_list|()
argument_list|)
expr_stmt|;
name|Long
name|ver
init|=
name|getVer
argument_list|(
name|req
argument_list|(
literal|"qt"
argument_list|,
literal|"/get"
argument_list|,
literal|"id"
argument_list|,
literal|"B3"
argument_list|)
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|1030L
argument_list|,
name|ver
operator|.
name|longValue
argument_list|()
argument_list|)
expr_stmt|;
comment|// add a reordered doc that shouldn't overwrite one in the index
name|updateJ
argument_list|(
name|jsonAdd
argument_list|(
name|sdoc
argument_list|(
literal|"id"
argument_list|,
literal|"B3"
argument_list|,
literal|"_version_"
argument_list|,
literal|"3"
argument_list|)
argument_list|)
argument_list|,
name|params
argument_list|(
name|DISTRIB_UPDATE_PARAM
argument_list|,
name|FROM_LEADER
argument_list|)
argument_list|)
expr_stmt|;
comment|// reorder two buffered updates
name|updateJ
argument_list|(
name|jsonAdd
argument_list|(
name|sdoc
argument_list|(
literal|"id"
argument_list|,
literal|"B4"
argument_list|,
literal|"_version_"
argument_list|,
literal|"1040"
argument_list|)
argument_list|)
argument_list|,
name|params
argument_list|(
name|DISTRIB_UPDATE_PARAM
argument_list|,
name|FROM_LEADER
argument_list|)
argument_list|)
expr_stmt|;
name|deleteAndGetVersion
argument_list|(
literal|"B4"
argument_list|,
name|params
argument_list|(
name|DISTRIB_UPDATE_PARAM
argument_list|,
name|FROM_LEADER
argument_list|,
literal|"_version_"
argument_list|,
literal|"-940"
argument_list|)
argument_list|)
expr_stmt|;
comment|// this update should not take affect
name|updateJ
argument_list|(
name|jsonAdd
argument_list|(
name|sdoc
argument_list|(
literal|"id"
argument_list|,
literal|"B6"
argument_list|,
literal|"_version_"
argument_list|,
literal|"1060"
argument_list|)
argument_list|)
argument_list|,
name|params
argument_list|(
name|DISTRIB_UPDATE_PARAM
argument_list|,
name|FROM_LEADER
argument_list|)
argument_list|)
expr_stmt|;
name|updateJ
argument_list|(
name|jsonAdd
argument_list|(
name|sdoc
argument_list|(
literal|"id"
argument_list|,
literal|"B5"
argument_list|,
literal|"_version_"
argument_list|,
literal|"1050"
argument_list|)
argument_list|)
argument_list|,
name|params
argument_list|(
name|DISTRIB_UPDATE_PARAM
argument_list|,
name|FROM_LEADER
argument_list|)
argument_list|)
expr_stmt|;
name|updateJ
argument_list|(
name|jsonAdd
argument_list|(
name|sdoc
argument_list|(
literal|"id"
argument_list|,
literal|"B8"
argument_list|,
literal|"_version_"
argument_list|,
literal|"1080"
argument_list|)
argument_list|)
argument_list|,
name|params
argument_list|(
name|DISTRIB_UPDATE_PARAM
argument_list|,
name|FROM_LEADER
argument_list|)
argument_list|)
expr_stmt|;
comment|// test that delete by query is at least buffered along with everything else so it will delete the
comment|// currently buffered id:8 (even if it doesn't currently support versioning)
name|updateJ
argument_list|(
literal|"{\"delete\": { \"query\":\"id:B2 OR id:B8\" }}"
argument_list|,
name|params
argument_list|(
name|DISTRIB_UPDATE_PARAM
argument_list|,
name|FROM_LEADER
argument_list|,
literal|"_version_"
argument_list|,
literal|"-3000"
argument_list|)
argument_list|)
expr_stmt|;
name|assertJQ
argument_list|(
name|req
argument_list|(
literal|"qt"
argument_list|,
literal|"/get"
argument_list|,
literal|"getVersions"
argument_list|,
literal|"13"
argument_list|)
argument_list|,
literal|"=={'versions':[-3000,1080,1050,1060,-940,1040,3,-2010,1030,1020,-1017,1015,1010]}"
comment|// the "3" appears because versions aren't checked while buffering
argument_list|)
expr_stmt|;
name|logReplay
operator|.
name|drainPermits
argument_list|()
expr_stmt|;
name|rinfoFuture
operator|=
name|ulog
operator|.
name|applyBufferedUpdates
argument_list|()
expr_stmt|;
name|assertTrue
argument_list|(
name|rinfoFuture
operator|!=
literal|null
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|UpdateLog
operator|.
name|State
operator|.
name|APPLYING_BUFFERED
argument_list|,
name|ulog
operator|.
name|getState
argument_list|()
argument_list|)
expr_stmt|;
comment|// apply a single update
name|logReplay
operator|.
name|release
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|// now add another update
name|updateJ
argument_list|(
name|jsonAdd
argument_list|(
name|sdoc
argument_list|(
literal|"id"
argument_list|,
literal|"B7"
argument_list|,
literal|"_version_"
argument_list|,
literal|"1070"
argument_list|)
argument_list|)
argument_list|,
name|params
argument_list|(
name|DISTRIB_UPDATE_PARAM
argument_list|,
name|FROM_LEADER
argument_list|)
argument_list|)
expr_stmt|;
comment|// a reordered update that should be dropped
name|deleteAndGetVersion
argument_list|(
literal|"B5"
argument_list|,
name|params
argument_list|(
name|DISTRIB_UPDATE_PARAM
argument_list|,
name|FROM_LEADER
argument_list|,
literal|"_version_"
argument_list|,
literal|"-950"
argument_list|)
argument_list|)
expr_stmt|;
name|deleteAndGetVersion
argument_list|(
literal|"B6"
argument_list|,
name|params
argument_list|(
name|DISTRIB_UPDATE_PARAM
argument_list|,
name|FROM_LEADER
argument_list|,
literal|"_version_"
argument_list|,
literal|"-2060"
argument_list|)
argument_list|)
expr_stmt|;
name|logReplay
operator|.
name|release
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|UpdateLog
operator|.
name|RecoveryInfo
name|recInfo
init|=
name|rinfoFuture
operator|.
name|get
argument_list|()
decl_stmt|;
name|assertJQ
argument_list|(
name|req
argument_list|(
literal|"q"
argument_list|,
literal|"*:*"
argument_list|,
literal|"sort"
argument_list|,
literal|"id asc"
argument_list|,
literal|"fl"
argument_list|,
literal|"id,_version_"
argument_list|)
argument_list|,
literal|"/response/docs==["
operator|+
literal|"{'id':'B3','_version_':1030}"
operator|+
literal|",{'id':'B4','_version_':1040}"
operator|+
literal|",{'id':'B5','_version_':1050}"
operator|+
literal|",{'id':'B7','_version_':1070}"
operator|+
literal|"]"
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|recInfo
operator|.
name|deleteByQuery
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|UpdateLog
operator|.
name|State
operator|.
name|ACTIVE
argument_list|,
name|ulog
operator|.
name|getState
argument_list|()
argument_list|)
expr_stmt|;
comment|// leave each test method in a good state
block|}
finally|finally
block|{
name|DirectUpdateHandler2
operator|.
name|commitOnClose
operator|=
literal|true
expr_stmt|;
name|UpdateLog
operator|.
name|testing_logReplayHook
operator|=
literal|null
expr_stmt|;
name|UpdateLog
operator|.
name|testing_logReplayFinishHook
operator|=
literal|null
expr_stmt|;
name|req
argument_list|()
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Test
DECL|method|testDropBuffered
specifier|public
name|void
name|testDropBuffered
parameter_list|()
throws|throws
name|Exception
block|{
name|DirectUpdateHandler2
operator|.
name|commitOnClose
operator|=
literal|false
expr_stmt|;
specifier|final
name|Semaphore
name|logReplay
init|=
operator|new
name|Semaphore
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|Semaphore
name|logReplayFinish
init|=
operator|new
name|Semaphore
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|UpdateLog
operator|.
name|testing_logReplayHook
operator|=
parameter_list|()
lambda|->
block|{
try|try
block|{
name|assertTrue
argument_list|(
name|logReplay
operator|.
name|tryAcquire
argument_list|(
name|timeout
argument_list|,
name|TimeUnit
operator|.
name|SECONDS
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
expr_stmt|;
name|UpdateLog
operator|.
name|testing_logReplayFinishHook
operator|=
parameter_list|()
lambda|->
name|logReplayFinish
operator|.
name|release
argument_list|()
expr_stmt|;
name|SolrQueryRequest
name|req
init|=
name|req
argument_list|()
decl_stmt|;
name|UpdateHandler
name|uhandler
init|=
name|req
operator|.
name|getCore
argument_list|()
operator|.
name|getUpdateHandler
argument_list|()
decl_stmt|;
name|UpdateLog
name|ulog
init|=
name|uhandler
operator|.
name|getUpdateLog
argument_list|()
decl_stmt|;
try|try
block|{
name|clearIndex
argument_list|()
expr_stmt|;
name|assertU
argument_list|(
name|commit
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|UpdateLog
operator|.
name|State
operator|.
name|ACTIVE
argument_list|,
name|ulog
operator|.
name|getState
argument_list|()
argument_list|)
expr_stmt|;
name|ulog
operator|.
name|bufferUpdates
argument_list|()
expr_stmt|;
name|assertEquals
argument_list|(
name|UpdateLog
operator|.
name|State
operator|.
name|BUFFERING
argument_list|,
name|ulog
operator|.
name|getState
argument_list|()
argument_list|)
expr_stmt|;
name|Future
argument_list|<
name|UpdateLog
operator|.
name|RecoveryInfo
argument_list|>
name|rinfoFuture
init|=
name|ulog
operator|.
name|applyBufferedUpdates
argument_list|()
decl_stmt|;
name|assertTrue
argument_list|(
name|rinfoFuture
operator|==
literal|null
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|UpdateLog
operator|.
name|State
operator|.
name|ACTIVE
argument_list|,
name|ulog
operator|.
name|getState
argument_list|()
argument_list|)
expr_stmt|;
name|ulog
operator|.
name|bufferUpdates
argument_list|()
expr_stmt|;
name|assertEquals
argument_list|(
name|UpdateLog
operator|.
name|State
operator|.
name|BUFFERING
argument_list|,
name|ulog
operator|.
name|getState
argument_list|()
argument_list|)
expr_stmt|;
comment|// simulate updates from a leader
name|updateJ
argument_list|(
name|jsonAdd
argument_list|(
name|sdoc
argument_list|(
literal|"id"
argument_list|,
literal|"C1"
argument_list|,
literal|"_version_"
argument_list|,
literal|"101"
argument_list|)
argument_list|)
argument_list|,
name|params
argument_list|(
name|DISTRIB_UPDATE_PARAM
argument_list|,
name|FROM_LEADER
argument_list|)
argument_list|)
expr_stmt|;
name|updateJ
argument_list|(
name|jsonAdd
argument_list|(
name|sdoc
argument_list|(
literal|"id"
argument_list|,
literal|"C2"
argument_list|,
literal|"_version_"
argument_list|,
literal|"102"
argument_list|)
argument_list|)
argument_list|,
name|params
argument_list|(
name|DISTRIB_UPDATE_PARAM
argument_list|,
name|FROM_LEADER
argument_list|)
argument_list|)
expr_stmt|;
name|updateJ
argument_list|(
name|jsonAdd
argument_list|(
name|sdoc
argument_list|(
literal|"id"
argument_list|,
literal|"C3"
argument_list|,
literal|"_version_"
argument_list|,
literal|"103"
argument_list|)
argument_list|)
argument_list|,
name|params
argument_list|(
name|DISTRIB_UPDATE_PARAM
argument_list|,
name|FROM_LEADER
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|ulog
operator|.
name|dropBufferedUpdates
argument_list|()
argument_list|)
expr_stmt|;
name|ulog
operator|.
name|bufferUpdates
argument_list|()
expr_stmt|;
name|updateJ
argument_list|(
name|jsonAdd
argument_list|(
name|sdoc
argument_list|(
literal|"id"
argument_list|,
literal|"C4"
argument_list|,
literal|"_version_"
argument_list|,
literal|"104"
argument_list|)
argument_list|)
argument_list|,
name|params
argument_list|(
name|DISTRIB_UPDATE_PARAM
argument_list|,
name|FROM_LEADER
argument_list|)
argument_list|)
expr_stmt|;
name|updateJ
argument_list|(
name|jsonAdd
argument_list|(
name|sdoc
argument_list|(
literal|"id"
argument_list|,
literal|"C5"
argument_list|,
literal|"_version_"
argument_list|,
literal|"105"
argument_list|)
argument_list|)
argument_list|,
name|params
argument_list|(
name|DISTRIB_UPDATE_PARAM
argument_list|,
name|FROM_LEADER
argument_list|)
argument_list|)
expr_stmt|;
name|logReplay
operator|.
name|release
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|rinfoFuture
operator|=
name|ulog
operator|.
name|applyBufferedUpdates
argument_list|()
expr_stmt|;
name|UpdateLog
operator|.
name|RecoveryInfo
name|rinfo
init|=
name|rinfoFuture
operator|.
name|get
argument_list|()
decl_stmt|;
name|assertEquals
argument_list|(
literal|2
argument_list|,
name|rinfo
operator|.
name|adds
argument_list|)
expr_stmt|;
name|assertJQ
argument_list|(
name|req
argument_list|(
literal|"qt"
argument_list|,
literal|"/get"
argument_list|,
literal|"getVersions"
argument_list|,
literal|"2"
argument_list|)
argument_list|,
literal|"=={'versions':[105,104]}"
argument_list|)
expr_stmt|;
comment|// this time add some docs first before buffering starts (so tlog won't be at pos 0)
name|updateJ
argument_list|(
name|jsonAdd
argument_list|(
name|sdoc
argument_list|(
literal|"id"
argument_list|,
literal|"C100"
argument_list|,
literal|"_version_"
argument_list|,
literal|"200"
argument_list|)
argument_list|)
argument_list|,
name|params
argument_list|(
name|DISTRIB_UPDATE_PARAM
argument_list|,
name|FROM_LEADER
argument_list|)
argument_list|)
expr_stmt|;
name|updateJ
argument_list|(
name|jsonAdd
argument_list|(
name|sdoc
argument_list|(
literal|"id"
argument_list|,
literal|"C101"
argument_list|,
literal|"_version_"
argument_list|,
literal|"201"
argument_list|)
argument_list|)
argument_list|,
name|params
argument_list|(
name|DISTRIB_UPDATE_PARAM
argument_list|,
name|FROM_LEADER
argument_list|)
argument_list|)
expr_stmt|;
name|ulog
operator|.
name|bufferUpdates
argument_list|()
expr_stmt|;
name|updateJ
argument_list|(
name|jsonAdd
argument_list|(
name|sdoc
argument_list|(
literal|"id"
argument_list|,
literal|"C103"
argument_list|,
literal|"_version_"
argument_list|,
literal|"203"
argument_list|)
argument_list|)
argument_list|,
name|params
argument_list|(
name|DISTRIB_UPDATE_PARAM
argument_list|,
name|FROM_LEADER
argument_list|)
argument_list|)
expr_stmt|;
name|updateJ
argument_list|(
name|jsonAdd
argument_list|(
name|sdoc
argument_list|(
literal|"id"
argument_list|,
literal|"C104"
argument_list|,
literal|"_version_"
argument_list|,
literal|"204"
argument_list|)
argument_list|)
argument_list|,
name|params
argument_list|(
name|DISTRIB_UPDATE_PARAM
argument_list|,
name|FROM_LEADER
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|ulog
operator|.
name|dropBufferedUpdates
argument_list|()
argument_list|)
expr_stmt|;
name|ulog
operator|.
name|bufferUpdates
argument_list|()
expr_stmt|;
name|updateJ
argument_list|(
name|jsonAdd
argument_list|(
name|sdoc
argument_list|(
literal|"id"
argument_list|,
literal|"C105"
argument_list|,
literal|"_version_"
argument_list|,
literal|"205"
argument_list|)
argument_list|)
argument_list|,
name|params
argument_list|(
name|DISTRIB_UPDATE_PARAM
argument_list|,
name|FROM_LEADER
argument_list|)
argument_list|)
expr_stmt|;
name|updateJ
argument_list|(
name|jsonAdd
argument_list|(
name|sdoc
argument_list|(
literal|"id"
argument_list|,
literal|"C106"
argument_list|,
literal|"_version_"
argument_list|,
literal|"206"
argument_list|)
argument_list|)
argument_list|,
name|params
argument_list|(
name|DISTRIB_UPDATE_PARAM
argument_list|,
name|FROM_LEADER
argument_list|)
argument_list|)
expr_stmt|;
name|rinfoFuture
operator|=
name|ulog
operator|.
name|applyBufferedUpdates
argument_list|()
expr_stmt|;
name|rinfo
operator|=
name|rinfoFuture
operator|.
name|get
argument_list|()
expr_stmt|;
name|assertEquals
argument_list|(
literal|2
argument_list|,
name|rinfo
operator|.
name|adds
argument_list|)
expr_stmt|;
name|assertJQ
argument_list|(
name|req
argument_list|(
literal|"q"
argument_list|,
literal|"*:*"
argument_list|,
literal|"sort"
argument_list|,
literal|"_version_ asc"
argument_list|,
literal|"fl"
argument_list|,
literal|"id,_version_"
argument_list|)
argument_list|,
literal|"/response/docs==["
operator|+
literal|"{'id':'C4','_version_':104}"
operator|+
literal|",{'id':'C5','_version_':105}"
operator|+
literal|",{'id':'C100','_version_':200}"
operator|+
literal|",{'id':'C101','_version_':201}"
operator|+
literal|",{'id':'C105','_version_':205}"
operator|+
literal|",{'id':'C106','_version_':206}"
operator|+
literal|"]"
argument_list|)
expr_stmt|;
name|assertJQ
argument_list|(
name|req
argument_list|(
literal|"qt"
argument_list|,
literal|"/get"
argument_list|,
literal|"getVersions"
argument_list|,
literal|"6"
argument_list|)
argument_list|,
literal|"=={'versions':[206,205,201,200,105,104]}"
argument_list|)
expr_stmt|;
name|ulog
operator|.
name|bufferUpdates
argument_list|()
expr_stmt|;
name|assertEquals
argument_list|(
name|UpdateLog
operator|.
name|State
operator|.
name|BUFFERING
argument_list|,
name|ulog
operator|.
name|getState
argument_list|()
argument_list|)
expr_stmt|;
name|updateJ
argument_list|(
name|jsonAdd
argument_list|(
name|sdoc
argument_list|(
literal|"id"
argument_list|,
literal|"C301"
argument_list|,
literal|"_version_"
argument_list|,
literal|"998"
argument_list|)
argument_list|)
argument_list|,
name|params
argument_list|(
name|DISTRIB_UPDATE_PARAM
argument_list|,
name|FROM_LEADER
argument_list|)
argument_list|)
expr_stmt|;
name|updateJ
argument_list|(
name|jsonAdd
argument_list|(
name|sdoc
argument_list|(
literal|"id"
argument_list|,
literal|"C302"
argument_list|,
literal|"_version_"
argument_list|,
literal|"999"
argument_list|)
argument_list|)
argument_list|,
name|params
argument_list|(
name|DISTRIB_UPDATE_PARAM
argument_list|,
name|FROM_LEADER
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|ulog
operator|.
name|dropBufferedUpdates
argument_list|()
argument_list|)
expr_stmt|;
comment|// make sure we can overwrite with a lower version
comment|// TODO: is this functionality needed?
name|updateJ
argument_list|(
name|jsonAdd
argument_list|(
name|sdoc
argument_list|(
literal|"id"
argument_list|,
literal|"C301"
argument_list|,
literal|"_version_"
argument_list|,
literal|"301"
argument_list|)
argument_list|)
argument_list|,
name|params
argument_list|(
name|DISTRIB_UPDATE_PARAM
argument_list|,
name|FROM_LEADER
argument_list|)
argument_list|)
expr_stmt|;
name|updateJ
argument_list|(
name|jsonAdd
argument_list|(
name|sdoc
argument_list|(
literal|"id"
argument_list|,
literal|"C302"
argument_list|,
literal|"_version_"
argument_list|,
literal|"302"
argument_list|)
argument_list|)
argument_list|,
name|params
argument_list|(
name|DISTRIB_UPDATE_PARAM
argument_list|,
name|FROM_LEADER
argument_list|)
argument_list|)
expr_stmt|;
name|assertU
argument_list|(
name|commit
argument_list|()
argument_list|)
expr_stmt|;
name|assertJQ
argument_list|(
name|req
argument_list|(
literal|"qt"
argument_list|,
literal|"/get"
argument_list|,
literal|"getVersions"
argument_list|,
literal|"2"
argument_list|)
argument_list|,
literal|"=={'versions':[302,301]}"
argument_list|)
expr_stmt|;
name|assertJQ
argument_list|(
name|req
argument_list|(
literal|"q"
argument_list|,
literal|"*:*"
argument_list|,
literal|"sort"
argument_list|,
literal|"_version_ desc"
argument_list|,
literal|"fl"
argument_list|,
literal|"id,_version_"
argument_list|,
literal|"rows"
argument_list|,
literal|"2"
argument_list|)
argument_list|,
literal|"/response/docs==["
operator|+
literal|"{'id':'C302','_version_':302}"
operator|+
literal|",{'id':'C301','_version_':301}"
operator|+
literal|"]"
argument_list|)
expr_stmt|;
name|updateJ
argument_list|(
name|jsonAdd
argument_list|(
name|sdoc
argument_list|(
literal|"id"
argument_list|,
literal|"C2"
argument_list|,
literal|"_version_"
argument_list|,
literal|"302"
argument_list|)
argument_list|)
argument_list|,
name|params
argument_list|(
name|DISTRIB_UPDATE_PARAM
argument_list|,
name|FROM_LEADER
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|UpdateLog
operator|.
name|State
operator|.
name|ACTIVE
argument_list|,
name|ulog
operator|.
name|getState
argument_list|()
argument_list|)
expr_stmt|;
comment|// leave each test method in a good state
block|}
finally|finally
block|{
name|DirectUpdateHandler2
operator|.
name|commitOnClose
operator|=
literal|true
expr_stmt|;
name|UpdateLog
operator|.
name|testing_logReplayHook
operator|=
literal|null
expr_stmt|;
name|UpdateLog
operator|.
name|testing_logReplayFinishHook
operator|=
literal|null
expr_stmt|;
name|req
argument_list|()
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Test
DECL|method|testBufferedMultipleCalls
specifier|public
name|void
name|testBufferedMultipleCalls
parameter_list|()
throws|throws
name|Exception
block|{
name|DirectUpdateHandler2
operator|.
name|commitOnClose
operator|=
literal|false
expr_stmt|;
specifier|final
name|Semaphore
name|logReplay
init|=
operator|new
name|Semaphore
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|Semaphore
name|logReplayFinish
init|=
operator|new
name|Semaphore
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|UpdateLog
operator|.
name|testing_logReplayHook
operator|=
parameter_list|()
lambda|->
block|{
try|try
block|{
name|assertTrue
argument_list|(
name|logReplay
operator|.
name|tryAcquire
argument_list|(
name|timeout
argument_list|,
name|TimeUnit
operator|.
name|SECONDS
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
expr_stmt|;
name|UpdateLog
operator|.
name|testing_logReplayFinishHook
operator|=
parameter_list|()
lambda|->
name|logReplayFinish
operator|.
name|release
argument_list|()
expr_stmt|;
name|SolrQueryRequest
name|req
init|=
name|req
argument_list|()
decl_stmt|;
name|UpdateHandler
name|uhandler
init|=
name|req
operator|.
name|getCore
argument_list|()
operator|.
name|getUpdateHandler
argument_list|()
decl_stmt|;
name|UpdateLog
name|ulog
init|=
name|uhandler
operator|.
name|getUpdateLog
argument_list|()
decl_stmt|;
name|Future
argument_list|<
name|UpdateLog
operator|.
name|RecoveryInfo
argument_list|>
name|rinfoFuture
decl_stmt|;
try|try
block|{
name|clearIndex
argument_list|()
expr_stmt|;
name|assertU
argument_list|(
name|commit
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|UpdateLog
operator|.
name|State
operator|.
name|ACTIVE
argument_list|,
name|ulog
operator|.
name|getState
argument_list|()
argument_list|)
expr_stmt|;
name|ulog
operator|.
name|bufferUpdates
argument_list|()
expr_stmt|;
name|assertEquals
argument_list|(
name|UpdateLog
operator|.
name|State
operator|.
name|BUFFERING
argument_list|,
name|ulog
operator|.
name|getState
argument_list|()
argument_list|)
expr_stmt|;
comment|// simulate updates from a leader
name|updateJ
argument_list|(
name|jsonAdd
argument_list|(
name|sdoc
argument_list|(
literal|"id"
argument_list|,
literal|"c1"
argument_list|,
literal|"_version_"
argument_list|,
literal|"101"
argument_list|)
argument_list|)
argument_list|,
name|params
argument_list|(
name|DISTRIB_UPDATE_PARAM
argument_list|,
name|FROM_LEADER
argument_list|)
argument_list|)
expr_stmt|;
name|updateJ
argument_list|(
name|jsonAdd
argument_list|(
name|sdoc
argument_list|(
literal|"id"
argument_list|,
literal|"c2"
argument_list|,
literal|"_version_"
argument_list|,
literal|"102"
argument_list|)
argument_list|)
argument_list|,
name|params
argument_list|(
name|DISTRIB_UPDATE_PARAM
argument_list|,
name|FROM_LEADER
argument_list|)
argument_list|)
expr_stmt|;
name|updateJ
argument_list|(
name|jsonAdd
argument_list|(
name|sdoc
argument_list|(
literal|"id"
argument_list|,
literal|"c3"
argument_list|,
literal|"_version_"
argument_list|,
literal|"103"
argument_list|)
argument_list|)
argument_list|,
name|params
argument_list|(
name|DISTRIB_UPDATE_PARAM
argument_list|,
name|FROM_LEADER
argument_list|)
argument_list|)
expr_stmt|;
comment|// call bufferUpdates again (this currently happens when recovery fails)... we should get a new starting point
name|ulog
operator|.
name|bufferUpdates
argument_list|()
expr_stmt|;
name|assertEquals
argument_list|(
name|UpdateLog
operator|.
name|State
operator|.
name|BUFFERING
argument_list|,
name|ulog
operator|.
name|getState
argument_list|()
argument_list|)
expr_stmt|;
name|updateJ
argument_list|(
name|jsonAdd
argument_list|(
name|sdoc
argument_list|(
literal|"id"
argument_list|,
literal|"c4"
argument_list|,
literal|"_version_"
argument_list|,
literal|"104"
argument_list|)
argument_list|)
argument_list|,
name|params
argument_list|(
name|DISTRIB_UPDATE_PARAM
argument_list|,
name|FROM_LEADER
argument_list|)
argument_list|)
expr_stmt|;
name|updateJ
argument_list|(
name|jsonAdd
argument_list|(
name|sdoc
argument_list|(
literal|"id"
argument_list|,
literal|"c5"
argument_list|,
literal|"_version_"
argument_list|,
literal|"105"
argument_list|)
argument_list|)
argument_list|,
name|params
argument_list|(
name|DISTRIB_UPDATE_PARAM
argument_list|,
name|FROM_LEADER
argument_list|)
argument_list|)
expr_stmt|;
name|logReplay
operator|.
name|release
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|rinfoFuture
operator|=
name|ulog
operator|.
name|applyBufferedUpdates
argument_list|()
expr_stmt|;
name|UpdateLog
operator|.
name|RecoveryInfo
name|rinfo
init|=
name|rinfoFuture
operator|.
name|get
argument_list|()
decl_stmt|;
name|assertEquals
argument_list|(
literal|2
argument_list|,
name|rinfo
operator|.
name|adds
argument_list|)
expr_stmt|;
name|assertJQ
argument_list|(
name|req
argument_list|(
literal|"qt"
argument_list|,
literal|"/get"
argument_list|,
literal|"getVersions"
argument_list|,
literal|"2"
argument_list|)
argument_list|,
literal|"=={'versions':[105,104]}"
argument_list|)
expr_stmt|;
comment|// this time add some docs first before buffering starts (so tlog won't be at pos 0)
name|updateJ
argument_list|(
name|jsonAdd
argument_list|(
name|sdoc
argument_list|(
literal|"id"
argument_list|,
literal|"c100"
argument_list|,
literal|"_version_"
argument_list|,
literal|"200"
argument_list|)
argument_list|)
argument_list|,
name|params
argument_list|(
name|DISTRIB_UPDATE_PARAM
argument_list|,
name|FROM_LEADER
argument_list|)
argument_list|)
expr_stmt|;
name|updateJ
argument_list|(
name|jsonAdd
argument_list|(
name|sdoc
argument_list|(
literal|"id"
argument_list|,
literal|"c101"
argument_list|,
literal|"_version_"
argument_list|,
literal|"201"
argument_list|)
argument_list|)
argument_list|,
name|params
argument_list|(
name|DISTRIB_UPDATE_PARAM
argument_list|,
name|FROM_LEADER
argument_list|)
argument_list|)
expr_stmt|;
name|ulog
operator|.
name|bufferUpdates
argument_list|()
expr_stmt|;
name|updateJ
argument_list|(
name|jsonAdd
argument_list|(
name|sdoc
argument_list|(
literal|"id"
argument_list|,
literal|"c103"
argument_list|,
literal|"_version_"
argument_list|,
literal|"203"
argument_list|)
argument_list|)
argument_list|,
name|params
argument_list|(
name|DISTRIB_UPDATE_PARAM
argument_list|,
name|FROM_LEADER
argument_list|)
argument_list|)
expr_stmt|;
name|updateJ
argument_list|(
name|jsonAdd
argument_list|(
name|sdoc
argument_list|(
literal|"id"
argument_list|,
literal|"c104"
argument_list|,
literal|"_version_"
argument_list|,
literal|"204"
argument_list|)
argument_list|)
argument_list|,
name|params
argument_list|(
name|DISTRIB_UPDATE_PARAM
argument_list|,
name|FROM_LEADER
argument_list|)
argument_list|)
expr_stmt|;
comment|// call bufferUpdates again (this currently happens when recovery fails)... we should get a new starting point
name|ulog
operator|.
name|bufferUpdates
argument_list|()
expr_stmt|;
name|updateJ
argument_list|(
name|jsonAdd
argument_list|(
name|sdoc
argument_list|(
literal|"id"
argument_list|,
literal|"c105"
argument_list|,
literal|"_version_"
argument_list|,
literal|"205"
argument_list|)
argument_list|)
argument_list|,
name|params
argument_list|(
name|DISTRIB_UPDATE_PARAM
argument_list|,
name|FROM_LEADER
argument_list|)
argument_list|)
expr_stmt|;
name|updateJ
argument_list|(
name|jsonAdd
argument_list|(
name|sdoc
argument_list|(
literal|"id"
argument_list|,
literal|"c106"
argument_list|,
literal|"_version_"
argument_list|,
literal|"206"
argument_list|)
argument_list|)
argument_list|,
name|params
argument_list|(
name|DISTRIB_UPDATE_PARAM
argument_list|,
name|FROM_LEADER
argument_list|)
argument_list|)
expr_stmt|;
name|rinfoFuture
operator|=
name|ulog
operator|.
name|applyBufferedUpdates
argument_list|()
expr_stmt|;
name|rinfo
operator|=
name|rinfoFuture
operator|.
name|get
argument_list|()
expr_stmt|;
name|assertEquals
argument_list|(
literal|2
argument_list|,
name|rinfo
operator|.
name|adds
argument_list|)
expr_stmt|;
name|assertJQ
argument_list|(
name|req
argument_list|(
literal|"q"
argument_list|,
literal|"*:*"
argument_list|,
literal|"sort"
argument_list|,
literal|"_version_ asc"
argument_list|,
literal|"fl"
argument_list|,
literal|"id,_version_"
argument_list|)
argument_list|,
literal|"/response/docs==["
operator|+
literal|"{'id':'c4','_version_':104}"
operator|+
literal|",{'id':'c5','_version_':105}"
operator|+
literal|",{'id':'c100','_version_':200}"
operator|+
literal|",{'id':'c101','_version_':201}"
operator|+
literal|",{'id':'c105','_version_':205}"
operator|+
literal|",{'id':'c106','_version_':206}"
operator|+
literal|"]"
argument_list|)
expr_stmt|;
comment|// The updates that were buffered (but never applied) still appear in recent versions!
comment|// This is good for some uses, but may not be good for others.
name|assertJQ
argument_list|(
name|req
argument_list|(
literal|"qt"
argument_list|,
literal|"/get"
argument_list|,
literal|"getVersions"
argument_list|,
literal|"11"
argument_list|)
argument_list|,
literal|"=={'versions':[206,205,204,203,201,200,105,104,103,102,101]}"
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|UpdateLog
operator|.
name|State
operator|.
name|ACTIVE
argument_list|,
name|ulog
operator|.
name|getState
argument_list|()
argument_list|)
expr_stmt|;
comment|// leave each test method in a good state
block|}
finally|finally
block|{
name|DirectUpdateHandler2
operator|.
name|commitOnClose
operator|=
literal|true
expr_stmt|;
name|UpdateLog
operator|.
name|testing_logReplayHook
operator|=
literal|null
expr_stmt|;
name|UpdateLog
operator|.
name|testing_logReplayFinishHook
operator|=
literal|null
expr_stmt|;
name|req
argument_list|()
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
comment|// we need to make sure that the log is informed of a core reload
annotation|@
name|Test
DECL|method|testReload
specifier|public
name|void
name|testReload
parameter_list|()
throws|throws
name|Exception
block|{
name|long
name|version
init|=
name|addAndGetVersion
argument_list|(
name|sdoc
argument_list|(
literal|"id"
argument_list|,
literal|"reload1"
argument_list|)
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|h
operator|.
name|reload
argument_list|()
expr_stmt|;
name|version
operator|=
name|addAndGetVersion
argument_list|(
name|sdoc
argument_list|(
literal|"id"
argument_list|,
literal|"reload1"
argument_list|,
literal|"_version_"
argument_list|,
name|Long
operator|.
name|toString
argument_list|(
name|version
argument_list|)
argument_list|)
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|assertU
argument_list|(
name|commit
argument_list|()
argument_list|)
expr_stmt|;
comment|// if we try the optimistic concurrency again, the tlog lookup maps should be clear
comment|// and we should go to the index to check the version.  This indirectly tests that
comment|// the update log was informed of the reload.  See SOLR-4858
name|version
operator|=
name|addAndGetVersion
argument_list|(
name|sdoc
argument_list|(
literal|"id"
argument_list|,
literal|"reload1"
argument_list|,
literal|"_version_"
argument_list|,
name|Long
operator|.
name|toString
argument_list|(
name|version
argument_list|)
argument_list|)
argument_list|,
literal|null
argument_list|)
expr_stmt|;
comment|// a deleteByQuery currently forces open a new realtime reader via the update log.
comment|// This also tests that the update log was informed of the new udpate handler.
name|deleteByQueryAndGetVersion
argument_list|(
literal|"foo_t:hownowbrowncow"
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|version
operator|=
name|addAndGetVersion
argument_list|(
name|sdoc
argument_list|(
literal|"id"
argument_list|,
literal|"reload1"
argument_list|,
literal|"_version_"
argument_list|,
name|Long
operator|.
name|toString
argument_list|(
name|version
argument_list|)
argument_list|)
argument_list|,
literal|null
argument_list|)
expr_stmt|;
comment|// if the update log was not informed of the new update handler, then the old core will
comment|// incorrectly be used for some of the operations above and opened searchers
comment|// will never be closed.  This used to cause the test framework to fail because of unclosed directory checks.
comment|// SolrCore.openNewSearcher was modified to throw an error if the core is closed, resulting in
comment|// a faster fail.
block|}
annotation|@
name|Test
DECL|method|testBufferingFlags
specifier|public
name|void
name|testBufferingFlags
parameter_list|()
throws|throws
name|Exception
block|{
name|DirectUpdateHandler2
operator|.
name|commitOnClose
operator|=
literal|false
expr_stmt|;
specifier|final
name|Semaphore
name|logReplayFinish
init|=
operator|new
name|Semaphore
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|UpdateLog
operator|.
name|testing_logReplayFinishHook
operator|=
parameter_list|()
lambda|->
name|logReplayFinish
operator|.
name|release
argument_list|()
expr_stmt|;
name|SolrQueryRequest
name|req
init|=
name|req
argument_list|()
decl_stmt|;
name|UpdateHandler
name|uhandler
init|=
name|req
operator|.
name|getCore
argument_list|()
operator|.
name|getUpdateHandler
argument_list|()
decl_stmt|;
name|UpdateLog
name|ulog
init|=
name|uhandler
operator|.
name|getUpdateLog
argument_list|()
decl_stmt|;
try|try
block|{
name|clearIndex
argument_list|()
expr_stmt|;
name|assertU
argument_list|(
name|commit
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|UpdateLog
operator|.
name|State
operator|.
name|ACTIVE
argument_list|,
name|ulog
operator|.
name|getState
argument_list|()
argument_list|)
expr_stmt|;
name|ulog
operator|.
name|bufferUpdates
argument_list|()
expr_stmt|;
comment|// simulate updates from a leader
name|updateJ
argument_list|(
name|jsonAdd
argument_list|(
name|sdoc
argument_list|(
literal|"id"
argument_list|,
literal|"Q1"
argument_list|,
literal|"_version_"
argument_list|,
literal|"101"
argument_list|)
argument_list|)
argument_list|,
name|params
argument_list|(
name|DISTRIB_UPDATE_PARAM
argument_list|,
name|FROM_LEADER
argument_list|)
argument_list|)
expr_stmt|;
name|updateJ
argument_list|(
name|jsonAdd
argument_list|(
name|sdoc
argument_list|(
literal|"id"
argument_list|,
literal|"Q2"
argument_list|,
literal|"_version_"
argument_list|,
literal|"102"
argument_list|)
argument_list|)
argument_list|,
name|params
argument_list|(
name|DISTRIB_UPDATE_PARAM
argument_list|,
name|FROM_LEADER
argument_list|)
argument_list|)
expr_stmt|;
name|updateJ
argument_list|(
name|jsonAdd
argument_list|(
name|sdoc
argument_list|(
literal|"id"
argument_list|,
literal|"Q3"
argument_list|,
literal|"_version_"
argument_list|,
literal|"103"
argument_list|)
argument_list|)
argument_list|,
name|params
argument_list|(
name|DISTRIB_UPDATE_PARAM
argument_list|,
name|FROM_LEADER
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|UpdateLog
operator|.
name|State
operator|.
name|BUFFERING
argument_list|,
name|ulog
operator|.
name|getState
argument_list|()
argument_list|)
expr_stmt|;
name|req
operator|.
name|close
argument_list|()
expr_stmt|;
name|h
operator|.
name|close
argument_list|()
expr_stmt|;
name|createCore
argument_list|()
expr_stmt|;
name|req
operator|=
name|req
argument_list|()
expr_stmt|;
name|uhandler
operator|=
name|req
operator|.
name|getCore
argument_list|()
operator|.
name|getUpdateHandler
argument_list|()
expr_stmt|;
name|ulog
operator|=
name|uhandler
operator|.
name|getUpdateLog
argument_list|()
expr_stmt|;
name|logReplayFinish
operator|.
name|acquire
argument_list|()
expr_stmt|;
comment|// wait for replay to finish
name|assertTrue
argument_list|(
operator|(
name|ulog
operator|.
name|getStartingOperation
argument_list|()
operator|&
name|UpdateLog
operator|.
name|FLAG_GAP
operator|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
comment|// since we died while buffering, we should see this last
comment|//
comment|// Try again to ensure that the previous log replay didn't wipe out our flags
comment|//
name|req
operator|.
name|close
argument_list|()
expr_stmt|;
name|h
operator|.
name|close
argument_list|()
expr_stmt|;
name|createCore
argument_list|()
expr_stmt|;
name|req
operator|=
name|req
argument_list|()
expr_stmt|;
name|uhandler
operator|=
name|req
operator|.
name|getCore
argument_list|()
operator|.
name|getUpdateHandler
argument_list|()
expr_stmt|;
name|ulog
operator|=
name|uhandler
operator|.
name|getUpdateLog
argument_list|()
expr_stmt|;
name|assertTrue
argument_list|(
operator|(
name|ulog
operator|.
name|getStartingOperation
argument_list|()
operator|&
name|UpdateLog
operator|.
name|FLAG_GAP
operator|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
comment|// now do some normal non-buffered adds
name|updateJ
argument_list|(
name|jsonAdd
argument_list|(
name|sdoc
argument_list|(
literal|"id"
argument_list|,
literal|"Q4"
argument_list|,
literal|"_version_"
argument_list|,
literal|"114"
argument_list|)
argument_list|)
argument_list|,
name|params
argument_list|(
name|DISTRIB_UPDATE_PARAM
argument_list|,
name|FROM_LEADER
argument_list|)
argument_list|)
expr_stmt|;
name|updateJ
argument_list|(
name|jsonAdd
argument_list|(
name|sdoc
argument_list|(
literal|"id"
argument_list|,
literal|"Q5"
argument_list|,
literal|"_version_"
argument_list|,
literal|"115"
argument_list|)
argument_list|)
argument_list|,
name|params
argument_list|(
name|DISTRIB_UPDATE_PARAM
argument_list|,
name|FROM_LEADER
argument_list|)
argument_list|)
expr_stmt|;
name|updateJ
argument_list|(
name|jsonAdd
argument_list|(
name|sdoc
argument_list|(
literal|"id"
argument_list|,
literal|"Q6"
argument_list|,
literal|"_version_"
argument_list|,
literal|"116"
argument_list|)
argument_list|)
argument_list|,
name|params
argument_list|(
name|DISTRIB_UPDATE_PARAM
argument_list|,
name|FROM_LEADER
argument_list|)
argument_list|)
expr_stmt|;
name|assertU
argument_list|(
name|commit
argument_list|()
argument_list|)
expr_stmt|;
name|req
operator|.
name|close
argument_list|()
expr_stmt|;
name|h
operator|.
name|close
argument_list|()
expr_stmt|;
name|createCore
argument_list|()
expr_stmt|;
name|req
operator|=
name|req
argument_list|()
expr_stmt|;
name|uhandler
operator|=
name|req
operator|.
name|getCore
argument_list|()
operator|.
name|getUpdateHandler
argument_list|()
expr_stmt|;
name|ulog
operator|=
name|uhandler
operator|.
name|getUpdateLog
argument_list|()
expr_stmt|;
name|assertTrue
argument_list|(
operator|(
name|ulog
operator|.
name|getStartingOperation
argument_list|()
operator|&
name|UpdateLog
operator|.
name|FLAG_GAP
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ulog
operator|.
name|bufferUpdates
argument_list|()
expr_stmt|;
comment|// simulate receiving no updates
name|ulog
operator|.
name|applyBufferedUpdates
argument_list|()
expr_stmt|;
name|updateJ
argument_list|(
name|jsonAdd
argument_list|(
name|sdoc
argument_list|(
literal|"id"
argument_list|,
literal|"Q7"
argument_list|,
literal|"_version_"
argument_list|,
literal|"117"
argument_list|)
argument_list|)
argument_list|,
name|params
argument_list|(
name|DISTRIB_UPDATE_PARAM
argument_list|,
name|FROM_LEADER
argument_list|)
argument_list|)
expr_stmt|;
comment|// do another add to make sure flags are back to normal
name|req
operator|.
name|close
argument_list|()
expr_stmt|;
name|h
operator|.
name|close
argument_list|()
expr_stmt|;
name|createCore
argument_list|()
expr_stmt|;
name|req
operator|=
name|req
argument_list|()
expr_stmt|;
name|uhandler
operator|=
name|req
operator|.
name|getCore
argument_list|()
operator|.
name|getUpdateHandler
argument_list|()
expr_stmt|;
name|ulog
operator|=
name|uhandler
operator|.
name|getUpdateLog
argument_list|()
expr_stmt|;
name|assertTrue
argument_list|(
operator|(
name|ulog
operator|.
name|getStartingOperation
argument_list|()
operator|&
name|UpdateLog
operator|.
name|FLAG_GAP
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|// check flags on Q7
name|logReplayFinish
operator|.
name|acquire
argument_list|()
expr_stmt|;
name|assertEquals
argument_list|(
name|UpdateLog
operator|.
name|State
operator|.
name|ACTIVE
argument_list|,
name|ulog
operator|.
name|getState
argument_list|()
argument_list|)
expr_stmt|;
comment|// leave each test method in a good state
block|}
finally|finally
block|{
name|DirectUpdateHandler2
operator|.
name|commitOnClose
operator|=
literal|true
expr_stmt|;
name|UpdateLog
operator|.
name|testing_logReplayHook
operator|=
literal|null
expr_stmt|;
name|UpdateLog
operator|.
name|testing_logReplayFinishHook
operator|=
literal|null
expr_stmt|;
name|req
argument_list|()
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
comment|// make sure that on a restart, versions don't start too low
annotation|@
name|Test
DECL|method|testVersionsOnRestart
specifier|public
name|void
name|testVersionsOnRestart
parameter_list|()
throws|throws
name|Exception
block|{
name|clearIndex
argument_list|()
expr_stmt|;
name|assertU
argument_list|(
name|commit
argument_list|()
argument_list|)
expr_stmt|;
name|assertU
argument_list|(
name|adoc
argument_list|(
literal|"id"
argument_list|,
literal|"D1"
argument_list|,
literal|"val_i"
argument_list|,
literal|"1"
argument_list|)
argument_list|)
expr_stmt|;
name|assertU
argument_list|(
name|adoc
argument_list|(
literal|"id"
argument_list|,
literal|"D2"
argument_list|,
literal|"val_i"
argument_list|,
literal|"1"
argument_list|)
argument_list|)
expr_stmt|;
name|assertU
argument_list|(
name|commit
argument_list|()
argument_list|)
expr_stmt|;
name|long
name|v1
init|=
name|getVer
argument_list|(
name|req
argument_list|(
literal|"q"
argument_list|,
literal|"id:D1"
argument_list|)
argument_list|)
decl_stmt|;
name|long
name|v1a
init|=
name|getVer
argument_list|(
name|req
argument_list|(
literal|"q"
argument_list|,
literal|"id:D2"
argument_list|)
argument_list|)
decl_stmt|;
name|h
operator|.
name|close
argument_list|()
expr_stmt|;
name|createCore
argument_list|()
expr_stmt|;
name|assertU
argument_list|(
name|adoc
argument_list|(
literal|"id"
argument_list|,
literal|"D1"
argument_list|,
literal|"val_i"
argument_list|,
literal|"2"
argument_list|)
argument_list|)
expr_stmt|;
name|assertU
argument_list|(
name|commit
argument_list|()
argument_list|)
expr_stmt|;
name|long
name|v2
init|=
name|getVer
argument_list|(
name|req
argument_list|(
literal|"q"
argument_list|,
literal|"id:D1"
argument_list|)
argument_list|)
decl_stmt|;
assert|assert
operator|(
name|v2
operator|>
name|v1
operator|)
assert|;
name|assertJQ
argument_list|(
name|req
argument_list|(
literal|"qt"
argument_list|,
literal|"/get"
argument_list|,
literal|"getVersions"
argument_list|,
literal|"2"
argument_list|)
argument_list|,
literal|"/versions==["
operator|+
name|v2
operator|+
literal|","
operator|+
name|v1a
operator|+
literal|"]"
argument_list|)
expr_stmt|;
block|}
comment|// make sure that log isn't needlessly replayed after a clean close
annotation|@
name|Test
DECL|method|testCleanShutdown
specifier|public
name|void
name|testCleanShutdown
parameter_list|()
throws|throws
name|Exception
block|{
name|DirectUpdateHandler2
operator|.
name|commitOnClose
operator|=
literal|true
expr_stmt|;
specifier|final
name|Semaphore
name|logReplay
init|=
operator|new
name|Semaphore
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|Semaphore
name|logReplayFinish
init|=
operator|new
name|Semaphore
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|UpdateLog
operator|.
name|testing_logReplayHook
operator|=
parameter_list|()
lambda|->
block|{
try|try
block|{
name|assertTrue
argument_list|(
name|logReplay
operator|.
name|tryAcquire
argument_list|(
name|timeout
argument_list|,
name|TimeUnit
operator|.
name|SECONDS
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
expr_stmt|;
name|UpdateLog
operator|.
name|testing_logReplayFinishHook
operator|=
parameter_list|()
lambda|->
name|logReplayFinish
operator|.
name|release
argument_list|()
expr_stmt|;
name|SolrQueryRequest
name|req
init|=
name|req
argument_list|()
decl_stmt|;
name|UpdateHandler
name|uhandler
init|=
name|req
operator|.
name|getCore
argument_list|()
operator|.
name|getUpdateHandler
argument_list|()
decl_stmt|;
name|UpdateLog
name|ulog
init|=
name|uhandler
operator|.
name|getUpdateLog
argument_list|()
decl_stmt|;
try|try
block|{
name|clearIndex
argument_list|()
expr_stmt|;
name|assertU
argument_list|(
name|commit
argument_list|()
argument_list|)
expr_stmt|;
name|assertU
argument_list|(
name|adoc
argument_list|(
literal|"id"
argument_list|,
literal|"E1"
argument_list|,
literal|"val_i"
argument_list|,
literal|"1"
argument_list|)
argument_list|)
expr_stmt|;
name|assertU
argument_list|(
name|adoc
argument_list|(
literal|"id"
argument_list|,
literal|"E2"
argument_list|,
literal|"val_i"
argument_list|,
literal|"1"
argument_list|)
argument_list|)
expr_stmt|;
comment|// set to a high enough number so this test won't hang on a bug
name|logReplay
operator|.
name|release
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|h
operator|.
name|close
argument_list|()
expr_stmt|;
name|createCore
argument_list|()
expr_stmt|;
comment|// make sure the docs got committed
name|assertJQ
argument_list|(
name|req
argument_list|(
literal|"q"
argument_list|,
literal|"*:*"
argument_list|)
argument_list|,
literal|"/response/numFound==2"
argument_list|)
expr_stmt|;
comment|// make sure no replay happened
name|assertEquals
argument_list|(
literal|10
argument_list|,
name|logReplay
operator|.
name|availablePermits
argument_list|()
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|DirectUpdateHandler2
operator|.
name|commitOnClose
operator|=
literal|true
expr_stmt|;
name|UpdateLog
operator|.
name|testing_logReplayHook
operator|=
literal|null
expr_stmt|;
name|UpdateLog
operator|.
name|testing_logReplayFinishHook
operator|=
literal|null
expr_stmt|;
name|req
argument_list|()
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|addDocs
specifier|private
name|void
name|addDocs
parameter_list|(
name|int
name|nDocs
parameter_list|,
name|int
name|start
parameter_list|,
name|LinkedList
argument_list|<
name|Long
argument_list|>
name|versions
parameter_list|)
throws|throws
name|Exception
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nDocs
condition|;
name|i
operator|++
control|)
block|{
name|versions
operator|.
name|addFirst
argument_list|(
name|addAndGetVersion
argument_list|(
name|sdoc
argument_list|(
literal|"id"
argument_list|,
name|Integer
operator|.
name|toString
argument_list|(
name|start
operator|+
name|nDocs
argument_list|)
argument_list|)
argument_list|,
literal|null
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Test
DECL|method|testRemoveOldLogs
specifier|public
name|void
name|testRemoveOldLogs
parameter_list|()
throws|throws
name|Exception
block|{
try|try
block|{
name|DirectUpdateHandler2
operator|.
name|commitOnClose
operator|=
literal|false
expr_stmt|;
specifier|final
name|Semaphore
name|logReplay
init|=
operator|new
name|Semaphore
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|Semaphore
name|logReplayFinish
init|=
operator|new
name|Semaphore
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|UpdateLog
operator|.
name|testing_logReplayHook
operator|=
parameter_list|()
lambda|->
block|{
try|try
block|{
name|assertTrue
argument_list|(
name|logReplay
operator|.
name|tryAcquire
argument_list|(
name|timeout
argument_list|,
name|TimeUnit
operator|.
name|SECONDS
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
expr_stmt|;
name|UpdateLog
operator|.
name|testing_logReplayFinishHook
operator|=
parameter_list|()
lambda|->
name|logReplayFinish
operator|.
name|release
argument_list|()
expr_stmt|;
name|clearIndex
argument_list|()
expr_stmt|;
name|assertU
argument_list|(
name|commit
argument_list|()
argument_list|)
expr_stmt|;
name|UpdateLog
name|ulog
init|=
name|h
operator|.
name|getCore
argument_list|()
operator|.
name|getUpdateHandler
argument_list|()
operator|.
name|getUpdateLog
argument_list|()
decl_stmt|;
name|File
name|logDir
init|=
operator|new
name|File
argument_list|(
name|h
operator|.
name|getCore
argument_list|()
operator|.
name|getUpdateHandler
argument_list|()
operator|.
name|getUpdateLog
argument_list|()
operator|.
name|getLogDir
argument_list|()
argument_list|)
decl_stmt|;
name|h
operator|.
name|close
argument_list|()
expr_stmt|;
name|String
index|[]
name|files
init|=
name|ulog
operator|.
name|getLogList
argument_list|(
name|logDir
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|file
range|:
name|files
control|)
block|{
name|Files
operator|.
name|delete
argument_list|(
operator|new
name|File
argument_list|(
name|logDir
argument_list|,
name|file
argument_list|)
operator|.
name|toPath
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|ulog
operator|.
name|getLogList
argument_list|(
name|logDir
argument_list|)
operator|.
name|length
argument_list|)
expr_stmt|;
name|createCore
argument_list|()
expr_stmt|;
name|int
name|numIndexed
init|=
literal|0
decl_stmt|;
name|int
name|maxReq
init|=
literal|200
decl_stmt|;
name|LinkedList
argument_list|<
name|Long
argument_list|>
name|versions
init|=
operator|new
name|LinkedList
argument_list|<>
argument_list|()
decl_stmt|;
name|int
name|docsPerBatch
init|=
literal|3
decl_stmt|;
comment|// we don't expect to reach numRecordsToKeep as yet, so the bottleneck is still number of logs to keep
name|int
name|expectedToRetain
init|=
name|ulog
operator|.
name|getMaxNumLogsToKeep
argument_list|()
operator|*
name|docsPerBatch
decl_stmt|;
name|int
name|versExpected
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<=
name|ulog
operator|.
name|getMaxNumLogsToKeep
argument_list|()
operator|+
literal|2
condition|;
name|i
operator|++
control|)
block|{
name|addDocs
argument_list|(
name|docsPerBatch
argument_list|,
name|numIndexed
argument_list|,
name|versions
argument_list|)
expr_stmt|;
name|numIndexed
operator|+=
name|docsPerBatch
expr_stmt|;
name|versExpected
operator|=
name|Math
operator|.
name|min
argument_list|(
name|numIndexed
argument_list|,
name|expectedToRetain
operator|+
name|docsPerBatch
argument_list|)
expr_stmt|;
comment|// not yet committed, so one more tlog could slip in
name|assertJQ
argument_list|(
name|req
argument_list|(
literal|"qt"
argument_list|,
literal|"/get"
argument_list|,
literal|"getVersions"
argument_list|,
literal|""
operator|+
name|maxReq
argument_list|)
argument_list|,
literal|"/versions=="
operator|+
name|versions
operator|.
name|subList
argument_list|(
literal|0
argument_list|,
name|Math
operator|.
name|min
argument_list|(
name|maxReq
argument_list|,
name|versExpected
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|assertU
argument_list|(
name|commit
argument_list|()
argument_list|)
expr_stmt|;
name|versExpected
operator|=
name|Math
operator|.
name|min
argument_list|(
name|numIndexed
argument_list|,
name|expectedToRetain
argument_list|)
expr_stmt|;
name|assertJQ
argument_list|(
name|req
argument_list|(
literal|"qt"
argument_list|,
literal|"/get"
argument_list|,
literal|"getVersions"
argument_list|,
literal|""
operator|+
name|maxReq
argument_list|)
argument_list|,
literal|"/versions=="
operator|+
name|versions
operator|.
name|subList
argument_list|(
literal|0
argument_list|,
name|Math
operator|.
name|min
argument_list|(
name|maxReq
argument_list|,
name|versExpected
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|Math
operator|.
name|min
argument_list|(
name|i
argument_list|,
name|ulog
operator|.
name|getMaxNumLogsToKeep
argument_list|()
argument_list|)
argument_list|,
name|ulog
operator|.
name|getLogList
argument_list|(
name|logDir
argument_list|)
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
name|docsPerBatch
operator|=
name|ulog
operator|.
name|getNumRecordsToKeep
argument_list|()
operator|+
literal|20
expr_stmt|;
comment|// about to commit a lot of docs, so numRecordsToKeep becomes the bottleneck
name|expectedToRetain
operator|=
name|ulog
operator|.
name|getNumRecordsToKeep
argument_list|()
expr_stmt|;
name|addDocs
argument_list|(
name|docsPerBatch
argument_list|,
name|numIndexed
argument_list|,
name|versions
argument_list|)
expr_stmt|;
name|numIndexed
operator|+=
name|docsPerBatch
expr_stmt|;
name|versExpected
operator|=
name|Math
operator|.
name|min
argument_list|(
name|numIndexed
argument_list|,
name|expectedToRetain
argument_list|)
expr_stmt|;
name|assertJQ
argument_list|(
name|req
argument_list|(
literal|"qt"
argument_list|,
literal|"/get"
argument_list|,
literal|"getVersions"
argument_list|,
literal|""
operator|+
name|maxReq
argument_list|)
argument_list|,
literal|"/versions=="
operator|+
name|versions
operator|.
name|subList
argument_list|(
literal|0
argument_list|,
name|Math
operator|.
name|min
argument_list|(
name|maxReq
argument_list|,
name|versExpected
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|assertU
argument_list|(
name|commit
argument_list|()
argument_list|)
expr_stmt|;
name|expectedToRetain
operator|=
name|expectedToRetain
operator|-
literal|1
expr_stmt|;
comment|// we lose a log entry due to the commit record
name|versExpected
operator|=
name|Math
operator|.
name|min
argument_list|(
name|numIndexed
argument_list|,
name|expectedToRetain
argument_list|)
expr_stmt|;
name|assertJQ
argument_list|(
name|req
argument_list|(
literal|"qt"
argument_list|,
literal|"/get"
argument_list|,
literal|"getVersions"
argument_list|,
literal|""
operator|+
name|maxReq
argument_list|)
argument_list|,
literal|"/versions=="
operator|+
name|versions
operator|.
name|subList
argument_list|(
literal|0
argument_list|,
name|Math
operator|.
name|min
argument_list|(
name|maxReq
argument_list|,
name|versExpected
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|// previous logs should be gone now
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|ulog
operator|.
name|getLogList
argument_list|(
name|logDir
argument_list|)
operator|.
name|length
argument_list|)
expr_stmt|;
name|addDocs
argument_list|(
literal|1
argument_list|,
name|numIndexed
argument_list|,
name|versions
argument_list|)
expr_stmt|;
name|numIndexed
operator|+=
literal|1
expr_stmt|;
name|h
operator|.
name|close
argument_list|()
expr_stmt|;
name|createCore
argument_list|()
expr_stmt|;
comment|// trigger recovery, make sure that tlog reference handling is correct
comment|// test we can get versions while replay is happening
name|assertJQ
argument_list|(
name|req
argument_list|(
literal|"qt"
argument_list|,
literal|"/get"
argument_list|,
literal|"getVersions"
argument_list|,
literal|""
operator|+
name|maxReq
argument_list|)
argument_list|,
literal|"/versions=="
operator|+
name|versions
operator|.
name|subList
argument_list|(
literal|0
argument_list|,
name|Math
operator|.
name|min
argument_list|(
name|maxReq
argument_list|,
name|expectedToRetain
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|logReplay
operator|.
name|release
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|logReplayFinish
operator|.
name|tryAcquire
argument_list|(
name|timeout
argument_list|,
name|TimeUnit
operator|.
name|SECONDS
argument_list|)
argument_list|)
expr_stmt|;
name|expectedToRetain
operator|=
name|expectedToRetain
operator|-
literal|1
expr_stmt|;
comment|// we lose a log entry due to the commit record made by recovery
name|assertJQ
argument_list|(
name|req
argument_list|(
literal|"qt"
argument_list|,
literal|"/get"
argument_list|,
literal|"getVersions"
argument_list|,
literal|""
operator|+
name|maxReq
argument_list|)
argument_list|,
literal|"/versions=="
operator|+
name|versions
operator|.
name|subList
argument_list|(
literal|0
argument_list|,
name|Math
operator|.
name|min
argument_list|(
name|maxReq
argument_list|,
name|expectedToRetain
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|docsPerBatch
operator|=
name|ulog
operator|.
name|getNumRecordsToKeep
argument_list|()
operator|+
literal|20
expr_stmt|;
comment|// about to commit a lot of docs, so numRecordsToKeep becomes the bottleneck
name|expectedToRetain
operator|=
name|ulog
operator|.
name|getNumRecordsToKeep
argument_list|()
expr_stmt|;
name|addDocs
argument_list|(
name|docsPerBatch
argument_list|,
name|numIndexed
argument_list|,
name|versions
argument_list|)
expr_stmt|;
name|numIndexed
operator|+=
name|docsPerBatch
expr_stmt|;
name|assertJQ
argument_list|(
name|req
argument_list|(
literal|"qt"
argument_list|,
literal|"/get"
argument_list|,
literal|"getVersions"
argument_list|,
literal|""
operator|+
name|maxReq
argument_list|)
argument_list|,
literal|"/versions=="
operator|+
name|versions
operator|.
name|subList
argument_list|(
literal|0
argument_list|,
name|Math
operator|.
name|min
argument_list|(
name|maxReq
argument_list|,
name|expectedToRetain
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|assertU
argument_list|(
name|commit
argument_list|()
argument_list|)
expr_stmt|;
name|expectedToRetain
operator|=
name|expectedToRetain
operator|-
literal|1
expr_stmt|;
comment|// we lose a log entry due to the commit record
name|assertJQ
argument_list|(
name|req
argument_list|(
literal|"qt"
argument_list|,
literal|"/get"
argument_list|,
literal|"getVersions"
argument_list|,
literal|""
operator|+
name|maxReq
argument_list|)
argument_list|,
literal|"/versions=="
operator|+
name|versions
operator|.
name|subList
argument_list|(
literal|0
argument_list|,
name|Math
operator|.
name|min
argument_list|(
name|maxReq
argument_list|,
name|expectedToRetain
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|// previous logs should be gone now
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|ulog
operator|.
name|getLogList
argument_list|(
name|logDir
argument_list|)
operator|.
name|length
argument_list|)
expr_stmt|;
comment|//
comment|// test that a corrupt tlog file doesn't stop us from coming up, or seeing versions before that tlog file.
comment|//
name|addDocs
argument_list|(
literal|1
argument_list|,
name|numIndexed
argument_list|,
operator|new
name|LinkedList
argument_list|<
name|Long
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
comment|// don't add this to the versions list because we are going to lose it...
name|h
operator|.
name|close
argument_list|()
expr_stmt|;
name|files
operator|=
name|ulog
operator|.
name|getLogList
argument_list|(
name|logDir
argument_list|)
expr_stmt|;
name|Arrays
operator|.
name|sort
argument_list|(
name|files
argument_list|)
expr_stmt|;
name|RandomAccessFile
name|raf
init|=
operator|new
name|RandomAccessFile
argument_list|(
operator|new
name|File
argument_list|(
name|logDir
argument_list|,
name|files
index|[
name|files
operator|.
name|length
operator|-
literal|1
index|]
argument_list|)
argument_list|,
literal|"rw"
argument_list|)
decl_stmt|;
name|raf
operator|.
name|writeChars
argument_list|(
literal|"This is a trashed log file that really shouldn't work at all, but we'll see..."
argument_list|)
expr_stmt|;
name|raf
operator|.
name|close
argument_list|()
expr_stmt|;
name|ignoreException
argument_list|(
literal|"Failure to open existing"
argument_list|)
expr_stmt|;
name|createCore
argument_list|()
expr_stmt|;
comment|// we should still be able to get the list of versions (not including the trashed log file)
name|assertJQ
argument_list|(
name|req
argument_list|(
literal|"qt"
argument_list|,
literal|"/get"
argument_list|,
literal|"getVersions"
argument_list|,
literal|""
operator|+
name|maxReq
argument_list|)
argument_list|,
literal|"/versions=="
operator|+
name|versions
operator|.
name|subList
argument_list|(
literal|0
argument_list|,
name|Math
operator|.
name|min
argument_list|(
name|maxReq
argument_list|,
name|expectedToRetain
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|resetExceptionIgnores
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|DirectUpdateHandler2
operator|.
name|commitOnClose
operator|=
literal|true
expr_stmt|;
name|UpdateLog
operator|.
name|testing_logReplayHook
operator|=
literal|null
expr_stmt|;
name|UpdateLog
operator|.
name|testing_logReplayFinishHook
operator|=
literal|null
expr_stmt|;
block|}
block|}
comment|//
comment|// test that a partially written last tlog entry (that will cause problems for both reverse reading and for
comment|// log replay) doesn't stop us from coming up, and from recovering the documents that were not cut off.
comment|//
annotation|@
name|Test
DECL|method|testTruncatedLog
specifier|public
name|void
name|testTruncatedLog
parameter_list|()
throws|throws
name|Exception
block|{
try|try
block|{
name|DirectUpdateHandler2
operator|.
name|commitOnClose
operator|=
literal|false
expr_stmt|;
specifier|final
name|Semaphore
name|logReplay
init|=
operator|new
name|Semaphore
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|Semaphore
name|logReplayFinish
init|=
operator|new
name|Semaphore
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|UpdateLog
operator|.
name|testing_logReplayHook
operator|=
parameter_list|()
lambda|->
block|{
try|try
block|{
name|assertTrue
argument_list|(
name|logReplay
operator|.
name|tryAcquire
argument_list|(
name|timeout
argument_list|,
name|TimeUnit
operator|.
name|SECONDS
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
expr_stmt|;
name|UpdateLog
operator|.
name|testing_logReplayFinishHook
operator|=
parameter_list|()
lambda|->
name|logReplayFinish
operator|.
name|release
argument_list|()
expr_stmt|;
name|UpdateLog
name|ulog
init|=
name|h
operator|.
name|getCore
argument_list|()
operator|.
name|getUpdateHandler
argument_list|()
operator|.
name|getUpdateLog
argument_list|()
decl_stmt|;
name|File
name|logDir
init|=
operator|new
name|File
argument_list|(
name|h
operator|.
name|getCore
argument_list|()
operator|.
name|getUpdateHandler
argument_list|()
operator|.
name|getUpdateLog
argument_list|()
operator|.
name|getLogDir
argument_list|()
argument_list|)
decl_stmt|;
name|clearIndex
argument_list|()
expr_stmt|;
name|assertU
argument_list|(
name|commit
argument_list|()
argument_list|)
expr_stmt|;
name|assertU
argument_list|(
name|adoc
argument_list|(
literal|"id"
argument_list|,
literal|"F1"
argument_list|)
argument_list|)
expr_stmt|;
name|assertU
argument_list|(
name|adoc
argument_list|(
literal|"id"
argument_list|,
literal|"F2"
argument_list|)
argument_list|)
expr_stmt|;
name|assertU
argument_list|(
name|adoc
argument_list|(
literal|"id"
argument_list|,
literal|"F3"
argument_list|)
argument_list|)
expr_stmt|;
name|h
operator|.
name|close
argument_list|()
expr_stmt|;
name|String
index|[]
name|files
init|=
name|ulog
operator|.
name|getLogList
argument_list|(
name|logDir
argument_list|)
decl_stmt|;
name|Arrays
operator|.
name|sort
argument_list|(
name|files
argument_list|)
expr_stmt|;
name|RandomAccessFile
name|raf
init|=
operator|new
name|RandomAccessFile
argument_list|(
operator|new
name|File
argument_list|(
name|logDir
argument_list|,
name|files
index|[
name|files
operator|.
name|length
operator|-
literal|1
index|]
argument_list|)
argument_list|,
literal|"rw"
argument_list|)
decl_stmt|;
name|raf
operator|.
name|seek
argument_list|(
name|raf
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
comment|// seek to end
name|raf
operator|.
name|writeLong
argument_list|(
literal|0xffffffffffffffffL
argument_list|)
expr_stmt|;
name|raf
operator|.
name|writeChars
argument_list|(
literal|"This should be appended to a good log file, representing a bad partially written record."
argument_list|)
expr_stmt|;
name|raf
operator|.
name|close
argument_list|()
expr_stmt|;
name|logReplay
operator|.
name|release
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|logReplayFinish
operator|.
name|drainPermits
argument_list|()
expr_stmt|;
name|ignoreException
argument_list|(
literal|"OutOfBoundsException"
argument_list|)
expr_stmt|;
comment|// this is what the corrupted log currently produces... subject to change.
name|createCore
argument_list|()
expr_stmt|;
name|assertTrue
argument_list|(
name|logReplayFinish
operator|.
name|tryAcquire
argument_list|(
name|timeout
argument_list|,
name|TimeUnit
operator|.
name|SECONDS
argument_list|)
argument_list|)
expr_stmt|;
name|resetExceptionIgnores
argument_list|()
expr_stmt|;
name|assertJQ
argument_list|(
name|req
argument_list|(
literal|"q"
argument_list|,
literal|"*:*"
argument_list|)
argument_list|,
literal|"/response/numFound==3"
argument_list|)
expr_stmt|;
comment|//
comment|// Now test that the bad log file doesn't mess up retrieving latest versions
comment|//
name|updateJ
argument_list|(
name|jsonAdd
argument_list|(
name|sdoc
argument_list|(
literal|"id"
argument_list|,
literal|"F4"
argument_list|,
literal|"_version_"
argument_list|,
literal|"104"
argument_list|)
argument_list|)
argument_list|,
name|params
argument_list|(
name|DISTRIB_UPDATE_PARAM
argument_list|,
name|FROM_LEADER
argument_list|)
argument_list|)
expr_stmt|;
name|updateJ
argument_list|(
name|jsonAdd
argument_list|(
name|sdoc
argument_list|(
literal|"id"
argument_list|,
literal|"F5"
argument_list|,
literal|"_version_"
argument_list|,
literal|"105"
argument_list|)
argument_list|)
argument_list|,
name|params
argument_list|(
name|DISTRIB_UPDATE_PARAM
argument_list|,
name|FROM_LEADER
argument_list|)
argument_list|)
expr_stmt|;
name|updateJ
argument_list|(
name|jsonAdd
argument_list|(
name|sdoc
argument_list|(
literal|"id"
argument_list|,
literal|"F6"
argument_list|,
literal|"_version_"
argument_list|,
literal|"106"
argument_list|)
argument_list|)
argument_list|,
name|params
argument_list|(
name|DISTRIB_UPDATE_PARAM
argument_list|,
name|FROM_LEADER
argument_list|)
argument_list|)
expr_stmt|;
comment|// This currently skips the bad log file and also returns the version of the clearIndex (del *:*)
comment|// assertJQ(req("qt","/get", "getVersions","6"), "/versions==[106,105,104]");
name|assertJQ
argument_list|(
name|req
argument_list|(
literal|"qt"
argument_list|,
literal|"/get"
argument_list|,
literal|"getVersions"
argument_list|,
literal|"3"
argument_list|)
argument_list|,
literal|"/versions==[106,105,104]"
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|DirectUpdateHandler2
operator|.
name|commitOnClose
operator|=
literal|true
expr_stmt|;
name|UpdateLog
operator|.
name|testing_logReplayHook
operator|=
literal|null
expr_stmt|;
name|UpdateLog
operator|.
name|testing_logReplayFinishHook
operator|=
literal|null
expr_stmt|;
block|}
block|}
comment|//
comment|// test that a corrupt tlog doesn't stop us from coming up
comment|//
annotation|@
name|Test
DECL|method|testCorruptLog
specifier|public
name|void
name|testCorruptLog
parameter_list|()
throws|throws
name|Exception
block|{
try|try
block|{
name|DirectUpdateHandler2
operator|.
name|commitOnClose
operator|=
literal|false
expr_stmt|;
name|UpdateLog
name|ulog
init|=
name|h
operator|.
name|getCore
argument_list|()
operator|.
name|getUpdateHandler
argument_list|()
operator|.
name|getUpdateLog
argument_list|()
decl_stmt|;
name|File
name|logDir
init|=
operator|new
name|File
argument_list|(
name|h
operator|.
name|getCore
argument_list|()
operator|.
name|getUpdateHandler
argument_list|()
operator|.
name|getUpdateLog
argument_list|()
operator|.
name|getLogDir
argument_list|()
argument_list|)
decl_stmt|;
name|clearIndex
argument_list|()
expr_stmt|;
name|assertU
argument_list|(
name|commit
argument_list|()
argument_list|)
expr_stmt|;
name|assertU
argument_list|(
name|adoc
argument_list|(
literal|"id"
argument_list|,
literal|"G1"
argument_list|)
argument_list|)
expr_stmt|;
name|assertU
argument_list|(
name|adoc
argument_list|(
literal|"id"
argument_list|,
literal|"G2"
argument_list|)
argument_list|)
expr_stmt|;
name|assertU
argument_list|(
name|adoc
argument_list|(
literal|"id"
argument_list|,
literal|"G3"
argument_list|)
argument_list|)
expr_stmt|;
name|h
operator|.
name|close
argument_list|()
expr_stmt|;
name|String
index|[]
name|files
init|=
name|ulog
operator|.
name|getLogList
argument_list|(
name|logDir
argument_list|)
decl_stmt|;
name|Arrays
operator|.
name|sort
argument_list|(
name|files
argument_list|)
expr_stmt|;
name|RandomAccessFile
name|raf
init|=
operator|new
name|RandomAccessFile
argument_list|(
operator|new
name|File
argument_list|(
name|logDir
argument_list|,
name|files
index|[
name|files
operator|.
name|length
operator|-
literal|1
index|]
argument_list|)
argument_list|,
literal|"rw"
argument_list|)
decl_stmt|;
name|long
name|len
init|=
name|raf
operator|.
name|length
argument_list|()
decl_stmt|;
name|raf
operator|.
name|seek
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|// seek to start
name|raf
operator|.
name|write
argument_list|(
operator|new
name|byte
index|[
operator|(
name|int
operator|)
name|len
index|]
argument_list|)
expr_stmt|;
comment|// zero out file
name|raf
operator|.
name|close
argument_list|()
expr_stmt|;
name|ignoreException
argument_list|(
literal|"Failure to open existing log file"
argument_list|)
expr_stmt|;
comment|// this is what the corrupted log currently produces... subject to change.
name|createCore
argument_list|()
expr_stmt|;
name|resetExceptionIgnores
argument_list|()
expr_stmt|;
comment|// just make sure it responds
name|assertJQ
argument_list|(
name|req
argument_list|(
literal|"q"
argument_list|,
literal|"*:*"
argument_list|)
argument_list|,
literal|"/response/numFound==0"
argument_list|)
expr_stmt|;
comment|//
comment|// Now test that the bad log file doesn't mess up retrieving latest versions
comment|//
name|updateJ
argument_list|(
name|jsonAdd
argument_list|(
name|sdoc
argument_list|(
literal|"id"
argument_list|,
literal|"G4"
argument_list|,
literal|"_version_"
argument_list|,
literal|"104"
argument_list|)
argument_list|)
argument_list|,
name|params
argument_list|(
name|DISTRIB_UPDATE_PARAM
argument_list|,
name|FROM_LEADER
argument_list|)
argument_list|)
expr_stmt|;
name|updateJ
argument_list|(
name|jsonAdd
argument_list|(
name|sdoc
argument_list|(
literal|"id"
argument_list|,
literal|"G5"
argument_list|,
literal|"_version_"
argument_list|,
literal|"105"
argument_list|)
argument_list|)
argument_list|,
name|params
argument_list|(
name|DISTRIB_UPDATE_PARAM
argument_list|,
name|FROM_LEADER
argument_list|)
argument_list|)
expr_stmt|;
name|updateJ
argument_list|(
name|jsonAdd
argument_list|(
name|sdoc
argument_list|(
literal|"id"
argument_list|,
literal|"G6"
argument_list|,
literal|"_version_"
argument_list|,
literal|"106"
argument_list|)
argument_list|)
argument_list|,
name|params
argument_list|(
name|DISTRIB_UPDATE_PARAM
argument_list|,
name|FROM_LEADER
argument_list|)
argument_list|)
expr_stmt|;
comment|// This currently skips the bad log file and also returns the version of the clearIndex (del *:*)
comment|// assertJQ(req("qt","/get", "getVersions","6"), "/versions==[106,105,104]");
name|assertJQ
argument_list|(
name|req
argument_list|(
literal|"qt"
argument_list|,
literal|"/get"
argument_list|,
literal|"getVersions"
argument_list|,
literal|"3"
argument_list|)
argument_list|,
literal|"/versions==[106,105,104]"
argument_list|)
expr_stmt|;
name|assertU
argument_list|(
name|commit
argument_list|()
argument_list|)
expr_stmt|;
name|assertJQ
argument_list|(
name|req
argument_list|(
literal|"q"
argument_list|,
literal|"*:*"
argument_list|)
argument_list|,
literal|"/response/numFound==3"
argument_list|)
expr_stmt|;
comment|// This messes up some other tests (on windows) if we don't remove the bad log.
comment|// This *should* hopefully just be because the tests are too fragile and not because of real bugs - but it should be investigated further.
name|deleteLogs
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|DirectUpdateHandler2
operator|.
name|commitOnClose
operator|=
literal|true
expr_stmt|;
name|UpdateLog
operator|.
name|testing_logReplayHook
operator|=
literal|null
expr_stmt|;
name|UpdateLog
operator|.
name|testing_logReplayFinishHook
operator|=
literal|null
expr_stmt|;
block|}
block|}
comment|// in rare circumstances, two logs can be left uncapped (lacking a commit at the end signifying that all the content in the log was committed)
annotation|@
name|Test
DECL|method|testRecoveryMultipleLogs
specifier|public
name|void
name|testRecoveryMultipleLogs
parameter_list|()
throws|throws
name|Exception
block|{
try|try
block|{
name|DirectUpdateHandler2
operator|.
name|commitOnClose
operator|=
literal|false
expr_stmt|;
specifier|final
name|Semaphore
name|logReplay
init|=
operator|new
name|Semaphore
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|Semaphore
name|logReplayFinish
init|=
operator|new
name|Semaphore
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|UpdateLog
operator|.
name|testing_logReplayHook
operator|=
parameter_list|()
lambda|->
block|{
try|try
block|{
name|assertTrue
argument_list|(
name|logReplay
operator|.
name|tryAcquire
argument_list|(
name|timeout
argument_list|,
name|TimeUnit
operator|.
name|SECONDS
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
expr_stmt|;
name|UpdateLog
operator|.
name|testing_logReplayFinishHook
operator|=
parameter_list|()
lambda|->
name|logReplayFinish
operator|.
name|release
argument_list|()
expr_stmt|;
name|UpdateLog
name|ulog
init|=
name|h
operator|.
name|getCore
argument_list|()
operator|.
name|getUpdateHandler
argument_list|()
operator|.
name|getUpdateLog
argument_list|()
decl_stmt|;
name|File
name|logDir
init|=
operator|new
name|File
argument_list|(
name|h
operator|.
name|getCore
argument_list|()
operator|.
name|getUpdateHandler
argument_list|()
operator|.
name|getUpdateLog
argument_list|()
operator|.
name|getLogDir
argument_list|()
argument_list|)
decl_stmt|;
name|clearIndex
argument_list|()
expr_stmt|;
name|assertU
argument_list|(
name|commit
argument_list|()
argument_list|)
expr_stmt|;
name|assertU
argument_list|(
name|adoc
argument_list|(
literal|"id"
argument_list|,
literal|"AAAAAA"
argument_list|)
argument_list|)
expr_stmt|;
name|assertU
argument_list|(
name|adoc
argument_list|(
literal|"id"
argument_list|,
literal|"BBBBBB"
argument_list|)
argument_list|)
expr_stmt|;
name|assertU
argument_list|(
name|adoc
argument_list|(
literal|"id"
argument_list|,
literal|"CCCCCC"
argument_list|)
argument_list|)
expr_stmt|;
name|h
operator|.
name|close
argument_list|()
expr_stmt|;
name|String
index|[]
name|files
init|=
name|ulog
operator|.
name|getLogList
argument_list|(
name|logDir
argument_list|)
decl_stmt|;
name|Arrays
operator|.
name|sort
argument_list|(
name|files
argument_list|)
expr_stmt|;
name|String
name|fname
init|=
name|files
index|[
name|files
operator|.
name|length
operator|-
literal|1
index|]
decl_stmt|;
name|RandomAccessFile
name|raf
init|=
operator|new
name|RandomAccessFile
argument_list|(
operator|new
name|File
argument_list|(
name|logDir
argument_list|,
name|fname
argument_list|)
argument_list|,
literal|"rw"
argument_list|)
decl_stmt|;
name|raf
operator|.
name|seek
argument_list|(
name|raf
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
comment|// seek to end
name|raf
operator|.
name|writeLong
argument_list|(
literal|0xffffffffffffffffL
argument_list|)
expr_stmt|;
name|raf
operator|.
name|writeChars
argument_list|(
literal|"This should be appended to a good log file, representing a bad partially written record."
argument_list|)
expr_stmt|;
name|byte
index|[]
name|content
init|=
operator|new
name|byte
index|[
operator|(
name|int
operator|)
name|raf
operator|.
name|length
argument_list|()
index|]
decl_stmt|;
name|raf
operator|.
name|seek
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|raf
operator|.
name|readFully
argument_list|(
name|content
argument_list|)
expr_stmt|;
name|raf
operator|.
name|close
argument_list|()
expr_stmt|;
comment|// Now make a newer log file with just the IDs changed.  NOTE: this may not work if log format changes too much!
name|findReplace
argument_list|(
literal|"AAAAAA"
operator|.
name|getBytes
argument_list|(
name|StandardCharsets
operator|.
name|UTF_8
argument_list|)
argument_list|,
literal|"aaaaaa"
operator|.
name|getBytes
argument_list|(
name|StandardCharsets
operator|.
name|UTF_8
argument_list|)
argument_list|,
name|content
argument_list|)
expr_stmt|;
name|findReplace
argument_list|(
literal|"BBBBBB"
operator|.
name|getBytes
argument_list|(
name|StandardCharsets
operator|.
name|UTF_8
argument_list|)
argument_list|,
literal|"bbbbbb"
operator|.
name|getBytes
argument_list|(
name|StandardCharsets
operator|.
name|UTF_8
argument_list|)
argument_list|,
name|content
argument_list|)
expr_stmt|;
name|findReplace
argument_list|(
literal|"CCCCCC"
operator|.
name|getBytes
argument_list|(
name|StandardCharsets
operator|.
name|UTF_8
argument_list|)
argument_list|,
literal|"cccccc"
operator|.
name|getBytes
argument_list|(
name|StandardCharsets
operator|.
name|UTF_8
argument_list|)
argument_list|,
name|content
argument_list|)
expr_stmt|;
comment|// WARNING... assumes format of .00000n where n is less than 9
name|long
name|logNumber
init|=
name|Long
operator|.
name|parseLong
argument_list|(
name|fname
operator|.
name|substring
argument_list|(
name|fname
operator|.
name|lastIndexOf
argument_list|(
literal|"."
argument_list|)
operator|+
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|String
name|fname2
init|=
name|String
operator|.
name|format
argument_list|(
name|Locale
operator|.
name|ROOT
argument_list|,
name|UpdateLog
operator|.
name|LOG_FILENAME_PATTERN
argument_list|,
name|UpdateLog
operator|.
name|TLOG_NAME
argument_list|,
name|logNumber
operator|+
literal|1
argument_list|)
decl_stmt|;
name|raf
operator|=
operator|new
name|RandomAccessFile
argument_list|(
operator|new
name|File
argument_list|(
name|logDir
argument_list|,
name|fname2
argument_list|)
argument_list|,
literal|"rw"
argument_list|)
expr_stmt|;
name|raf
operator|.
name|write
argument_list|(
name|content
argument_list|)
expr_stmt|;
name|raf
operator|.
name|close
argument_list|()
expr_stmt|;
name|logReplay
operator|.
name|release
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|logReplayFinish
operator|.
name|drainPermits
argument_list|()
expr_stmt|;
name|ignoreException
argument_list|(
literal|"OutOfBoundsException"
argument_list|)
expr_stmt|;
comment|// this is what the corrupted log currently produces... subject to change.
name|createCore
argument_list|()
expr_stmt|;
name|assertTrue
argument_list|(
name|logReplayFinish
operator|.
name|tryAcquire
argument_list|(
name|timeout
argument_list|,
name|TimeUnit
operator|.
name|SECONDS
argument_list|)
argument_list|)
expr_stmt|;
name|resetExceptionIgnores
argument_list|()
expr_stmt|;
name|assertJQ
argument_list|(
name|req
argument_list|(
literal|"q"
argument_list|,
literal|"*:*"
argument_list|)
argument_list|,
literal|"/response/numFound==6"
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|DirectUpdateHandler2
operator|.
name|commitOnClose
operator|=
literal|true
expr_stmt|;
name|UpdateLog
operator|.
name|testing_logReplayHook
operator|=
literal|null
expr_stmt|;
name|UpdateLog
operator|.
name|testing_logReplayFinishHook
operator|=
literal|null
expr_stmt|;
block|}
block|}
comment|// NOTE: replacement must currently be same size
DECL|method|findReplace
specifier|private
specifier|static
name|void
name|findReplace
parameter_list|(
name|byte
index|[]
name|from
parameter_list|,
name|byte
index|[]
name|to
parameter_list|,
name|byte
index|[]
name|data
parameter_list|)
block|{
name|int
name|idx
init|=
operator|-
name|from
operator|.
name|length
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|idx
operator|=
name|indexOf
argument_list|(
name|from
argument_list|,
name|data
argument_list|,
name|idx
operator|+
name|from
operator|.
name|length
argument_list|)
expr_stmt|;
comment|// skip over previous match
if|if
condition|(
name|idx
operator|<
literal|0
condition|)
break|break;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|to
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|data
index|[
name|idx
operator|+
name|i
index|]
operator|=
name|to
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
block|}
DECL|method|indexOf
specifier|private
specifier|static
name|int
name|indexOf
parameter_list|(
name|byte
index|[]
name|target
parameter_list|,
name|byte
index|[]
name|data
parameter_list|,
name|int
name|start
parameter_list|)
block|{
name|outer
label|:
for|for
control|(
name|int
name|i
init|=
name|start
init|;
name|i
operator|<
name|data
operator|.
name|length
operator|-
name|target
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|target
operator|.
name|length
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|data
index|[
name|i
operator|+
name|j
index|]
operator|!=
name|target
index|[
name|j
index|]
condition|)
continue|continue
name|outer
continue|;
block|}
return|return
name|i
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
comment|// stops the core, removes the transaction logs, restarts the core.
DECL|method|deleteLogs
name|void
name|deleteLogs
parameter_list|()
throws|throws
name|Exception
block|{
name|UpdateLog
name|ulog
init|=
name|h
operator|.
name|getCore
argument_list|()
operator|.
name|getUpdateHandler
argument_list|()
operator|.
name|getUpdateLog
argument_list|()
decl_stmt|;
name|File
name|logDir
init|=
operator|new
name|File
argument_list|(
name|h
operator|.
name|getCore
argument_list|()
operator|.
name|getUpdateHandler
argument_list|()
operator|.
name|getUpdateLog
argument_list|()
operator|.
name|getLogDir
argument_list|()
argument_list|)
decl_stmt|;
name|h
operator|.
name|close
argument_list|()
expr_stmt|;
try|try
block|{
name|String
index|[]
name|files
init|=
name|ulog
operator|.
name|getLogList
argument_list|(
name|logDir
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|file
range|:
name|files
control|)
block|{
name|Files
operator|.
name|delete
argument_list|(
operator|new
name|File
argument_list|(
name|logDir
argument_list|,
name|file
argument_list|)
operator|.
name|toPath
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|ulog
operator|.
name|getLogList
argument_list|(
name|logDir
argument_list|)
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
comment|// make sure we create the core again, even if the assert fails so it won't mess
comment|// up the next test.
name|createCore
argument_list|()
expr_stmt|;
name|assertJQ
argument_list|(
name|req
argument_list|(
literal|"q"
argument_list|,
literal|"*:*"
argument_list|)
argument_list|,
literal|"/response/numFound=="
argument_list|)
expr_stmt|;
comment|// ensure it works
block|}
block|}
DECL|method|getVer
specifier|private
specifier|static
name|Long
name|getVer
parameter_list|(
name|SolrQueryRequest
name|req
parameter_list|)
throws|throws
name|Exception
block|{
name|String
name|response
init|=
name|JQ
argument_list|(
name|req
argument_list|)
decl_stmt|;
name|Map
name|rsp
init|=
operator|(
name|Map
operator|)
name|ObjectBuilder
operator|.
name|fromJSON
argument_list|(
name|response
argument_list|)
decl_stmt|;
name|Map
name|doc
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|rsp
operator|.
name|containsKey
argument_list|(
literal|"doc"
argument_list|)
condition|)
block|{
name|doc
operator|=
operator|(
name|Map
operator|)
name|rsp
operator|.
name|get
argument_list|(
literal|"doc"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rsp
operator|.
name|containsKey
argument_list|(
literal|"docs"
argument_list|)
condition|)
block|{
name|List
name|lst
init|=
operator|(
name|List
operator|)
name|rsp
operator|.
name|get
argument_list|(
literal|"docs"
argument_list|)
decl_stmt|;
if|if
condition|(
name|lst
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|doc
operator|=
operator|(
name|Map
operator|)
name|lst
operator|.
name|get
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|rsp
operator|.
name|containsKey
argument_list|(
literal|"response"
argument_list|)
condition|)
block|{
name|Map
name|responseMap
init|=
operator|(
name|Map
operator|)
name|rsp
operator|.
name|get
argument_list|(
literal|"response"
argument_list|)
decl_stmt|;
name|List
name|lst
init|=
operator|(
name|List
operator|)
name|responseMap
operator|.
name|get
argument_list|(
literal|"docs"
argument_list|)
decl_stmt|;
if|if
condition|(
name|lst
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|doc
operator|=
operator|(
name|Map
operator|)
name|lst
operator|.
name|get
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|doc
operator|==
literal|null
condition|)
return|return
literal|null
return|;
return|return
operator|(
name|Long
operator|)
name|doc
operator|.
name|get
argument_list|(
literal|"_version_"
argument_list|)
return|;
block|}
block|}
end_class
end_unit
