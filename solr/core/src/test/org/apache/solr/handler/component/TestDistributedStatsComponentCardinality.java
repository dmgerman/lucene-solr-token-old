begin_unit
begin_package
DECL|package|org.apache.solr.handler.component
package|package
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|handler
operator|.
name|component
package|;
end_package
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|TestUtil
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|LuceneTestCase
operator|.
name|Slow
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|BaseDistributedSearchTestCase
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|client
operator|.
name|solrj
operator|.
name|response
operator|.
name|FieldStatsInfo
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|client
operator|.
name|solrj
operator|.
name|response
operator|.
name|QueryResponse
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|params
operator|.
name|SolrParams
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|params
operator|.
name|ModifiableSolrParams
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|util
operator|.
name|hll
operator|.
name|HLL
import|;
end_import
begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|hash
operator|.
name|Hashing
import|;
end_import
begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|hash
operator|.
name|HashFunction
import|;
end_import
begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import
begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import
begin_class
annotation|@
name|Slow
DECL|class|TestDistributedStatsComponentCardinality
specifier|public
class|class
name|TestDistributedStatsComponentCardinality
extends|extends
name|BaseDistributedSearchTestCase
block|{
DECL|field|log
specifier|public
specifier|static
specifier|final
name|Logger
name|log
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|TestDistributedStatsComponentCardinality
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|HASHER
specifier|final
specifier|static
name|HashFunction
name|HASHER
init|=
name|Hashing
operator|.
name|murmur3_128
argument_list|()
decl_stmt|;
DECL|field|BIG_PRIME
specifier|final
specifier|static
name|long
name|BIG_PRIME
init|=
literal|982451653L
decl_stmt|;
DECL|field|MIN_NUM_DOCS
specifier|final
specifier|static
name|int
name|MIN_NUM_DOCS
init|=
literal|10000
decl_stmt|;
DECL|field|MAX_NUM_DOCS
specifier|final
specifier|static
name|int
name|MAX_NUM_DOCS
init|=
name|MIN_NUM_DOCS
operator|*
literal|2
decl_stmt|;
DECL|field|STAT_FIELDS
specifier|final
specifier|static
name|List
argument_list|<
name|String
argument_list|>
name|STAT_FIELDS
init|=
name|Collections
operator|.
name|unmodifiableList
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
literal|"int_i"
argument_list|,
literal|"long_l"
argument_list|,
literal|"string_s"
argument_list|)
argument_list|)
decl_stmt|;
DECL|field|NUM_DOCS
specifier|final
name|int
name|NUM_DOCS
decl_stmt|;
DECL|field|MAX_LONG
specifier|final
name|long
name|MAX_LONG
decl_stmt|;
DECL|field|MIN_LONG
specifier|final
name|long
name|MIN_LONG
decl_stmt|;
DECL|method|TestDistributedStatsComponentCardinality
specifier|public
name|TestDistributedStatsComponentCardinality
parameter_list|()
block|{
name|super
argument_list|()
expr_stmt|;
comment|// we want some randomness in the shard number, but we don't want multiple iterations
name|fixShardCount
argument_list|(
name|TEST_NIGHTLY
condition|?
literal|7
else|:
name|random
argument_list|()
operator|.
name|nextInt
argument_list|(
literal|3
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|handle
operator|.
name|put
argument_list|(
literal|"maxScore"
argument_list|,
name|SKIPVAL
argument_list|)
expr_stmt|;
name|NUM_DOCS
operator|=
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|random
argument_list|()
argument_list|,
literal|10000
argument_list|,
literal|15000
argument_list|)
expr_stmt|;
name|MAX_LONG
operator|=
name|TestUtil
operator|.
name|nextLong
argument_list|(
name|random
argument_list|()
argument_list|,
literal|0
argument_list|,
name|NUM_DOCS
operator|*
name|BIG_PRIME
argument_list|)
expr_stmt|;
name|MIN_LONG
operator|=
name|MAX_LONG
operator|-
operator|(
operator|(
operator|(
name|long
operator|)
name|NUM_DOCS
operator|-
literal|1
operator|)
operator|*
name|BIG_PRIME
operator|)
expr_stmt|;
block|}
comment|/** CAUTION: this builds a very large index */
DECL|method|buildIndex
specifier|public
name|void
name|buildIndex
parameter_list|()
throws|throws
name|Exception
block|{
name|log
operator|.
name|info
argument_list|(
literal|"Building an index of {} docs"
argument_list|,
name|NUM_DOCS
argument_list|)
expr_stmt|;
comment|// we want a big spread in the long values we use, decrement by BIG_PRIME as we index
name|long
name|longValue
init|=
name|MAX_LONG
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<=
name|NUM_DOCS
condition|;
name|i
operator|++
control|)
block|{
comment|// with these values, we know that every doc indexed has a unique value in all of the
comment|// fields we will compute cardinality against.
comment|// which means the number of docs matching a query is the true cardinality for each field
specifier|final
name|String
name|strValue
init|=
literal|"s"
operator|+
name|longValue
decl_stmt|;
name|indexDoc
argument_list|(
name|sdoc
argument_list|(
literal|"id"
argument_list|,
literal|""
operator|+
name|i
argument_list|,
literal|"int_i"
argument_list|,
literal|""
operator|+
name|i
argument_list|,
literal|"int_i_prehashed_l"
argument_list|,
literal|""
operator|+
name|HASHER
operator|.
name|hashInt
argument_list|(
name|i
argument_list|)
operator|.
name|asLong
argument_list|()
argument_list|,
literal|"long_l"
argument_list|,
literal|""
operator|+
name|longValue
argument_list|,
literal|"long_l_prehashed_l"
argument_list|,
literal|""
operator|+
name|HASHER
operator|.
name|hashLong
argument_list|(
name|longValue
argument_list|)
operator|.
name|asLong
argument_list|()
argument_list|,
literal|"string_s"
argument_list|,
name|strValue
argument_list|,
comment|// NOTE: renamed hashUnencodedChars starting with guava 15
literal|"string_s_prehashed_l"
argument_list|,
literal|""
operator|+
name|HASHER
operator|.
name|hashString
argument_list|(
name|strValue
argument_list|)
operator|.
name|asLong
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|longValue
operator|-=
name|BIG_PRIME
expr_stmt|;
block|}
name|commit
argument_list|()
expr_stmt|;
block|}
DECL|method|test
specifier|public
name|void
name|test
parameter_list|()
throws|throws
name|Exception
block|{
name|buildIndex
argument_list|()
expr_stmt|;
block|{
comment|// simple sanity checks - don't leak variables
name|QueryResponse
name|rsp
init|=
literal|null
decl_stmt|;
name|rsp
operator|=
name|query
argument_list|(
name|params
argument_list|(
literal|"rows"
argument_list|,
literal|"0"
argument_list|,
literal|"q"
argument_list|,
literal|"id:42"
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|rsp
operator|.
name|getResults
argument_list|()
operator|.
name|getNumFound
argument_list|()
argument_list|)
expr_stmt|;
name|rsp
operator|=
name|query
argument_list|(
name|params
argument_list|(
literal|"rows"
argument_list|,
literal|"0"
argument_list|,
literal|"q"
argument_list|,
literal|"*:*"
argument_list|,
literal|"stats"
argument_list|,
literal|"true"
argument_list|,
literal|"stats.field"
argument_list|,
literal|"{!min=true max=true}long_l"
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|NUM_DOCS
argument_list|,
name|rsp
operator|.
name|getResults
argument_list|()
operator|.
name|getNumFound
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|MIN_LONG
argument_list|,
name|Math
operator|.
name|round
argument_list|(
operator|(
name|double
operator|)
name|rsp
operator|.
name|getFieldStatsInfo
argument_list|()
operator|.
name|get
argument_list|(
literal|"long_l"
argument_list|)
operator|.
name|getMin
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|MAX_LONG
argument_list|,
name|Math
operator|.
name|round
argument_list|(
operator|(
name|double
operator|)
name|rsp
operator|.
name|getFieldStatsInfo
argument_list|()
operator|.
name|get
argument_list|(
literal|"long_l"
argument_list|)
operator|.
name|getMax
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|final
name|int
name|NUM_QUERIES
init|=
name|atLeast
argument_list|(
literal|100
argument_list|)
decl_stmt|;
comment|// Some Randomized queries with randomized log2m and max regwidth
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|NUM_QUERIES
condition|;
name|i
operator|++
control|)
block|{
comment|// testing shows that on random data, at the size we're dealing with,
comment|// MINIMUM_LOG2M_PARAM is just too absurdly small to give anything remotely close the
comment|// the theoretically expected relative error.
comment|//
comment|// So we have to use a slightly higher lower bound on what log2m values we randomly test
specifier|final
name|int
name|log2m
init|=
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|random
argument_list|()
argument_list|,
literal|2
operator|+
name|HLL
operator|.
name|MINIMUM_LOG2M_PARAM
argument_list|,
name|HLL
operator|.
name|MAXIMUM_LOG2M_PARAM
argument_list|)
decl_stmt|;
comment|// use max regwidth to try and prevent hash collisions from introducing problems
specifier|final
name|int
name|regwidth
init|=
name|HLL
operator|.
name|MAXIMUM_REGWIDTH_PARAM
decl_stmt|;
specifier|final
name|int
name|lowId
init|=
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|random
argument_list|()
argument_list|,
literal|1
argument_list|,
name|NUM_DOCS
operator|-
literal|2000
argument_list|)
decl_stmt|;
specifier|final
name|int
name|highId
init|=
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|random
argument_list|()
argument_list|,
name|lowId
operator|+
literal|1000
argument_list|,
name|NUM_DOCS
argument_list|)
decl_stmt|;
specifier|final
name|int
name|numMatches
init|=
literal|1
operator|+
name|highId
operator|-
name|lowId
decl_stmt|;
name|SolrParams
name|p
init|=
name|buildCardinalityQ
argument_list|(
name|lowId
argument_list|,
name|highId
argument_list|,
name|log2m
argument_list|,
name|regwidth
argument_list|)
decl_stmt|;
name|QueryResponse
name|rsp
init|=
name|query
argument_list|(
name|p
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|"sanity check num matches, p="
operator|+
name|p
argument_list|,
name|numMatches
argument_list|,
name|rsp
operator|.
name|getResults
argument_list|()
operator|.
name|getNumFound
argument_list|()
argument_list|)
expr_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|FieldStatsInfo
argument_list|>
name|stats
init|=
name|rsp
operator|.
name|getFieldStatsInfo
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|f
range|:
name|STAT_FIELDS
control|)
block|{
comment|// regardless of log2m and regwidth, the estimated cardinality of the
comment|// hashed vs prehashed values should be exactly the same for each field
name|assertEquals
argument_list|(
name|f
operator|+
literal|": hashed vs prehashed, real="
operator|+
name|numMatches
operator|+
literal|", p="
operator|+
name|p
argument_list|,
name|stats
operator|.
name|get
argument_list|(
name|f
argument_list|)
operator|.
name|getCardinality
argument_list|()
operator|.
name|longValue
argument_list|()
argument_list|,
name|stats
operator|.
name|get
argument_list|(
name|f
operator|+
literal|"_prehashed_l"
argument_list|)
operator|.
name|getCardinality
argument_list|()
operator|.
name|longValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|String
name|f
range|:
name|STAT_FIELDS
control|)
block|{
comment|// check the relative error of the estimate returned against the known truth
specifier|final
name|double
name|relErr
init|=
name|expectedRelativeError
argument_list|(
name|log2m
argument_list|)
decl_stmt|;
specifier|final
name|long
name|estimate
init|=
name|stats
operator|.
name|get
argument_list|(
name|f
argument_list|)
operator|.
name|getCardinality
argument_list|()
operator|.
name|longValue
argument_list|()
decl_stmt|;
name|assertTrue
argument_list|(
name|f
operator|+
literal|": relativeErr="
operator|+
name|relErr
operator|+
literal|", estimate="
operator|+
name|estimate
operator|+
literal|", real="
operator|+
name|numMatches
operator|+
literal|", p="
operator|+
name|p
argument_list|,
operator|(
name|Math
operator|.
name|abs
argument_list|(
name|numMatches
operator|-
name|estimate
argument_list|)
operator|/
name|numMatches
operator|)
operator|<
name|relErr
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Some Randomized queries with both low and high accuracy options
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|NUM_QUERIES
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|int
name|lowId
init|=
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|random
argument_list|()
argument_list|,
literal|1
argument_list|,
name|NUM_DOCS
operator|-
literal|2000
argument_list|)
decl_stmt|;
specifier|final
name|int
name|highId
init|=
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|random
argument_list|()
argument_list|,
name|lowId
operator|+
literal|1000
argument_list|,
name|NUM_DOCS
argument_list|)
decl_stmt|;
specifier|final
name|int
name|numMatches
init|=
literal|1
operator|+
name|highId
operator|-
name|lowId
decl_stmt|;
comment|// WTF? - https://github.com/aggregateknowledge/java-hll/issues/15
comment|//
comment|// aparently we can't rely on estimates always being more accurate with higher log2m values?
comment|// so for now, just try testing accuracy values that differ by at least 0.5
comment|//
comment|// (that should give us a significant enough log2m diff that the "highAccuracy" is always
comment|// more accurate -- if, not then the entire premise of the float value is fundementally bogus)
comment|//
specifier|final
name|double
name|lowAccuracy
init|=
name|random
argument_list|()
operator|.
name|nextDouble
argument_list|()
operator|/
literal|2
decl_stmt|;
comment|// final double highAccuracy = Math.min(1.0D, lowAccuracy + (random().nextDouble() / 2));
specifier|final
name|double
name|highAccuracy
init|=
name|Math
operator|.
name|min
argument_list|(
literal|1.0D
argument_list|,
name|lowAccuracy
operator|+
literal|0.5D
argument_list|)
decl_stmt|;
name|SolrParams
name|p
init|=
name|buildCardinalityQ
argument_list|(
name|lowId
argument_list|,
name|highId
argument_list|,
name|lowAccuracy
argument_list|,
name|highAccuracy
argument_list|)
decl_stmt|;
name|QueryResponse
name|rsp
init|=
name|query
argument_list|(
name|p
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|"sanity check num matches, p="
operator|+
name|p
argument_list|,
name|numMatches
argument_list|,
name|rsp
operator|.
name|getResults
argument_list|()
operator|.
name|getNumFound
argument_list|()
argument_list|)
expr_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|FieldStatsInfo
argument_list|>
name|stats
init|=
name|rsp
operator|.
name|getFieldStatsInfo
argument_list|()
decl_stmt|;
comment|// can't use STAT_FIELDS here ...
comment|//
comment|// hueristic differences for regwidth on 32 bit values mean we get differences
comment|// between estimates for the normal field vs the prehashed (long) field
comment|//
comment|// so we settle for only testing things where the regwidth is consistent
comment|// w/the prehashed long...
for|for
control|(
name|String
name|f
range|:
operator|new
name|String
index|[]
block|{
literal|"long_l"
block|,
literal|"string_s"
block|}
control|)
block|{
comment|// regardless of accuracy, the estimated cardinality of the
comment|// hashed vs prehashed values should be exactly the same for each field
name|assertEquals
argument_list|(
name|f
operator|+
literal|": hashed vs prehashed (low), real="
operator|+
name|numMatches
operator|+
literal|", p="
operator|+
name|p
argument_list|,
name|stats
operator|.
name|get
argument_list|(
literal|"low_"
operator|+
name|f
argument_list|)
operator|.
name|getCardinality
argument_list|()
operator|.
name|longValue
argument_list|()
argument_list|,
name|stats
operator|.
name|get
argument_list|(
literal|"low_"
operator|+
name|f
operator|+
literal|"_prehashed_l"
argument_list|)
operator|.
name|getCardinality
argument_list|()
operator|.
name|longValue
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|f
operator|+
literal|": hashed vs prehashed (high), real="
operator|+
name|numMatches
operator|+
literal|", p="
operator|+
name|p
argument_list|,
name|stats
operator|.
name|get
argument_list|(
literal|"high_"
operator|+
name|f
argument_list|)
operator|.
name|getCardinality
argument_list|()
operator|.
name|longValue
argument_list|()
argument_list|,
name|stats
operator|.
name|get
argument_list|(
literal|"high_"
operator|+
name|f
operator|+
literal|"_prehashed_l"
argument_list|)
operator|.
name|getCardinality
argument_list|()
operator|.
name|longValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|String
name|f
range|:
name|STAT_FIELDS
control|)
block|{
for|for
control|(
name|String
name|ff
range|:
operator|new
name|String
index|[]
block|{
name|f
block|,
name|f
operator|+
literal|"_prehashed_l"
block|}
control|)
block|{
comment|// for both the prehashed and regular fields, the high accuracy option
comment|// should always produce an estimate at least as good as the low accuracy option
name|long
name|poorEst
init|=
name|stats
operator|.
name|get
argument_list|(
literal|"low_"
operator|+
name|ff
argument_list|)
operator|.
name|getCardinality
argument_list|()
decl_stmt|;
name|long
name|goodEst
init|=
name|stats
operator|.
name|get
argument_list|(
literal|"high_"
operator|+
name|ff
argument_list|)
operator|.
name|getCardinality
argument_list|()
decl_stmt|;
name|assertTrue
argument_list|(
name|ff
operator|+
literal|": goodEst="
operator|+
name|goodEst
operator|+
literal|", poorEst="
operator|+
name|poorEst
operator|+
literal|", real="
operator|+
name|numMatches
operator|+
literal|", p="
operator|+
name|p
argument_list|,
name|Math
operator|.
name|abs
argument_list|(
name|numMatches
operator|-
name|goodEst
argument_list|)
operator|<=
name|Math
operator|.
name|abs
argument_list|(
name|numMatches
operator|-
name|poorEst
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**    * Returns the (max) expected relative error according ot the HLL algorithm docs    */
DECL|method|expectedRelativeError
specifier|private
specifier|static
name|double
name|expectedRelativeError
parameter_list|(
specifier|final
name|int
name|log2m
parameter_list|)
block|{
specifier|final
name|long
name|m
init|=
literal|1
operator|<<
name|log2m
decl_stmt|;
comment|// theoretical error is 1.04D * sqrt(m)
comment|// fudge slightly to account for variance in random data
return|return
literal|1.1D
operator|/
name|Math
operator|.
name|sqrt
argument_list|(
name|m
argument_list|)
return|;
block|}
comment|/**     * Helper utility for building up a set of query params.      *    * The main query is a simple range query against the id field (using lowId TO highId).     * 2 stats.field params are generated for every field in {@link #STAT_FIELDS} --    * both with and w/o a prehashed_l suffix -- using the specified log2m and regwidth.    *     * The response keys will be the full field names    */
DECL|method|buildCardinalityQ
specifier|private
specifier|static
name|SolrParams
name|buildCardinalityQ
parameter_list|(
specifier|final
name|int
name|lowId
parameter_list|,
specifier|final
name|int
name|highId
parameter_list|,
specifier|final
name|int
name|log2m
parameter_list|,
specifier|final
name|int
name|regwidth
parameter_list|)
block|{
name|ModifiableSolrParams
name|p
init|=
name|params
argument_list|(
literal|"q"
argument_list|,
literal|"id:["
operator|+
name|lowId
operator|+
literal|" TO "
operator|+
name|highId
operator|+
literal|"]"
argument_list|,
literal|"rows"
argument_list|,
literal|"0"
argument_list|,
literal|"stats"
argument_list|,
literal|"true"
argument_list|)
decl_stmt|;
specifier|final
name|String
name|prefix
init|=
literal|"{!cardinality=true hllLog2m="
operator|+
name|log2m
operator|+
literal|" hllRegwidth="
operator|+
name|regwidth
decl_stmt|;
for|for
control|(
name|String
name|f
range|:
name|STAT_FIELDS
control|)
block|{
name|p
operator|.
name|add
argument_list|(
literal|"stats.field"
argument_list|,
name|prefix
operator|+
literal|"}"
operator|+
name|f
argument_list|)
expr_stmt|;
name|p
operator|.
name|add
argument_list|(
literal|"stats.field"
argument_list|,
name|prefix
operator|+
literal|" hllPreHashed=true}"
operator|+
name|f
operator|+
literal|"_prehashed_l"
argument_list|)
expr_stmt|;
block|}
return|return
name|p
return|;
block|}
comment|/**     * Helper utility for building up a set of query params.      *    * The main query is a simple range query against the id field (using lowId TO highId).     * 4 stats.field params are generated for every field in {@link #STAT_FIELDS} --    * both with and w/o a prehashed_l suffix, and using both the low and high accuracy values    *    * The response keys will be the full field names with either a "low_" or "high_" prefix    */
DECL|method|buildCardinalityQ
specifier|private
specifier|static
name|SolrParams
name|buildCardinalityQ
parameter_list|(
specifier|final
name|int
name|lowId
parameter_list|,
specifier|final
name|int
name|highId
parameter_list|,
specifier|final
name|double
name|lowAccuracy
parameter_list|,
specifier|final
name|double
name|highAccuracy
parameter_list|)
block|{
name|ModifiableSolrParams
name|p
init|=
name|params
argument_list|(
literal|"q"
argument_list|,
literal|"id:["
operator|+
name|lowId
operator|+
literal|" TO "
operator|+
name|highId
operator|+
literal|"]"
argument_list|,
literal|"rows"
argument_list|,
literal|"0"
argument_list|,
literal|"stats"
argument_list|,
literal|"true"
argument_list|)
decl_stmt|;
specifier|final
name|String
index|[]
name|prefixes
init|=
operator|new
name|String
index|[]
block|{
literal|"{!cardinality="
operator|+
name|lowAccuracy
operator|+
literal|" key=low_"
block|,
literal|"{!cardinality="
operator|+
name|highAccuracy
operator|+
literal|" key=high_"
block|}
decl_stmt|;
for|for
control|(
name|String
name|f
range|:
name|STAT_FIELDS
control|)
block|{
for|for
control|(
name|String
name|prefix
range|:
name|prefixes
control|)
block|{
name|p
operator|.
name|add
argument_list|(
literal|"stats.field"
argument_list|,
name|prefix
operator|+
name|f
operator|+
literal|"}"
operator|+
name|f
argument_list|)
expr_stmt|;
name|p
operator|.
name|add
argument_list|(
literal|"stats.field"
argument_list|,
name|prefix
operator|+
name|f
operator|+
literal|"_prehashed_l hllPreHashed=true}"
operator|+
name|f
operator|+
literal|"_prehashed_l"
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|p
return|;
block|}
block|}
end_class
end_unit
