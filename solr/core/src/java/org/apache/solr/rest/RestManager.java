begin_unit
begin_package
DECL|package|org.apache.solr.rest
package|package
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|rest
package|;
end_package
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileNotFoundException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Constructor
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Locale
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeMap
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Matcher
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Pattern
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|SolrException
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|SolrException
operator|.
name|ErrorCode
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|util
operator|.
name|NamedList
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|core
operator|.
name|SolrResourceLoader
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|request
operator|.
name|SolrQueryRequest
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|request
operator|.
name|SolrRequestInfo
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|rest
operator|.
name|ManagedResourceStorage
operator|.
name|StorageIO
import|;
end_import
begin_import
import|import
name|org
operator|.
name|noggit
operator|.
name|ObjectBuilder
import|;
end_import
begin_import
import|import
name|org
operator|.
name|restlet
operator|.
name|Request
import|;
end_import
begin_import
import|import
name|org
operator|.
name|restlet
operator|.
name|data
operator|.
name|MediaType
import|;
end_import
begin_import
import|import
name|org
operator|.
name|restlet
operator|.
name|data
operator|.
name|Method
import|;
end_import
begin_import
import|import
name|org
operator|.
name|restlet
operator|.
name|data
operator|.
name|Status
import|;
end_import
begin_import
import|import
name|org
operator|.
name|restlet
operator|.
name|representation
operator|.
name|Representation
import|;
end_import
begin_import
import|import
name|org
operator|.
name|restlet
operator|.
name|resource
operator|.
name|ResourceException
import|;
end_import
begin_import
import|import
name|org
operator|.
name|restlet
operator|.
name|routing
operator|.
name|Router
import|;
end_import
begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import
begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import
begin_comment
comment|/**  * Supports runtime mapping of REST API endpoints to ManagedResource   * implementations; endpoints can be registered at either the /schema  * or /config base paths, depending on which base path is more appropriate  * for the type of managed resource.  */
end_comment
begin_class
DECL|class|RestManager
specifier|public
class|class
name|RestManager
block|{
DECL|field|log
specifier|public
specifier|static
specifier|final
name|Logger
name|log
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|RestManager
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|SCHEMA_BASE_PATH
specifier|public
specifier|static
specifier|final
name|String
name|SCHEMA_BASE_PATH
init|=
literal|"/schema"
decl_stmt|;
DECL|field|MANAGED_ENDPOINT
specifier|public
specifier|static
specifier|final
name|String
name|MANAGED_ENDPOINT
init|=
literal|"/managed"
decl_stmt|;
comment|// used for validating resourceIds provided during registration
DECL|field|resourceIdRegex
specifier|private
specifier|static
specifier|final
name|Pattern
name|resourceIdRegex
init|=
name|Pattern
operator|.
name|compile
argument_list|(
literal|"(/config|/schema)(/.*)"
argument_list|)
decl_stmt|;
DECL|field|DECODE
specifier|private
specifier|static
specifier|final
name|boolean
name|DECODE
init|=
literal|true
decl_stmt|;
comment|/**    * Used internally to keep track of registrations during core initialization    */
DECL|class|ManagedResourceRegistration
specifier|private
specifier|static
class|class
name|ManagedResourceRegistration
block|{
DECL|field|resourceId
name|String
name|resourceId
decl_stmt|;
DECL|field|implClass
name|Class
argument_list|<
name|?
extends|extends
name|ManagedResource
argument_list|>
name|implClass
decl_stmt|;
DECL|field|observers
name|List
argument_list|<
name|ManagedResourceObserver
argument_list|>
name|observers
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
DECL|method|ManagedResourceRegistration
specifier|private
name|ManagedResourceRegistration
parameter_list|(
name|String
name|resourceId
parameter_list|,
name|Class
argument_list|<
name|?
extends|extends
name|ManagedResource
argument_list|>
name|implClass
parameter_list|,
name|ManagedResourceObserver
name|observer
parameter_list|)
block|{
name|this
operator|.
name|resourceId
operator|=
name|resourceId
expr_stmt|;
name|this
operator|.
name|implClass
operator|=
name|implClass
expr_stmt|;
if|if
condition|(
name|observer
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|observers
operator|.
name|add
argument_list|(
name|observer
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Returns resourceId, class, and number of observers of this registered resource */
DECL|method|getInfo
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|getInfo
parameter_list|()
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|info
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|info
operator|.
name|put
argument_list|(
literal|"resourceId"
argument_list|,
name|resourceId
argument_list|)
expr_stmt|;
name|info
operator|.
name|put
argument_list|(
literal|"class"
argument_list|,
name|implClass
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|info
operator|.
name|put
argument_list|(
literal|"numObservers"
argument_list|,
name|String
operator|.
name|valueOf
argument_list|(
name|observers
operator|.
name|size
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|info
return|;
block|}
block|}
comment|/**    * Per-core registry of ManagedResources found during core initialization.    *     * Registering of managed resources can happen before the RestManager is    * fully initialized. To avoid timing issues, resources register themselves    * and then the RestManager initializes all ManagedResources before the core    * is activated.      */
DECL|class|Registry
specifier|public
specifier|static
class|class
name|Registry
block|{
DECL|field|registered
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|ManagedResourceRegistration
argument_list|>
name|registered
init|=
operator|new
name|TreeMap
argument_list|<>
argument_list|()
decl_stmt|;
comment|// maybe null until there is a restManager
DECL|field|initializedRestManager
specifier|private
name|RestManager
name|initializedRestManager
init|=
literal|null
decl_stmt|;
comment|// REST API endpoints that need to be protected against dynamic endpoint creation
DECL|field|reservedEndpoints
specifier|private
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|reservedEndpoints
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
DECL|field|reservedEndpointsPattern
specifier|private
specifier|final
name|Pattern
name|reservedEndpointsPattern
decl_stmt|;
DECL|method|Registry
specifier|public
name|Registry
parameter_list|()
block|{
name|reservedEndpoints
operator|.
name|add
argument_list|(
name|SCHEMA_BASE_PATH
operator|+
name|MANAGED_ENDPOINT
argument_list|)
expr_stmt|;
for|for
control|(
name|String
name|reservedEndpoint
range|:
name|SolrSchemaRestApi
operator|.
name|getReservedEndpoints
argument_list|()
control|)
block|{
name|reservedEndpoints
operator|.
name|add
argument_list|(
name|reservedEndpoint
argument_list|)
expr_stmt|;
block|}
name|reservedEndpointsPattern
operator|=
name|getReservedEndpointsPattern
argument_list|()
expr_stmt|;
block|}
comment|/**      * Returns the set of non-registerable endpoints.      */
DECL|method|getReservedEndpoints
specifier|public
name|Set
argument_list|<
name|String
argument_list|>
name|getReservedEndpoints
parameter_list|()
block|{
return|return
name|Collections
operator|.
name|unmodifiableSet
argument_list|(
name|reservedEndpoints
argument_list|)
return|;
block|}
comment|/**      * Returns a Pattern, to be used with Matcher.matches(), that will recognize      * prefixes or full matches against reserved endpoints that need to be protected      * against dynamic endpoint registration.  group(1) will contain the match      * regardless of whether it's a full match or a prefix.      */
DECL|method|getReservedEndpointsPattern
specifier|private
name|Pattern
name|getReservedEndpointsPattern
parameter_list|()
block|{
comment|// Match any of the reserved endpoints exactly, or followed by a slash and more stuff
name|StringBuilder
name|builder
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|builder
operator|.
name|append
argument_list|(
literal|"("
argument_list|)
expr_stmt|;
name|boolean
name|notFirst
init|=
literal|false
decl_stmt|;
for|for
control|(
name|String
name|reservedEndpoint
range|:
name|reservedEndpoints
control|)
block|{
if|if
condition|(
name|notFirst
condition|)
block|{
name|builder
operator|.
name|append
argument_list|(
literal|"|"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|notFirst
operator|=
literal|true
expr_stmt|;
block|}
name|builder
operator|.
name|append
argument_list|(
name|reservedEndpoint
argument_list|)
expr_stmt|;
block|}
name|builder
operator|.
name|append
argument_list|(
literal|")(?:|/.*)"
argument_list|)
expr_stmt|;
return|return
name|Pattern
operator|.
name|compile
argument_list|(
name|builder
operator|.
name|toString
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * Get a view of the currently registered resources.       */
DECL|method|getRegistered
specifier|public
name|Collection
argument_list|<
name|ManagedResourceRegistration
argument_list|>
name|getRegistered
parameter_list|()
block|{
return|return
name|Collections
operator|.
name|unmodifiableCollection
argument_list|(
name|registered
operator|.
name|values
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * Register the need to use a ManagedResource; this method is typically called      * by a Solr component during core initialization to register itself as an       * observer of a specific type of ManagedResource. As many Solr components may      * share the same ManagedResource, this method only serves to associate the      * observer with an endpoint and implementation class. The actual construction      * of the ManagedResource and loading of data from storage occurs later once      * the RestManager is fully initialized.      * @param resourceId - An endpoint in the Rest API to manage the resource; must      * start with /config and /schema.      * @param implClass - Class that implements ManagedResource.      * @param observer - Solr component that needs to know when the data being managed      * by the ManagedResource is loaded, such as a TokenFilter.      */
DECL|method|registerManagedResource
specifier|public
specifier|synchronized
name|void
name|registerManagedResource
parameter_list|(
name|String
name|resourceId
parameter_list|,
name|Class
argument_list|<
name|?
extends|extends
name|ManagedResource
argument_list|>
name|implClass
parameter_list|,
name|ManagedResourceObserver
name|observer
parameter_list|)
block|{
if|if
condition|(
name|resourceId
operator|==
literal|null
condition|)
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Must provide a non-null resourceId to register a ManagedResource!"
argument_list|)
throw|;
name|Matcher
name|resourceIdValidator
init|=
name|resourceIdRegex
operator|.
name|matcher
argument_list|(
name|resourceId
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|resourceIdValidator
operator|.
name|matches
argument_list|()
condition|)
block|{
name|String
name|errMsg
init|=
name|String
operator|.
name|format
argument_list|(
name|Locale
operator|.
name|ROOT
argument_list|,
literal|"Invalid resourceId '%s'; must start with  %s."
argument_list|,
name|resourceId
argument_list|,
name|SCHEMA_BASE_PATH
argument_list|)
decl_stmt|;
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|SERVER_ERROR
argument_list|,
name|errMsg
argument_list|)
throw|;
block|}
comment|// protect reserved REST API endpoints from being used by another
name|Matcher
name|reservedEndpointsMatcher
init|=
name|reservedEndpointsPattern
operator|.
name|matcher
argument_list|(
name|resourceId
argument_list|)
decl_stmt|;
if|if
condition|(
name|reservedEndpointsMatcher
operator|.
name|matches
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|SERVER_ERROR
argument_list|,
name|reservedEndpointsMatcher
operator|.
name|group
argument_list|(
literal|1
argument_list|)
operator|+
literal|" is a reserved endpoint used by the Solr REST API!"
argument_list|)
throw|;
block|}
comment|// IMPORTANT: this code should assume there is no RestManager at this point
comment|// it's ok to re-register the same class for an existing path
name|ManagedResourceRegistration
name|reg
init|=
name|registered
operator|.
name|get
argument_list|(
name|resourceId
argument_list|)
decl_stmt|;
if|if
condition|(
name|reg
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
operator|!
name|reg
operator|.
name|implClass
operator|.
name|equals
argument_list|(
name|implClass
argument_list|)
condition|)
block|{
name|String
name|errMsg
init|=
name|String
operator|.
name|format
argument_list|(
name|Locale
operator|.
name|ROOT
argument_list|,
literal|"REST API path %s already registered to instances of %s"
argument_list|,
name|resourceId
argument_list|,
name|reg
operator|.
name|implClass
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|SERVER_ERROR
argument_list|,
name|errMsg
argument_list|)
throw|;
block|}
if|if
condition|(
name|observer
operator|!=
literal|null
condition|)
block|{
name|reg
operator|.
name|observers
operator|.
name|add
argument_list|(
name|observer
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Added observer of type {} to existing ManagedResource {}"
argument_list|,
name|observer
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|resourceId
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|registered
operator|.
name|put
argument_list|(
name|resourceId
argument_list|,
operator|new
name|ManagedResourceRegistration
argument_list|(
name|resourceId
argument_list|,
name|implClass
argument_list|,
name|observer
argument_list|)
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Registered ManagedResource impl {} for path {}"
argument_list|,
name|implClass
operator|.
name|getName
argument_list|()
argument_list|,
name|resourceId
argument_list|)
expr_stmt|;
block|}
comment|// there may be a RestManager, in which case, we want to add this new ManagedResource immediately
if|if
condition|(
name|initializedRestManager
operator|!=
literal|null
condition|)
block|{
name|initializedRestManager
operator|.
name|addRegisteredResource
argument_list|(
name|registered
operator|.
name|get
argument_list|(
name|resourceId
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Locates the RestManager using ThreadLocal SolrRequestInfo.    */
DECL|method|getRestManager
specifier|public
specifier|static
name|RestManager
name|getRestManager
parameter_list|(
name|SolrRequestInfo
name|solrRequestInfo
parameter_list|)
block|{
if|if
condition|(
name|solrRequestInfo
operator|==
literal|null
condition|)
throw|throw
operator|new
name|ResourceException
argument_list|(
name|Status
operator|.
name|SERVER_ERROR_INTERNAL
argument_list|,
literal|"No SolrRequestInfo in this Thread!"
argument_list|)
throw|;
name|SolrQueryRequest
name|req
init|=
name|solrRequestInfo
operator|.
name|getReq
argument_list|()
decl_stmt|;
name|RestManager
name|restManager
init|=
operator|(
name|req
operator|!=
literal|null
operator|)
condition|?
name|req
operator|.
name|getCore
argument_list|()
operator|.
name|getRestManager
argument_list|()
else|:
literal|null
decl_stmt|;
if|if
condition|(
name|restManager
operator|==
literal|null
condition|)
throw|throw
operator|new
name|ResourceException
argument_list|(
name|Status
operator|.
name|SERVER_ERROR_INTERNAL
argument_list|,
literal|"No RestManager found!"
argument_list|)
throw|;
return|return
name|restManager
return|;
block|}
comment|/**    * The Restlet router needs a lightweight extension of ServerResource to delegate a request    * to. ManagedResource implementations are heavy-weight objects that live for the duration of    * a SolrCore, so this class acts as the proxy between Restlet and a ManagedResource when    * doing request processing.    *    */
DECL|class|ManagedEndpoint
specifier|public
specifier|static
class|class
name|ManagedEndpoint
extends|extends
name|BaseSolrResource
implements|implements
name|GETable
implements|,
name|PUTable
implements|,
name|POSTable
implements|,
name|DELETEable
block|{
comment|/**      * Determines the ManagedResource resourceId from the Restlet request.      */
DECL|method|resolveResourceId
specifier|public
specifier|static
name|String
name|resolveResourceId
parameter_list|(
name|Request
name|restletReq
parameter_list|)
block|{
name|String
name|resourceId
init|=
name|restletReq
operator|.
name|getResourceRef
argument_list|()
operator|.
name|getRelativeRef
argument_list|(
name|restletReq
operator|.
name|getRootRef
argument_list|()
operator|.
name|getParentRef
argument_list|()
argument_list|)
operator|.
name|getPath
argument_list|(
name|DECODE
argument_list|)
decl_stmt|;
comment|// all resources are registered with the leading slash
if|if
condition|(
operator|!
name|resourceId
operator|.
name|startsWith
argument_list|(
literal|"/"
argument_list|)
condition|)
name|resourceId
operator|=
literal|"/"
operator|+
name|resourceId
expr_stmt|;
return|return
name|resourceId
return|;
block|}
DECL|field|managedResource
specifier|protected
name|ManagedResource
name|managedResource
decl_stmt|;
DECL|field|childId
specifier|protected
name|String
name|childId
decl_stmt|;
comment|/**      * Initialize objects needed to handle a request to the REST API. Specifically,      * we lookup the RestManager using the ThreadLocal SolrRequestInfo and then      * dynamically locate the ManagedResource associated with the request URI.      */
annotation|@
name|Override
DECL|method|doInit
specifier|public
name|void
name|doInit
parameter_list|()
throws|throws
name|ResourceException
block|{
name|super
operator|.
name|doInit
argument_list|()
expr_stmt|;
comment|// get the relative path to the requested resource, which is
comment|// needed to locate ManagedResource impls at runtime
name|String
name|resourceId
init|=
name|resolveResourceId
argument_list|(
name|getRequest
argument_list|()
argument_list|)
decl_stmt|;
comment|// supports a request for a registered resource or its child
name|RestManager
name|restManager
init|=
name|RestManager
operator|.
name|getRestManager
argument_list|(
name|SolrRequestInfo
operator|.
name|getRequestInfo
argument_list|()
argument_list|)
decl_stmt|;
name|managedResource
operator|=
name|restManager
operator|.
name|getManagedResourceOrNull
argument_list|(
name|resourceId
argument_list|)
expr_stmt|;
if|if
condition|(
name|managedResource
operator|==
literal|null
condition|)
block|{
comment|// see if we have a registered endpoint one-level up ...
name|int
name|lastSlashAt
init|=
name|resourceId
operator|.
name|lastIndexOf
argument_list|(
literal|'/'
argument_list|)
decl_stmt|;
if|if
condition|(
name|lastSlashAt
operator|!=
operator|-
literal|1
condition|)
block|{
name|String
name|parentResourceId
init|=
name|resourceId
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|lastSlashAt
argument_list|)
decl_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Resource not found for {}, looking for parent: {}"
argument_list|,
name|resourceId
argument_list|,
name|parentResourceId
argument_list|)
expr_stmt|;
name|managedResource
operator|=
name|restManager
operator|.
name|getManagedResourceOrNull
argument_list|(
name|parentResourceId
argument_list|)
expr_stmt|;
if|if
condition|(
name|managedResource
operator|!=
literal|null
condition|)
block|{
comment|// verify this resource supports child resources
if|if
condition|(
operator|!
operator|(
name|managedResource
operator|instanceof
name|ManagedResource
operator|.
name|ChildResourceSupport
operator|)
condition|)
block|{
name|String
name|errMsg
init|=
name|String
operator|.
name|format
argument_list|(
name|Locale
operator|.
name|ROOT
argument_list|,
literal|"%s does not support child resources!"
argument_list|,
name|managedResource
operator|.
name|getResourceId
argument_list|()
argument_list|)
decl_stmt|;
throw|throw
operator|new
name|ResourceException
argument_list|(
name|Status
operator|.
name|CLIENT_ERROR_BAD_REQUEST
argument_list|,
name|errMsg
argument_list|)
throw|;
block|}
name|childId
operator|=
name|resourceId
operator|.
name|substring
argument_list|(
name|lastSlashAt
operator|+
literal|1
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Found parent resource {} for child: {}"
argument_list|,
name|parentResourceId
argument_list|,
name|childId
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|managedResource
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|Method
operator|.
name|PUT
operator|.
name|equals
argument_list|(
name|getMethod
argument_list|()
argument_list|)
operator|||
name|Method
operator|.
name|POST
operator|.
name|equals
argument_list|(
name|getMethod
argument_list|()
argument_list|)
condition|)
block|{
comment|// delegate create requests to the RestManager
name|managedResource
operator|=
name|restManager
operator|.
name|endpoint
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|ResourceException
argument_list|(
name|Status
operator|.
name|CLIENT_ERROR_NOT_FOUND
argument_list|,
literal|"No REST managed resource registered for path "
operator|+
name|resourceId
argument_list|)
throw|;
block|}
block|}
name|log
operator|.
name|info
argument_list|(
literal|"Found ManagedResource ["
operator|+
name|managedResource
operator|+
literal|"] for "
operator|+
name|resourceId
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|put
specifier|public
name|Representation
name|put
parameter_list|(
name|Representation
name|entity
parameter_list|)
block|{
try|try
block|{
name|managedResource
operator|.
name|doPut
argument_list|(
name|this
argument_list|,
name|entity
argument_list|,
name|parseJsonFromRequestBody
argument_list|(
name|entity
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|getSolrResponse
argument_list|()
operator|.
name|setException
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
name|handlePostExecution
argument_list|(
name|log
argument_list|)
expr_stmt|;
return|return
operator|new
name|SolrOutputRepresentation
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|post
specifier|public
name|Representation
name|post
parameter_list|(
name|Representation
name|entity
parameter_list|)
block|{
try|try
block|{
name|managedResource
operator|.
name|doPost
argument_list|(
name|this
argument_list|,
name|entity
argument_list|,
name|parseJsonFromRequestBody
argument_list|(
name|entity
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|getSolrResponse
argument_list|()
operator|.
name|setException
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
name|handlePostExecution
argument_list|(
name|log
argument_list|)
expr_stmt|;
return|return
operator|new
name|SolrOutputRepresentation
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|delete
specifier|public
name|Representation
name|delete
parameter_list|()
block|{
comment|// only delegate delete child resources to the ManagedResource
comment|// as deleting the actual resource is best handled by the
comment|// RestManager
if|if
condition|(
name|childId
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|managedResource
operator|.
name|doDeleteChild
argument_list|(
name|this
argument_list|,
name|childId
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|getSolrResponse
argument_list|()
operator|.
name|setException
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
try|try
block|{
name|RestManager
name|restManager
init|=
name|RestManager
operator|.
name|getRestManager
argument_list|(
name|SolrRequestInfo
operator|.
name|getRequestInfo
argument_list|()
argument_list|)
decl_stmt|;
name|restManager
operator|.
name|deleteManagedResource
argument_list|(
name|managedResource
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|getSolrResponse
argument_list|()
operator|.
name|setException
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
block|}
name|handlePostExecution
argument_list|(
name|log
argument_list|)
expr_stmt|;
return|return
operator|new
name|SolrOutputRepresentation
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|get
specifier|public
name|Representation
name|get
parameter_list|()
block|{
try|try
block|{
name|managedResource
operator|.
name|doGet
argument_list|(
name|this
argument_list|,
name|childId
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|getSolrResponse
argument_list|()
operator|.
name|setException
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
name|handlePostExecution
argument_list|(
name|log
argument_list|)
expr_stmt|;
return|return
operator|new
name|SolrOutputRepresentation
argument_list|()
return|;
block|}
comment|/**      * Parses and validates the JSON passed from the to the ManagedResource.       */
DECL|method|parseJsonFromRequestBody
specifier|protected
name|Object
name|parseJsonFromRequestBody
parameter_list|(
name|Representation
name|entity
parameter_list|)
block|{
if|if
condition|(
name|entity
operator|.
name|getMediaType
argument_list|()
operator|==
literal|null
condition|)
block|{
name|entity
operator|.
name|setMediaType
argument_list|(
name|MediaType
operator|.
name|APPLICATION_JSON
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|entity
operator|.
name|getMediaType
argument_list|()
operator|.
name|equals
argument_list|(
name|MediaType
operator|.
name|APPLICATION_JSON
argument_list|,
literal|true
argument_list|)
condition|)
block|{
name|String
name|errMsg
init|=
name|String
operator|.
name|format
argument_list|(
name|Locale
operator|.
name|ROOT
argument_list|,
literal|"Invalid content type %s; only %s is supported."
argument_list|,
name|entity
operator|.
name|getMediaType
argument_list|()
argument_list|,
name|MediaType
operator|.
name|APPLICATION_JSON
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
name|log
operator|.
name|error
argument_list|(
name|errMsg
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|ResourceException
argument_list|(
name|Status
operator|.
name|CLIENT_ERROR_BAD_REQUEST
argument_list|,
name|errMsg
argument_list|)
throw|;
block|}
name|String
name|text
init|=
literal|null
decl_stmt|;
try|try
block|{
name|text
operator|=
name|entity
operator|.
name|getText
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioExc
parameter_list|)
block|{
name|String
name|errMsg
init|=
literal|"Failed to read entity text due to: "
operator|+
name|ioExc
decl_stmt|;
name|log
operator|.
name|error
argument_list|(
name|errMsg
argument_list|,
name|ioExc
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|ResourceException
argument_list|(
name|Status
operator|.
name|SERVER_ERROR_INTERNAL
argument_list|,
name|errMsg
argument_list|,
name|ioExc
argument_list|)
throw|;
block|}
if|if
condition|(
name|text
operator|==
literal|null
operator|||
name|text
operator|.
name|trim
argument_list|()
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
block|{
throw|throw
operator|new
name|ResourceException
argument_list|(
name|Status
operator|.
name|CLIENT_ERROR_BAD_REQUEST
argument_list|,
literal|"Empty request body!"
argument_list|)
throw|;
block|}
name|Object
name|parsedJson
init|=
literal|null
decl_stmt|;
try|try
block|{
name|parsedJson
operator|=
name|ObjectBuilder
operator|.
name|fromJSON
argument_list|(
name|text
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioExc
parameter_list|)
block|{
name|String
name|errMsg
init|=
name|String
operator|.
name|format
argument_list|(
name|Locale
operator|.
name|ROOT
argument_list|,
literal|"Failed to parse request [%s] into JSON due to: %s"
argument_list|,
name|text
argument_list|,
name|ioExc
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
name|log
operator|.
name|error
argument_list|(
name|errMsg
argument_list|,
name|ioExc
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|ResourceException
argument_list|(
name|Status
operator|.
name|CLIENT_ERROR_BAD_REQUEST
argument_list|,
name|errMsg
argument_list|,
name|ioExc
argument_list|)
throw|;
block|}
return|return
name|parsedJson
return|;
block|}
block|}
comment|// end ManagedEndpoint class
comment|/**    * The RestManager itself supports some endpoints for creating and listing managed resources.    * Effectively, this resource provides the API endpoint for doing CRUD on the registry.    */
DECL|class|RestManagerManagedResource
specifier|private
specifier|static
class|class
name|RestManagerManagedResource
extends|extends
name|ManagedResource
block|{
DECL|field|REST_MANAGER_STORAGE_ID
specifier|private
specifier|static
specifier|final
name|String
name|REST_MANAGER_STORAGE_ID
init|=
literal|"/rest/managed"
decl_stmt|;
DECL|field|restManager
specifier|private
specifier|final
name|RestManager
name|restManager
decl_stmt|;
DECL|method|RestManagerManagedResource
specifier|public
name|RestManagerManagedResource
parameter_list|(
name|RestManager
name|restManager
parameter_list|)
throws|throws
name|SolrException
block|{
name|super
argument_list|(
name|REST_MANAGER_STORAGE_ID
argument_list|,
name|restManager
operator|.
name|loader
argument_list|,
name|restManager
operator|.
name|storageIO
argument_list|)
expr_stmt|;
name|this
operator|.
name|restManager
operator|=
name|restManager
expr_stmt|;
block|}
comment|/**      * Overrides the parent impl to handle FileNotFoundException better      */
annotation|@
name|Override
DECL|method|reloadFromStorage
specifier|protected
specifier|synchronized
name|void
name|reloadFromStorage
parameter_list|()
throws|throws
name|SolrException
block|{
name|String
name|resourceId
init|=
name|getResourceId
argument_list|()
decl_stmt|;
name|Object
name|data
init|=
literal|null
decl_stmt|;
try|try
block|{
name|data
operator|=
name|storage
operator|.
name|load
argument_list|(
name|resourceId
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|FileNotFoundException
name|fnf
parameter_list|)
block|{
comment|// this is ok - simply means there are no managed components added yet
block|}
catch|catch
parameter_list|(
name|IOException
name|ioExc
parameter_list|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|SERVER_ERROR
argument_list|,
literal|"Failed to load stored data for "
operator|+
name|resourceId
operator|+
literal|" due to: "
operator|+
name|ioExc
argument_list|,
name|ioExc
argument_list|)
throw|;
block|}
name|Object
name|managedData
init|=
name|processStoredData
argument_list|(
name|data
argument_list|)
decl_stmt|;
if|if
condition|(
name|managedInitArgs
operator|==
literal|null
condition|)
name|managedInitArgs
operator|=
operator|new
name|NamedList
argument_list|<>
argument_list|()
expr_stmt|;
if|if
condition|(
name|managedData
operator|!=
literal|null
condition|)
name|onManagedDataLoadedFromStorage
argument_list|(
name|managedInitArgs
argument_list|,
name|managedData
argument_list|)
expr_stmt|;
block|}
comment|/**      * Loads and initializes any ManagedResources that have been created but      * are not associated with any Solr components.      */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
annotation|@
name|Override
DECL|method|onManagedDataLoadedFromStorage
specifier|protected
name|void
name|onManagedDataLoadedFromStorage
parameter_list|(
name|NamedList
argument_list|<
name|?
argument_list|>
name|managedInitArgs
parameter_list|,
name|Object
name|managedData
parameter_list|)
throws|throws
name|SolrException
block|{
if|if
condition|(
name|managedData
operator|==
literal|null
condition|)
block|{
comment|// this is ok - just means no managed components have been added yet
return|return;
block|}
name|List
argument_list|<
name|Object
argument_list|>
name|managedList
init|=
operator|(
name|List
argument_list|<
name|Object
argument_list|>
operator|)
name|managedData
decl_stmt|;
for|for
control|(
name|Object
name|next
range|:
name|managedList
control|)
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|info
init|=
operator|(
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
operator|)
name|next
decl_stmt|;
name|String
name|implClass
init|=
name|info
operator|.
name|get
argument_list|(
literal|"class"
argument_list|)
decl_stmt|;
name|String
name|resourceId
init|=
name|info
operator|.
name|get
argument_list|(
literal|"resourceId"
argument_list|)
decl_stmt|;
name|Class
argument_list|<
name|?
extends|extends
name|ManagedResource
argument_list|>
name|clazz
init|=
name|solrResourceLoader
operator|.
name|findClass
argument_list|(
name|implClass
argument_list|,
name|ManagedResource
operator|.
name|class
argument_list|)
decl_stmt|;
name|ManagedResourceRegistration
name|existingReg
init|=
name|restManager
operator|.
name|registry
operator|.
name|registered
operator|.
name|get
argument_list|(
name|resourceId
argument_list|)
decl_stmt|;
if|if
condition|(
name|existingReg
operator|==
literal|null
condition|)
block|{
name|restManager
operator|.
name|registry
operator|.
name|registerManagedResource
argument_list|(
name|resourceId
argument_list|,
name|clazz
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|// else already registered, no need to take any action
block|}
block|}
comment|/**      * Creates a new ManagedResource in the RestManager.      */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
annotation|@
name|Override
DECL|method|doPut
specifier|public
specifier|synchronized
name|void
name|doPut
parameter_list|(
name|BaseSolrResource
name|endpoint
parameter_list|,
name|Representation
name|entity
parameter_list|,
name|Object
name|json
parameter_list|)
block|{
if|if
condition|(
name|json
operator|instanceof
name|Map
condition|)
block|{
name|String
name|resourceId
init|=
name|ManagedEndpoint
operator|.
name|resolveResourceId
argument_list|(
name|endpoint
operator|.
name|getRequest
argument_list|()
argument_list|)
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|info
init|=
operator|(
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
operator|)
name|json
decl_stmt|;
name|info
operator|.
name|put
argument_list|(
literal|"resourceId"
argument_list|,
name|resourceId
argument_list|)
expr_stmt|;
name|storeManagedData
argument_list|(
name|applyUpdatesToManagedData
argument_list|(
name|json
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|ResourceException
argument_list|(
name|Status
operator|.
name|CLIENT_ERROR_BAD_REQUEST
argument_list|,
literal|"Expected Map to create a new ManagedResource but received a "
operator|+
name|json
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
throw|;
block|}
comment|// PUT just returns success status code with an empty body
block|}
comment|/**      * Registers a new {@link ManagedResource}.      *      * Called during PUT/POST processing to apply updates to the managed data passed from the client.      */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
annotation|@
name|Override
DECL|method|applyUpdatesToManagedData
specifier|protected
name|Object
name|applyUpdatesToManagedData
parameter_list|(
name|Object
name|updates
parameter_list|)
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|info
init|=
operator|(
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
operator|)
name|updates
decl_stmt|;
comment|// this is where we'd register a new ManagedResource
name|String
name|implClass
init|=
name|info
operator|.
name|get
argument_list|(
literal|"class"
argument_list|)
decl_stmt|;
name|String
name|resourceId
init|=
name|info
operator|.
name|get
argument_list|(
literal|"resourceId"
argument_list|)
decl_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Creating a new ManagedResource of type {} at path {}"
argument_list|,
name|implClass
argument_list|,
name|resourceId
argument_list|)
expr_stmt|;
name|Class
argument_list|<
name|?
extends|extends
name|ManagedResource
argument_list|>
name|clazz
init|=
name|solrResourceLoader
operator|.
name|findClass
argument_list|(
name|implClass
argument_list|,
name|ManagedResource
operator|.
name|class
argument_list|)
decl_stmt|;
comment|// add this new resource to the RestManager
name|restManager
operator|.
name|addManagedResource
argument_list|(
name|resourceId
argument_list|,
name|clazz
argument_list|)
expr_stmt|;
comment|// we only store ManagedResources that don't have observers as those that do
comment|// are already implicitly defined
name|List
argument_list|<
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|>
name|managedList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|ManagedResourceRegistration
name|reg
range|:
name|restManager
operator|.
name|registry
operator|.
name|getRegistered
argument_list|()
control|)
block|{
if|if
condition|(
name|reg
operator|.
name|observers
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|managedList
operator|.
name|add
argument_list|(
name|reg
operator|.
name|getInfo
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|managedList
return|;
block|}
comment|/**      * Deleting of child resources not supported by this implementation.      */
annotation|@
name|Override
DECL|method|doDeleteChild
specifier|public
name|void
name|doDeleteChild
parameter_list|(
name|BaseSolrResource
name|endpoint
parameter_list|,
name|String
name|childId
parameter_list|)
block|{
throw|throw
operator|new
name|ResourceException
argument_list|(
name|Status
operator|.
name|SERVER_ERROR_NOT_IMPLEMENTED
argument_list|)
throw|;
block|}
annotation|@
name|Override
DECL|method|doGet
specifier|public
name|void
name|doGet
parameter_list|(
name|BaseSolrResource
name|endpoint
parameter_list|,
name|String
name|childId
parameter_list|)
block|{
comment|// filter results by /schema or /config
name|String
name|path
init|=
name|ManagedEndpoint
operator|.
name|resolveResourceId
argument_list|(
name|endpoint
operator|.
name|getRequest
argument_list|()
argument_list|)
decl_stmt|;
name|Matcher
name|resourceIdMatcher
init|=
name|resourceIdRegex
operator|.
name|matcher
argument_list|(
name|path
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|resourceIdMatcher
operator|.
name|matches
argument_list|()
condition|)
block|{
comment|// extremely unlikely but didn't want to squelch it either
throw|throw
operator|new
name|ResourceException
argument_list|(
name|Status
operator|.
name|SERVER_ERROR_NOT_IMPLEMENTED
argument_list|,
name|path
argument_list|)
throw|;
block|}
name|String
name|filter
init|=
name|resourceIdMatcher
operator|.
name|group
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|>
name|regList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|ManagedResourceRegistration
name|reg
range|:
name|restManager
operator|.
name|registry
operator|.
name|getRegistered
argument_list|()
control|)
block|{
if|if
condition|(
operator|!
name|reg
operator|.
name|resourceId
operator|.
name|startsWith
argument_list|(
name|filter
argument_list|)
condition|)
continue|continue;
comment|// doesn't match filter
if|if
condition|(
name|RestManagerManagedResource
operator|.
name|class
operator|.
name|isAssignableFrom
argument_list|(
name|reg
operator|.
name|implClass
argument_list|)
condition|)
continue|continue;
comment|// internal, no need to expose to outside
name|regList
operator|.
name|add
argument_list|(
name|reg
operator|.
name|getInfo
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|endpoint
operator|.
name|getSolrResponse
argument_list|()
operator|.
name|add
argument_list|(
literal|"managedResources"
argument_list|,
name|regList
argument_list|)
expr_stmt|;
block|}
block|}
comment|// end RestManagerManagedResource
DECL|field|storageIO
specifier|protected
name|StorageIO
name|storageIO
decl_stmt|;
DECL|field|registry
specifier|protected
name|Registry
name|registry
decl_stmt|;
DECL|field|managed
specifier|protected
name|Map
argument_list|<
name|String
argument_list|,
name|ManagedResource
argument_list|>
name|managed
init|=
operator|new
name|TreeMap
argument_list|<>
argument_list|()
decl_stmt|;
DECL|field|endpoint
specifier|protected
name|RestManagerManagedResource
name|endpoint
decl_stmt|;
DECL|field|loader
specifier|protected
name|SolrResourceLoader
name|loader
decl_stmt|;
comment|// refs to these are needed to bind new ManagedResources created using the API
DECL|field|schemaRouter
specifier|protected
name|Router
name|schemaRouter
decl_stmt|;
DECL|field|configRouter
specifier|protected
name|Router
name|configRouter
decl_stmt|;
comment|/**    * Initializes the RestManager with the storageIO being optionally created outside of this implementation    * such as to use ZooKeeper instead of the local FS.     */
DECL|method|init
specifier|public
name|void
name|init
parameter_list|(
name|SolrResourceLoader
name|loader
parameter_list|,
name|NamedList
argument_list|<
name|String
argument_list|>
name|initArgs
parameter_list|,
name|StorageIO
name|storageIO
parameter_list|)
throws|throws
name|SolrException
block|{
name|log
operator|.
name|info
argument_list|(
literal|"Initializing RestManager with initArgs: "
operator|+
name|initArgs
argument_list|)
expr_stmt|;
if|if
condition|(
name|storageIO
operator|==
literal|null
condition|)
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Must provide a valid StorageIO implementation to the RestManager!"
argument_list|)
throw|;
name|this
operator|.
name|storageIO
operator|=
name|storageIO
expr_stmt|;
name|this
operator|.
name|loader
operator|=
name|loader
expr_stmt|;
name|registry
operator|=
name|loader
operator|.
name|getManagedResourceRegistry
argument_list|()
expr_stmt|;
comment|// the RestManager provides metadata about managed resources via the /managed endpoint
comment|// and allows you to create new ManagedResources dynamically by PUT'ing to this endpoint
name|endpoint
operator|=
operator|new
name|RestManagerManagedResource
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|endpoint
operator|.
name|loadManagedDataAndNotify
argument_list|(
literal|null
argument_list|)
expr_stmt|;
comment|// no observers for my endpoint
comment|// responds to requests to /config/managed and /schema/managed
name|managed
operator|.
name|put
argument_list|(
name|SCHEMA_BASE_PATH
operator|+
name|MANAGED_ENDPOINT
argument_list|,
name|endpoint
argument_list|)
expr_stmt|;
comment|// init registered managed resources
name|log
operator|.
name|info
argument_list|(
literal|"Initializing {} registered ManagedResources"
argument_list|,
name|registry
operator|.
name|registered
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|ManagedResourceRegistration
name|reg
range|:
name|registry
operator|.
name|registered
operator|.
name|values
argument_list|()
control|)
block|{
comment|// keep track of this for lookups during request processing
name|managed
operator|.
name|put
argument_list|(
name|reg
operator|.
name|resourceId
argument_list|,
name|createManagedResource
argument_list|(
name|reg
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// this is for any new registrations that don't come through the API
comment|// such as from adding a new fieldType to a managed schema that uses a ManagedResource
name|registry
operator|.
name|initializedRestManager
operator|=
name|this
expr_stmt|;
block|}
comment|/**    * If not already registered, registers the given {@link ManagedResource} subclass    * at the given resourceId, creates an instance, and attaches it to the appropriate    * Restlet router.  Returns the corresponding instance.    */
DECL|method|addManagedResource
specifier|public
specifier|synchronized
name|ManagedResource
name|addManagedResource
parameter_list|(
name|String
name|resourceId
parameter_list|,
name|Class
argument_list|<
name|?
extends|extends
name|ManagedResource
argument_list|>
name|clazz
parameter_list|)
block|{
name|ManagedResource
name|res
init|=
literal|null
decl_stmt|;
name|ManagedResourceRegistration
name|existingReg
init|=
name|registry
operator|.
name|registered
operator|.
name|get
argument_list|(
name|resourceId
argument_list|)
decl_stmt|;
if|if
condition|(
name|existingReg
operator|==
literal|null
condition|)
block|{
name|registry
operator|.
name|registerManagedResource
argument_list|(
name|resourceId
argument_list|,
name|clazz
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|addRegisteredResource
argument_list|(
name|registry
operator|.
name|registered
operator|.
name|get
argument_list|(
name|resourceId
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|res
operator|=
name|getManagedResource
argument_list|(
name|resourceId
argument_list|)
expr_stmt|;
block|}
return|return
name|res
return|;
block|}
comment|// used internally to create and attach a ManagedResource to the Restlet router
comment|// the registry also uses this method directly, which is slightly hacky but necessary
comment|// in order to support dynamic adding of new fieldTypes using the managed-schema API
DECL|method|addRegisteredResource
specifier|private
specifier|synchronized
name|ManagedResource
name|addRegisteredResource
parameter_list|(
name|ManagedResourceRegistration
name|reg
parameter_list|)
block|{
name|String
name|resourceId
init|=
name|reg
operator|.
name|resourceId
decl_stmt|;
name|ManagedResource
name|res
init|=
name|createManagedResource
argument_list|(
name|reg
argument_list|)
decl_stmt|;
name|managed
operator|.
name|put
argument_list|(
name|resourceId
argument_list|,
name|res
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Registered new managed resource {}"
argument_list|,
name|resourceId
argument_list|)
expr_stmt|;
comment|// attach this new resource to the Restlet router
name|Matcher
name|resourceIdValidator
init|=
name|resourceIdRegex
operator|.
name|matcher
argument_list|(
name|resourceId
argument_list|)
decl_stmt|;
name|boolean
name|validated
init|=
name|resourceIdValidator
operator|.
name|matches
argument_list|()
decl_stmt|;
assert|assert
name|validated
operator|:
literal|"managed resourceId '"
operator|+
name|resourceId
operator|+
literal|"' should already be validated by registerManagedResource()"
assert|;
name|String
name|routerPath
init|=
name|resourceIdValidator
operator|.
name|group
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|String
name|path
init|=
name|resourceIdValidator
operator|.
name|group
argument_list|(
literal|2
argument_list|)
decl_stmt|;
name|Router
name|router
init|=
name|SCHEMA_BASE_PATH
operator|.
name|equals
argument_list|(
name|routerPath
argument_list|)
condition|?
name|schemaRouter
else|:
name|configRouter
decl_stmt|;
if|if
condition|(
name|router
operator|!=
literal|null
condition|)
block|{
name|attachManagedResource
argument_list|(
name|res
argument_list|,
name|path
argument_list|,
name|router
argument_list|)
expr_stmt|;
block|}
return|return
name|res
return|;
block|}
comment|/**    * Creates a ManagedResource using registration information.     */
DECL|method|createManagedResource
specifier|protected
name|ManagedResource
name|createManagedResource
parameter_list|(
name|ManagedResourceRegistration
name|reg
parameter_list|)
throws|throws
name|SolrException
block|{
name|ManagedResource
name|res
init|=
literal|null
decl_stmt|;
try|try
block|{
name|Constructor
argument_list|<
name|?
extends|extends
name|ManagedResource
argument_list|>
name|ctor
init|=
name|reg
operator|.
name|implClass
operator|.
name|getConstructor
argument_list|(
name|String
operator|.
name|class
argument_list|,
name|SolrResourceLoader
operator|.
name|class
argument_list|,
name|StorageIO
operator|.
name|class
argument_list|)
decl_stmt|;
name|res
operator|=
name|ctor
operator|.
name|newInstance
argument_list|(
name|reg
operator|.
name|resourceId
argument_list|,
name|loader
argument_list|,
name|storageIO
argument_list|)
expr_stmt|;
name|res
operator|.
name|loadManagedDataAndNotify
argument_list|(
name|reg
operator|.
name|observers
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|String
name|errMsg
init|=
name|String
operator|.
name|format
argument_list|(
name|Locale
operator|.
name|ROOT
argument_list|,
literal|"Failed to create new ManagedResource %s of type %s due to: %s"
argument_list|,
name|reg
operator|.
name|resourceId
argument_list|,
name|reg
operator|.
name|implClass
operator|.
name|getName
argument_list|()
argument_list|,
name|e
argument_list|)
decl_stmt|;
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|SERVER_ERROR
argument_list|,
name|errMsg
argument_list|,
name|e
argument_list|)
throw|;
block|}
return|return
name|res
return|;
block|}
comment|/**    * Returns the {@link ManagedResource} subclass instance corresponding    * to the given resourceId from the registry.    *    * @throws ResourceException if no managed resource is registered with    *  the given resourceId.    */
DECL|method|getManagedResource
specifier|public
name|ManagedResource
name|getManagedResource
parameter_list|(
name|String
name|resourceId
parameter_list|)
block|{
name|ManagedResource
name|res
init|=
name|getManagedResourceOrNull
argument_list|(
name|resourceId
argument_list|)
decl_stmt|;
if|if
condition|(
name|res
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|ResourceException
argument_list|(
name|Status
operator|.
name|SERVER_ERROR_INTERNAL
argument_list|,
literal|"No ManagedResource registered for path: "
operator|+
name|resourceId
argument_list|)
throw|;
block|}
return|return
name|res
return|;
block|}
comment|/**    * Returns the {@link ManagedResource} subclass instance corresponding    * to the given resourceId from the registry, or null if no resource    * has been registered with the given resourceId.    */
DECL|method|getManagedResourceOrNull
specifier|public
specifier|synchronized
name|ManagedResource
name|getManagedResourceOrNull
parameter_list|(
name|String
name|resourceId
parameter_list|)
block|{
return|return
name|managed
operator|.
name|get
argument_list|(
name|resourceId
argument_list|)
return|;
block|}
comment|/**    * Deletes a managed resource if it is not being used by any Solr components.     */
DECL|method|deleteManagedResource
specifier|public
specifier|synchronized
name|void
name|deleteManagedResource
parameter_list|(
name|ManagedResource
name|res
parameter_list|)
block|{
name|String
name|resourceId
init|=
name|res
operator|.
name|getResourceId
argument_list|()
decl_stmt|;
name|ManagedResourceRegistration
name|existingReg
init|=
name|registry
operator|.
name|registered
operator|.
name|get
argument_list|(
name|resourceId
argument_list|)
decl_stmt|;
name|int
name|numObservers
init|=
name|existingReg
operator|.
name|observers
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|numObservers
operator|>
literal|0
condition|)
block|{
name|String
name|errMsg
init|=
name|String
operator|.
name|format
argument_list|(
name|Locale
operator|.
name|ROOT
argument_list|,
literal|"Cannot delete managed resource %s as it is being used by %d Solr components"
argument_list|,
name|resourceId
argument_list|,
name|numObservers
argument_list|)
decl_stmt|;
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|FORBIDDEN
argument_list|,
name|errMsg
argument_list|)
throw|;
block|}
name|registry
operator|.
name|registered
operator|.
name|remove
argument_list|(
name|resourceId
argument_list|)
expr_stmt|;
name|managed
operator|.
name|remove
argument_list|(
name|resourceId
argument_list|)
expr_stmt|;
try|try
block|{
name|res
operator|.
name|onResourceDeleted
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|// the resource is already deleted so just log this
name|log
operator|.
name|error
argument_list|(
literal|"Error when trying to clean-up after deleting "
operator|+
name|resourceId
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Attach managed resource paths to the given Restlet Router.     * @param router - Restlet Router    */
DECL|method|attachManagedResources
specifier|public
specifier|synchronized
name|void
name|attachManagedResources
parameter_list|(
name|String
name|routerPath
parameter_list|,
name|Router
name|router
parameter_list|)
block|{
if|if
condition|(
name|SCHEMA_BASE_PATH
operator|.
name|equals
argument_list|(
name|routerPath
argument_list|)
condition|)
block|{
name|this
operator|.
name|schemaRouter
operator|=
name|router
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|SERVER_ERROR
argument_list|,
name|routerPath
operator|+
literal|" not supported by the RestManager"
argument_list|)
throw|;
block|}
name|int
name|numAttached
init|=
literal|0
decl_stmt|;
for|for
control|(
name|String
name|resourceId
range|:
name|managed
operator|.
name|keySet
argument_list|()
control|)
block|{
if|if
condition|(
name|resourceId
operator|.
name|startsWith
argument_list|(
name|routerPath
argument_list|)
condition|)
block|{
comment|// the way restlet works is you attach a path w/o the routerPath
name|String
name|path
init|=
name|resourceId
operator|.
name|substring
argument_list|(
name|routerPath
operator|.
name|length
argument_list|()
argument_list|)
decl_stmt|;
name|attachManagedResource
argument_list|(
name|managed
operator|.
name|get
argument_list|(
name|resourceId
argument_list|)
argument_list|,
name|path
argument_list|,
name|router
argument_list|)
expr_stmt|;
operator|++
name|numAttached
expr_stmt|;
block|}
block|}
name|log
operator|.
name|info
argument_list|(
literal|"Attached {} ManagedResource endpoints to Restlet router: {}"
argument_list|,
name|numAttached
argument_list|,
name|routerPath
argument_list|)
expr_stmt|;
block|}
comment|/**    * Attaches a ManagedResource and optionally a path for child resources    * to the given Restlet Router.    */
DECL|method|attachManagedResource
specifier|protected
name|void
name|attachManagedResource
parameter_list|(
name|ManagedResource
name|res
parameter_list|,
name|String
name|path
parameter_list|,
name|Router
name|router
parameter_list|)
block|{
name|router
operator|.
name|attach
argument_list|(
name|path
argument_list|,
name|res
operator|.
name|getServerResourceClass
argument_list|()
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Attached managed resource at path: {}"
argument_list|,
name|path
argument_list|)
expr_stmt|;
comment|// Determine if we should also route requests for child resources
comment|// ManagedResource.ChildResourceSupport is a marker interface that
comment|// indicates the ManagedResource also manages child resources at
comment|// a path one level down from the main resourceId
if|if
condition|(
name|ManagedResource
operator|.
name|ChildResourceSupport
operator|.
name|class
operator|.
name|isAssignableFrom
argument_list|(
name|res
operator|.
name|getClass
argument_list|()
argument_list|)
condition|)
block|{
name|router
operator|.
name|attach
argument_list|(
name|path
operator|+
literal|"/{child}"
argument_list|,
name|res
operator|.
name|getServerResourceClass
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_class
end_unit
