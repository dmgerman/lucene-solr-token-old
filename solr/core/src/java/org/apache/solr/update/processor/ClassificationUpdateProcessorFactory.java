begin_unit
begin_package
DECL|package|org.apache.solr.update.processor
package|package
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|update
operator|.
name|processor
package|;
end_package
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|LeafReader
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|SolrException
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|params
operator|.
name|SolrParams
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|util
operator|.
name|NamedList
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|request
operator|.
name|SolrQueryRequest
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|response
operator|.
name|SolrQueryResponse
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|schema
operator|.
name|IndexSchema
import|;
end_import
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_comment
comment|/**  * This class implements an UpdateProcessorFactory for the Classification Update Processor.  * It takes in input a series of parameter that will be necessary to instantiate and use the Classifier  */
end_comment
begin_class
DECL|class|ClassificationUpdateProcessorFactory
specifier|public
class|class
name|ClassificationUpdateProcessorFactory
extends|extends
name|UpdateRequestProcessorFactory
block|{
comment|// Update Processor Config params
DECL|field|INPUT_FIELDS_PARAM
specifier|private
specifier|static
specifier|final
name|String
name|INPUT_FIELDS_PARAM
init|=
literal|"inputFields"
decl_stmt|;
DECL|field|CLASS_FIELD_PARAM
specifier|private
specifier|static
specifier|final
name|String
name|CLASS_FIELD_PARAM
init|=
literal|"classField"
decl_stmt|;
DECL|field|ALGORITHM_PARAM
specifier|private
specifier|static
specifier|final
name|String
name|ALGORITHM_PARAM
init|=
literal|"algorithm"
decl_stmt|;
DECL|field|KNN_MIN_TF_PARAM
specifier|private
specifier|static
specifier|final
name|String
name|KNN_MIN_TF_PARAM
init|=
literal|"knn.minTf"
decl_stmt|;
DECL|field|KNN_MIN_DF_PARAM
specifier|private
specifier|static
specifier|final
name|String
name|KNN_MIN_DF_PARAM
init|=
literal|"knn.minDf"
decl_stmt|;
DECL|field|KNN_K_PARAM
specifier|private
specifier|static
specifier|final
name|String
name|KNN_K_PARAM
init|=
literal|"knn.k"
decl_stmt|;
comment|//Update Processor Defaults
DECL|field|DEFAULT_MIN_TF
specifier|private
specifier|static
specifier|final
name|int
name|DEFAULT_MIN_TF
init|=
literal|1
decl_stmt|;
DECL|field|DEFAULT_MIN_DF
specifier|private
specifier|static
specifier|final
name|int
name|DEFAULT_MIN_DF
init|=
literal|1
decl_stmt|;
DECL|field|DEFAULT_K
specifier|private
specifier|static
specifier|final
name|int
name|DEFAULT_K
init|=
literal|10
decl_stmt|;
DECL|field|DEFAULT_ALGORITHM
specifier|private
specifier|static
specifier|final
name|String
name|DEFAULT_ALGORITHM
init|=
literal|"knn"
decl_stmt|;
DECL|field|inputFieldNames
specifier|private
name|String
index|[]
name|inputFieldNames
decl_stmt|;
comment|// the array of fields to be sent to the Classifier
DECL|field|classFieldName
specifier|private
name|String
name|classFieldName
decl_stmt|;
comment|// the field containing the class for the Document
DECL|field|algorithm
specifier|private
name|String
name|algorithm
decl_stmt|;
comment|// the Classification Algorithm to use - currently 'knn' or 'bayes'
DECL|field|minTf
specifier|private
name|int
name|minTf
decl_stmt|;
comment|// knn specific - the minimum Term Frequency for considering a term
DECL|field|minDf
specifier|private
name|int
name|minDf
decl_stmt|;
comment|// knn specific - the minimum Document Frequency for considering a term
DECL|field|k
specifier|private
name|int
name|k
decl_stmt|;
comment|// knn specific - thw window of top results to evaluate, when assigning the class
annotation|@
name|Override
DECL|method|init
specifier|public
name|void
name|init
parameter_list|(
specifier|final
name|NamedList
name|args
parameter_list|)
block|{
if|if
condition|(
name|args
operator|!=
literal|null
condition|)
block|{
name|SolrParams
name|params
init|=
name|SolrParams
operator|.
name|toSolrParams
argument_list|(
name|args
argument_list|)
decl_stmt|;
name|String
name|fieldNames
init|=
name|params
operator|.
name|get
argument_list|(
name|INPUT_FIELDS_PARAM
argument_list|)
decl_stmt|;
comment|// must be a comma separated list of fields
name|checkNotNull
argument_list|(
name|INPUT_FIELDS_PARAM
argument_list|,
name|fieldNames
argument_list|)
expr_stmt|;
name|inputFieldNames
operator|=
name|fieldNames
operator|.
name|split
argument_list|(
literal|"\\,"
argument_list|)
expr_stmt|;
name|classFieldName
operator|=
name|params
operator|.
name|get
argument_list|(
name|CLASS_FIELD_PARAM
argument_list|)
expr_stmt|;
name|checkNotNull
argument_list|(
name|CLASS_FIELD_PARAM
argument_list|,
name|classFieldName
argument_list|)
expr_stmt|;
name|algorithm
operator|=
name|params
operator|.
name|get
argument_list|(
name|ALGORITHM_PARAM
argument_list|)
expr_stmt|;
if|if
condition|(
name|algorithm
operator|==
literal|null
condition|)
name|algorithm
operator|=
name|DEFAULT_ALGORITHM
expr_stmt|;
name|minTf
operator|=
name|getIntParam
argument_list|(
name|params
argument_list|,
name|KNN_MIN_TF_PARAM
argument_list|,
name|DEFAULT_MIN_TF
argument_list|)
expr_stmt|;
name|minDf
operator|=
name|getIntParam
argument_list|(
name|params
argument_list|,
name|KNN_MIN_DF_PARAM
argument_list|,
name|DEFAULT_MIN_DF
argument_list|)
expr_stmt|;
name|k
operator|=
name|getIntParam
argument_list|(
name|params
argument_list|,
name|KNN_K_PARAM
argument_list|,
name|DEFAULT_K
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*    * Returns an Int parsed param or a default if the param is null    *    * @param params       Solr params in input    * @param name         the param name    * @param defaultValue the param default    * @return the Int value for the param    */
DECL|method|getIntParam
specifier|private
name|int
name|getIntParam
parameter_list|(
name|SolrParams
name|params
parameter_list|,
name|String
name|name
parameter_list|,
name|int
name|defaultValue
parameter_list|)
block|{
name|String
name|paramString
init|=
name|params
operator|.
name|get
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|int
name|paramInt
decl_stmt|;
if|if
condition|(
name|paramString
operator|!=
literal|null
operator|&&
operator|!
name|paramString
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|paramInt
operator|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|paramString
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|paramInt
operator|=
name|defaultValue
expr_stmt|;
block|}
return|return
name|paramInt
return|;
block|}
DECL|method|checkNotNull
specifier|private
name|void
name|checkNotNull
parameter_list|(
name|String
name|paramName
parameter_list|,
name|Object
name|param
parameter_list|)
block|{
if|if
condition|(
name|param
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|SolrException
operator|.
name|ErrorCode
operator|.
name|SERVER_ERROR
argument_list|,
literal|"Classification UpdateProcessor '"
operator|+
name|paramName
operator|+
literal|"' can not be null"
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
DECL|method|getInstance
specifier|public
name|UpdateRequestProcessor
name|getInstance
parameter_list|(
name|SolrQueryRequest
name|req
parameter_list|,
name|SolrQueryResponse
name|rsp
parameter_list|,
name|UpdateRequestProcessor
name|next
parameter_list|)
block|{
name|IndexSchema
name|schema
init|=
name|req
operator|.
name|getSchema
argument_list|()
decl_stmt|;
name|LeafReader
name|leafReader
init|=
name|req
operator|.
name|getSearcher
argument_list|()
operator|.
name|getLeafReader
argument_list|()
decl_stmt|;
return|return
operator|new
name|ClassificationUpdateProcessor
argument_list|(
name|inputFieldNames
argument_list|,
name|classFieldName
argument_list|,
name|minDf
argument_list|,
name|minTf
argument_list|,
name|k
argument_list|,
name|algorithm
argument_list|,
name|next
argument_list|,
name|leafReader
argument_list|,
name|schema
argument_list|)
return|;
block|}
comment|/**    * get field names used as classifier's inputs    *    * @return the input field names    */
DECL|method|getInputFieldNames
specifier|public
name|String
index|[]
name|getInputFieldNames
parameter_list|()
block|{
return|return
name|inputFieldNames
return|;
block|}
comment|/**    * set field names used as classifier's inputs    *    * @param inputFieldNames the input field names    */
DECL|method|setInputFieldNames
specifier|public
name|void
name|setInputFieldNames
parameter_list|(
name|String
index|[]
name|inputFieldNames
parameter_list|)
block|{
name|this
operator|.
name|inputFieldNames
operator|=
name|inputFieldNames
expr_stmt|;
block|}
comment|/**    * get field names used as classifier's output    *    * @return the output field name    */
DECL|method|getClassFieldName
specifier|public
name|String
name|getClassFieldName
parameter_list|()
block|{
return|return
name|classFieldName
return|;
block|}
comment|/**    * set field names used as classifier's output    *    * @param classFieldName the output field name    */
DECL|method|setClassFieldName
specifier|public
name|void
name|setClassFieldName
parameter_list|(
name|String
name|classFieldName
parameter_list|)
block|{
name|this
operator|.
name|classFieldName
operator|=
name|classFieldName
expr_stmt|;
block|}
comment|/**    * get the name of the classifier algorithm used    *    * @return the classifier algorithm used    */
DECL|method|getAlgorithm
specifier|public
name|String
name|getAlgorithm
parameter_list|()
block|{
return|return
name|algorithm
return|;
block|}
comment|/**    * set the name of the classifier algorithm used    *    * @param algorithm the classifier algorithm used    */
DECL|method|setAlgorithm
specifier|public
name|void
name|setAlgorithm
parameter_list|(
name|String
name|algorithm
parameter_list|)
block|{
name|this
operator|.
name|algorithm
operator|=
name|algorithm
expr_stmt|;
block|}
comment|/**    * get the min term frequency value to be used in case algorithm is {@code "knn"}    *    * @return the min term frequency    */
DECL|method|getMinTf
specifier|public
name|int
name|getMinTf
parameter_list|()
block|{
return|return
name|minTf
return|;
block|}
comment|/**    * set the min term frequency value to be used in case algorithm is {@code "knn"}    *    * @param minTf the min term frequency    */
DECL|method|setMinTf
specifier|public
name|void
name|setMinTf
parameter_list|(
name|int
name|minTf
parameter_list|)
block|{
name|this
operator|.
name|minTf
operator|=
name|minTf
expr_stmt|;
block|}
comment|/**    * get the min document frequency value to be used in case algorithm is {@code "knn"}    *    * @return the min document frequency    */
DECL|method|getMinDf
specifier|public
name|int
name|getMinDf
parameter_list|()
block|{
return|return
name|minDf
return|;
block|}
comment|/**    * set the min document frequency value to be used in case algorithm is {@code "knn"}    *    * @param minDf the min document frequency    */
DECL|method|setMinDf
specifier|public
name|void
name|setMinDf
parameter_list|(
name|int
name|minDf
parameter_list|)
block|{
name|this
operator|.
name|minDf
operator|=
name|minDf
expr_stmt|;
block|}
comment|/**    * get the the no. of nearest neighbor to analyze, to be used in case algorithm is {@code "knn"}    *    * @return the no. of neighbors to analyze    */
DECL|method|getK
specifier|public
name|int
name|getK
parameter_list|()
block|{
return|return
name|k
return|;
block|}
comment|/**    * set the the no. of nearest neighbor to analyze, to be used in case algorithm is {@code "knn"}    *    * @param k the no. of neighbors to analyze    */
DECL|method|setK
specifier|public
name|void
name|setK
parameter_list|(
name|int
name|k
parameter_list|)
block|{
name|this
operator|.
name|k
operator|=
name|k
expr_stmt|;
block|}
block|}
end_class
end_unit
