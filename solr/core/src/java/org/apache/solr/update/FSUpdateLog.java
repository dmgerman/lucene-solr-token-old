begin_unit
begin_package
DECL|package|org.apache.solr.update
package|package
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|update
package|;
end_package
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|BytesRef
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|SolrException
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|SolrInputDocument
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|util
operator|.
name|FastInputStream
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|util
operator|.
name|FastOutputStream
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|util
operator|.
name|JavaBinCodec
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|util
operator|.
name|NamedList
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|core
operator|.
name|PluginInfo
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|core
operator|.
name|SolrCore
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|*
import|;
end_import
begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|ByteBuffer
import|;
end_import
begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|channels
operator|.
name|Channels
import|;
end_import
begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|channels
operator|.
name|FileChannel
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|*
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicInteger
import|;
end_import
begin_class
DECL|class|NullUpdateLog
class|class
name|NullUpdateLog
extends|extends
name|UpdateLog
block|{
annotation|@
name|Override
DECL|method|init
specifier|public
name|void
name|init
parameter_list|(
name|PluginInfo
name|info
parameter_list|)
block|{   }
annotation|@
name|Override
DECL|method|init
specifier|public
name|void
name|init
parameter_list|(
name|UpdateHandler
name|uhandler
parameter_list|,
name|SolrCore
name|core
parameter_list|)
block|{   }
annotation|@
name|Override
DECL|method|add
specifier|public
name|void
name|add
parameter_list|(
name|AddUpdateCommand
name|cmd
parameter_list|)
block|{   }
annotation|@
name|Override
DECL|method|delete
specifier|public
name|void
name|delete
parameter_list|(
name|DeleteUpdateCommand
name|cmd
parameter_list|)
block|{   }
annotation|@
name|Override
DECL|method|deleteByQuery
specifier|public
name|void
name|deleteByQuery
parameter_list|(
name|DeleteUpdateCommand
name|cmd
parameter_list|)
block|{   }
annotation|@
name|Override
DECL|method|preCommit
specifier|public
name|void
name|preCommit
parameter_list|(
name|CommitUpdateCommand
name|cmd
parameter_list|)
block|{   }
annotation|@
name|Override
DECL|method|postCommit
specifier|public
name|void
name|postCommit
parameter_list|(
name|CommitUpdateCommand
name|cmd
parameter_list|)
block|{   }
annotation|@
name|Override
DECL|method|preSoftCommit
specifier|public
name|void
name|preSoftCommit
parameter_list|(
name|CommitUpdateCommand
name|cmd
parameter_list|)
block|{   }
annotation|@
name|Override
DECL|method|postSoftCommit
specifier|public
name|void
name|postSoftCommit
parameter_list|(
name|CommitUpdateCommand
name|cmd
parameter_list|)
block|{   }
annotation|@
name|Override
DECL|method|lookup
specifier|public
name|Object
name|lookup
parameter_list|(
name|BytesRef
name|indexedId
parameter_list|)
block|{
return|return
literal|null
return|;
block|}
annotation|@
name|Override
DECL|method|close
specifier|public
name|void
name|close
parameter_list|()
block|{   }
block|}
end_class
begin_class
DECL|class|FSUpdateLog
specifier|public
class|class
name|FSUpdateLog
extends|extends
name|UpdateLog
block|{
DECL|field|TLOG_NAME
specifier|public
specifier|static
name|String
name|TLOG_NAME
init|=
literal|"tlog"
decl_stmt|;
DECL|field|id
name|long
name|id
init|=
operator|-
literal|1
decl_stmt|;
DECL|field|tlog
specifier|private
name|TransactionLog
name|tlog
decl_stmt|;
DECL|field|prevTlog
specifier|private
name|TransactionLog
name|prevTlog
decl_stmt|;
DECL|field|map
specifier|private
name|Map
argument_list|<
name|BytesRef
argument_list|,
name|LogPtr
argument_list|>
name|map
init|=
operator|new
name|HashMap
argument_list|<
name|BytesRef
argument_list|,
name|LogPtr
argument_list|>
argument_list|()
decl_stmt|;
DECL|field|prevMap
specifier|private
name|Map
argument_list|<
name|BytesRef
argument_list|,
name|LogPtr
argument_list|>
name|prevMap
decl_stmt|;
comment|// used while committing/reopening is happening
DECL|field|prevMap2
specifier|private
name|Map
argument_list|<
name|BytesRef
argument_list|,
name|LogPtr
argument_list|>
name|prevMap2
decl_stmt|;
comment|// used while committing/reopening is happening
DECL|field|prevMapLog
specifier|private
name|TransactionLog
name|prevMapLog
decl_stmt|;
comment|// the transaction log used to look up entries found in prevMap
DECL|field|prevMapLog2
specifier|private
name|TransactionLog
name|prevMapLog2
decl_stmt|;
comment|// the transaction log used to look up entries found in prevMap
DECL|field|tlogFiles
specifier|private
name|String
index|[]
name|tlogFiles
decl_stmt|;
DECL|field|tlogDir
specifier|private
name|File
name|tlogDir
decl_stmt|;
DECL|field|globalStrings
specifier|private
name|Collection
argument_list|<
name|String
argument_list|>
name|globalStrings
decl_stmt|;
DECL|field|dataDir
specifier|private
name|String
name|dataDir
decl_stmt|;
DECL|field|lastDataDir
specifier|private
name|String
name|lastDataDir
decl_stmt|;
annotation|@
name|Override
DECL|method|init
specifier|public
name|void
name|init
parameter_list|(
name|PluginInfo
name|info
parameter_list|)
block|{
name|dataDir
operator|=
operator|(
name|String
operator|)
name|info
operator|.
name|initArgs
operator|.
name|get
argument_list|(
literal|"dir"
argument_list|)
expr_stmt|;
block|}
DECL|method|init
specifier|public
name|void
name|init
parameter_list|(
name|UpdateHandler
name|uhandler
parameter_list|,
name|SolrCore
name|core
parameter_list|)
block|{
if|if
condition|(
name|dataDir
operator|==
literal|null
operator|||
name|dataDir
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
block|{
name|dataDir
operator|=
name|core
operator|.
name|getDataDir
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|dataDir
operator|.
name|equals
argument_list|(
name|lastDataDir
argument_list|)
condition|)
block|{
comment|// on a normal reopen, we currently shouldn't have to do anything
return|return;
block|}
name|lastDataDir
operator|=
name|dataDir
expr_stmt|;
name|tlogDir
operator|=
operator|new
name|File
argument_list|(
name|dataDir
argument_list|,
name|TLOG_NAME
argument_list|)
expr_stmt|;
name|tlogDir
operator|.
name|mkdirs
argument_list|()
expr_stmt|;
name|tlogFiles
operator|=
name|getLogList
argument_list|(
name|tlogDir
argument_list|)
expr_stmt|;
name|id
operator|=
name|getLastLogId
argument_list|()
operator|+
literal|1
expr_stmt|;
comment|// add 1 since we will create a new log for the next update
block|}
DECL|class|LogPtr
specifier|static
class|class
name|LogPtr
block|{
DECL|field|pointer
specifier|final
name|long
name|pointer
decl_stmt|;
DECL|method|LogPtr
specifier|public
name|LogPtr
parameter_list|(
name|long
name|pointer
parameter_list|)
block|{
name|this
operator|.
name|pointer
operator|=
name|pointer
expr_stmt|;
block|}
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"LogPtr("
operator|+
name|pointer
operator|+
literal|")"
return|;
block|}
block|}
DECL|method|getLogList
specifier|public
specifier|static
name|String
index|[]
name|getLogList
parameter_list|(
name|File
name|directory
parameter_list|)
block|{
specifier|final
name|String
name|prefix
init|=
name|TLOG_NAME
operator|+
literal|'.'
decl_stmt|;
name|String
index|[]
name|names
init|=
name|directory
operator|.
name|list
argument_list|(
operator|new
name|FilenameFilter
argument_list|()
block|{
specifier|public
name|boolean
name|accept
parameter_list|(
name|File
name|dir
parameter_list|,
name|String
name|name
parameter_list|)
block|{
return|return
name|name
operator|.
name|startsWith
argument_list|(
name|prefix
argument_list|)
return|;
block|}
block|}
argument_list|)
decl_stmt|;
name|Arrays
operator|.
name|sort
argument_list|(
name|names
argument_list|)
expr_stmt|;
return|return
name|names
return|;
block|}
DECL|method|getLastLogId
specifier|public
name|long
name|getLastLogId
parameter_list|()
block|{
if|if
condition|(
name|id
operator|!=
operator|-
literal|1
condition|)
return|return
name|id
return|;
if|if
condition|(
name|tlogFiles
operator|.
name|length
operator|==
literal|0
condition|)
return|return
operator|-
literal|1
return|;
name|String
name|last
init|=
name|tlogFiles
index|[
name|tlogFiles
operator|.
name|length
operator|-
literal|1
index|]
decl_stmt|;
return|return
name|Long
operator|.
name|parseLong
argument_list|(
name|last
operator|.
name|substring
argument_list|(
name|TLOG_NAME
operator|.
name|length
argument_list|()
operator|+
literal|1
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|add
specifier|public
name|void
name|add
parameter_list|(
name|AddUpdateCommand
name|cmd
parameter_list|)
block|{
synchronized|synchronized
init|(
name|this
init|)
block|{
name|ensureLog
argument_list|()
expr_stmt|;
name|long
name|pos
init|=
name|tlog
operator|.
name|write
argument_list|(
name|cmd
argument_list|)
decl_stmt|;
name|LogPtr
name|ptr
init|=
operator|new
name|LogPtr
argument_list|(
name|pos
argument_list|)
decl_stmt|;
name|map
operator|.
name|put
argument_list|(
name|cmd
operator|.
name|getIndexedId
argument_list|()
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
comment|// System.out.println("TLOG: added id " + cmd.getPrintableId() + " to " + tlog + " " + ptr + " map=" + System.identityHashCode(map));
block|}
block|}
annotation|@
name|Override
DECL|method|delete
specifier|public
name|void
name|delete
parameter_list|(
name|DeleteUpdateCommand
name|cmd
parameter_list|)
block|{
name|BytesRef
name|br
init|=
name|cmd
operator|.
name|getIndexedId
argument_list|()
decl_stmt|;
synchronized|synchronized
init|(
name|this
init|)
block|{
name|ensureLog
argument_list|()
expr_stmt|;
name|long
name|pos
init|=
name|tlog
operator|.
name|writeDelete
argument_list|(
name|cmd
argument_list|)
decl_stmt|;
name|LogPtr
name|ptr
init|=
operator|new
name|LogPtr
argument_list|(
name|pos
argument_list|)
decl_stmt|;
name|map
operator|.
name|put
argument_list|(
name|br
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
comment|// System.out.println("TLOG: added delete for id " + cmd.id + " to " + tlog + " " + ptr + " map=" + System.identityHashCode(map));
block|}
block|}
annotation|@
name|Override
DECL|method|deleteByQuery
specifier|public
name|void
name|deleteByQuery
parameter_list|(
name|DeleteUpdateCommand
name|cmd
parameter_list|)
block|{
synchronized|synchronized
init|(
name|this
init|)
block|{
name|ensureLog
argument_list|()
expr_stmt|;
comment|// TODO: how to support realtime-get, optimistic concurrency, or anything else in this case?
comment|// Maybe we shouldn't?
comment|// realtime-get could just do a reopen of the searcher
comment|// optimistic concurrency? Maybe we shouldn't support deleteByQuery w/ optimistic concurrency
name|long
name|pos
init|=
name|tlog
operator|.
name|writeDeleteByQuery
argument_list|(
name|cmd
argument_list|)
decl_stmt|;
name|LogPtr
name|ptr
init|=
operator|new
name|LogPtr
argument_list|(
name|pos
argument_list|)
decl_stmt|;
comment|// System.out.println("TLOG: added deleteByQuery " + cmd.query + " to " + tlog + " " + ptr + " map=" + System.identityHashCode(map));
block|}
block|}
DECL|method|newMap
specifier|private
name|void
name|newMap
parameter_list|()
block|{
name|prevMap2
operator|=
name|prevMap
expr_stmt|;
name|prevMapLog2
operator|=
name|prevMapLog
expr_stmt|;
name|prevMap
operator|=
name|map
expr_stmt|;
name|prevMapLog
operator|=
name|tlog
expr_stmt|;
name|map
operator|=
operator|new
name|HashMap
argument_list|<
name|BytesRef
argument_list|,
name|LogPtr
argument_list|>
argument_list|()
expr_stmt|;
block|}
DECL|method|clearOldMaps
specifier|private
name|void
name|clearOldMaps
parameter_list|()
block|{
name|prevMap
operator|=
literal|null
expr_stmt|;
name|prevMap2
operator|=
literal|null
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|preCommit
specifier|public
name|void
name|preCommit
parameter_list|(
name|CommitUpdateCommand
name|cmd
parameter_list|)
block|{
synchronized|synchronized
init|(
name|this
init|)
block|{
comment|// since we're changing the log, we must change the map.
name|newMap
argument_list|()
expr_stmt|;
comment|// since document additions can happen concurrently with commit, create
comment|// a new transaction log first so that we know the old one is definitely
comment|// in the index.
name|prevTlog
operator|=
name|tlog
expr_stmt|;
name|tlog
operator|=
literal|null
expr_stmt|;
name|id
operator|++
expr_stmt|;
if|if
condition|(
name|prevTlog
operator|!=
literal|null
condition|)
block|{
name|globalStrings
operator|=
name|prevTlog
operator|.
name|getGlobalStrings
argument_list|()
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|Override
DECL|method|postCommit
specifier|public
name|void
name|postCommit
parameter_list|(
name|CommitUpdateCommand
name|cmd
parameter_list|)
block|{
synchronized|synchronized
init|(
name|this
init|)
block|{
if|if
condition|(
name|prevTlog
operator|!=
literal|null
condition|)
block|{
name|prevTlog
operator|.
name|decref
argument_list|()
expr_stmt|;
name|prevTlog
operator|=
literal|null
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|Override
DECL|method|preSoftCommit
specifier|public
name|void
name|preSoftCommit
parameter_list|(
name|CommitUpdateCommand
name|cmd
parameter_list|)
block|{
synchronized|synchronized
init|(
name|this
init|)
block|{
if|if
condition|(
operator|!
name|cmd
operator|.
name|softCommit
condition|)
return|return;
comment|// already handled this at the start of the hard commit
name|newMap
argument_list|()
expr_stmt|;
comment|// start adding documents to a new map since we won't know if
comment|// any added documents will make it into this commit or not.
comment|// But we do know that any updates already added will definitely
comment|// show up in the latest reader after the commit succeeds.
name|map
operator|=
operator|new
name|HashMap
argument_list|<
name|BytesRef
argument_list|,
name|LogPtr
argument_list|>
argument_list|()
expr_stmt|;
comment|// System.out.println("TLOG: preSoftCommit: prevMap="+ System.identityHashCode(prevMap) + " new map=" + System.identityHashCode(map));
block|}
block|}
annotation|@
name|Override
DECL|method|postSoftCommit
specifier|public
name|void
name|postSoftCommit
parameter_list|(
name|CommitUpdateCommand
name|cmd
parameter_list|)
block|{
synchronized|synchronized
init|(
name|this
init|)
block|{
comment|// We can clear out all old maps now that a new searcher has been opened.
comment|// This currently only works since DUH2 synchronizes around preCommit to avoid
comment|// it being called in the middle of a preSoftCommit, postSoftCommit sequence.
comment|// If this DUH2 synchronization were to be removed, preSoftCommit should
comment|// record what old maps were created and only remove those.
name|clearOldMaps
argument_list|()
expr_stmt|;
comment|// System.out.println("TLOG: postSoftCommit: disposing of prevMap="+ System.identityHashCode(prevMap));
block|}
block|}
annotation|@
name|Override
DECL|method|lookup
specifier|public
name|Object
name|lookup
parameter_list|(
name|BytesRef
name|indexedId
parameter_list|)
block|{
name|LogPtr
name|entry
decl_stmt|;
name|TransactionLog
name|lookupLog
decl_stmt|;
synchronized|synchronized
init|(
name|this
init|)
block|{
name|entry
operator|=
name|map
operator|.
name|get
argument_list|(
name|indexedId
argument_list|)
expr_stmt|;
name|lookupLog
operator|=
name|tlog
expr_stmt|;
comment|// something found in "map" will always be in "tlog"
comment|// System.out.println("TLOG: lookup: for id " + indexedId.utf8ToString() + " in map " +  System.identityHashCode(map) + " got " + entry + " lookupLog=" + lookupLog);
if|if
condition|(
name|entry
operator|==
literal|null
operator|&&
name|prevMap
operator|!=
literal|null
condition|)
block|{
name|entry
operator|=
name|prevMap
operator|.
name|get
argument_list|(
name|indexedId
argument_list|)
expr_stmt|;
comment|// something found in prevMap will always be found in preMapLog (which could be tlog or prevTlog)
name|lookupLog
operator|=
name|prevMapLog
expr_stmt|;
comment|// System.out.println("TLOG: lookup: for id " + indexedId.utf8ToString() + " in prevMap " +  System.identityHashCode(prevMap) + " got " + entry + " lookupLog="+lookupLog);
block|}
if|if
condition|(
name|entry
operator|==
literal|null
operator|&&
name|prevMap2
operator|!=
literal|null
condition|)
block|{
name|entry
operator|=
name|prevMap2
operator|.
name|get
argument_list|(
name|indexedId
argument_list|)
expr_stmt|;
comment|// something found in prevMap2 will always be found in preMapLog2 (which could be tlog or prevTlog)
name|lookupLog
operator|=
name|prevMapLog2
expr_stmt|;
comment|// System.out.println("TLOG: lookup: for id " + indexedId.utf8ToString() + " in prevMap2 " +  System.identityHashCode(prevMap) + " got " + entry + " lookupLog="+lookupLog);
block|}
if|if
condition|(
name|entry
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|lookupLog
operator|.
name|incref
argument_list|()
expr_stmt|;
block|}
try|try
block|{
comment|// now do the lookup outside of the sync block for concurrency
return|return
name|lookupLog
operator|.
name|lookup
argument_list|(
name|entry
operator|.
name|pointer
argument_list|)
return|;
block|}
finally|finally
block|{
name|lookupLog
operator|.
name|decref
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|ensureLog
specifier|private
name|void
name|ensureLog
parameter_list|()
block|{
if|if
condition|(
name|tlog
operator|==
literal|null
condition|)
block|{
name|String
name|newLogName
init|=
name|String
operator|.
name|format
argument_list|(
literal|"%s.%019d"
argument_list|,
name|TLOG_NAME
argument_list|,
name|id
argument_list|)
decl_stmt|;
name|tlog
operator|=
operator|new
name|TransactionLog
argument_list|(
operator|new
name|File
argument_list|(
name|tlogDir
argument_list|,
name|newLogName
argument_list|)
argument_list|,
name|globalStrings
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|close
specifier|public
name|void
name|close
parameter_list|()
block|{
synchronized|synchronized
init|(
name|this
init|)
block|{
if|if
condition|(
name|prevTlog
operator|!=
literal|null
condition|)
block|{
name|prevTlog
operator|.
name|decref
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|tlog
operator|!=
literal|null
condition|)
block|{
name|tlog
operator|.
name|decref
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
end_class
begin_comment
comment|/**  *  Log Format: List{Operation, Version, ...}  *  ADD, VERSION, DOC  *  DELETE, VERSION, ID_BYTES  *  DELETE_BY_QUERY, VERSION, String  *  *  TODO: keep two files, one for [operation, version, id] and the other for the actual  *  document data.  That way we could throw away document log files more readily  *  while retaining the smaller operation log files longer (and we can retrieve  *  the stored fields from the latest documents from the index).  *  *  This would require keeping all source fields stored of course.  *  *  This would also allow to not log document data for requests with commit=true  *  in them (since we know that if the request succeeds, all docs will be committed)  *  */
end_comment
begin_class
DECL|class|TransactionLog
class|class
name|TransactionLog
block|{
DECL|field|id
name|long
name|id
decl_stmt|;
DECL|field|tlogFile
name|File
name|tlogFile
decl_stmt|;
DECL|field|raf
name|RandomAccessFile
name|raf
decl_stmt|;
DECL|field|channel
name|FileChannel
name|channel
decl_stmt|;
DECL|field|os
name|OutputStream
name|os
decl_stmt|;
DECL|field|fos
name|FastOutputStream
name|fos
decl_stmt|;
DECL|field|is
name|InputStream
name|is
decl_stmt|;
DECL|field|start
name|long
name|start
decl_stmt|;
DECL|field|deleteOnClose
specifier|volatile
name|boolean
name|deleteOnClose
init|=
literal|true
decl_stmt|;
comment|// we can delete old tlogs since they are currently only used for real-time-get (and in the future, recovery)
DECL|field|refcount
name|AtomicInteger
name|refcount
init|=
operator|new
name|AtomicInteger
argument_list|(
literal|1
argument_list|)
decl_stmt|;
DECL|field|globalStringMap
name|Map
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|globalStringMap
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
DECL|field|globalStringList
name|List
argument_list|<
name|String
argument_list|>
name|globalStringList
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
comment|// write a BytesRef as a byte array
DECL|field|resolver
name|JavaBinCodec
operator|.
name|ObjectResolver
name|resolver
init|=
operator|new
name|JavaBinCodec
operator|.
name|ObjectResolver
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Object
name|resolve
parameter_list|(
name|Object
name|o
parameter_list|,
name|JavaBinCodec
name|codec
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|o
operator|instanceof
name|BytesRef
condition|)
block|{
name|BytesRef
name|br
init|=
operator|(
name|BytesRef
operator|)
name|o
decl_stmt|;
name|codec
operator|.
name|writeByteArray
argument_list|(
name|br
operator|.
name|bytes
argument_list|,
name|br
operator|.
name|offset
argument_list|,
name|br
operator|.
name|length
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
return|return
name|o
return|;
block|}
block|}
decl_stmt|;
DECL|class|LogCodec
specifier|public
class|class
name|LogCodec
extends|extends
name|JavaBinCodec
block|{
DECL|method|LogCodec
specifier|public
name|LogCodec
parameter_list|()
block|{
name|super
argument_list|(
name|resolver
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|writeExternString
specifier|public
name|void
name|writeExternString
parameter_list|(
name|String
name|s
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|s
operator|==
literal|null
condition|)
block|{
name|writeTag
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// no need to synchronize globalStringMap - it's only updated before the first record is written to the log
name|Integer
name|idx
init|=
name|globalStringMap
operator|.
name|get
argument_list|(
name|s
argument_list|)
decl_stmt|;
if|if
condition|(
name|idx
operator|==
literal|null
condition|)
block|{
comment|// write a normal string
name|writeStr
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// write the extern string
name|writeTag
argument_list|(
name|EXTERN_STRING
argument_list|,
name|idx
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|readExternString
specifier|public
name|String
name|readExternString
parameter_list|(
name|FastInputStream
name|fis
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|idx
init|=
name|readSize
argument_list|(
name|fis
argument_list|)
decl_stmt|;
if|if
condition|(
name|idx
operator|!=
literal|0
condition|)
block|{
comment|// idx != 0 is the index of the extern string
comment|// no need to synchronize globalStringList - it's only updated before the first record is written to the log
return|return
name|globalStringList
operator|.
name|get
argument_list|(
name|idx
operator|-
literal|1
argument_list|)
return|;
block|}
else|else
block|{
comment|// idx == 0 means it has a string value
comment|// this shouldn't happen with this codec subclass.
throw|throw
operator|new
name|SolrException
argument_list|(
name|SolrException
operator|.
name|ErrorCode
operator|.
name|SERVER_ERROR
argument_list|,
literal|"Corrupt transaction log"
argument_list|)
throw|;
block|}
block|}
block|}
DECL|method|writeData
specifier|public
name|long
name|writeData
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
name|LogCodec
name|codec
init|=
operator|new
name|LogCodec
argument_list|()
decl_stmt|;
try|try
block|{
name|long
name|pos
init|=
name|start
operator|+
name|fos
operator|.
name|size
argument_list|()
decl_stmt|;
comment|// if we had flushed, this should be equal to channel.position()
name|codec
operator|.
name|init
argument_list|(
name|fos
argument_list|)
expr_stmt|;
name|codec
operator|.
name|writeVal
argument_list|(
name|o
argument_list|)
expr_stmt|;
return|return
name|pos
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|SolrException
operator|.
name|ErrorCode
operator|.
name|SERVER_ERROR
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
DECL|method|TransactionLog
name|TransactionLog
parameter_list|(
name|File
name|tlogFile
parameter_list|,
name|Collection
argument_list|<
name|String
argument_list|>
name|globalStrings
parameter_list|)
block|{
try|try
block|{
name|this
operator|.
name|tlogFile
operator|=
name|tlogFile
expr_stmt|;
name|raf
operator|=
operator|new
name|RandomAccessFile
argument_list|(
name|this
operator|.
name|tlogFile
argument_list|,
literal|"rw"
argument_list|)
expr_stmt|;
name|start
operator|=
name|raf
operator|.
name|length
argument_list|()
expr_stmt|;
name|channel
operator|=
name|raf
operator|.
name|getChannel
argument_list|()
expr_stmt|;
name|os
operator|=
name|Channels
operator|.
name|newOutputStream
argument_list|(
name|channel
argument_list|)
expr_stmt|;
name|fos
operator|=
name|FastOutputStream
operator|.
name|wrap
argument_list|(
name|os
argument_list|)
expr_stmt|;
name|addGlobalStrings
argument_list|(
name|globalStrings
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|SolrException
operator|.
name|ErrorCode
operator|.
name|SERVER_ERROR
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
DECL|method|addGlobalStrings
specifier|private
name|void
name|addGlobalStrings
parameter_list|(
name|Collection
argument_list|<
name|String
argument_list|>
name|strings
parameter_list|)
block|{
if|if
condition|(
name|strings
operator|==
literal|null
condition|)
return|return;
name|int
name|origSize
init|=
name|globalStringMap
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|s
range|:
name|strings
control|)
block|{
name|Integer
name|idx
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|origSize
operator|>
literal|0
condition|)
block|{
name|idx
operator|=
name|globalStringMap
operator|.
name|get
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|idx
operator|!=
literal|null
condition|)
continue|continue;
comment|// already in list
name|globalStringList
operator|.
name|add
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|globalStringMap
operator|.
name|put
argument_list|(
name|s
argument_list|,
name|globalStringList
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
assert|assert
name|globalStringMap
operator|.
name|size
argument_list|()
operator|==
name|globalStringList
operator|.
name|size
argument_list|()
assert|;
block|}
DECL|method|getGlobalStrings
name|Collection
argument_list|<
name|String
argument_list|>
name|getGlobalStrings
parameter_list|()
block|{
synchronized|synchronized
init|(
name|fos
init|)
block|{
return|return
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|(
name|globalStringList
argument_list|)
return|;
block|}
block|}
DECL|method|writeLogHeader
specifier|private
name|void
name|writeLogHeader
parameter_list|(
name|LogCodec
name|codec
parameter_list|)
throws|throws
name|IOException
block|{
name|NamedList
name|header
init|=
operator|new
name|NamedList
argument_list|<
name|Object
argument_list|>
argument_list|()
decl_stmt|;
name|header
operator|.
name|add
argument_list|(
literal|"SOLR_TLOG"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|// a magic string + version number?
name|header
operator|.
name|add
argument_list|(
literal|"strings"
argument_list|,
name|globalStringList
argument_list|)
expr_stmt|;
name|codec
operator|.
name|marshal
argument_list|(
name|header
argument_list|,
name|fos
argument_list|)
expr_stmt|;
block|}
DECL|method|write
specifier|public
name|long
name|write
parameter_list|(
name|AddUpdateCommand
name|cmd
parameter_list|)
block|{
name|LogCodec
name|codec
init|=
operator|new
name|LogCodec
argument_list|()
decl_stmt|;
synchronized|synchronized
init|(
name|fos
init|)
block|{
try|try
block|{
name|long
name|pos
init|=
name|start
operator|+
name|fos
operator|.
name|size
argument_list|()
decl_stmt|;
comment|// if we had flushed, this should be equal to channel.position()
name|SolrInputDocument
name|sdoc
init|=
name|cmd
operator|.
name|getSolrInputDocument
argument_list|()
decl_stmt|;
if|if
condition|(
name|pos
operator|==
literal|0
condition|)
block|{
comment|// TODO: needs to be changed if we start writing a header first
name|addGlobalStrings
argument_list|(
name|sdoc
operator|.
name|getFieldNames
argument_list|()
argument_list|)
expr_stmt|;
name|pos
operator|=
name|start
operator|+
name|fos
operator|.
name|size
argument_list|()
expr_stmt|;
block|}
name|codec
operator|.
name|init
argument_list|(
name|fos
argument_list|)
expr_stmt|;
name|codec
operator|.
name|writeTag
argument_list|(
name|JavaBinCodec
operator|.
name|ARR
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|codec
operator|.
name|writeInt
argument_list|(
name|UpdateLog
operator|.
name|ADD
argument_list|)
expr_stmt|;
comment|// should just take one byte
name|codec
operator|.
name|writeLong
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|// the version... should also just be one byte if 0
name|codec
operator|.
name|writeSolrInputDocument
argument_list|(
name|cmd
operator|.
name|getSolrInputDocument
argument_list|()
argument_list|)
expr_stmt|;
comment|// fos.flushBuffer();  // flush later
return|return
name|pos
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|SolrException
operator|.
name|ErrorCode
operator|.
name|SERVER_ERROR
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
block|}
DECL|method|writeDelete
specifier|public
name|long
name|writeDelete
parameter_list|(
name|DeleteUpdateCommand
name|cmd
parameter_list|)
block|{
name|LogCodec
name|codec
init|=
operator|new
name|LogCodec
argument_list|()
decl_stmt|;
synchronized|synchronized
init|(
name|fos
init|)
block|{
try|try
block|{
name|long
name|pos
init|=
name|start
operator|+
name|fos
operator|.
name|size
argument_list|()
decl_stmt|;
comment|// if we had flushed, this should be equal to channel.position()
if|if
condition|(
name|pos
operator|==
literal|0
condition|)
block|{
name|writeLogHeader
argument_list|(
name|codec
argument_list|)
expr_stmt|;
name|pos
operator|=
name|start
operator|+
name|fos
operator|.
name|size
argument_list|()
expr_stmt|;
block|}
name|codec
operator|.
name|init
argument_list|(
name|fos
argument_list|)
expr_stmt|;
name|codec
operator|.
name|writeTag
argument_list|(
name|JavaBinCodec
operator|.
name|ARR
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|codec
operator|.
name|writeInt
argument_list|(
name|UpdateLog
operator|.
name|DELETE
argument_list|)
expr_stmt|;
comment|// should just take one byte
name|codec
operator|.
name|writeLong
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|// the version... should also just be one byte if 0
name|BytesRef
name|br
init|=
name|cmd
operator|.
name|getIndexedId
argument_list|()
decl_stmt|;
name|codec
operator|.
name|writeByteArray
argument_list|(
name|br
operator|.
name|bytes
argument_list|,
name|br
operator|.
name|offset
argument_list|,
name|br
operator|.
name|length
argument_list|)
expr_stmt|;
comment|// fos.flushBuffer();  // flush later
return|return
name|pos
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|SolrException
operator|.
name|ErrorCode
operator|.
name|SERVER_ERROR
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
block|}
DECL|method|writeDeleteByQuery
specifier|public
name|long
name|writeDeleteByQuery
parameter_list|(
name|DeleteUpdateCommand
name|cmd
parameter_list|)
block|{
name|LogCodec
name|codec
init|=
operator|new
name|LogCodec
argument_list|()
decl_stmt|;
synchronized|synchronized
init|(
name|fos
init|)
block|{
try|try
block|{
name|long
name|pos
init|=
name|start
operator|+
name|fos
operator|.
name|size
argument_list|()
decl_stmt|;
comment|// if we had flushed, this should be equal to channel.position()
if|if
condition|(
name|pos
operator|==
literal|0
condition|)
block|{
name|writeLogHeader
argument_list|(
name|codec
argument_list|)
expr_stmt|;
name|pos
operator|=
name|start
operator|+
name|fos
operator|.
name|size
argument_list|()
expr_stmt|;
block|}
name|codec
operator|.
name|init
argument_list|(
name|fos
argument_list|)
expr_stmt|;
name|codec
operator|.
name|writeTag
argument_list|(
name|JavaBinCodec
operator|.
name|ARR
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|codec
operator|.
name|writeInt
argument_list|(
name|UpdateLog
operator|.
name|DELETE_BY_QUERY
argument_list|)
expr_stmt|;
comment|// should just take one byte
name|codec
operator|.
name|writeLong
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|// the version... should also just be one byte if 0
name|codec
operator|.
name|writeStr
argument_list|(
name|cmd
operator|.
name|query
argument_list|)
expr_stmt|;
comment|// fos.flushBuffer();  // flush later
return|return
name|pos
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|SolrException
operator|.
name|ErrorCode
operator|.
name|SERVER_ERROR
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
block|}
comment|/* This method is thread safe */
DECL|method|lookup
specifier|public
name|Object
name|lookup
parameter_list|(
name|long
name|pos
parameter_list|)
block|{
try|try
block|{
comment|// make sure any unflushed buffer has been flushed
synchronized|synchronized
init|(
name|fos
init|)
block|{
comment|// TODO: optimize this by keeping track of what we have flushed up to
name|fos
operator|.
name|flushBuffer
argument_list|()
expr_stmt|;
block|}
name|ChannelFastInputStream
name|fis
init|=
operator|new
name|ChannelFastInputStream
argument_list|(
name|channel
argument_list|,
name|pos
argument_list|)
decl_stmt|;
name|LogCodec
name|codec
init|=
operator|new
name|LogCodec
argument_list|()
decl_stmt|;
return|return
name|codec
operator|.
name|readVal
argument_list|(
name|fis
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|SolrException
operator|.
name|ErrorCode
operator|.
name|SERVER_ERROR
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
DECL|method|incref
specifier|public
name|void
name|incref
parameter_list|()
block|{
name|refcount
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
block|}
DECL|method|decref
specifier|public
name|void
name|decref
parameter_list|()
block|{
if|if
condition|(
name|refcount
operator|.
name|decrementAndGet
argument_list|()
operator|==
literal|0
condition|)
block|{
name|close
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|close
specifier|private
name|void
name|close
parameter_list|()
block|{
try|try
block|{
name|fos
operator|.
name|flush
argument_list|()
expr_stmt|;
name|fos
operator|.
name|close
argument_list|()
expr_stmt|;
if|if
condition|(
name|deleteOnClose
condition|)
block|{
name|tlogFile
operator|.
name|delete
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|SolrException
operator|.
name|ErrorCode
operator|.
name|SERVER_ERROR
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|tlogFile
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
end_class
begin_class
DECL|class|ChannelFastInputStream
class|class
name|ChannelFastInputStream
extends|extends
name|FastInputStream
block|{
DECL|field|ch
name|FileChannel
name|ch
decl_stmt|;
DECL|field|chPosition
name|long
name|chPosition
decl_stmt|;
DECL|method|ChannelFastInputStream
specifier|public
name|ChannelFastInputStream
parameter_list|(
name|FileChannel
name|ch
parameter_list|,
name|long
name|chPosition
parameter_list|)
block|{
name|super
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|this
operator|.
name|ch
operator|=
name|ch
expr_stmt|;
name|this
operator|.
name|chPosition
operator|=
name|chPosition
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|readWrappedStream
specifier|public
name|int
name|readWrappedStream
parameter_list|(
name|byte
index|[]
name|target
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|len
parameter_list|)
throws|throws
name|IOException
block|{
name|ByteBuffer
name|bb
init|=
name|ByteBuffer
operator|.
name|wrap
argument_list|(
name|target
argument_list|,
name|offset
argument_list|,
name|len
argument_list|)
decl_stmt|;
name|int
name|ret
init|=
name|ch
operator|.
name|read
argument_list|(
name|bb
argument_list|,
name|chPosition
argument_list|)
decl_stmt|;
if|if
condition|(
name|ret
operator|>=
literal|0
condition|)
block|{
name|chPosition
operator|+=
name|ret
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
annotation|@
name|Override
DECL|method|close
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
name|ch
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
end_class
end_unit
