begin_unit
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_package
DECL|package|org.apache.solr.update.processor
package|package
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|update
operator|.
name|processor
package|;
end_package
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Locale
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import
begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|invoke
operator|.
name|MethodHandles
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|BytesRef
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|CharsRefBuilder
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|cloud
operator|.
name|ZkController
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|SolrException
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|SolrException
operator|.
name|ErrorCode
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|ToleratedUpdateError
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|ToleratedUpdateError
operator|.
name|CmdType
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|cloud
operator|.
name|DocCollection
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|cloud
operator|.
name|Slice
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|params
operator|.
name|ShardParams
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|params
operator|.
name|SolrParams
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|util
operator|.
name|NamedList
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|util
operator|.
name|SimpleOrderedMap
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|request
operator|.
name|SolrQueryRequest
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|response
operator|.
name|SolrQueryResponse
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|schema
operator|.
name|SchemaField
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|update
operator|.
name|AddUpdateCommand
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|update
operator|.
name|CommitUpdateCommand
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|update
operator|.
name|DeleteUpdateCommand
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|update
operator|.
name|MergeIndexesCommand
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|update
operator|.
name|RollbackUpdateCommand
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|update
operator|.
name|SolrCmdDistributor
operator|.
name|Error
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|update
operator|.
name|processor
operator|.
name|DistributedUpdateProcessor
operator|.
name|DistribPhase
import|;
end_import
begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import
begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import
begin_comment
comment|/**   *<p>   * Suppresses errors for individual add/delete commands within a single request.  * Instead of failing on the first error, at most<code>maxErrors</code> errors (or unlimited   * if<code>-1==maxErrors</code>) are logged and recorded the batch continues.   * The client will receive a<code>status==200</code> response, which includes a list of errors   * that were tolerated.  *</p>  *<p>  * If more then<code>maxErrors</code> occur, the first exception recorded will be re-thrown,   * Solr will respond with<code>status==5xx</code> or<code>status==4xx</code>   * (depending on the underlying exceptions) and it won't finish processing any more updates in the request.   * (ie: subsequent update commands in the request will not be processed even if they are valid).  *</p>  *   *<p>  * NOTE: In cloud based collections, this processor expects to<b>NOT</b> be used on {@link DistribPhase#FROMLEADER}   * requests (because any successes that occur locally on the leader are considered successes even if there is some   * subsequent error on a replica).  {@link TolerantUpdateProcessorFactory} will short circut it away in those   * requests.  *</p>  *   * @see TolerantUpdateProcessorFactory  */
end_comment
begin_class
DECL|class|TolerantUpdateProcessor
specifier|public
class|class
name|TolerantUpdateProcessor
extends|extends
name|UpdateRequestProcessor
block|{
DECL|field|log
specifier|private
specifier|static
specifier|final
name|Logger
name|log
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|MethodHandles
operator|.
name|lookup
argument_list|()
operator|.
name|lookupClass
argument_list|()
argument_list|)
decl_stmt|;
comment|/**    * String to be used as document key for errors when a real uniqueKey can't be determined    */
DECL|field|UNKNOWN_ID
specifier|private
specifier|static
specifier|final
name|String
name|UNKNOWN_ID
init|=
literal|"(unknown)"
decl_stmt|;
comment|/**    * Response Header    */
DECL|field|header
specifier|private
specifier|final
name|NamedList
argument_list|<
name|Object
argument_list|>
name|header
decl_stmt|;
comment|/**    * Number of errors this UpdateRequestProcessor will tolerate. If more then this occur,     * the original exception will be thrown, interrupting the processing of the document    * batch    */
DECL|field|maxErrors
specifier|private
specifier|final
name|int
name|maxErrors
decl_stmt|;
comment|/** The uniqueKey field */
DECL|field|uniqueKeyField
specifier|private
name|SchemaField
name|uniqueKeyField
decl_stmt|;
DECL|field|req
specifier|private
specifier|final
name|SolrQueryRequest
name|req
decl_stmt|;
DECL|field|zkController
specifier|private
name|ZkController
name|zkController
decl_stmt|;
comment|/**    * Known errors that occurred in this batch, in order encountered (may not be the same as the     * order the commands were originally executed in due to the async distributed updates).    */
DECL|field|knownErrors
specifier|private
specifier|final
name|List
argument_list|<
name|ToleratedUpdateError
argument_list|>
name|knownErrors
init|=
operator|new
name|ArrayList
argument_list|<
name|ToleratedUpdateError
argument_list|>
argument_list|()
decl_stmt|;
comment|// Kludge: Because deleteByQuery updates are forwarded to every leader, we can get identical
comment|// errors reported by every leader for the same underlying problem.
comment|//
comment|// It would be nice if we could cleanly handle the unlikely (but possible) situation of an
comment|// update stream that includes multiple identical DBQs, with identical failures, and
comment|// to report each one once, for example...
comment|//   add: id#1
comment|//   dbq: foo:bar
comment|//   add: id#2
comment|//   add: id#3
comment|//   dbq: foo:bar
comment|//
comment|// ...but i can't figure out a way to accurately identify& return duplicate
comment|// ToleratedUpdateErrors from duplicate identical underlying requests w/o erroneously returning identical
comment|// ToleratedUpdateErrors for the *same* underlying request but from diff shards.
comment|//
comment|// So as a kludge, we keep track of them for deduping against identical remote failures
comment|//
DECL|field|knownDBQErrors
specifier|private
name|Set
argument_list|<
name|ToleratedUpdateError
argument_list|>
name|knownDBQErrors
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
DECL|field|firstErrTracker
specifier|private
specifier|final
name|FirstErrTracker
name|firstErrTracker
init|=
operator|new
name|FirstErrTracker
argument_list|()
decl_stmt|;
DECL|field|distribPhase
specifier|private
specifier|final
name|DistribPhase
name|distribPhase
decl_stmt|;
DECL|method|TolerantUpdateProcessor
specifier|public
name|TolerantUpdateProcessor
parameter_list|(
name|SolrQueryRequest
name|req
parameter_list|,
name|SolrQueryResponse
name|rsp
parameter_list|,
name|UpdateRequestProcessor
name|next
parameter_list|,
name|int
name|maxErrors
parameter_list|,
name|DistribPhase
name|distribPhase
parameter_list|)
block|{
name|super
argument_list|(
name|next
argument_list|)
expr_stmt|;
assert|assert
name|maxErrors
operator|>=
operator|-
literal|1
assert|;
name|header
operator|=
name|rsp
operator|.
name|getResponseHeader
argument_list|()
expr_stmt|;
name|this
operator|.
name|maxErrors
operator|=
name|ToleratedUpdateError
operator|.
name|getEffectiveMaxErrors
argument_list|(
name|maxErrors
argument_list|)
expr_stmt|;
name|this
operator|.
name|req
operator|=
name|req
expr_stmt|;
name|this
operator|.
name|distribPhase
operator|=
name|distribPhase
expr_stmt|;
assert|assert
operator|!
name|DistribPhase
operator|.
name|FROMLEADER
operator|.
name|equals
argument_list|(
name|distribPhase
argument_list|)
assert|;
name|this
operator|.
name|zkController
operator|=
name|this
operator|.
name|req
operator|.
name|getCore
argument_list|()
operator|.
name|getCoreDescriptor
argument_list|()
operator|.
name|getCoreContainer
argument_list|()
operator|.
name|getZkController
argument_list|()
expr_stmt|;
name|this
operator|.
name|uniqueKeyField
operator|=
name|this
operator|.
name|req
operator|.
name|getCore
argument_list|()
operator|.
name|getLatestSchema
argument_list|()
operator|.
name|getUniqueKeyField
argument_list|()
expr_stmt|;
assert|assert
literal|null
operator|!=
name|uniqueKeyField
operator|:
literal|"Factory didn't enforce uniqueKey field?"
assert|;
block|}
annotation|@
name|Override
DECL|method|processAdd
specifier|public
name|void
name|processAdd
parameter_list|(
name|AddUpdateCommand
name|cmd
parameter_list|)
throws|throws
name|IOException
block|{
name|BytesRef
name|id
init|=
literal|null
decl_stmt|;
try|try
block|{
comment|// force AddUpdateCommand to validate+cache the id before proceeding
name|id
operator|=
name|cmd
operator|.
name|getIndexedId
argument_list|()
expr_stmt|;
name|super
operator|.
name|processAdd
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|firstErrTracker
operator|.
name|caught
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|knownErrors
operator|.
name|add
argument_list|(
operator|new
name|ToleratedUpdateError
argument_list|(
name|CmdType
operator|.
name|ADD
argument_list|,
name|getPrintableId
argument_list|(
name|id
argument_list|)
argument_list|,
name|t
operator|.
name|getMessage
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|knownErrors
operator|.
name|size
argument_list|()
operator|>
name|maxErrors
condition|)
block|{
name|firstErrTracker
operator|.
name|throwFirst
argument_list|()
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|Override
DECL|method|processDelete
specifier|public
name|void
name|processDelete
parameter_list|(
name|DeleteUpdateCommand
name|cmd
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
name|super
operator|.
name|processDelete
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|firstErrTracker
operator|.
name|caught
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|ToleratedUpdateError
name|err
init|=
operator|new
name|ToleratedUpdateError
argument_list|(
name|cmd
operator|.
name|isDeleteById
argument_list|()
condition|?
name|CmdType
operator|.
name|DELID
else|:
name|CmdType
operator|.
name|DELQ
argument_list|,
name|cmd
operator|.
name|isDeleteById
argument_list|()
condition|?
name|cmd
operator|.
name|id
else|:
name|cmd
operator|.
name|query
argument_list|,
name|t
operator|.
name|getMessage
argument_list|()
argument_list|)
decl_stmt|;
name|knownErrors
operator|.
name|add
argument_list|(
name|err
argument_list|)
expr_stmt|;
comment|// NOTE: we're not using this to dedup before adding to knownErrors.
comment|// if we're lucky enough to get an immediate local failure (ie: we're a leader, or some other processor
comment|// failed) then recording the multiple failures is a good thing -- helps us with an accurate fail
comment|// fast if we exceed maxErrors
if|if
condition|(
name|CmdType
operator|.
name|DELQ
operator|.
name|equals
argument_list|(
name|err
operator|.
name|getType
argument_list|()
argument_list|)
condition|)
block|{
name|knownDBQErrors
operator|.
name|add
argument_list|(
name|err
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|knownErrors
operator|.
name|size
argument_list|()
operator|>
name|maxErrors
condition|)
block|{
name|firstErrTracker
operator|.
name|throwFirst
argument_list|()
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|Override
DECL|method|processMergeIndexes
specifier|public
name|void
name|processMergeIndexes
parameter_list|(
name|MergeIndexesCommand
name|cmd
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
name|super
operator|.
name|processMergeIndexes
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
comment|// we're not tolerant of errors from this type of command, but we
comment|// do need to track it so we can annotate it with any other errors we were already tolerant of
name|firstErrTracker
operator|.
name|caught
argument_list|(
name|t
argument_list|)
expr_stmt|;
throw|throw
name|t
throw|;
block|}
block|}
annotation|@
name|Override
DECL|method|processCommit
specifier|public
name|void
name|processCommit
parameter_list|(
name|CommitUpdateCommand
name|cmd
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
name|super
operator|.
name|processCommit
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
comment|// we're not tolerant of errors from this type of command, but we
comment|// do need to track it so we can annotate it with any other errors we were already tolerant of
name|firstErrTracker
operator|.
name|caught
argument_list|(
name|t
argument_list|)
expr_stmt|;
throw|throw
name|t
throw|;
block|}
block|}
annotation|@
name|Override
DECL|method|processRollback
specifier|public
name|void
name|processRollback
parameter_list|(
name|RollbackUpdateCommand
name|cmd
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
name|super
operator|.
name|processRollback
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
comment|// we're not tolerant of errors from this type of command, but we
comment|// do need to track it so we can annotate it with any other errors we were already tolerant of
name|firstErrTracker
operator|.
name|caught
argument_list|(
name|t
argument_list|)
expr_stmt|;
throw|throw
name|t
throw|;
block|}
block|}
annotation|@
name|Override
DECL|method|finish
specifier|public
name|void
name|finish
parameter_list|()
throws|throws
name|IOException
block|{
comment|// even if processAdd threw an error, this.finish() is still called and we might have additional
comment|// errors from other remote leaders that we need to check for from the finish method of downstream processors
comment|// (like DUP)
try|try
block|{
name|super
operator|.
name|finish
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|DistributedUpdateProcessor
operator|.
name|DistributedUpdatesAsyncException
name|duae
parameter_list|)
block|{
name|firstErrTracker
operator|.
name|caught
argument_list|(
name|duae
argument_list|)
expr_stmt|;
comment|// adjust our stats based on each of the distributed errors
for|for
control|(
name|Error
name|error
range|:
name|duae
operator|.
name|errors
control|)
block|{
comment|// we can't trust the req info from the Error, because multiple original requests might have been
comment|// lumped together
comment|//
comment|// instead we trust the metadata that the TolerantUpdateProcessor running on the remote node added
comment|// to the exception when it failed.
if|if
condition|(
operator|!
operator|(
name|error
operator|.
name|e
operator|instanceof
name|SolrException
operator|)
condition|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"async update exception is not SolrException, no metadata to process"
argument_list|,
name|error
operator|.
name|e
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|SolrException
name|remoteErr
init|=
operator|(
name|SolrException
operator|)
name|error
operator|.
name|e
decl_stmt|;
name|NamedList
argument_list|<
name|String
argument_list|>
name|remoteErrMetadata
init|=
name|remoteErr
operator|.
name|getMetadata
argument_list|()
decl_stmt|;
if|if
condition|(
literal|null
operator|==
name|remoteErrMetadata
condition|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"remote error has no metadata to aggregate: "
operator|+
name|remoteErr
operator|.
name|getMessage
argument_list|()
argument_list|,
name|remoteErr
argument_list|)
expr_stmt|;
continue|continue;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|remoteErrMetadata
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|ToleratedUpdateError
name|err
init|=
name|ToleratedUpdateError
operator|.
name|parseMetadataIfToleratedUpdateError
argument_list|(
name|remoteErrMetadata
operator|.
name|getName
argument_list|(
name|i
argument_list|)
argument_list|,
name|remoteErrMetadata
operator|.
name|getVal
argument_list|(
name|i
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
literal|null
operator|==
name|err
condition|)
block|{
comment|// some metadata unrelated to this update processor
continue|continue;
block|}
if|if
condition|(
name|CmdType
operator|.
name|DELQ
operator|.
name|equals
argument_list|(
name|err
operator|.
name|getType
argument_list|()
argument_list|)
condition|)
block|{
if|if
condition|(
name|knownDBQErrors
operator|.
name|contains
argument_list|(
name|err
argument_list|)
condition|)
block|{
comment|// we've already seen this identical error, probably a dup from another shard
continue|continue;
block|}
else|else
block|{
name|knownDBQErrors
operator|.
name|add
argument_list|(
name|err
argument_list|)
expr_stmt|;
block|}
block|}
name|knownErrors
operator|.
name|add
argument_list|(
name|err
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|header
operator|.
name|add
argument_list|(
literal|"errors"
argument_list|,
name|ToleratedUpdateError
operator|.
name|formatForResponseHeader
argument_list|(
name|knownErrors
argument_list|)
argument_list|)
expr_stmt|;
comment|// include in response so client knows what effective value was (may have been server side config)
name|header
operator|.
name|add
argument_list|(
literal|"maxErrors"
argument_list|,
name|ToleratedUpdateError
operator|.
name|getUserFriendlyMaxErrors
argument_list|(
name|maxErrors
argument_list|)
argument_list|)
expr_stmt|;
comment|// annotate any error that might be thrown (or was already thrown)
name|firstErrTracker
operator|.
name|annotate
argument_list|(
name|knownErrors
argument_list|)
expr_stmt|;
comment|// decide if we have hit a situation where we know an error needs to be thrown.
if|if
condition|(
operator|(
name|DistribPhase
operator|.
name|TOLEADER
operator|.
name|equals
argument_list|(
name|distribPhase
argument_list|)
condition|?
literal|0
else|:
name|maxErrors
operator|)
operator|<
name|knownErrors
operator|.
name|size
argument_list|()
condition|)
block|{
comment|// NOTE: even if maxErrors wasn't exceeded, we need to throw an error when we have any errors if we're
comment|// a leader that was forwarded to by another node so that the forwarding node knows we encountered some
comment|// problems and can aggregate the results
name|firstErrTracker
operator|.
name|throwFirst
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Returns the output of {@link org.apache.solr.schema.FieldType#    * indexedToReadable(BytesRef, CharsRefBuilder)} of the field    * type of the uniqueKey on the {@link BytesRef} passed as parameter.    *<code>ref</code> should be the indexed representation of the id -- if null    * (possibly because it's missing in the update) this method will return {@link #UNKNOWN_ID}    */
DECL|method|getPrintableId
specifier|private
name|String
name|getPrintableId
parameter_list|(
name|BytesRef
name|ref
parameter_list|)
block|{
if|if
condition|(
name|ref
operator|==
literal|null
condition|)
block|{
return|return
name|UNKNOWN_ID
return|;
block|}
return|return
name|uniqueKeyField
operator|.
name|getType
argument_list|()
operator|.
name|indexedToReadable
argument_list|(
name|ref
argument_list|,
operator|new
name|CharsRefBuilder
argument_list|()
argument_list|)
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**    * Simple helper class for "tracking" any exceptions encountered.    *     * Only remembers the "first" exception encountered, and wraps it in a SolrException if needed, so that     * it can later be annotated with the metadata our users expect and re-thrown.    *    * NOTE: NOT THREAD SAFE    */
DECL|class|FirstErrTracker
specifier|private
specifier|static
specifier|final
class|class
name|FirstErrTracker
block|{
DECL|field|first
name|SolrException
name|first
init|=
literal|null
decl_stmt|;
DECL|field|thrown
name|boolean
name|thrown
init|=
literal|false
decl_stmt|;
DECL|method|FirstErrTracker
specifier|public
name|FirstErrTracker
parameter_list|()
block|{
comment|/* NOOP */
block|}
comment|/**       * Call this method immediately anytime an exception is caught from a down stream method --       * even if you are going to ignore it (for now).  If you plan to rethrow the Exception, use       * {@link #throwFirst} instead.      */
DECL|method|caught
specifier|public
name|void
name|caught
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
assert|assert
literal|null
operator|!=
name|t
assert|;
if|if
condition|(
literal|null
operator|==
name|first
condition|)
block|{
if|if
condition|(
name|t
operator|instanceof
name|SolrException
condition|)
block|{
name|first
operator|=
operator|(
name|SolrException
operator|)
name|t
expr_stmt|;
block|}
else|else
block|{
name|first
operator|=
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|SERVER_ERROR
argument_list|,
literal|"Tolerantly Caught Exception: "
operator|+
name|t
operator|.
name|getMessage
argument_list|()
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**       * Call this method in place of any situation where you would normally (re)throw an exception       * (already passed to the {@link #caught} method because maxErrors was exceeded      * is exceed.      *      * This method will keep a record that this update processor has already thrown the exception, and do       * nothing on future calls, so subsequent update processor methods can update the metadata but won't       * inadvertently re-throw this (or any other) cascading exception by mistake.      */
DECL|method|throwFirst
specifier|public
name|void
name|throwFirst
parameter_list|()
throws|throws
name|SolrException
block|{
assert|assert
literal|null
operator|!=
name|first
operator|:
literal|"caught was never called?"
assert|;
if|if
condition|(
operator|!
name|thrown
condition|)
block|{
name|thrown
operator|=
literal|true
expr_stmt|;
throw|throw
name|first
throw|;
block|}
block|}
comment|/**       * Annotates the first exception (which may already have been thrown, or be thrown in the future) with       * the metadata from this update processor.  For use in {@link TolerantUpdateProcessor#finish}      */
DECL|method|annotate
specifier|public
name|void
name|annotate
parameter_list|(
name|List
argument_list|<
name|ToleratedUpdateError
argument_list|>
name|errors
parameter_list|)
block|{
if|if
condition|(
literal|null
operator|==
name|first
condition|)
block|{
return|return;
comment|// no exception to annotate
block|}
assert|assert
literal|null
operator|!=
name|errors
operator|:
literal|"how do we have an exception to annotate w/o any errors?"
assert|;
name|NamedList
argument_list|<
name|String
argument_list|>
name|firstErrMetadata
init|=
name|first
operator|.
name|getMetadata
argument_list|()
decl_stmt|;
if|if
condition|(
literal|null
operator|==
name|firstErrMetadata
condition|)
block|{
comment|// obnoxious
name|firstErrMetadata
operator|=
operator|new
name|NamedList
argument_list|<
name|String
argument_list|>
argument_list|()
expr_stmt|;
name|first
operator|.
name|setMetadata
argument_list|(
name|firstErrMetadata
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// any existing metadata representing ToleratedUpdateErrors in this single exception needs removed
comment|// so we can add *all* of the known ToleratedUpdateErrors (from this and other exceptions)
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|firstErrMetadata
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
literal|null
operator|!=
name|ToleratedUpdateError
operator|.
name|parseMetadataIfToleratedUpdateError
argument_list|(
name|firstErrMetadata
operator|.
name|getName
argument_list|(
name|i
argument_list|)
argument_list|,
name|firstErrMetadata
operator|.
name|getVal
argument_list|(
name|i
argument_list|)
argument_list|)
condition|)
block|{
name|firstErrMetadata
operator|.
name|remove
argument_list|(
name|i
argument_list|)
expr_stmt|;
comment|// NOTE: post decrementing index so we don't miss anything as we remove items
name|i
operator|--
expr_stmt|;
block|}
block|}
block|}
for|for
control|(
name|ToleratedUpdateError
name|te
range|:
name|errors
control|)
block|{
name|firstErrMetadata
operator|.
name|add
argument_list|(
name|te
operator|.
name|getMetadataKey
argument_list|()
argument_list|,
name|te
operator|.
name|getMetadataValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** The first exception that was thrown (or may be thrown) whose metadata can be annotated. */
DECL|method|getFirst
specifier|public
name|SolrException
name|getFirst
parameter_list|()
block|{
return|return
name|first
return|;
block|}
block|}
block|}
end_class
end_unit
