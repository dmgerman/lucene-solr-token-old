begin_unit
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_package
DECL|package|org.apache.solr.update
package|package
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|update
package|;
end_package
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|document
operator|.
name|Document
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|CodecReader
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|DirectoryReader
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|IndexWriter
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|LeafReaderContext
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|SlowCodecReaderWrapper
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|Term
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|queries
operator|.
name|function
operator|.
name|ValueSource
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|BooleanClause
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|BooleanClause
operator|.
name|Occur
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|BooleanQuery
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|MatchAllDocsQuery
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|Query
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|TermQuery
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|SolrException
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|params
operator|.
name|ModifiableSolrParams
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|util
operator|.
name|NamedList
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|util
operator|.
name|SimpleOrderedMap
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|core
operator|.
name|SolrConfig
operator|.
name|UpdateHandlerInfo
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|core
operator|.
name|SolrCore
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|request
operator|.
name|LocalSolrQueryRequest
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|request
operator|.
name|SolrQueryRequest
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|request
operator|.
name|SolrRequestInfo
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|response
operator|.
name|SolrQueryResponse
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|schema
operator|.
name|IndexSchema
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|schema
operator|.
name|SchemaField
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|search
operator|.
name|FunctionRangeQuery
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|search
operator|.
name|QParser
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|search
operator|.
name|QueryUtils
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|search
operator|.
name|SolrIndexSearcher
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|search
operator|.
name|SyntaxError
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|search
operator|.
name|function
operator|.
name|ValueSourceRangeFilter
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|util
operator|.
name|RefCounted
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URL
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Locale
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ExecutionException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Future
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicLong
import|;
end_import
begin_comment
comment|/**  *<code>DirectUpdateHandler2</code> implements an UpdateHandler where documents are added  * directly to the main Lucene index as opposed to adding to a separate smaller index.  *<p>  * TODO: add soft commitWithin support  */
end_comment
begin_class
DECL|class|DirectUpdateHandler2
specifier|public
class|class
name|DirectUpdateHandler2
extends|extends
name|UpdateHandler
implements|implements
name|SolrCoreState
operator|.
name|IndexWriterCloser
block|{
DECL|field|solrCoreState
specifier|protected
specifier|final
name|SolrCoreState
name|solrCoreState
decl_stmt|;
comment|// stats
DECL|field|addCommands
name|AtomicLong
name|addCommands
init|=
operator|new
name|AtomicLong
argument_list|()
decl_stmt|;
DECL|field|addCommandsCumulative
name|AtomicLong
name|addCommandsCumulative
init|=
operator|new
name|AtomicLong
argument_list|()
decl_stmt|;
DECL|field|deleteByIdCommands
name|AtomicLong
name|deleteByIdCommands
init|=
operator|new
name|AtomicLong
argument_list|()
decl_stmt|;
DECL|field|deleteByIdCommandsCumulative
name|AtomicLong
name|deleteByIdCommandsCumulative
init|=
operator|new
name|AtomicLong
argument_list|()
decl_stmt|;
DECL|field|deleteByQueryCommands
name|AtomicLong
name|deleteByQueryCommands
init|=
operator|new
name|AtomicLong
argument_list|()
decl_stmt|;
DECL|field|deleteByQueryCommandsCumulative
name|AtomicLong
name|deleteByQueryCommandsCumulative
init|=
operator|new
name|AtomicLong
argument_list|()
decl_stmt|;
DECL|field|expungeDeleteCommands
name|AtomicLong
name|expungeDeleteCommands
init|=
operator|new
name|AtomicLong
argument_list|()
decl_stmt|;
DECL|field|mergeIndexesCommands
name|AtomicLong
name|mergeIndexesCommands
init|=
operator|new
name|AtomicLong
argument_list|()
decl_stmt|;
DECL|field|commitCommands
name|AtomicLong
name|commitCommands
init|=
operator|new
name|AtomicLong
argument_list|()
decl_stmt|;
DECL|field|optimizeCommands
name|AtomicLong
name|optimizeCommands
init|=
operator|new
name|AtomicLong
argument_list|()
decl_stmt|;
DECL|field|rollbackCommands
name|AtomicLong
name|rollbackCommands
init|=
operator|new
name|AtomicLong
argument_list|()
decl_stmt|;
DECL|field|numDocsPending
name|AtomicLong
name|numDocsPending
init|=
operator|new
name|AtomicLong
argument_list|()
decl_stmt|;
DECL|field|numErrors
name|AtomicLong
name|numErrors
init|=
operator|new
name|AtomicLong
argument_list|()
decl_stmt|;
DECL|field|numErrorsCumulative
name|AtomicLong
name|numErrorsCumulative
init|=
operator|new
name|AtomicLong
argument_list|()
decl_stmt|;
comment|// tracks when auto-commit should occur
DECL|field|commitTracker
specifier|protected
specifier|final
name|CommitTracker
name|commitTracker
decl_stmt|;
DECL|field|softCommitTracker
specifier|protected
specifier|final
name|CommitTracker
name|softCommitTracker
decl_stmt|;
DECL|field|commitWithinSoftCommit
specifier|protected
name|boolean
name|commitWithinSoftCommit
decl_stmt|;
DECL|field|indexWriterCloseWaitsForMerges
specifier|protected
name|boolean
name|indexWriterCloseWaitsForMerges
decl_stmt|;
DECL|method|DirectUpdateHandler2
specifier|public
name|DirectUpdateHandler2
parameter_list|(
name|SolrCore
name|core
parameter_list|)
block|{
name|super
argument_list|(
name|core
argument_list|)
expr_stmt|;
name|solrCoreState
operator|=
name|core
operator|.
name|getSolrCoreState
argument_list|()
expr_stmt|;
name|UpdateHandlerInfo
name|updateHandlerInfo
init|=
name|core
operator|.
name|getSolrConfig
argument_list|()
operator|.
name|getUpdateHandlerInfo
argument_list|()
decl_stmt|;
name|int
name|docsUpperBound
init|=
name|updateHandlerInfo
operator|.
name|autoCommmitMaxDocs
decl_stmt|;
comment|// getInt("updateHandler/autoCommit/maxDocs", -1);
name|int
name|timeUpperBound
init|=
name|updateHandlerInfo
operator|.
name|autoCommmitMaxTime
decl_stmt|;
comment|// getInt("updateHandler/autoCommit/maxTime", -1);
name|commitTracker
operator|=
operator|new
name|CommitTracker
argument_list|(
literal|"Hard"
argument_list|,
name|core
argument_list|,
name|docsUpperBound
argument_list|,
name|timeUpperBound
argument_list|,
name|updateHandlerInfo
operator|.
name|openSearcher
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|int
name|softCommitDocsUpperBound
init|=
name|updateHandlerInfo
operator|.
name|autoSoftCommmitMaxDocs
decl_stmt|;
comment|// getInt("updateHandler/autoSoftCommit/maxDocs", -1);
name|int
name|softCommitTimeUpperBound
init|=
name|updateHandlerInfo
operator|.
name|autoSoftCommmitMaxTime
decl_stmt|;
comment|// getInt("updateHandler/autoSoftCommit/maxTime", -1);
name|softCommitTracker
operator|=
operator|new
name|CommitTracker
argument_list|(
literal|"Soft"
argument_list|,
name|core
argument_list|,
name|softCommitDocsUpperBound
argument_list|,
name|softCommitTimeUpperBound
argument_list|,
literal|true
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|commitWithinSoftCommit
operator|=
name|updateHandlerInfo
operator|.
name|commitWithinSoftCommit
expr_stmt|;
name|indexWriterCloseWaitsForMerges
operator|=
name|updateHandlerInfo
operator|.
name|indexWriterCloseWaitsForMerges
expr_stmt|;
block|}
DECL|method|DirectUpdateHandler2
specifier|public
name|DirectUpdateHandler2
parameter_list|(
name|SolrCore
name|core
parameter_list|,
name|UpdateHandler
name|updateHandler
parameter_list|)
block|{
name|super
argument_list|(
name|core
argument_list|,
name|updateHandler
operator|.
name|getUpdateLog
argument_list|()
argument_list|)
expr_stmt|;
name|solrCoreState
operator|=
name|core
operator|.
name|getSolrCoreState
argument_list|()
expr_stmt|;
name|UpdateHandlerInfo
name|updateHandlerInfo
init|=
name|core
operator|.
name|getSolrConfig
argument_list|()
operator|.
name|getUpdateHandlerInfo
argument_list|()
decl_stmt|;
name|int
name|docsUpperBound
init|=
name|updateHandlerInfo
operator|.
name|autoCommmitMaxDocs
decl_stmt|;
comment|// getInt("updateHandler/autoCommit/maxDocs", -1);
name|int
name|timeUpperBound
init|=
name|updateHandlerInfo
operator|.
name|autoCommmitMaxTime
decl_stmt|;
comment|// getInt("updateHandler/autoCommit/maxTime", -1);
name|commitTracker
operator|=
operator|new
name|CommitTracker
argument_list|(
literal|"Hard"
argument_list|,
name|core
argument_list|,
name|docsUpperBound
argument_list|,
name|timeUpperBound
argument_list|,
name|updateHandlerInfo
operator|.
name|openSearcher
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|int
name|softCommitDocsUpperBound
init|=
name|updateHandlerInfo
operator|.
name|autoSoftCommmitMaxDocs
decl_stmt|;
comment|// getInt("updateHandler/autoSoftCommit/maxDocs", -1);
name|int
name|softCommitTimeUpperBound
init|=
name|updateHandlerInfo
operator|.
name|autoSoftCommmitMaxTime
decl_stmt|;
comment|// getInt("updateHandler/autoSoftCommit/maxTime", -1);
name|softCommitTracker
operator|=
operator|new
name|CommitTracker
argument_list|(
literal|"Soft"
argument_list|,
name|core
argument_list|,
name|softCommitDocsUpperBound
argument_list|,
name|softCommitTimeUpperBound
argument_list|,
name|updateHandlerInfo
operator|.
name|openSearcher
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|commitWithinSoftCommit
operator|=
name|updateHandlerInfo
operator|.
name|commitWithinSoftCommit
expr_stmt|;
name|indexWriterCloseWaitsForMerges
operator|=
name|updateHandlerInfo
operator|.
name|indexWriterCloseWaitsForMerges
expr_stmt|;
name|UpdateLog
name|existingLog
init|=
name|updateHandler
operator|.
name|getUpdateLog
argument_list|()
decl_stmt|;
if|if
condition|(
name|this
operator|.
name|ulog
operator|!=
literal|null
operator|&&
name|this
operator|.
name|ulog
operator|==
name|existingLog
condition|)
block|{
comment|// If we are reusing the existing update log, inform the log that its update handler has changed.
comment|// We do this as late as possible.
name|this
operator|.
name|ulog
operator|.
name|init
argument_list|(
name|this
argument_list|,
name|core
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|deleteAll
specifier|private
name|void
name|deleteAll
parameter_list|()
throws|throws
name|IOException
block|{
name|SolrCore
operator|.
name|log
operator|.
name|info
argument_list|(
name|core
operator|.
name|getLogId
argument_list|()
operator|+
literal|"REMOVING ALL DOCUMENTS FROM INDEX"
argument_list|)
expr_stmt|;
name|RefCounted
argument_list|<
name|IndexWriter
argument_list|>
name|iw
init|=
name|solrCoreState
operator|.
name|getIndexWriter
argument_list|(
name|core
argument_list|)
decl_stmt|;
try|try
block|{
name|iw
operator|.
name|get
argument_list|()
operator|.
name|deleteAll
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|iw
operator|.
name|decref
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|rollbackWriter
specifier|protected
name|void
name|rollbackWriter
parameter_list|()
throws|throws
name|IOException
block|{
name|numDocsPending
operator|.
name|set
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|solrCoreState
operator|.
name|rollbackIndexWriter
argument_list|(
name|core
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|addDoc
specifier|public
name|int
name|addDoc
parameter_list|(
name|AddUpdateCommand
name|cmd
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
return|return
name|addDoc0
argument_list|(
name|cmd
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|SolrException
name|e
parameter_list|)
block|{
throw|throw
name|e
throw|;
block|}
catch|catch
parameter_list|(
name|RuntimeException
name|t
parameter_list|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|SolrException
operator|.
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
name|String
operator|.
name|format
argument_list|(
name|Locale
operator|.
name|ROOT
argument_list|,
literal|"Exception writing document id %s to the index; possible analysis error."
argument_list|,
name|cmd
operator|.
name|getPrintableId
argument_list|()
argument_list|)
argument_list|,
name|t
argument_list|)
throw|;
block|}
block|}
comment|/**    * This is the implementation of {@link #addDoc0(AddUpdateCommand)}. It is factored out to allow an exception    * handler to decorate RuntimeExceptions with information about the document being handled.    * @param cmd the command.    * @return the count.    */
DECL|method|addDoc0
specifier|private
name|int
name|addDoc0
parameter_list|(
name|AddUpdateCommand
name|cmd
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|rc
init|=
operator|-
literal|1
decl_stmt|;
name|RefCounted
argument_list|<
name|IndexWriter
argument_list|>
name|iw
init|=
name|solrCoreState
operator|.
name|getIndexWriter
argument_list|(
name|core
argument_list|)
decl_stmt|;
try|try
block|{
name|IndexWriter
name|writer
init|=
name|iw
operator|.
name|get
argument_list|()
decl_stmt|;
name|addCommands
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
name|addCommandsCumulative
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
comment|// if there is no ID field, don't overwrite
if|if
condition|(
name|idField
operator|==
literal|null
condition|)
block|{
name|cmd
operator|.
name|overwrite
operator|=
literal|false
expr_stmt|;
block|}
try|try
block|{
name|IndexSchema
name|schema
init|=
name|cmd
operator|.
name|getReq
argument_list|()
operator|.
name|getSchema
argument_list|()
decl_stmt|;
if|if
condition|(
name|cmd
operator|.
name|overwrite
condition|)
block|{
comment|// Check for delete by query commands newer (i.e. reordered). This
comment|// should always be null on a leader
name|List
argument_list|<
name|UpdateLog
operator|.
name|DBQ
argument_list|>
name|deletesAfter
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|ulog
operator|!=
literal|null
operator|&&
name|cmd
operator|.
name|version
operator|>
literal|0
condition|)
block|{
name|deletesAfter
operator|=
name|ulog
operator|.
name|getDBQNewer
argument_list|(
name|cmd
operator|.
name|version
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|deletesAfter
operator|!=
literal|null
condition|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"Reordered DBQs detected.  Update="
operator|+
name|cmd
operator|+
literal|" DBQs="
operator|+
name|deletesAfter
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|Query
argument_list|>
name|dbqList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|deletesAfter
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|UpdateLog
operator|.
name|DBQ
name|dbq
range|:
name|deletesAfter
control|)
block|{
try|try
block|{
name|DeleteUpdateCommand
name|tmpDel
init|=
operator|new
name|DeleteUpdateCommand
argument_list|(
name|cmd
operator|.
name|req
argument_list|)
decl_stmt|;
name|tmpDel
operator|.
name|query
operator|=
name|dbq
operator|.
name|q
expr_stmt|;
name|tmpDel
operator|.
name|version
operator|=
operator|-
name|dbq
operator|.
name|version
expr_stmt|;
name|dbqList
operator|.
name|add
argument_list|(
name|getQuery
argument_list|(
name|tmpDel
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"Exception parsing reordered query : "
operator|+
name|dbq
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
name|addAndDelete
argument_list|(
name|cmd
argument_list|,
name|dbqList
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// normal update
name|Term
name|updateTerm
decl_stmt|;
name|Term
name|idTerm
init|=
operator|new
name|Term
argument_list|(
name|cmd
operator|.
name|isBlock
argument_list|()
condition|?
literal|"_root_"
else|:
name|idField
operator|.
name|getName
argument_list|()
argument_list|,
name|cmd
operator|.
name|getIndexedId
argument_list|()
argument_list|)
decl_stmt|;
name|boolean
name|del
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|cmd
operator|.
name|updateTerm
operator|==
literal|null
condition|)
block|{
name|updateTerm
operator|=
name|idTerm
expr_stmt|;
block|}
else|else
block|{
comment|// this is only used by the dedup update processor
name|del
operator|=
literal|true
expr_stmt|;
name|updateTerm
operator|=
name|cmd
operator|.
name|updateTerm
expr_stmt|;
block|}
if|if
condition|(
name|cmd
operator|.
name|isBlock
argument_list|()
condition|)
block|{
name|writer
operator|.
name|updateDocuments
argument_list|(
name|updateTerm
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Document
name|luceneDocument
init|=
name|cmd
operator|.
name|getLuceneDocument
argument_list|()
decl_stmt|;
comment|// SolrCore.verbose("updateDocument",updateTerm,luceneDocument,writer);
name|writer
operator|.
name|updateDocument
argument_list|(
name|updateTerm
argument_list|,
name|luceneDocument
argument_list|)
expr_stmt|;
block|}
comment|// SolrCore.verbose("updateDocument",updateTerm,"DONE");
if|if
condition|(
name|del
condition|)
block|{
comment|// ensure id remains unique
name|BooleanQuery
name|bq
init|=
operator|new
name|BooleanQuery
argument_list|()
decl_stmt|;
name|bq
operator|.
name|add
argument_list|(
operator|new
name|BooleanClause
argument_list|(
operator|new
name|TermQuery
argument_list|(
name|updateTerm
argument_list|)
argument_list|,
name|Occur
operator|.
name|MUST_NOT
argument_list|)
argument_list|)
expr_stmt|;
name|bq
operator|.
name|add
argument_list|(
operator|new
name|BooleanClause
argument_list|(
operator|new
name|TermQuery
argument_list|(
name|idTerm
argument_list|)
argument_list|,
name|Occur
operator|.
name|MUST
argument_list|)
argument_list|)
expr_stmt|;
name|writer
operator|.
name|deleteDocuments
argument_list|(
operator|new
name|DeleteByQueryWrapper
argument_list|(
name|bq
argument_list|,
name|core
operator|.
name|getLatestSchema
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// Add to the transaction log *after* successfully adding to the
comment|// index, if there was no error.
comment|// This ordering ensures that if we log it, it's definitely been
comment|// added to the the index.
comment|// This also ensures that if a commit sneaks in-between, that we
comment|// know everything in a particular
comment|// log version was definitely committed.
if|if
condition|(
name|ulog
operator|!=
literal|null
condition|)
name|ulog
operator|.
name|add
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// allow duplicates
if|if
condition|(
name|cmd
operator|.
name|isBlock
argument_list|()
condition|)
block|{
name|writer
operator|.
name|addDocuments
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|writer
operator|.
name|addDocument
argument_list|(
name|cmd
operator|.
name|getLuceneDocument
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ulog
operator|!=
literal|null
condition|)
name|ulog
operator|.
name|add
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|cmd
operator|.
name|getFlags
argument_list|()
operator|&
name|UpdateCommand
operator|.
name|IGNORE_AUTOCOMMIT
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|commitWithinSoftCommit
condition|)
block|{
name|commitTracker
operator|.
name|addedDocument
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
name|softCommitTracker
operator|.
name|addedDocument
argument_list|(
name|cmd
operator|.
name|commitWithin
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|softCommitTracker
operator|.
name|addedDocument
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
name|commitTracker
operator|.
name|addedDocument
argument_list|(
name|cmd
operator|.
name|commitWithin
argument_list|)
expr_stmt|;
block|}
block|}
name|rc
operator|=
literal|1
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
name|rc
operator|!=
literal|1
condition|)
block|{
name|numErrors
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
name|numErrorsCumulative
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|numDocsPending
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
block|}
block|}
block|}
finally|finally
block|{
name|iw
operator|.
name|decref
argument_list|()
expr_stmt|;
block|}
return|return
name|rc
return|;
block|}
DECL|method|updateDeleteTrackers
specifier|private
name|void
name|updateDeleteTrackers
parameter_list|(
name|DeleteUpdateCommand
name|cmd
parameter_list|)
block|{
if|if
condition|(
operator|(
name|cmd
operator|.
name|getFlags
argument_list|()
operator|&
name|UpdateCommand
operator|.
name|IGNORE_AUTOCOMMIT
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|commitWithinSoftCommit
condition|)
block|{
name|softCommitTracker
operator|.
name|deletedDocument
argument_list|(
name|cmd
operator|.
name|commitWithin
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|commitTracker
operator|.
name|deletedDocument
argument_list|(
name|cmd
operator|.
name|commitWithin
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|commitTracker
operator|.
name|getTimeUpperBound
argument_list|()
operator|>
literal|0
condition|)
block|{
name|commitTracker
operator|.
name|scheduleCommitWithin
argument_list|(
name|commitTracker
operator|.
name|getTimeUpperBound
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|softCommitTracker
operator|.
name|getTimeUpperBound
argument_list|()
operator|>
literal|0
condition|)
block|{
name|softCommitTracker
operator|.
name|scheduleCommitWithin
argument_list|(
name|softCommitTracker
operator|.
name|getTimeUpperBound
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// we don't return the number of docs deleted because it's not always possible to quickly know that info.
annotation|@
name|Override
DECL|method|delete
specifier|public
name|void
name|delete
parameter_list|(
name|DeleteUpdateCommand
name|cmd
parameter_list|)
throws|throws
name|IOException
block|{
name|deleteByIdCommands
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
name|deleteByIdCommandsCumulative
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
name|Term
name|deleteTerm
init|=
operator|new
name|Term
argument_list|(
name|idField
operator|.
name|getName
argument_list|()
argument_list|,
name|cmd
operator|.
name|getIndexedId
argument_list|()
argument_list|)
decl_stmt|;
comment|// SolrCore.verbose("deleteDocuments",deleteTerm,writer);
name|RefCounted
argument_list|<
name|IndexWriter
argument_list|>
name|iw
init|=
name|solrCoreState
operator|.
name|getIndexWriter
argument_list|(
name|core
argument_list|)
decl_stmt|;
try|try
block|{
name|iw
operator|.
name|get
argument_list|()
operator|.
name|deleteDocuments
argument_list|(
name|deleteTerm
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|iw
operator|.
name|decref
argument_list|()
expr_stmt|;
block|}
comment|// SolrCore.verbose("deleteDocuments",deleteTerm,"DONE");
if|if
condition|(
name|ulog
operator|!=
literal|null
condition|)
name|ulog
operator|.
name|delete
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
name|updateDeleteTrackers
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
block|}
DECL|method|clearIndex
specifier|public
name|void
name|clearIndex
parameter_list|()
throws|throws
name|IOException
block|{
name|deleteAll
argument_list|()
expr_stmt|;
if|if
condition|(
name|ulog
operator|!=
literal|null
condition|)
block|{
name|ulog
operator|.
name|deleteAll
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|getQuery
specifier|private
name|Query
name|getQuery
parameter_list|(
name|DeleteUpdateCommand
name|cmd
parameter_list|)
block|{
name|Query
name|q
decl_stmt|;
try|try
block|{
comment|// move this higher in the stack?
name|QParser
name|parser
init|=
name|QParser
operator|.
name|getParser
argument_list|(
name|cmd
operator|.
name|getQuery
argument_list|()
argument_list|,
literal|"lucene"
argument_list|,
name|cmd
operator|.
name|req
argument_list|)
decl_stmt|;
name|q
operator|=
name|parser
operator|.
name|getQuery
argument_list|()
expr_stmt|;
name|q
operator|=
name|QueryUtils
operator|.
name|makeQueryable
argument_list|(
name|q
argument_list|)
expr_stmt|;
comment|// Make sure not to delete newer versions
if|if
condition|(
name|ulog
operator|!=
literal|null
operator|&&
name|cmd
operator|.
name|getVersion
argument_list|()
operator|!=
literal|0
operator|&&
name|cmd
operator|.
name|getVersion
argument_list|()
operator|!=
operator|-
name|Long
operator|.
name|MAX_VALUE
condition|)
block|{
name|BooleanQuery
name|bq
init|=
operator|new
name|BooleanQuery
argument_list|()
decl_stmt|;
name|bq
operator|.
name|add
argument_list|(
name|q
argument_list|,
name|Occur
operator|.
name|MUST
argument_list|)
expr_stmt|;
name|SchemaField
name|sf
init|=
name|ulog
operator|.
name|getVersionInfo
argument_list|()
operator|.
name|getVersionField
argument_list|()
decl_stmt|;
name|ValueSource
name|vs
init|=
name|sf
operator|.
name|getType
argument_list|()
operator|.
name|getValueSource
argument_list|(
name|sf
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|ValueSourceRangeFilter
name|filt
init|=
operator|new
name|ValueSourceRangeFilter
argument_list|(
name|vs
argument_list|,
literal|null
argument_list|,
name|Long
operator|.
name|toString
argument_list|(
name|Math
operator|.
name|abs
argument_list|(
name|cmd
operator|.
name|getVersion
argument_list|()
argument_list|)
argument_list|)
argument_list|,
literal|true
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|FunctionRangeQuery
name|range
init|=
operator|new
name|FunctionRangeQuery
argument_list|(
name|filt
argument_list|)
decl_stmt|;
name|bq
operator|.
name|add
argument_list|(
name|range
argument_list|,
name|Occur
operator|.
name|MUST
argument_list|)
expr_stmt|;
name|q
operator|=
name|bq
expr_stmt|;
block|}
return|return
name|q
return|;
block|}
catch|catch
parameter_list|(
name|SyntaxError
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|SolrException
operator|.
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
comment|// we don't return the number of docs deleted because it's not always possible to quickly know that info.
annotation|@
name|Override
DECL|method|deleteByQuery
specifier|public
name|void
name|deleteByQuery
parameter_list|(
name|DeleteUpdateCommand
name|cmd
parameter_list|)
throws|throws
name|IOException
block|{
name|deleteByQueryCommands
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
name|deleteByQueryCommandsCumulative
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
name|boolean
name|madeIt
init|=
literal|false
decl_stmt|;
try|try
block|{
name|Query
name|q
init|=
name|getQuery
argument_list|(
name|cmd
argument_list|)
decl_stmt|;
name|boolean
name|delAll
init|=
name|MatchAllDocsQuery
operator|.
name|class
operator|==
name|q
operator|.
name|getClass
argument_list|()
decl_stmt|;
comment|// currently for testing purposes.  Do a delete of complete index w/o worrying about versions, don't log, clean up most state in update log, etc
if|if
condition|(
name|delAll
operator|&&
name|cmd
operator|.
name|getVersion
argument_list|()
operator|==
operator|-
name|Long
operator|.
name|MAX_VALUE
condition|)
block|{
synchronized|synchronized
init|(
name|solrCoreState
operator|.
name|getUpdateLock
argument_list|()
init|)
block|{
name|deleteAll
argument_list|()
expr_stmt|;
name|ulog
operator|.
name|deleteAll
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
comment|//
comment|// synchronized to prevent deleteByQuery from running during the "open new searcher"
comment|// part of a commit.  DBQ needs to signal that a fresh reader will be needed for
comment|// a realtime view of the index.  When a new searcher is opened after a DBQ, that
comment|// flag can be cleared.  If those thing happen concurrently, it's not thread safe.
comment|//
synchronized|synchronized
init|(
name|solrCoreState
operator|.
name|getUpdateLock
argument_list|()
init|)
block|{
if|if
condition|(
name|delAll
condition|)
block|{
name|deleteAll
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|RefCounted
argument_list|<
name|IndexWriter
argument_list|>
name|iw
init|=
name|solrCoreState
operator|.
name|getIndexWriter
argument_list|(
name|core
argument_list|)
decl_stmt|;
try|try
block|{
name|iw
operator|.
name|get
argument_list|()
operator|.
name|deleteDocuments
argument_list|(
operator|new
name|DeleteByQueryWrapper
argument_list|(
name|q
argument_list|,
name|core
operator|.
name|getLatestSchema
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|iw
operator|.
name|decref
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ulog
operator|!=
literal|null
condition|)
name|ulog
operator|.
name|deleteByQuery
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
block|}
name|madeIt
operator|=
literal|true
expr_stmt|;
name|updateDeleteTrackers
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
operator|!
name|madeIt
condition|)
block|{
name|numErrors
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
name|numErrorsCumulative
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/** Add a document execute the deletes as atomically as possible */
DECL|method|addAndDelete
specifier|private
name|void
name|addAndDelete
parameter_list|(
name|AddUpdateCommand
name|cmd
parameter_list|,
name|List
argument_list|<
name|Query
argument_list|>
name|dbqList
parameter_list|)
throws|throws
name|IOException
block|{
name|Document
name|luceneDocument
init|=
name|cmd
operator|.
name|getLuceneDocument
argument_list|()
decl_stmt|;
name|Term
name|idTerm
init|=
operator|new
name|Term
argument_list|(
name|idField
operator|.
name|getName
argument_list|()
argument_list|,
name|cmd
operator|.
name|getIndexedId
argument_list|()
argument_list|)
decl_stmt|;
comment|// see comment in deleteByQuery
synchronized|synchronized
init|(
name|solrCoreState
operator|.
name|getUpdateLock
argument_list|()
init|)
block|{
name|RefCounted
argument_list|<
name|IndexWriter
argument_list|>
name|iw
init|=
name|solrCoreState
operator|.
name|getIndexWriter
argument_list|(
name|core
argument_list|)
decl_stmt|;
try|try
block|{
name|IndexWriter
name|writer
init|=
name|iw
operator|.
name|get
argument_list|()
decl_stmt|;
name|writer
operator|.
name|updateDocument
argument_list|(
name|idTerm
argument_list|,
name|luceneDocument
argument_list|)
expr_stmt|;
for|for
control|(
name|Query
name|q
range|:
name|dbqList
control|)
block|{
name|writer
operator|.
name|deleteDocuments
argument_list|(
operator|new
name|DeleteByQueryWrapper
argument_list|(
name|q
argument_list|,
name|core
operator|.
name|getLatestSchema
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|iw
operator|.
name|decref
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|ulog
operator|!=
literal|null
condition|)
name|ulog
operator|.
name|add
argument_list|(
name|cmd
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|mergeIndexes
specifier|public
name|int
name|mergeIndexes
parameter_list|(
name|MergeIndexesCommand
name|cmd
parameter_list|)
throws|throws
name|IOException
block|{
name|mergeIndexesCommands
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
name|int
name|rc
decl_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"start "
operator|+
name|cmd
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|DirectoryReader
argument_list|>
name|readers
init|=
name|cmd
operator|.
name|readers
decl_stmt|;
if|if
condition|(
name|readers
operator|!=
literal|null
operator|&&
name|readers
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|List
argument_list|<
name|CodecReader
argument_list|>
name|mergeReaders
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|DirectoryReader
name|reader
range|:
name|readers
control|)
block|{
for|for
control|(
name|LeafReaderContext
name|leaf
range|:
name|reader
operator|.
name|leaves
argument_list|()
control|)
block|{
name|mergeReaders
operator|.
name|add
argument_list|(
name|SlowCodecReaderWrapper
operator|.
name|wrap
argument_list|(
name|leaf
operator|.
name|reader
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|RefCounted
argument_list|<
name|IndexWriter
argument_list|>
name|iw
init|=
name|solrCoreState
operator|.
name|getIndexWriter
argument_list|(
name|core
argument_list|)
decl_stmt|;
try|try
block|{
name|iw
operator|.
name|get
argument_list|()
operator|.
name|addIndexes
argument_list|(
name|mergeReaders
operator|.
name|toArray
argument_list|(
operator|new
name|CodecReader
index|[
name|mergeReaders
operator|.
name|size
argument_list|()
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|iw
operator|.
name|decref
argument_list|()
expr_stmt|;
block|}
name|rc
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|rc
operator|=
literal|0
expr_stmt|;
block|}
name|log
operator|.
name|info
argument_list|(
literal|"end_mergeIndexes"
argument_list|)
expr_stmt|;
comment|// TODO: consider soft commit issues
if|if
condition|(
name|rc
operator|==
literal|1
operator|&&
name|commitTracker
operator|.
name|getTimeUpperBound
argument_list|()
operator|>
literal|0
condition|)
block|{
name|commitTracker
operator|.
name|scheduleCommitWithin
argument_list|(
name|commitTracker
operator|.
name|getTimeUpperBound
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rc
operator|==
literal|1
operator|&&
name|softCommitTracker
operator|.
name|getTimeUpperBound
argument_list|()
operator|>
literal|0
condition|)
block|{
name|softCommitTracker
operator|.
name|scheduleCommitWithin
argument_list|(
name|softCommitTracker
operator|.
name|getTimeUpperBound
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|rc
return|;
block|}
DECL|method|prepareCommit
specifier|public
name|void
name|prepareCommit
parameter_list|(
name|CommitUpdateCommand
name|cmd
parameter_list|)
throws|throws
name|IOException
block|{
name|boolean
name|error
init|=
literal|true
decl_stmt|;
try|try
block|{
name|log
operator|.
name|info
argument_list|(
literal|"start "
operator|+
name|cmd
argument_list|)
expr_stmt|;
name|RefCounted
argument_list|<
name|IndexWriter
argument_list|>
name|iw
init|=
name|solrCoreState
operator|.
name|getIndexWriter
argument_list|(
name|core
argument_list|)
decl_stmt|;
try|try
block|{
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|commitData
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|commitData
operator|.
name|put
argument_list|(
name|SolrIndexWriter
operator|.
name|COMMIT_TIME_MSEC_KEY
argument_list|,
name|String
operator|.
name|valueOf
argument_list|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|iw
operator|.
name|get
argument_list|()
operator|.
name|setCommitData
argument_list|(
name|commitData
argument_list|)
expr_stmt|;
name|iw
operator|.
name|get
argument_list|()
operator|.
name|prepareCommit
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|iw
operator|.
name|decref
argument_list|()
expr_stmt|;
block|}
name|log
operator|.
name|info
argument_list|(
literal|"end_prepareCommit"
argument_list|)
expr_stmt|;
name|error
operator|=
literal|false
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
name|error
condition|)
name|numErrors
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|commit
specifier|public
name|void
name|commit
parameter_list|(
name|CommitUpdateCommand
name|cmd
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|cmd
operator|.
name|prepareCommit
condition|)
block|{
name|prepareCommit
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|cmd
operator|.
name|optimize
condition|)
block|{
name|optimizeCommands
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|commitCommands
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
if|if
condition|(
name|cmd
operator|.
name|expungeDeletes
condition|)
name|expungeDeleteCommands
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
block|}
name|Future
index|[]
name|waitSearcher
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|cmd
operator|.
name|waitSearcher
condition|)
block|{
name|waitSearcher
operator|=
operator|new
name|Future
index|[
literal|1
index|]
expr_stmt|;
block|}
name|boolean
name|error
init|=
literal|true
decl_stmt|;
try|try
block|{
comment|// only allow one hard commit to proceed at once
if|if
condition|(
operator|!
name|cmd
operator|.
name|softCommit
condition|)
block|{
name|solrCoreState
operator|.
name|getCommitLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
block|}
name|log
operator|.
name|info
argument_list|(
literal|"start "
operator|+
name|cmd
argument_list|)
expr_stmt|;
comment|// We must cancel pending commits *before* we actually execute the commit.
if|if
condition|(
name|cmd
operator|.
name|openSearcher
condition|)
block|{
comment|// we can cancel any pending soft commits if this commit will open a new searcher
name|softCommitTracker
operator|.
name|cancelPendingCommit
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|cmd
operator|.
name|softCommit
operator|&&
operator|(
name|cmd
operator|.
name|openSearcher
operator|||
operator|!
name|commitTracker
operator|.
name|getOpenSearcher
argument_list|()
operator|)
condition|)
block|{
comment|// cancel a pending hard commit if this commit is of equal or greater "strength"...
comment|// If the autoCommit has openSearcher=true, then this commit must have openSearcher=true
comment|// to cancel.
name|commitTracker
operator|.
name|cancelPendingCommit
argument_list|()
expr_stmt|;
block|}
name|RefCounted
argument_list|<
name|IndexWriter
argument_list|>
name|iw
init|=
name|solrCoreState
operator|.
name|getIndexWriter
argument_list|(
name|core
argument_list|)
decl_stmt|;
try|try
block|{
name|IndexWriter
name|writer
init|=
name|iw
operator|.
name|get
argument_list|()
decl_stmt|;
if|if
condition|(
name|cmd
operator|.
name|optimize
condition|)
block|{
name|writer
operator|.
name|forceMerge
argument_list|(
name|cmd
operator|.
name|maxOptimizeSegments
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cmd
operator|.
name|expungeDeletes
condition|)
block|{
name|writer
operator|.
name|forceMergeDeletes
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|cmd
operator|.
name|softCommit
condition|)
block|{
synchronized|synchronized
init|(
name|solrCoreState
operator|.
name|getUpdateLock
argument_list|()
init|)
block|{
comment|// sync is currently needed to prevent preCommit
comment|// from being called between preSoft and
comment|// postSoft... see postSoft comments.
if|if
condition|(
name|ulog
operator|!=
literal|null
condition|)
name|ulog
operator|.
name|preCommit
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
block|}
comment|// SolrCore.verbose("writer.commit() start writer=",writer);
if|if
condition|(
name|writer
operator|.
name|hasUncommittedChanges
argument_list|()
condition|)
block|{
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|commitData
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|commitData
operator|.
name|put
argument_list|(
name|SolrIndexWriter
operator|.
name|COMMIT_TIME_MSEC_KEY
argument_list|,
name|String
operator|.
name|valueOf
argument_list|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|writer
operator|.
name|setCommitData
argument_list|(
name|commitData
argument_list|)
expr_stmt|;
name|writer
operator|.
name|commit
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|log
operator|.
name|info
argument_list|(
literal|"No uncommitted changes. Skipping IW.commit."
argument_list|)
expr_stmt|;
block|}
comment|// SolrCore.verbose("writer.commit() end");
name|numDocsPending
operator|.
name|set
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|callPostCommitCallbacks
argument_list|()
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|iw
operator|.
name|decref
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|cmd
operator|.
name|optimize
condition|)
block|{
name|callPostOptimizeCallbacks
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|cmd
operator|.
name|softCommit
condition|)
block|{
comment|// ulog.preSoftCommit();
synchronized|synchronized
init|(
name|solrCoreState
operator|.
name|getUpdateLock
argument_list|()
init|)
block|{
if|if
condition|(
name|ulog
operator|!=
literal|null
condition|)
name|ulog
operator|.
name|preSoftCommit
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
name|core
operator|.
name|getSearcher
argument_list|(
literal|true
argument_list|,
literal|false
argument_list|,
name|waitSearcher
argument_list|,
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|ulog
operator|!=
literal|null
condition|)
name|ulog
operator|.
name|postSoftCommit
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
block|}
name|callPostSoftCommitCallbacks
argument_list|()
expr_stmt|;
block|}
else|else
block|{
synchronized|synchronized
init|(
name|solrCoreState
operator|.
name|getUpdateLock
argument_list|()
init|)
block|{
if|if
condition|(
name|ulog
operator|!=
literal|null
condition|)
name|ulog
operator|.
name|preSoftCommit
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|.
name|openSearcher
condition|)
block|{
name|core
operator|.
name|getSearcher
argument_list|(
literal|true
argument_list|,
literal|false
argument_list|,
name|waitSearcher
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// force open a new realtime searcher so realtime-get and versioning code can see the latest
name|RefCounted
argument_list|<
name|SolrIndexSearcher
argument_list|>
name|searchHolder
init|=
name|core
operator|.
name|openNewSearcher
argument_list|(
literal|true
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|searchHolder
operator|.
name|decref
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|ulog
operator|!=
literal|null
condition|)
name|ulog
operator|.
name|postSoftCommit
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ulog
operator|!=
literal|null
condition|)
name|ulog
operator|.
name|postCommit
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
comment|// postCommit currently means new searcher has
comment|// also been opened
block|}
comment|// reset commit tracking
if|if
condition|(
name|cmd
operator|.
name|softCommit
condition|)
block|{
name|softCommitTracker
operator|.
name|didCommit
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|commitTracker
operator|.
name|didCommit
argument_list|()
expr_stmt|;
block|}
name|log
operator|.
name|info
argument_list|(
literal|"end_commit_flush"
argument_list|)
expr_stmt|;
name|error
operator|=
literal|false
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
operator|!
name|cmd
operator|.
name|softCommit
condition|)
block|{
name|solrCoreState
operator|.
name|getCommitLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
name|addCommands
operator|.
name|set
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|deleteByIdCommands
operator|.
name|set
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|deleteByQueryCommands
operator|.
name|set
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|numErrors
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
block|}
comment|// if we are supposed to wait for the searcher to be registered, then we should do it
comment|// outside any synchronized block so that other update operations can proceed.
if|if
condition|(
name|waitSearcher
operator|!=
literal|null
operator|&&
name|waitSearcher
index|[
literal|0
index|]
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|waitSearcher
index|[
literal|0
index|]
operator|.
name|get
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
decl||
name|ExecutionException
name|e
parameter_list|)
block|{
name|SolrException
operator|.
name|log
argument_list|(
name|log
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|Override
DECL|method|newIndexWriter
specifier|public
name|void
name|newIndexWriter
parameter_list|(
name|boolean
name|rollback
parameter_list|)
throws|throws
name|IOException
block|{
name|solrCoreState
operator|.
name|newIndexWriter
argument_list|(
name|core
argument_list|,
name|rollback
argument_list|)
expr_stmt|;
block|}
comment|/**    * @since Solr 1.4    */
annotation|@
name|Override
DECL|method|rollback
specifier|public
name|void
name|rollback
parameter_list|(
name|RollbackUpdateCommand
name|cmd
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|core
operator|.
name|getCoreDescriptor
argument_list|()
operator|.
name|getCoreContainer
argument_list|()
operator|.
name|isZooKeeperAware
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"Rollback is currently not supported in SolrCloud mode. (SOLR-4895)"
argument_list|)
throw|;
block|}
name|rollbackCommands
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
name|boolean
name|error
init|=
literal|true
decl_stmt|;
try|try
block|{
name|log
operator|.
name|info
argument_list|(
literal|"start "
operator|+
name|cmd
argument_list|)
expr_stmt|;
name|rollbackWriter
argument_list|()
expr_stmt|;
comment|//callPostRollbackCallbacks();
comment|// reset commit tracking
name|commitTracker
operator|.
name|didRollback
argument_list|()
expr_stmt|;
name|softCommitTracker
operator|.
name|didRollback
argument_list|()
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"end_rollback"
argument_list|)
expr_stmt|;
name|error
operator|=
literal|false
expr_stmt|;
block|}
finally|finally
block|{
name|addCommandsCumulative
operator|.
name|set
argument_list|(
name|addCommandsCumulative
operator|.
name|get
argument_list|()
operator|-
name|addCommands
operator|.
name|getAndSet
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|deleteByIdCommandsCumulative
operator|.
name|set
argument_list|(
name|deleteByIdCommandsCumulative
operator|.
name|get
argument_list|()
operator|-
name|deleteByIdCommands
operator|.
name|getAndSet
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|deleteByQueryCommandsCumulative
operator|.
name|set
argument_list|(
name|deleteByQueryCommandsCumulative
operator|.
name|get
argument_list|()
operator|-
name|deleteByQueryCommands
operator|.
name|getAndSet
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|numErrors
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|getUpdateLog
specifier|public
name|UpdateLog
name|getUpdateLog
parameter_list|()
block|{
return|return
name|ulog
return|;
block|}
annotation|@
name|Override
DECL|method|close
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
name|log
operator|.
name|info
argument_list|(
literal|"closing "
operator|+
name|this
argument_list|)
expr_stmt|;
name|commitTracker
operator|.
name|close
argument_list|()
expr_stmt|;
name|softCommitTracker
operator|.
name|close
argument_list|()
expr_stmt|;
name|numDocsPending
operator|.
name|set
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
DECL|field|commitOnClose
specifier|public
specifier|static
name|boolean
name|commitOnClose
init|=
literal|true
decl_stmt|;
comment|// TODO: make this a real config option?
comment|// IndexWriterCloser interface method - called from solrCoreState.decref(this)
annotation|@
name|Override
DECL|method|closeWriter
specifier|public
name|void
name|closeWriter
parameter_list|(
name|IndexWriter
name|writer
parameter_list|)
throws|throws
name|IOException
block|{
name|boolean
name|clearRequestInfo
init|=
literal|false
decl_stmt|;
name|solrCoreState
operator|.
name|getCommitLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|SolrQueryRequest
name|req
init|=
operator|new
name|LocalSolrQueryRequest
argument_list|(
name|core
argument_list|,
operator|new
name|ModifiableSolrParams
argument_list|()
argument_list|)
decl_stmt|;
name|SolrQueryResponse
name|rsp
init|=
operator|new
name|SolrQueryResponse
argument_list|()
decl_stmt|;
if|if
condition|(
name|SolrRequestInfo
operator|.
name|getRequestInfo
argument_list|()
operator|==
literal|null
condition|)
block|{
name|clearRequestInfo
operator|=
literal|true
expr_stmt|;
name|SolrRequestInfo
operator|.
name|setRequestInfo
argument_list|(
operator|new
name|SolrRequestInfo
argument_list|(
name|req
argument_list|,
name|rsp
argument_list|)
argument_list|)
expr_stmt|;
comment|// important for debugging
block|}
if|if
condition|(
operator|!
name|commitOnClose
condition|)
block|{
if|if
condition|(
name|writer
operator|!=
literal|null
condition|)
block|{
name|writer
operator|.
name|rollback
argument_list|()
expr_stmt|;
block|}
comment|// we shouldn't close the transaction logs either, but leaving them open
comment|// means we can't delete them on windows (needed for tests)
if|if
condition|(
name|ulog
operator|!=
literal|null
condition|)
name|ulog
operator|.
name|close
argument_list|(
literal|false
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// do a commit before we quit?
name|boolean
name|tryToCommit
init|=
name|writer
operator|!=
literal|null
operator|&&
name|ulog
operator|!=
literal|null
operator|&&
name|ulog
operator|.
name|hasUncommittedChanges
argument_list|()
operator|&&
name|ulog
operator|.
name|getState
argument_list|()
operator|==
name|UpdateLog
operator|.
name|State
operator|.
name|ACTIVE
decl_stmt|;
try|try
block|{
if|if
condition|(
name|tryToCommit
condition|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"Committing on IndexWriter close."
argument_list|)
expr_stmt|;
name|CommitUpdateCommand
name|cmd
init|=
operator|new
name|CommitUpdateCommand
argument_list|(
name|req
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|cmd
operator|.
name|openSearcher
operator|=
literal|false
expr_stmt|;
name|cmd
operator|.
name|waitSearcher
operator|=
literal|false
expr_stmt|;
name|cmd
operator|.
name|softCommit
operator|=
literal|false
expr_stmt|;
comment|// TODO: keep other commit callbacks from being called?
comment|//  this.commit(cmd);        // too many test failures using this method... is it because of callbacks?
synchronized|synchronized
init|(
name|solrCoreState
operator|.
name|getUpdateLock
argument_list|()
init|)
block|{
name|ulog
operator|.
name|preCommit
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
block|}
comment|// todo: refactor this shared code (or figure out why a real CommitUpdateCommand can't be used)
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|commitData
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|commitData
operator|.
name|put
argument_list|(
name|SolrIndexWriter
operator|.
name|COMMIT_TIME_MSEC_KEY
argument_list|,
name|String
operator|.
name|valueOf
argument_list|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|writer
operator|.
name|setCommitData
argument_list|(
name|commitData
argument_list|)
expr_stmt|;
name|writer
operator|.
name|commit
argument_list|()
expr_stmt|;
synchronized|synchronized
init|(
name|solrCoreState
operator|.
name|getUpdateLock
argument_list|()
init|)
block|{
name|ulog
operator|.
name|postCommit
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|Throwable
name|th
parameter_list|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"Error in final commit"
argument_list|,
name|th
argument_list|)
expr_stmt|;
if|if
condition|(
name|th
operator|instanceof
name|OutOfMemoryError
condition|)
block|{
throw|throw
operator|(
name|OutOfMemoryError
operator|)
name|th
throw|;
block|}
block|}
comment|// we went through the normal process to commit, so we don't have to artificially
comment|// cap any ulog files.
try|try
block|{
if|if
condition|(
name|ulog
operator|!=
literal|null
condition|)
name|ulog
operator|.
name|close
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|th
parameter_list|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"Error closing log files"
argument_list|,
name|th
argument_list|)
expr_stmt|;
if|if
condition|(
name|th
operator|instanceof
name|OutOfMemoryError
condition|)
block|{
throw|throw
operator|(
name|OutOfMemoryError
operator|)
name|th
throw|;
block|}
block|}
if|if
condition|(
name|writer
operator|!=
literal|null
condition|)
block|{
name|writer
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|solrCoreState
operator|.
name|getCommitLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
if|if
condition|(
name|clearRequestInfo
condition|)
name|SolrRequestInfo
operator|.
name|clearRequestInfo
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|split
specifier|public
name|void
name|split
parameter_list|(
name|SplitIndexCommand
name|cmd
parameter_list|)
throws|throws
name|IOException
block|{
name|commit
argument_list|(
operator|new
name|CommitUpdateCommand
argument_list|(
name|cmd
operator|.
name|req
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|SolrIndexSplitter
name|splitter
init|=
operator|new
name|SolrIndexSplitter
argument_list|(
name|cmd
argument_list|)
decl_stmt|;
name|splitter
operator|.
name|split
argument_list|()
expr_stmt|;
block|}
comment|/////////////////////////////////////////////////////////////////////
comment|// SolrInfoMBean stuff: Statistics and Module Info
comment|/////////////////////////////////////////////////////////////////////
annotation|@
name|Override
DECL|method|getName
specifier|public
name|String
name|getName
parameter_list|()
block|{
return|return
name|DirectUpdateHandler2
operator|.
name|class
operator|.
name|getName
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|getVersion
specifier|public
name|String
name|getVersion
parameter_list|()
block|{
return|return
name|SolrCore
operator|.
name|version
return|;
block|}
annotation|@
name|Override
DECL|method|getDescription
specifier|public
name|String
name|getDescription
parameter_list|()
block|{
return|return
literal|"Update handler that efficiently directly updates the on-disk main lucene index"
return|;
block|}
annotation|@
name|Override
DECL|method|getCategory
specifier|public
name|Category
name|getCategory
parameter_list|()
block|{
return|return
name|Category
operator|.
name|UPDATEHANDLER
return|;
block|}
annotation|@
name|Override
DECL|method|getSource
specifier|public
name|String
name|getSource
parameter_list|()
block|{
return|return
literal|null
return|;
block|}
annotation|@
name|Override
DECL|method|getDocs
specifier|public
name|URL
index|[]
name|getDocs
parameter_list|()
block|{
return|return
literal|null
return|;
block|}
annotation|@
name|Override
DECL|method|getStatistics
specifier|public
name|NamedList
name|getStatistics
parameter_list|()
block|{
name|NamedList
name|lst
init|=
operator|new
name|SimpleOrderedMap
argument_list|()
decl_stmt|;
name|lst
operator|.
name|add
argument_list|(
literal|"commits"
argument_list|,
name|commitCommands
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|commitTracker
operator|.
name|getDocsUpperBound
argument_list|()
operator|>
literal|0
condition|)
block|{
name|lst
operator|.
name|add
argument_list|(
literal|"autocommit maxDocs"
argument_list|,
name|commitTracker
operator|.
name|getDocsUpperBound
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|commitTracker
operator|.
name|getTimeUpperBound
argument_list|()
operator|>
literal|0
condition|)
block|{
name|lst
operator|.
name|add
argument_list|(
literal|"autocommit maxTime"
argument_list|,
literal|""
operator|+
name|commitTracker
operator|.
name|getTimeUpperBound
argument_list|()
operator|+
literal|"ms"
argument_list|)
expr_stmt|;
block|}
name|lst
operator|.
name|add
argument_list|(
literal|"autocommits"
argument_list|,
name|commitTracker
operator|.
name|getCommitCount
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|softCommitTracker
operator|.
name|getDocsUpperBound
argument_list|()
operator|>
literal|0
condition|)
block|{
name|lst
operator|.
name|add
argument_list|(
literal|"soft autocommit maxDocs"
argument_list|,
name|softCommitTracker
operator|.
name|getDocsUpperBound
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|softCommitTracker
operator|.
name|getTimeUpperBound
argument_list|()
operator|>
literal|0
condition|)
block|{
name|lst
operator|.
name|add
argument_list|(
literal|"soft autocommit maxTime"
argument_list|,
literal|""
operator|+
name|softCommitTracker
operator|.
name|getTimeUpperBound
argument_list|()
operator|+
literal|"ms"
argument_list|)
expr_stmt|;
block|}
name|lst
operator|.
name|add
argument_list|(
literal|"soft autocommits"
argument_list|,
name|softCommitTracker
operator|.
name|getCommitCount
argument_list|()
argument_list|)
expr_stmt|;
name|lst
operator|.
name|add
argument_list|(
literal|"optimizes"
argument_list|,
name|optimizeCommands
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
name|lst
operator|.
name|add
argument_list|(
literal|"rollbacks"
argument_list|,
name|rollbackCommands
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
name|lst
operator|.
name|add
argument_list|(
literal|"expungeDeletes"
argument_list|,
name|expungeDeleteCommands
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
name|lst
operator|.
name|add
argument_list|(
literal|"docsPending"
argument_list|,
name|numDocsPending
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
comment|// pset.size() not synchronized, but it should be fine to access.
comment|// lst.add("deletesPending", pset.size());
name|lst
operator|.
name|add
argument_list|(
literal|"adds"
argument_list|,
name|addCommands
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
name|lst
operator|.
name|add
argument_list|(
literal|"deletesById"
argument_list|,
name|deleteByIdCommands
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
name|lst
operator|.
name|add
argument_list|(
literal|"deletesByQuery"
argument_list|,
name|deleteByQueryCommands
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
name|lst
operator|.
name|add
argument_list|(
literal|"errors"
argument_list|,
name|numErrors
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
name|lst
operator|.
name|add
argument_list|(
literal|"cumulative_adds"
argument_list|,
name|addCommandsCumulative
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
name|lst
operator|.
name|add
argument_list|(
literal|"cumulative_deletesById"
argument_list|,
name|deleteByIdCommandsCumulative
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
name|lst
operator|.
name|add
argument_list|(
literal|"cumulative_deletesByQuery"
argument_list|,
name|deleteByQueryCommandsCumulative
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
name|lst
operator|.
name|add
argument_list|(
literal|"cumulative_errors"
argument_list|,
name|numErrorsCumulative
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|ulog
operator|!=
literal|null
condition|)
block|{
name|lst
operator|.
name|add
argument_list|(
literal|"transaction_logs_total_size"
argument_list|,
name|ulog
operator|.
name|getTotalLogsSize
argument_list|()
argument_list|)
expr_stmt|;
name|lst
operator|.
name|add
argument_list|(
literal|"transaction_logs_total_number"
argument_list|,
name|ulog
operator|.
name|getTotalLogsNumber
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|lst
return|;
block|}
annotation|@
name|Override
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"DirectUpdateHandler2"
operator|+
name|getStatistics
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|getSolrCoreState
specifier|public
name|SolrCoreState
name|getSolrCoreState
parameter_list|()
block|{
return|return
name|solrCoreState
return|;
block|}
comment|// allow access for tests
DECL|method|getCommitTracker
specifier|public
name|CommitTracker
name|getCommitTracker
parameter_list|()
block|{
return|return
name|commitTracker
return|;
block|}
comment|// allow access for tests
DECL|method|getSoftCommitTracker
specifier|public
name|CommitTracker
name|getSoftCommitTracker
parameter_list|()
block|{
return|return
name|softCommitTracker
return|;
block|}
block|}
end_class
end_unit
