begin_unit
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_comment
comment|/**  */
end_comment
begin_package
DECL|package|org.apache.solr.update
package|package
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|update
package|;
end_package
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URL
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ExecutionException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Future
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicLong
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|Lock
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|ReentrantLock
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|document
operator|.
name|Document
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|IndexReader
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|IndexWriter
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|Term
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|queries
operator|.
name|function
operator|.
name|ValueSource
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|queryparser
operator|.
name|classic
operator|.
name|ParseException
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|BooleanClause
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|BooleanClause
operator|.
name|Occur
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|BooleanQuery
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|MatchAllDocsQuery
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|Query
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|TermQuery
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|client
operator|.
name|solrj
operator|.
name|SolrRequest
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|SolrException
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|SolrException
operator|.
name|ErrorCode
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|params
operator|.
name|ModifiableSolrParams
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|params
operator|.
name|SolrParams
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|util
operator|.
name|NamedList
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|util
operator|.
name|SimpleOrderedMap
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|core
operator|.
name|SolrConfig
operator|.
name|UpdateHandlerInfo
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|core
operator|.
name|SolrCore
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|request
operator|.
name|LocalSolrQueryRequest
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|request
operator|.
name|SolrQueryRequest
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|request
operator|.
name|SolrRequestInfo
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|response
operator|.
name|SolrQueryResponse
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|schema
operator|.
name|SchemaField
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|search
operator|.
name|FunctionRangeQuery
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|search
operator|.
name|QParser
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|search
operator|.
name|QueryUtils
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|search
operator|.
name|function
operator|.
name|ValueSourceRangeFilter
import|;
end_import
begin_comment
comment|/**  *  TODO: add soft commitWithin support  *   *<code>DirectUpdateHandler2</code> implements an UpdateHandler where documents are added  * directly to the main Lucene index as opposed to adding to a separate smaller index.  */
end_comment
begin_class
DECL|class|DirectUpdateHandler2
specifier|public
class|class
name|DirectUpdateHandler2
extends|extends
name|UpdateHandler
implements|implements
name|SolrCoreState
operator|.
name|IndexWriterCloser
block|{
DECL|field|solrCoreState
specifier|protected
specifier|final
name|SolrCoreState
name|solrCoreState
decl_stmt|;
DECL|field|commitLock
specifier|protected
specifier|final
name|Lock
name|commitLock
init|=
operator|new
name|ReentrantLock
argument_list|()
decl_stmt|;
comment|// stats
DECL|field|addCommands
name|AtomicLong
name|addCommands
init|=
operator|new
name|AtomicLong
argument_list|()
decl_stmt|;
DECL|field|addCommandsCumulative
name|AtomicLong
name|addCommandsCumulative
init|=
operator|new
name|AtomicLong
argument_list|()
decl_stmt|;
DECL|field|deleteByIdCommands
name|AtomicLong
name|deleteByIdCommands
init|=
operator|new
name|AtomicLong
argument_list|()
decl_stmt|;
DECL|field|deleteByIdCommandsCumulative
name|AtomicLong
name|deleteByIdCommandsCumulative
init|=
operator|new
name|AtomicLong
argument_list|()
decl_stmt|;
DECL|field|deleteByQueryCommands
name|AtomicLong
name|deleteByQueryCommands
init|=
operator|new
name|AtomicLong
argument_list|()
decl_stmt|;
DECL|field|deleteByQueryCommandsCumulative
name|AtomicLong
name|deleteByQueryCommandsCumulative
init|=
operator|new
name|AtomicLong
argument_list|()
decl_stmt|;
DECL|field|expungeDeleteCommands
name|AtomicLong
name|expungeDeleteCommands
init|=
operator|new
name|AtomicLong
argument_list|()
decl_stmt|;
DECL|field|mergeIndexesCommands
name|AtomicLong
name|mergeIndexesCommands
init|=
operator|new
name|AtomicLong
argument_list|()
decl_stmt|;
DECL|field|commitCommands
name|AtomicLong
name|commitCommands
init|=
operator|new
name|AtomicLong
argument_list|()
decl_stmt|;
DECL|field|optimizeCommands
name|AtomicLong
name|optimizeCommands
init|=
operator|new
name|AtomicLong
argument_list|()
decl_stmt|;
DECL|field|rollbackCommands
name|AtomicLong
name|rollbackCommands
init|=
operator|new
name|AtomicLong
argument_list|()
decl_stmt|;
DECL|field|numDocsPending
name|AtomicLong
name|numDocsPending
init|=
operator|new
name|AtomicLong
argument_list|()
decl_stmt|;
DECL|field|numErrors
name|AtomicLong
name|numErrors
init|=
operator|new
name|AtomicLong
argument_list|()
decl_stmt|;
DECL|field|numErrorsCumulative
name|AtomicLong
name|numErrorsCumulative
init|=
operator|new
name|AtomicLong
argument_list|()
decl_stmt|;
comment|// tracks when auto-commit should occur
DECL|field|commitTracker
specifier|protected
specifier|final
name|CommitTracker
name|commitTracker
decl_stmt|;
DECL|field|softCommitTracker
specifier|protected
specifier|final
name|CommitTracker
name|softCommitTracker
decl_stmt|;
DECL|method|DirectUpdateHandler2
specifier|public
name|DirectUpdateHandler2
parameter_list|(
name|SolrCore
name|core
parameter_list|)
throws|throws
name|IOException
block|{
name|super
argument_list|(
name|core
argument_list|)
expr_stmt|;
name|solrCoreState
operator|=
operator|new
name|DefaultSolrCoreState
argument_list|(
name|core
operator|.
name|getDirectoryFactory
argument_list|()
argument_list|)
expr_stmt|;
name|UpdateHandlerInfo
name|updateHandlerInfo
init|=
name|core
operator|.
name|getSolrConfig
argument_list|()
operator|.
name|getUpdateHandlerInfo
argument_list|()
decl_stmt|;
name|int
name|docsUpperBound
init|=
name|updateHandlerInfo
operator|.
name|autoCommmitMaxDocs
decl_stmt|;
comment|// getInt("updateHandler/autoCommit/maxDocs", -1);
name|int
name|timeUpperBound
init|=
name|updateHandlerInfo
operator|.
name|autoCommmitMaxTime
decl_stmt|;
comment|// getInt("updateHandler/autoCommit/maxTime", -1);
name|commitTracker
operator|=
operator|new
name|CommitTracker
argument_list|(
literal|"Hard"
argument_list|,
name|core
argument_list|,
name|docsUpperBound
argument_list|,
name|timeUpperBound
argument_list|,
name|updateHandlerInfo
operator|.
name|openSearcher
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|int
name|softCommitDocsUpperBound
init|=
name|updateHandlerInfo
operator|.
name|autoSoftCommmitMaxDocs
decl_stmt|;
comment|// getInt("updateHandler/autoSoftCommit/maxDocs", -1);
name|int
name|softCommitTimeUpperBound
init|=
name|updateHandlerInfo
operator|.
name|autoSoftCommmitMaxTime
decl_stmt|;
comment|// getInt("updateHandler/autoSoftCommit/maxTime", -1);
name|softCommitTracker
operator|=
operator|new
name|CommitTracker
argument_list|(
literal|"Soft"
argument_list|,
name|core
argument_list|,
name|softCommitDocsUpperBound
argument_list|,
name|softCommitTimeUpperBound
argument_list|,
literal|true
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
DECL|method|DirectUpdateHandler2
specifier|public
name|DirectUpdateHandler2
parameter_list|(
name|SolrCore
name|core
parameter_list|,
name|UpdateHandler
name|updateHandler
parameter_list|)
throws|throws
name|IOException
block|{
name|super
argument_list|(
name|core
argument_list|)
expr_stmt|;
if|if
condition|(
name|updateHandler
operator|instanceof
name|DirectUpdateHandler2
condition|)
block|{
name|this
operator|.
name|solrCoreState
operator|=
operator|(
operator|(
name|DirectUpdateHandler2
operator|)
name|updateHandler
operator|)
operator|.
name|solrCoreState
expr_stmt|;
block|}
else|else
block|{
comment|// the impl has changed, so we cannot use the old state - decref it
name|updateHandler
operator|.
name|decref
argument_list|()
expr_stmt|;
name|solrCoreState
operator|=
operator|new
name|DefaultSolrCoreState
argument_list|(
name|core
operator|.
name|getDirectoryFactory
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|UpdateHandlerInfo
name|updateHandlerInfo
init|=
name|core
operator|.
name|getSolrConfig
argument_list|()
operator|.
name|getUpdateHandlerInfo
argument_list|()
decl_stmt|;
name|int
name|docsUpperBound
init|=
name|updateHandlerInfo
operator|.
name|autoCommmitMaxDocs
decl_stmt|;
comment|// getInt("updateHandler/autoCommit/maxDocs", -1);
name|int
name|timeUpperBound
init|=
name|updateHandlerInfo
operator|.
name|autoCommmitMaxTime
decl_stmt|;
comment|// getInt("updateHandler/autoCommit/maxTime", -1);
name|commitTracker
operator|=
operator|new
name|CommitTracker
argument_list|(
literal|"Hard"
argument_list|,
name|core
argument_list|,
name|docsUpperBound
argument_list|,
name|timeUpperBound
argument_list|,
name|updateHandlerInfo
operator|.
name|openSearcher
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|int
name|softCommitDocsUpperBound
init|=
name|updateHandlerInfo
operator|.
name|autoSoftCommmitMaxDocs
decl_stmt|;
comment|// getInt("updateHandler/autoSoftCommit/maxDocs", -1);
name|int
name|softCommitTimeUpperBound
init|=
name|updateHandlerInfo
operator|.
name|autoSoftCommmitMaxTime
decl_stmt|;
comment|// getInt("updateHandler/autoSoftCommit/maxTime", -1);
name|softCommitTracker
operator|=
operator|new
name|CommitTracker
argument_list|(
literal|"Soft"
argument_list|,
name|core
argument_list|,
name|softCommitDocsUpperBound
argument_list|,
name|softCommitTimeUpperBound
argument_list|,
name|updateHandlerInfo
operator|.
name|openSearcher
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|this
operator|.
name|ulog
operator|=
name|updateHandler
operator|.
name|getUpdateLog
argument_list|()
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|ulog
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|ulog
operator|.
name|init
argument_list|(
name|this
argument_list|,
name|core
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|deleteAll
specifier|private
name|void
name|deleteAll
parameter_list|()
throws|throws
name|IOException
block|{
name|SolrCore
operator|.
name|log
operator|.
name|info
argument_list|(
name|core
operator|.
name|getLogId
argument_list|()
operator|+
literal|"REMOVING ALL DOCUMENTS FROM INDEX"
argument_list|)
expr_stmt|;
name|solrCoreState
operator|.
name|getIndexWriter
argument_list|(
name|core
argument_list|)
operator|.
name|deleteAll
argument_list|()
expr_stmt|;
block|}
DECL|method|rollbackWriter
specifier|protected
name|void
name|rollbackWriter
parameter_list|()
throws|throws
name|IOException
block|{
name|numDocsPending
operator|.
name|set
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|solrCoreState
operator|.
name|rollbackIndexWriter
argument_list|(
name|core
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|addDoc
specifier|public
name|int
name|addDoc
parameter_list|(
name|AddUpdateCommand
name|cmd
parameter_list|)
throws|throws
name|IOException
block|{
name|IndexWriter
name|writer
init|=
name|solrCoreState
operator|.
name|getIndexWriter
argument_list|(
name|core
argument_list|)
decl_stmt|;
name|addCommands
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
name|addCommandsCumulative
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
name|int
name|rc
init|=
operator|-
literal|1
decl_stmt|;
comment|// if there is no ID field, don't overwrite
if|if
condition|(
name|idField
operator|==
literal|null
condition|)
block|{
name|cmd
operator|.
name|overwrite
operator|=
literal|false
expr_stmt|;
block|}
try|try
block|{
if|if
condition|(
name|cmd
operator|.
name|overwrite
condition|)
block|{
name|Term
name|updateTerm
decl_stmt|;
name|Term
name|idTerm
init|=
operator|new
name|Term
argument_list|(
name|idField
operator|.
name|getName
argument_list|()
argument_list|,
name|cmd
operator|.
name|getIndexedId
argument_list|()
argument_list|)
decl_stmt|;
name|boolean
name|del
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|cmd
operator|.
name|updateTerm
operator|==
literal|null
condition|)
block|{
name|updateTerm
operator|=
name|idTerm
expr_stmt|;
block|}
else|else
block|{
name|del
operator|=
literal|true
expr_stmt|;
name|updateTerm
operator|=
name|cmd
operator|.
name|updateTerm
expr_stmt|;
block|}
name|Document
name|luceneDocument
init|=
name|cmd
operator|.
name|getLuceneDocument
argument_list|()
decl_stmt|;
comment|// SolrCore.verbose("updateDocument",updateTerm,luceneDocument,writer);
name|writer
operator|.
name|updateDocument
argument_list|(
name|updateTerm
argument_list|,
name|luceneDocument
argument_list|)
expr_stmt|;
comment|// SolrCore.verbose("updateDocument",updateTerm,"DONE");
if|if
condition|(
name|del
condition|)
block|{
comment|// ensure id remains unique
name|BooleanQuery
name|bq
init|=
operator|new
name|BooleanQuery
argument_list|()
decl_stmt|;
name|bq
operator|.
name|add
argument_list|(
operator|new
name|BooleanClause
argument_list|(
operator|new
name|TermQuery
argument_list|(
name|updateTerm
argument_list|)
argument_list|,
name|Occur
operator|.
name|MUST_NOT
argument_list|)
argument_list|)
expr_stmt|;
name|bq
operator|.
name|add
argument_list|(
operator|new
name|BooleanClause
argument_list|(
operator|new
name|TermQuery
argument_list|(
name|idTerm
argument_list|)
argument_list|,
name|Occur
operator|.
name|MUST
argument_list|)
argument_list|)
expr_stmt|;
name|writer
operator|.
name|deleteDocuments
argument_list|(
name|bq
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// allow duplicates
name|writer
operator|.
name|addDocument
argument_list|(
name|cmd
operator|.
name|getLuceneDocument
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// Add to the transaction log *after* successfully adding to the index, if there was no error.
comment|// This ordering ensures that if we log it, it's definitely been added to the the index.
comment|// This also ensures that if a commit sneaks in-between, that we know everything in a particular
comment|// log version was definitely committed.
if|if
condition|(
name|ulog
operator|!=
literal|null
condition|)
name|ulog
operator|.
name|add
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cmd
operator|.
name|getFlags
argument_list|()
operator|&
name|UpdateCommand
operator|.
name|IGNORE_AUTOCOMMIT
operator|)
operator|==
literal|0
condition|)
block|{
name|commitTracker
operator|.
name|addedDocument
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
name|softCommitTracker
operator|.
name|addedDocument
argument_list|(
name|cmd
operator|.
name|commitWithin
argument_list|)
expr_stmt|;
block|}
name|rc
operator|=
literal|1
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
name|rc
operator|!=
literal|1
condition|)
block|{
name|numErrors
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
name|numErrorsCumulative
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|numDocsPending
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|rc
return|;
block|}
DECL|method|updateDeleteTrackers
specifier|private
name|void
name|updateDeleteTrackers
parameter_list|(
name|DeleteUpdateCommand
name|cmd
parameter_list|)
block|{
if|if
condition|(
operator|(
name|cmd
operator|.
name|getFlags
argument_list|()
operator|&
name|UpdateCommand
operator|.
name|IGNORE_AUTOCOMMIT
operator|)
operator|==
literal|0
condition|)
block|{
name|softCommitTracker
operator|.
name|deletedDocument
argument_list|(
name|cmd
operator|.
name|commitWithin
argument_list|)
expr_stmt|;
if|if
condition|(
name|commitTracker
operator|.
name|getTimeUpperBound
argument_list|()
operator|>
literal|0
condition|)
block|{
name|commitTracker
operator|.
name|scheduleCommitWithin
argument_list|(
name|commitTracker
operator|.
name|getTimeUpperBound
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|softCommitTracker
operator|.
name|getTimeUpperBound
argument_list|()
operator|>
literal|0
condition|)
block|{
name|softCommitTracker
operator|.
name|scheduleCommitWithin
argument_list|(
name|softCommitTracker
operator|.
name|getTimeUpperBound
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// we don't return the number of docs deleted because it's not always possible to quickly know that info.
annotation|@
name|Override
DECL|method|delete
specifier|public
name|void
name|delete
parameter_list|(
name|DeleteUpdateCommand
name|cmd
parameter_list|)
throws|throws
name|IOException
block|{
name|deleteByIdCommands
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
name|deleteByIdCommandsCumulative
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
name|IndexWriter
name|writer
init|=
name|solrCoreState
operator|.
name|getIndexWriter
argument_list|(
name|core
argument_list|)
decl_stmt|;
name|Term
name|deleteTerm
init|=
operator|new
name|Term
argument_list|(
name|idField
operator|.
name|getName
argument_list|()
argument_list|,
name|cmd
operator|.
name|getIndexedId
argument_list|()
argument_list|)
decl_stmt|;
comment|// SolrCore.verbose("deleteDocuments",deleteTerm,writer);
name|writer
operator|.
name|deleteDocuments
argument_list|(
name|deleteTerm
argument_list|)
expr_stmt|;
comment|// SolrCore.verbose("deleteDocuments",deleteTerm,"DONE");
if|if
condition|(
name|ulog
operator|!=
literal|null
condition|)
name|ulog
operator|.
name|delete
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
name|updateDeleteTrackers
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
block|}
comment|// we don't return the number of docs deleted because it's not always possible to quickly know that info.
annotation|@
name|Override
DECL|method|deleteByQuery
specifier|public
name|void
name|deleteByQuery
parameter_list|(
name|DeleteUpdateCommand
name|cmd
parameter_list|)
throws|throws
name|IOException
block|{
name|deleteByQueryCommands
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
name|deleteByQueryCommandsCumulative
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
name|boolean
name|madeIt
init|=
literal|false
decl_stmt|;
try|try
block|{
name|Query
name|q
decl_stmt|;
try|try
block|{
comment|// TODO: move this higher in the stack?
name|QParser
name|parser
init|=
name|QParser
operator|.
name|getParser
argument_list|(
name|cmd
operator|.
name|query
argument_list|,
literal|"lucene"
argument_list|,
name|cmd
operator|.
name|req
argument_list|)
decl_stmt|;
name|q
operator|=
name|parser
operator|.
name|getQuery
argument_list|()
expr_stmt|;
name|q
operator|=
name|QueryUtils
operator|.
name|makeQueryable
argument_list|(
name|q
argument_list|)
expr_stmt|;
comment|// peer-sync can cause older deleteByQueries to be executed and could
comment|// delete newer documents.  We prevent this by adding a clause restricting
comment|// version.
if|if
condition|(
operator|(
name|cmd
operator|.
name|getFlags
argument_list|()
operator|&
name|UpdateCommand
operator|.
name|PEER_SYNC
operator|)
operator|!=
literal|0
condition|)
block|{
name|BooleanQuery
name|bq
init|=
operator|new
name|BooleanQuery
argument_list|()
decl_stmt|;
name|bq
operator|.
name|add
argument_list|(
name|q
argument_list|,
name|Occur
operator|.
name|MUST
argument_list|)
expr_stmt|;
name|SchemaField
name|sf
init|=
name|core
operator|.
name|getSchema
argument_list|()
operator|.
name|getField
argument_list|(
name|VersionInfo
operator|.
name|VERSION_FIELD
argument_list|)
decl_stmt|;
name|ValueSource
name|vs
init|=
name|sf
operator|.
name|getType
argument_list|()
operator|.
name|getValueSource
argument_list|(
name|sf
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|ValueSourceRangeFilter
name|filt
init|=
operator|new
name|ValueSourceRangeFilter
argument_list|(
name|vs
argument_list|,
literal|null
argument_list|,
name|Long
operator|.
name|toString
argument_list|(
name|Math
operator|.
name|abs
argument_list|(
name|cmd
operator|.
name|version
argument_list|)
argument_list|)
argument_list|,
literal|true
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|FunctionRangeQuery
name|range
init|=
operator|new
name|FunctionRangeQuery
argument_list|(
name|filt
argument_list|)
decl_stmt|;
name|bq
operator|.
name|add
argument_list|(
name|range
argument_list|,
name|Occur
operator|.
name|MUST
argument_list|)
expr_stmt|;
name|q
operator|=
name|bq
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|ParseException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|SolrException
operator|.
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
name|e
argument_list|)
throw|;
block|}
name|boolean
name|delAll
init|=
name|MatchAllDocsQuery
operator|.
name|class
operator|==
name|q
operator|.
name|getClass
argument_list|()
decl_stmt|;
comment|//
comment|// synchronized to prevent deleteByQuery from running during the "open new searcher"
comment|// part of a commit.  DBQ needs to signal that a fresh reader will be needed for
comment|// a realtime view of the index.  When a new searcher is opened after a DBQ, that
comment|// flag can be cleared.  If those thing happen concurrently, it's not thread safe.
comment|//
synchronized|synchronized
init|(
name|this
init|)
block|{
if|if
condition|(
name|delAll
condition|)
block|{
name|deleteAll
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|solrCoreState
operator|.
name|getIndexWriter
argument_list|(
name|core
argument_list|)
operator|.
name|deleteDocuments
argument_list|(
name|q
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ulog
operator|!=
literal|null
condition|)
name|ulog
operator|.
name|deleteByQuery
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
block|}
name|madeIt
operator|=
literal|true
expr_stmt|;
name|updateDeleteTrackers
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
operator|!
name|madeIt
condition|)
block|{
name|numErrors
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
name|numErrorsCumulative
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|Override
DECL|method|mergeIndexes
specifier|public
name|int
name|mergeIndexes
parameter_list|(
name|MergeIndexesCommand
name|cmd
parameter_list|)
throws|throws
name|IOException
block|{
name|mergeIndexesCommands
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
name|int
name|rc
decl_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"start "
operator|+
name|cmd
argument_list|)
expr_stmt|;
name|IndexReader
index|[]
name|readers
init|=
name|cmd
operator|.
name|readers
decl_stmt|;
if|if
condition|(
name|readers
operator|!=
literal|null
operator|&&
name|readers
operator|.
name|length
operator|>
literal|0
condition|)
block|{
name|solrCoreState
operator|.
name|getIndexWriter
argument_list|(
name|core
argument_list|)
operator|.
name|addIndexes
argument_list|(
name|readers
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|rc
operator|=
literal|0
expr_stmt|;
block|}
name|log
operator|.
name|info
argument_list|(
literal|"end_mergeIndexes"
argument_list|)
expr_stmt|;
comment|// TODO: consider soft commit issues
if|if
condition|(
name|rc
operator|==
literal|1
operator|&&
name|commitTracker
operator|.
name|getTimeUpperBound
argument_list|()
operator|>
literal|0
condition|)
block|{
name|commitTracker
operator|.
name|scheduleCommitWithin
argument_list|(
name|commitTracker
operator|.
name|getTimeUpperBound
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rc
operator|==
literal|1
operator|&&
name|softCommitTracker
operator|.
name|getTimeUpperBound
argument_list|()
operator|>
literal|0
condition|)
block|{
name|softCommitTracker
operator|.
name|scheduleCommitWithin
argument_list|(
name|softCommitTracker
operator|.
name|getTimeUpperBound
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|rc
return|;
block|}
DECL|method|prepareCommit
specifier|public
name|void
name|prepareCommit
parameter_list|(
name|CommitUpdateCommand
name|cmd
parameter_list|)
throws|throws
name|IOException
block|{
name|boolean
name|error
init|=
literal|true
decl_stmt|;
try|try
block|{
name|log
operator|.
name|info
argument_list|(
literal|"start "
operator|+
name|cmd
argument_list|)
expr_stmt|;
name|IndexWriter
name|writer
init|=
name|solrCoreState
operator|.
name|getIndexWriter
argument_list|(
name|core
argument_list|)
decl_stmt|;
name|writer
operator|.
name|prepareCommit
argument_list|()
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"end_prepareCommit"
argument_list|)
expr_stmt|;
name|error
operator|=
literal|false
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
name|error
condition|)
name|numErrors
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|commit
specifier|public
name|void
name|commit
parameter_list|(
name|CommitUpdateCommand
name|cmd
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|cmd
operator|.
name|prepareCommit
condition|)
block|{
name|prepareCommit
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
return|return;
block|}
name|IndexWriter
name|writer
init|=
name|solrCoreState
operator|.
name|getIndexWriter
argument_list|(
name|core
argument_list|)
decl_stmt|;
if|if
condition|(
name|cmd
operator|.
name|optimize
condition|)
block|{
name|optimizeCommands
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|commitCommands
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
if|if
condition|(
name|cmd
operator|.
name|expungeDeletes
condition|)
name|expungeDeleteCommands
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
block|}
name|Future
index|[]
name|waitSearcher
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|cmd
operator|.
name|waitSearcher
condition|)
block|{
name|waitSearcher
operator|=
operator|new
name|Future
index|[
literal|1
index|]
expr_stmt|;
block|}
name|boolean
name|error
init|=
literal|true
decl_stmt|;
try|try
block|{
comment|// only allow one hard commit to proceed at once
if|if
condition|(
operator|!
name|cmd
operator|.
name|softCommit
condition|)
block|{
name|commitLock
operator|.
name|lock
argument_list|()
expr_stmt|;
block|}
name|log
operator|.
name|info
argument_list|(
literal|"start "
operator|+
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|.
name|optimize
condition|)
block|{
name|writer
operator|.
name|forceMerge
argument_list|(
name|cmd
operator|.
name|maxOptimizeSegments
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cmd
operator|.
name|expungeDeletes
condition|)
block|{
name|writer
operator|.
name|forceMergeDeletes
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|cmd
operator|.
name|softCommit
condition|)
block|{
synchronized|synchronized
init|(
name|this
init|)
block|{
comment|// sync is currently needed to prevent preCommit from being called between preSoft and postSoft... see postSoft comments.
if|if
condition|(
name|ulog
operator|!=
literal|null
condition|)
name|ulog
operator|.
name|preCommit
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
block|}
comment|// SolrCore.verbose("writer.commit() start writer=",writer);
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|commitData
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|commitData
operator|.
name|put
argument_list|(
name|SolrIndexWriter
operator|.
name|COMMIT_TIME_MSEC_KEY
argument_list|,
name|String
operator|.
name|valueOf
argument_list|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|writer
operator|.
name|commit
argument_list|(
name|commitData
argument_list|)
expr_stmt|;
comment|// SolrCore.verbose("writer.commit() end");
name|numDocsPending
operator|.
name|set
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|callPostCommitCallbacks
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|callPostSoftCommitCallbacks
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|cmd
operator|.
name|optimize
condition|)
block|{
name|callPostOptimizeCallbacks
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|cmd
operator|.
name|softCommit
condition|)
block|{
comment|// ulog.preSoftCommit();
synchronized|synchronized
init|(
name|this
init|)
block|{
if|if
condition|(
name|ulog
operator|!=
literal|null
condition|)
name|ulog
operator|.
name|preSoftCommit
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
name|core
operator|.
name|getSearcher
argument_list|(
literal|true
argument_list|,
literal|false
argument_list|,
name|waitSearcher
argument_list|,
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|ulog
operator|!=
literal|null
condition|)
name|ulog
operator|.
name|postSoftCommit
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
block|}
comment|// ulog.postSoftCommit();
block|}
else|else
block|{
synchronized|synchronized
init|(
name|this
init|)
block|{
if|if
condition|(
name|ulog
operator|!=
literal|null
condition|)
name|ulog
operator|.
name|preSoftCommit
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|.
name|openSearcher
condition|)
block|{
name|core
operator|.
name|getSearcher
argument_list|(
literal|true
argument_list|,
literal|false
argument_list|,
name|waitSearcher
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// force open a new realtime searcher so realtime-get and versioning code can see the latest
name|core
operator|.
name|openNewSearcher
argument_list|(
literal|true
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ulog
operator|!=
literal|null
condition|)
name|ulog
operator|.
name|postSoftCommit
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ulog
operator|!=
literal|null
condition|)
name|ulog
operator|.
name|postCommit
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
comment|// postCommit currently means new searcher has
comment|// also been opened
block|}
comment|// reset commit tracking
if|if
condition|(
name|cmd
operator|.
name|softCommit
condition|)
block|{
name|softCommitTracker
operator|.
name|didCommit
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|commitTracker
operator|.
name|didCommit
argument_list|()
expr_stmt|;
block|}
name|log
operator|.
name|info
argument_list|(
literal|"end_commit_flush"
argument_list|)
expr_stmt|;
name|error
operator|=
literal|false
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
operator|!
name|cmd
operator|.
name|softCommit
condition|)
block|{
name|commitLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
name|addCommands
operator|.
name|set
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|deleteByIdCommands
operator|.
name|set
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|deleteByQueryCommands
operator|.
name|set
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|numErrors
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
block|}
comment|// if we are supposed to wait for the searcher to be registered, then we should do it
comment|// outside any synchronized block so that other update operations can proceed.
if|if
condition|(
name|waitSearcher
operator|!=
literal|null
operator|&&
name|waitSearcher
index|[
literal|0
index|]
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|waitSearcher
index|[
literal|0
index|]
operator|.
name|get
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|SolrException
operator|.
name|log
argument_list|(
name|log
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ExecutionException
name|e
parameter_list|)
block|{
name|SolrException
operator|.
name|log
argument_list|(
name|log
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|Override
DECL|method|newIndexWriter
specifier|public
name|void
name|newIndexWriter
parameter_list|()
throws|throws
name|IOException
block|{
name|solrCoreState
operator|.
name|newIndexWriter
argument_list|(
name|core
argument_list|)
expr_stmt|;
block|}
comment|/**    * @since Solr 1.4    */
annotation|@
name|Override
DECL|method|rollback
specifier|public
name|void
name|rollback
parameter_list|(
name|RollbackUpdateCommand
name|cmd
parameter_list|)
throws|throws
name|IOException
block|{
name|rollbackCommands
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
name|boolean
name|error
init|=
literal|true
decl_stmt|;
try|try
block|{
name|log
operator|.
name|info
argument_list|(
literal|"start "
operator|+
name|cmd
argument_list|)
expr_stmt|;
name|rollbackWriter
argument_list|()
expr_stmt|;
comment|//callPostRollbackCallbacks();
comment|// reset commit tracking
name|commitTracker
operator|.
name|didRollback
argument_list|()
expr_stmt|;
name|softCommitTracker
operator|.
name|didRollback
argument_list|()
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"end_rollback"
argument_list|)
expr_stmt|;
name|error
operator|=
literal|false
expr_stmt|;
block|}
finally|finally
block|{
name|addCommandsCumulative
operator|.
name|set
argument_list|(
name|addCommandsCumulative
operator|.
name|get
argument_list|()
operator|-
name|addCommands
operator|.
name|getAndSet
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|deleteByIdCommandsCumulative
operator|.
name|set
argument_list|(
name|deleteByIdCommandsCumulative
operator|.
name|get
argument_list|()
operator|-
name|deleteByIdCommands
operator|.
name|getAndSet
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|deleteByQueryCommandsCumulative
operator|.
name|set
argument_list|(
name|deleteByQueryCommandsCumulative
operator|.
name|get
argument_list|()
operator|-
name|deleteByQueryCommands
operator|.
name|getAndSet
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|numErrors
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|getUpdateLog
specifier|public
name|UpdateLog
name|getUpdateLog
parameter_list|()
block|{
return|return
name|ulog
return|;
block|}
annotation|@
name|Override
DECL|method|close
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
name|log
operator|.
name|info
argument_list|(
literal|"closing "
operator|+
name|this
argument_list|)
expr_stmt|;
name|commitTracker
operator|.
name|close
argument_list|()
expr_stmt|;
name|softCommitTracker
operator|.
name|close
argument_list|()
expr_stmt|;
name|numDocsPending
operator|.
name|set
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|solrCoreState
operator|.
name|decref
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
DECL|field|commitOnClose
specifier|public
specifier|static
name|boolean
name|commitOnClose
init|=
literal|true
decl_stmt|;
comment|// TODO: make this a real config option?
comment|// IndexWriterCloser interface method - called from solrCoreState.decref(this)
annotation|@
name|Override
DECL|method|closeWriter
specifier|public
name|void
name|closeWriter
parameter_list|(
name|IndexWriter
name|writer
parameter_list|)
throws|throws
name|IOException
block|{
name|boolean
name|clearRequestInfo
init|=
literal|false
decl_stmt|;
name|commitLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|SolrQueryRequest
name|req
init|=
operator|new
name|LocalSolrQueryRequest
argument_list|(
name|core
argument_list|,
operator|new
name|ModifiableSolrParams
argument_list|()
argument_list|)
decl_stmt|;
name|SolrQueryResponse
name|rsp
init|=
operator|new
name|SolrQueryResponse
argument_list|()
decl_stmt|;
if|if
condition|(
name|SolrRequestInfo
operator|.
name|getRequestInfo
argument_list|()
operator|==
literal|null
condition|)
block|{
name|clearRequestInfo
operator|=
literal|true
expr_stmt|;
name|SolrRequestInfo
operator|.
name|setRequestInfo
argument_list|(
operator|new
name|SolrRequestInfo
argument_list|(
name|req
argument_list|,
name|rsp
argument_list|)
argument_list|)
expr_stmt|;
comment|// important for debugging
block|}
if|if
condition|(
operator|!
name|commitOnClose
condition|)
block|{
if|if
condition|(
name|writer
operator|!=
literal|null
condition|)
block|{
name|writer
operator|.
name|rollback
argument_list|()
expr_stmt|;
block|}
comment|// we shouldn't close the transaction logs either, but leaving them open
comment|// means we can't delete them on windows (needed for tests)
if|if
condition|(
name|ulog
operator|!=
literal|null
condition|)
name|ulog
operator|.
name|close
argument_list|(
literal|false
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// do a commit before we quit?
name|boolean
name|tryToCommit
init|=
name|writer
operator|!=
literal|null
operator|&&
name|ulog
operator|!=
literal|null
operator|&&
name|ulog
operator|.
name|hasUncommittedChanges
argument_list|()
operator|&&
name|ulog
operator|.
name|getState
argument_list|()
operator|==
name|UpdateLog
operator|.
name|State
operator|.
name|ACTIVE
decl_stmt|;
try|try
block|{
if|if
condition|(
name|tryToCommit
condition|)
block|{
name|CommitUpdateCommand
name|cmd
init|=
operator|new
name|CommitUpdateCommand
argument_list|(
name|req
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|cmd
operator|.
name|openSearcher
operator|=
literal|false
expr_stmt|;
name|cmd
operator|.
name|waitSearcher
operator|=
literal|false
expr_stmt|;
name|cmd
operator|.
name|softCommit
operator|=
literal|false
expr_stmt|;
comment|// TODO: keep other commit callbacks from being called?
comment|//  this.commit(cmd);        // too many test failures using this method... is it because of callbacks?
synchronized|synchronized
init|(
name|this
init|)
block|{
name|ulog
operator|.
name|preCommit
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
block|}
comment|// todo: refactor this shared code (or figure out why a real CommitUpdateCommand can't be used)
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|commitData
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|commitData
operator|.
name|put
argument_list|(
name|SolrIndexWriter
operator|.
name|COMMIT_TIME_MSEC_KEY
argument_list|,
name|String
operator|.
name|valueOf
argument_list|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|writer
operator|.
name|commit
argument_list|(
name|commitData
argument_list|)
expr_stmt|;
synchronized|synchronized
init|(
name|this
init|)
block|{
name|ulog
operator|.
name|postCommit
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|Throwable
name|th
parameter_list|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"Error in final commit"
argument_list|,
name|th
argument_list|)
expr_stmt|;
block|}
comment|// we went through the normal process to commit, so we don't have to artificially
comment|// cap any ulog files.
try|try
block|{
if|if
condition|(
name|ulog
operator|!=
literal|null
condition|)
name|ulog
operator|.
name|close
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|th
parameter_list|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"Error closing log files"
argument_list|,
name|th
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|writer
operator|!=
literal|null
condition|)
name|writer
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|commitLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
if|if
condition|(
name|clearRequestInfo
condition|)
name|SolrRequestInfo
operator|.
name|clearRequestInfo
argument_list|()
expr_stmt|;
block|}
block|}
comment|/////////////////////////////////////////////////////////////////////
comment|// SolrInfoMBean stuff: Statistics and Module Info
comment|/////////////////////////////////////////////////////////////////////
DECL|method|getName
specifier|public
name|String
name|getName
parameter_list|()
block|{
return|return
name|DirectUpdateHandler2
operator|.
name|class
operator|.
name|getName
argument_list|()
return|;
block|}
DECL|method|getVersion
specifier|public
name|String
name|getVersion
parameter_list|()
block|{
return|return
name|SolrCore
operator|.
name|version
return|;
block|}
DECL|method|getDescription
specifier|public
name|String
name|getDescription
parameter_list|()
block|{
return|return
literal|"Update handler that efficiently directly updates the on-disk main lucene index"
return|;
block|}
DECL|method|getCategory
specifier|public
name|Category
name|getCategory
parameter_list|()
block|{
return|return
name|Category
operator|.
name|UPDATEHANDLER
return|;
block|}
DECL|method|getSourceId
specifier|public
name|String
name|getSourceId
parameter_list|()
block|{
return|return
literal|"$Id$"
return|;
block|}
DECL|method|getSource
specifier|public
name|String
name|getSource
parameter_list|()
block|{
return|return
literal|"$URL$"
return|;
block|}
DECL|method|getDocs
specifier|public
name|URL
index|[]
name|getDocs
parameter_list|()
block|{
return|return
literal|null
return|;
block|}
DECL|method|getStatistics
specifier|public
name|NamedList
name|getStatistics
parameter_list|()
block|{
name|NamedList
name|lst
init|=
operator|new
name|SimpleOrderedMap
argument_list|()
decl_stmt|;
name|lst
operator|.
name|add
argument_list|(
literal|"commits"
argument_list|,
name|commitCommands
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|commitTracker
operator|.
name|getDocsUpperBound
argument_list|()
operator|>
literal|0
condition|)
block|{
name|lst
operator|.
name|add
argument_list|(
literal|"autocommit maxDocs"
argument_list|,
name|commitTracker
operator|.
name|getDocsUpperBound
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|commitTracker
operator|.
name|getTimeUpperBound
argument_list|()
operator|>
literal|0
condition|)
block|{
name|lst
operator|.
name|add
argument_list|(
literal|"autocommit maxTime"
argument_list|,
literal|""
operator|+
name|commitTracker
operator|.
name|getTimeUpperBound
argument_list|()
operator|+
literal|"ms"
argument_list|)
expr_stmt|;
block|}
name|lst
operator|.
name|add
argument_list|(
literal|"autocommits"
argument_list|,
name|commitTracker
operator|.
name|getCommitCount
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|softCommitTracker
operator|.
name|getDocsUpperBound
argument_list|()
operator|>
literal|0
condition|)
block|{
name|lst
operator|.
name|add
argument_list|(
literal|"soft autocommit maxDocs"
argument_list|,
name|softCommitTracker
operator|.
name|getDocsUpperBound
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|softCommitTracker
operator|.
name|getTimeUpperBound
argument_list|()
operator|>
literal|0
condition|)
block|{
name|lst
operator|.
name|add
argument_list|(
literal|"soft autocommit maxTime"
argument_list|,
literal|""
operator|+
name|softCommitTracker
operator|.
name|getTimeUpperBound
argument_list|()
operator|+
literal|"ms"
argument_list|)
expr_stmt|;
block|}
name|lst
operator|.
name|add
argument_list|(
literal|"soft autocommits"
argument_list|,
name|softCommitTracker
operator|.
name|getCommitCount
argument_list|()
argument_list|)
expr_stmt|;
name|lst
operator|.
name|add
argument_list|(
literal|"optimizes"
argument_list|,
name|optimizeCommands
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
name|lst
operator|.
name|add
argument_list|(
literal|"rollbacks"
argument_list|,
name|rollbackCommands
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
name|lst
operator|.
name|add
argument_list|(
literal|"expungeDeletes"
argument_list|,
name|expungeDeleteCommands
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
name|lst
operator|.
name|add
argument_list|(
literal|"docsPending"
argument_list|,
name|numDocsPending
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
comment|// pset.size() not synchronized, but it should be fine to access.
comment|// lst.add("deletesPending", pset.size());
name|lst
operator|.
name|add
argument_list|(
literal|"adds"
argument_list|,
name|addCommands
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
name|lst
operator|.
name|add
argument_list|(
literal|"deletesById"
argument_list|,
name|deleteByIdCommands
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
name|lst
operator|.
name|add
argument_list|(
literal|"deletesByQuery"
argument_list|,
name|deleteByQueryCommands
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
name|lst
operator|.
name|add
argument_list|(
literal|"errors"
argument_list|,
name|numErrors
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
name|lst
operator|.
name|add
argument_list|(
literal|"cumulative_adds"
argument_list|,
name|addCommandsCumulative
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
name|lst
operator|.
name|add
argument_list|(
literal|"cumulative_deletesById"
argument_list|,
name|deleteByIdCommandsCumulative
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
name|lst
operator|.
name|add
argument_list|(
literal|"cumulative_deletesByQuery"
argument_list|,
name|deleteByQueryCommandsCumulative
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
name|lst
operator|.
name|add
argument_list|(
literal|"cumulative_errors"
argument_list|,
name|numErrorsCumulative
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|lst
return|;
block|}
annotation|@
name|Override
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"DirectUpdateHandler2"
operator|+
name|getStatistics
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|getSolrCoreState
specifier|public
name|SolrCoreState
name|getSolrCoreState
parameter_list|()
block|{
return|return
name|solrCoreState
return|;
block|}
annotation|@
name|Override
DECL|method|decref
specifier|public
name|void
name|decref
parameter_list|()
block|{
try|try
block|{
name|solrCoreState
operator|.
name|decref
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|SERVER_ERROR
argument_list|,
literal|""
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
DECL|method|incref
specifier|public
name|void
name|incref
parameter_list|()
block|{
name|solrCoreState
operator|.
name|incref
argument_list|()
expr_stmt|;
block|}
block|}
end_class
end_unit
