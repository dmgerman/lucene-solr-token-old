begin_unit
begin_package
DECL|package|org.apache.solr.update.processor
package|package
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|update
operator|.
name|processor
package|;
end_package
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|BytesRef
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|CharsRefBuilder
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|client
operator|.
name|solrj
operator|.
name|request
operator|.
name|UpdateRequest
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|cloud
operator|.
name|CloudDescriptor
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|cloud
operator|.
name|DistributedQueue
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|cloud
operator|.
name|LeaderInitiatedRecoveryThread
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|cloud
operator|.
name|Overseer
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|cloud
operator|.
name|ZkController
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|cloud
operator|.
name|overseer
operator|.
name|OverseerAction
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|SolrException
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|SolrException
operator|.
name|ErrorCode
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|SolrInputDocument
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|SolrInputField
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|cloud
operator|.
name|ClusterState
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|cloud
operator|.
name|CompositeIdRouter
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|cloud
operator|.
name|DocCollection
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|cloud
operator|.
name|DocRouter
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|cloud
operator|.
name|Replica
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|cloud
operator|.
name|RoutingRule
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|cloud
operator|.
name|Slice
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|cloud
operator|.
name|SolrZkClient
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|cloud
operator|.
name|ZkCoreNodeProps
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|cloud
operator|.
name|ZkNodeProps
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|cloud
operator|.
name|ZkStateReader
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|cloud
operator|.
name|ZooKeeperException
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|params
operator|.
name|ModifiableSolrParams
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|params
operator|.
name|ShardParams
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|params
operator|.
name|SolrParams
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|params
operator|.
name|UpdateParams
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|util
operator|.
name|Hash
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|util
operator|.
name|NamedList
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|core
operator|.
name|CoreContainer
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|core
operator|.
name|CoreDescriptor
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|handler
operator|.
name|component
operator|.
name|RealTimeGetComponent
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|request
operator|.
name|SolrQueryRequest
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|request
operator|.
name|SolrRequestInfo
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|response
operator|.
name|SolrQueryResponse
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|schema
operator|.
name|SchemaField
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|update
operator|.
name|AddUpdateCommand
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|update
operator|.
name|CommitUpdateCommand
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|update
operator|.
name|DeleteUpdateCommand
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|update
operator|.
name|SolrCmdDistributor
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|update
operator|.
name|SolrCmdDistributor
operator|.
name|Error
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|update
operator|.
name|SolrCmdDistributor
operator|.
name|Node
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|update
operator|.
name|SolrCmdDistributor
operator|.
name|RetryNode
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|update
operator|.
name|SolrCmdDistributor
operator|.
name|StdNode
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|update
operator|.
name|SolrIndexSplitter
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|update
operator|.
name|UpdateCommand
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|update
operator|.
name|UpdateHandler
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|update
operator|.
name|UpdateLog
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|update
operator|.
name|VersionBucket
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|update
operator|.
name|VersionInfo
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|KeeperException
import|;
end_import
begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import
begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
operator|.
name|Entry
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ExecutorService
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicInteger
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|ReentrantLock
import|;
end_import
begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|update
operator|.
name|processor
operator|.
name|DistributingUpdateProcessorFactory
operator|.
name|DISTRIB_UPDATE_PARAM
import|;
end_import
begin_comment
comment|// NOT mt-safe... create a new processor for each add thread
end_comment
begin_comment
comment|// TODO: we really should not wait for distrib after local? unless a certain replication factor is asked for
end_comment
begin_class
DECL|class|DistributedUpdateProcessor
specifier|public
class|class
name|DistributedUpdateProcessor
extends|extends
name|UpdateRequestProcessor
block|{
DECL|field|DISTRIB_FROM_SHARD
specifier|public
specifier|static
specifier|final
name|String
name|DISTRIB_FROM_SHARD
init|=
literal|"distrib.from.shard"
decl_stmt|;
DECL|field|DISTRIB_FROM_COLLECTION
specifier|public
specifier|static
specifier|final
name|String
name|DISTRIB_FROM_COLLECTION
init|=
literal|"distrib.from.collection"
decl_stmt|;
DECL|field|DISTRIB_FROM_PARENT
specifier|public
specifier|static
specifier|final
name|String
name|DISTRIB_FROM_PARENT
init|=
literal|"distrib.from.parent"
decl_stmt|;
DECL|field|DISTRIB_FROM
specifier|public
specifier|static
specifier|final
name|String
name|DISTRIB_FROM
init|=
literal|"distrib.from"
decl_stmt|;
DECL|field|TEST_DISTRIB_SKIP_SERVERS
specifier|private
specifier|static
specifier|final
name|String
name|TEST_DISTRIB_SKIP_SERVERS
init|=
literal|"test.distrib.skip.servers"
decl_stmt|;
DECL|field|log
specifier|public
specifier|final
specifier|static
name|Logger
name|log
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|DistributedUpdateProcessor
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/**    * Values this processor supports for the<code>DISTRIB_UPDATE_PARAM</code>.    * This is an implementation detail exposed solely for tests.    *     * @see DistributingUpdateProcessorFactory#DISTRIB_UPDATE_PARAM    */
DECL|enum|DistribPhase
specifier|public
specifier|static
enum|enum
name|DistribPhase
block|{
DECL|enum constant|NONE
DECL|enum constant|TOLEADER
DECL|enum constant|FROMLEADER
name|NONE
block|,
name|TOLEADER
block|,
name|FROMLEADER
block|;
DECL|method|parseParam
specifier|public
specifier|static
name|DistribPhase
name|parseParam
parameter_list|(
specifier|final
name|String
name|param
parameter_list|)
block|{
if|if
condition|(
name|param
operator|==
literal|null
operator|||
name|param
operator|.
name|trim
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
name|NONE
return|;
block|}
try|try
block|{
return|return
name|valueOf
argument_list|(
name|param
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|SolrException
operator|.
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
literal|"Illegal value for "
operator|+
name|DISTRIB_UPDATE_PARAM
operator|+
literal|": "
operator|+
name|param
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
block|}
comment|/**    * Keeps track of the replication factor achieved for a distributed update request    * originated in this distributed update processor.    */
DECL|class|RequestReplicationTracker
specifier|public
specifier|static
class|class
name|RequestReplicationTracker
block|{
DECL|field|minRf
name|int
name|minRf
decl_stmt|;
comment|// if a leader is driving the update request, then this will be non-null
comment|// however a replica may also be driving the update request (forwards to leaders)
comment|// in which case we leave this as null so we only count the rf back from the leaders
DECL|field|onLeaderShardId
name|String
name|onLeaderShardId
decl_stmt|;
comment|// track number of nodes we sent requests to and how many resulted in errors
comment|// there may be multiple requests per node when processing a batch
DECL|field|nodeErrorTracker
name|Map
argument_list|<
name|String
argument_list|,
name|AtomicInteger
argument_list|>
name|nodeErrorTracker
decl_stmt|;
comment|// if not using DirectUpdates, a leader may end up forwarding to other
comment|// leaders, so we need to keep the achieved rf for each of those too
DECL|field|otherLeaderRf
name|Map
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|otherLeaderRf
decl_stmt|;
DECL|method|RequestReplicationTracker
specifier|private
name|RequestReplicationTracker
parameter_list|(
name|String
name|shardId
parameter_list|,
name|int
name|minRf
parameter_list|)
block|{
name|this
operator|.
name|minRf
operator|=
name|minRf
expr_stmt|;
name|this
operator|.
name|onLeaderShardId
operator|=
name|shardId
expr_stmt|;
name|this
operator|.
name|nodeErrorTracker
operator|=
operator|new
name|HashMap
argument_list|<>
argument_list|(
literal|5
argument_list|)
expr_stmt|;
name|this
operator|.
name|otherLeaderRf
operator|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
expr_stmt|;
block|}
comment|// gives the replication factor that was achieved for this request
DECL|method|getAchievedRf
specifier|public
name|int
name|getAchievedRf
parameter_list|()
block|{
comment|// look across all shards to find the minimum achieved replication
comment|// factor ... unless the client is using direct updates from CloudSolrServer
comment|// there may be multiple shards at play here
name|int
name|achievedRf
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|onLeaderShardId
operator|!=
literal|null
condition|)
block|{
synchronized|synchronized
init|(
name|nodeErrorTracker
init|)
block|{
for|for
control|(
name|AtomicInteger
name|nodeErrors
range|:
name|nodeErrorTracker
operator|.
name|values
argument_list|()
control|)
block|{
if|if
condition|(
name|nodeErrors
operator|.
name|get
argument_list|()
operator|==
literal|0
condition|)
operator|++
name|achievedRf
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|// the node driving this updateRequest is not a leader and so
comment|// it only forwards to other leaders, so its local result doesn't count
name|achievedRf
operator|=
name|Integer
operator|.
name|MAX_VALUE
expr_stmt|;
block|}
comment|// min achieved may come from a request to another leader
synchronized|synchronized
init|(
name|otherLeaderRf
init|)
block|{
for|for
control|(
name|Integer
name|otherRf
range|:
name|otherLeaderRf
operator|.
name|values
argument_list|()
control|)
block|{
if|if
condition|(
name|otherRf
operator|<
name|achievedRf
condition|)
name|achievedRf
operator|=
name|otherRf
expr_stmt|;
block|}
block|}
return|return
operator|(
name|achievedRf
operator|==
name|Integer
operator|.
name|MAX_VALUE
operator|)
condition|?
literal|1
else|:
name|achievedRf
return|;
block|}
DECL|method|trackRequestResult
specifier|public
name|void
name|trackRequestResult
parameter_list|(
name|Node
name|node
parameter_list|,
name|boolean
name|success
parameter_list|,
name|Integer
name|rf
parameter_list|)
block|{
name|String
name|shardId
init|=
name|node
operator|.
name|getShardId
argument_list|()
decl_stmt|;
if|if
condition|(
name|log
operator|.
name|isDebugEnabled
argument_list|()
condition|)
name|log
operator|.
name|debug
argument_list|(
literal|"trackRequestResult("
operator|+
name|node
operator|+
literal|"): success? "
operator|+
name|success
operator|+
literal|" rf="
operator|+
name|rf
operator|+
literal|", shardId="
operator|+
name|shardId
operator|+
literal|" onLeaderShardId="
operator|+
name|onLeaderShardId
argument_list|)
expr_stmt|;
if|if
condition|(
name|onLeaderShardId
operator|==
literal|null
operator|||
operator|!
name|onLeaderShardId
operator|.
name|equals
argument_list|(
name|shardId
argument_list|)
condition|)
block|{
comment|// result from another leader that we forwarded to
synchronized|synchronized
init|(
name|otherLeaderRf
init|)
block|{
name|otherLeaderRf
operator|.
name|put
argument_list|(
name|shardId
argument_list|,
name|rf
operator|!=
literal|null
condition|?
name|rf
else|:
operator|new
name|Integer
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
if|if
condition|(
name|onLeaderShardId
operator|!=
literal|null
condition|)
block|{
comment|// track result for this leader
name|String
name|nodeUrl
init|=
name|node
operator|.
name|getUrl
argument_list|()
decl_stmt|;
name|AtomicInteger
name|nodeErrors
init|=
literal|null
decl_stmt|;
comment|// potentially many results flooding into this method from multiple nodes concurrently
synchronized|synchronized
init|(
name|nodeErrorTracker
init|)
block|{
name|nodeErrors
operator|=
name|nodeErrorTracker
operator|.
name|get
argument_list|(
name|nodeUrl
argument_list|)
expr_stmt|;
if|if
condition|(
name|nodeErrors
operator|==
literal|null
condition|)
block|{
name|nodeErrors
operator|=
operator|new
name|AtomicInteger
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|nodeErrorTracker
operator|.
name|put
argument_list|(
name|nodeUrl
argument_list|,
name|nodeErrors
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|success
condition|)
name|nodeErrors
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|(
literal|"RequestReplicationTracker"
argument_list|)
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|": onLeaderShardId="
argument_list|)
operator|.
name|append
argument_list|(
name|String
operator|.
name|valueOf
argument_list|(
name|onLeaderShardId
argument_list|)
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|", minRf="
argument_list|)
operator|.
name|append
argument_list|(
name|minRf
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|", achievedRf="
argument_list|)
operator|.
name|append
argument_list|(
name|getAchievedRf
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
DECL|field|COMMIT_END_POINT
specifier|public
specifier|static
specifier|final
name|String
name|COMMIT_END_POINT
init|=
literal|"commit_end_point"
decl_stmt|;
DECL|field|LOG_REPLAY
specifier|public
specifier|static
specifier|final
name|String
name|LOG_REPLAY
init|=
literal|"log_replay"
decl_stmt|;
DECL|field|req
specifier|private
specifier|final
name|SolrQueryRequest
name|req
decl_stmt|;
DECL|field|rsp
specifier|private
specifier|final
name|SolrQueryResponse
name|rsp
decl_stmt|;
DECL|field|next
specifier|private
specifier|final
name|UpdateRequestProcessor
name|next
decl_stmt|;
DECL|field|docMerger
specifier|private
specifier|final
name|AtomicUpdateDocumentMerger
name|docMerger
decl_stmt|;
DECL|field|VERSION_FIELD
specifier|public
specifier|static
specifier|final
name|String
name|VERSION_FIELD
init|=
literal|"_version_"
decl_stmt|;
DECL|field|updateHandler
specifier|private
specifier|final
name|UpdateHandler
name|updateHandler
decl_stmt|;
DECL|field|ulog
specifier|private
specifier|final
name|UpdateLog
name|ulog
decl_stmt|;
DECL|field|vinfo
specifier|private
specifier|final
name|VersionInfo
name|vinfo
decl_stmt|;
DECL|field|versionsStored
specifier|private
specifier|final
name|boolean
name|versionsStored
decl_stmt|;
DECL|field|returnVersions
specifier|private
name|boolean
name|returnVersions
init|=
literal|true
decl_stmt|;
comment|// todo: default to false and make configurable
DECL|field|addsResponse
specifier|private
name|NamedList
name|addsResponse
init|=
literal|null
decl_stmt|;
DECL|field|deleteResponse
specifier|private
name|NamedList
name|deleteResponse
init|=
literal|null
decl_stmt|;
DECL|field|deleteByQueryResponse
specifier|private
name|NamedList
name|deleteByQueryResponse
init|=
literal|null
decl_stmt|;
DECL|field|scratch
specifier|private
name|CharsRefBuilder
name|scratch
decl_stmt|;
DECL|field|idField
specifier|private
specifier|final
name|SchemaField
name|idField
decl_stmt|;
DECL|field|cmdDistrib
specifier|private
name|SolrCmdDistributor
name|cmdDistrib
decl_stmt|;
DECL|field|zkEnabled
specifier|private
specifier|final
name|boolean
name|zkEnabled
decl_stmt|;
DECL|field|cloudDesc
specifier|private
name|CloudDescriptor
name|cloudDesc
decl_stmt|;
DECL|field|collection
specifier|private
specifier|final
name|String
name|collection
decl_stmt|;
DECL|field|zkController
specifier|private
specifier|final
name|ZkController
name|zkController
decl_stmt|;
comment|// these are setup at the start of each request processing
comment|// method in this update processor
DECL|field|isLeader
specifier|private
name|boolean
name|isLeader
init|=
literal|true
decl_stmt|;
DECL|field|forwardToLeader
specifier|private
name|boolean
name|forwardToLeader
init|=
literal|false
decl_stmt|;
DECL|field|isSubShardLeader
specifier|private
name|boolean
name|isSubShardLeader
init|=
literal|false
decl_stmt|;
DECL|field|nodes
specifier|private
name|List
argument_list|<
name|Node
argument_list|>
name|nodes
decl_stmt|;
DECL|field|updateCommand
specifier|private
name|UpdateCommand
name|updateCommand
decl_stmt|;
comment|// the current command this processor is working on.
comment|//used for keeping track of replicas that have processed an add/update from the leader
DECL|field|replicationTracker
specifier|private
name|RequestReplicationTracker
name|replicationTracker
init|=
literal|null
decl_stmt|;
DECL|method|DistributedUpdateProcessor
specifier|public
name|DistributedUpdateProcessor
parameter_list|(
name|SolrQueryRequest
name|req
parameter_list|,
name|SolrQueryResponse
name|rsp
parameter_list|,
name|UpdateRequestProcessor
name|next
parameter_list|)
block|{
name|this
argument_list|(
name|req
argument_list|,
name|rsp
argument_list|,
operator|new
name|AtomicUpdateDocumentMerger
argument_list|(
name|req
argument_list|)
argument_list|,
name|next
argument_list|)
expr_stmt|;
block|}
comment|/** Specification of AtomicUpdateDocumentMerger is currently experimental.    * @lucene.experimental    */
DECL|method|DistributedUpdateProcessor
specifier|public
name|DistributedUpdateProcessor
parameter_list|(
name|SolrQueryRequest
name|req
parameter_list|,
name|SolrQueryResponse
name|rsp
parameter_list|,
name|AtomicUpdateDocumentMerger
name|docMerger
parameter_list|,
name|UpdateRequestProcessor
name|next
parameter_list|)
block|{
name|super
argument_list|(
name|next
argument_list|)
expr_stmt|;
name|this
operator|.
name|rsp
operator|=
name|rsp
expr_stmt|;
name|this
operator|.
name|next
operator|=
name|next
expr_stmt|;
name|this
operator|.
name|docMerger
operator|=
name|docMerger
expr_stmt|;
name|this
operator|.
name|idField
operator|=
name|req
operator|.
name|getSchema
argument_list|()
operator|.
name|getUniqueKeyField
argument_list|()
expr_stmt|;
comment|// version init
name|this
operator|.
name|updateHandler
operator|=
name|req
operator|.
name|getCore
argument_list|()
operator|.
name|getUpdateHandler
argument_list|()
expr_stmt|;
name|this
operator|.
name|ulog
operator|=
name|updateHandler
operator|.
name|getUpdateLog
argument_list|()
expr_stmt|;
name|this
operator|.
name|vinfo
operator|=
name|ulog
operator|==
literal|null
condition|?
literal|null
else|:
name|ulog
operator|.
name|getVersionInfo
argument_list|()
expr_stmt|;
name|versionsStored
operator|=
name|this
operator|.
name|vinfo
operator|!=
literal|null
operator|&&
name|this
operator|.
name|vinfo
operator|.
name|getVersionField
argument_list|()
operator|!=
literal|null
expr_stmt|;
name|returnVersions
operator|=
name|req
operator|.
name|getParams
argument_list|()
operator|.
name|getBool
argument_list|(
name|UpdateParams
operator|.
name|VERSIONS
argument_list|,
literal|false
argument_list|)
expr_stmt|;
comment|// TODO: better way to get the response, or pass back info to it?
name|SolrRequestInfo
name|reqInfo
init|=
name|returnVersions
condition|?
name|SolrRequestInfo
operator|.
name|getRequestInfo
argument_list|()
else|:
literal|null
decl_stmt|;
name|this
operator|.
name|req
operator|=
name|req
expr_stmt|;
name|CoreDescriptor
name|coreDesc
init|=
name|req
operator|.
name|getCore
argument_list|()
operator|.
name|getCoreDescriptor
argument_list|()
decl_stmt|;
name|this
operator|.
name|zkEnabled
operator|=
name|coreDesc
operator|.
name|getCoreContainer
argument_list|()
operator|.
name|isZooKeeperAware
argument_list|()
expr_stmt|;
name|zkController
operator|=
name|req
operator|.
name|getCore
argument_list|()
operator|.
name|getCoreDescriptor
argument_list|()
operator|.
name|getCoreContainer
argument_list|()
operator|.
name|getZkController
argument_list|()
expr_stmt|;
if|if
condition|(
name|zkEnabled
condition|)
block|{
name|cmdDistrib
operator|=
operator|new
name|SolrCmdDistributor
argument_list|(
name|coreDesc
operator|.
name|getCoreContainer
argument_list|()
operator|.
name|getUpdateShardHandler
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|//this.rsp = reqInfo != null ? reqInfo.getRsp() : null;
name|cloudDesc
operator|=
name|coreDesc
operator|.
name|getCloudDescriptor
argument_list|()
expr_stmt|;
if|if
condition|(
name|cloudDesc
operator|!=
literal|null
condition|)
block|{
name|collection
operator|=
name|cloudDesc
operator|.
name|getCollectionName
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|collection
operator|=
literal|null
expr_stmt|;
block|}
block|}
DECL|method|setupRequest
specifier|private
name|List
argument_list|<
name|Node
argument_list|>
name|setupRequest
parameter_list|(
name|String
name|id
parameter_list|,
name|SolrInputDocument
name|doc
parameter_list|)
block|{
return|return
name|setupRequest
argument_list|(
name|id
argument_list|,
name|doc
argument_list|,
literal|null
argument_list|)
return|;
block|}
DECL|method|setupRequest
specifier|private
name|List
argument_list|<
name|Node
argument_list|>
name|setupRequest
parameter_list|(
name|String
name|id
parameter_list|,
name|SolrInputDocument
name|doc
parameter_list|,
name|String
name|route
parameter_list|)
block|{
name|List
argument_list|<
name|Node
argument_list|>
name|nodes
init|=
literal|null
decl_stmt|;
comment|// if we are in zk mode...
if|if
condition|(
name|zkEnabled
condition|)
block|{
if|if
condition|(
operator|(
name|updateCommand
operator|.
name|getFlags
argument_list|()
operator|&
operator|(
name|UpdateCommand
operator|.
name|REPLAY
operator||
name|UpdateCommand
operator|.
name|PEER_SYNC
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|isLeader
operator|=
literal|false
expr_stmt|;
comment|// we actually might be the leader, but we don't want leader-logic for these types of updates anyway.
name|forwardToLeader
operator|=
literal|false
expr_stmt|;
return|return
name|nodes
return|;
block|}
name|ClusterState
name|cstate
init|=
name|zkController
operator|.
name|getClusterState
argument_list|()
decl_stmt|;
name|DocCollection
name|coll
init|=
name|cstate
operator|.
name|getCollection
argument_list|(
name|collection
argument_list|)
decl_stmt|;
name|Slice
name|slice
init|=
name|coll
operator|.
name|getRouter
argument_list|()
operator|.
name|getTargetSlice
argument_list|(
name|id
argument_list|,
name|doc
argument_list|,
name|route
argument_list|,
name|req
operator|.
name|getParams
argument_list|()
argument_list|,
name|coll
argument_list|)
decl_stmt|;
if|if
condition|(
name|slice
operator|==
literal|null
condition|)
block|{
comment|// No slice found.  Most strict routers will have already thrown an exception, so a null return is
comment|// a signal to use the slice of this core.
comment|// TODO: what if this core is not in the targeted collection?
name|String
name|shardId
init|=
name|req
operator|.
name|getCore
argument_list|()
operator|.
name|getCoreDescriptor
argument_list|()
operator|.
name|getCloudDescriptor
argument_list|()
operator|.
name|getShardId
argument_list|()
decl_stmt|;
name|slice
operator|=
name|coll
operator|.
name|getSlice
argument_list|(
name|shardId
argument_list|)
expr_stmt|;
if|if
condition|(
name|slice
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
literal|"No shard "
operator|+
name|shardId
operator|+
literal|" in "
operator|+
name|coll
argument_list|)
throw|;
block|}
block|}
name|DistribPhase
name|phase
init|=
name|DistribPhase
operator|.
name|parseParam
argument_list|(
name|req
operator|.
name|getParams
argument_list|()
operator|.
name|get
argument_list|(
name|DISTRIB_UPDATE_PARAM
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|DistribPhase
operator|.
name|FROMLEADER
operator|==
name|phase
operator|&&
operator|!
name|couldIbeSubShardLeader
argument_list|(
name|coll
argument_list|)
condition|)
block|{
if|if
condition|(
name|req
operator|.
name|getCore
argument_list|()
operator|.
name|getCoreDescriptor
argument_list|()
operator|.
name|getCloudDescriptor
argument_list|()
operator|.
name|isLeader
argument_list|()
condition|)
block|{
comment|// locally we think we are leader but the request says it came FROMLEADER
comment|// that could indicate a problem, let the full logic below figure it out
block|}
else|else
block|{
name|isLeader
operator|=
literal|false
expr_stmt|;
comment|// we actually might be the leader, but we don't want leader-logic for these types of updates anyway.
name|forwardToLeader
operator|=
literal|false
expr_stmt|;
return|return
name|nodes
return|;
block|}
block|}
name|String
name|shardId
init|=
name|slice
operator|.
name|getName
argument_list|()
decl_stmt|;
try|try
block|{
comment|// Not equivalent to getLeaderProps, which does retries to find a leader.
comment|// Replica leader = slice.getLeader();
name|Replica
name|leaderReplica
init|=
name|zkController
operator|.
name|getZkStateReader
argument_list|()
operator|.
name|getLeaderRetry
argument_list|(
name|collection
argument_list|,
name|shardId
argument_list|)
decl_stmt|;
name|isLeader
operator|=
name|leaderReplica
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
name|req
operator|.
name|getCore
argument_list|()
operator|.
name|getCoreDescriptor
argument_list|()
operator|.
name|getCloudDescriptor
argument_list|()
operator|.
name|getCoreNodeName
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isLeader
condition|)
block|{
name|isSubShardLeader
operator|=
name|amISubShardLeader
argument_list|(
name|coll
argument_list|,
name|slice
argument_list|,
name|id
argument_list|,
name|doc
argument_list|)
expr_stmt|;
if|if
condition|(
name|isSubShardLeader
condition|)
block|{
name|String
name|myShardId
init|=
name|req
operator|.
name|getCore
argument_list|()
operator|.
name|getCoreDescriptor
argument_list|()
operator|.
name|getCloudDescriptor
argument_list|()
operator|.
name|getShardId
argument_list|()
decl_stmt|;
name|slice
operator|=
name|coll
operator|.
name|getSlice
argument_list|(
name|myShardId
argument_list|)
expr_stmt|;
name|shardId
operator|=
name|myShardId
expr_stmt|;
name|leaderReplica
operator|=
name|zkController
operator|.
name|getZkStateReader
argument_list|()
operator|.
name|getLeaderRetry
argument_list|(
name|collection
argument_list|,
name|myShardId
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|ZkCoreNodeProps
argument_list|>
name|myReplicas
init|=
name|zkController
operator|.
name|getZkStateReader
argument_list|()
operator|.
name|getReplicaProps
argument_list|(
name|collection
argument_list|,
name|shardId
argument_list|,
name|leaderReplica
operator|.
name|getName
argument_list|()
argument_list|,
literal|null
argument_list|,
name|ZkStateReader
operator|.
name|DOWN
argument_list|)
decl_stmt|;
block|}
block|}
name|doDefensiveChecks
argument_list|(
name|phase
argument_list|)
expr_stmt|;
comment|// if request is coming from another collection then we want it to be sent to all replicas
comment|// even if its phase is FROMLEADER
name|String
name|fromCollection
init|=
name|updateCommand
operator|.
name|getReq
argument_list|()
operator|.
name|getParams
argument_list|()
operator|.
name|get
argument_list|(
name|DISTRIB_FROM_COLLECTION
argument_list|)
decl_stmt|;
if|if
condition|(
name|DistribPhase
operator|.
name|FROMLEADER
operator|==
name|phase
operator|&&
operator|!
name|isSubShardLeader
operator|&&
name|fromCollection
operator|==
literal|null
condition|)
block|{
comment|// we are coming from the leader, just go local - add no urls
name|forwardToLeader
operator|=
literal|false
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isLeader
operator|||
name|isSubShardLeader
condition|)
block|{
comment|// that means I want to forward onto my replicas...
comment|// so get the replicas...
name|forwardToLeader
operator|=
literal|false
expr_stmt|;
name|List
argument_list|<
name|ZkCoreNodeProps
argument_list|>
name|replicaProps
init|=
name|zkController
operator|.
name|getZkStateReader
argument_list|()
operator|.
name|getReplicaProps
argument_list|(
name|collection
argument_list|,
name|shardId
argument_list|,
name|leaderReplica
operator|.
name|getName
argument_list|()
argument_list|,
literal|null
argument_list|,
name|ZkStateReader
operator|.
name|DOWN
argument_list|)
decl_stmt|;
if|if
condition|(
name|replicaProps
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|nodes
operator|==
literal|null
condition|)
block|{
name|nodes
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|replicaProps
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// check for test param that lets us miss replicas
name|String
index|[]
name|skipList
init|=
name|req
operator|.
name|getParams
argument_list|()
operator|.
name|getParams
argument_list|(
name|TEST_DISTRIB_SKIP_SERVERS
argument_list|)
decl_stmt|;
name|Set
argument_list|<
name|String
argument_list|>
name|skipListSet
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|skipList
operator|!=
literal|null
condition|)
block|{
name|skipListSet
operator|=
operator|new
name|HashSet
argument_list|<>
argument_list|(
name|skipList
operator|.
name|length
argument_list|)
expr_stmt|;
name|skipListSet
operator|.
name|addAll
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|skipList
argument_list|)
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"test.distrib.skip.servers was found and contains:"
operator|+
name|skipListSet
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|ZkCoreNodeProps
name|props
range|:
name|replicaProps
control|)
block|{
if|if
condition|(
name|skipList
operator|!=
literal|null
condition|)
block|{
name|boolean
name|skip
init|=
name|skipListSet
operator|.
name|contains
argument_list|(
name|props
operator|.
name|getCoreUrl
argument_list|()
argument_list|)
decl_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"check url:"
operator|+
name|props
operator|.
name|getCoreUrl
argument_list|()
operator|+
literal|" against:"
operator|+
name|skipListSet
operator|+
literal|" result:"
operator|+
name|skip
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|skip
condition|)
block|{
name|nodes
operator|.
name|add
argument_list|(
operator|new
name|StdNode
argument_list|(
name|props
argument_list|,
name|collection
argument_list|,
name|shardId
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|nodes
operator|.
name|add
argument_list|(
operator|new
name|StdNode
argument_list|(
name|props
argument_list|,
name|collection
argument_list|,
name|shardId
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
block|{
comment|// I need to forward onto the leader...
name|nodes
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|nodes
operator|.
name|add
argument_list|(
operator|new
name|RetryNode
argument_list|(
operator|new
name|ZkCoreNodeProps
argument_list|(
name|leaderReplica
argument_list|)
argument_list|,
name|zkController
operator|.
name|getZkStateReader
argument_list|()
argument_list|,
name|collection
argument_list|,
name|shardId
argument_list|)
argument_list|)
expr_stmt|;
name|forwardToLeader
operator|=
literal|true
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
throw|throw
operator|new
name|ZooKeeperException
argument_list|(
name|SolrException
operator|.
name|ErrorCode
operator|.
name|SERVER_ERROR
argument_list|,
literal|""
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
return|return
name|nodes
return|;
block|}
DECL|method|couldIbeSubShardLeader
specifier|private
name|boolean
name|couldIbeSubShardLeader
parameter_list|(
name|DocCollection
name|coll
parameter_list|)
block|{
comment|// Could I be the leader of a shard in "construction/recovery" state?
name|String
name|myShardId
init|=
name|req
operator|.
name|getCore
argument_list|()
operator|.
name|getCoreDescriptor
argument_list|()
operator|.
name|getCloudDescriptor
argument_list|()
operator|.
name|getShardId
argument_list|()
decl_stmt|;
name|Slice
name|mySlice
init|=
name|coll
operator|.
name|getSlice
argument_list|(
name|myShardId
argument_list|)
decl_stmt|;
name|String
name|state
init|=
name|mySlice
operator|.
name|getState
argument_list|()
decl_stmt|;
return|return
operator|(
name|Slice
operator|.
name|CONSTRUCTION
operator|.
name|equals
argument_list|(
name|state
argument_list|)
operator|||
name|Slice
operator|.
name|RECOVERY
operator|.
name|equals
argument_list|(
name|state
argument_list|)
operator|)
return|;
block|}
DECL|method|amISubShardLeader
specifier|private
name|boolean
name|amISubShardLeader
parameter_list|(
name|DocCollection
name|coll
parameter_list|,
name|Slice
name|parentSlice
parameter_list|,
name|String
name|id
parameter_list|,
name|SolrInputDocument
name|doc
parameter_list|)
throws|throws
name|InterruptedException
block|{
comment|// Am I the leader of a shard in "construction/recovery" state?
name|String
name|myShardId
init|=
name|req
operator|.
name|getCore
argument_list|()
operator|.
name|getCoreDescriptor
argument_list|()
operator|.
name|getCloudDescriptor
argument_list|()
operator|.
name|getShardId
argument_list|()
decl_stmt|;
name|Slice
name|mySlice
init|=
name|coll
operator|.
name|getSlice
argument_list|(
name|myShardId
argument_list|)
decl_stmt|;
name|String
name|state
init|=
name|mySlice
operator|.
name|getState
argument_list|()
decl_stmt|;
if|if
condition|(
name|Slice
operator|.
name|CONSTRUCTION
operator|.
name|equals
argument_list|(
name|state
argument_list|)
operator|||
name|Slice
operator|.
name|RECOVERY
operator|.
name|equals
argument_list|(
name|state
argument_list|)
condition|)
block|{
name|Replica
name|myLeader
init|=
name|zkController
operator|.
name|getZkStateReader
argument_list|()
operator|.
name|getLeaderRetry
argument_list|(
name|collection
argument_list|,
name|myShardId
argument_list|)
decl_stmt|;
name|boolean
name|amILeader
init|=
name|myLeader
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
name|req
operator|.
name|getCore
argument_list|()
operator|.
name|getCoreDescriptor
argument_list|()
operator|.
name|getCloudDescriptor
argument_list|()
operator|.
name|getCoreNodeName
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|amILeader
condition|)
block|{
comment|// Does the document belong to my hash range as well?
name|DocRouter
operator|.
name|Range
name|myRange
init|=
name|mySlice
operator|.
name|getRange
argument_list|()
decl_stmt|;
if|if
condition|(
name|myRange
operator|==
literal|null
condition|)
name|myRange
operator|=
operator|new
name|DocRouter
operator|.
name|Range
argument_list|(
name|Integer
operator|.
name|MIN_VALUE
argument_list|,
name|Integer
operator|.
name|MAX_VALUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|parentSlice
operator|!=
literal|null
condition|)
block|{
name|boolean
name|isSubset
init|=
name|parentSlice
operator|.
name|getRange
argument_list|()
operator|!=
literal|null
operator|&&
name|myRange
operator|.
name|isSubsetOf
argument_list|(
name|parentSlice
operator|.
name|getRange
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|isSubset
operator|&&
name|coll
operator|.
name|getRouter
argument_list|()
operator|.
name|isTargetSlice
argument_list|(
name|id
argument_list|,
name|doc
argument_list|,
name|req
operator|.
name|getParams
argument_list|()
argument_list|,
name|myShardId
argument_list|,
name|coll
argument_list|)
return|;
block|}
else|else
block|{
comment|// delete by query case -- as long as I am a sub shard leader we're fine
return|return
literal|true
return|;
block|}
block|}
block|}
return|return
literal|false
return|;
block|}
DECL|method|getSubShardLeaders
specifier|private
name|List
argument_list|<
name|Node
argument_list|>
name|getSubShardLeaders
parameter_list|(
name|DocCollection
name|coll
parameter_list|,
name|String
name|shardId
parameter_list|,
name|String
name|docId
parameter_list|,
name|SolrInputDocument
name|doc
parameter_list|)
block|{
name|Collection
argument_list|<
name|Slice
argument_list|>
name|allSlices
init|=
name|coll
operator|.
name|getSlices
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|Node
argument_list|>
name|nodes
init|=
literal|null
decl_stmt|;
for|for
control|(
name|Slice
name|aslice
range|:
name|allSlices
control|)
block|{
if|if
condition|(
name|Slice
operator|.
name|CONSTRUCTION
operator|.
name|equals
argument_list|(
name|aslice
operator|.
name|getState
argument_list|()
argument_list|)
operator|||
name|Slice
operator|.
name|RECOVERY
operator|.
name|equals
argument_list|(
name|aslice
operator|.
name|getState
argument_list|()
argument_list|)
condition|)
block|{
name|DocRouter
operator|.
name|Range
name|myRange
init|=
name|coll
operator|.
name|getSlice
argument_list|(
name|shardId
argument_list|)
operator|.
name|getRange
argument_list|()
decl_stmt|;
if|if
condition|(
name|myRange
operator|==
literal|null
condition|)
name|myRange
operator|=
operator|new
name|DocRouter
operator|.
name|Range
argument_list|(
name|Integer
operator|.
name|MIN_VALUE
argument_list|,
name|Integer
operator|.
name|MAX_VALUE
argument_list|)
expr_stmt|;
name|boolean
name|isSubset
init|=
name|aslice
operator|.
name|getRange
argument_list|()
operator|!=
literal|null
operator|&&
name|aslice
operator|.
name|getRange
argument_list|()
operator|.
name|isSubsetOf
argument_list|(
name|myRange
argument_list|)
decl_stmt|;
if|if
condition|(
name|isSubset
operator|&&
operator|(
name|docId
operator|==
literal|null
comment|// in case of deletes
operator|||
operator|(
name|docId
operator|!=
literal|null
operator|&&
name|coll
operator|.
name|getRouter
argument_list|()
operator|.
name|isTargetSlice
argument_list|(
name|docId
argument_list|,
name|doc
argument_list|,
name|req
operator|.
name|getParams
argument_list|()
argument_list|,
name|aslice
operator|.
name|getName
argument_list|()
argument_list|,
name|coll
argument_list|)
operator|)
operator|)
condition|)
block|{
name|Replica
name|sliceLeader
init|=
name|aslice
operator|.
name|getLeader
argument_list|()
decl_stmt|;
comment|// slice leader can be null because node/shard is created zk before leader election
if|if
condition|(
name|sliceLeader
operator|!=
literal|null
operator|&&
name|zkController
operator|.
name|getClusterState
argument_list|()
operator|.
name|liveNodesContain
argument_list|(
name|sliceLeader
operator|.
name|getNodeName
argument_list|()
argument_list|)
condition|)
block|{
if|if
condition|(
name|nodes
operator|==
literal|null
condition|)
name|nodes
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
expr_stmt|;
name|ZkCoreNodeProps
name|nodeProps
init|=
operator|new
name|ZkCoreNodeProps
argument_list|(
name|sliceLeader
argument_list|)
decl_stmt|;
name|nodes
operator|.
name|add
argument_list|(
operator|new
name|StdNode
argument_list|(
name|nodeProps
argument_list|,
name|coll
operator|.
name|getName
argument_list|()
argument_list|,
name|shardId
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
name|nodes
return|;
block|}
DECL|method|getNodesByRoutingRules
specifier|private
name|List
argument_list|<
name|Node
argument_list|>
name|getNodesByRoutingRules
parameter_list|(
name|ClusterState
name|cstate
parameter_list|,
name|DocCollection
name|coll
parameter_list|,
name|String
name|id
parameter_list|,
name|SolrInputDocument
name|doc
parameter_list|)
block|{
name|DocRouter
name|router
init|=
name|coll
operator|.
name|getRouter
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|Node
argument_list|>
name|nodes
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|router
operator|instanceof
name|CompositeIdRouter
condition|)
block|{
name|CompositeIdRouter
name|compositeIdRouter
init|=
operator|(
name|CompositeIdRouter
operator|)
name|router
decl_stmt|;
name|String
name|myShardId
init|=
name|req
operator|.
name|getCore
argument_list|()
operator|.
name|getCoreDescriptor
argument_list|()
operator|.
name|getCloudDescriptor
argument_list|()
operator|.
name|getShardId
argument_list|()
decl_stmt|;
name|Slice
name|slice
init|=
name|coll
operator|.
name|getSlice
argument_list|(
name|myShardId
argument_list|)
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|RoutingRule
argument_list|>
name|routingRules
init|=
name|slice
operator|.
name|getRoutingRules
argument_list|()
decl_stmt|;
if|if
condition|(
name|routingRules
operator|!=
literal|null
condition|)
block|{
comment|// delete by query case
if|if
condition|(
name|id
operator|==
literal|null
condition|)
block|{
for|for
control|(
name|Entry
argument_list|<
name|String
argument_list|,
name|RoutingRule
argument_list|>
name|entry
range|:
name|routingRules
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|String
name|targetCollectionName
init|=
name|entry
operator|.
name|getValue
argument_list|()
operator|.
name|getTargetCollectionName
argument_list|()
decl_stmt|;
name|Collection
argument_list|<
name|Slice
argument_list|>
name|activeSlices
init|=
name|cstate
operator|.
name|getActiveSlices
argument_list|(
name|targetCollectionName
argument_list|)
decl_stmt|;
if|if
condition|(
name|activeSlices
operator|!=
literal|null
operator|&&
operator|!
name|activeSlices
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|Slice
name|any
init|=
name|activeSlices
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|nodes
operator|==
literal|null
condition|)
name|nodes
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
expr_stmt|;
name|nodes
operator|.
name|add
argument_list|(
operator|new
name|StdNode
argument_list|(
operator|new
name|ZkCoreNodeProps
argument_list|(
name|any
operator|.
name|getLeader
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|nodes
return|;
block|}
name|String
name|routeKey
init|=
name|SolrIndexSplitter
operator|.
name|getRouteKey
argument_list|(
name|id
argument_list|)
decl_stmt|;
if|if
condition|(
name|routeKey
operator|!=
literal|null
condition|)
block|{
name|RoutingRule
name|rule
init|=
name|routingRules
operator|.
name|get
argument_list|(
name|routeKey
operator|+
literal|"!"
argument_list|)
decl_stmt|;
if|if
condition|(
name|rule
operator|!=
literal|null
condition|)
block|{
comment|// TODO: look at using nanoTime
if|if
condition|(
name|rule
operator|.
name|getExpireAt
argument_list|()
operator|>=
name|System
operator|.
name|currentTimeMillis
argument_list|()
condition|)
block|{
name|List
argument_list|<
name|DocRouter
operator|.
name|Range
argument_list|>
name|ranges
init|=
name|rule
operator|.
name|getRouteRanges
argument_list|()
decl_stmt|;
if|if
condition|(
name|ranges
operator|!=
literal|null
operator|&&
operator|!
name|ranges
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|int
name|hash
init|=
name|compositeIdRouter
operator|.
name|sliceHash
argument_list|(
name|id
argument_list|,
name|doc
argument_list|,
literal|null
argument_list|,
name|coll
argument_list|)
decl_stmt|;
for|for
control|(
name|DocRouter
operator|.
name|Range
name|range
range|:
name|ranges
control|)
block|{
if|if
condition|(
name|range
operator|.
name|includes
argument_list|(
name|hash
argument_list|)
condition|)
block|{
if|if
condition|(
name|nodes
operator|==
literal|null
condition|)
name|nodes
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
expr_stmt|;
name|DocCollection
name|targetColl
init|=
name|cstate
operator|.
name|getCollection
argument_list|(
name|rule
operator|.
name|getTargetCollectionName
argument_list|()
argument_list|)
decl_stmt|;
name|Collection
argument_list|<
name|Slice
argument_list|>
name|activeSlices
init|=
name|targetColl
operator|.
name|getRouter
argument_list|()
operator|.
name|getSearchSlicesSingle
argument_list|(
name|id
argument_list|,
literal|null
argument_list|,
name|targetColl
argument_list|)
decl_stmt|;
if|if
condition|(
name|activeSlices
operator|==
literal|null
operator|||
name|activeSlices
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|SERVER_ERROR
argument_list|,
literal|"No active slices serving "
operator|+
name|id
operator|+
literal|" found for target collection: "
operator|+
name|rule
operator|.
name|getTargetCollectionName
argument_list|()
argument_list|)
throw|;
block|}
name|Replica
name|targetLeader
init|=
name|cstate
operator|.
name|getLeader
argument_list|(
name|rule
operator|.
name|getTargetCollectionName
argument_list|()
argument_list|,
name|activeSlices
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
name|nodes
operator|.
name|add
argument_list|(
operator|new
name|StdNode
argument_list|(
operator|new
name|ZkCoreNodeProps
argument_list|(
name|targetLeader
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
else|else
block|{
name|ReentrantLock
name|ruleExpiryLock
init|=
name|req
operator|.
name|getCore
argument_list|()
operator|.
name|getRuleExpiryLock
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|ruleExpiryLock
operator|.
name|isLocked
argument_list|()
condition|)
block|{
try|try
block|{
if|if
condition|(
name|ruleExpiryLock
operator|.
name|tryLock
argument_list|(
literal|10
argument_list|,
name|TimeUnit
operator|.
name|MILLISECONDS
argument_list|)
condition|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"Going to expire routing rule"
argument_list|)
expr_stmt|;
try|try
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|map
init|=
name|ZkNodeProps
operator|.
name|makeMap
argument_list|(
name|Overseer
operator|.
name|QUEUE_OPERATION
argument_list|,
name|OverseerAction
operator|.
name|REMOVEROUTINGRULE
operator|.
name|toLower
argument_list|()
argument_list|,
name|ZkStateReader
operator|.
name|COLLECTION_PROP
argument_list|,
name|collection
argument_list|,
name|ZkStateReader
operator|.
name|SHARD_ID_PROP
argument_list|,
name|myShardId
argument_list|,
literal|"routeKey"
argument_list|,
name|routeKey
operator|+
literal|"!"
argument_list|)
decl_stmt|;
name|SolrZkClient
name|zkClient
init|=
name|req
operator|.
name|getCore
argument_list|()
operator|.
name|getCoreDescriptor
argument_list|()
operator|.
name|getCoreContainer
argument_list|()
operator|.
name|getZkController
argument_list|()
operator|.
name|getZkClient
argument_list|()
decl_stmt|;
name|DistributedQueue
name|queue
init|=
name|Overseer
operator|.
name|getInQueue
argument_list|(
name|zkClient
argument_list|)
decl_stmt|;
name|queue
operator|.
name|offer
argument_list|(
name|ZkStateReader
operator|.
name|toJSON
argument_list|(
name|map
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|KeeperException
name|e
parameter_list|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Exception while removing routing rule for route key: "
operator|+
name|routeKey
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"Exception while removing routing rule for route key: "
operator|+
name|routeKey
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|ruleExpiryLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
block|}
block|}
return|return
name|nodes
return|;
block|}
DECL|method|doDefensiveChecks
specifier|private
name|void
name|doDefensiveChecks
parameter_list|(
name|DistribPhase
name|phase
parameter_list|)
block|{
name|boolean
name|isReplayOrPeersync
init|=
operator|(
name|updateCommand
operator|.
name|getFlags
argument_list|()
operator|&
operator|(
name|UpdateCommand
operator|.
name|REPLAY
operator||
name|UpdateCommand
operator|.
name|PEER_SYNC
operator|)
operator|)
operator|!=
literal|0
decl_stmt|;
if|if
condition|(
name|isReplayOrPeersync
condition|)
return|return;
name|String
name|from
init|=
name|req
operator|.
name|getParams
argument_list|()
operator|.
name|get
argument_list|(
name|DISTRIB_FROM
argument_list|)
decl_stmt|;
name|ClusterState
name|clusterState
init|=
name|zkController
operator|.
name|getClusterState
argument_list|()
decl_stmt|;
name|CloudDescriptor
name|cloudDescriptor
init|=
name|req
operator|.
name|getCore
argument_list|()
operator|.
name|getCoreDescriptor
argument_list|()
operator|.
name|getCloudDescriptor
argument_list|()
decl_stmt|;
name|Slice
name|mySlice
init|=
name|clusterState
operator|.
name|getSlice
argument_list|(
name|collection
argument_list|,
name|cloudDescriptor
operator|.
name|getShardId
argument_list|()
argument_list|)
decl_stmt|;
name|boolean
name|localIsLeader
init|=
name|cloudDescriptor
operator|.
name|isLeader
argument_list|()
decl_stmt|;
if|if
condition|(
name|DistribPhase
operator|.
name|FROMLEADER
operator|==
name|phase
operator|&&
name|localIsLeader
operator|&&
name|from
operator|!=
literal|null
condition|)
block|{
comment|// from will be null on log replay
name|String
name|fromShard
init|=
name|req
operator|.
name|getParams
argument_list|()
operator|.
name|get
argument_list|(
name|DISTRIB_FROM_PARENT
argument_list|)
decl_stmt|;
if|if
condition|(
name|fromShard
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|Slice
operator|.
name|ACTIVE
operator|.
name|equals
argument_list|(
name|mySlice
operator|.
name|getState
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|SERVICE_UNAVAILABLE
argument_list|,
literal|"Request says it is coming from parent shard leader but we are in active state"
argument_list|)
throw|;
block|}
comment|// shard splitting case -- check ranges to see if we are a sub-shard
name|Slice
name|fromSlice
init|=
name|zkController
operator|.
name|getClusterState
argument_list|()
operator|.
name|getCollection
argument_list|(
name|collection
argument_list|)
operator|.
name|getSlice
argument_list|(
name|fromShard
argument_list|)
decl_stmt|;
name|DocRouter
operator|.
name|Range
name|parentRange
init|=
name|fromSlice
operator|.
name|getRange
argument_list|()
decl_stmt|;
if|if
condition|(
name|parentRange
operator|==
literal|null
condition|)
name|parentRange
operator|=
operator|new
name|DocRouter
operator|.
name|Range
argument_list|(
name|Integer
operator|.
name|MIN_VALUE
argument_list|,
name|Integer
operator|.
name|MAX_VALUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|mySlice
operator|.
name|getRange
argument_list|()
operator|!=
literal|null
operator|&&
operator|!
name|mySlice
operator|.
name|getRange
argument_list|()
operator|.
name|isSubsetOf
argument_list|(
name|parentRange
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|SERVICE_UNAVAILABLE
argument_list|,
literal|"Request says it is coming from parent shard leader but parent hash range is not superset of my range"
argument_list|)
throw|;
block|}
block|}
else|else
block|{
name|String
name|fromCollection
init|=
name|req
operator|.
name|getParams
argument_list|()
operator|.
name|get
argument_list|(
name|DISTRIB_FROM_COLLECTION
argument_list|)
decl_stmt|;
comment|// is it because of a routing rule?
if|if
condition|(
name|fromCollection
operator|==
literal|null
condition|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"Request says it is coming from leader, but we are the leader: "
operator|+
name|req
operator|.
name|getParamString
argument_list|()
argument_list|)
expr_stmt|;
name|SolrException
name|solrExc
init|=
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|SERVICE_UNAVAILABLE
argument_list|,
literal|"Request says it is coming from leader, but we are the leader"
argument_list|)
decl_stmt|;
name|solrExc
operator|.
name|setMetadata
argument_list|(
literal|"cause"
argument_list|,
literal|"LeaderChanged"
argument_list|)
expr_stmt|;
throw|throw
name|solrExc
throw|;
block|}
block|}
block|}
if|if
condition|(
operator|(
name|isLeader
operator|&&
operator|!
name|localIsLeader
operator|)
operator|||
operator|(
name|isSubShardLeader
operator|&&
operator|!
name|localIsLeader
operator|)
condition|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"ClusterState says we are the leader, but locally we don't think so"
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|SERVICE_UNAVAILABLE
argument_list|,
literal|"ClusterState says we are the leader ("
operator|+
name|zkController
operator|.
name|getBaseUrl
argument_list|()
operator|+
literal|"/"
operator|+
name|req
operator|.
name|getCore
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|"), but locally we don't think so. Request came from "
operator|+
name|from
argument_list|)
throw|;
block|}
block|}
comment|// used for deleteByQuery to get the list of nodes this leader should forward to
DECL|method|setupRequest
specifier|private
name|List
argument_list|<
name|Node
argument_list|>
name|setupRequest
parameter_list|()
block|{
name|List
argument_list|<
name|Node
argument_list|>
name|nodes
init|=
literal|null
decl_stmt|;
name|String
name|shardId
init|=
name|cloudDesc
operator|.
name|getShardId
argument_list|()
decl_stmt|;
try|try
block|{
name|Replica
name|leaderReplica
init|=
name|zkController
operator|.
name|getZkStateReader
argument_list|()
operator|.
name|getLeaderRetry
argument_list|(
name|collection
argument_list|,
name|shardId
argument_list|)
decl_stmt|;
name|isLeader
operator|=
name|leaderReplica
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
name|req
operator|.
name|getCore
argument_list|()
operator|.
name|getCoreDescriptor
argument_list|()
operator|.
name|getCloudDescriptor
argument_list|()
operator|.
name|getCoreNodeName
argument_list|()
argument_list|)
expr_stmt|;
comment|// TODO: what if we are no longer the leader?
name|forwardToLeader
operator|=
literal|false
expr_stmt|;
name|List
argument_list|<
name|ZkCoreNodeProps
argument_list|>
name|replicaProps
init|=
name|zkController
operator|.
name|getZkStateReader
argument_list|()
operator|.
name|getReplicaProps
argument_list|(
name|collection
argument_list|,
name|shardId
argument_list|,
name|leaderReplica
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|replicaProps
operator|!=
literal|null
condition|)
block|{
name|nodes
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|replicaProps
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|ZkCoreNodeProps
name|props
range|:
name|replicaProps
control|)
block|{
name|nodes
operator|.
name|add
argument_list|(
operator|new
name|StdNode
argument_list|(
name|props
argument_list|,
name|collection
argument_list|,
name|shardId
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
throw|throw
operator|new
name|ZooKeeperException
argument_list|(
name|SolrException
operator|.
name|ErrorCode
operator|.
name|SERVER_ERROR
argument_list|,
literal|""
argument_list|,
name|e
argument_list|)
throw|;
block|}
return|return
name|nodes
return|;
block|}
annotation|@
name|Override
DECL|method|processAdd
specifier|public
name|void
name|processAdd
parameter_list|(
name|AddUpdateCommand
name|cmd
parameter_list|)
throws|throws
name|IOException
block|{
name|updateCommand
operator|=
name|cmd
expr_stmt|;
if|if
condition|(
name|zkEnabled
condition|)
block|{
name|zkCheck
argument_list|()
expr_stmt|;
name|nodes
operator|=
name|setupRequest
argument_list|(
name|cmd
operator|.
name|getHashableId
argument_list|()
argument_list|,
name|cmd
operator|.
name|getSolrInputDocument
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|isLeader
operator|=
name|getNonZkLeaderAssumption
argument_list|(
name|req
argument_list|)
expr_stmt|;
block|}
comment|// check if client has requested minimum replication factor information
name|int
name|minRf
init|=
operator|-
literal|1
decl_stmt|;
comment|// disabled by default
if|if
condition|(
name|replicationTracker
operator|!=
literal|null
condition|)
block|{
name|minRf
operator|=
name|replicationTracker
operator|.
name|minRf
expr_stmt|;
comment|// for subsequent requests in the same batch
block|}
else|else
block|{
name|SolrParams
name|rp
init|=
name|cmd
operator|.
name|getReq
argument_list|()
operator|.
name|getParams
argument_list|()
decl_stmt|;
name|String
name|distribUpdate
init|=
name|rp
operator|.
name|get
argument_list|(
name|DISTRIB_UPDATE_PARAM
argument_list|)
decl_stmt|;
comment|// somewhat tricky logic here: we only activate the replication tracker if we're on
comment|// a leader or this is the top-level request processor
if|if
condition|(
name|distribUpdate
operator|==
literal|null
operator|||
name|distribUpdate
operator|.
name|equals
argument_list|(
name|DistribPhase
operator|.
name|TOLEADER
operator|.
name|toString
argument_list|()
argument_list|)
condition|)
block|{
name|String
name|minRepFact
init|=
name|rp
operator|.
name|get
argument_list|(
name|UpdateRequest
operator|.
name|MIN_REPFACT
argument_list|)
decl_stmt|;
if|if
condition|(
name|minRepFact
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|minRf
operator|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|minRepFact
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|nfe
parameter_list|)
block|{
name|minRf
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|minRf
operator|<=
literal|0
condition|)
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
literal|"Invalid value "
operator|+
name|minRepFact
operator|+
literal|" for "
operator|+
name|UpdateRequest
operator|.
name|MIN_REPFACT
operator|+
literal|"; must be>0 and less than or equal to the collection replication factor."
argument_list|)
throw|;
block|}
if|if
condition|(
name|minRf
operator|>
literal|1
condition|)
block|{
name|String
name|myShardId
init|=
name|forwardToLeader
condition|?
literal|null
else|:
name|cloudDesc
operator|.
name|getShardId
argument_list|()
decl_stmt|;
name|replicationTracker
operator|=
operator|new
name|RequestReplicationTracker
argument_list|(
name|myShardId
argument_list|,
name|minRf
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// TODO: if minRf> 1 and we know the leader is the only active replica, we could fail
comment|// the request right here but for now I think it is better to just return the status
comment|// to the client that the minRf wasn't reached and let them handle it
name|boolean
name|dropCmd
init|=
literal|false
decl_stmt|;
if|if
condition|(
operator|!
name|forwardToLeader
condition|)
block|{
name|dropCmd
operator|=
name|versionAdd
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dropCmd
condition|)
block|{
comment|// TODO: do we need to add anything to the response?
return|return;
block|}
if|if
condition|(
name|zkEnabled
operator|&&
name|isLeader
operator|&&
operator|!
name|isSubShardLeader
condition|)
block|{
name|DocCollection
name|coll
init|=
name|zkController
operator|.
name|getClusterState
argument_list|()
operator|.
name|getCollection
argument_list|(
name|collection
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Node
argument_list|>
name|subShardLeaders
init|=
name|getSubShardLeaders
argument_list|(
name|coll
argument_list|,
name|cloudDesc
operator|.
name|getShardId
argument_list|()
argument_list|,
name|cmd
operator|.
name|getHashableId
argument_list|()
argument_list|,
name|cmd
operator|.
name|getSolrInputDocument
argument_list|()
argument_list|)
decl_stmt|;
comment|// the list<node> will actually have only one element for an add request
if|if
condition|(
name|subShardLeaders
operator|!=
literal|null
operator|&&
operator|!
name|subShardLeaders
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|ModifiableSolrParams
name|params
init|=
operator|new
name|ModifiableSolrParams
argument_list|(
name|filterParams
argument_list|(
name|req
operator|.
name|getParams
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|params
operator|.
name|set
argument_list|(
name|DISTRIB_UPDATE_PARAM
argument_list|,
name|DistribPhase
operator|.
name|FROMLEADER
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|params
operator|.
name|set
argument_list|(
name|DISTRIB_FROM
argument_list|,
name|ZkCoreNodeProps
operator|.
name|getCoreUrl
argument_list|(
name|zkController
operator|.
name|getBaseUrl
argument_list|()
argument_list|,
name|req
operator|.
name|getCore
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|params
operator|.
name|set
argument_list|(
name|DISTRIB_FROM_PARENT
argument_list|,
name|req
operator|.
name|getCore
argument_list|()
operator|.
name|getCoreDescriptor
argument_list|()
operator|.
name|getCloudDescriptor
argument_list|()
operator|.
name|getShardId
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|Node
name|subShardLeader
range|:
name|subShardLeaders
control|)
block|{
name|cmdDistrib
operator|.
name|distribAdd
argument_list|(
name|cmd
argument_list|,
name|Collections
operator|.
name|singletonList
argument_list|(
name|subShardLeader
argument_list|)
argument_list|,
name|params
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
name|List
argument_list|<
name|Node
argument_list|>
name|nodesByRoutingRules
init|=
name|getNodesByRoutingRules
argument_list|(
name|zkController
operator|.
name|getClusterState
argument_list|()
argument_list|,
name|coll
argument_list|,
name|cmd
operator|.
name|getHashableId
argument_list|()
argument_list|,
name|cmd
operator|.
name|getSolrInputDocument
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|nodesByRoutingRules
operator|!=
literal|null
operator|&&
operator|!
name|nodesByRoutingRules
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|ModifiableSolrParams
name|params
init|=
operator|new
name|ModifiableSolrParams
argument_list|(
name|filterParams
argument_list|(
name|req
operator|.
name|getParams
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|params
operator|.
name|set
argument_list|(
name|DISTRIB_UPDATE_PARAM
argument_list|,
name|DistribPhase
operator|.
name|FROMLEADER
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|params
operator|.
name|set
argument_list|(
name|DISTRIB_FROM
argument_list|,
name|ZkCoreNodeProps
operator|.
name|getCoreUrl
argument_list|(
name|zkController
operator|.
name|getBaseUrl
argument_list|()
argument_list|,
name|req
operator|.
name|getCore
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|params
operator|.
name|set
argument_list|(
name|DISTRIB_FROM_COLLECTION
argument_list|,
name|req
operator|.
name|getCore
argument_list|()
operator|.
name|getCoreDescriptor
argument_list|()
operator|.
name|getCloudDescriptor
argument_list|()
operator|.
name|getCollectionName
argument_list|()
argument_list|)
expr_stmt|;
name|params
operator|.
name|set
argument_list|(
name|DISTRIB_FROM_SHARD
argument_list|,
name|req
operator|.
name|getCore
argument_list|()
operator|.
name|getCoreDescriptor
argument_list|()
operator|.
name|getCloudDescriptor
argument_list|()
operator|.
name|getShardId
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|Node
name|nodesByRoutingRule
range|:
name|nodesByRoutingRules
control|)
block|{
name|cmdDistrib
operator|.
name|distribAdd
argument_list|(
name|cmd
argument_list|,
name|Collections
operator|.
name|singletonList
argument_list|(
name|nodesByRoutingRule
argument_list|)
argument_list|,
name|params
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|ModifiableSolrParams
name|params
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|nodes
operator|!=
literal|null
condition|)
block|{
name|params
operator|=
operator|new
name|ModifiableSolrParams
argument_list|(
name|filterParams
argument_list|(
name|req
operator|.
name|getParams
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|params
operator|.
name|set
argument_list|(
name|DISTRIB_UPDATE_PARAM
argument_list|,
operator|(
name|isLeader
operator|||
name|isSubShardLeader
condition|?
name|DistribPhase
operator|.
name|FROMLEADER
operator|.
name|toString
argument_list|()
else|:
name|DistribPhase
operator|.
name|TOLEADER
operator|.
name|toString
argument_list|()
operator|)
argument_list|)
expr_stmt|;
name|params
operator|.
name|set
argument_list|(
name|DISTRIB_FROM
argument_list|,
name|ZkCoreNodeProps
operator|.
name|getCoreUrl
argument_list|(
name|zkController
operator|.
name|getBaseUrl
argument_list|()
argument_list|,
name|req
operator|.
name|getCore
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|replicationTracker
operator|!=
literal|null
operator|&&
name|minRf
operator|>
literal|1
condition|)
name|params
operator|.
name|set
argument_list|(
name|UpdateRequest
operator|.
name|MIN_REPFACT
argument_list|,
name|String
operator|.
name|valueOf
argument_list|(
name|minRf
argument_list|)
argument_list|)
expr_stmt|;
name|cmdDistrib
operator|.
name|distribAdd
argument_list|(
name|cmd
argument_list|,
name|nodes
argument_list|,
name|params
argument_list|,
literal|false
argument_list|,
name|replicationTracker
argument_list|)
expr_stmt|;
block|}
comment|// TODO: what to do when no idField?
if|if
condition|(
name|returnVersions
operator|&&
name|rsp
operator|!=
literal|null
operator|&&
name|idField
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|addsResponse
operator|==
literal|null
condition|)
block|{
name|addsResponse
operator|=
operator|new
name|NamedList
argument_list|<
name|String
argument_list|>
argument_list|()
expr_stmt|;
name|rsp
operator|.
name|add
argument_list|(
literal|"adds"
argument_list|,
name|addsResponse
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|scratch
operator|==
literal|null
condition|)
name|scratch
operator|=
operator|new
name|CharsRefBuilder
argument_list|()
expr_stmt|;
name|idField
operator|.
name|getType
argument_list|()
operator|.
name|indexedToReadable
argument_list|(
name|cmd
operator|.
name|getIndexedId
argument_list|()
argument_list|,
name|scratch
argument_list|)
expr_stmt|;
name|addsResponse
operator|.
name|add
argument_list|(
name|scratch
operator|.
name|toString
argument_list|()
argument_list|,
name|cmd
operator|.
name|getVersion
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// TODO: keep track of errors?  needs to be done at a higher level though since
comment|// an id may fail before it gets to this processor.
comment|// Given that, it may also make sense to move the version reporting out of this
comment|// processor too.
block|}
comment|// TODO: optionally fail if n replicas are not reached...
DECL|method|doFinish
specifier|private
name|void
name|doFinish
parameter_list|()
block|{
comment|// TODO: if not a forward and replication req is not specified, we could
comment|// send in a background thread
name|cmdDistrib
operator|.
name|finish
argument_list|()
expr_stmt|;
name|List
argument_list|<
name|Error
argument_list|>
name|errors
init|=
name|cmdDistrib
operator|.
name|getErrors
argument_list|()
decl_stmt|;
comment|// TODO - we may need to tell about more than one error...
comment|// if it's a forward, any fail is a problem -
comment|// otherwise we assume things are fine if we got it locally
comment|// until we start allowing min replication param
if|if
condition|(
name|errors
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
comment|// if one node is a RetryNode, this was a forward request
if|if
condition|(
name|errors
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|req
operator|.
name|node
operator|instanceof
name|RetryNode
condition|)
block|{
name|rsp
operator|.
name|setException
argument_list|(
name|errors
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|e
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|log
operator|.
name|isWarnEnabled
argument_list|()
condition|)
block|{
for|for
control|(
name|Error
name|error
range|:
name|errors
control|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Error sending update to "
operator|+
name|error
operator|.
name|req
operator|.
name|node
operator|.
name|getBaseUrl
argument_list|()
argument_list|,
name|error
operator|.
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// else
comment|// for now we don't error - we assume if it was added locally, we
comment|// succeeded
block|}
comment|// if it is not a forward request, for each fail, try to tell them to
comment|// recover - the doc was already added locally, so it should have been
comment|// legit
for|for
control|(
specifier|final
name|SolrCmdDistributor
operator|.
name|Error
name|error
range|:
name|errors
control|)
block|{
if|if
condition|(
name|error
operator|.
name|req
operator|.
name|node
operator|instanceof
name|RetryNode
condition|)
block|{
comment|// we don't try to force a leader to recover
comment|// when we cannot forward to it
continue|continue;
block|}
name|DistribPhase
name|phase
init|=
name|DistribPhase
operator|.
name|parseParam
argument_list|(
name|error
operator|.
name|req
operator|.
name|uReq
operator|.
name|getParams
argument_list|()
operator|.
name|get
argument_list|(
name|DISTRIB_UPDATE_PARAM
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|phase
operator|!=
name|DistribPhase
operator|.
name|FROMLEADER
condition|)
continue|continue;
comment|// don't have non-leaders try to recovery other nodes
comment|// commits are special -- they can run on any node irrespective of whether it is a leader or not
comment|// we don't want to run recovery on a node which missed a commit command
if|if
condition|(
name|error
operator|.
name|req
operator|.
name|uReq
operator|.
name|getParams
argument_list|()
operator|.
name|get
argument_list|(
name|COMMIT_END_POINT
argument_list|)
operator|!=
literal|null
condition|)
continue|continue;
specifier|final
name|String
name|replicaUrl
init|=
name|error
operator|.
name|req
operator|.
name|node
operator|.
name|getUrl
argument_list|()
decl_stmt|;
comment|// if the remote replica failed the request because of leader change (SOLR-6511), then fail the request
name|String
name|cause
init|=
operator|(
name|error
operator|.
name|e
operator|instanceof
name|SolrException
operator|)
condition|?
operator|(
operator|(
name|SolrException
operator|)
name|error
operator|.
name|e
operator|)
operator|.
name|getMetadata
argument_list|(
literal|"cause"
argument_list|)
else|:
literal|null
decl_stmt|;
if|if
condition|(
literal|"LeaderChanged"
operator|.
name|equals
argument_list|(
name|cause
argument_list|)
condition|)
block|{
comment|// let's just fail this request and let the client retry? or just call processAdd again?
name|log
operator|.
name|error
argument_list|(
literal|"On "
operator|+
name|cloudDesc
operator|.
name|getCoreNodeName
argument_list|()
operator|+
literal|", replica "
operator|+
name|replicaUrl
operator|+
literal|" now thinks it is the leader! Failing the request to let the client retry! "
operator|+
name|error
operator|.
name|e
argument_list|)
expr_stmt|;
name|rsp
operator|.
name|setException
argument_list|(
name|error
operator|.
name|e
argument_list|)
expr_stmt|;
break|break;
block|}
name|int
name|maxTries
init|=
literal|1
decl_stmt|;
name|boolean
name|sendRecoveryCommand
init|=
literal|true
decl_stmt|;
name|String
name|collection
init|=
literal|null
decl_stmt|;
name|String
name|shardId
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|error
operator|.
name|req
operator|.
name|node
operator|instanceof
name|StdNode
condition|)
block|{
name|StdNode
name|stdNode
init|=
operator|(
name|StdNode
operator|)
name|error
operator|.
name|req
operator|.
name|node
decl_stmt|;
name|collection
operator|=
name|stdNode
operator|.
name|getCollection
argument_list|()
expr_stmt|;
name|shardId
operator|=
name|stdNode
operator|.
name|getShardId
argument_list|()
expr_stmt|;
comment|// before we go setting other replicas to down, make sure we're still the leader!
name|String
name|leaderCoreNodeName
init|=
literal|null
decl_stmt|;
try|try
block|{
name|leaderCoreNodeName
operator|=
name|zkController
operator|.
name|getZkStateReader
argument_list|()
operator|.
name|getLeaderRetry
argument_list|(
name|collection
argument_list|,
name|shardId
argument_list|)
operator|.
name|getName
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|exc
parameter_list|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"Failed to determine if "
operator|+
name|cloudDesc
operator|.
name|getCoreNodeName
argument_list|()
operator|+
literal|" is still the leader for "
operator|+
name|collection
operator|+
literal|" "
operator|+
name|shardId
operator|+
literal|" before putting "
operator|+
name|replicaUrl
operator|+
literal|" into leader-initiated recovery due to: "
operator|+
name|exc
argument_list|)
expr_stmt|;
block|}
name|List
argument_list|<
name|ZkCoreNodeProps
argument_list|>
name|myReplicas
init|=
name|zkController
operator|.
name|getZkStateReader
argument_list|()
operator|.
name|getReplicaProps
argument_list|(
name|collection
argument_list|,
name|cloudDesc
operator|.
name|getShardId
argument_list|()
argument_list|,
name|cloudDesc
operator|.
name|getCoreNodeName
argument_list|()
argument_list|)
decl_stmt|;
name|boolean
name|foundErrorNodeInReplicaList
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|myReplicas
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|ZkCoreNodeProps
name|replicaProp
range|:
name|myReplicas
control|)
block|{
if|if
condition|(
operator|(
operator|(
name|Replica
operator|)
name|replicaProp
operator|.
name|getNodeProps
argument_list|()
operator|)
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
operator|(
operator|(
name|Replica
operator|)
name|stdNode
operator|.
name|getNodeProps
argument_list|()
operator|.
name|getNodeProps
argument_list|()
operator|)
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
block|{
name|foundErrorNodeInReplicaList
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|cloudDesc
operator|.
name|getCoreNodeName
argument_list|()
operator|.
name|equals
argument_list|(
name|leaderCoreNodeName
argument_list|)
operator|&&
name|foundErrorNodeInReplicaList
condition|)
block|{
try|try
block|{
comment|// if false, then the node is probably not "live" anymore
name|sendRecoveryCommand
operator|=
name|zkController
operator|.
name|ensureReplicaInLeaderInitiatedRecovery
argument_list|(
name|collection
argument_list|,
name|shardId
argument_list|,
name|stdNode
operator|.
name|getNodeProps
argument_list|()
argument_list|,
literal|false
argument_list|,
name|leaderCoreNodeName
argument_list|)
expr_stmt|;
comment|// we want to try more than once, ~10 minutes
if|if
condition|(
name|sendRecoveryCommand
condition|)
block|{
name|maxTries
operator|=
literal|120
expr_stmt|;
block|}
comment|// else the node is no longer "live" so no need to send any recovery command
block|}
catch|catch
parameter_list|(
name|Exception
name|exc
parameter_list|)
block|{
name|Throwable
name|setLirZnodeFailedCause
init|=
name|SolrException
operator|.
name|getRootCause
argument_list|(
name|exc
argument_list|)
decl_stmt|;
name|log
operator|.
name|error
argument_list|(
literal|"Leader failed to set replica "
operator|+
name|error
operator|.
name|req
operator|.
name|node
operator|.
name|getUrl
argument_list|()
operator|+
literal|" state to DOWN due to: "
operator|+
name|setLirZnodeFailedCause
argument_list|,
name|setLirZnodeFailedCause
argument_list|)
expr_stmt|;
if|if
condition|(
name|setLirZnodeFailedCause
operator|instanceof
name|KeeperException
operator|.
name|SessionExpiredException
operator|||
name|setLirZnodeFailedCause
operator|instanceof
name|KeeperException
operator|.
name|ConnectionLossException
condition|)
block|{
comment|// our session is expired, which means our state is suspect, so don't go
comment|// putting other replicas in recovery (see SOLR-6511)
name|sendRecoveryCommand
operator|=
literal|false
expr_stmt|;
block|}
comment|// else will go ahead and try to send the recovery command once after this error
block|}
block|}
else|else
block|{
comment|// not the leader anymore maybe or the error'd node is not my replica?
name|sendRecoveryCommand
operator|=
literal|false
expr_stmt|;
if|if
condition|(
operator|!
name|foundErrorNodeInReplicaList
condition|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Core "
operator|+
name|cloudDesc
operator|.
name|getCoreNodeName
argument_list|()
operator|+
literal|" belonging to "
operator|+
name|collection
operator|+
literal|" "
operator|+
name|shardId
operator|+
literal|", does not have error'd node "
operator|+
name|stdNode
operator|.
name|getNodeProps
argument_list|()
operator|.
name|getCoreUrl
argument_list|()
operator|+
literal|" as a replica. "
operator|+
literal|"No request recovery command will be sent!"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Core "
operator|+
name|cloudDesc
operator|.
name|getCoreNodeName
argument_list|()
operator|+
literal|" is no longer the leader for "
operator|+
name|collection
operator|+
literal|" "
operator|+
name|shardId
operator|+
literal|", no request recovery command will be sent!"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// else not a StdNode, recovery command still gets sent once
if|if
condition|(
operator|!
name|sendRecoveryCommand
condition|)
continue|continue;
comment|// the replica is already in recovery handling or is not live
name|Throwable
name|rootCause
init|=
name|SolrException
operator|.
name|getRootCause
argument_list|(
name|error
operator|.
name|e
argument_list|)
decl_stmt|;
name|log
operator|.
name|error
argument_list|(
literal|"Setting up to try to start recovery on replica "
operator|+
name|replicaUrl
operator|+
literal|" after: "
operator|+
name|rootCause
argument_list|)
expr_stmt|;
comment|// try to send the recovery command to the downed replica in a background thread
name|CoreContainer
name|coreContainer
init|=
name|req
operator|.
name|getCore
argument_list|()
operator|.
name|getCoreDescriptor
argument_list|()
operator|.
name|getCoreContainer
argument_list|()
decl_stmt|;
name|LeaderInitiatedRecoveryThread
name|lirThread
init|=
operator|new
name|LeaderInitiatedRecoveryThread
argument_list|(
name|zkController
argument_list|,
name|coreContainer
argument_list|,
name|collection
argument_list|,
name|shardId
argument_list|,
name|error
operator|.
name|req
operator|.
name|node
operator|.
name|getNodeProps
argument_list|()
argument_list|,
name|maxTries
argument_list|,
name|cloudDesc
operator|.
name|getCoreNodeName
argument_list|()
argument_list|)
decl_stmt|;
comment|// core node name of current leader
name|ExecutorService
name|executor
init|=
name|coreContainer
operator|.
name|getUpdateShardHandler
argument_list|()
operator|.
name|getUpdateExecutor
argument_list|()
decl_stmt|;
name|executor
operator|.
name|execute
argument_list|(
name|lirThread
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|replicationTracker
operator|!=
literal|null
condition|)
block|{
name|rsp
operator|.
name|getResponseHeader
argument_list|()
operator|.
name|add
argument_list|(
name|UpdateRequest
operator|.
name|REPFACT
argument_list|,
name|replicationTracker
operator|.
name|getAchievedRf
argument_list|()
argument_list|)
expr_stmt|;
name|rsp
operator|.
name|getResponseHeader
argument_list|()
operator|.
name|add
argument_list|(
name|UpdateRequest
operator|.
name|MIN_REPFACT
argument_list|,
name|replicationTracker
operator|.
name|minRf
argument_list|)
expr_stmt|;
name|replicationTracker
operator|=
literal|null
expr_stmt|;
block|}
block|}
comment|// must be synchronized by bucket
DECL|method|doLocalAdd
specifier|private
name|void
name|doLocalAdd
parameter_list|(
name|AddUpdateCommand
name|cmd
parameter_list|)
throws|throws
name|IOException
block|{
name|super
operator|.
name|processAdd
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
block|}
comment|// must be synchronized by bucket
DECL|method|doLocalDelete
specifier|private
name|void
name|doLocalDelete
parameter_list|(
name|DeleteUpdateCommand
name|cmd
parameter_list|)
throws|throws
name|IOException
block|{
name|super
operator|.
name|processDelete
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
block|}
comment|/**    * @return whether or not to drop this cmd    * @throws IOException If there is a low-level I/O error.    */
DECL|method|versionAdd
specifier|private
name|boolean
name|versionAdd
parameter_list|(
name|AddUpdateCommand
name|cmd
parameter_list|)
throws|throws
name|IOException
block|{
name|BytesRef
name|idBytes
init|=
name|cmd
operator|.
name|getIndexedId
argument_list|()
decl_stmt|;
if|if
condition|(
name|idBytes
operator|==
literal|null
condition|)
block|{
name|super
operator|.
name|processAdd
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|vinfo
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|AtomicUpdateDocumentMerger
operator|.
name|isAtomicUpdate
argument_list|(
name|cmd
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|SolrException
operator|.
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
literal|"Atomic document updates are not supported unless<updateLog/> is configured"
argument_list|)
throw|;
block|}
else|else
block|{
name|super
operator|.
name|processAdd
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
comment|// This is only the hash for the bucket, and must be based only on the uniqueKey (i.e. do not use a pluggable hash here)
name|int
name|bucketHash
init|=
name|Hash
operator|.
name|murmurhash3_x86_32
argument_list|(
name|idBytes
operator|.
name|bytes
argument_list|,
name|idBytes
operator|.
name|offset
argument_list|,
name|idBytes
operator|.
name|length
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|// at this point, there is an update we need to try and apply.
comment|// we may or may not be the leader.
comment|// Find any existing version in the document
comment|// TODO: don't reuse update commands any more!
name|long
name|versionOnUpdate
init|=
name|cmd
operator|.
name|getVersion
argument_list|()
decl_stmt|;
if|if
condition|(
name|versionOnUpdate
operator|==
literal|0
condition|)
block|{
name|SolrInputField
name|versionField
init|=
name|cmd
operator|.
name|getSolrInputDocument
argument_list|()
operator|.
name|getField
argument_list|(
name|VersionInfo
operator|.
name|VERSION_FIELD
argument_list|)
decl_stmt|;
if|if
condition|(
name|versionField
operator|!=
literal|null
condition|)
block|{
name|Object
name|o
init|=
name|versionField
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|versionOnUpdate
operator|=
name|o
operator|instanceof
name|Number
condition|?
operator|(
operator|(
name|Number
operator|)
name|o
operator|)
operator|.
name|longValue
argument_list|()
else|:
name|Long
operator|.
name|parseLong
argument_list|(
name|o
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Find the version
name|String
name|versionOnUpdateS
init|=
name|req
operator|.
name|getParams
argument_list|()
operator|.
name|get
argument_list|(
name|VERSION_FIELD
argument_list|)
decl_stmt|;
name|versionOnUpdate
operator|=
name|versionOnUpdateS
operator|==
literal|null
condition|?
literal|0
else|:
name|Long
operator|.
name|parseLong
argument_list|(
name|versionOnUpdateS
argument_list|)
expr_stmt|;
block|}
block|}
name|boolean
name|isReplayOrPeersync
init|=
operator|(
name|cmd
operator|.
name|getFlags
argument_list|()
operator|&
operator|(
name|UpdateCommand
operator|.
name|REPLAY
operator||
name|UpdateCommand
operator|.
name|PEER_SYNC
operator|)
operator|)
operator|!=
literal|0
decl_stmt|;
name|boolean
name|leaderLogic
init|=
name|isLeader
operator|&&
operator|!
name|isReplayOrPeersync
decl_stmt|;
name|boolean
name|forwardedFromCollection
init|=
name|cmd
operator|.
name|getReq
argument_list|()
operator|.
name|getParams
argument_list|()
operator|.
name|get
argument_list|(
name|DISTRIB_FROM_COLLECTION
argument_list|)
operator|!=
literal|null
decl_stmt|;
name|VersionBucket
name|bucket
init|=
name|vinfo
operator|.
name|bucket
argument_list|(
name|bucketHash
argument_list|)
decl_stmt|;
name|vinfo
operator|.
name|lockForUpdate
argument_list|()
expr_stmt|;
try|try
block|{
synchronized|synchronized
init|(
name|bucket
init|)
block|{
comment|// we obtain the version when synchronized and then do the add so we can ensure that
comment|// if version1< version2 then version1 is actually added before version2.
comment|// even if we don't store the version field, synchronizing on the bucket
comment|// will enable us to know what version happened first, and thus enable
comment|// realtime-get to work reliably.
comment|// TODO: if versions aren't stored, do we need to set on the cmd anyway for some reason?
comment|// there may be other reasons in the future for a version on the commands
name|boolean
name|checkDeleteByQueries
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|versionsStored
condition|)
block|{
name|long
name|bucketVersion
init|=
name|bucket
operator|.
name|highest
decl_stmt|;
if|if
condition|(
name|leaderLogic
condition|)
block|{
if|if
condition|(
name|forwardedFromCollection
operator|&&
name|ulog
operator|.
name|getState
argument_list|()
operator|==
name|UpdateLog
operator|.
name|State
operator|.
name|ACTIVE
condition|)
block|{
comment|// forwarded from a collection but we are not buffering so strip original version and apply our own
comment|// see SOLR-5308
name|log
operator|.
name|info
argument_list|(
literal|"Removing version field from doc: "
operator|+
name|cmd
operator|.
name|getPrintableId
argument_list|()
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|solrDoc
operator|.
name|remove
argument_list|(
name|VERSION_FIELD
argument_list|)
expr_stmt|;
name|versionOnUpdate
operator|=
literal|0
expr_stmt|;
block|}
name|boolean
name|updated
init|=
name|getUpdatedDocument
argument_list|(
name|cmd
argument_list|,
name|versionOnUpdate
argument_list|)
decl_stmt|;
comment|// leaders can also be in buffering state during "migrate" API call, see SOLR-5308
if|if
condition|(
name|forwardedFromCollection
operator|&&
name|ulog
operator|.
name|getState
argument_list|()
operator|!=
name|UpdateLog
operator|.
name|State
operator|.
name|ACTIVE
operator|&&
operator|(
name|cmd
operator|.
name|getFlags
argument_list|()
operator|&
name|UpdateCommand
operator|.
name|REPLAY
operator|)
operator|==
literal|0
condition|)
block|{
comment|// we're not in an active state, and this update isn't from a replay, so buffer it.
name|log
operator|.
name|info
argument_list|(
literal|"Leader logic applied but update log is buffering: "
operator|+
name|cmd
operator|.
name|getPrintableId
argument_list|()
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|setFlags
argument_list|(
name|cmd
operator|.
name|getFlags
argument_list|()
operator||
name|UpdateCommand
operator|.
name|BUFFERING
argument_list|)
expr_stmt|;
name|ulog
operator|.
name|add
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
if|if
condition|(
name|versionOnUpdate
operator|!=
literal|0
condition|)
block|{
name|Long
name|lastVersion
init|=
name|vinfo
operator|.
name|lookupVersion
argument_list|(
name|cmd
operator|.
name|getIndexedId
argument_list|()
argument_list|)
decl_stmt|;
name|long
name|foundVersion
init|=
name|lastVersion
operator|==
literal|null
condition|?
operator|-
literal|1
else|:
name|lastVersion
decl_stmt|;
if|if
condition|(
name|versionOnUpdate
operator|==
name|foundVersion
operator|||
operator|(
name|versionOnUpdate
operator|<
literal|0
operator|&&
name|foundVersion
operator|<
literal|0
operator|)
operator|||
operator|(
name|versionOnUpdate
operator|==
literal|1
operator|&&
name|foundVersion
operator|>
literal|0
operator|)
condition|)
block|{
comment|// we're ok if versions match, or if both are negative (all missing docs are equal), or if cmd
comment|// specified it must exist (versionOnUpdate==1) and it does.
block|}
else|else
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|CONFLICT
argument_list|,
literal|"version conflict for "
operator|+
name|cmd
operator|.
name|getPrintableId
argument_list|()
operator|+
literal|" expected="
operator|+
name|versionOnUpdate
operator|+
literal|" actual="
operator|+
name|foundVersion
argument_list|)
throw|;
block|}
block|}
name|long
name|version
init|=
name|vinfo
operator|.
name|getNewClock
argument_list|()
decl_stmt|;
name|cmd
operator|.
name|setVersion
argument_list|(
name|version
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|getSolrInputDocument
argument_list|()
operator|.
name|setField
argument_list|(
name|VersionInfo
operator|.
name|VERSION_FIELD
argument_list|,
name|version
argument_list|)
expr_stmt|;
name|bucket
operator|.
name|updateHighest
argument_list|(
name|version
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// The leader forwarded us this update.
name|cmd
operator|.
name|setVersion
argument_list|(
name|versionOnUpdate
argument_list|)
expr_stmt|;
if|if
condition|(
name|ulog
operator|.
name|getState
argument_list|()
operator|!=
name|UpdateLog
operator|.
name|State
operator|.
name|ACTIVE
operator|&&
operator|(
name|cmd
operator|.
name|getFlags
argument_list|()
operator|&
name|UpdateCommand
operator|.
name|REPLAY
operator|)
operator|==
literal|0
condition|)
block|{
comment|// we're not in an active state, and this update isn't from a replay, so buffer it.
name|cmd
operator|.
name|setFlags
argument_list|(
name|cmd
operator|.
name|getFlags
argument_list|()
operator||
name|UpdateCommand
operator|.
name|BUFFERING
argument_list|)
expr_stmt|;
name|ulog
operator|.
name|add
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
comment|// if we aren't the leader, then we need to check that updates were not re-ordered
if|if
condition|(
name|bucketVersion
operator|!=
literal|0
operator|&&
name|bucketVersion
operator|<
name|versionOnUpdate
condition|)
block|{
comment|// we're OK... this update has a version higher than anything we've seen
comment|// in this bucket so far, so we know that no reordering has yet occurred.
name|bucket
operator|.
name|updateHighest
argument_list|(
name|versionOnUpdate
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// there have been updates higher than the current update.  we need to check
comment|// the specific version for this id.
name|Long
name|lastVersion
init|=
name|vinfo
operator|.
name|lookupVersion
argument_list|(
name|cmd
operator|.
name|getIndexedId
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|lastVersion
operator|!=
literal|null
operator|&&
name|Math
operator|.
name|abs
argument_list|(
name|lastVersion
argument_list|)
operator|>=
name|versionOnUpdate
condition|)
block|{
comment|// This update is a repeat, or was reordered.  We need to drop this update.
return|return
literal|true
return|;
block|}
comment|// also need to re-apply newer deleteByQuery commands
name|checkDeleteByQueries
operator|=
literal|true
expr_stmt|;
block|}
block|}
block|}
name|boolean
name|willDistrib
init|=
name|isLeader
operator|&&
name|nodes
operator|!=
literal|null
operator|&&
name|nodes
operator|.
name|size
argument_list|()
operator|>
literal|0
decl_stmt|;
name|SolrInputDocument
name|clonedDoc
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|willDistrib
condition|)
block|{
name|clonedDoc
operator|=
name|cmd
operator|.
name|solrDoc
operator|.
name|deepCopy
argument_list|()
expr_stmt|;
block|}
comment|// TODO: possibly set checkDeleteByQueries as a flag on the command?
name|doLocalAdd
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|willDistrib
condition|)
block|{
name|cmd
operator|.
name|solrDoc
operator|=
name|clonedDoc
expr_stmt|;
block|}
block|}
comment|// end synchronized (bucket)
block|}
finally|finally
block|{
name|vinfo
operator|.
name|unlockForUpdate
argument_list|()
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
comment|// TODO: may want to switch to using optimistic locking in the future for better concurrency
comment|// that's why this code is here... need to retry in a loop closely around/in versionAdd
DECL|method|getUpdatedDocument
name|boolean
name|getUpdatedDocument
parameter_list|(
name|AddUpdateCommand
name|cmd
parameter_list|,
name|long
name|versionOnUpdate
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|AtomicUpdateDocumentMerger
operator|.
name|isAtomicUpdate
argument_list|(
name|cmd
argument_list|)
condition|)
return|return
literal|false
return|;
name|SolrInputDocument
name|sdoc
init|=
name|cmd
operator|.
name|getSolrInputDocument
argument_list|()
decl_stmt|;
name|BytesRef
name|id
init|=
name|cmd
operator|.
name|getIndexedId
argument_list|()
decl_stmt|;
name|SolrInputDocument
name|oldDoc
init|=
name|RealTimeGetComponent
operator|.
name|getInputDocument
argument_list|(
name|cmd
operator|.
name|getReq
argument_list|()
operator|.
name|getCore
argument_list|()
argument_list|,
name|id
argument_list|)
decl_stmt|;
if|if
condition|(
name|oldDoc
operator|==
literal|null
condition|)
block|{
comment|// create a new doc by default if an old one wasn't found
if|if
condition|(
name|versionOnUpdate
operator|<=
literal|0
condition|)
block|{
name|oldDoc
operator|=
operator|new
name|SolrInputDocument
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|// could just let the optimistic locking throw the error
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|CONFLICT
argument_list|,
literal|"Document not found for update.  id="
operator|+
name|cmd
operator|.
name|getPrintableId
argument_list|()
argument_list|)
throw|;
block|}
block|}
else|else
block|{
name|oldDoc
operator|.
name|remove
argument_list|(
name|VERSION_FIELD
argument_list|)
expr_stmt|;
block|}
name|cmd
operator|.
name|solrDoc
operator|=
name|docMerger
operator|.
name|merge
argument_list|(
name|sdoc
argument_list|,
name|oldDoc
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
annotation|@
name|Override
DECL|method|processDelete
specifier|public
name|void
name|processDelete
parameter_list|(
name|DeleteUpdateCommand
name|cmd
parameter_list|)
throws|throws
name|IOException
block|{
name|updateCommand
operator|=
name|cmd
expr_stmt|;
if|if
condition|(
operator|!
name|cmd
operator|.
name|isDeleteById
argument_list|()
condition|)
block|{
name|doDeleteByQuery
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|zkEnabled
condition|)
block|{
name|zkCheck
argument_list|()
expr_stmt|;
name|nodes
operator|=
name|setupRequest
argument_list|(
name|cmd
operator|.
name|getId
argument_list|()
argument_list|,
literal|null
argument_list|,
name|cmd
operator|.
name|getRoute
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|isLeader
operator|=
name|getNonZkLeaderAssumption
argument_list|(
name|req
argument_list|)
expr_stmt|;
block|}
name|boolean
name|dropCmd
init|=
literal|false
decl_stmt|;
if|if
condition|(
operator|!
name|forwardToLeader
condition|)
block|{
name|dropCmd
operator|=
name|versionDelete
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dropCmd
condition|)
block|{
comment|// TODO: do we need to add anything to the response?
return|return;
block|}
if|if
condition|(
name|zkEnabled
operator|&&
name|isLeader
operator|&&
operator|!
name|isSubShardLeader
condition|)
block|{
name|DocCollection
name|coll
init|=
name|zkController
operator|.
name|getClusterState
argument_list|()
operator|.
name|getCollection
argument_list|(
name|collection
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Node
argument_list|>
name|subShardLeaders
init|=
name|getSubShardLeaders
argument_list|(
name|coll
argument_list|,
name|cloudDesc
operator|.
name|getShardId
argument_list|()
argument_list|,
name|cmd
operator|.
name|getId
argument_list|()
argument_list|,
literal|null
argument_list|)
decl_stmt|;
comment|// the list<node> will actually have only one element for an add request
if|if
condition|(
name|subShardLeaders
operator|!=
literal|null
operator|&&
operator|!
name|subShardLeaders
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|ModifiableSolrParams
name|params
init|=
operator|new
name|ModifiableSolrParams
argument_list|(
name|filterParams
argument_list|(
name|req
operator|.
name|getParams
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|params
operator|.
name|set
argument_list|(
name|DISTRIB_UPDATE_PARAM
argument_list|,
name|DistribPhase
operator|.
name|FROMLEADER
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|params
operator|.
name|set
argument_list|(
name|DISTRIB_FROM
argument_list|,
name|ZkCoreNodeProps
operator|.
name|getCoreUrl
argument_list|(
name|zkController
operator|.
name|getBaseUrl
argument_list|()
argument_list|,
name|req
operator|.
name|getCore
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|params
operator|.
name|set
argument_list|(
name|DISTRIB_FROM_PARENT
argument_list|,
name|cloudDesc
operator|.
name|getShardId
argument_list|()
argument_list|)
expr_stmt|;
name|cmdDistrib
operator|.
name|distribDelete
argument_list|(
name|cmd
argument_list|,
name|subShardLeaders
argument_list|,
name|params
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
name|List
argument_list|<
name|Node
argument_list|>
name|nodesByRoutingRules
init|=
name|getNodesByRoutingRules
argument_list|(
name|zkController
operator|.
name|getClusterState
argument_list|()
argument_list|,
name|coll
argument_list|,
name|cmd
operator|.
name|getId
argument_list|()
argument_list|,
literal|null
argument_list|)
decl_stmt|;
if|if
condition|(
name|nodesByRoutingRules
operator|!=
literal|null
operator|&&
operator|!
name|nodesByRoutingRules
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|ModifiableSolrParams
name|params
init|=
operator|new
name|ModifiableSolrParams
argument_list|(
name|filterParams
argument_list|(
name|req
operator|.
name|getParams
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|params
operator|.
name|set
argument_list|(
name|DISTRIB_UPDATE_PARAM
argument_list|,
name|DistribPhase
operator|.
name|FROMLEADER
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|params
operator|.
name|set
argument_list|(
name|DISTRIB_FROM
argument_list|,
name|ZkCoreNodeProps
operator|.
name|getCoreUrl
argument_list|(
name|zkController
operator|.
name|getBaseUrl
argument_list|()
argument_list|,
name|req
operator|.
name|getCore
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|params
operator|.
name|set
argument_list|(
name|DISTRIB_FROM_COLLECTION
argument_list|,
name|req
operator|.
name|getCore
argument_list|()
operator|.
name|getCoreDescriptor
argument_list|()
operator|.
name|getCloudDescriptor
argument_list|()
operator|.
name|getCollectionName
argument_list|()
argument_list|)
expr_stmt|;
name|params
operator|.
name|set
argument_list|(
name|DISTRIB_FROM_SHARD
argument_list|,
name|req
operator|.
name|getCore
argument_list|()
operator|.
name|getCoreDescriptor
argument_list|()
operator|.
name|getCloudDescriptor
argument_list|()
operator|.
name|getShardId
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|Node
name|nodesByRoutingRule
range|:
name|nodesByRoutingRules
control|)
block|{
name|cmdDistrib
operator|.
name|distribDelete
argument_list|(
name|cmd
argument_list|,
name|Collections
operator|.
name|singletonList
argument_list|(
name|nodesByRoutingRule
argument_list|)
argument_list|,
name|params
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|ModifiableSolrParams
name|params
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|nodes
operator|!=
literal|null
condition|)
block|{
name|params
operator|=
operator|new
name|ModifiableSolrParams
argument_list|(
name|filterParams
argument_list|(
name|req
operator|.
name|getParams
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|params
operator|.
name|set
argument_list|(
name|DISTRIB_UPDATE_PARAM
argument_list|,
operator|(
name|isLeader
operator|||
name|isSubShardLeader
condition|?
name|DistribPhase
operator|.
name|FROMLEADER
operator|.
name|toString
argument_list|()
else|:
name|DistribPhase
operator|.
name|TOLEADER
operator|.
name|toString
argument_list|()
operator|)
argument_list|)
expr_stmt|;
name|params
operator|.
name|set
argument_list|(
name|DISTRIB_FROM
argument_list|,
name|ZkCoreNodeProps
operator|.
name|getCoreUrl
argument_list|(
name|zkController
operator|.
name|getBaseUrl
argument_list|()
argument_list|,
name|req
operator|.
name|getCore
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|cmdDistrib
operator|.
name|distribDelete
argument_list|(
name|cmd
argument_list|,
name|nodes
argument_list|,
name|params
argument_list|)
expr_stmt|;
block|}
comment|// cmd.getIndexId == null when delete by query
comment|// TODO: what to do when no idField?
if|if
condition|(
name|returnVersions
operator|&&
name|rsp
operator|!=
literal|null
operator|&&
name|cmd
operator|.
name|getIndexedId
argument_list|()
operator|!=
literal|null
operator|&&
name|idField
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|deleteResponse
operator|==
literal|null
condition|)
block|{
name|deleteResponse
operator|=
operator|new
name|NamedList
argument_list|<
name|String
argument_list|>
argument_list|()
expr_stmt|;
name|rsp
operator|.
name|add
argument_list|(
literal|"deletes"
argument_list|,
name|deleteResponse
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|scratch
operator|==
literal|null
condition|)
name|scratch
operator|=
operator|new
name|CharsRefBuilder
argument_list|()
expr_stmt|;
name|idField
operator|.
name|getType
argument_list|()
operator|.
name|indexedToReadable
argument_list|(
name|cmd
operator|.
name|getIndexedId
argument_list|()
argument_list|,
name|scratch
argument_list|)
expr_stmt|;
name|deleteResponse
operator|.
name|add
argument_list|(
name|scratch
operator|.
name|toString
argument_list|()
argument_list|,
name|cmd
operator|.
name|getVersion
argument_list|()
argument_list|)
expr_stmt|;
comment|// we're returning the version of the delete.. not the version of the doc we deleted.
block|}
block|}
DECL|method|filterParams
specifier|private
name|ModifiableSolrParams
name|filterParams
parameter_list|(
name|SolrParams
name|params
parameter_list|)
block|{
name|ModifiableSolrParams
name|fparams
init|=
operator|new
name|ModifiableSolrParams
argument_list|()
decl_stmt|;
name|passParam
argument_list|(
name|params
argument_list|,
name|fparams
argument_list|,
name|UpdateParams
operator|.
name|UPDATE_CHAIN
argument_list|)
expr_stmt|;
name|passParam
argument_list|(
name|params
argument_list|,
name|fparams
argument_list|,
name|TEST_DISTRIB_SKIP_SERVERS
argument_list|)
expr_stmt|;
return|return
name|fparams
return|;
block|}
DECL|method|passParam
specifier|private
name|void
name|passParam
parameter_list|(
name|SolrParams
name|params
parameter_list|,
name|ModifiableSolrParams
name|fparams
parameter_list|,
name|String
name|param
parameter_list|)
block|{
name|String
index|[]
name|values
init|=
name|params
operator|.
name|getParams
argument_list|(
name|param
argument_list|)
decl_stmt|;
if|if
condition|(
name|values
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|String
name|value
range|:
name|values
control|)
block|{
name|fparams
operator|.
name|add
argument_list|(
name|param
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|doDeleteByQuery
specifier|public
name|void
name|doDeleteByQuery
parameter_list|(
name|DeleteUpdateCommand
name|cmd
parameter_list|)
throws|throws
name|IOException
block|{
comment|// even in non zk mode, tests simulate updates from a leader
if|if
condition|(
operator|!
name|zkEnabled
condition|)
block|{
name|isLeader
operator|=
name|getNonZkLeaderAssumption
argument_list|(
name|req
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|zkCheck
argument_list|()
expr_stmt|;
block|}
comment|// NONE: we are the first to receive this deleteByQuery
comment|//       - it must be forwarded to the leader of every shard
comment|// TO:   we are a leader receiving a forwarded deleteByQuery... we must:
comment|//       - block all updates (use VersionInfo)
comment|//       - flush *all* updates going to our replicas
comment|//       - forward the DBQ to our replicas and wait for the response
comment|//       - log + execute the local DBQ
comment|// FROM: we are a replica receiving a DBQ from our leader
comment|//       - log + execute the local DBQ
name|DistribPhase
name|phase
init|=
name|DistribPhase
operator|.
name|parseParam
argument_list|(
name|req
operator|.
name|getParams
argument_list|()
operator|.
name|get
argument_list|(
name|DISTRIB_UPDATE_PARAM
argument_list|)
argument_list|)
decl_stmt|;
name|DocCollection
name|coll
init|=
name|zkEnabled
condition|?
name|zkController
operator|.
name|getClusterState
argument_list|()
operator|.
name|getCollection
argument_list|(
name|collection
argument_list|)
else|:
literal|null
decl_stmt|;
if|if
condition|(
name|zkEnabled
operator|&&
name|DistribPhase
operator|.
name|NONE
operator|==
name|phase
condition|)
block|{
name|boolean
name|leaderForAnyShard
init|=
literal|false
decl_stmt|;
comment|// start off by assuming we are not a leader for any shard
name|ModifiableSolrParams
name|outParams
init|=
operator|new
name|ModifiableSolrParams
argument_list|(
name|filterParams
argument_list|(
name|req
operator|.
name|getParams
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|outParams
operator|.
name|set
argument_list|(
name|DISTRIB_UPDATE_PARAM
argument_list|,
name|DistribPhase
operator|.
name|TOLEADER
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|outParams
operator|.
name|set
argument_list|(
name|DISTRIB_FROM
argument_list|,
name|ZkCoreNodeProps
operator|.
name|getCoreUrl
argument_list|(
name|zkController
operator|.
name|getBaseUrl
argument_list|()
argument_list|,
name|req
operator|.
name|getCore
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|SolrParams
name|params
init|=
name|req
operator|.
name|getParams
argument_list|()
decl_stmt|;
name|String
name|route
init|=
name|params
operator|.
name|get
argument_list|(
name|ShardParams
operator|.
name|_ROUTE_
argument_list|)
decl_stmt|;
name|Collection
argument_list|<
name|Slice
argument_list|>
name|slices
init|=
name|coll
operator|.
name|getRouter
argument_list|()
operator|.
name|getSearchSlices
argument_list|(
name|route
argument_list|,
name|params
argument_list|,
name|coll
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Node
argument_list|>
name|leaders
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|slices
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|Slice
name|slice
range|:
name|slices
control|)
block|{
name|String
name|sliceName
init|=
name|slice
operator|.
name|getName
argument_list|()
decl_stmt|;
name|Replica
name|leader
decl_stmt|;
try|try
block|{
name|leader
operator|=
name|zkController
operator|.
name|getZkStateReader
argument_list|()
operator|.
name|getLeaderRetry
argument_list|(
name|collection
argument_list|,
name|sliceName
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|SERVICE_UNAVAILABLE
argument_list|,
literal|"Exception finding leader for shard "
operator|+
name|sliceName
argument_list|,
name|e
argument_list|)
throw|;
block|}
comment|// TODO: What if leaders changed in the meantime?
comment|// should we send out slice-at-a-time and if a node returns "hey, I'm not a leader" (or we get an error because it went down) then look up the new leader?
comment|// Am I the leader for this slice?
name|ZkCoreNodeProps
name|coreLeaderProps
init|=
operator|new
name|ZkCoreNodeProps
argument_list|(
name|leader
argument_list|)
decl_stmt|;
name|String
name|leaderCoreNodeName
init|=
name|leader
operator|.
name|getName
argument_list|()
decl_stmt|;
name|String
name|coreNodeName
init|=
name|req
operator|.
name|getCore
argument_list|()
operator|.
name|getCoreDescriptor
argument_list|()
operator|.
name|getCloudDescriptor
argument_list|()
operator|.
name|getCoreNodeName
argument_list|()
decl_stmt|;
name|isLeader
operator|=
name|coreNodeName
operator|.
name|equals
argument_list|(
name|leaderCoreNodeName
argument_list|)
expr_stmt|;
if|if
condition|(
name|isLeader
condition|)
block|{
comment|// don't forward to ourself
name|leaderForAnyShard
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|leaders
operator|.
name|add
argument_list|(
operator|new
name|StdNode
argument_list|(
name|coreLeaderProps
argument_list|,
name|collection
argument_list|,
name|sliceName
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|outParams
operator|.
name|remove
argument_list|(
literal|"commit"
argument_list|)
expr_stmt|;
comment|// this will be distributed from the local commit
name|cmdDistrib
operator|.
name|distribDelete
argument_list|(
name|cmd
argument_list|,
name|leaders
argument_list|,
name|outParams
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|leaderForAnyShard
condition|)
block|{
return|return;
block|}
comment|// change the phase to TOLEADER so we look up and forward to our own replicas (if any)
name|phase
operator|=
name|DistribPhase
operator|.
name|TOLEADER
expr_stmt|;
block|}
name|List
argument_list|<
name|Node
argument_list|>
name|replicas
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|zkEnabled
operator|&&
name|DistribPhase
operator|.
name|TOLEADER
operator|==
name|phase
condition|)
block|{
comment|// This core should be a leader
name|isLeader
operator|=
literal|true
expr_stmt|;
name|replicas
operator|=
name|setupRequest
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|DistribPhase
operator|.
name|FROMLEADER
operator|==
name|phase
condition|)
block|{
name|isLeader
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
name|vinfo
operator|==
literal|null
condition|)
block|{
name|super
operator|.
name|processDelete
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// at this point, there is an update we need to try and apply.
comment|// we may or may not be the leader.
comment|// Find the version
name|long
name|versionOnUpdate
init|=
name|cmd
operator|.
name|getVersion
argument_list|()
decl_stmt|;
if|if
condition|(
name|versionOnUpdate
operator|==
literal|0
condition|)
block|{
name|String
name|versionOnUpdateS
init|=
name|req
operator|.
name|getParams
argument_list|()
operator|.
name|get
argument_list|(
name|VERSION_FIELD
argument_list|)
decl_stmt|;
name|versionOnUpdate
operator|=
name|versionOnUpdateS
operator|==
literal|null
condition|?
literal|0
else|:
name|Long
operator|.
name|parseLong
argument_list|(
name|versionOnUpdateS
argument_list|)
expr_stmt|;
block|}
name|versionOnUpdate
operator|=
name|Math
operator|.
name|abs
argument_list|(
name|versionOnUpdate
argument_list|)
expr_stmt|;
comment|// normalize to positive version
name|boolean
name|isReplayOrPeersync
init|=
operator|(
name|cmd
operator|.
name|getFlags
argument_list|()
operator|&
operator|(
name|UpdateCommand
operator|.
name|REPLAY
operator||
name|UpdateCommand
operator|.
name|PEER_SYNC
operator|)
operator|)
operator|!=
literal|0
decl_stmt|;
name|boolean
name|leaderLogic
init|=
name|isLeader
operator|&&
operator|!
name|isReplayOrPeersync
decl_stmt|;
if|if
condition|(
operator|!
name|leaderLogic
operator|&&
name|versionOnUpdate
operator|==
literal|0
condition|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
literal|"missing _version_ on update from leader"
argument_list|)
throw|;
block|}
name|vinfo
operator|.
name|blockUpdates
argument_list|()
expr_stmt|;
try|try
block|{
if|if
condition|(
name|versionsStored
condition|)
block|{
if|if
condition|(
name|leaderLogic
condition|)
block|{
name|long
name|version
init|=
name|vinfo
operator|.
name|getNewClock
argument_list|()
decl_stmt|;
name|cmd
operator|.
name|setVersion
argument_list|(
operator|-
name|version
argument_list|)
expr_stmt|;
comment|// TODO update versions in all buckets
name|doLocalDelete
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cmd
operator|.
name|setVersion
argument_list|(
operator|-
name|versionOnUpdate
argument_list|)
expr_stmt|;
if|if
condition|(
name|ulog
operator|.
name|getState
argument_list|()
operator|!=
name|UpdateLog
operator|.
name|State
operator|.
name|ACTIVE
operator|&&
operator|(
name|cmd
operator|.
name|getFlags
argument_list|()
operator|&
name|UpdateCommand
operator|.
name|REPLAY
operator|)
operator|==
literal|0
condition|)
block|{
comment|// we're not in an active state, and this update isn't from a replay, so buffer it.
name|cmd
operator|.
name|setFlags
argument_list|(
name|cmd
operator|.
name|getFlags
argument_list|()
operator||
name|UpdateCommand
operator|.
name|BUFFERING
argument_list|)
expr_stmt|;
name|ulog
operator|.
name|deleteByQuery
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
return|return;
block|}
name|doLocalDelete
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
block|}
block|}
comment|// since we don't know which documents were deleted, the easiest thing to do is to invalidate
comment|// all real-time caches (i.e. UpdateLog) which involves also getting a new version of the IndexReader
comment|// (so cache misses will see up-to-date data)
block|}
finally|finally
block|{
name|vinfo
operator|.
name|unblockUpdates
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|zkEnabled
condition|)
block|{
comment|// forward to all replicas
name|ModifiableSolrParams
name|params
init|=
operator|new
name|ModifiableSolrParams
argument_list|(
name|filterParams
argument_list|(
name|req
operator|.
name|getParams
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|params
operator|.
name|set
argument_list|(
name|VERSION_FIELD
argument_list|,
name|Long
operator|.
name|toString
argument_list|(
name|cmd
operator|.
name|getVersion
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|params
operator|.
name|set
argument_list|(
name|DISTRIB_UPDATE_PARAM
argument_list|,
name|DistribPhase
operator|.
name|FROMLEADER
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|params
operator|.
name|set
argument_list|(
name|DISTRIB_FROM
argument_list|,
name|ZkCoreNodeProps
operator|.
name|getCoreUrl
argument_list|(
name|zkController
operator|.
name|getBaseUrl
argument_list|()
argument_list|,
name|req
operator|.
name|getCore
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|boolean
name|someReplicas
init|=
literal|false
decl_stmt|;
name|boolean
name|subShardLeader
init|=
literal|false
decl_stmt|;
try|try
block|{
name|subShardLeader
operator|=
name|amISubShardLeader
argument_list|(
name|coll
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
if|if
condition|(
name|subShardLeader
condition|)
block|{
name|String
name|myShardId
init|=
name|req
operator|.
name|getCore
argument_list|()
operator|.
name|getCoreDescriptor
argument_list|()
operator|.
name|getCloudDescriptor
argument_list|()
operator|.
name|getShardId
argument_list|()
decl_stmt|;
name|Replica
name|leaderReplica
init|=
name|zkController
operator|.
name|getZkStateReader
argument_list|()
operator|.
name|getLeaderRetry
argument_list|(
name|collection
argument_list|,
name|myShardId
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|ZkCoreNodeProps
argument_list|>
name|replicaProps
init|=
name|zkController
operator|.
name|getZkStateReader
argument_list|()
operator|.
name|getReplicaProps
argument_list|(
name|collection
argument_list|,
name|myShardId
argument_list|,
name|leaderReplica
operator|.
name|getName
argument_list|()
argument_list|,
literal|null
argument_list|,
name|ZkStateReader
operator|.
name|DOWN
argument_list|)
decl_stmt|;
if|if
condition|(
name|replicaProps
operator|!=
literal|null
condition|)
block|{
name|List
argument_list|<
name|Node
argument_list|>
name|myReplicas
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|ZkCoreNodeProps
name|replicaProp
range|:
name|replicaProps
control|)
block|{
name|myReplicas
operator|.
name|add
argument_list|(
operator|new
name|StdNode
argument_list|(
name|replicaProp
argument_list|,
name|collection
argument_list|,
name|myShardId
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|cmdDistrib
operator|.
name|distribDelete
argument_list|(
name|cmd
argument_list|,
name|myReplicas
argument_list|,
name|params
argument_list|)
expr_stmt|;
name|someReplicas
operator|=
literal|true
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
throw|throw
operator|new
name|ZooKeeperException
argument_list|(
name|ErrorCode
operator|.
name|SERVER_ERROR
argument_list|,
literal|""
argument_list|,
name|e
argument_list|)
throw|;
block|}
if|if
condition|(
name|leaderLogic
condition|)
block|{
name|List
argument_list|<
name|Node
argument_list|>
name|subShardLeaders
init|=
name|getSubShardLeaders
argument_list|(
name|coll
argument_list|,
name|cloudDesc
operator|.
name|getShardId
argument_list|()
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
decl_stmt|;
if|if
condition|(
name|subShardLeaders
operator|!=
literal|null
condition|)
block|{
name|cmdDistrib
operator|.
name|distribDelete
argument_list|(
name|cmd
argument_list|,
name|subShardLeaders
argument_list|,
name|params
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
name|List
argument_list|<
name|Node
argument_list|>
name|nodesByRoutingRules
init|=
name|getNodesByRoutingRules
argument_list|(
name|zkController
operator|.
name|getClusterState
argument_list|()
argument_list|,
name|coll
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
decl_stmt|;
if|if
condition|(
name|nodesByRoutingRules
operator|!=
literal|null
operator|&&
operator|!
name|nodesByRoutingRules
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|params
operator|=
operator|new
name|ModifiableSolrParams
argument_list|(
name|filterParams
argument_list|(
name|req
operator|.
name|getParams
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|params
operator|.
name|set
argument_list|(
name|DISTRIB_UPDATE_PARAM
argument_list|,
name|DistribPhase
operator|.
name|FROMLEADER
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|params
operator|.
name|set
argument_list|(
name|DISTRIB_FROM
argument_list|,
name|ZkCoreNodeProps
operator|.
name|getCoreUrl
argument_list|(
name|zkController
operator|.
name|getBaseUrl
argument_list|()
argument_list|,
name|req
operator|.
name|getCore
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|params
operator|.
name|set
argument_list|(
name|DISTRIB_FROM_COLLECTION
argument_list|,
name|req
operator|.
name|getCore
argument_list|()
operator|.
name|getCoreDescriptor
argument_list|()
operator|.
name|getCloudDescriptor
argument_list|()
operator|.
name|getCollectionName
argument_list|()
argument_list|)
expr_stmt|;
name|params
operator|.
name|set
argument_list|(
name|DISTRIB_FROM_SHARD
argument_list|,
name|req
operator|.
name|getCore
argument_list|()
operator|.
name|getCoreDescriptor
argument_list|()
operator|.
name|getCloudDescriptor
argument_list|()
operator|.
name|getShardId
argument_list|()
argument_list|)
expr_stmt|;
name|cmdDistrib
operator|.
name|distribDelete
argument_list|(
name|cmd
argument_list|,
name|nodesByRoutingRules
argument_list|,
name|params
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|replicas
operator|!=
literal|null
condition|)
block|{
name|cmdDistrib
operator|.
name|distribDelete
argument_list|(
name|cmd
argument_list|,
name|replicas
argument_list|,
name|params
argument_list|)
expr_stmt|;
name|someReplicas
operator|=
literal|true
expr_stmt|;
block|}
block|}
if|if
condition|(
name|someReplicas
condition|)
block|{
name|cmdDistrib
operator|.
name|finish
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|returnVersions
operator|&&
name|rsp
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|deleteByQueryResponse
operator|==
literal|null
condition|)
block|{
name|deleteByQueryResponse
operator|=
operator|new
name|NamedList
argument_list|<
name|String
argument_list|>
argument_list|()
expr_stmt|;
name|rsp
operator|.
name|add
argument_list|(
literal|"deleteByQuery"
argument_list|,
name|deleteByQueryResponse
argument_list|)
expr_stmt|;
block|}
name|deleteByQueryResponse
operator|.
name|add
argument_list|(
name|cmd
operator|.
name|getQuery
argument_list|()
argument_list|,
name|cmd
operator|.
name|getVersion
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|// internal helper method to tell if we are the leader for an add or deleteById update
DECL|method|isLeader
name|boolean
name|isLeader
parameter_list|(
name|UpdateCommand
name|cmd
parameter_list|)
block|{
name|updateCommand
operator|=
name|cmd
expr_stmt|;
if|if
condition|(
name|zkEnabled
condition|)
block|{
name|zkCheck
argument_list|()
expr_stmt|;
if|if
condition|(
name|cmd
operator|instanceof
name|AddUpdateCommand
condition|)
block|{
name|AddUpdateCommand
name|acmd
init|=
operator|(
name|AddUpdateCommand
operator|)
name|cmd
decl_stmt|;
name|nodes
operator|=
name|setupRequest
argument_list|(
name|acmd
operator|.
name|getHashableId
argument_list|()
argument_list|,
name|acmd
operator|.
name|getSolrInputDocument
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cmd
operator|instanceof
name|DeleteUpdateCommand
condition|)
block|{
name|DeleteUpdateCommand
name|dcmd
init|=
operator|(
name|DeleteUpdateCommand
operator|)
name|cmd
decl_stmt|;
name|nodes
operator|=
name|setupRequest
argument_list|(
name|dcmd
operator|.
name|getId
argument_list|()
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|isLeader
operator|=
name|getNonZkLeaderAssumption
argument_list|(
name|req
argument_list|)
expr_stmt|;
block|}
return|return
name|isLeader
return|;
block|}
DECL|method|zkCheck
specifier|private
name|void
name|zkCheck
parameter_list|()
block|{
if|if
condition|(
operator|(
name|updateCommand
operator|.
name|getFlags
argument_list|()
operator|&
operator|(
name|UpdateCommand
operator|.
name|REPLAY
operator||
name|UpdateCommand
operator|.
name|PEER_SYNC
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
comment|// for log reply or peer sync, we don't need to be connected to ZK
return|return;
block|}
if|if
condition|(
operator|!
name|zkController
operator|.
name|getZkClient
argument_list|()
operator|.
name|getConnectionManager
argument_list|()
operator|.
name|isLikelyExpired
argument_list|()
condition|)
block|{
return|return;
block|}
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|SERVICE_UNAVAILABLE
argument_list|,
literal|"Cannot talk to ZooKeeper - Updates are disabled."
argument_list|)
throw|;
block|}
DECL|method|versionDelete
specifier|private
name|boolean
name|versionDelete
parameter_list|(
name|DeleteUpdateCommand
name|cmd
parameter_list|)
throws|throws
name|IOException
block|{
name|BytesRef
name|idBytes
init|=
name|cmd
operator|.
name|getIndexedId
argument_list|()
decl_stmt|;
if|if
condition|(
name|vinfo
operator|==
literal|null
operator|||
name|idBytes
operator|==
literal|null
condition|)
block|{
name|super
operator|.
name|processDelete
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
comment|// This is only the hash for the bucket, and must be based only on the uniqueKey (i.e. do not use a pluggable hash here)
name|int
name|bucketHash
init|=
name|Hash
operator|.
name|murmurhash3_x86_32
argument_list|(
name|idBytes
operator|.
name|bytes
argument_list|,
name|idBytes
operator|.
name|offset
argument_list|,
name|idBytes
operator|.
name|length
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|// at this point, there is an update we need to try and apply.
comment|// we may or may not be the leader.
comment|// Find the version
name|long
name|versionOnUpdate
init|=
name|cmd
operator|.
name|getVersion
argument_list|()
decl_stmt|;
if|if
condition|(
name|versionOnUpdate
operator|==
literal|0
condition|)
block|{
name|String
name|versionOnUpdateS
init|=
name|req
operator|.
name|getParams
argument_list|()
operator|.
name|get
argument_list|(
name|VERSION_FIELD
argument_list|)
decl_stmt|;
name|versionOnUpdate
operator|=
name|versionOnUpdateS
operator|==
literal|null
condition|?
literal|0
else|:
name|Long
operator|.
name|parseLong
argument_list|(
name|versionOnUpdateS
argument_list|)
expr_stmt|;
block|}
name|long
name|signedVersionOnUpdate
init|=
name|versionOnUpdate
decl_stmt|;
name|versionOnUpdate
operator|=
name|Math
operator|.
name|abs
argument_list|(
name|versionOnUpdate
argument_list|)
expr_stmt|;
comment|// normalize to positive version
name|boolean
name|isReplayOrPeersync
init|=
operator|(
name|cmd
operator|.
name|getFlags
argument_list|()
operator|&
operator|(
name|UpdateCommand
operator|.
name|REPLAY
operator||
name|UpdateCommand
operator|.
name|PEER_SYNC
operator|)
operator|)
operator|!=
literal|0
decl_stmt|;
name|boolean
name|leaderLogic
init|=
name|isLeader
operator|&&
operator|!
name|isReplayOrPeersync
decl_stmt|;
name|boolean
name|forwardedFromCollection
init|=
name|cmd
operator|.
name|getReq
argument_list|()
operator|.
name|getParams
argument_list|()
operator|.
name|get
argument_list|(
name|DISTRIB_FROM_COLLECTION
argument_list|)
operator|!=
literal|null
decl_stmt|;
if|if
condition|(
operator|!
name|leaderLogic
operator|&&
name|versionOnUpdate
operator|==
literal|0
condition|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
literal|"missing _version_ on update from leader"
argument_list|)
throw|;
block|}
name|VersionBucket
name|bucket
init|=
name|vinfo
operator|.
name|bucket
argument_list|(
name|bucketHash
argument_list|)
decl_stmt|;
name|vinfo
operator|.
name|lockForUpdate
argument_list|()
expr_stmt|;
try|try
block|{
synchronized|synchronized
init|(
name|bucket
init|)
block|{
if|if
condition|(
name|versionsStored
condition|)
block|{
name|long
name|bucketVersion
init|=
name|bucket
operator|.
name|highest
decl_stmt|;
if|if
condition|(
name|leaderLogic
condition|)
block|{
if|if
condition|(
name|forwardedFromCollection
operator|&&
name|ulog
operator|.
name|getState
argument_list|()
operator|==
name|UpdateLog
operator|.
name|State
operator|.
name|ACTIVE
condition|)
block|{
comment|// forwarded from a collection but we are not buffering so strip original version and apply our own
comment|// see SOLR-5308
name|log
operator|.
name|info
argument_list|(
literal|"Removing version field from doc: "
operator|+
name|cmd
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
name|versionOnUpdate
operator|=
name|signedVersionOnUpdate
operator|=
literal|0
expr_stmt|;
block|}
comment|// leaders can also be in buffering state during "migrate" API call, see SOLR-5308
if|if
condition|(
name|forwardedFromCollection
operator|&&
name|ulog
operator|.
name|getState
argument_list|()
operator|!=
name|UpdateLog
operator|.
name|State
operator|.
name|ACTIVE
operator|&&
operator|(
name|cmd
operator|.
name|getFlags
argument_list|()
operator|&
name|UpdateCommand
operator|.
name|REPLAY
operator|)
operator|==
literal|0
condition|)
block|{
comment|// we're not in an active state, and this update isn't from a replay, so buffer it.
name|log
operator|.
name|info
argument_list|(
literal|"Leader logic applied but update log is buffering: "
operator|+
name|cmd
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|setFlags
argument_list|(
name|cmd
operator|.
name|getFlags
argument_list|()
operator||
name|UpdateCommand
operator|.
name|BUFFERING
argument_list|)
expr_stmt|;
name|ulog
operator|.
name|delete
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
if|if
condition|(
name|signedVersionOnUpdate
operator|!=
literal|0
condition|)
block|{
name|Long
name|lastVersion
init|=
name|vinfo
operator|.
name|lookupVersion
argument_list|(
name|cmd
operator|.
name|getIndexedId
argument_list|()
argument_list|)
decl_stmt|;
name|long
name|foundVersion
init|=
name|lastVersion
operator|==
literal|null
condition|?
operator|-
literal|1
else|:
name|lastVersion
decl_stmt|;
if|if
condition|(
operator|(
name|signedVersionOnUpdate
operator|==
name|foundVersion
operator|)
operator|||
operator|(
name|signedVersionOnUpdate
operator|<
literal|0
operator|&&
name|foundVersion
operator|<
literal|0
operator|)
operator|||
operator|(
name|signedVersionOnUpdate
operator|==
literal|1
operator|&&
name|foundVersion
operator|>
literal|0
operator|)
condition|)
block|{
comment|// we're ok if versions match, or if both are negative (all missing docs are equal), or if cmd
comment|// specified it must exist (versionOnUpdate==1) and it does.
block|}
else|else
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|CONFLICT
argument_list|,
literal|"version conflict for "
operator|+
name|cmd
operator|.
name|getId
argument_list|()
operator|+
literal|" expected="
operator|+
name|signedVersionOnUpdate
operator|+
literal|" actual="
operator|+
name|foundVersion
argument_list|)
throw|;
block|}
block|}
name|long
name|version
init|=
name|vinfo
operator|.
name|getNewClock
argument_list|()
decl_stmt|;
name|cmd
operator|.
name|setVersion
argument_list|(
operator|-
name|version
argument_list|)
expr_stmt|;
name|bucket
operator|.
name|updateHighest
argument_list|(
name|version
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cmd
operator|.
name|setVersion
argument_list|(
operator|-
name|versionOnUpdate
argument_list|)
expr_stmt|;
if|if
condition|(
name|ulog
operator|.
name|getState
argument_list|()
operator|!=
name|UpdateLog
operator|.
name|State
operator|.
name|ACTIVE
operator|&&
operator|(
name|cmd
operator|.
name|getFlags
argument_list|()
operator|&
name|UpdateCommand
operator|.
name|REPLAY
operator|)
operator|==
literal|0
condition|)
block|{
comment|// we're not in an active state, and this update isn't from a replay, so buffer it.
name|cmd
operator|.
name|setFlags
argument_list|(
name|cmd
operator|.
name|getFlags
argument_list|()
operator||
name|UpdateCommand
operator|.
name|BUFFERING
argument_list|)
expr_stmt|;
name|ulog
operator|.
name|delete
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
comment|// if we aren't the leader, then we need to check that updates were not re-ordered
if|if
condition|(
name|bucketVersion
operator|!=
literal|0
operator|&&
name|bucketVersion
operator|<
name|versionOnUpdate
condition|)
block|{
comment|// we're OK... this update has a version higher than anything we've seen
comment|// in this bucket so far, so we know that no reordering has yet occured.
name|bucket
operator|.
name|updateHighest
argument_list|(
name|versionOnUpdate
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// there have been updates higher than the current update.  we need to check
comment|// the specific version for this id.
name|Long
name|lastVersion
init|=
name|vinfo
operator|.
name|lookupVersion
argument_list|(
name|cmd
operator|.
name|getIndexedId
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|lastVersion
operator|!=
literal|null
operator|&&
name|Math
operator|.
name|abs
argument_list|(
name|lastVersion
argument_list|)
operator|>=
name|versionOnUpdate
condition|)
block|{
comment|// This update is a repeat, or was reordered.  We need to drop this update.
return|return
literal|true
return|;
block|}
block|}
block|}
block|}
name|doLocalDelete
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
comment|// end synchronized (bucket)
block|}
finally|finally
block|{
name|vinfo
operator|.
name|unlockForUpdate
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|processCommit
specifier|public
name|void
name|processCommit
parameter_list|(
name|CommitUpdateCommand
name|cmd
parameter_list|)
throws|throws
name|IOException
block|{
name|updateCommand
operator|=
name|cmd
expr_stmt|;
name|List
argument_list|<
name|Node
argument_list|>
name|nodes
init|=
literal|null
decl_stmt|;
name|boolean
name|singleLeader
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|zkEnabled
condition|)
block|{
name|zkCheck
argument_list|()
expr_stmt|;
name|nodes
operator|=
name|getCollectionUrls
argument_list|(
name|req
argument_list|,
name|req
operator|.
name|getCore
argument_list|()
operator|.
name|getCoreDescriptor
argument_list|()
operator|.
name|getCloudDescriptor
argument_list|()
operator|.
name|getCollectionName
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|isLeader
operator|&&
name|nodes
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
name|singleLeader
operator|=
literal|true
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|zkEnabled
operator|||
name|req
operator|.
name|getParams
argument_list|()
operator|.
name|getBool
argument_list|(
name|COMMIT_END_POINT
argument_list|,
literal|false
argument_list|)
operator|||
name|singleLeader
condition|)
block|{
name|doLocalCommit
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|zkEnabled
condition|)
block|{
name|ModifiableSolrParams
name|params
init|=
operator|new
name|ModifiableSolrParams
argument_list|(
name|filterParams
argument_list|(
name|req
operator|.
name|getParams
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|req
operator|.
name|getParams
argument_list|()
operator|.
name|getBool
argument_list|(
name|COMMIT_END_POINT
argument_list|,
literal|false
argument_list|)
condition|)
block|{
name|params
operator|.
name|set
argument_list|(
name|COMMIT_END_POINT
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|params
operator|.
name|set
argument_list|(
name|DISTRIB_UPDATE_PARAM
argument_list|,
name|DistribPhase
operator|.
name|FROMLEADER
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|params
operator|.
name|set
argument_list|(
name|DISTRIB_FROM
argument_list|,
name|ZkCoreNodeProps
operator|.
name|getCoreUrl
argument_list|(
name|zkController
operator|.
name|getBaseUrl
argument_list|()
argument_list|,
name|req
operator|.
name|getCore
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nodes
operator|!=
literal|null
condition|)
block|{
name|cmdDistrib
operator|.
name|distribCommit
argument_list|(
name|cmd
argument_list|,
name|nodes
argument_list|,
name|params
argument_list|)
expr_stmt|;
name|finish
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
DECL|method|doLocalCommit
specifier|private
name|void
name|doLocalCommit
parameter_list|(
name|CommitUpdateCommand
name|cmd
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|vinfo
operator|!=
literal|null
condition|)
block|{
name|vinfo
operator|.
name|lockForUpdate
argument_list|()
expr_stmt|;
block|}
try|try
block|{
if|if
condition|(
name|ulog
operator|==
literal|null
operator|||
name|ulog
operator|.
name|getState
argument_list|()
operator|==
name|UpdateLog
operator|.
name|State
operator|.
name|ACTIVE
operator|||
operator|(
name|cmd
operator|.
name|getFlags
argument_list|()
operator|&
name|UpdateCommand
operator|.
name|REPLAY
operator|)
operator|!=
literal|0
condition|)
block|{
name|super
operator|.
name|processCommit
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|log
operator|.
name|info
argument_list|(
literal|"Ignoring commit while not ACTIVE - state: "
operator|+
name|ulog
operator|.
name|getState
argument_list|()
operator|+
literal|" replay:"
operator|+
operator|(
name|cmd
operator|.
name|getFlags
argument_list|()
operator|&
name|UpdateCommand
operator|.
name|REPLAY
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
if|if
condition|(
name|vinfo
operator|!=
literal|null
condition|)
block|{
name|vinfo
operator|.
name|unlockForUpdate
argument_list|()
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|Override
DECL|method|finish
specifier|public
name|void
name|finish
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|zkEnabled
condition|)
name|doFinish
argument_list|()
expr_stmt|;
if|if
condition|(
name|next
operator|!=
literal|null
operator|&&
name|nodes
operator|==
literal|null
condition|)
name|next
operator|.
name|finish
argument_list|()
expr_stmt|;
block|}
DECL|method|getCollectionUrls
specifier|private
name|List
argument_list|<
name|Node
argument_list|>
name|getCollectionUrls
parameter_list|(
name|SolrQueryRequest
name|req
parameter_list|,
name|String
name|collection
parameter_list|)
block|{
name|ClusterState
name|clusterState
init|=
name|req
operator|.
name|getCore
argument_list|()
operator|.
name|getCoreDescriptor
argument_list|()
operator|.
name|getCoreContainer
argument_list|()
operator|.
name|getZkController
argument_list|()
operator|.
name|getClusterState
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|Node
argument_list|>
name|urls
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|Slice
argument_list|>
name|slices
init|=
name|clusterState
operator|.
name|getSlicesMap
argument_list|(
name|collection
argument_list|)
decl_stmt|;
if|if
condition|(
name|slices
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|ZooKeeperException
argument_list|(
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
literal|"Could not find collection in zk: "
operator|+
name|clusterState
argument_list|)
throw|;
block|}
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|Slice
argument_list|>
name|sliceEntry
range|:
name|slices
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|Slice
name|replicas
init|=
name|slices
operator|.
name|get
argument_list|(
name|sliceEntry
operator|.
name|getKey
argument_list|()
argument_list|)
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|Replica
argument_list|>
name|shardMap
init|=
name|replicas
operator|.
name|getReplicasMap
argument_list|()
decl_stmt|;
for|for
control|(
name|Entry
argument_list|<
name|String
argument_list|,
name|Replica
argument_list|>
name|entry
range|:
name|shardMap
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|ZkCoreNodeProps
name|nodeProps
init|=
operator|new
name|ZkCoreNodeProps
argument_list|(
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|clusterState
operator|.
name|liveNodesContain
argument_list|(
name|nodeProps
operator|.
name|getNodeName
argument_list|()
argument_list|)
condition|)
block|{
name|urls
operator|.
name|add
argument_list|(
operator|new
name|StdNode
argument_list|(
name|nodeProps
argument_list|,
name|collection
argument_list|,
name|replicas
operator|.
name|getName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|urls
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|urls
return|;
block|}
comment|/**    * Returns a boolean indicating whether or not the caller should behave as    * if this is the "leader" even when ZooKeeper is not enabled.      * (Even in non zk mode, tests may simulate updates to/from a leader)    */
DECL|method|getNonZkLeaderAssumption
specifier|public
specifier|static
name|boolean
name|getNonZkLeaderAssumption
parameter_list|(
name|SolrQueryRequest
name|req
parameter_list|)
block|{
name|DistribPhase
name|phase
init|=
name|DistribPhase
operator|.
name|parseParam
argument_list|(
name|req
operator|.
name|getParams
argument_list|()
operator|.
name|get
argument_list|(
name|DISTRIB_UPDATE_PARAM
argument_list|)
argument_list|)
decl_stmt|;
comment|// if we have been told we are coming from a leader, then we are
comment|// definitely not the leader.  Otherwise assume we are.
return|return
name|DistribPhase
operator|.
name|FROMLEADER
operator|!=
name|phase
return|;
block|}
block|}
end_class
end_unit
