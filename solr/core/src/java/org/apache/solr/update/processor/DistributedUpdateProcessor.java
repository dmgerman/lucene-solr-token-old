begin_unit
begin_package
DECL|package|org.apache.solr.update.processor
package|package
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|update
operator|.
name|processor
package|;
end_package
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
operator|.
name|Entry
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|BytesRef
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|CharsRef
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|client
operator|.
name|solrj
operator|.
name|impl
operator|.
name|HttpSolrServer
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|client
operator|.
name|solrj
operator|.
name|request
operator|.
name|CoreAdminRequest
operator|.
name|RequestRecovery
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|cloud
operator|.
name|CloudDescriptor
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|cloud
operator|.
name|ZkController
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|SolrException
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|SolrException
operator|.
name|ErrorCode
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|SolrInputDocument
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|SolrInputField
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|cloud
operator|.
name|ClusterState
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|cloud
operator|.
name|Slice
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|cloud
operator|.
name|ZkCoreNodeProps
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|cloud
operator|.
name|ZkNodeProps
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|cloud
operator|.
name|ZkStateReader
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|cloud
operator|.
name|ZooKeeperException
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|params
operator|.
name|CoreAdminParams
operator|.
name|CoreAdminAction
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|params
operator|.
name|ModifiableSolrParams
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|params
operator|.
name|UpdateParams
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|util
operator|.
name|Hash
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|util
operator|.
name|NamedList
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|core
operator|.
name|CoreDescriptor
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|handler
operator|.
name|component
operator|.
name|RealTimeGetComponent
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|request
operator|.
name|SolrQueryRequest
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|request
operator|.
name|SolrRequestInfo
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|response
operator|.
name|SolrQueryResponse
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|schema
operator|.
name|SchemaField
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|update
operator|.
name|AddUpdateCommand
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|update
operator|.
name|CommitUpdateCommand
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|update
operator|.
name|DeleteUpdateCommand
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|update
operator|.
name|SolrCmdDistributor
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|update
operator|.
name|SolrCmdDistributor
operator|.
name|Node
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|update
operator|.
name|SolrCmdDistributor
operator|.
name|Response
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|update
operator|.
name|SolrCmdDistributor
operator|.
name|StdNode
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|update
operator|.
name|UpdateCommand
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|update
operator|.
name|UpdateHandler
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|update
operator|.
name|UpdateLog
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|update
operator|.
name|VersionBucket
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|update
operator|.
name|VersionInfo
import|;
end_import
begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import
begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import
begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|update
operator|.
name|processor
operator|.
name|DistributingUpdateProcessorFactory
operator|.
name|DISTRIB_UPDATE_PARAM
import|;
end_import
begin_comment
comment|// NOT mt-safe... create a new processor for each add thread
end_comment
begin_comment
comment|// TODO: we really should not wait for distrib after local? unless a certain replication factor is asked for
end_comment
begin_class
DECL|class|DistributedUpdateProcessor
specifier|public
class|class
name|DistributedUpdateProcessor
extends|extends
name|UpdateRequestProcessor
block|{
DECL|field|log
specifier|public
specifier|final
specifier|static
name|Logger
name|log
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|DistributedUpdateProcessor
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/**    * Values this processor supports for the<code>DISTRIB_UPDATE_PARAM</code>.    * This is an implementation detail exposed solely for tests.    *     * @see DistributingUpdateProcessorFactory#DISTRIB_UPDATE_PARAM    */
DECL|enum|DistribPhase
specifier|public
specifier|static
enum|enum
name|DistribPhase
block|{
DECL|enum constant|NONE
DECL|enum constant|TOLEADER
DECL|enum constant|FROMLEADER
name|NONE
block|,
name|TOLEADER
block|,
name|FROMLEADER
block|;
DECL|method|parseParam
specifier|public
specifier|static
name|DistribPhase
name|parseParam
parameter_list|(
specifier|final
name|String
name|param
parameter_list|)
block|{
if|if
condition|(
name|param
operator|==
literal|null
operator|||
name|param
operator|.
name|trim
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
name|NONE
return|;
block|}
try|try
block|{
return|return
name|valueOf
argument_list|(
name|param
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|SolrException
operator|.
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
literal|"Illegal value for "
operator|+
name|DISTRIB_UPDATE_PARAM
operator|+
literal|": "
operator|+
name|param
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
block|}
DECL|field|COMMIT_END_POINT
specifier|public
specifier|static
specifier|final
name|String
name|COMMIT_END_POINT
init|=
literal|"commit_end_point"
decl_stmt|;
DECL|field|req
specifier|private
specifier|final
name|SolrQueryRequest
name|req
decl_stmt|;
DECL|field|rsp
specifier|private
specifier|final
name|SolrQueryResponse
name|rsp
decl_stmt|;
DECL|field|next
specifier|private
specifier|final
name|UpdateRequestProcessor
name|next
decl_stmt|;
DECL|field|VERSION_FIELD
specifier|public
specifier|static
specifier|final
name|String
name|VERSION_FIELD
init|=
literal|"_version_"
decl_stmt|;
DECL|field|updateHandler
specifier|private
specifier|final
name|UpdateHandler
name|updateHandler
decl_stmt|;
DECL|field|ulog
specifier|private
specifier|final
name|UpdateLog
name|ulog
decl_stmt|;
DECL|field|vinfo
specifier|private
specifier|final
name|VersionInfo
name|vinfo
decl_stmt|;
DECL|field|versionsStored
specifier|private
specifier|final
name|boolean
name|versionsStored
decl_stmt|;
DECL|field|returnVersions
specifier|private
name|boolean
name|returnVersions
init|=
literal|true
decl_stmt|;
comment|// todo: default to false and make configurable
DECL|field|addsResponse
specifier|private
name|NamedList
name|addsResponse
init|=
literal|null
decl_stmt|;
DECL|field|deleteResponse
specifier|private
name|NamedList
name|deleteResponse
init|=
literal|null
decl_stmt|;
DECL|field|deleteByQueryResponse
specifier|private
name|NamedList
name|deleteByQueryResponse
init|=
literal|null
decl_stmt|;
DECL|field|scratch
specifier|private
name|CharsRef
name|scratch
decl_stmt|;
DECL|field|idField
specifier|private
specifier|final
name|SchemaField
name|idField
decl_stmt|;
DECL|field|cmdDistrib
specifier|private
specifier|final
name|SolrCmdDistributor
name|cmdDistrib
decl_stmt|;
DECL|field|zkEnabled
specifier|private
name|boolean
name|zkEnabled
init|=
literal|false
decl_stmt|;
DECL|field|cloudDesc
specifier|private
name|CloudDescriptor
name|cloudDesc
decl_stmt|;
DECL|field|collection
specifier|private
name|String
name|collection
decl_stmt|;
DECL|field|zkController
specifier|private
name|ZkController
name|zkController
decl_stmt|;
comment|// these are setup at the start of each request processing
comment|// method in this update processor
DECL|field|isLeader
specifier|private
name|boolean
name|isLeader
init|=
literal|true
decl_stmt|;
DECL|field|forwardToLeader
specifier|private
name|boolean
name|forwardToLeader
init|=
literal|false
decl_stmt|;
DECL|field|nodes
specifier|private
name|List
argument_list|<
name|Node
argument_list|>
name|nodes
decl_stmt|;
DECL|field|numNodes
specifier|private
name|int
name|numNodes
decl_stmt|;
DECL|method|DistributedUpdateProcessor
specifier|public
name|DistributedUpdateProcessor
parameter_list|(
name|SolrQueryRequest
name|req
parameter_list|,
name|SolrQueryResponse
name|rsp
parameter_list|,
name|UpdateRequestProcessor
name|next
parameter_list|)
block|{
name|super
argument_list|(
name|next
argument_list|)
expr_stmt|;
name|this
operator|.
name|rsp
operator|=
name|rsp
expr_stmt|;
name|this
operator|.
name|next
operator|=
name|next
expr_stmt|;
name|this
operator|.
name|idField
operator|=
name|req
operator|.
name|getSchema
argument_list|()
operator|.
name|getUniqueKeyField
argument_list|()
expr_stmt|;
comment|// version init
name|this
operator|.
name|updateHandler
operator|=
name|req
operator|.
name|getCore
argument_list|()
operator|.
name|getUpdateHandler
argument_list|()
expr_stmt|;
name|this
operator|.
name|ulog
operator|=
name|updateHandler
operator|.
name|getUpdateLog
argument_list|()
expr_stmt|;
name|this
operator|.
name|vinfo
operator|=
name|ulog
operator|==
literal|null
condition|?
literal|null
else|:
name|ulog
operator|.
name|getVersionInfo
argument_list|()
expr_stmt|;
name|versionsStored
operator|=
name|this
operator|.
name|vinfo
operator|!=
literal|null
operator|&&
name|this
operator|.
name|vinfo
operator|.
name|getVersionField
argument_list|()
operator|!=
literal|null
expr_stmt|;
name|returnVersions
operator|=
name|req
operator|.
name|getParams
argument_list|()
operator|.
name|getBool
argument_list|(
name|UpdateParams
operator|.
name|VERSIONS
argument_list|,
literal|false
argument_list|)
expr_stmt|;
comment|// TODO: better way to get the response, or pass back info to it?
name|SolrRequestInfo
name|reqInfo
init|=
name|returnVersions
condition|?
name|SolrRequestInfo
operator|.
name|getRequestInfo
argument_list|()
else|:
literal|null
decl_stmt|;
name|this
operator|.
name|req
operator|=
name|req
expr_stmt|;
name|CoreDescriptor
name|coreDesc
init|=
name|req
operator|.
name|getCore
argument_list|()
operator|.
name|getCoreDescriptor
argument_list|()
decl_stmt|;
name|this
operator|.
name|zkEnabled
operator|=
name|coreDesc
operator|.
name|getCoreContainer
argument_list|()
operator|.
name|isZooKeeperAware
argument_list|()
expr_stmt|;
name|zkController
operator|=
name|req
operator|.
name|getCore
argument_list|()
operator|.
name|getCoreDescriptor
argument_list|()
operator|.
name|getCoreContainer
argument_list|()
operator|.
name|getZkController
argument_list|()
expr_stmt|;
if|if
condition|(
name|zkEnabled
condition|)
block|{
name|numNodes
operator|=
name|zkController
operator|.
name|getZkStateReader
argument_list|()
operator|.
name|getClusterState
argument_list|()
operator|.
name|getLiveNodes
argument_list|()
operator|.
name|size
argument_list|()
expr_stmt|;
block|}
comment|//this.rsp = reqInfo != null ? reqInfo.getRsp() : null;
name|cloudDesc
operator|=
name|coreDesc
operator|.
name|getCloudDescriptor
argument_list|()
expr_stmt|;
if|if
condition|(
name|cloudDesc
operator|!=
literal|null
condition|)
block|{
name|collection
operator|=
name|cloudDesc
operator|.
name|getCollectionName
argument_list|()
expr_stmt|;
block|}
name|cmdDistrib
operator|=
operator|new
name|SolrCmdDistributor
argument_list|(
name|numNodes
argument_list|)
expr_stmt|;
block|}
DECL|method|setupRequest
specifier|private
name|List
argument_list|<
name|Node
argument_list|>
name|setupRequest
parameter_list|(
name|int
name|hash
parameter_list|)
block|{
name|List
argument_list|<
name|Node
argument_list|>
name|nodes
init|=
literal|null
decl_stmt|;
comment|// if we are in zk mode...
if|if
condition|(
name|zkEnabled
condition|)
block|{
comment|// set num nodes
name|numNodes
operator|=
name|zkController
operator|.
name|getClusterState
argument_list|()
operator|.
name|getLiveNodes
argument_list|()
operator|.
name|size
argument_list|()
expr_stmt|;
comment|// the leader is...
comment|// TODO: if there is no leader, wait and look again
comment|// TODO: we are reading the leader from zk every time - we should cache
comment|// this and watch for changes?? Just pull it from ZkController cluster state probably?
name|String
name|shardId
init|=
name|getShard
argument_list|(
name|hash
argument_list|,
name|collection
argument_list|,
name|zkController
operator|.
name|getClusterState
argument_list|()
argument_list|)
decl_stmt|;
comment|// get the right shard based on the hash...
try|try
block|{
comment|// TODO: if we find out we cannot talk to zk anymore, we should probably realize we are not
comment|// a leader anymore - we shouldn't accept updates at all??
name|ZkCoreNodeProps
name|leaderProps
init|=
operator|new
name|ZkCoreNodeProps
argument_list|(
name|zkController
operator|.
name|getZkStateReader
argument_list|()
operator|.
name|getLeaderProps
argument_list|(
name|collection
argument_list|,
name|shardId
argument_list|)
argument_list|)
decl_stmt|;
name|String
name|leaderNodeName
init|=
name|leaderProps
operator|.
name|getCoreNodeName
argument_list|()
decl_stmt|;
name|String
name|coreName
init|=
name|req
operator|.
name|getCore
argument_list|()
operator|.
name|getName
argument_list|()
decl_stmt|;
name|String
name|coreNodeName
init|=
name|zkController
operator|.
name|getNodeName
argument_list|()
operator|+
literal|"_"
operator|+
name|coreName
decl_stmt|;
name|isLeader
operator|=
name|coreNodeName
operator|.
name|equals
argument_list|(
name|leaderNodeName
argument_list|)
expr_stmt|;
name|DistribPhase
name|phase
init|=
name|DistribPhase
operator|.
name|parseParam
argument_list|(
name|req
operator|.
name|getParams
argument_list|()
operator|.
name|get
argument_list|(
name|DISTRIB_UPDATE_PARAM
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|DistribPhase
operator|.
name|FROMLEADER
operator|==
name|phase
condition|)
block|{
comment|// we are coming from the leader, just go local - add no urls
name|forwardToLeader
operator|=
literal|false
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isLeader
condition|)
block|{
comment|// that means I want to forward onto my replicas...
comment|// so get the replicas...
name|forwardToLeader
operator|=
literal|false
expr_stmt|;
name|List
argument_list|<
name|ZkCoreNodeProps
argument_list|>
name|replicaProps
init|=
name|zkController
operator|.
name|getZkStateReader
argument_list|()
operator|.
name|getReplicaProps
argument_list|(
name|collection
argument_list|,
name|shardId
argument_list|,
name|zkController
operator|.
name|getNodeName
argument_list|()
argument_list|,
name|coreName
argument_list|,
literal|null
argument_list|,
name|ZkStateReader
operator|.
name|DOWN
argument_list|)
decl_stmt|;
if|if
condition|(
name|replicaProps
operator|!=
literal|null
condition|)
block|{
name|nodes
operator|=
operator|new
name|ArrayList
argument_list|<
name|Node
argument_list|>
argument_list|(
name|replicaProps
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
comment|// check for test param that lets us miss replicas
name|String
index|[]
name|skipList
init|=
name|req
operator|.
name|getParams
argument_list|()
operator|.
name|getParams
argument_list|(
literal|"test.distrib.skip.servers"
argument_list|)
decl_stmt|;
name|Set
argument_list|<
name|String
argument_list|>
name|skipListSet
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|skipList
operator|!=
literal|null
condition|)
block|{
name|skipListSet
operator|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|(
name|skipList
operator|.
name|length
argument_list|)
expr_stmt|;
name|skipListSet
operator|.
name|addAll
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|skipList
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|ZkCoreNodeProps
name|props
range|:
name|replicaProps
control|)
block|{
if|if
condition|(
name|skipList
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
operator|!
name|skipListSet
operator|.
name|contains
argument_list|(
name|props
operator|.
name|getCoreUrl
argument_list|()
argument_list|)
condition|)
block|{
name|nodes
operator|.
name|add
argument_list|(
operator|new
name|StdNode
argument_list|(
name|props
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|nodes
operator|.
name|add
argument_list|(
operator|new
name|StdNode
argument_list|(
name|props
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
block|{
comment|// I need to forward onto the leader...
name|nodes
operator|=
operator|new
name|ArrayList
argument_list|<
name|Node
argument_list|>
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|nodes
operator|.
name|add
argument_list|(
operator|new
name|RetryNode
argument_list|(
name|leaderProps
argument_list|,
name|zkController
operator|.
name|getZkStateReader
argument_list|()
argument_list|,
name|collection
argument_list|,
name|shardId
argument_list|)
argument_list|)
expr_stmt|;
name|forwardToLeader
operator|=
literal|true
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
throw|throw
operator|new
name|ZooKeeperException
argument_list|(
name|SolrException
operator|.
name|ErrorCode
operator|.
name|SERVER_ERROR
argument_list|,
literal|""
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
return|return
name|nodes
return|;
block|}
DECL|method|getShard
specifier|private
name|String
name|getShard
parameter_list|(
name|int
name|hash
parameter_list|,
name|String
name|collection
parameter_list|,
name|ClusterState
name|clusterState
parameter_list|)
block|{
comment|// ranges should be part of the cloud state and eventually gotten from zk
comment|// get the shard names
return|return
name|clusterState
operator|.
name|getShard
argument_list|(
name|hash
argument_list|,
name|collection
argument_list|)
return|;
block|}
comment|// used for deleteByQuery to get the list of nodes this leader should forward to
DECL|method|setupRequest
specifier|private
name|List
argument_list|<
name|Node
argument_list|>
name|setupRequest
parameter_list|()
block|{
name|List
argument_list|<
name|Node
argument_list|>
name|nodes
init|=
literal|null
decl_stmt|;
name|String
name|shardId
init|=
name|cloudDesc
operator|.
name|getShardId
argument_list|()
decl_stmt|;
try|try
block|{
name|ZkCoreNodeProps
name|leaderProps
init|=
operator|new
name|ZkCoreNodeProps
argument_list|(
name|zkController
operator|.
name|getZkStateReader
argument_list|()
operator|.
name|getLeaderProps
argument_list|(
name|collection
argument_list|,
name|shardId
argument_list|)
argument_list|)
decl_stmt|;
name|String
name|leaderNodeName
init|=
name|leaderProps
operator|.
name|getCoreNodeName
argument_list|()
decl_stmt|;
name|String
name|coreName
init|=
name|req
operator|.
name|getCore
argument_list|()
operator|.
name|getName
argument_list|()
decl_stmt|;
name|String
name|coreNodeName
init|=
name|zkController
operator|.
name|getNodeName
argument_list|()
operator|+
literal|"_"
operator|+
name|coreName
decl_stmt|;
name|isLeader
operator|=
name|coreNodeName
operator|.
name|equals
argument_list|(
name|leaderNodeName
argument_list|)
expr_stmt|;
comment|// TODO: what if we are no longer the leader?
name|forwardToLeader
operator|=
literal|false
expr_stmt|;
name|List
argument_list|<
name|ZkCoreNodeProps
argument_list|>
name|replicaProps
init|=
name|zkController
operator|.
name|getZkStateReader
argument_list|()
operator|.
name|getReplicaProps
argument_list|(
name|collection
argument_list|,
name|shardId
argument_list|,
name|zkController
operator|.
name|getNodeName
argument_list|()
argument_list|,
name|coreName
argument_list|)
decl_stmt|;
if|if
condition|(
name|replicaProps
operator|!=
literal|null
condition|)
block|{
name|nodes
operator|=
operator|new
name|ArrayList
argument_list|<
name|Node
argument_list|>
argument_list|(
name|replicaProps
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|ZkCoreNodeProps
name|props
range|:
name|replicaProps
control|)
block|{
name|nodes
operator|.
name|add
argument_list|(
operator|new
name|StdNode
argument_list|(
name|props
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
throw|throw
operator|new
name|ZooKeeperException
argument_list|(
name|SolrException
operator|.
name|ErrorCode
operator|.
name|SERVER_ERROR
argument_list|,
literal|""
argument_list|,
name|e
argument_list|)
throw|;
block|}
return|return
name|nodes
return|;
block|}
annotation|@
name|Override
DECL|method|processAdd
specifier|public
name|void
name|processAdd
parameter_list|(
name|AddUpdateCommand
name|cmd
parameter_list|)
throws|throws
name|IOException
block|{
comment|// TODO: check for id field?
name|int
name|hash
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|zkEnabled
condition|)
block|{
name|zkCheck
argument_list|()
expr_stmt|;
name|hash
operator|=
name|hash
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
name|nodes
operator|=
name|setupRequest
argument_list|(
name|hash
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|isLeader
operator|=
name|getNonZkLeaderAssumption
argument_list|(
name|req
argument_list|)
expr_stmt|;
block|}
name|boolean
name|dropCmd
init|=
literal|false
decl_stmt|;
if|if
condition|(
operator|!
name|forwardToLeader
condition|)
block|{
comment|// clone the original doc
name|SolrInputDocument
name|clonedDoc
init|=
name|cmd
operator|.
name|solrDoc
operator|.
name|deepCopy
argument_list|()
decl_stmt|;
name|dropCmd
operator|=
name|versionAdd
argument_list|(
name|cmd
argument_list|,
name|clonedDoc
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|solrDoc
operator|=
name|clonedDoc
expr_stmt|;
block|}
if|if
condition|(
name|dropCmd
condition|)
block|{
comment|// TODO: do we need to add anything to the response?
return|return;
block|}
name|ModifiableSolrParams
name|params
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|nodes
operator|!=
literal|null
condition|)
block|{
name|params
operator|=
operator|new
name|ModifiableSolrParams
argument_list|(
name|req
operator|.
name|getParams
argument_list|()
argument_list|)
expr_stmt|;
name|params
operator|.
name|set
argument_list|(
name|DISTRIB_UPDATE_PARAM
argument_list|,
operator|(
name|isLeader
condition|?
name|DistribPhase
operator|.
name|FROMLEADER
operator|.
name|toString
argument_list|()
else|:
name|DistribPhase
operator|.
name|TOLEADER
operator|.
name|toString
argument_list|()
operator|)
argument_list|)
expr_stmt|;
name|params
operator|.
name|remove
argument_list|(
literal|"commit"
argument_list|)
expr_stmt|;
comment|// this will be distributed from the local commit
name|cmdDistrib
operator|.
name|distribAdd
argument_list|(
name|cmd
argument_list|,
name|nodes
argument_list|,
name|params
argument_list|)
expr_stmt|;
block|}
comment|// TODO: what to do when no idField?
if|if
condition|(
name|returnVersions
operator|&&
name|rsp
operator|!=
literal|null
operator|&&
name|idField
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|addsResponse
operator|==
literal|null
condition|)
block|{
name|addsResponse
operator|=
operator|new
name|NamedList
argument_list|<
name|String
argument_list|>
argument_list|()
expr_stmt|;
name|rsp
operator|.
name|add
argument_list|(
literal|"adds"
argument_list|,
name|addsResponse
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|scratch
operator|==
literal|null
condition|)
name|scratch
operator|=
operator|new
name|CharsRef
argument_list|()
expr_stmt|;
name|idField
operator|.
name|getType
argument_list|()
operator|.
name|indexedToReadable
argument_list|(
name|cmd
operator|.
name|getIndexedId
argument_list|()
argument_list|,
name|scratch
argument_list|)
expr_stmt|;
name|addsResponse
operator|.
name|add
argument_list|(
name|scratch
operator|.
name|toString
argument_list|()
argument_list|,
name|cmd
operator|.
name|getVersion
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// TODO: keep track of errors?  needs to be done at a higher level though since
comment|// an id may fail before it gets to this processor.
comment|// Given that, it may also make sense to move the version reporting out of this
comment|// processor too.
block|}
comment|// TODO: optionally fail if n replicas are not reached...
DECL|method|doFinish
specifier|private
name|void
name|doFinish
parameter_list|()
block|{
comment|// TODO: if not a forward and replication req is not specified, we could
comment|// send in a background thread
name|cmdDistrib
operator|.
name|finish
argument_list|()
expr_stmt|;
name|Response
name|response
init|=
name|cmdDistrib
operator|.
name|getResponse
argument_list|()
decl_stmt|;
comment|// TODO - we may need to tell about more than one error...
comment|// if its a forward, any fail is a problem -
comment|// otherwise we assume things are fine if we got it locally
comment|// until we start allowing min replication param
if|if
condition|(
name|response
operator|.
name|errors
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
comment|// if one node is a RetryNode, this was a forward request
if|if
condition|(
name|response
operator|.
name|errors
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|node
operator|instanceof
name|RetryNode
condition|)
block|{
name|rsp
operator|.
name|setException
argument_list|(
name|response
operator|.
name|errors
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|e
argument_list|)
expr_stmt|;
block|}
comment|// else
comment|// for now we don't error - we assume if it was added locally, we
comment|// succeeded
block|}
comment|// if it is not a forward request, for each fail, try to tell them to
comment|// recover - the doc was already added locally, so it should have been
comment|// legit
comment|// TODO: we should do this in the background it would seem
for|for
control|(
name|SolrCmdDistributor
operator|.
name|Error
name|error
range|:
name|response
operator|.
name|errors
control|)
block|{
if|if
condition|(
name|error
operator|.
name|node
operator|instanceof
name|RetryNode
condition|)
block|{
comment|// we don't try to force a leader to recover
comment|// when we cannot forward to it
continue|continue;
block|}
comment|// TODO: we should force their state to recovering ??
comment|// TODO: could be sent in parallel
comment|// TODO: do retries??
comment|// TODO: what if its is already recovering? Right now recoveries queue up -
comment|// should they?
name|String
name|recoveryUrl
init|=
name|error
operator|.
name|node
operator|.
name|getBaseUrl
argument_list|()
decl_stmt|;
name|HttpSolrServer
name|server
decl_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"try and ask "
operator|+
name|recoveryUrl
operator|+
literal|" to recover"
argument_list|)
expr_stmt|;
try|try
block|{
name|server
operator|=
operator|new
name|HttpSolrServer
argument_list|(
name|recoveryUrl
argument_list|)
expr_stmt|;
name|server
operator|.
name|setSoTimeout
argument_list|(
literal|5000
argument_list|)
expr_stmt|;
name|server
operator|.
name|setConnectionTimeout
argument_list|(
literal|5000
argument_list|)
expr_stmt|;
name|RequestRecovery
name|recoverRequestCmd
init|=
operator|new
name|RequestRecovery
argument_list|()
decl_stmt|;
name|recoverRequestCmd
operator|.
name|setAction
argument_list|(
name|CoreAdminAction
operator|.
name|REQUESTRECOVERY
argument_list|)
expr_stmt|;
name|recoverRequestCmd
operator|.
name|setCoreName
argument_list|(
name|error
operator|.
name|node
operator|.
name|getCoreName
argument_list|()
argument_list|)
expr_stmt|;
name|server
operator|.
name|request
argument_list|(
name|recoverRequestCmd
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"Could not tell a replica to recover"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// must be synchronized by bucket
DECL|method|doLocalAdd
specifier|private
name|void
name|doLocalAdd
parameter_list|(
name|AddUpdateCommand
name|cmd
parameter_list|)
throws|throws
name|IOException
block|{
name|super
operator|.
name|processAdd
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
block|}
comment|// must be synchronized by bucket
DECL|method|doLocalDelete
specifier|private
name|void
name|doLocalDelete
parameter_list|(
name|DeleteUpdateCommand
name|cmd
parameter_list|)
throws|throws
name|IOException
block|{
name|super
operator|.
name|processDelete
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
block|}
comment|/**    * @param cmd    * @param cloneDoc needs the version if it's assigned    * @return whether or not to drop this cmd    * @throws IOException    */
DECL|method|versionAdd
specifier|private
name|boolean
name|versionAdd
parameter_list|(
name|AddUpdateCommand
name|cmd
parameter_list|,
name|SolrInputDocument
name|cloneDoc
parameter_list|)
throws|throws
name|IOException
block|{
name|BytesRef
name|idBytes
init|=
name|cmd
operator|.
name|getIndexedId
argument_list|()
decl_stmt|;
if|if
condition|(
name|vinfo
operator|==
literal|null
operator|||
name|idBytes
operator|==
literal|null
condition|)
block|{
name|super
operator|.
name|processAdd
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
comment|// This is only the hash for the bucket, and must be based only on the uniqueKey (i.e. do not use a pluggable hash here)
name|int
name|bucketHash
init|=
name|Hash
operator|.
name|murmurhash3_x86_32
argument_list|(
name|idBytes
operator|.
name|bytes
argument_list|,
name|idBytes
operator|.
name|offset
argument_list|,
name|idBytes
operator|.
name|length
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|// at this point, there is an update we need to try and apply.
comment|// we may or may not be the leader.
comment|// Find any existing version in the document
comment|// TODO: don't reuse update commands any more!
name|long
name|versionOnUpdate
init|=
name|cmd
operator|.
name|getVersion
argument_list|()
decl_stmt|;
if|if
condition|(
name|versionOnUpdate
operator|==
literal|0
condition|)
block|{
name|SolrInputField
name|versionField
init|=
name|cmd
operator|.
name|getSolrInputDocument
argument_list|()
operator|.
name|getField
argument_list|(
name|VersionInfo
operator|.
name|VERSION_FIELD
argument_list|)
decl_stmt|;
if|if
condition|(
name|versionField
operator|!=
literal|null
condition|)
block|{
name|Object
name|o
init|=
name|versionField
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|versionOnUpdate
operator|=
name|o
operator|instanceof
name|Number
condition|?
operator|(
operator|(
name|Number
operator|)
name|o
operator|)
operator|.
name|longValue
argument_list|()
else|:
name|Long
operator|.
name|parseLong
argument_list|(
name|o
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Find the version
name|String
name|versionOnUpdateS
init|=
name|req
operator|.
name|getParams
argument_list|()
operator|.
name|get
argument_list|(
name|VERSION_FIELD
argument_list|)
decl_stmt|;
name|versionOnUpdate
operator|=
name|versionOnUpdateS
operator|==
literal|null
condition|?
literal|0
else|:
name|Long
operator|.
name|parseLong
argument_list|(
name|versionOnUpdateS
argument_list|)
expr_stmt|;
block|}
block|}
name|boolean
name|isReplay
init|=
operator|(
name|cmd
operator|.
name|getFlags
argument_list|()
operator|&
name|UpdateCommand
operator|.
name|REPLAY
operator|)
operator|!=
literal|0
decl_stmt|;
name|boolean
name|leaderLogic
init|=
name|isLeader
operator|&&
operator|!
name|isReplay
decl_stmt|;
name|VersionBucket
name|bucket
init|=
name|vinfo
operator|.
name|bucket
argument_list|(
name|bucketHash
argument_list|)
decl_stmt|;
name|vinfo
operator|.
name|lockForUpdate
argument_list|()
expr_stmt|;
try|try
block|{
synchronized|synchronized
init|(
name|bucket
init|)
block|{
comment|// we obtain the version when synchronized and then do the add so we can ensure that
comment|// if version1< version2 then version1 is actually added before version2.
comment|// even if we don't store the version field, synchronizing on the bucket
comment|// will enable us to know what version happened first, and thus enable
comment|// realtime-get to work reliably.
comment|// TODO: if versions aren't stored, do we need to set on the cmd anyway for some reason?
comment|// there may be other reasons in the future for a version on the commands
name|boolean
name|checkDeleteByQueries
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|versionsStored
condition|)
block|{
name|long
name|bucketVersion
init|=
name|bucket
operator|.
name|highest
decl_stmt|;
if|if
condition|(
name|leaderLogic
condition|)
block|{
name|boolean
name|updated
init|=
name|getUpdatedDocument
argument_list|(
name|cmd
argument_list|,
name|versionOnUpdate
argument_list|)
decl_stmt|;
if|if
condition|(
name|versionOnUpdate
operator|!=
literal|0
condition|)
block|{
name|Long
name|lastVersion
init|=
name|vinfo
operator|.
name|lookupVersion
argument_list|(
name|cmd
operator|.
name|getIndexedId
argument_list|()
argument_list|)
decl_stmt|;
name|long
name|foundVersion
init|=
name|lastVersion
operator|==
literal|null
condition|?
operator|-
literal|1
else|:
name|lastVersion
decl_stmt|;
if|if
condition|(
name|versionOnUpdate
operator|==
name|foundVersion
operator|||
operator|(
name|versionOnUpdate
operator|<
literal|0
operator|&&
name|foundVersion
operator|<
literal|0
operator|)
operator|||
operator|(
name|versionOnUpdate
operator|==
literal|1
operator|&&
name|foundVersion
operator|>
literal|0
operator|)
condition|)
block|{
comment|// we're ok if versions match, or if both are negative (all missing docs are equal), or if cmd
comment|// specified it must exist (versionOnUpdate==1) and it does.
block|}
else|else
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|CONFLICT
argument_list|,
literal|"version conflict for "
operator|+
name|cmd
operator|.
name|getPrintableId
argument_list|()
operator|+
literal|" expected="
operator|+
name|versionOnUpdate
operator|+
literal|" actual="
operator|+
name|foundVersion
argument_list|)
throw|;
block|}
block|}
name|long
name|version
init|=
name|vinfo
operator|.
name|getNewClock
argument_list|()
decl_stmt|;
name|cmd
operator|.
name|setVersion
argument_list|(
name|version
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|getSolrInputDocument
argument_list|()
operator|.
name|setField
argument_list|(
name|VersionInfo
operator|.
name|VERSION_FIELD
argument_list|,
name|version
argument_list|)
expr_stmt|;
name|cloneDoc
operator|.
name|setField
argument_list|(
name|VersionInfo
operator|.
name|VERSION_FIELD
argument_list|,
name|version
argument_list|)
expr_stmt|;
name|bucket
operator|.
name|updateHighest
argument_list|(
name|version
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// The leader forwarded us this update.
name|cmd
operator|.
name|setVersion
argument_list|(
name|versionOnUpdate
argument_list|)
expr_stmt|;
if|if
condition|(
name|ulog
operator|.
name|getState
argument_list|()
operator|!=
name|UpdateLog
operator|.
name|State
operator|.
name|ACTIVE
operator|&&
operator|(
name|cmd
operator|.
name|getFlags
argument_list|()
operator|&
name|UpdateCommand
operator|.
name|REPLAY
operator|)
operator|==
literal|0
condition|)
block|{
comment|// we're not in an active state, and this update isn't from a replay, so buffer it.
name|cmd
operator|.
name|setFlags
argument_list|(
name|cmd
operator|.
name|getFlags
argument_list|()
operator||
name|UpdateCommand
operator|.
name|BUFFERING
argument_list|)
expr_stmt|;
name|ulog
operator|.
name|add
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
comment|// if we aren't the leader, then we need to check that updates were not re-ordered
if|if
condition|(
name|bucketVersion
operator|!=
literal|0
operator|&&
name|bucketVersion
operator|<
name|versionOnUpdate
condition|)
block|{
comment|// we're OK... this update has a version higher than anything we've seen
comment|// in this bucket so far, so we know that no reordering has yet occurred.
name|bucket
operator|.
name|updateHighest
argument_list|(
name|versionOnUpdate
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// there have been updates higher than the current update.  we need to check
comment|// the specific version for this id.
name|Long
name|lastVersion
init|=
name|vinfo
operator|.
name|lookupVersion
argument_list|(
name|cmd
operator|.
name|getIndexedId
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|lastVersion
operator|!=
literal|null
operator|&&
name|Math
operator|.
name|abs
argument_list|(
name|lastVersion
argument_list|)
operator|>=
name|versionOnUpdate
condition|)
block|{
comment|// This update is a repeat, or was reordered.  We need to drop this update.
return|return
literal|true
return|;
block|}
comment|// also need to re-apply newer deleteByQuery commands
name|checkDeleteByQueries
operator|=
literal|true
expr_stmt|;
block|}
block|}
block|}
comment|// TODO: possibly set checkDeleteByQueries as a flag on the command?
name|doLocalAdd
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
block|}
comment|// end synchronized (bucket)
block|}
finally|finally
block|{
name|vinfo
operator|.
name|unlockForUpdate
argument_list|()
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
comment|// TODO: may want to switch to using optimistic locking in the future for better concurrency
comment|// that's why this code is here... need to retry in a loop closely around/in versionAdd
DECL|method|getUpdatedDocument
name|boolean
name|getUpdatedDocument
parameter_list|(
name|AddUpdateCommand
name|cmd
parameter_list|,
name|long
name|versionOnUpdate
parameter_list|)
throws|throws
name|IOException
block|{
name|SolrInputDocument
name|sdoc
init|=
name|cmd
operator|.
name|getSolrInputDocument
argument_list|()
decl_stmt|;
name|boolean
name|update
init|=
literal|false
decl_stmt|;
for|for
control|(
name|SolrInputField
name|sif
range|:
name|sdoc
operator|.
name|values
argument_list|()
control|)
block|{
if|if
condition|(
name|sif
operator|.
name|getValue
argument_list|()
operator|instanceof
name|Map
condition|)
block|{
name|update
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|update
condition|)
return|return
literal|false
return|;
name|BytesRef
name|id
init|=
name|cmd
operator|.
name|getIndexedId
argument_list|()
decl_stmt|;
name|SolrInputDocument
name|oldDoc
init|=
name|RealTimeGetComponent
operator|.
name|getInputDocument
argument_list|(
name|cmd
operator|.
name|getReq
argument_list|()
operator|.
name|getCore
argument_list|()
argument_list|,
name|id
argument_list|)
decl_stmt|;
if|if
condition|(
name|oldDoc
operator|==
literal|null
condition|)
block|{
comment|// create a new doc by default if an old one wasn't found
if|if
condition|(
name|versionOnUpdate
operator|<=
literal|0
condition|)
block|{
name|oldDoc
operator|=
operator|new
name|SolrInputDocument
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|// could just let the optimistic locking throw the error
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|CONFLICT
argument_list|,
literal|"Document not found for update.  id="
operator|+
name|cmd
operator|.
name|getPrintableId
argument_list|()
argument_list|)
throw|;
block|}
block|}
else|else
block|{
name|oldDoc
operator|.
name|remove
argument_list|(
name|VERSION_FIELD
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|SolrInputField
name|sif
range|:
name|sdoc
operator|.
name|values
argument_list|()
control|)
block|{
name|Object
name|val
init|=
name|sif
operator|.
name|getValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|val
operator|instanceof
name|Map
condition|)
block|{
for|for
control|(
name|Entry
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|entry
range|:
operator|(
operator|(
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
operator|)
name|val
operator|)
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|String
name|key
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|Object
name|fieldVal
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
if|if
condition|(
literal|"add"
operator|.
name|equals
argument_list|(
name|key
argument_list|)
condition|)
block|{
name|oldDoc
operator|.
name|addField
argument_list|(
name|sif
operator|.
name|getName
argument_list|()
argument_list|,
name|fieldVal
argument_list|,
name|sif
operator|.
name|getBoost
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|"set"
operator|.
name|equals
argument_list|(
name|key
argument_list|)
condition|)
block|{
name|oldDoc
operator|.
name|setField
argument_list|(
name|sif
operator|.
name|getName
argument_list|()
argument_list|,
name|fieldVal
argument_list|,
name|sif
operator|.
name|getBoost
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|"inc"
operator|.
name|equals
argument_list|(
name|key
argument_list|)
condition|)
block|{
name|SolrInputField
name|numericField
init|=
name|oldDoc
operator|.
name|get
argument_list|(
name|sif
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|numericField
operator|==
literal|null
condition|)
block|{
name|oldDoc
operator|.
name|setField
argument_list|(
name|sif
operator|.
name|getName
argument_list|()
argument_list|,
name|fieldVal
argument_list|,
name|sif
operator|.
name|getBoost
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// TODO: fieldtype needs externalToObject?
name|String
name|oldValS
init|=
name|numericField
operator|.
name|getFirstValue
argument_list|()
operator|.
name|toString
argument_list|()
decl_stmt|;
name|SchemaField
name|sf
init|=
name|cmd
operator|.
name|getReq
argument_list|()
operator|.
name|getSchema
argument_list|()
operator|.
name|getField
argument_list|(
name|sif
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
name|BytesRef
name|term
init|=
operator|new
name|BytesRef
argument_list|()
decl_stmt|;
name|sf
operator|.
name|getType
argument_list|()
operator|.
name|readableToIndexed
argument_list|(
name|oldValS
argument_list|,
name|term
argument_list|)
expr_stmt|;
name|Object
name|oldVal
init|=
name|sf
operator|.
name|getType
argument_list|()
operator|.
name|toObject
argument_list|(
name|sf
argument_list|,
name|term
argument_list|)
decl_stmt|;
name|String
name|fieldValS
init|=
name|fieldVal
operator|.
name|toString
argument_list|()
decl_stmt|;
name|Number
name|result
decl_stmt|;
if|if
condition|(
name|oldVal
operator|instanceof
name|Long
condition|)
block|{
name|result
operator|=
operator|(
operator|(
name|Long
operator|)
name|oldVal
operator|)
operator|.
name|longValue
argument_list|()
operator|+
name|Long
operator|.
name|parseLong
argument_list|(
name|fieldValS
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|oldVal
operator|instanceof
name|Float
condition|)
block|{
name|result
operator|=
operator|(
operator|(
name|Float
operator|)
name|oldVal
operator|)
operator|.
name|floatValue
argument_list|()
operator|+
name|Float
operator|.
name|parseFloat
argument_list|(
name|fieldValS
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|oldVal
operator|instanceof
name|Double
condition|)
block|{
name|result
operator|=
operator|(
operator|(
name|Double
operator|)
name|oldVal
operator|)
operator|.
name|doubleValue
argument_list|()
operator|+
name|Double
operator|.
name|parseDouble
argument_list|(
name|fieldValS
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// int, short, byte
name|result
operator|=
operator|(
operator|(
name|Integer
operator|)
name|oldVal
operator|)
operator|.
name|intValue
argument_list|()
operator|+
name|Integer
operator|.
name|parseInt
argument_list|(
name|fieldValS
argument_list|)
expr_stmt|;
block|}
name|oldDoc
operator|.
name|setField
argument_list|(
name|sif
operator|.
name|getName
argument_list|()
argument_list|,
name|result
argument_list|,
name|sif
operator|.
name|getBoost
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
block|{
comment|// normal fields are treated as a "set"
name|oldDoc
operator|.
name|put
argument_list|(
name|sif
operator|.
name|getName
argument_list|()
argument_list|,
name|sif
argument_list|)
expr_stmt|;
block|}
block|}
name|cmd
operator|.
name|solrDoc
operator|=
name|oldDoc
expr_stmt|;
return|return
literal|true
return|;
block|}
annotation|@
name|Override
DECL|method|processDelete
specifier|public
name|void
name|processDelete
parameter_list|(
name|DeleteUpdateCommand
name|cmd
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|cmd
operator|.
name|isDeleteById
argument_list|()
condition|)
block|{
name|doDeleteByQuery
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
return|return;
block|}
name|int
name|hash
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|zkEnabled
condition|)
block|{
name|zkCheck
argument_list|()
expr_stmt|;
name|hash
operator|=
name|hash
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
name|nodes
operator|=
name|setupRequest
argument_list|(
name|hash
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|isLeader
operator|=
name|getNonZkLeaderAssumption
argument_list|(
name|req
argument_list|)
expr_stmt|;
block|}
name|boolean
name|dropCmd
init|=
literal|false
decl_stmt|;
if|if
condition|(
operator|!
name|forwardToLeader
condition|)
block|{
name|dropCmd
operator|=
name|versionDelete
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dropCmd
condition|)
block|{
comment|// TODO: do we need to add anything to the response?
return|return;
block|}
name|ModifiableSolrParams
name|params
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|nodes
operator|!=
literal|null
condition|)
block|{
name|params
operator|=
operator|new
name|ModifiableSolrParams
argument_list|(
name|req
operator|.
name|getParams
argument_list|()
argument_list|)
expr_stmt|;
name|params
operator|.
name|set
argument_list|(
name|DISTRIB_UPDATE_PARAM
argument_list|,
operator|(
name|isLeader
condition|?
name|DistribPhase
operator|.
name|FROMLEADER
operator|.
name|toString
argument_list|()
else|:
name|DistribPhase
operator|.
name|TOLEADER
operator|.
name|toString
argument_list|()
operator|)
argument_list|)
expr_stmt|;
name|params
operator|.
name|remove
argument_list|(
literal|"commit"
argument_list|)
expr_stmt|;
comment|// we already will have forwarded this from our local commit
name|cmdDistrib
operator|.
name|distribDelete
argument_list|(
name|cmd
argument_list|,
name|nodes
argument_list|,
name|params
argument_list|)
expr_stmt|;
block|}
comment|// cmd.getIndexId == null when delete by query
comment|// TODO: what to do when no idField?
if|if
condition|(
name|returnVersions
operator|&&
name|rsp
operator|!=
literal|null
operator|&&
name|cmd
operator|.
name|getIndexedId
argument_list|()
operator|!=
literal|null
operator|&&
name|idField
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|deleteResponse
operator|==
literal|null
condition|)
block|{
name|deleteResponse
operator|=
operator|new
name|NamedList
argument_list|<
name|String
argument_list|>
argument_list|()
expr_stmt|;
name|rsp
operator|.
name|add
argument_list|(
literal|"deletes"
argument_list|,
name|deleteResponse
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|scratch
operator|==
literal|null
condition|)
name|scratch
operator|=
operator|new
name|CharsRef
argument_list|()
expr_stmt|;
name|idField
operator|.
name|getType
argument_list|()
operator|.
name|indexedToReadable
argument_list|(
name|cmd
operator|.
name|getIndexedId
argument_list|()
argument_list|,
name|scratch
argument_list|)
expr_stmt|;
name|deleteResponse
operator|.
name|add
argument_list|(
name|scratch
operator|.
name|toString
argument_list|()
argument_list|,
name|cmd
operator|.
name|getVersion
argument_list|()
argument_list|)
expr_stmt|;
comment|// we're returning the version of the delete.. not the version of the doc we deleted.
block|}
block|}
DECL|method|doDeleteByQuery
specifier|public
name|void
name|doDeleteByQuery
parameter_list|(
name|DeleteUpdateCommand
name|cmd
parameter_list|)
throws|throws
name|IOException
block|{
comment|// even in non zk mode, tests simulate updates from a leader
if|if
condition|(
operator|!
name|zkEnabled
condition|)
block|{
name|isLeader
operator|=
name|getNonZkLeaderAssumption
argument_list|(
name|req
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|zkCheck
argument_list|()
expr_stmt|;
block|}
comment|// NONE: we are the first to receive this deleteByQuery
comment|//       - it must be forwarded to the leader of every shard
comment|// TO:   we are a leader receiving a forwarded deleteByQuery... we must:
comment|//       - block all updates (use VersionInfo)
comment|//       - flush *all* updates going to our replicas
comment|//       - forward the DBQ to our replicas and wait for the response
comment|//       - log + execute the local DBQ
comment|// FROM: we are a replica receiving a DBQ from our leader
comment|//       - log + execute the local DBQ
name|DistribPhase
name|phase
init|=
name|DistribPhase
operator|.
name|parseParam
argument_list|(
name|req
operator|.
name|getParams
argument_list|()
operator|.
name|get
argument_list|(
name|DISTRIB_UPDATE_PARAM
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|zkEnabled
operator|&&
name|DistribPhase
operator|.
name|NONE
operator|==
name|phase
condition|)
block|{
name|boolean
name|leaderForAnyShard
init|=
literal|false
decl_stmt|;
comment|// start off by assuming we are not a leader for any shard
name|Map
argument_list|<
name|String
argument_list|,
name|Slice
argument_list|>
name|slices
init|=
name|zkController
operator|.
name|getClusterState
argument_list|()
operator|.
name|getSlices
argument_list|(
name|collection
argument_list|)
decl_stmt|;
if|if
condition|(
name|slices
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
literal|"Cannot find collection:"
operator|+
name|collection
operator|+
literal|" in "
operator|+
name|zkController
operator|.
name|getClusterState
argument_list|()
operator|.
name|getCollections
argument_list|()
argument_list|)
throw|;
block|}
name|ModifiableSolrParams
name|params
init|=
operator|new
name|ModifiableSolrParams
argument_list|(
name|req
operator|.
name|getParams
argument_list|()
argument_list|)
decl_stmt|;
name|params
operator|.
name|set
argument_list|(
name|DISTRIB_UPDATE_PARAM
argument_list|,
name|DistribPhase
operator|.
name|TOLEADER
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|Node
argument_list|>
name|leaders
init|=
operator|new
name|ArrayList
argument_list|<
name|Node
argument_list|>
argument_list|(
name|slices
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|Slice
argument_list|>
name|sliceEntry
range|:
name|slices
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|String
name|sliceName
init|=
name|sliceEntry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|ZkNodeProps
name|leaderProps
decl_stmt|;
try|try
block|{
name|leaderProps
operator|=
name|zkController
operator|.
name|getZkStateReader
argument_list|()
operator|.
name|getLeaderProps
argument_list|(
name|collection
argument_list|,
name|sliceName
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|SERVER_ERROR
argument_list|,
literal|"Exception finding leader for shard "
operator|+
name|sliceName
argument_list|,
name|e
argument_list|)
throw|;
block|}
comment|// TODO: What if leaders changed in the meantime?
comment|// should we send out slice-at-a-time and if a node returns "hey, I'm not a leader" (or we get an error because it went down) then look up the new leader?
comment|// Am I the leader for this slice?
name|ZkCoreNodeProps
name|coreLeaderProps
init|=
operator|new
name|ZkCoreNodeProps
argument_list|(
name|leaderProps
argument_list|)
decl_stmt|;
name|String
name|leaderNodeName
init|=
name|coreLeaderProps
operator|.
name|getCoreNodeName
argument_list|()
decl_stmt|;
name|String
name|coreName
init|=
name|req
operator|.
name|getCore
argument_list|()
operator|.
name|getName
argument_list|()
decl_stmt|;
name|String
name|coreNodeName
init|=
name|zkController
operator|.
name|getNodeName
argument_list|()
operator|+
literal|"_"
operator|+
name|coreName
decl_stmt|;
name|isLeader
operator|=
name|coreNodeName
operator|.
name|equals
argument_list|(
name|leaderNodeName
argument_list|)
expr_stmt|;
if|if
condition|(
name|isLeader
condition|)
block|{
comment|// don't forward to ourself
name|leaderForAnyShard
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|leaders
operator|.
name|add
argument_list|(
operator|new
name|StdNode
argument_list|(
name|coreLeaderProps
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|params
operator|.
name|remove
argument_list|(
literal|"commit"
argument_list|)
expr_stmt|;
comment|// this will be distributed from the local commit
name|cmdDistrib
operator|.
name|distribDelete
argument_list|(
name|cmd
argument_list|,
name|leaders
argument_list|,
name|params
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|leaderForAnyShard
condition|)
block|{
return|return;
block|}
comment|// change the phase to TOLEADER so we look up and forward to our own replicas (if any)
name|phase
operator|=
name|DistribPhase
operator|.
name|TOLEADER
expr_stmt|;
block|}
name|List
argument_list|<
name|Node
argument_list|>
name|replicas
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|zkEnabled
operator|&&
name|DistribPhase
operator|.
name|TOLEADER
operator|==
name|phase
condition|)
block|{
comment|// This core should be a leader
name|isLeader
operator|=
literal|true
expr_stmt|;
name|replicas
operator|=
name|setupRequest
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|DistribPhase
operator|.
name|FROMLEADER
operator|==
name|phase
condition|)
block|{
name|isLeader
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
name|vinfo
operator|==
literal|null
condition|)
block|{
name|super
operator|.
name|processDelete
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// at this point, there is an update we need to try and apply.
comment|// we may or may not be the leader.
comment|// Find the version
name|long
name|versionOnUpdate
init|=
name|cmd
operator|.
name|getVersion
argument_list|()
decl_stmt|;
if|if
condition|(
name|versionOnUpdate
operator|==
literal|0
condition|)
block|{
name|String
name|versionOnUpdateS
init|=
name|req
operator|.
name|getParams
argument_list|()
operator|.
name|get
argument_list|(
name|VERSION_FIELD
argument_list|)
decl_stmt|;
name|versionOnUpdate
operator|=
name|versionOnUpdateS
operator|==
literal|null
condition|?
literal|0
else|:
name|Long
operator|.
name|parseLong
argument_list|(
name|versionOnUpdateS
argument_list|)
expr_stmt|;
block|}
name|versionOnUpdate
operator|=
name|Math
operator|.
name|abs
argument_list|(
name|versionOnUpdate
argument_list|)
expr_stmt|;
comment|// normalize to positive version
name|boolean
name|isReplay
init|=
operator|(
name|cmd
operator|.
name|getFlags
argument_list|()
operator|&
name|UpdateCommand
operator|.
name|REPLAY
operator|)
operator|!=
literal|0
decl_stmt|;
name|boolean
name|leaderLogic
init|=
name|isLeader
operator|&&
operator|!
name|isReplay
decl_stmt|;
if|if
condition|(
operator|!
name|leaderLogic
operator|&&
name|versionOnUpdate
operator|==
literal|0
condition|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
literal|"missing _version_ on update from leader"
argument_list|)
throw|;
block|}
name|vinfo
operator|.
name|blockUpdates
argument_list|()
expr_stmt|;
try|try
block|{
if|if
condition|(
name|versionsStored
condition|)
block|{
if|if
condition|(
name|leaderLogic
condition|)
block|{
name|long
name|version
init|=
name|vinfo
operator|.
name|getNewClock
argument_list|()
decl_stmt|;
name|cmd
operator|.
name|setVersion
argument_list|(
operator|-
name|version
argument_list|)
expr_stmt|;
comment|// TODO update versions in all buckets
name|doLocalDelete
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cmd
operator|.
name|setVersion
argument_list|(
operator|-
name|versionOnUpdate
argument_list|)
expr_stmt|;
if|if
condition|(
name|ulog
operator|.
name|getState
argument_list|()
operator|!=
name|UpdateLog
operator|.
name|State
operator|.
name|ACTIVE
operator|&&
operator|(
name|cmd
operator|.
name|getFlags
argument_list|()
operator|&
name|UpdateCommand
operator|.
name|REPLAY
operator|)
operator|==
literal|0
condition|)
block|{
comment|// we're not in an active state, and this update isn't from a replay, so buffer it.
name|cmd
operator|.
name|setFlags
argument_list|(
name|cmd
operator|.
name|getFlags
argument_list|()
operator||
name|UpdateCommand
operator|.
name|BUFFERING
argument_list|)
expr_stmt|;
name|ulog
operator|.
name|deleteByQuery
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
return|return;
block|}
name|doLocalDelete
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
block|}
block|}
comment|// since we don't know which documents were deleted, the easiest thing to do is to invalidate
comment|// all real-time caches (i.e. UpdateLog) which involves also getting a new version of the IndexReader
comment|// (so cache misses will see up-to-date data)
block|}
finally|finally
block|{
name|vinfo
operator|.
name|unblockUpdates
argument_list|()
expr_stmt|;
block|}
comment|// forward to all replicas
if|if
condition|(
name|leaderLogic
operator|&&
name|replicas
operator|!=
literal|null
condition|)
block|{
name|ModifiableSolrParams
name|params
init|=
operator|new
name|ModifiableSolrParams
argument_list|(
name|req
operator|.
name|getParams
argument_list|()
argument_list|)
decl_stmt|;
name|params
operator|.
name|set
argument_list|(
name|VERSION_FIELD
argument_list|,
name|Long
operator|.
name|toString
argument_list|(
name|cmd
operator|.
name|getVersion
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|params
operator|.
name|set
argument_list|(
name|DISTRIB_UPDATE_PARAM
argument_list|,
name|DistribPhase
operator|.
name|FROMLEADER
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|cmdDistrib
operator|.
name|distribDelete
argument_list|(
name|cmd
argument_list|,
name|replicas
argument_list|,
name|params
argument_list|)
expr_stmt|;
name|cmdDistrib
operator|.
name|finish
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|returnVersions
operator|&&
name|rsp
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|deleteByQueryResponse
operator|==
literal|null
condition|)
block|{
name|deleteByQueryResponse
operator|=
operator|new
name|NamedList
argument_list|<
name|String
argument_list|>
argument_list|()
expr_stmt|;
name|rsp
operator|.
name|add
argument_list|(
literal|"deleteByQuery"
argument_list|,
name|deleteByQueryResponse
argument_list|)
expr_stmt|;
block|}
name|deleteByQueryResponse
operator|.
name|add
argument_list|(
name|cmd
operator|.
name|getQuery
argument_list|()
argument_list|,
name|cmd
operator|.
name|getVersion
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|zkCheck
specifier|private
name|void
name|zkCheck
parameter_list|()
block|{
name|int
name|retries
init|=
literal|10
decl_stmt|;
while|while
condition|(
operator|!
name|zkController
operator|.
name|isConnected
argument_list|()
condition|)
block|{
if|if
condition|(
name|retries
operator|--
operator|==
literal|0
condition|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|SERVICE_UNAVAILABLE
argument_list|,
literal|"Cannot talk to ZooKeeper - Updates are disabled."
argument_list|)
throw|;
block|}
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
block|}
DECL|method|versionDelete
specifier|private
name|boolean
name|versionDelete
parameter_list|(
name|DeleteUpdateCommand
name|cmd
parameter_list|)
throws|throws
name|IOException
block|{
name|BytesRef
name|idBytes
init|=
name|cmd
operator|.
name|getIndexedId
argument_list|()
decl_stmt|;
if|if
condition|(
name|vinfo
operator|==
literal|null
operator|||
name|idBytes
operator|==
literal|null
condition|)
block|{
name|super
operator|.
name|processDelete
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
comment|// This is only the hash for the bucket, and must be based only on the uniqueKey (i.e. do not use a pluggable hash here)
name|int
name|bucketHash
init|=
name|Hash
operator|.
name|murmurhash3_x86_32
argument_list|(
name|idBytes
operator|.
name|bytes
argument_list|,
name|idBytes
operator|.
name|offset
argument_list|,
name|idBytes
operator|.
name|length
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|// at this point, there is an update we need to try and apply.
comment|// we may or may not be the leader.
comment|// Find the version
name|long
name|versionOnUpdate
init|=
name|cmd
operator|.
name|getVersion
argument_list|()
decl_stmt|;
if|if
condition|(
name|versionOnUpdate
operator|==
literal|0
condition|)
block|{
name|String
name|versionOnUpdateS
init|=
name|req
operator|.
name|getParams
argument_list|()
operator|.
name|get
argument_list|(
name|VERSION_FIELD
argument_list|)
decl_stmt|;
name|versionOnUpdate
operator|=
name|versionOnUpdateS
operator|==
literal|null
condition|?
literal|0
else|:
name|Long
operator|.
name|parseLong
argument_list|(
name|versionOnUpdateS
argument_list|)
expr_stmt|;
block|}
name|long
name|signedVersionOnUpdate
init|=
name|versionOnUpdate
decl_stmt|;
name|versionOnUpdate
operator|=
name|Math
operator|.
name|abs
argument_list|(
name|versionOnUpdate
argument_list|)
expr_stmt|;
comment|// normalize to positive version
name|boolean
name|isReplay
init|=
operator|(
name|cmd
operator|.
name|getFlags
argument_list|()
operator|&
name|UpdateCommand
operator|.
name|REPLAY
operator|)
operator|!=
literal|0
decl_stmt|;
name|boolean
name|leaderLogic
init|=
name|isLeader
operator|&&
operator|!
name|isReplay
decl_stmt|;
if|if
condition|(
operator|!
name|leaderLogic
operator|&&
name|versionOnUpdate
operator|==
literal|0
condition|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
literal|"missing _version_ on update from leader"
argument_list|)
throw|;
block|}
name|VersionBucket
name|bucket
init|=
name|vinfo
operator|.
name|bucket
argument_list|(
name|bucketHash
argument_list|)
decl_stmt|;
name|vinfo
operator|.
name|lockForUpdate
argument_list|()
expr_stmt|;
try|try
block|{
synchronized|synchronized
init|(
name|bucket
init|)
block|{
if|if
condition|(
name|versionsStored
condition|)
block|{
name|long
name|bucketVersion
init|=
name|bucket
operator|.
name|highest
decl_stmt|;
if|if
condition|(
name|leaderLogic
condition|)
block|{
if|if
condition|(
name|signedVersionOnUpdate
operator|!=
literal|0
condition|)
block|{
name|Long
name|lastVersion
init|=
name|vinfo
operator|.
name|lookupVersion
argument_list|(
name|cmd
operator|.
name|getIndexedId
argument_list|()
argument_list|)
decl_stmt|;
name|long
name|foundVersion
init|=
name|lastVersion
operator|==
literal|null
condition|?
operator|-
literal|1
else|:
name|lastVersion
decl_stmt|;
if|if
condition|(
operator|(
name|signedVersionOnUpdate
operator|==
name|foundVersion
operator|)
operator|||
operator|(
name|signedVersionOnUpdate
operator|<
literal|0
operator|&&
name|foundVersion
operator|<
literal|0
operator|)
operator|||
operator|(
name|signedVersionOnUpdate
operator|==
literal|1
operator|&&
name|foundVersion
operator|>
literal|0
operator|)
condition|)
block|{
comment|// we're ok if versions match, or if both are negative (all missing docs are equal), or if cmd
comment|// specified it must exist (versionOnUpdate==1) and it does.
block|}
else|else
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|CONFLICT
argument_list|,
literal|"version conflict for "
operator|+
name|cmd
operator|.
name|getId
argument_list|()
operator|+
literal|" expected="
operator|+
name|signedVersionOnUpdate
operator|+
literal|" actual="
operator|+
name|foundVersion
argument_list|)
throw|;
block|}
block|}
name|long
name|version
init|=
name|vinfo
operator|.
name|getNewClock
argument_list|()
decl_stmt|;
name|cmd
operator|.
name|setVersion
argument_list|(
operator|-
name|version
argument_list|)
expr_stmt|;
name|bucket
operator|.
name|updateHighest
argument_list|(
name|version
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cmd
operator|.
name|setVersion
argument_list|(
operator|-
name|versionOnUpdate
argument_list|)
expr_stmt|;
if|if
condition|(
name|ulog
operator|.
name|getState
argument_list|()
operator|!=
name|UpdateLog
operator|.
name|State
operator|.
name|ACTIVE
operator|&&
operator|(
name|cmd
operator|.
name|getFlags
argument_list|()
operator|&
name|UpdateCommand
operator|.
name|REPLAY
operator|)
operator|==
literal|0
condition|)
block|{
comment|// we're not in an active state, and this update isn't from a replay, so buffer it.
name|cmd
operator|.
name|setFlags
argument_list|(
name|cmd
operator|.
name|getFlags
argument_list|()
operator||
name|UpdateCommand
operator|.
name|BUFFERING
argument_list|)
expr_stmt|;
name|ulog
operator|.
name|delete
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
comment|// if we aren't the leader, then we need to check that updates were not re-ordered
if|if
condition|(
name|bucketVersion
operator|!=
literal|0
operator|&&
name|bucketVersion
operator|<
name|versionOnUpdate
condition|)
block|{
comment|// we're OK... this update has a version higher than anything we've seen
comment|// in this bucket so far, so we know that no reordering has yet occured.
name|bucket
operator|.
name|updateHighest
argument_list|(
name|versionOnUpdate
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// there have been updates higher than the current update.  we need to check
comment|// the specific version for this id.
name|Long
name|lastVersion
init|=
name|vinfo
operator|.
name|lookupVersion
argument_list|(
name|cmd
operator|.
name|getIndexedId
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|lastVersion
operator|!=
literal|null
operator|&&
name|Math
operator|.
name|abs
argument_list|(
name|lastVersion
argument_list|)
operator|>=
name|versionOnUpdate
condition|)
block|{
comment|// This update is a repeat, or was reordered.  We need to drop this update.
return|return
literal|true
return|;
block|}
block|}
block|}
block|}
name|doLocalDelete
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
comment|// end synchronized (bucket)
block|}
finally|finally
block|{
name|vinfo
operator|.
name|unlockForUpdate
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|processCommit
specifier|public
name|void
name|processCommit
parameter_list|(
name|CommitUpdateCommand
name|cmd
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|zkEnabled
condition|)
block|{
name|zkCheck
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|vinfo
operator|!=
literal|null
condition|)
block|{
name|vinfo
operator|.
name|lockForUpdate
argument_list|()
expr_stmt|;
block|}
try|try
block|{
if|if
condition|(
name|ulog
operator|==
literal|null
operator|||
name|ulog
operator|.
name|getState
argument_list|()
operator|==
name|UpdateLog
operator|.
name|State
operator|.
name|ACTIVE
operator|||
operator|(
name|cmd
operator|.
name|getFlags
argument_list|()
operator|&
name|UpdateCommand
operator|.
name|REPLAY
operator|)
operator|!=
literal|0
condition|)
block|{
name|super
operator|.
name|processCommit
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|log
operator|.
name|info
argument_list|(
literal|"Ignoring commit while not ACTIVE - state: "
operator|+
name|ulog
operator|.
name|getState
argument_list|()
operator|+
literal|" replay:"
operator|+
operator|(
name|cmd
operator|.
name|getFlags
argument_list|()
operator|&
name|UpdateCommand
operator|.
name|REPLAY
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
if|if
condition|(
name|vinfo
operator|!=
literal|null
condition|)
block|{
name|vinfo
operator|.
name|unlockForUpdate
argument_list|()
expr_stmt|;
block|}
block|}
comment|// TODO: we should consider this? commit everyone in the current collection
if|if
condition|(
name|zkEnabled
condition|)
block|{
name|ModifiableSolrParams
name|params
init|=
operator|new
name|ModifiableSolrParams
argument_list|(
name|req
operator|.
name|getParams
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|params
operator|.
name|getBool
argument_list|(
name|COMMIT_END_POINT
argument_list|,
literal|false
argument_list|)
condition|)
block|{
name|params
operator|.
name|set
argument_list|(
name|COMMIT_END_POINT
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|String
name|nodeName
init|=
name|req
operator|.
name|getCore
argument_list|()
operator|.
name|getCoreDescriptor
argument_list|()
operator|.
name|getCoreContainer
argument_list|()
operator|.
name|getZkController
argument_list|()
operator|.
name|getNodeName
argument_list|()
decl_stmt|;
name|String
name|shardZkNodeName
init|=
name|nodeName
operator|+
literal|"_"
operator|+
name|req
operator|.
name|getCore
argument_list|()
operator|.
name|getName
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|Node
argument_list|>
name|nodes
init|=
name|getCollectionUrls
argument_list|(
name|req
argument_list|,
name|req
operator|.
name|getCore
argument_list|()
operator|.
name|getCoreDescriptor
argument_list|()
operator|.
name|getCloudDescriptor
argument_list|()
operator|.
name|getCollectionName
argument_list|()
argument_list|,
name|shardZkNodeName
argument_list|)
decl_stmt|;
if|if
condition|(
name|nodes
operator|!=
literal|null
condition|)
block|{
name|cmdDistrib
operator|.
name|distribCommit
argument_list|(
name|cmd
argument_list|,
name|nodes
argument_list|,
name|params
argument_list|)
expr_stmt|;
name|finish
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
annotation|@
name|Override
DECL|method|finish
specifier|public
name|void
name|finish
parameter_list|()
throws|throws
name|IOException
block|{
name|doFinish
argument_list|()
expr_stmt|;
if|if
condition|(
name|next
operator|!=
literal|null
operator|&&
name|nodes
operator|==
literal|null
condition|)
name|next
operator|.
name|finish
argument_list|()
expr_stmt|;
block|}
DECL|method|getCollectionUrls
specifier|private
name|List
argument_list|<
name|Node
argument_list|>
name|getCollectionUrls
parameter_list|(
name|SolrQueryRequest
name|req
parameter_list|,
name|String
name|collection
parameter_list|,
name|String
name|shardZkNodeName
parameter_list|)
block|{
name|ClusterState
name|clusterState
init|=
name|req
operator|.
name|getCore
argument_list|()
operator|.
name|getCoreDescriptor
argument_list|()
operator|.
name|getCoreContainer
argument_list|()
operator|.
name|getZkController
argument_list|()
operator|.
name|getClusterState
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|Node
argument_list|>
name|urls
init|=
operator|new
name|ArrayList
argument_list|<
name|Node
argument_list|>
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|Slice
argument_list|>
name|slices
init|=
name|clusterState
operator|.
name|getSlices
argument_list|(
name|collection
argument_list|)
decl_stmt|;
if|if
condition|(
name|slices
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|ZooKeeperException
argument_list|(
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
literal|"Could not find collection in zk: "
operator|+
name|clusterState
argument_list|)
throw|;
block|}
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|Slice
argument_list|>
name|sliceEntry
range|:
name|slices
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|Slice
name|replicas
init|=
name|slices
operator|.
name|get
argument_list|(
name|sliceEntry
operator|.
name|getKey
argument_list|()
argument_list|)
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|ZkNodeProps
argument_list|>
name|shardMap
init|=
name|replicas
operator|.
name|getShards
argument_list|()
decl_stmt|;
for|for
control|(
name|Entry
argument_list|<
name|String
argument_list|,
name|ZkNodeProps
argument_list|>
name|entry
range|:
name|shardMap
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|ZkCoreNodeProps
name|nodeProps
init|=
operator|new
name|ZkCoreNodeProps
argument_list|(
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|clusterState
operator|.
name|liveNodesContain
argument_list|(
name|nodeProps
operator|.
name|getNodeName
argument_list|()
argument_list|)
operator|&&
operator|!
name|entry
operator|.
name|getKey
argument_list|()
operator|.
name|equals
argument_list|(
name|shardZkNodeName
argument_list|)
condition|)
block|{
name|urls
operator|.
name|add
argument_list|(
operator|new
name|StdNode
argument_list|(
name|nodeProps
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|urls
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|urls
return|;
block|}
comment|// TODO: move this to AddUpdateCommand/DeleteUpdateCommand and cache it? And
comment|// make the hash pluggable of course.
comment|// The hash also needs to be pluggable
DECL|method|hash
specifier|private
name|int
name|hash
parameter_list|(
name|AddUpdateCommand
name|cmd
parameter_list|)
block|{
name|BytesRef
name|br
init|=
name|cmd
operator|.
name|getIndexedId
argument_list|()
decl_stmt|;
return|return
name|Hash
operator|.
name|murmurhash3_x86_32
argument_list|(
name|br
operator|.
name|bytes
argument_list|,
name|br
operator|.
name|offset
argument_list|,
name|br
operator|.
name|length
argument_list|,
literal|0
argument_list|)
return|;
block|}
DECL|method|hash
specifier|private
name|int
name|hash
parameter_list|(
name|DeleteUpdateCommand
name|cmd
parameter_list|)
block|{
name|BytesRef
name|br
init|=
name|cmd
operator|.
name|getIndexedId
argument_list|()
decl_stmt|;
return|return
name|Hash
operator|.
name|murmurhash3_x86_32
argument_list|(
name|br
operator|.
name|bytes
argument_list|,
name|br
operator|.
name|offset
argument_list|,
name|br
operator|.
name|length
argument_list|,
literal|0
argument_list|)
return|;
block|}
comment|// RetryNodes are used in the case of 'forward to leader' where we want
comment|// to try the latest leader on a fail in the case the leader just went down.
DECL|class|RetryNode
specifier|public
specifier|static
class|class
name|RetryNode
extends|extends
name|StdNode
block|{
DECL|field|zkStateReader
specifier|private
name|ZkStateReader
name|zkStateReader
decl_stmt|;
DECL|field|collection
specifier|private
name|String
name|collection
decl_stmt|;
DECL|field|shardId
specifier|private
name|String
name|shardId
decl_stmt|;
DECL|method|RetryNode
specifier|public
name|RetryNode
parameter_list|(
name|ZkCoreNodeProps
name|nodeProps
parameter_list|,
name|ZkStateReader
name|zkStateReader
parameter_list|,
name|String
name|collection
parameter_list|,
name|String
name|shardId
parameter_list|)
block|{
name|super
argument_list|(
name|nodeProps
argument_list|)
expr_stmt|;
name|this
operator|.
name|zkStateReader
operator|=
name|zkStateReader
expr_stmt|;
name|this
operator|.
name|collection
operator|=
name|collection
expr_stmt|;
name|this
operator|.
name|shardId
operator|=
name|shardId
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|url
return|;
block|}
annotation|@
name|Override
DECL|method|checkRetry
specifier|public
name|boolean
name|checkRetry
parameter_list|()
block|{
name|ZkCoreNodeProps
name|leaderProps
decl_stmt|;
try|try
block|{
name|leaderProps
operator|=
operator|new
name|ZkCoreNodeProps
argument_list|(
name|zkStateReader
operator|.
name|getLeaderProps
argument_list|(
name|collection
argument_list|,
name|shardId
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
block|}
name|this
operator|.
name|url
operator|=
name|leaderProps
operator|.
name|getCoreUrl
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
annotation|@
name|Override
DECL|method|hashCode
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
specifier|final
name|int
name|prime
init|=
literal|31
decl_stmt|;
name|int
name|result
init|=
name|super
operator|.
name|hashCode
argument_list|()
decl_stmt|;
name|result
operator|=
name|prime
operator|*
name|result
operator|+
operator|(
operator|(
name|collection
operator|==
literal|null
operator|)
condition|?
literal|0
else|:
name|collection
operator|.
name|hashCode
argument_list|()
operator|)
expr_stmt|;
name|result
operator|=
name|prime
operator|*
name|result
operator|+
operator|(
operator|(
name|shardId
operator|==
literal|null
operator|)
condition|?
literal|0
else|:
name|shardId
operator|.
name|hashCode
argument_list|()
operator|)
expr_stmt|;
return|return
name|result
return|;
block|}
annotation|@
name|Override
DECL|method|equals
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|obj
parameter_list|)
block|{
if|if
condition|(
name|this
operator|==
name|obj
condition|)
return|return
literal|true
return|;
if|if
condition|(
operator|!
name|super
operator|.
name|equals
argument_list|(
name|obj
argument_list|)
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|getClass
argument_list|()
operator|!=
name|obj
operator|.
name|getClass
argument_list|()
condition|)
return|return
literal|false
return|;
name|RetryNode
name|other
init|=
operator|(
name|RetryNode
operator|)
name|obj
decl_stmt|;
if|if
condition|(
name|url
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|other
operator|.
name|url
operator|!=
literal|null
condition|)
return|return
literal|false
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|url
operator|.
name|equals
argument_list|(
name|other
operator|.
name|url
argument_list|)
condition|)
return|return
literal|false
return|;
return|return
literal|true
return|;
block|}
block|}
comment|/**    * Returns a boolean indicating wether or not the caller should behave as     * if this is the "leader" even when ZooKeeper is not enabled.      * (Even in non zk mode, tests may simulate updates to/from a leader)    */
DECL|method|getNonZkLeaderAssumption
specifier|public
specifier|static
name|boolean
name|getNonZkLeaderAssumption
parameter_list|(
name|SolrQueryRequest
name|req
parameter_list|)
block|{
name|DistribPhase
name|phase
init|=
name|DistribPhase
operator|.
name|parseParam
argument_list|(
name|req
operator|.
name|getParams
argument_list|()
operator|.
name|get
argument_list|(
name|DISTRIB_UPDATE_PARAM
argument_list|)
argument_list|)
decl_stmt|;
comment|// if we have been told we are coming from a leader, then we are
comment|// definitely not the leader.  Otherwise assume we are.
return|return
name|DistribPhase
operator|.
name|FROMLEADER
operator|!=
name|phase
return|;
block|}
block|}
end_class
end_unit
