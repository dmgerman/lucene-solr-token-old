begin_unit
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_package
DECL|package|org.apache.solr.update
package|package
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|update
package|;
end_package
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|BytesRef
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|SolrException
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|SolrInputDocument
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|params
operator|.
name|MapSolrParams
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|params
operator|.
name|ModifiableSolrParams
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|params
operator|.
name|SolrParams
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|util
operator|.
name|NamedList
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|core
operator|.
name|PluginInfo
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|core
operator|.
name|SolrCore
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|request
operator|.
name|LocalSolrQueryRequest
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|request
operator|.
name|SolrQueryRequest
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|request
operator|.
name|SolrRequestInfo
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|response
operator|.
name|SolrQueryResponse
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|search
operator|.
name|SolrIndexSearcher
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|update
operator|.
name|processor
operator|.
name|DistributedUpdateProcessor
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|update
operator|.
name|processor
operator|.
name|DistributedUpdateProcessorFactory
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|update
operator|.
name|processor
operator|.
name|RunUpdateProcessorFactory
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|update
operator|.
name|processor
operator|.
name|UpdateRequestProcessor
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|util
operator|.
name|DefaultSolrThreadFactory
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|util
operator|.
name|RefCounted
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|util
operator|.
name|plugin
operator|.
name|PluginInfoInitialized
import|;
end_import
begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import
begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FilenameFilter
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|*
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|*
import|;
end_import
begin_comment
comment|/** @lucene.experimental */
end_comment
begin_class
DECL|class|UpdateLog
specifier|public
class|class
name|UpdateLog
implements|implements
name|PluginInfoInitialized
block|{
DECL|field|log
specifier|public
specifier|static
name|Logger
name|log
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|UpdateLog
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|debug
specifier|public
name|boolean
name|debug
init|=
name|log
operator|.
name|isDebugEnabled
argument_list|()
decl_stmt|;
DECL|field|trace
specifier|public
name|boolean
name|trace
init|=
name|log
operator|.
name|isTraceEnabled
argument_list|()
decl_stmt|;
DECL|enum|SyncLevel
DECL|enum constant|NONE
DECL|enum constant|FLUSH
DECL|enum constant|FSYNC
specifier|public
enum|enum
name|SyncLevel
block|{
name|NONE
block|,
name|FLUSH
block|,
name|FSYNC
block|}
DECL|enum|State
DECL|enum constant|REPLAYING
DECL|enum constant|BUFFERING
DECL|enum constant|APPLYING_BUFFERED
DECL|enum constant|ACTIVE
specifier|public
enum|enum
name|State
block|{
name|REPLAYING
block|,
name|BUFFERING
block|,
name|APPLYING_BUFFERED
block|,
name|ACTIVE
block|}
DECL|field|ADD
specifier|public
specifier|static
specifier|final
name|int
name|ADD
init|=
literal|0x01
decl_stmt|;
DECL|field|DELETE
specifier|public
specifier|static
specifier|final
name|int
name|DELETE
init|=
literal|0x02
decl_stmt|;
DECL|field|DELETE_BY_QUERY
specifier|public
specifier|static
specifier|final
name|int
name|DELETE_BY_QUERY
init|=
literal|0x03
decl_stmt|;
DECL|field|COMMIT
specifier|public
specifier|static
specifier|final
name|int
name|COMMIT
init|=
literal|0x04
decl_stmt|;
DECL|class|RecoveryInfo
specifier|public
specifier|static
class|class
name|RecoveryInfo
block|{
DECL|field|positionOfStart
specifier|public
name|long
name|positionOfStart
decl_stmt|;
DECL|field|adds
specifier|public
name|int
name|adds
decl_stmt|;
DECL|field|deletes
specifier|public
name|int
name|deletes
decl_stmt|;
DECL|field|deleteByQuery
specifier|public
name|int
name|deleteByQuery
decl_stmt|;
DECL|field|errors
specifier|public
name|int
name|errors
decl_stmt|;
annotation|@
name|Override
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"RecoveryInfo{adds="
operator|+
name|adds
operator|+
literal|" deletes="
operator|+
name|deletes
operator|+
literal|" deleteByQuery="
operator|+
name|deleteByQuery
operator|+
literal|" errors="
operator|+
name|errors
operator|+
literal|" positionOfStart="
operator|+
name|positionOfStart
operator|+
literal|"}"
return|;
block|}
block|}
DECL|field|TLOG_NAME
specifier|public
specifier|static
name|String
name|TLOG_NAME
init|=
literal|"tlog"
decl_stmt|;
DECL|field|id
name|long
name|id
init|=
operator|-
literal|1
decl_stmt|;
DECL|field|state
specifier|private
name|State
name|state
init|=
name|State
operator|.
name|ACTIVE
decl_stmt|;
DECL|field|tlog
specifier|private
name|TransactionLog
name|tlog
decl_stmt|;
DECL|field|prevTlog
specifier|private
name|TransactionLog
name|prevTlog
decl_stmt|;
DECL|field|logs
specifier|private
name|Deque
argument_list|<
name|TransactionLog
argument_list|>
name|logs
init|=
operator|new
name|LinkedList
argument_list|<
name|TransactionLog
argument_list|>
argument_list|()
decl_stmt|;
comment|// list of recent logs, newest first
DECL|field|newestLogOnStartup
specifier|private
name|TransactionLog
name|newestLogOnStartup
decl_stmt|;
DECL|field|numOldRecords
specifier|private
name|int
name|numOldRecords
decl_stmt|;
comment|// number of records in the recent logs
DECL|field|map
specifier|private
name|Map
argument_list|<
name|BytesRef
argument_list|,
name|LogPtr
argument_list|>
name|map
init|=
operator|new
name|HashMap
argument_list|<
name|BytesRef
argument_list|,
name|LogPtr
argument_list|>
argument_list|()
decl_stmt|;
DECL|field|prevMap
specifier|private
name|Map
argument_list|<
name|BytesRef
argument_list|,
name|LogPtr
argument_list|>
name|prevMap
decl_stmt|;
comment|// used while committing/reopening is happening
DECL|field|prevMap2
specifier|private
name|Map
argument_list|<
name|BytesRef
argument_list|,
name|LogPtr
argument_list|>
name|prevMap2
decl_stmt|;
comment|// used while committing/reopening is happening
DECL|field|prevMapLog
specifier|private
name|TransactionLog
name|prevMapLog
decl_stmt|;
comment|// the transaction log used to look up entries found in prevMap
DECL|field|prevMapLog2
specifier|private
name|TransactionLog
name|prevMapLog2
decl_stmt|;
comment|// the transaction log used to look up entries found in prevMap
DECL|field|numDeletesToKeep
specifier|private
specifier|final
name|int
name|numDeletesToKeep
init|=
literal|1000
decl_stmt|;
DECL|field|numRecordsToKeep
specifier|public
specifier|final
name|int
name|numRecordsToKeep
init|=
literal|100
decl_stmt|;
comment|// keep track of deletes only... this is not updated on an add
DECL|field|oldDeletes
specifier|private
name|LinkedHashMap
argument_list|<
name|BytesRef
argument_list|,
name|LogPtr
argument_list|>
name|oldDeletes
init|=
operator|new
name|LinkedHashMap
argument_list|<
name|BytesRef
argument_list|,
name|LogPtr
argument_list|>
argument_list|(
name|numDeletesToKeep
argument_list|)
block|{
specifier|protected
name|boolean
name|removeEldestEntry
parameter_list|(
name|Map
operator|.
name|Entry
name|eldest
parameter_list|)
block|{
return|return
name|size
argument_list|()
operator|>
name|numDeletesToKeep
return|;
block|}
block|}
decl_stmt|;
DECL|field|tlogFiles
specifier|private
name|String
index|[]
name|tlogFiles
decl_stmt|;
DECL|field|tlogDir
specifier|private
name|File
name|tlogDir
decl_stmt|;
DECL|field|globalStrings
specifier|private
name|Collection
argument_list|<
name|String
argument_list|>
name|globalStrings
decl_stmt|;
DECL|field|dataDir
specifier|private
name|String
name|dataDir
decl_stmt|;
DECL|field|lastDataDir
specifier|private
name|String
name|lastDataDir
decl_stmt|;
DECL|field|versionInfo
specifier|private
name|VersionInfo
name|versionInfo
decl_stmt|;
DECL|field|defaultSyncLevel
specifier|private
name|SyncLevel
name|defaultSyncLevel
init|=
name|SyncLevel
operator|.
name|FLUSH
decl_stmt|;
DECL|field|uhandler
specifier|private
specifier|volatile
name|UpdateHandler
name|uhandler
decl_stmt|;
comment|// a core reload can change this reference!
DECL|field|cancelApplyBufferUpdate
specifier|private
specifier|volatile
name|boolean
name|cancelApplyBufferUpdate
decl_stmt|;
DECL|field|startingVersions
name|List
argument_list|<
name|Long
argument_list|>
name|startingVersions
decl_stmt|;
DECL|class|LogPtr
specifier|public
specifier|static
class|class
name|LogPtr
block|{
DECL|field|pointer
specifier|final
name|long
name|pointer
decl_stmt|;
DECL|field|version
specifier|final
name|long
name|version
decl_stmt|;
DECL|method|LogPtr
specifier|public
name|LogPtr
parameter_list|(
name|long
name|pointer
parameter_list|,
name|long
name|version
parameter_list|)
block|{
name|this
operator|.
name|pointer
operator|=
name|pointer
expr_stmt|;
name|this
operator|.
name|version
operator|=
name|version
expr_stmt|;
block|}
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"LogPtr("
operator|+
name|pointer
operator|+
literal|")"
return|;
block|}
block|}
DECL|method|getVersionInfo
specifier|public
name|VersionInfo
name|getVersionInfo
parameter_list|()
block|{
return|return
name|versionInfo
return|;
block|}
DECL|method|init
specifier|public
name|void
name|init
parameter_list|(
name|PluginInfo
name|info
parameter_list|)
block|{
name|dataDir
operator|=
operator|(
name|String
operator|)
name|info
operator|.
name|initArgs
operator|.
name|get
argument_list|(
literal|"dir"
argument_list|)
expr_stmt|;
block|}
DECL|method|init
specifier|public
name|void
name|init
parameter_list|(
name|UpdateHandler
name|uhandler
parameter_list|,
name|SolrCore
name|core
parameter_list|)
block|{
if|if
condition|(
name|dataDir
operator|==
literal|null
operator|||
name|dataDir
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
block|{
name|dataDir
operator|=
name|core
operator|.
name|getDataDir
argument_list|()
expr_stmt|;
block|}
name|this
operator|.
name|uhandler
operator|=
name|uhandler
expr_stmt|;
if|if
condition|(
name|dataDir
operator|.
name|equals
argument_list|(
name|lastDataDir
argument_list|)
condition|)
block|{
if|if
condition|(
name|debug
condition|)
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"UpdateHandler init: tlogDir="
operator|+
name|tlogDir
operator|+
literal|", next id="
operator|+
name|id
argument_list|,
literal|" this is a reopen... nothing else to do."
argument_list|)
expr_stmt|;
block|}
comment|// on a normal reopen, we currently shouldn't have to do anything
return|return;
block|}
name|lastDataDir
operator|=
name|dataDir
expr_stmt|;
name|tlogDir
operator|=
operator|new
name|File
argument_list|(
name|dataDir
argument_list|,
name|TLOG_NAME
argument_list|)
expr_stmt|;
name|tlogDir
operator|.
name|mkdirs
argument_list|()
expr_stmt|;
name|tlogFiles
operator|=
name|getLogList
argument_list|(
name|tlogDir
argument_list|)
expr_stmt|;
name|id
operator|=
name|getLastLogId
argument_list|()
operator|+
literal|1
expr_stmt|;
comment|// add 1 since we will create a new log for the next update
if|if
condition|(
name|debug
condition|)
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"UpdateHandler init: tlogDir="
operator|+
name|tlogDir
operator|+
literal|", existing tlogs="
operator|+
name|Arrays
operator|.
name|asList
argument_list|(
name|tlogFiles
argument_list|)
operator|+
literal|", next id="
operator|+
name|id
argument_list|)
expr_stmt|;
block|}
name|TransactionLog
name|oldLog
init|=
literal|null
decl_stmt|;
for|for
control|(
name|String
name|oldLogName
range|:
name|tlogFiles
control|)
block|{
name|File
name|f
init|=
operator|new
name|File
argument_list|(
name|tlogDir
argument_list|,
name|oldLogName
argument_list|)
decl_stmt|;
try|try
block|{
name|oldLog
operator|=
operator|new
name|TransactionLog
argument_list|(
name|f
argument_list|,
literal|null
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|addOldLog
argument_list|(
name|oldLog
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|SolrException
operator|.
name|log
argument_list|(
name|log
argument_list|,
literal|"Failure to open existing log file (non fatal) "
operator|+
name|f
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|f
operator|.
name|delete
argument_list|()
expr_stmt|;
block|}
block|}
name|newestLogOnStartup
operator|=
name|oldLog
expr_stmt|;
name|versionInfo
operator|=
operator|new
name|VersionInfo
argument_list|(
name|uhandler
argument_list|,
literal|256
argument_list|)
expr_stmt|;
name|UpdateLog
operator|.
name|RecentUpdates
name|startingRecentUpdates
init|=
name|getRecentUpdates
argument_list|()
decl_stmt|;
try|try
block|{
name|startingVersions
operator|=
name|startingRecentUpdates
operator|.
name|getVersions
argument_list|(
name|numRecordsToKeep
argument_list|)
expr_stmt|;
comment|// populate recent deletes list (since we can't get that info from the index)
for|for
control|(
name|int
name|i
init|=
name|startingRecentUpdates
operator|.
name|deleteList
operator|.
name|size
argument_list|()
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|DeleteUpdate
name|du
init|=
name|startingRecentUpdates
operator|.
name|deleteList
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|oldDeletes
operator|.
name|put
argument_list|(
operator|new
name|BytesRef
argument_list|(
name|du
operator|.
name|id
argument_list|)
argument_list|,
operator|new
name|LogPtr
argument_list|(
operator|-
literal|1
argument_list|,
name|du
operator|.
name|version
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|startingRecentUpdates
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|getLogDir
specifier|public
name|File
name|getLogDir
parameter_list|()
block|{
return|return
name|tlogDir
return|;
block|}
DECL|method|getStartingVersions
specifier|public
name|List
argument_list|<
name|Long
argument_list|>
name|getStartingVersions
parameter_list|()
block|{
return|return
name|startingVersions
return|;
block|}
comment|/* Takes over ownership of the log, keeping it until no longer needed      and then decrementing it's reference and dropping it.    */
DECL|method|addOldLog
specifier|private
name|void
name|addOldLog
parameter_list|(
name|TransactionLog
name|oldLog
parameter_list|)
block|{
if|if
condition|(
name|oldLog
operator|==
literal|null
condition|)
return|return;
name|numOldRecords
operator|+=
name|oldLog
operator|.
name|numRecords
argument_list|()
expr_stmt|;
name|int
name|currRecords
init|=
name|numOldRecords
decl_stmt|;
if|if
condition|(
name|oldLog
operator|!=
name|tlog
operator|&&
name|tlog
operator|!=
literal|null
condition|)
block|{
name|currRecords
operator|+=
name|tlog
operator|.
name|numRecords
argument_list|()
expr_stmt|;
block|}
while|while
condition|(
name|logs
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|TransactionLog
name|log
init|=
name|logs
operator|.
name|peekLast
argument_list|()
decl_stmt|;
name|int
name|nrec
init|=
name|log
operator|.
name|numRecords
argument_list|()
decl_stmt|;
comment|// remove oldest log if we don't need it to keep at least numRecordsToKeep, or if
comment|// we already have the limit of 10 log files.
if|if
condition|(
name|currRecords
operator|-
name|nrec
operator|>=
name|numRecordsToKeep
operator|||
name|logs
operator|.
name|size
argument_list|()
operator|>=
literal|10
condition|)
block|{
name|currRecords
operator|-=
name|nrec
expr_stmt|;
name|numOldRecords
operator|-=
name|nrec
expr_stmt|;
name|logs
operator|.
name|removeLast
argument_list|()
operator|.
name|decref
argument_list|()
expr_stmt|;
comment|// dereference so it will be deleted when no longer in use
continue|continue;
block|}
break|break;
block|}
comment|// don't incref... we are taking ownership from the caller.
name|logs
operator|.
name|addFirst
argument_list|(
name|oldLog
argument_list|)
expr_stmt|;
block|}
DECL|method|getLogList
specifier|public
specifier|static
name|String
index|[]
name|getLogList
parameter_list|(
name|File
name|directory
parameter_list|)
block|{
specifier|final
name|String
name|prefix
init|=
name|TLOG_NAME
operator|+
literal|'.'
decl_stmt|;
name|String
index|[]
name|names
init|=
name|directory
operator|.
name|list
argument_list|(
operator|new
name|FilenameFilter
argument_list|()
block|{
specifier|public
name|boolean
name|accept
parameter_list|(
name|File
name|dir
parameter_list|,
name|String
name|name
parameter_list|)
block|{
return|return
name|name
operator|.
name|startsWith
argument_list|(
name|prefix
argument_list|)
return|;
block|}
block|}
argument_list|)
decl_stmt|;
name|Arrays
operator|.
name|sort
argument_list|(
name|names
argument_list|)
expr_stmt|;
return|return
name|names
return|;
block|}
DECL|method|getLastLogId
specifier|public
name|long
name|getLastLogId
parameter_list|()
block|{
if|if
condition|(
name|id
operator|!=
operator|-
literal|1
condition|)
return|return
name|id
return|;
if|if
condition|(
name|tlogFiles
operator|.
name|length
operator|==
literal|0
condition|)
return|return
operator|-
literal|1
return|;
name|String
name|last
init|=
name|tlogFiles
index|[
name|tlogFiles
operator|.
name|length
operator|-
literal|1
index|]
decl_stmt|;
return|return
name|Long
operator|.
name|parseLong
argument_list|(
name|last
operator|.
name|substring
argument_list|(
name|TLOG_NAME
operator|.
name|length
argument_list|()
operator|+
literal|1
argument_list|)
argument_list|)
return|;
block|}
DECL|method|add
specifier|public
name|void
name|add
parameter_list|(
name|AddUpdateCommand
name|cmd
parameter_list|)
block|{
comment|// don't log if we are replaying from another log
comment|// TODO: we currently need to log to maintain correct versioning, rtg, etc
comment|// if ((cmd.getFlags()& UpdateCommand.REPLAY) != 0) return;
synchronized|synchronized
init|(
name|this
init|)
block|{
name|long
name|pos
init|=
operator|-
literal|1
decl_stmt|;
comment|// don't log if we are replaying from another log
if|if
condition|(
operator|(
name|cmd
operator|.
name|getFlags
argument_list|()
operator|&
name|UpdateCommand
operator|.
name|REPLAY
operator|)
operator|==
literal|0
condition|)
block|{
name|ensureLog
argument_list|()
expr_stmt|;
name|pos
operator|=
name|tlog
operator|.
name|write
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
block|}
comment|// TODO: in the future we could support a real position for a REPLAY update.
comment|// Only currently would be useful for RTG while in recovery mode though.
name|LogPtr
name|ptr
init|=
operator|new
name|LogPtr
argument_list|(
name|pos
argument_list|,
name|cmd
operator|.
name|getVersion
argument_list|()
argument_list|)
decl_stmt|;
comment|// only update our map if we're not buffering
if|if
condition|(
operator|(
name|cmd
operator|.
name|getFlags
argument_list|()
operator|&
name|UpdateCommand
operator|.
name|BUFFERING
operator|)
operator|==
literal|0
condition|)
block|{
name|map
operator|.
name|put
argument_list|(
name|cmd
operator|.
name|getIndexedId
argument_list|()
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|trace
condition|)
block|{
name|log
operator|.
name|trace
argument_list|(
literal|"TLOG: added id "
operator|+
name|cmd
operator|.
name|getPrintableId
argument_list|()
operator|+
literal|" to "
operator|+
name|tlog
operator|+
literal|" "
operator|+
name|ptr
operator|+
literal|" map="
operator|+
name|System
operator|.
name|identityHashCode
argument_list|(
name|map
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|delete
specifier|public
name|void
name|delete
parameter_list|(
name|DeleteUpdateCommand
name|cmd
parameter_list|)
block|{
name|BytesRef
name|br
init|=
name|cmd
operator|.
name|getIndexedId
argument_list|()
decl_stmt|;
synchronized|synchronized
init|(
name|this
init|)
block|{
name|long
name|pos
init|=
operator|-
literal|1
decl_stmt|;
comment|// don't log if we are replaying from another log
if|if
condition|(
operator|(
name|cmd
operator|.
name|getFlags
argument_list|()
operator|&
name|UpdateCommand
operator|.
name|REPLAY
operator|)
operator|==
literal|0
condition|)
block|{
name|ensureLog
argument_list|()
expr_stmt|;
name|pos
operator|=
name|tlog
operator|.
name|writeDelete
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
block|}
name|LogPtr
name|ptr
init|=
operator|new
name|LogPtr
argument_list|(
name|pos
argument_list|,
name|cmd
operator|.
name|version
argument_list|)
decl_stmt|;
comment|// only update our map if we're not buffering
if|if
condition|(
operator|(
name|cmd
operator|.
name|getFlags
argument_list|()
operator|&
name|UpdateCommand
operator|.
name|BUFFERING
operator|)
operator|==
literal|0
condition|)
block|{
name|map
operator|.
name|put
argument_list|(
name|br
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
name|oldDeletes
operator|.
name|put
argument_list|(
name|br
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|trace
condition|)
block|{
name|log
operator|.
name|trace
argument_list|(
literal|"TLOG: added delete for id "
operator|+
name|cmd
operator|.
name|id
operator|+
literal|" to "
operator|+
name|tlog
operator|+
literal|" "
operator|+
name|ptr
operator|+
literal|" map="
operator|+
name|System
operator|.
name|identityHashCode
argument_list|(
name|map
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|deleteByQuery
specifier|public
name|void
name|deleteByQuery
parameter_list|(
name|DeleteUpdateCommand
name|cmd
parameter_list|)
block|{
synchronized|synchronized
init|(
name|this
init|)
block|{
name|long
name|pos
init|=
operator|-
literal|1
decl_stmt|;
comment|// don't log if we are replaying from another log
if|if
condition|(
operator|(
name|cmd
operator|.
name|getFlags
argument_list|()
operator|&
name|UpdateCommand
operator|.
name|REPLAY
operator|)
operator|==
literal|0
condition|)
block|{
name|ensureLog
argument_list|()
expr_stmt|;
name|pos
operator|=
name|tlog
operator|.
name|writeDeleteByQuery
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
block|}
comment|// only change our caches if we are not buffering
if|if
condition|(
operator|(
name|cmd
operator|.
name|getFlags
argument_list|()
operator|&
name|UpdateCommand
operator|.
name|BUFFERING
operator|)
operator|==
literal|0
condition|)
block|{
comment|// given that we just did a delete-by-query, we don't know what documents were
comment|// affected and hence we must purge our caches.
name|map
operator|.
name|clear
argument_list|()
expr_stmt|;
comment|// oldDeletes.clear();
comment|// We must cause a new IndexReader to be opened before anything looks at these caches again
comment|// so that a cache miss will read fresh data.
comment|//
comment|// TODO: FUTURE: open a new searcher lazily for better throughput with delete-by-query commands
try|try
block|{
name|RefCounted
argument_list|<
name|SolrIndexSearcher
argument_list|>
name|holder
init|=
name|uhandler
operator|.
name|core
operator|.
name|openNewSearcher
argument_list|(
literal|true
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|holder
operator|.
name|decref
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|SolrException
operator|.
name|log
argument_list|(
name|log
argument_list|,
literal|"Error opening realtime searcher for deleteByQuery"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
name|LogPtr
name|ptr
init|=
operator|new
name|LogPtr
argument_list|(
name|pos
argument_list|,
name|cmd
operator|.
name|getVersion
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|trace
condition|)
block|{
name|log
operator|.
name|trace
argument_list|(
literal|"TLOG: added deleteByQuery "
operator|+
name|cmd
operator|.
name|query
operator|+
literal|" to "
operator|+
name|tlog
operator|+
literal|" "
operator|+
name|ptr
operator|+
literal|" map="
operator|+
name|System
operator|.
name|identityHashCode
argument_list|(
name|map
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|newMap
specifier|private
name|void
name|newMap
parameter_list|()
block|{
name|prevMap2
operator|=
name|prevMap
expr_stmt|;
name|prevMapLog2
operator|=
name|prevMapLog
expr_stmt|;
name|prevMap
operator|=
name|map
expr_stmt|;
name|prevMapLog
operator|=
name|tlog
expr_stmt|;
name|map
operator|=
operator|new
name|HashMap
argument_list|<
name|BytesRef
argument_list|,
name|LogPtr
argument_list|>
argument_list|()
expr_stmt|;
block|}
DECL|method|clearOldMaps
specifier|private
name|void
name|clearOldMaps
parameter_list|()
block|{
name|prevMap
operator|=
literal|null
expr_stmt|;
name|prevMap2
operator|=
literal|null
expr_stmt|;
block|}
DECL|method|preCommit
specifier|public
name|void
name|preCommit
parameter_list|(
name|CommitUpdateCommand
name|cmd
parameter_list|)
block|{
synchronized|synchronized
init|(
name|this
init|)
block|{
if|if
condition|(
name|debug
condition|)
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"TLOG: preCommit"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|getState
argument_list|()
operator|!=
name|State
operator|.
name|ACTIVE
operator|&&
operator|(
name|cmd
operator|.
name|getFlags
argument_list|()
operator|&
name|UpdateCommand
operator|.
name|REPLAY
operator|)
operator|==
literal|0
condition|)
block|{
comment|// if we aren't in the active state, and this isn't a replay
comment|// from the recovery process, then we shouldn't mess with
comment|// the current transaction log.  This normally shouldn't happen
comment|// as DistributedUpdateProcessor will prevent this.  Commits
comment|// that don't use the processor are possible though.
return|return;
block|}
comment|// since we're changing the log, we must change the map.
name|newMap
argument_list|()
expr_stmt|;
comment|// since document additions can happen concurrently with commit, create
comment|// a new transaction log first so that we know the old one is definitely
comment|// in the index.
name|prevTlog
operator|=
name|tlog
expr_stmt|;
name|tlog
operator|=
literal|null
expr_stmt|;
name|id
operator|++
expr_stmt|;
if|if
condition|(
name|prevTlog
operator|!=
literal|null
condition|)
block|{
name|globalStrings
operator|=
name|prevTlog
operator|.
name|getGlobalStrings
argument_list|()
expr_stmt|;
block|}
name|addOldLog
argument_list|(
name|prevTlog
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|postCommit
specifier|public
name|void
name|postCommit
parameter_list|(
name|CommitUpdateCommand
name|cmd
parameter_list|)
block|{
synchronized|synchronized
init|(
name|this
init|)
block|{
if|if
condition|(
name|debug
condition|)
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"TLOG: postCommit"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|prevTlog
operator|!=
literal|null
condition|)
block|{
comment|// if we made it through the commit, write a commit command to the log
comment|// TODO: check that this works to cap a tlog we were using to buffer so we don't replay on startup.
name|prevTlog
operator|.
name|writeCommit
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
comment|// the old log list will decref when no longer needed
comment|// prevTlog.decref();
name|prevTlog
operator|=
literal|null
expr_stmt|;
block|}
block|}
block|}
DECL|method|preSoftCommit
specifier|public
name|void
name|preSoftCommit
parameter_list|(
name|CommitUpdateCommand
name|cmd
parameter_list|)
block|{
name|debug
operator|=
name|log
operator|.
name|isDebugEnabled
argument_list|()
expr_stmt|;
comment|// refresh our view of debugging occasionally
name|trace
operator|=
name|log
operator|.
name|isTraceEnabled
argument_list|()
expr_stmt|;
synchronized|synchronized
init|(
name|this
init|)
block|{
if|if
condition|(
operator|!
name|cmd
operator|.
name|softCommit
condition|)
return|return;
comment|// already handled this at the start of the hard commit
name|newMap
argument_list|()
expr_stmt|;
comment|// start adding documents to a new map since we won't know if
comment|// any added documents will make it into this commit or not.
comment|// But we do know that any updates already added will definitely
comment|// show up in the latest reader after the commit succeeds.
name|map
operator|=
operator|new
name|HashMap
argument_list|<
name|BytesRef
argument_list|,
name|LogPtr
argument_list|>
argument_list|()
expr_stmt|;
if|if
condition|(
name|debug
condition|)
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"TLOG: preSoftCommit: prevMap="
operator|+
name|System
operator|.
name|identityHashCode
argument_list|(
name|prevMap
argument_list|)
operator|+
literal|" new map="
operator|+
name|System
operator|.
name|identityHashCode
argument_list|(
name|map
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|postSoftCommit
specifier|public
name|void
name|postSoftCommit
parameter_list|(
name|CommitUpdateCommand
name|cmd
parameter_list|)
block|{
synchronized|synchronized
init|(
name|this
init|)
block|{
comment|// We can clear out all old maps now that a new searcher has been opened.
comment|// This currently only works since DUH2 synchronizes around preCommit to avoid
comment|// it being called in the middle of a preSoftCommit, postSoftCommit sequence.
comment|// If this DUH2 synchronization were to be removed, preSoftCommit should
comment|// record what old maps were created and only remove those.
if|if
condition|(
name|debug
condition|)
block|{
name|SolrCore
operator|.
name|verbose
argument_list|(
literal|"TLOG: postSoftCommit: disposing of prevMap="
operator|+
name|System
operator|.
name|identityHashCode
argument_list|(
name|prevMap
argument_list|)
operator|+
literal|", prevMap2="
operator|+
name|System
operator|.
name|identityHashCode
argument_list|(
name|prevMap2
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|clearOldMaps
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|lookup
specifier|public
name|Object
name|lookup
parameter_list|(
name|BytesRef
name|indexedId
parameter_list|)
block|{
name|LogPtr
name|entry
decl_stmt|;
name|TransactionLog
name|lookupLog
decl_stmt|;
synchronized|synchronized
init|(
name|this
init|)
block|{
name|entry
operator|=
name|map
operator|.
name|get
argument_list|(
name|indexedId
argument_list|)
expr_stmt|;
name|lookupLog
operator|=
name|tlog
expr_stmt|;
comment|// something found in "map" will always be in "tlog"
comment|// SolrCore.verbose("TLOG: lookup: for id ",indexedId.utf8ToString(),"in map",System.identityHashCode(map),"got",entry,"lookupLog=",lookupLog);
if|if
condition|(
name|entry
operator|==
literal|null
operator|&&
name|prevMap
operator|!=
literal|null
condition|)
block|{
name|entry
operator|=
name|prevMap
operator|.
name|get
argument_list|(
name|indexedId
argument_list|)
expr_stmt|;
comment|// something found in prevMap will always be found in preMapLog (which could be tlog or prevTlog)
name|lookupLog
operator|=
name|prevMapLog
expr_stmt|;
comment|// SolrCore.verbose("TLOG: lookup: for id ",indexedId.utf8ToString(),"in prevMap",System.identityHashCode(map),"got",entry,"lookupLog=",lookupLog);
block|}
if|if
condition|(
name|entry
operator|==
literal|null
operator|&&
name|prevMap2
operator|!=
literal|null
condition|)
block|{
name|entry
operator|=
name|prevMap2
operator|.
name|get
argument_list|(
name|indexedId
argument_list|)
expr_stmt|;
comment|// something found in prevMap2 will always be found in preMapLog2 (which could be tlog or prevTlog)
name|lookupLog
operator|=
name|prevMapLog2
expr_stmt|;
comment|// SolrCore.verbose("TLOG: lookup: for id ",indexedId.utf8ToString(),"in prevMap2",System.identityHashCode(map),"got",entry,"lookupLog=",lookupLog);
block|}
if|if
condition|(
name|entry
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|lookupLog
operator|.
name|incref
argument_list|()
expr_stmt|;
block|}
try|try
block|{
comment|// now do the lookup outside of the sync block for concurrency
return|return
name|lookupLog
operator|.
name|lookup
argument_list|(
name|entry
operator|.
name|pointer
argument_list|)
return|;
block|}
finally|finally
block|{
name|lookupLog
operator|.
name|decref
argument_list|()
expr_stmt|;
block|}
block|}
comment|// This method works like realtime-get... it only guarantees to return the latest
comment|// version of the *completed* update.  There can be updates in progress concurrently
comment|// that have already grabbed higher version numbers.  Higher level coordination or
comment|// synchronization is needed for stronger guarantees (as VersionUpdateProcessor does).
DECL|method|lookupVersion
specifier|public
name|Long
name|lookupVersion
parameter_list|(
name|BytesRef
name|indexedId
parameter_list|)
block|{
name|LogPtr
name|entry
decl_stmt|;
name|TransactionLog
name|lookupLog
decl_stmt|;
synchronized|synchronized
init|(
name|this
init|)
block|{
name|entry
operator|=
name|map
operator|.
name|get
argument_list|(
name|indexedId
argument_list|)
expr_stmt|;
name|lookupLog
operator|=
name|tlog
expr_stmt|;
comment|// something found in "map" will always be in "tlog"
comment|// SolrCore.verbose("TLOG: lookup ver: for id ",indexedId.utf8ToString(),"in map",System.identityHashCode(map),"got",entry,"lookupLog=",lookupLog);
if|if
condition|(
name|entry
operator|==
literal|null
operator|&&
name|prevMap
operator|!=
literal|null
condition|)
block|{
name|entry
operator|=
name|prevMap
operator|.
name|get
argument_list|(
name|indexedId
argument_list|)
expr_stmt|;
comment|// something found in prevMap will always be found in preMapLog (which could be tlog or prevTlog)
name|lookupLog
operator|=
name|prevMapLog
expr_stmt|;
comment|// SolrCore.verbose("TLOG: lookup ver: for id ",indexedId.utf8ToString(),"in prevMap",System.identityHashCode(map),"got",entry,"lookupLog=",lookupLog);
block|}
if|if
condition|(
name|entry
operator|==
literal|null
operator|&&
name|prevMap2
operator|!=
literal|null
condition|)
block|{
name|entry
operator|=
name|prevMap2
operator|.
name|get
argument_list|(
name|indexedId
argument_list|)
expr_stmt|;
comment|// something found in prevMap2 will always be found in preMapLog2 (which could be tlog or prevTlog)
name|lookupLog
operator|=
name|prevMapLog2
expr_stmt|;
comment|// SolrCore.verbose("TLOG: lookup ver: for id ",indexedId.utf8ToString(),"in prevMap2",System.identityHashCode(map),"got",entry,"lookupLog=",lookupLog);
block|}
block|}
if|if
condition|(
name|entry
operator|!=
literal|null
condition|)
block|{
return|return
name|entry
operator|.
name|version
return|;
block|}
comment|// Now check real index
name|Long
name|version
init|=
name|versionInfo
operator|.
name|getVersionFromIndex
argument_list|(
name|indexedId
argument_list|)
decl_stmt|;
if|if
condition|(
name|version
operator|!=
literal|null
condition|)
block|{
return|return
name|version
return|;
block|}
comment|// We can't get any version info for deletes from the index, so if the doc
comment|// wasn't found, check a cache of recent deletes.
synchronized|synchronized
init|(
name|this
init|)
block|{
name|entry
operator|=
name|oldDeletes
operator|.
name|get
argument_list|(
name|indexedId
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|entry
operator|!=
literal|null
condition|)
block|{
return|return
name|entry
operator|.
name|version
return|;
block|}
return|return
literal|null
return|;
block|}
DECL|method|finish
specifier|public
name|void
name|finish
parameter_list|(
name|SyncLevel
name|syncLevel
parameter_list|)
block|{
if|if
condition|(
name|syncLevel
operator|==
literal|null
condition|)
block|{
name|syncLevel
operator|=
name|defaultSyncLevel
expr_stmt|;
block|}
if|if
condition|(
name|syncLevel
operator|==
name|SyncLevel
operator|.
name|NONE
condition|)
block|{
return|return;
block|}
name|TransactionLog
name|currLog
decl_stmt|;
synchronized|synchronized
init|(
name|this
init|)
block|{
name|currLog
operator|=
name|tlog
expr_stmt|;
if|if
condition|(
name|currLog
operator|==
literal|null
condition|)
return|return;
name|currLog
operator|.
name|incref
argument_list|()
expr_stmt|;
block|}
try|try
block|{
name|currLog
operator|.
name|finish
argument_list|(
name|syncLevel
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|currLog
operator|.
name|decref
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|recoverFromLog
specifier|public
name|Future
argument_list|<
name|RecoveryInfo
argument_list|>
name|recoverFromLog
parameter_list|()
block|{
name|recoveryInfo
operator|=
operator|new
name|RecoveryInfo
argument_list|()
expr_stmt|;
if|if
condition|(
name|newestLogOnStartup
operator|==
literal|null
condition|)
return|return
literal|null
return|;
if|if
condition|(
operator|!
name|newestLogOnStartup
operator|.
name|try_incref
argument_list|()
condition|)
return|return
literal|null
return|;
comment|// log file was already closed
comment|// now that we've incremented the reference, the log shouldn't go away.
try|try
block|{
if|if
condition|(
name|newestLogOnStartup
operator|.
name|endsWithCommit
argument_list|()
condition|)
block|{
name|newestLogOnStartup
operator|.
name|decref
argument_list|()
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"Error inspecting tlog "
operator|+
name|newestLogOnStartup
argument_list|)
expr_stmt|;
name|newestLogOnStartup
operator|.
name|decref
argument_list|()
expr_stmt|;
return|return
literal|null
return|;
block|}
name|ExecutorCompletionService
argument_list|<
name|RecoveryInfo
argument_list|>
name|cs
init|=
operator|new
name|ExecutorCompletionService
argument_list|<
name|RecoveryInfo
argument_list|>
argument_list|(
name|recoveryExecutor
argument_list|)
decl_stmt|;
name|LogReplayer
name|replayer
init|=
operator|new
name|LogReplayer
argument_list|(
name|newestLogOnStartup
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|versionInfo
operator|.
name|blockUpdates
argument_list|()
expr_stmt|;
try|try
block|{
name|state
operator|=
name|State
operator|.
name|REPLAYING
expr_stmt|;
block|}
finally|finally
block|{
name|versionInfo
operator|.
name|unblockUpdates
argument_list|()
expr_stmt|;
block|}
return|return
name|cs
operator|.
name|submit
argument_list|(
name|replayer
argument_list|,
name|recoveryInfo
argument_list|)
return|;
block|}
DECL|method|ensureLog
specifier|private
name|void
name|ensureLog
parameter_list|()
block|{
if|if
condition|(
name|tlog
operator|==
literal|null
condition|)
block|{
name|String
name|newLogName
init|=
name|String
operator|.
name|format
argument_list|(
name|Locale
operator|.
name|ENGLISH
argument_list|,
literal|"%s.%019d"
argument_list|,
name|TLOG_NAME
argument_list|,
name|id
argument_list|)
decl_stmt|;
try|try
block|{
name|tlog
operator|=
operator|new
name|TransactionLog
argument_list|(
operator|new
name|File
argument_list|(
name|tlogDir
argument_list|,
name|newLogName
argument_list|)
argument_list|,
name|globalStrings
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|SolrException
operator|.
name|ErrorCode
operator|.
name|SERVER_ERROR
argument_list|,
literal|"Can't open new tlog!"
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
block|}
DECL|method|close
specifier|public
name|void
name|close
parameter_list|(
name|boolean
name|committed
parameter_list|)
block|{
synchronized|synchronized
init|(
name|this
init|)
block|{
try|try
block|{
name|recoveryExecutor
operator|.
name|shutdownNow
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|SolrException
operator|.
name|log
argument_list|(
name|log
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
comment|// Don't delete the old tlogs, we want to be able to replay from them and retrieve old versions
if|if
condition|(
name|prevTlog
operator|!=
literal|null
condition|)
block|{
name|prevTlog
operator|.
name|deleteOnClose
operator|=
literal|false
expr_stmt|;
name|prevTlog
operator|.
name|decref
argument_list|()
expr_stmt|;
name|prevTlog
operator|.
name|forceClose
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|tlog
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|committed
condition|)
block|{
comment|// record a commit
name|log
operator|.
name|info
argument_list|(
literal|"Recording current log as closed for "
operator|+
name|uhandler
operator|.
name|core
argument_list|)
expr_stmt|;
name|CommitUpdateCommand
name|cmd
init|=
operator|new
name|CommitUpdateCommand
argument_list|(
operator|new
name|LocalSolrQueryRequest
argument_list|(
name|uhandler
operator|.
name|core
argument_list|,
operator|new
name|ModifiableSolrParams
argument_list|(
operator|(
name|SolrParams
operator|)
literal|null
argument_list|)
argument_list|)
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|tlog
operator|.
name|writeCommit
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
block|}
name|tlog
operator|.
name|deleteOnClose
operator|=
literal|false
expr_stmt|;
name|tlog
operator|.
name|decref
argument_list|()
expr_stmt|;
name|tlog
operator|.
name|forceClose
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|TransactionLog
name|log
range|:
name|logs
control|)
block|{
name|log
operator|.
name|deleteOnClose
operator|=
literal|false
expr_stmt|;
name|log
operator|.
name|decref
argument_list|()
expr_stmt|;
name|log
operator|.
name|forceClose
argument_list|()
expr_stmt|;
block|}
block|}
block|}
DECL|class|Update
specifier|static
class|class
name|Update
block|{
DECL|field|log
name|TransactionLog
name|log
decl_stmt|;
DECL|field|version
name|long
name|version
decl_stmt|;
DECL|field|pointer
name|long
name|pointer
decl_stmt|;
block|}
DECL|class|DeleteUpdate
specifier|static
class|class
name|DeleteUpdate
block|{
DECL|field|version
name|long
name|version
decl_stmt|;
DECL|field|id
name|byte
index|[]
name|id
decl_stmt|;
DECL|method|DeleteUpdate
specifier|public
name|DeleteUpdate
parameter_list|(
name|long
name|version
parameter_list|,
name|byte
index|[]
name|id
parameter_list|)
block|{
name|this
operator|.
name|version
operator|=
name|version
expr_stmt|;
name|this
operator|.
name|id
operator|=
name|id
expr_stmt|;
block|}
block|}
DECL|class|RecentUpdates
specifier|public
class|class
name|RecentUpdates
block|{
DECL|field|logList
name|Deque
argument_list|<
name|TransactionLog
argument_list|>
name|logList
decl_stmt|;
comment|// newest first
DECL|field|updateList
name|List
argument_list|<
name|List
argument_list|<
name|Update
argument_list|>
argument_list|>
name|updateList
decl_stmt|;
DECL|field|updates
name|HashMap
argument_list|<
name|Long
argument_list|,
name|Update
argument_list|>
name|updates
decl_stmt|;
DECL|field|deleteByQueryList
name|List
argument_list|<
name|Update
argument_list|>
name|deleteByQueryList
decl_stmt|;
DECL|field|deleteList
name|List
argument_list|<
name|DeleteUpdate
argument_list|>
name|deleteList
decl_stmt|;
DECL|method|getVersions
specifier|public
name|List
argument_list|<
name|Long
argument_list|>
name|getVersions
parameter_list|(
name|int
name|n
parameter_list|)
block|{
name|List
argument_list|<
name|Long
argument_list|>
name|ret
init|=
operator|new
name|ArrayList
argument_list|(
name|n
argument_list|)
decl_stmt|;
for|for
control|(
name|List
argument_list|<
name|Update
argument_list|>
name|singleList
range|:
name|updateList
control|)
block|{
for|for
control|(
name|Update
name|ptr
range|:
name|singleList
control|)
block|{
name|ret
operator|.
name|add
argument_list|(
name|ptr
operator|.
name|version
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|n
operator|<=
literal|0
condition|)
return|return
name|ret
return|;
block|}
block|}
return|return
name|ret
return|;
block|}
DECL|method|lookup
specifier|public
name|Object
name|lookup
parameter_list|(
name|long
name|version
parameter_list|)
block|{
name|Update
name|update
init|=
name|updates
operator|.
name|get
argument_list|(
name|version
argument_list|)
decl_stmt|;
if|if
condition|(
name|update
operator|==
literal|null
condition|)
return|return
literal|null
return|;
return|return
name|update
operator|.
name|log
operator|.
name|lookup
argument_list|(
name|update
operator|.
name|pointer
argument_list|)
return|;
block|}
comment|/** Returns the list of deleteByQueries that happened after the given version */
DECL|method|getDeleteByQuery
specifier|public
name|List
argument_list|<
name|Object
argument_list|>
name|getDeleteByQuery
parameter_list|(
name|long
name|afterVersion
parameter_list|)
block|{
name|List
argument_list|<
name|Object
argument_list|>
name|result
init|=
operator|new
name|ArrayList
argument_list|<
name|Object
argument_list|>
argument_list|(
name|deleteByQueryList
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|Update
name|update
range|:
name|deleteByQueryList
control|)
block|{
if|if
condition|(
name|Math
operator|.
name|abs
argument_list|(
name|update
operator|.
name|version
argument_list|)
operator|>
name|afterVersion
condition|)
block|{
name|Object
name|dbq
init|=
name|update
operator|.
name|log
operator|.
name|lookup
argument_list|(
name|update
operator|.
name|pointer
argument_list|)
decl_stmt|;
name|result
operator|.
name|add
argument_list|(
name|dbq
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
DECL|method|update
specifier|private
name|void
name|update
parameter_list|()
block|{
name|int
name|numUpdates
init|=
literal|0
decl_stmt|;
name|updateList
operator|=
operator|new
name|ArrayList
argument_list|<
name|List
argument_list|<
name|Update
argument_list|>
argument_list|>
argument_list|(
name|logList
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|deleteByQueryList
operator|=
operator|new
name|ArrayList
argument_list|<
name|Update
argument_list|>
argument_list|()
expr_stmt|;
name|deleteList
operator|=
operator|new
name|ArrayList
argument_list|<
name|DeleteUpdate
argument_list|>
argument_list|()
expr_stmt|;
name|updates
operator|=
operator|new
name|HashMap
argument_list|<
name|Long
argument_list|,
name|Update
argument_list|>
argument_list|(
name|numRecordsToKeep
argument_list|)
expr_stmt|;
for|for
control|(
name|TransactionLog
name|oldLog
range|:
name|logList
control|)
block|{
name|List
argument_list|<
name|Update
argument_list|>
name|updatesForLog
init|=
operator|new
name|ArrayList
argument_list|<
name|Update
argument_list|>
argument_list|()
decl_stmt|;
name|TransactionLog
operator|.
name|ReverseReader
name|reader
init|=
literal|null
decl_stmt|;
try|try
block|{
name|reader
operator|=
name|oldLog
operator|.
name|getReverseReader
argument_list|()
expr_stmt|;
while|while
condition|(
name|numUpdates
operator|<
name|numRecordsToKeep
condition|)
block|{
name|Object
name|o
init|=
name|reader
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|o
operator|==
literal|null
condition|)
break|break;
try|try
block|{
comment|// should currently be a List<Oper,Ver,Doc/Id>
name|List
name|entry
init|=
operator|(
name|List
operator|)
name|o
decl_stmt|;
comment|// TODO: refactor this out so we get common error handling
name|int
name|oper
init|=
operator|(
name|Integer
operator|)
name|entry
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|long
name|version
init|=
operator|(
name|Long
operator|)
name|entry
operator|.
name|get
argument_list|(
literal|1
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|oper
condition|)
block|{
case|case
name|UpdateLog
operator|.
name|ADD
case|:
case|case
name|UpdateLog
operator|.
name|DELETE
case|:
case|case
name|UpdateLog
operator|.
name|DELETE_BY_QUERY
case|:
name|Update
name|update
init|=
operator|new
name|Update
argument_list|()
decl_stmt|;
name|update
operator|.
name|log
operator|=
name|oldLog
expr_stmt|;
name|update
operator|.
name|pointer
operator|=
name|reader
operator|.
name|position
argument_list|()
expr_stmt|;
name|update
operator|.
name|version
operator|=
name|version
expr_stmt|;
name|updatesForLog
operator|.
name|add
argument_list|(
name|update
argument_list|)
expr_stmt|;
name|updates
operator|.
name|put
argument_list|(
name|version
argument_list|,
name|update
argument_list|)
expr_stmt|;
if|if
condition|(
name|oper
operator|==
name|UpdateLog
operator|.
name|DELETE_BY_QUERY
condition|)
block|{
name|deleteByQueryList
operator|.
name|add
argument_list|(
name|update
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|oper
operator|==
name|UpdateLog
operator|.
name|DELETE
condition|)
block|{
name|deleteList
operator|.
name|add
argument_list|(
operator|new
name|DeleteUpdate
argument_list|(
name|version
argument_list|,
operator|(
name|byte
index|[]
operator|)
name|entry
operator|.
name|get
argument_list|(
literal|2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|UpdateLog
operator|.
name|COMMIT
case|:
break|break;
default|default:
throw|throw
operator|new
name|SolrException
argument_list|(
name|SolrException
operator|.
name|ErrorCode
operator|.
name|SERVER_ERROR
argument_list|,
literal|"Unknown Operation! "
operator|+
name|oper
argument_list|)
throw|;
block|}
block|}
catch|catch
parameter_list|(
name|ClassCastException
name|cl
parameter_list|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Unexpected log entry or corrupt log.  Entry="
operator|+
name|o
argument_list|,
name|cl
argument_list|)
expr_stmt|;
comment|// would be caused by a corrupt transaction log
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Exception reverse reading log"
argument_list|,
name|ex
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|// failure to read a log record isn't fatal
name|log
operator|.
name|error
argument_list|(
literal|"Exception reading versions from log"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
name|reader
operator|!=
literal|null
condition|)
name|reader
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
name|updateList
operator|.
name|add
argument_list|(
name|updatesForLog
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|close
specifier|public
name|void
name|close
parameter_list|()
block|{
for|for
control|(
name|TransactionLog
name|log
range|:
name|logList
control|)
block|{
name|log
operator|.
name|decref
argument_list|()
expr_stmt|;
block|}
block|}
block|}
DECL|method|getRecentUpdates
specifier|public
name|RecentUpdates
name|getRecentUpdates
parameter_list|()
block|{
name|Deque
argument_list|<
name|TransactionLog
argument_list|>
name|logList
decl_stmt|;
synchronized|synchronized
init|(
name|this
init|)
block|{
name|logList
operator|=
operator|new
name|LinkedList
argument_list|<
name|TransactionLog
argument_list|>
argument_list|(
name|logs
argument_list|)
expr_stmt|;
for|for
control|(
name|TransactionLog
name|log
range|:
name|logList
control|)
block|{
name|log
operator|.
name|incref
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|prevTlog
operator|!=
literal|null
condition|)
block|{
name|prevTlog
operator|.
name|incref
argument_list|()
expr_stmt|;
name|logList
operator|.
name|addFirst
argument_list|(
name|prevTlog
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tlog
operator|!=
literal|null
condition|)
block|{
name|tlog
operator|.
name|incref
argument_list|()
expr_stmt|;
name|logList
operator|.
name|addFirst
argument_list|(
name|tlog
argument_list|)
expr_stmt|;
block|}
block|}
comment|// TODO: what if I hand out a list of updates, then do an update, then hand out another list (and
comment|// one of the updates I originally handed out fell off the list).  Over-request?
name|RecentUpdates
name|recentUpdates
init|=
operator|new
name|RecentUpdates
argument_list|()
decl_stmt|;
name|recentUpdates
operator|.
name|logList
operator|=
name|logList
expr_stmt|;
name|recentUpdates
operator|.
name|update
argument_list|()
expr_stmt|;
return|return
name|recentUpdates
return|;
block|}
DECL|method|bufferUpdates
specifier|public
name|void
name|bufferUpdates
parameter_list|()
block|{
comment|// recovery trips this assert under some race - even when
comment|// it checks the state first
comment|// assert state == State.ACTIVE;
name|recoveryInfo
operator|=
operator|new
name|RecoveryInfo
argument_list|()
expr_stmt|;
comment|// block all updates to eliminate race conditions
comment|// reading state and acting on it in the update processor
name|versionInfo
operator|.
name|blockUpdates
argument_list|()
expr_stmt|;
try|try
block|{
if|if
condition|(
name|state
operator|!=
name|State
operator|.
name|ACTIVE
condition|)
return|return;
if|if
condition|(
name|log
operator|.
name|isInfoEnabled
argument_list|()
condition|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"Starting to buffer updates. "
operator|+
name|this
argument_list|)
expr_stmt|;
block|}
comment|// since we blocked updates, this synchronization shouldn't strictly be necessary.
synchronized|synchronized
init|(
name|this
init|)
block|{
name|recoveryInfo
operator|.
name|positionOfStart
operator|=
name|tlog
operator|==
literal|null
condition|?
literal|0
else|:
name|tlog
operator|.
name|snapshot
argument_list|()
expr_stmt|;
block|}
name|state
operator|=
name|State
operator|.
name|BUFFERING
expr_stmt|;
block|}
finally|finally
block|{
name|versionInfo
operator|.
name|unblockUpdates
argument_list|()
expr_stmt|;
block|}
block|}
comment|/** Returns true if we were able to drop buffered updates and return to the ACTIVE state */
DECL|method|dropBufferedUpdates
specifier|public
name|boolean
name|dropBufferedUpdates
parameter_list|()
block|{
name|versionInfo
operator|.
name|blockUpdates
argument_list|()
expr_stmt|;
try|try
block|{
if|if
condition|(
name|state
operator|!=
name|State
operator|.
name|BUFFERING
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|log
operator|.
name|isInfoEnabled
argument_list|()
condition|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"Dropping buffered updates "
operator|+
name|this
argument_list|)
expr_stmt|;
block|}
comment|// since we blocked updates, this synchronization shouldn't strictly be necessary.
synchronized|synchronized
init|(
name|this
init|)
block|{
if|if
condition|(
name|tlog
operator|!=
literal|null
condition|)
block|{
name|tlog
operator|.
name|rollback
argument_list|(
name|recoveryInfo
operator|.
name|positionOfStart
argument_list|)
expr_stmt|;
block|}
block|}
name|state
operator|=
name|State
operator|.
name|ACTIVE
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|SolrException
operator|.
name|log
argument_list|(
name|log
argument_list|,
literal|"Error attempting to roll back log"
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
finally|finally
block|{
name|versionInfo
operator|.
name|unblockUpdates
argument_list|()
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
comment|/** Returns the Future to wait on, or null if no replay was needed */
DECL|method|applyBufferedUpdates
specifier|public
name|Future
argument_list|<
name|RecoveryInfo
argument_list|>
name|applyBufferedUpdates
parameter_list|()
block|{
comment|// recovery trips this assert under some race - even when
comment|// it checks the state first
comment|// assert state == State.BUFFERING;
comment|// block all updates to eliminate race conditions
comment|// reading state and acting on it in the update processor
name|versionInfo
operator|.
name|blockUpdates
argument_list|()
expr_stmt|;
try|try
block|{
name|cancelApplyBufferUpdate
operator|=
literal|false
expr_stmt|;
if|if
condition|(
name|state
operator|!=
name|State
operator|.
name|BUFFERING
condition|)
return|return
literal|null
return|;
comment|// handle case when no log was even created because no updates
comment|// were received.
if|if
condition|(
name|tlog
operator|==
literal|null
condition|)
block|{
name|state
operator|=
name|State
operator|.
name|ACTIVE
expr_stmt|;
return|return
literal|null
return|;
block|}
name|tlog
operator|.
name|incref
argument_list|()
expr_stmt|;
name|state
operator|=
name|State
operator|.
name|APPLYING_BUFFERED
expr_stmt|;
block|}
finally|finally
block|{
name|versionInfo
operator|.
name|unblockUpdates
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|recoveryExecutor
operator|.
name|isShutdown
argument_list|()
condition|)
block|{
name|tlog
operator|.
name|decref
argument_list|()
expr_stmt|;
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"executor is not running..."
argument_list|)
throw|;
block|}
name|ExecutorCompletionService
argument_list|<
name|RecoveryInfo
argument_list|>
name|cs
init|=
operator|new
name|ExecutorCompletionService
argument_list|<
name|RecoveryInfo
argument_list|>
argument_list|(
name|recoveryExecutor
argument_list|)
decl_stmt|;
name|LogReplayer
name|replayer
init|=
operator|new
name|LogReplayer
argument_list|(
name|tlog
argument_list|,
literal|true
argument_list|)
decl_stmt|;
return|return
name|cs
operator|.
name|submit
argument_list|(
name|replayer
argument_list|,
name|recoveryInfo
argument_list|)
return|;
block|}
DECL|method|getState
specifier|public
name|State
name|getState
parameter_list|()
block|{
return|return
name|state
return|;
block|}
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"FSUpdateLog{state="
operator|+
name|getState
argument_list|()
operator|+
literal|", tlog="
operator|+
name|tlog
operator|+
literal|"}"
return|;
block|}
DECL|field|testing_logReplayHook
specifier|public
specifier|static
name|Runnable
name|testing_logReplayHook
decl_stmt|;
comment|// called before each log read
DECL|field|testing_logReplayFinishHook
specifier|public
specifier|static
name|Runnable
name|testing_logReplayFinishHook
decl_stmt|;
comment|// called when log replay has finished
DECL|field|recoveryInfo
specifier|private
name|RecoveryInfo
name|recoveryInfo
decl_stmt|;
comment|// TODO: do we let the log replayer run across core reloads?
DECL|class|LogReplayer
class|class
name|LogReplayer
implements|implements
name|Runnable
block|{
DECL|field|loglog
specifier|private
name|Logger
name|loglog
init|=
name|log
decl_stmt|;
comment|// set to something different?
DECL|field|translog
name|TransactionLog
name|translog
decl_stmt|;
DECL|field|tlogReader
name|TransactionLog
operator|.
name|LogReader
name|tlogReader
decl_stmt|;
DECL|field|activeLog
name|boolean
name|activeLog
decl_stmt|;
DECL|field|finishing
name|boolean
name|finishing
init|=
literal|false
decl_stmt|;
comment|// state where we lock out other updates and finish those updates that snuck in before we locked
DECL|field|debug
name|boolean
name|debug
init|=
name|loglog
operator|.
name|isDebugEnabled
argument_list|()
decl_stmt|;
DECL|method|LogReplayer
specifier|public
name|LogReplayer
parameter_list|(
name|TransactionLog
name|translog
parameter_list|,
name|boolean
name|activeLog
parameter_list|)
block|{
name|this
operator|.
name|translog
operator|=
name|translog
expr_stmt|;
name|this
operator|.
name|activeLog
operator|=
name|activeLog
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|run
specifier|public
name|void
name|run
parameter_list|()
block|{
name|ModifiableSolrParams
name|params
init|=
operator|new
name|ModifiableSolrParams
argument_list|()
decl_stmt|;
name|params
operator|.
name|set
argument_list|(
name|DistributedUpdateProcessor
operator|.
name|SEEN_LEADER
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|SolrQueryRequest
name|req
init|=
operator|new
name|LocalSolrQueryRequest
argument_list|(
name|uhandler
operator|.
name|core
argument_list|,
name|params
argument_list|)
decl_stmt|;
name|SolrQueryResponse
name|rsp
init|=
operator|new
name|SolrQueryResponse
argument_list|()
decl_stmt|;
name|SolrRequestInfo
operator|.
name|setRequestInfo
argument_list|(
operator|new
name|SolrRequestInfo
argument_list|(
name|req
argument_list|,
name|rsp
argument_list|)
argument_list|)
expr_stmt|;
comment|// setting request info will help logging
try|try
block|{
name|loglog
operator|.
name|warn
argument_list|(
literal|"Starting log replay "
operator|+
name|translog
operator|+
literal|" active="
operator|+
name|activeLog
operator|+
literal|" starting pos="
operator|+
name|recoveryInfo
operator|.
name|positionOfStart
argument_list|)
expr_stmt|;
name|tlogReader
operator|=
name|translog
operator|.
name|getReader
argument_list|(
name|recoveryInfo
operator|.
name|positionOfStart
argument_list|)
expr_stmt|;
comment|// NOTE: we don't currently handle a core reload during recovery.  This would cause the core
comment|// to change underneath us.
comment|// TODO: use the standard request factory?  We won't get any custom configuration instantiating this way.
name|RunUpdateProcessorFactory
name|runFac
init|=
operator|new
name|RunUpdateProcessorFactory
argument_list|()
decl_stmt|;
name|DistributedUpdateProcessorFactory
name|magicFac
init|=
operator|new
name|DistributedUpdateProcessorFactory
argument_list|()
decl_stmt|;
name|runFac
operator|.
name|init
argument_list|(
operator|new
name|NamedList
argument_list|()
argument_list|)
expr_stmt|;
name|magicFac
operator|.
name|init
argument_list|(
operator|new
name|NamedList
argument_list|()
argument_list|)
expr_stmt|;
name|UpdateRequestProcessor
name|proc
init|=
name|magicFac
operator|.
name|getInstance
argument_list|(
name|req
argument_list|,
name|rsp
argument_list|,
name|runFac
operator|.
name|getInstance
argument_list|(
name|req
argument_list|,
name|rsp
argument_list|,
literal|null
argument_list|)
argument_list|)
decl_stmt|;
name|long
name|commitVersion
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|Object
name|o
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|cancelApplyBufferUpdate
condition|)
break|break;
try|try
block|{
if|if
condition|(
name|testing_logReplayHook
operator|!=
literal|null
condition|)
name|testing_logReplayHook
operator|.
name|run
argument_list|()
expr_stmt|;
name|o
operator|=
literal|null
expr_stmt|;
name|o
operator|=
name|tlogReader
operator|.
name|next
argument_list|()
expr_stmt|;
if|if
condition|(
name|o
operator|==
literal|null
operator|&&
name|activeLog
condition|)
block|{
if|if
condition|(
operator|!
name|finishing
condition|)
block|{
comment|// block to prevent new adds, but don't immediately unlock since
comment|// we could be starved from ever completing recovery.  Only unlock
comment|// after we've finished this recovery.
comment|// NOTE: our own updates won't be blocked since the thread holding a write lock can
comment|// lock a read lock.
name|versionInfo
operator|.
name|blockUpdates
argument_list|()
expr_stmt|;
name|finishing
operator|=
literal|true
expr_stmt|;
name|o
operator|=
name|tlogReader
operator|.
name|next
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|// we had previously blocked updates, so this "null" from the log is final.
comment|// Wait until our final commit to change the state and unlock.
comment|// This is only so no new updates are written to the current log file, and is
comment|// only an issue if we crash before the commit (and we are paying attention
comment|// to incomplete log files).
comment|//
comment|// versionInfo.unblockUpdates();
block|}
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|SolrException
operator|.
name|log
argument_list|(
name|log
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|SolrException
operator|.
name|log
argument_list|(
name|log
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|SolrException
operator|.
name|log
argument_list|(
name|log
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|o
operator|==
literal|null
condition|)
break|break;
try|try
block|{
comment|// should currently be a List<Oper,Ver,Doc/Id>
name|List
name|entry
init|=
operator|(
name|List
operator|)
name|o
decl_stmt|;
name|int
name|oper
init|=
operator|(
name|Integer
operator|)
name|entry
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|long
name|version
init|=
operator|(
name|Long
operator|)
name|entry
operator|.
name|get
argument_list|(
literal|1
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|oper
condition|)
block|{
case|case
name|UpdateLog
operator|.
name|ADD
case|:
block|{
name|recoveryInfo
operator|.
name|adds
operator|++
expr_stmt|;
comment|// byte[] idBytes = (byte[]) entry.get(2);
name|SolrInputDocument
name|sdoc
init|=
operator|(
name|SolrInputDocument
operator|)
name|entry
operator|.
name|get
argument_list|(
name|entry
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
decl_stmt|;
name|AddUpdateCommand
name|cmd
init|=
operator|new
name|AddUpdateCommand
argument_list|(
name|req
argument_list|)
decl_stmt|;
comment|// cmd.setIndexedId(new BytesRef(idBytes));
name|cmd
operator|.
name|solrDoc
operator|=
name|sdoc
expr_stmt|;
name|cmd
operator|.
name|setVersion
argument_list|(
name|version
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|setFlags
argument_list|(
name|UpdateCommand
operator|.
name|REPLAY
operator||
name|UpdateCommand
operator|.
name|IGNORE_AUTOCOMMIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|log
operator|.
name|debug
argument_list|(
literal|"add "
operator|+
name|cmd
argument_list|)
expr_stmt|;
name|proc
operator|.
name|processAdd
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|UpdateLog
operator|.
name|DELETE
case|:
block|{
name|recoveryInfo
operator|.
name|deletes
operator|++
expr_stmt|;
name|byte
index|[]
name|idBytes
init|=
operator|(
name|byte
index|[]
operator|)
name|entry
operator|.
name|get
argument_list|(
literal|2
argument_list|)
decl_stmt|;
name|DeleteUpdateCommand
name|cmd
init|=
operator|new
name|DeleteUpdateCommand
argument_list|(
name|req
argument_list|)
decl_stmt|;
name|cmd
operator|.
name|setIndexedId
argument_list|(
operator|new
name|BytesRef
argument_list|(
name|idBytes
argument_list|)
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|setVersion
argument_list|(
name|version
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|setFlags
argument_list|(
name|UpdateCommand
operator|.
name|REPLAY
operator||
name|UpdateCommand
operator|.
name|IGNORE_AUTOCOMMIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|log
operator|.
name|debug
argument_list|(
literal|"delete "
operator|+
name|cmd
argument_list|)
expr_stmt|;
name|proc
operator|.
name|processDelete
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|UpdateLog
operator|.
name|DELETE_BY_QUERY
case|:
block|{
name|recoveryInfo
operator|.
name|deleteByQuery
operator|++
expr_stmt|;
name|String
name|query
init|=
operator|(
name|String
operator|)
name|entry
operator|.
name|get
argument_list|(
literal|2
argument_list|)
decl_stmt|;
name|DeleteUpdateCommand
name|cmd
init|=
operator|new
name|DeleteUpdateCommand
argument_list|(
name|req
argument_list|)
decl_stmt|;
name|cmd
operator|.
name|query
operator|=
name|query
expr_stmt|;
name|cmd
operator|.
name|setVersion
argument_list|(
name|version
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|setFlags
argument_list|(
name|UpdateCommand
operator|.
name|REPLAY
operator||
name|UpdateCommand
operator|.
name|IGNORE_AUTOCOMMIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|log
operator|.
name|debug
argument_list|(
literal|"deleteByQuery "
operator|+
name|cmd
argument_list|)
expr_stmt|;
name|proc
operator|.
name|processDelete
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|UpdateLog
operator|.
name|COMMIT
case|:
block|{
name|commitVersion
operator|=
name|version
expr_stmt|;
break|break;
block|}
default|default:
throw|throw
operator|new
name|SolrException
argument_list|(
name|SolrException
operator|.
name|ErrorCode
operator|.
name|SERVER_ERROR
argument_list|,
literal|"Unknown Operation! "
operator|+
name|oper
argument_list|)
throw|;
block|}
if|if
condition|(
name|rsp
operator|.
name|getException
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|loglog
operator|.
name|error
argument_list|(
literal|"REPLAY_ERR: Exception replaying log"
argument_list|,
name|rsp
operator|.
name|getException
argument_list|()
argument_list|)
expr_stmt|;
throw|throw
name|rsp
operator|.
name|getException
argument_list|()
throw|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
name|recoveryInfo
operator|.
name|errors
operator|++
expr_stmt|;
name|loglog
operator|.
name|warn
argument_list|(
literal|"REYPLAY_ERR: IOException reading log"
argument_list|,
name|ex
argument_list|)
expr_stmt|;
comment|// could be caused by an incomplete flush if recovering from log
block|}
catch|catch
parameter_list|(
name|ClassCastException
name|cl
parameter_list|)
block|{
name|recoveryInfo
operator|.
name|errors
operator|++
expr_stmt|;
name|loglog
operator|.
name|warn
argument_list|(
literal|"REPLAY_ERR: Unexpected log entry or corrupt log.  Entry="
operator|+
name|o
argument_list|,
name|cl
argument_list|)
expr_stmt|;
comment|// would be caused by a corrupt transaction log
block|}
catch|catch
parameter_list|(
name|Throwable
name|ex
parameter_list|)
block|{
name|recoveryInfo
operator|.
name|errors
operator|++
expr_stmt|;
name|loglog
operator|.
name|warn
argument_list|(
literal|"REPLAY_ERR: Exception replaying log"
argument_list|,
name|ex
argument_list|)
expr_stmt|;
comment|// something wrong with the request?
block|}
block|}
name|CommitUpdateCommand
name|cmd
init|=
operator|new
name|CommitUpdateCommand
argument_list|(
name|req
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|cmd
operator|.
name|setVersion
argument_list|(
name|commitVersion
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|softCommit
operator|=
literal|false
expr_stmt|;
name|cmd
operator|.
name|waitSearcher
operator|=
literal|true
expr_stmt|;
name|cmd
operator|.
name|setFlags
argument_list|(
name|UpdateCommand
operator|.
name|REPLAY
argument_list|)
expr_stmt|;
try|try
block|{
if|if
condition|(
name|debug
condition|)
name|log
operator|.
name|debug
argument_list|(
literal|"commit "
operator|+
name|cmd
argument_list|)
expr_stmt|;
name|uhandler
operator|.
name|commit
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
comment|// this should cause a commit to be added to the incomplete log and avoid it being replayed again after a restart.
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
name|recoveryInfo
operator|.
name|errors
operator|++
expr_stmt|;
name|loglog
operator|.
name|error
argument_list|(
literal|"Replay exception: final commit."
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|activeLog
condition|)
block|{
comment|// if we are replaying an old tlog file, we need to add a commit to the end
comment|// so we don't replay it again if we restart right after.
name|translog
operator|.
name|writeCommit
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|proc
operator|.
name|finish
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
name|recoveryInfo
operator|.
name|errors
operator|++
expr_stmt|;
name|loglog
operator|.
name|error
argument_list|(
literal|"Replay exception: finish()"
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
name|tlogReader
operator|.
name|close
argument_list|()
expr_stmt|;
name|translog
operator|.
name|decref
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|recoveryInfo
operator|.
name|errors
operator|++
expr_stmt|;
name|SolrException
operator|.
name|log
argument_list|(
name|log
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
comment|// change the state while updates are still blocked to prevent races
name|state
operator|=
name|State
operator|.
name|ACTIVE
expr_stmt|;
if|if
condition|(
name|finishing
condition|)
block|{
name|versionInfo
operator|.
name|unblockUpdates
argument_list|()
expr_stmt|;
block|}
block|}
name|loglog
operator|.
name|warn
argument_list|(
literal|"Ending log replay "
operator|+
name|tlogReader
operator|+
literal|" recoveryInfo="
operator|+
name|recoveryInfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|testing_logReplayFinishHook
operator|!=
literal|null
condition|)
name|testing_logReplayFinishHook
operator|.
name|run
argument_list|()
expr_stmt|;
name|SolrRequestInfo
operator|.
name|clearRequestInfo
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|cancelApplyBufferedUpdates
specifier|public
name|void
name|cancelApplyBufferedUpdates
parameter_list|()
block|{
name|this
operator|.
name|cancelApplyBufferUpdate
operator|=
literal|true
expr_stmt|;
block|}
DECL|field|recoveryExecutor
name|ThreadPoolExecutor
name|recoveryExecutor
init|=
operator|new
name|ThreadPoolExecutor
argument_list|(
literal|0
argument_list|,
name|Integer
operator|.
name|MAX_VALUE
argument_list|,
literal|1
argument_list|,
name|TimeUnit
operator|.
name|SECONDS
argument_list|,
operator|new
name|SynchronousQueue
argument_list|<
name|Runnable
argument_list|>
argument_list|()
argument_list|,
operator|new
name|DefaultSolrThreadFactory
argument_list|(
literal|"recoveryExecutor"
argument_list|)
argument_list|)
decl_stmt|;
block|}
end_class
end_unit
