begin_unit
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_package
DECL|package|org.apache.solr.update
package|package
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|update
package|;
end_package
begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|update
operator|.
name|processor
operator|.
name|DistributedUpdateProcessor
operator|.
name|DistribPhase
operator|.
name|FROMLEADER
import|;
end_import
begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|update
operator|.
name|processor
operator|.
name|DistributingUpdateProcessorFactory
operator|.
name|DISTRIB_UPDATE_PARAM
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileNotFoundException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FilenameFilter
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Deque
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashMap
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedList
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ListIterator
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Locale
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ExecutorCompletionService
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Future
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|SynchronousQueue
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ThreadPoolExecutor
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileSystem
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|BytesRef
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|SolrException
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|SolrException
operator|.
name|ErrorCode
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|SolrInputDocument
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|params
operator|.
name|ModifiableSolrParams
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|params
operator|.
name|SolrParams
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|util
operator|.
name|ExecutorUtil
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|core
operator|.
name|PluginInfo
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|core
operator|.
name|SolrCore
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|request
operator|.
name|LocalSolrQueryRequest
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|request
operator|.
name|SolrQueryRequest
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|request
operator|.
name|SolrRequestInfo
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|response
operator|.
name|SolrQueryResponse
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|search
operator|.
name|SolrIndexSearcher
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|update
operator|.
name|processor
operator|.
name|DistributedUpdateProcessor
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|update
operator|.
name|processor
operator|.
name|UpdateRequestProcessor
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|update
operator|.
name|processor
operator|.
name|UpdateRequestProcessorChain
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|util
operator|.
name|DefaultSolrThreadFactory
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|util
operator|.
name|RefCounted
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|util
operator|.
name|plugin
operator|.
name|PluginInfoInitialized
import|;
end_import
begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import
begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import
begin_comment
comment|/** @lucene.experimental */
end_comment
begin_class
DECL|class|UpdateLog
specifier|public
class|class
name|UpdateLog
implements|implements
name|PluginInfoInitialized
block|{
DECL|field|LOG_FILENAME_PATTERN
specifier|public
specifier|static
name|String
name|LOG_FILENAME_PATTERN
init|=
literal|"%s.%019d"
decl_stmt|;
DECL|field|TLOG_NAME
specifier|public
specifier|static
name|String
name|TLOG_NAME
init|=
literal|"tlog"
decl_stmt|;
DECL|field|log
specifier|public
specifier|static
name|Logger
name|log
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|UpdateLog
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|debug
specifier|public
name|boolean
name|debug
init|=
name|log
operator|.
name|isDebugEnabled
argument_list|()
decl_stmt|;
DECL|field|trace
specifier|public
name|boolean
name|trace
init|=
name|log
operator|.
name|isTraceEnabled
argument_list|()
decl_stmt|;
comment|// TODO: hack
DECL|method|getFs
specifier|public
name|FileSystem
name|getFs
parameter_list|()
block|{
return|return
literal|null
return|;
block|}
DECL|enum|SyncLevel
DECL|enum constant|NONE
DECL|enum constant|FLUSH
DECL|enum constant|FSYNC
specifier|public
enum|enum
name|SyncLevel
block|{
name|NONE
block|,
name|FLUSH
block|,
name|FSYNC
block|;
DECL|method|getSyncLevel
specifier|public
specifier|static
name|SyncLevel
name|getSyncLevel
parameter_list|(
name|String
name|level
parameter_list|)
block|{
if|if
condition|(
name|level
operator|==
literal|null
condition|)
block|{
return|return
name|SyncLevel
operator|.
name|FLUSH
return|;
block|}
try|try
block|{
return|return
name|SyncLevel
operator|.
name|valueOf
argument_list|(
name|level
operator|.
name|toUpperCase
argument_list|(
name|Locale
operator|.
name|ROOT
argument_list|)
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"There was an error reading the SyncLevel - default to "
operator|+
name|SyncLevel
operator|.
name|FLUSH
argument_list|,
name|ex
argument_list|)
expr_stmt|;
return|return
name|SyncLevel
operator|.
name|FLUSH
return|;
block|}
block|}
block|}
DECL|enum|State
DECL|enum constant|REPLAYING
DECL|enum constant|BUFFERING
DECL|enum constant|APPLYING_BUFFERED
DECL|enum constant|ACTIVE
specifier|public
enum|enum
name|State
block|{
name|REPLAYING
block|,
name|BUFFERING
block|,
name|APPLYING_BUFFERED
block|,
name|ACTIVE
block|}
DECL|field|ADD
specifier|public
specifier|static
specifier|final
name|int
name|ADD
init|=
literal|0x01
decl_stmt|;
DECL|field|DELETE
specifier|public
specifier|static
specifier|final
name|int
name|DELETE
init|=
literal|0x02
decl_stmt|;
DECL|field|DELETE_BY_QUERY
specifier|public
specifier|static
specifier|final
name|int
name|DELETE_BY_QUERY
init|=
literal|0x03
decl_stmt|;
DECL|field|COMMIT
specifier|public
specifier|static
specifier|final
name|int
name|COMMIT
init|=
literal|0x04
decl_stmt|;
comment|// Flag indicating that this is a buffered operation, and that a gap exists before buffering started.
comment|// for example, if full index replication starts and we are buffering updates, then this flag should
comment|// be set to indicate that replaying the log would not bring us into sync (i.e. peersync should
comment|// fail if this flag is set on the last update in the tlog).
DECL|field|FLAG_GAP
specifier|public
specifier|static
specifier|final
name|int
name|FLAG_GAP
init|=
literal|0x10
decl_stmt|;
DECL|field|OPERATION_MASK
specifier|public
specifier|static
specifier|final
name|int
name|OPERATION_MASK
init|=
literal|0x0f
decl_stmt|;
comment|// mask off flags to get the operation
DECL|class|RecoveryInfo
specifier|public
specifier|static
class|class
name|RecoveryInfo
block|{
DECL|field|positionOfStart
specifier|public
name|long
name|positionOfStart
decl_stmt|;
DECL|field|adds
specifier|public
name|int
name|adds
decl_stmt|;
DECL|field|deletes
specifier|public
name|int
name|deletes
decl_stmt|;
DECL|field|deleteByQuery
specifier|public
name|int
name|deleteByQuery
decl_stmt|;
DECL|field|errors
specifier|public
name|int
name|errors
decl_stmt|;
DECL|field|failed
specifier|public
name|boolean
name|failed
decl_stmt|;
annotation|@
name|Override
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"RecoveryInfo{adds="
operator|+
name|adds
operator|+
literal|" deletes="
operator|+
name|deletes
operator|+
literal|" deleteByQuery="
operator|+
name|deleteByQuery
operator|+
literal|" errors="
operator|+
name|errors
operator|+
literal|" positionOfStart="
operator|+
name|positionOfStart
operator|+
literal|"}"
return|;
block|}
block|}
DECL|field|id
name|long
name|id
init|=
operator|-
literal|1
decl_stmt|;
DECL|field|state
specifier|protected
name|State
name|state
init|=
name|State
operator|.
name|ACTIVE
decl_stmt|;
DECL|field|operationFlags
specifier|protected
name|int
name|operationFlags
decl_stmt|;
comment|// flags to write in the transaction log with operations (i.e. FLAG_GAP)
DECL|field|tlog
specifier|protected
name|TransactionLog
name|tlog
decl_stmt|;
DECL|field|prevTlog
specifier|protected
name|TransactionLog
name|prevTlog
decl_stmt|;
DECL|field|logs
specifier|protected
name|Deque
argument_list|<
name|TransactionLog
argument_list|>
name|logs
init|=
operator|new
name|LinkedList
argument_list|<
name|TransactionLog
argument_list|>
argument_list|()
decl_stmt|;
comment|// list of recent logs, newest first
DECL|field|newestLogsOnStartup
specifier|protected
name|LinkedList
argument_list|<
name|TransactionLog
argument_list|>
name|newestLogsOnStartup
init|=
operator|new
name|LinkedList
argument_list|<
name|TransactionLog
argument_list|>
argument_list|()
decl_stmt|;
DECL|field|numOldRecords
specifier|protected
name|int
name|numOldRecords
decl_stmt|;
comment|// number of records in the recent logs
DECL|field|map
specifier|protected
name|Map
argument_list|<
name|BytesRef
argument_list|,
name|LogPtr
argument_list|>
name|map
init|=
operator|new
name|HashMap
argument_list|<
name|BytesRef
argument_list|,
name|LogPtr
argument_list|>
argument_list|()
decl_stmt|;
DECL|field|prevMap
specifier|protected
name|Map
argument_list|<
name|BytesRef
argument_list|,
name|LogPtr
argument_list|>
name|prevMap
decl_stmt|;
comment|// used while committing/reopening is happening
DECL|field|prevMap2
specifier|protected
name|Map
argument_list|<
name|BytesRef
argument_list|,
name|LogPtr
argument_list|>
name|prevMap2
decl_stmt|;
comment|// used while committing/reopening is happening
DECL|field|prevMapLog
specifier|protected
name|TransactionLog
name|prevMapLog
decl_stmt|;
comment|// the transaction log used to look up entries found in prevMap
DECL|field|prevMapLog2
specifier|protected
name|TransactionLog
name|prevMapLog2
decl_stmt|;
comment|// the transaction log used to look up entries found in prevMap
DECL|field|numDeletesToKeep
specifier|protected
specifier|final
name|int
name|numDeletesToKeep
init|=
literal|1000
decl_stmt|;
DECL|field|numDeletesByQueryToKeep
specifier|protected
specifier|final
name|int
name|numDeletesByQueryToKeep
init|=
literal|100
decl_stmt|;
DECL|field|numRecordsToKeep
specifier|public
specifier|final
name|int
name|numRecordsToKeep
init|=
literal|100
decl_stmt|;
comment|// keep track of deletes only... this is not updated on an add
DECL|field|oldDeletes
specifier|protected
name|LinkedHashMap
argument_list|<
name|BytesRef
argument_list|,
name|LogPtr
argument_list|>
name|oldDeletes
init|=
operator|new
name|LinkedHashMap
argument_list|<
name|BytesRef
argument_list|,
name|LogPtr
argument_list|>
argument_list|(
name|numDeletesToKeep
argument_list|)
block|{
annotation|@
name|Override
specifier|protected
name|boolean
name|removeEldestEntry
parameter_list|(
name|Map
operator|.
name|Entry
name|eldest
parameter_list|)
block|{
return|return
name|size
argument_list|()
operator|>
name|numDeletesToKeep
return|;
block|}
block|}
decl_stmt|;
DECL|class|DBQ
specifier|public
class|class
name|DBQ
block|{
DECL|field|q
specifier|public
name|String
name|q
decl_stmt|;
comment|// the query string
DECL|field|version
specifier|public
name|long
name|version
decl_stmt|;
comment|// positive version of the DBQ
annotation|@
name|Override
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"DBQ{version="
operator|+
name|version
operator|+
literal|",q="
operator|+
name|q
operator|+
literal|"}"
return|;
block|}
block|}
DECL|field|deleteByQueries
specifier|protected
name|LinkedList
argument_list|<
name|DBQ
argument_list|>
name|deleteByQueries
init|=
operator|new
name|LinkedList
argument_list|<
name|DBQ
argument_list|>
argument_list|()
decl_stmt|;
DECL|field|tlogFiles
specifier|protected
name|String
index|[]
name|tlogFiles
decl_stmt|;
DECL|field|tlogDir
specifier|protected
name|File
name|tlogDir
decl_stmt|;
DECL|field|globalStrings
specifier|protected
name|Collection
argument_list|<
name|String
argument_list|>
name|globalStrings
decl_stmt|;
DECL|field|dataDir
specifier|protected
name|String
name|dataDir
decl_stmt|;
DECL|field|lastDataDir
specifier|protected
name|String
name|lastDataDir
decl_stmt|;
DECL|field|versionInfo
specifier|protected
name|VersionInfo
name|versionInfo
decl_stmt|;
DECL|field|defaultSyncLevel
specifier|protected
name|SyncLevel
name|defaultSyncLevel
init|=
name|SyncLevel
operator|.
name|FLUSH
decl_stmt|;
DECL|field|uhandler
specifier|volatile
name|UpdateHandler
name|uhandler
decl_stmt|;
comment|// a core reload can change this reference!
DECL|field|cancelApplyBufferUpdate
specifier|protected
specifier|volatile
name|boolean
name|cancelApplyBufferUpdate
decl_stmt|;
DECL|field|startingVersions
name|List
argument_list|<
name|Long
argument_list|>
name|startingVersions
decl_stmt|;
DECL|field|startingOperation
name|int
name|startingOperation
decl_stmt|;
comment|// last operation in the logs on startup
DECL|class|LogPtr
specifier|public
specifier|static
class|class
name|LogPtr
block|{
DECL|field|pointer
specifier|final
name|long
name|pointer
decl_stmt|;
DECL|field|version
specifier|final
name|long
name|version
decl_stmt|;
DECL|method|LogPtr
specifier|public
name|LogPtr
parameter_list|(
name|long
name|pointer
parameter_list|,
name|long
name|version
parameter_list|)
block|{
name|this
operator|.
name|pointer
operator|=
name|pointer
expr_stmt|;
name|this
operator|.
name|version
operator|=
name|version
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"LogPtr("
operator|+
name|pointer
operator|+
literal|")"
return|;
block|}
block|}
DECL|method|getVersionInfo
specifier|public
name|VersionInfo
name|getVersionInfo
parameter_list|()
block|{
return|return
name|versionInfo
return|;
block|}
annotation|@
name|Override
DECL|method|init
specifier|public
name|void
name|init
parameter_list|(
name|PluginInfo
name|info
parameter_list|)
block|{
name|dataDir
operator|=
operator|(
name|String
operator|)
name|info
operator|.
name|initArgs
operator|.
name|get
argument_list|(
literal|"dir"
argument_list|)
expr_stmt|;
name|defaultSyncLevel
operator|=
name|SyncLevel
operator|.
name|getSyncLevel
argument_list|(
operator|(
name|String
operator|)
name|info
operator|.
name|initArgs
operator|.
name|get
argument_list|(
literal|"syncLevel"
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Note, when this is called, uhandler is not completely constructed.    * This must be called when a new log is created, or    * for an existing log whenever the core or update handler changes.    */
DECL|method|init
specifier|public
name|void
name|init
parameter_list|(
name|UpdateHandler
name|uhandler
parameter_list|,
name|SolrCore
name|core
parameter_list|)
block|{
comment|// ulogDir from CoreDescriptor overrides
name|String
name|ulogDir
init|=
name|core
operator|.
name|getCoreDescriptor
argument_list|()
operator|.
name|getUlogDir
argument_list|()
decl_stmt|;
if|if
condition|(
name|ulogDir
operator|!=
literal|null
condition|)
block|{
name|dataDir
operator|=
name|ulogDir
expr_stmt|;
block|}
if|if
condition|(
name|dataDir
operator|==
literal|null
operator|||
name|dataDir
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
block|{
name|dataDir
operator|=
name|core
operator|.
name|getDataDir
argument_list|()
expr_stmt|;
block|}
name|this
operator|.
name|uhandler
operator|=
name|uhandler
expr_stmt|;
if|if
condition|(
name|dataDir
operator|.
name|equals
argument_list|(
name|lastDataDir
argument_list|)
condition|)
block|{
if|if
condition|(
name|debug
condition|)
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"UpdateHandler init: tlogDir="
operator|+
name|tlogDir
operator|+
literal|", next id="
operator|+
name|id
argument_list|,
literal|" this is a reopen... nothing else to do."
argument_list|)
expr_stmt|;
block|}
name|versionInfo
operator|.
name|reload
argument_list|()
expr_stmt|;
comment|// on a normal reopen, we currently shouldn't have to do anything
return|return;
block|}
name|lastDataDir
operator|=
name|dataDir
expr_stmt|;
name|tlogDir
operator|=
operator|new
name|File
argument_list|(
name|dataDir
argument_list|,
name|TLOG_NAME
argument_list|)
expr_stmt|;
name|tlogDir
operator|.
name|mkdirs
argument_list|()
expr_stmt|;
name|tlogFiles
operator|=
name|getLogList
argument_list|(
name|tlogDir
argument_list|)
expr_stmt|;
name|id
operator|=
name|getLastLogId
argument_list|()
operator|+
literal|1
expr_stmt|;
comment|// add 1 since we will create a new log for the next update
if|if
condition|(
name|debug
condition|)
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"UpdateHandler init: tlogDir="
operator|+
name|tlogDir
operator|+
literal|", existing tlogs="
operator|+
name|Arrays
operator|.
name|asList
argument_list|(
name|tlogFiles
argument_list|)
operator|+
literal|", next id="
operator|+
name|id
argument_list|)
expr_stmt|;
block|}
name|TransactionLog
name|oldLog
init|=
literal|null
decl_stmt|;
for|for
control|(
name|String
name|oldLogName
range|:
name|tlogFiles
control|)
block|{
name|File
name|f
init|=
operator|new
name|File
argument_list|(
name|tlogDir
argument_list|,
name|oldLogName
argument_list|)
decl_stmt|;
try|try
block|{
name|oldLog
operator|=
operator|new
name|TransactionLog
argument_list|(
name|f
argument_list|,
literal|null
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|addOldLog
argument_list|(
name|oldLog
argument_list|,
literal|false
argument_list|)
expr_stmt|;
comment|// don't remove old logs on startup since more than one may be uncapped.
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|SolrException
operator|.
name|log
argument_list|(
name|log
argument_list|,
literal|"Failure to open existing log file (non fatal) "
operator|+
name|f
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|deleteFile
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Record first two logs (oldest first) at startup for potential tlog recovery.
comment|// It's possible that at abnormal shutdown both "tlog" and "prevTlog" were uncapped.
for|for
control|(
name|TransactionLog
name|ll
range|:
name|logs
control|)
block|{
name|newestLogsOnStartup
operator|.
name|addFirst
argument_list|(
name|ll
argument_list|)
expr_stmt|;
if|if
condition|(
name|newestLogsOnStartup
operator|.
name|size
argument_list|()
operator|>=
literal|2
condition|)
break|break;
block|}
try|try
block|{
name|versionInfo
operator|=
operator|new
name|VersionInfo
argument_list|(
name|this
argument_list|,
literal|256
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SolrException
name|e
parameter_list|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"Unable to use updateLog: "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|SolrException
argument_list|(
name|SolrException
operator|.
name|ErrorCode
operator|.
name|SERVER_ERROR
argument_list|,
literal|"Unable to use updateLog: "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
comment|// TODO: these startingVersions assume that we successfully recover from all non-complete tlogs.
name|UpdateLog
operator|.
name|RecentUpdates
name|startingUpdates
init|=
name|getRecentUpdates
argument_list|()
decl_stmt|;
try|try
block|{
name|startingVersions
operator|=
name|startingUpdates
operator|.
name|getVersions
argument_list|(
name|numRecordsToKeep
argument_list|)
expr_stmt|;
name|startingOperation
operator|=
name|startingUpdates
operator|.
name|getLatestOperation
argument_list|()
expr_stmt|;
comment|// populate recent deletes list (since we can't get that info from the index)
for|for
control|(
name|int
name|i
init|=
name|startingUpdates
operator|.
name|deleteList
operator|.
name|size
argument_list|()
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|DeleteUpdate
name|du
init|=
name|startingUpdates
operator|.
name|deleteList
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|oldDeletes
operator|.
name|put
argument_list|(
operator|new
name|BytesRef
argument_list|(
name|du
operator|.
name|id
argument_list|)
argument_list|,
operator|new
name|LogPtr
argument_list|(
operator|-
literal|1
argument_list|,
name|du
operator|.
name|version
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// populate recent deleteByQuery commands
for|for
control|(
name|int
name|i
init|=
name|startingUpdates
operator|.
name|deleteByQueryList
operator|.
name|size
argument_list|()
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|Update
name|update
init|=
name|startingUpdates
operator|.
name|deleteByQueryList
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Object
argument_list|>
name|dbq
init|=
operator|(
name|List
argument_list|<
name|Object
argument_list|>
operator|)
name|update
operator|.
name|log
operator|.
name|lookup
argument_list|(
name|update
operator|.
name|pointer
argument_list|)
decl_stmt|;
name|long
name|version
init|=
operator|(
name|Long
operator|)
name|dbq
operator|.
name|get
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|String
name|q
init|=
operator|(
name|String
operator|)
name|dbq
operator|.
name|get
argument_list|(
literal|2
argument_list|)
decl_stmt|;
name|trackDeleteByQuery
argument_list|(
name|q
argument_list|,
name|version
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|startingUpdates
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|getLogDir
specifier|public
name|String
name|getLogDir
parameter_list|()
block|{
return|return
name|tlogDir
operator|.
name|getAbsolutePath
argument_list|()
return|;
block|}
DECL|method|getStartingVersions
specifier|public
name|List
argument_list|<
name|Long
argument_list|>
name|getStartingVersions
parameter_list|()
block|{
return|return
name|startingVersions
return|;
block|}
DECL|method|getStartingOperation
specifier|public
name|int
name|getStartingOperation
parameter_list|()
block|{
return|return
name|startingOperation
return|;
block|}
comment|/* Takes over ownership of the log, keeping it until no longer needed      and then decrementing it's reference and dropping it.    */
DECL|method|addOldLog
specifier|protected
name|void
name|addOldLog
parameter_list|(
name|TransactionLog
name|oldLog
parameter_list|,
name|boolean
name|removeOld
parameter_list|)
block|{
if|if
condition|(
name|oldLog
operator|==
literal|null
condition|)
return|return;
name|numOldRecords
operator|+=
name|oldLog
operator|.
name|numRecords
argument_list|()
expr_stmt|;
name|int
name|currRecords
init|=
name|numOldRecords
decl_stmt|;
if|if
condition|(
name|oldLog
operator|!=
name|tlog
operator|&&
name|tlog
operator|!=
literal|null
condition|)
block|{
name|currRecords
operator|+=
name|tlog
operator|.
name|numRecords
argument_list|()
expr_stmt|;
block|}
while|while
condition|(
name|removeOld
operator|&&
name|logs
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|TransactionLog
name|log
init|=
name|logs
operator|.
name|peekLast
argument_list|()
decl_stmt|;
name|int
name|nrec
init|=
name|log
operator|.
name|numRecords
argument_list|()
decl_stmt|;
comment|// remove oldest log if we don't need it to keep at least numRecordsToKeep, or if
comment|// we already have the limit of 10 log files.
if|if
condition|(
name|currRecords
operator|-
name|nrec
operator|>=
name|numRecordsToKeep
operator|||
name|logs
operator|.
name|size
argument_list|()
operator|>=
literal|10
condition|)
block|{
name|currRecords
operator|-=
name|nrec
expr_stmt|;
name|numOldRecords
operator|-=
name|nrec
expr_stmt|;
name|logs
operator|.
name|removeLast
argument_list|()
operator|.
name|decref
argument_list|()
expr_stmt|;
comment|// dereference so it will be deleted when no longer in use
continue|continue;
block|}
break|break;
block|}
comment|// don't incref... we are taking ownership from the caller.
name|logs
operator|.
name|addFirst
argument_list|(
name|oldLog
argument_list|)
expr_stmt|;
block|}
DECL|method|getLogList
specifier|public
name|String
index|[]
name|getLogList
parameter_list|(
name|File
name|directory
parameter_list|)
block|{
specifier|final
name|String
name|prefix
init|=
name|TLOG_NAME
operator|+
literal|'.'
decl_stmt|;
name|String
index|[]
name|names
init|=
name|directory
operator|.
name|list
argument_list|(
operator|new
name|FilenameFilter
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|boolean
name|accept
parameter_list|(
name|File
name|dir
parameter_list|,
name|String
name|name
parameter_list|)
block|{
return|return
name|name
operator|.
name|startsWith
argument_list|(
name|prefix
argument_list|)
return|;
block|}
block|}
argument_list|)
decl_stmt|;
if|if
condition|(
name|names
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
operator|new
name|FileNotFoundException
argument_list|(
name|directory
operator|.
name|getAbsolutePath
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
name|Arrays
operator|.
name|sort
argument_list|(
name|names
argument_list|)
expr_stmt|;
return|return
name|names
return|;
block|}
DECL|method|getLastLogId
specifier|public
name|long
name|getLastLogId
parameter_list|()
block|{
if|if
condition|(
name|id
operator|!=
operator|-
literal|1
condition|)
return|return
name|id
return|;
if|if
condition|(
name|tlogFiles
operator|.
name|length
operator|==
literal|0
condition|)
return|return
operator|-
literal|1
return|;
name|String
name|last
init|=
name|tlogFiles
index|[
name|tlogFiles
operator|.
name|length
operator|-
literal|1
index|]
decl_stmt|;
return|return
name|Long
operator|.
name|parseLong
argument_list|(
name|last
operator|.
name|substring
argument_list|(
name|TLOG_NAME
operator|.
name|length
argument_list|()
operator|+
literal|1
argument_list|)
argument_list|)
return|;
block|}
DECL|method|add
specifier|public
name|void
name|add
parameter_list|(
name|AddUpdateCommand
name|cmd
parameter_list|)
block|{
name|add
argument_list|(
name|cmd
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
DECL|method|add
specifier|public
name|void
name|add
parameter_list|(
name|AddUpdateCommand
name|cmd
parameter_list|,
name|boolean
name|clearCaches
parameter_list|)
block|{
comment|// don't log if we are replaying from another log
comment|// TODO: we currently need to log to maintain correct versioning, rtg, etc
comment|// if ((cmd.getFlags()& UpdateCommand.REPLAY) != 0) return;
synchronized|synchronized
init|(
name|this
init|)
block|{
name|long
name|pos
init|=
operator|-
literal|1
decl_stmt|;
comment|// don't log if we are replaying from another log
if|if
condition|(
operator|(
name|cmd
operator|.
name|getFlags
argument_list|()
operator|&
name|UpdateCommand
operator|.
name|REPLAY
operator|)
operator|==
literal|0
condition|)
block|{
name|ensureLog
argument_list|()
expr_stmt|;
name|pos
operator|=
name|tlog
operator|.
name|write
argument_list|(
name|cmd
argument_list|,
name|operationFlags
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|clearCaches
condition|)
block|{
comment|// TODO: in the future we could support a real position for a REPLAY update.
comment|// Only currently would be useful for RTG while in recovery mode though.
name|LogPtr
name|ptr
init|=
operator|new
name|LogPtr
argument_list|(
name|pos
argument_list|,
name|cmd
operator|.
name|getVersion
argument_list|()
argument_list|)
decl_stmt|;
comment|// only update our map if we're not buffering
if|if
condition|(
operator|(
name|cmd
operator|.
name|getFlags
argument_list|()
operator|&
name|UpdateCommand
operator|.
name|BUFFERING
operator|)
operator|==
literal|0
condition|)
block|{
name|map
operator|.
name|put
argument_list|(
name|cmd
operator|.
name|getIndexedId
argument_list|()
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|trace
condition|)
block|{
name|log
operator|.
name|trace
argument_list|(
literal|"TLOG: added id "
operator|+
name|cmd
operator|.
name|getPrintableId
argument_list|()
operator|+
literal|" to "
operator|+
name|tlog
operator|+
literal|" "
operator|+
name|ptr
operator|+
literal|" map="
operator|+
name|System
operator|.
name|identityHashCode
argument_list|(
name|map
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// replicate the deleteByQuery logic.  See deleteByQuery for comments.
if|if
condition|(
name|map
operator|!=
literal|null
condition|)
name|map
operator|.
name|clear
argument_list|()
expr_stmt|;
if|if
condition|(
name|prevMap
operator|!=
literal|null
condition|)
name|prevMap
operator|.
name|clear
argument_list|()
expr_stmt|;
if|if
condition|(
name|prevMap2
operator|!=
literal|null
condition|)
name|prevMap2
operator|.
name|clear
argument_list|()
expr_stmt|;
try|try
block|{
name|RefCounted
argument_list|<
name|SolrIndexSearcher
argument_list|>
name|holder
init|=
name|uhandler
operator|.
name|core
operator|.
name|openNewSearcher
argument_list|(
literal|true
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|holder
operator|.
name|decref
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|SolrException
operator|.
name|log
argument_list|(
name|log
argument_list|,
literal|"Error opening realtime searcher for deleteByQuery"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|trace
condition|)
block|{
name|log
operator|.
name|trace
argument_list|(
literal|"TLOG: added id "
operator|+
name|cmd
operator|.
name|getPrintableId
argument_list|()
operator|+
literal|" to "
operator|+
name|tlog
operator|+
literal|" clearCaches=true"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
DECL|method|delete
specifier|public
name|void
name|delete
parameter_list|(
name|DeleteUpdateCommand
name|cmd
parameter_list|)
block|{
name|BytesRef
name|br
init|=
name|cmd
operator|.
name|getIndexedId
argument_list|()
decl_stmt|;
synchronized|synchronized
init|(
name|this
init|)
block|{
name|long
name|pos
init|=
operator|-
literal|1
decl_stmt|;
comment|// don't log if we are replaying from another log
if|if
condition|(
operator|(
name|cmd
operator|.
name|getFlags
argument_list|()
operator|&
name|UpdateCommand
operator|.
name|REPLAY
operator|)
operator|==
literal|0
condition|)
block|{
name|ensureLog
argument_list|()
expr_stmt|;
name|pos
operator|=
name|tlog
operator|.
name|writeDelete
argument_list|(
name|cmd
argument_list|,
name|operationFlags
argument_list|)
expr_stmt|;
block|}
name|LogPtr
name|ptr
init|=
operator|new
name|LogPtr
argument_list|(
name|pos
argument_list|,
name|cmd
operator|.
name|version
argument_list|)
decl_stmt|;
comment|// only update our map if we're not buffering
if|if
condition|(
operator|(
name|cmd
operator|.
name|getFlags
argument_list|()
operator|&
name|UpdateCommand
operator|.
name|BUFFERING
operator|)
operator|==
literal|0
condition|)
block|{
name|map
operator|.
name|put
argument_list|(
name|br
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
name|oldDeletes
operator|.
name|put
argument_list|(
name|br
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|trace
condition|)
block|{
name|log
operator|.
name|trace
argument_list|(
literal|"TLOG: added delete for id "
operator|+
name|cmd
operator|.
name|id
operator|+
literal|" to "
operator|+
name|tlog
operator|+
literal|" "
operator|+
name|ptr
operator|+
literal|" map="
operator|+
name|System
operator|.
name|identityHashCode
argument_list|(
name|map
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|deleteByQuery
specifier|public
name|void
name|deleteByQuery
parameter_list|(
name|DeleteUpdateCommand
name|cmd
parameter_list|)
block|{
synchronized|synchronized
init|(
name|this
init|)
block|{
name|long
name|pos
init|=
operator|-
literal|1
decl_stmt|;
comment|// don't log if we are replaying from another log
if|if
condition|(
operator|(
name|cmd
operator|.
name|getFlags
argument_list|()
operator|&
name|UpdateCommand
operator|.
name|REPLAY
operator|)
operator|==
literal|0
condition|)
block|{
name|ensureLog
argument_list|()
expr_stmt|;
name|pos
operator|=
name|tlog
operator|.
name|writeDeleteByQuery
argument_list|(
name|cmd
argument_list|,
name|operationFlags
argument_list|)
expr_stmt|;
block|}
comment|// only change our caches if we are not buffering
if|if
condition|(
operator|(
name|cmd
operator|.
name|getFlags
argument_list|()
operator|&
name|UpdateCommand
operator|.
name|BUFFERING
operator|)
operator|==
literal|0
condition|)
block|{
comment|// given that we just did a delete-by-query, we don't know what documents were
comment|// affected and hence we must purge our caches.
if|if
condition|(
name|map
operator|!=
literal|null
condition|)
name|map
operator|.
name|clear
argument_list|()
expr_stmt|;
if|if
condition|(
name|prevMap
operator|!=
literal|null
condition|)
name|prevMap
operator|.
name|clear
argument_list|()
expr_stmt|;
if|if
condition|(
name|prevMap2
operator|!=
literal|null
condition|)
name|prevMap2
operator|.
name|clear
argument_list|()
expr_stmt|;
name|trackDeleteByQuery
argument_list|(
name|cmd
operator|.
name|getQuery
argument_list|()
argument_list|,
name|cmd
operator|.
name|getVersion
argument_list|()
argument_list|)
expr_stmt|;
comment|// oldDeletes.clear();
comment|// We must cause a new IndexReader to be opened before anything looks at these caches again
comment|// so that a cache miss will read fresh data.
comment|//
comment|// TODO: FUTURE: open a new searcher lazily for better throughput with delete-by-query commands
try|try
block|{
name|RefCounted
argument_list|<
name|SolrIndexSearcher
argument_list|>
name|holder
init|=
name|uhandler
operator|.
name|core
operator|.
name|openNewSearcher
argument_list|(
literal|true
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|holder
operator|.
name|decref
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|SolrException
operator|.
name|log
argument_list|(
name|log
argument_list|,
literal|"Error opening realtime searcher for deleteByQuery"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
name|LogPtr
name|ptr
init|=
operator|new
name|LogPtr
argument_list|(
name|pos
argument_list|,
name|cmd
operator|.
name|getVersion
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|trace
condition|)
block|{
name|log
operator|.
name|trace
argument_list|(
literal|"TLOG: added deleteByQuery "
operator|+
name|cmd
operator|.
name|query
operator|+
literal|" to "
operator|+
name|tlog
operator|+
literal|" "
operator|+
name|ptr
operator|+
literal|" map="
operator|+
name|System
operator|.
name|identityHashCode
argument_list|(
name|map
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/** currently for testing only */
DECL|method|deleteAll
specifier|public
name|void
name|deleteAll
parameter_list|()
block|{
synchronized|synchronized
init|(
name|this
init|)
block|{
try|try
block|{
name|RefCounted
argument_list|<
name|SolrIndexSearcher
argument_list|>
name|holder
init|=
name|uhandler
operator|.
name|core
operator|.
name|openNewSearcher
argument_list|(
literal|true
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|holder
operator|.
name|decref
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|SolrException
operator|.
name|log
argument_list|(
name|log
argument_list|,
literal|"Error opening realtime searcher for deleteByQuery"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|map
operator|!=
literal|null
condition|)
name|map
operator|.
name|clear
argument_list|()
expr_stmt|;
if|if
condition|(
name|prevMap
operator|!=
literal|null
condition|)
name|prevMap
operator|.
name|clear
argument_list|()
expr_stmt|;
if|if
condition|(
name|prevMap2
operator|!=
literal|null
condition|)
name|prevMap2
operator|.
name|clear
argument_list|()
expr_stmt|;
name|oldDeletes
operator|.
name|clear
argument_list|()
expr_stmt|;
name|deleteByQueries
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|trackDeleteByQuery
name|void
name|trackDeleteByQuery
parameter_list|(
name|String
name|q
parameter_list|,
name|long
name|version
parameter_list|)
block|{
name|version
operator|=
name|Math
operator|.
name|abs
argument_list|(
name|version
argument_list|)
expr_stmt|;
name|DBQ
name|dbq
init|=
operator|new
name|DBQ
argument_list|()
decl_stmt|;
name|dbq
operator|.
name|q
operator|=
name|q
expr_stmt|;
name|dbq
operator|.
name|version
operator|=
name|version
expr_stmt|;
synchronized|synchronized
init|(
name|this
init|)
block|{
if|if
condition|(
name|deleteByQueries
operator|.
name|isEmpty
argument_list|()
operator|||
name|deleteByQueries
operator|.
name|getFirst
argument_list|()
operator|.
name|version
operator|<
name|version
condition|)
block|{
comment|// common non-reordered case
name|deleteByQueries
operator|.
name|addFirst
argument_list|(
name|dbq
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// find correct insertion point
name|ListIterator
argument_list|<
name|DBQ
argument_list|>
name|iter
init|=
name|deleteByQueries
operator|.
name|listIterator
argument_list|()
decl_stmt|;
name|iter
operator|.
name|next
argument_list|()
expr_stmt|;
comment|// we already checked the first element in the previous "if" clause
while|while
condition|(
name|iter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|DBQ
name|oldDBQ
init|=
name|iter
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|oldDBQ
operator|.
name|version
operator|<
name|version
condition|)
block|{
name|iter
operator|.
name|previous
argument_list|()
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|oldDBQ
operator|.
name|version
operator|==
name|version
operator|&&
name|oldDBQ
operator|.
name|q
operator|.
name|equals
argument_list|(
name|q
argument_list|)
condition|)
block|{
comment|// a duplicate
return|return;
block|}
block|}
name|iter
operator|.
name|add
argument_list|(
name|dbq
argument_list|)
expr_stmt|;
comment|// this also handles the case of adding at the end when hasNext() == false
block|}
if|if
condition|(
name|deleteByQueries
operator|.
name|size
argument_list|()
operator|>
name|numDeletesByQueryToKeep
condition|)
block|{
name|deleteByQueries
operator|.
name|removeLast
argument_list|()
expr_stmt|;
block|}
block|}
block|}
DECL|method|getDBQNewer
specifier|public
name|List
argument_list|<
name|DBQ
argument_list|>
name|getDBQNewer
parameter_list|(
name|long
name|version
parameter_list|)
block|{
synchronized|synchronized
init|(
name|this
init|)
block|{
if|if
condition|(
name|deleteByQueries
operator|.
name|isEmpty
argument_list|()
operator|||
name|deleteByQueries
operator|.
name|getFirst
argument_list|()
operator|.
name|version
operator|<
name|version
condition|)
block|{
comment|// fast common case
return|return
literal|null
return|;
block|}
name|List
argument_list|<
name|DBQ
argument_list|>
name|dbqList
init|=
operator|new
name|ArrayList
argument_list|<
name|DBQ
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|DBQ
name|dbq
range|:
name|deleteByQueries
control|)
block|{
if|if
condition|(
name|dbq
operator|.
name|version
operator|<=
name|version
condition|)
break|break;
name|dbqList
operator|.
name|add
argument_list|(
name|dbq
argument_list|)
expr_stmt|;
block|}
return|return
name|dbqList
return|;
block|}
block|}
DECL|method|newMap
specifier|protected
name|void
name|newMap
parameter_list|()
block|{
name|prevMap2
operator|=
name|prevMap
expr_stmt|;
name|prevMapLog2
operator|=
name|prevMapLog
expr_stmt|;
name|prevMap
operator|=
name|map
expr_stmt|;
name|prevMapLog
operator|=
name|tlog
expr_stmt|;
name|map
operator|=
operator|new
name|HashMap
argument_list|<
name|BytesRef
argument_list|,
name|LogPtr
argument_list|>
argument_list|()
expr_stmt|;
block|}
DECL|method|clearOldMaps
specifier|private
name|void
name|clearOldMaps
parameter_list|()
block|{
name|prevMap
operator|=
literal|null
expr_stmt|;
name|prevMap2
operator|=
literal|null
expr_stmt|;
block|}
DECL|method|hasUncommittedChanges
specifier|public
name|boolean
name|hasUncommittedChanges
parameter_list|()
block|{
return|return
name|tlog
operator|!=
literal|null
return|;
block|}
DECL|method|preCommit
specifier|public
name|void
name|preCommit
parameter_list|(
name|CommitUpdateCommand
name|cmd
parameter_list|)
block|{
synchronized|synchronized
init|(
name|this
init|)
block|{
if|if
condition|(
name|debug
condition|)
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"TLOG: preCommit"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|getState
argument_list|()
operator|!=
name|State
operator|.
name|ACTIVE
operator|&&
operator|(
name|cmd
operator|.
name|getFlags
argument_list|()
operator|&
name|UpdateCommand
operator|.
name|REPLAY
operator|)
operator|==
literal|0
condition|)
block|{
comment|// if we aren't in the active state, and this isn't a replay
comment|// from the recovery process, then we shouldn't mess with
comment|// the current transaction log.  This normally shouldn't happen
comment|// as DistributedUpdateProcessor will prevent this.  Commits
comment|// that don't use the processor are possible though.
return|return;
block|}
comment|// since we're changing the log, we must change the map.
name|newMap
argument_list|()
expr_stmt|;
if|if
condition|(
name|prevTlog
operator|!=
literal|null
condition|)
block|{
name|globalStrings
operator|=
name|prevTlog
operator|.
name|getGlobalStrings
argument_list|()
expr_stmt|;
block|}
comment|// since document additions can happen concurrently with commit, create
comment|// a new transaction log first so that we know the old one is definitely
comment|// in the index.
name|prevTlog
operator|=
name|tlog
expr_stmt|;
name|tlog
operator|=
literal|null
expr_stmt|;
name|id
operator|++
expr_stmt|;
block|}
block|}
DECL|method|postCommit
specifier|public
name|void
name|postCommit
parameter_list|(
name|CommitUpdateCommand
name|cmd
parameter_list|)
block|{
synchronized|synchronized
init|(
name|this
init|)
block|{
if|if
condition|(
name|debug
condition|)
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"TLOG: postCommit"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|prevTlog
operator|!=
literal|null
condition|)
block|{
comment|// if we made it through the commit, write a commit command to the log
comment|// TODO: check that this works to cap a tlog we were using to buffer so we don't replay on startup.
name|prevTlog
operator|.
name|writeCommit
argument_list|(
name|cmd
argument_list|,
name|operationFlags
argument_list|)
expr_stmt|;
name|addOldLog
argument_list|(
name|prevTlog
argument_list|,
literal|true
argument_list|)
expr_stmt|;
comment|// the old log list will decref when no longer needed
comment|// prevTlog.decref();
name|prevTlog
operator|=
literal|null
expr_stmt|;
block|}
block|}
block|}
DECL|method|preSoftCommit
specifier|public
name|void
name|preSoftCommit
parameter_list|(
name|CommitUpdateCommand
name|cmd
parameter_list|)
block|{
name|debug
operator|=
name|log
operator|.
name|isDebugEnabled
argument_list|()
expr_stmt|;
comment|// refresh our view of debugging occasionally
name|trace
operator|=
name|log
operator|.
name|isTraceEnabled
argument_list|()
expr_stmt|;
synchronized|synchronized
init|(
name|this
init|)
block|{
if|if
condition|(
operator|!
name|cmd
operator|.
name|softCommit
condition|)
return|return;
comment|// already handled this at the start of the hard commit
name|newMap
argument_list|()
expr_stmt|;
comment|// start adding documents to a new map since we won't know if
comment|// any added documents will make it into this commit or not.
comment|// But we do know that any updates already added will definitely
comment|// show up in the latest reader after the commit succeeds.
name|map
operator|=
operator|new
name|HashMap
argument_list|<
name|BytesRef
argument_list|,
name|LogPtr
argument_list|>
argument_list|()
expr_stmt|;
if|if
condition|(
name|debug
condition|)
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"TLOG: preSoftCommit: prevMap="
operator|+
name|System
operator|.
name|identityHashCode
argument_list|(
name|prevMap
argument_list|)
operator|+
literal|" new map="
operator|+
name|System
operator|.
name|identityHashCode
argument_list|(
name|map
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|postSoftCommit
specifier|public
name|void
name|postSoftCommit
parameter_list|(
name|CommitUpdateCommand
name|cmd
parameter_list|)
block|{
synchronized|synchronized
init|(
name|this
init|)
block|{
comment|// We can clear out all old maps now that a new searcher has been opened.
comment|// This currently only works since DUH2 synchronizes around preCommit to avoid
comment|// it being called in the middle of a preSoftCommit, postSoftCommit sequence.
comment|// If this DUH2 synchronization were to be removed, preSoftCommit should
comment|// record what old maps were created and only remove those.
if|if
condition|(
name|debug
condition|)
block|{
name|SolrCore
operator|.
name|verbose
argument_list|(
literal|"TLOG: postSoftCommit: disposing of prevMap="
operator|+
name|System
operator|.
name|identityHashCode
argument_list|(
name|prevMap
argument_list|)
operator|+
literal|", prevMap2="
operator|+
name|System
operator|.
name|identityHashCode
argument_list|(
name|prevMap2
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|clearOldMaps
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|lookup
specifier|public
name|Object
name|lookup
parameter_list|(
name|BytesRef
name|indexedId
parameter_list|)
block|{
name|LogPtr
name|entry
decl_stmt|;
name|TransactionLog
name|lookupLog
decl_stmt|;
synchronized|synchronized
init|(
name|this
init|)
block|{
name|entry
operator|=
name|map
operator|.
name|get
argument_list|(
name|indexedId
argument_list|)
expr_stmt|;
name|lookupLog
operator|=
name|tlog
expr_stmt|;
comment|// something found in "map" will always be in "tlog"
comment|// SolrCore.verbose("TLOG: lookup: for id ",indexedId.utf8ToString(),"in map",System.identityHashCode(map),"got",entry,"lookupLog=",lookupLog);
if|if
condition|(
name|entry
operator|==
literal|null
operator|&&
name|prevMap
operator|!=
literal|null
condition|)
block|{
name|entry
operator|=
name|prevMap
operator|.
name|get
argument_list|(
name|indexedId
argument_list|)
expr_stmt|;
comment|// something found in prevMap will always be found in preMapLog (which could be tlog or prevTlog)
name|lookupLog
operator|=
name|prevMapLog
expr_stmt|;
comment|// SolrCore.verbose("TLOG: lookup: for id ",indexedId.utf8ToString(),"in prevMap",System.identityHashCode(map),"got",entry,"lookupLog=",lookupLog);
block|}
if|if
condition|(
name|entry
operator|==
literal|null
operator|&&
name|prevMap2
operator|!=
literal|null
condition|)
block|{
name|entry
operator|=
name|prevMap2
operator|.
name|get
argument_list|(
name|indexedId
argument_list|)
expr_stmt|;
comment|// something found in prevMap2 will always be found in preMapLog2 (which could be tlog or prevTlog)
name|lookupLog
operator|=
name|prevMapLog2
expr_stmt|;
comment|// SolrCore.verbose("TLOG: lookup: for id ",indexedId.utf8ToString(),"in prevMap2",System.identityHashCode(map),"got",entry,"lookupLog=",lookupLog);
block|}
if|if
condition|(
name|entry
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|lookupLog
operator|.
name|incref
argument_list|()
expr_stmt|;
block|}
try|try
block|{
comment|// now do the lookup outside of the sync block for concurrency
return|return
name|lookupLog
operator|.
name|lookup
argument_list|(
name|entry
operator|.
name|pointer
argument_list|)
return|;
block|}
finally|finally
block|{
name|lookupLog
operator|.
name|decref
argument_list|()
expr_stmt|;
block|}
block|}
comment|// This method works like realtime-get... it only guarantees to return the latest
comment|// version of the *completed* update.  There can be updates in progress concurrently
comment|// that have already grabbed higher version numbers.  Higher level coordination or
comment|// synchronization is needed for stronger guarantees (as VersionUpdateProcessor does).
DECL|method|lookupVersion
specifier|public
name|Long
name|lookupVersion
parameter_list|(
name|BytesRef
name|indexedId
parameter_list|)
block|{
name|LogPtr
name|entry
decl_stmt|;
name|TransactionLog
name|lookupLog
decl_stmt|;
synchronized|synchronized
init|(
name|this
init|)
block|{
name|entry
operator|=
name|map
operator|.
name|get
argument_list|(
name|indexedId
argument_list|)
expr_stmt|;
name|lookupLog
operator|=
name|tlog
expr_stmt|;
comment|// something found in "map" will always be in "tlog"
comment|// SolrCore.verbose("TLOG: lookup ver: for id ",indexedId.utf8ToString(),"in map",System.identityHashCode(map),"got",entry,"lookupLog=",lookupLog);
if|if
condition|(
name|entry
operator|==
literal|null
operator|&&
name|prevMap
operator|!=
literal|null
condition|)
block|{
name|entry
operator|=
name|prevMap
operator|.
name|get
argument_list|(
name|indexedId
argument_list|)
expr_stmt|;
comment|// something found in prevMap will always be found in preMapLog (which could be tlog or prevTlog)
name|lookupLog
operator|=
name|prevMapLog
expr_stmt|;
comment|// SolrCore.verbose("TLOG: lookup ver: for id ",indexedId.utf8ToString(),"in prevMap",System.identityHashCode(map),"got",entry,"lookupLog=",lookupLog);
block|}
if|if
condition|(
name|entry
operator|==
literal|null
operator|&&
name|prevMap2
operator|!=
literal|null
condition|)
block|{
name|entry
operator|=
name|prevMap2
operator|.
name|get
argument_list|(
name|indexedId
argument_list|)
expr_stmt|;
comment|// something found in prevMap2 will always be found in preMapLog2 (which could be tlog or prevTlog)
name|lookupLog
operator|=
name|prevMapLog2
expr_stmt|;
comment|// SolrCore.verbose("TLOG: lookup ver: for id ",indexedId.utf8ToString(),"in prevMap2",System.identityHashCode(map),"got",entry,"lookupLog=",lookupLog);
block|}
block|}
if|if
condition|(
name|entry
operator|!=
literal|null
condition|)
block|{
return|return
name|entry
operator|.
name|version
return|;
block|}
comment|// Now check real index
name|Long
name|version
init|=
name|versionInfo
operator|.
name|getVersionFromIndex
argument_list|(
name|indexedId
argument_list|)
decl_stmt|;
if|if
condition|(
name|version
operator|!=
literal|null
condition|)
block|{
return|return
name|version
return|;
block|}
comment|// We can't get any version info for deletes from the index, so if the doc
comment|// wasn't found, check a cache of recent deletes.
synchronized|synchronized
init|(
name|this
init|)
block|{
name|entry
operator|=
name|oldDeletes
operator|.
name|get
argument_list|(
name|indexedId
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|entry
operator|!=
literal|null
condition|)
block|{
return|return
name|entry
operator|.
name|version
return|;
block|}
return|return
literal|null
return|;
block|}
DECL|method|finish
specifier|public
name|void
name|finish
parameter_list|(
name|SyncLevel
name|syncLevel
parameter_list|)
block|{
if|if
condition|(
name|syncLevel
operator|==
literal|null
condition|)
block|{
name|syncLevel
operator|=
name|defaultSyncLevel
expr_stmt|;
block|}
if|if
condition|(
name|syncLevel
operator|==
name|SyncLevel
operator|.
name|NONE
condition|)
block|{
return|return;
block|}
name|TransactionLog
name|currLog
decl_stmt|;
synchronized|synchronized
init|(
name|this
init|)
block|{
name|currLog
operator|=
name|tlog
expr_stmt|;
if|if
condition|(
name|currLog
operator|==
literal|null
condition|)
return|return;
name|currLog
operator|.
name|incref
argument_list|()
expr_stmt|;
block|}
try|try
block|{
name|currLog
operator|.
name|finish
argument_list|(
name|syncLevel
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|currLog
operator|.
name|decref
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|recoverFromLog
specifier|public
name|Future
argument_list|<
name|RecoveryInfo
argument_list|>
name|recoverFromLog
parameter_list|()
block|{
name|recoveryInfo
operator|=
operator|new
name|RecoveryInfo
argument_list|()
expr_stmt|;
name|List
argument_list|<
name|TransactionLog
argument_list|>
name|recoverLogs
init|=
operator|new
name|ArrayList
argument_list|<
name|TransactionLog
argument_list|>
argument_list|(
literal|1
argument_list|)
decl_stmt|;
for|for
control|(
name|TransactionLog
name|ll
range|:
name|newestLogsOnStartup
control|)
block|{
if|if
condition|(
operator|!
name|ll
operator|.
name|try_incref
argument_list|()
condition|)
continue|continue;
try|try
block|{
if|if
condition|(
name|ll
operator|.
name|endsWithCommit
argument_list|()
condition|)
block|{
name|ll
operator|.
name|decref
argument_list|()
expr_stmt|;
continue|continue;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"Error inspecting tlog "
operator|+
name|ll
argument_list|)
expr_stmt|;
name|ll
operator|.
name|decref
argument_list|()
expr_stmt|;
continue|continue;
block|}
name|recoverLogs
operator|.
name|add
argument_list|(
name|ll
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|recoverLogs
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
literal|null
return|;
name|ExecutorCompletionService
argument_list|<
name|RecoveryInfo
argument_list|>
name|cs
init|=
operator|new
name|ExecutorCompletionService
argument_list|<
name|RecoveryInfo
argument_list|>
argument_list|(
name|recoveryExecutor
argument_list|)
decl_stmt|;
name|LogReplayer
name|replayer
init|=
operator|new
name|LogReplayer
argument_list|(
name|recoverLogs
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|versionInfo
operator|.
name|blockUpdates
argument_list|()
expr_stmt|;
try|try
block|{
name|state
operator|=
name|State
operator|.
name|REPLAYING
expr_stmt|;
block|}
finally|finally
block|{
name|versionInfo
operator|.
name|unblockUpdates
argument_list|()
expr_stmt|;
block|}
comment|// At this point, we are guaranteed that any new updates coming in will see the state as "replaying"
return|return
name|cs
operator|.
name|submit
argument_list|(
name|replayer
argument_list|,
name|recoveryInfo
argument_list|)
return|;
block|}
DECL|method|ensureLog
specifier|protected
name|void
name|ensureLog
parameter_list|()
block|{
if|if
condition|(
name|tlog
operator|==
literal|null
condition|)
block|{
name|String
name|newLogName
init|=
name|String
operator|.
name|format
argument_list|(
name|Locale
operator|.
name|ROOT
argument_list|,
name|LOG_FILENAME_PATTERN
argument_list|,
name|TLOG_NAME
argument_list|,
name|id
argument_list|)
decl_stmt|;
name|tlog
operator|=
operator|new
name|TransactionLog
argument_list|(
operator|new
name|File
argument_list|(
name|tlogDir
argument_list|,
name|newLogName
argument_list|)
argument_list|,
name|globalStrings
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|doClose
specifier|private
name|void
name|doClose
parameter_list|(
name|TransactionLog
name|theLog
parameter_list|,
name|boolean
name|writeCommit
parameter_list|)
block|{
if|if
condition|(
name|theLog
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|writeCommit
condition|)
block|{
comment|// record a commit
name|log
operator|.
name|info
argument_list|(
literal|"Recording current closed for "
operator|+
name|uhandler
operator|.
name|core
operator|+
literal|" log="
operator|+
name|theLog
argument_list|)
expr_stmt|;
name|CommitUpdateCommand
name|cmd
init|=
operator|new
name|CommitUpdateCommand
argument_list|(
operator|new
name|LocalSolrQueryRequest
argument_list|(
name|uhandler
operator|.
name|core
argument_list|,
operator|new
name|ModifiableSolrParams
argument_list|(
operator|(
name|SolrParams
operator|)
literal|null
argument_list|)
argument_list|)
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|theLog
operator|.
name|writeCommit
argument_list|(
name|cmd
argument_list|,
name|operationFlags
argument_list|)
expr_stmt|;
block|}
name|theLog
operator|.
name|deleteOnClose
operator|=
literal|false
expr_stmt|;
name|theLog
operator|.
name|decref
argument_list|()
expr_stmt|;
name|theLog
operator|.
name|forceClose
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|close
specifier|public
name|void
name|close
parameter_list|(
name|boolean
name|committed
parameter_list|)
block|{
name|close
argument_list|(
name|committed
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
DECL|method|close
specifier|public
name|void
name|close
parameter_list|(
name|boolean
name|committed
parameter_list|,
name|boolean
name|deleteOnClose
parameter_list|)
block|{
synchronized|synchronized
init|(
name|this
init|)
block|{
try|try
block|{
name|ExecutorUtil
operator|.
name|shutdownNowAndAwaitTermination
argument_list|(
name|recoveryExecutor
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|SolrException
operator|.
name|log
argument_list|(
name|log
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
comment|// Don't delete the old tlogs, we want to be able to replay from them and retrieve old versions
name|doClose
argument_list|(
name|prevTlog
argument_list|,
name|committed
argument_list|)
expr_stmt|;
name|doClose
argument_list|(
name|tlog
argument_list|,
name|committed
argument_list|)
expr_stmt|;
for|for
control|(
name|TransactionLog
name|log
range|:
name|logs
control|)
block|{
if|if
condition|(
name|log
operator|==
name|prevTlog
operator|||
name|log
operator|==
name|tlog
condition|)
continue|continue;
name|log
operator|.
name|deleteOnClose
operator|=
literal|false
expr_stmt|;
name|log
operator|.
name|decref
argument_list|()
expr_stmt|;
name|log
operator|.
name|forceClose
argument_list|()
expr_stmt|;
block|}
block|}
block|}
DECL|class|Update
specifier|static
class|class
name|Update
block|{
DECL|field|log
name|TransactionLog
name|log
decl_stmt|;
DECL|field|version
name|long
name|version
decl_stmt|;
DECL|field|pointer
name|long
name|pointer
decl_stmt|;
block|}
DECL|class|DeleteUpdate
specifier|static
class|class
name|DeleteUpdate
block|{
DECL|field|version
name|long
name|version
decl_stmt|;
DECL|field|id
name|byte
index|[]
name|id
decl_stmt|;
DECL|method|DeleteUpdate
specifier|public
name|DeleteUpdate
parameter_list|(
name|long
name|version
parameter_list|,
name|byte
index|[]
name|id
parameter_list|)
block|{
name|this
operator|.
name|version
operator|=
name|version
expr_stmt|;
name|this
operator|.
name|id
operator|=
name|id
expr_stmt|;
block|}
block|}
DECL|class|RecentUpdates
specifier|public
class|class
name|RecentUpdates
block|{
DECL|field|logList
name|Deque
argument_list|<
name|TransactionLog
argument_list|>
name|logList
decl_stmt|;
comment|// newest first
DECL|field|updateList
name|List
argument_list|<
name|List
argument_list|<
name|Update
argument_list|>
argument_list|>
name|updateList
decl_stmt|;
DECL|field|updates
name|HashMap
argument_list|<
name|Long
argument_list|,
name|Update
argument_list|>
name|updates
decl_stmt|;
DECL|field|deleteByQueryList
name|List
argument_list|<
name|Update
argument_list|>
name|deleteByQueryList
decl_stmt|;
DECL|field|deleteList
name|List
argument_list|<
name|DeleteUpdate
argument_list|>
name|deleteList
decl_stmt|;
DECL|field|latestOperation
name|int
name|latestOperation
decl_stmt|;
DECL|method|getVersions
specifier|public
name|List
argument_list|<
name|Long
argument_list|>
name|getVersions
parameter_list|(
name|int
name|n
parameter_list|)
block|{
name|List
argument_list|<
name|Long
argument_list|>
name|ret
init|=
operator|new
name|ArrayList
argument_list|(
name|n
argument_list|)
decl_stmt|;
for|for
control|(
name|List
argument_list|<
name|Update
argument_list|>
name|singleList
range|:
name|updateList
control|)
block|{
for|for
control|(
name|Update
name|ptr
range|:
name|singleList
control|)
block|{
name|ret
operator|.
name|add
argument_list|(
name|ptr
operator|.
name|version
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|n
operator|<=
literal|0
condition|)
return|return
name|ret
return|;
block|}
block|}
return|return
name|ret
return|;
block|}
DECL|method|lookup
specifier|public
name|Object
name|lookup
parameter_list|(
name|long
name|version
parameter_list|)
block|{
name|Update
name|update
init|=
name|updates
operator|.
name|get
argument_list|(
name|version
argument_list|)
decl_stmt|;
if|if
condition|(
name|update
operator|==
literal|null
condition|)
return|return
literal|null
return|;
return|return
name|update
operator|.
name|log
operator|.
name|lookup
argument_list|(
name|update
operator|.
name|pointer
argument_list|)
return|;
block|}
comment|/** Returns the list of deleteByQueries that happened after the given version */
DECL|method|getDeleteByQuery
specifier|public
name|List
argument_list|<
name|Object
argument_list|>
name|getDeleteByQuery
parameter_list|(
name|long
name|afterVersion
parameter_list|)
block|{
name|List
argument_list|<
name|Object
argument_list|>
name|result
init|=
operator|new
name|ArrayList
argument_list|<
name|Object
argument_list|>
argument_list|(
name|deleteByQueryList
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|Update
name|update
range|:
name|deleteByQueryList
control|)
block|{
if|if
condition|(
name|Math
operator|.
name|abs
argument_list|(
name|update
operator|.
name|version
argument_list|)
operator|>
name|afterVersion
condition|)
block|{
name|Object
name|dbq
init|=
name|update
operator|.
name|log
operator|.
name|lookup
argument_list|(
name|update
operator|.
name|pointer
argument_list|)
decl_stmt|;
name|result
operator|.
name|add
argument_list|(
name|dbq
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
DECL|method|getLatestOperation
specifier|public
name|int
name|getLatestOperation
parameter_list|()
block|{
return|return
name|latestOperation
return|;
block|}
DECL|method|update
specifier|private
name|void
name|update
parameter_list|()
block|{
name|int
name|numUpdates
init|=
literal|0
decl_stmt|;
name|updateList
operator|=
operator|new
name|ArrayList
argument_list|<
name|List
argument_list|<
name|Update
argument_list|>
argument_list|>
argument_list|(
name|logList
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|deleteByQueryList
operator|=
operator|new
name|ArrayList
argument_list|<
name|Update
argument_list|>
argument_list|()
expr_stmt|;
name|deleteList
operator|=
operator|new
name|ArrayList
argument_list|<
name|DeleteUpdate
argument_list|>
argument_list|()
expr_stmt|;
name|updates
operator|=
operator|new
name|HashMap
argument_list|<
name|Long
argument_list|,
name|Update
argument_list|>
argument_list|(
name|numRecordsToKeep
argument_list|)
expr_stmt|;
for|for
control|(
name|TransactionLog
name|oldLog
range|:
name|logList
control|)
block|{
name|List
argument_list|<
name|Update
argument_list|>
name|updatesForLog
init|=
operator|new
name|ArrayList
argument_list|<
name|Update
argument_list|>
argument_list|()
decl_stmt|;
name|TransactionLog
operator|.
name|ReverseReader
name|reader
init|=
literal|null
decl_stmt|;
try|try
block|{
name|reader
operator|=
name|oldLog
operator|.
name|getReverseReader
argument_list|()
expr_stmt|;
while|while
condition|(
name|numUpdates
operator|<
name|numRecordsToKeep
condition|)
block|{
name|Object
name|o
init|=
literal|null
decl_stmt|;
try|try
block|{
name|o
operator|=
name|reader
operator|.
name|next
argument_list|()
expr_stmt|;
if|if
condition|(
name|o
operator|==
literal|null
condition|)
break|break;
comment|// should currently be a List<Oper,Ver,Doc/Id>
name|List
name|entry
init|=
operator|(
name|List
operator|)
name|o
decl_stmt|;
comment|// TODO: refactor this out so we get common error handling
name|int
name|opAndFlags
init|=
operator|(
name|Integer
operator|)
name|entry
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|latestOperation
operator|==
literal|0
condition|)
block|{
name|latestOperation
operator|=
name|opAndFlags
expr_stmt|;
block|}
name|int
name|oper
init|=
name|opAndFlags
operator|&
name|UpdateLog
operator|.
name|OPERATION_MASK
decl_stmt|;
name|long
name|version
init|=
operator|(
name|Long
operator|)
name|entry
operator|.
name|get
argument_list|(
literal|1
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|oper
condition|)
block|{
case|case
name|UpdateLog
operator|.
name|ADD
case|:
case|case
name|UpdateLog
operator|.
name|DELETE
case|:
case|case
name|UpdateLog
operator|.
name|DELETE_BY_QUERY
case|:
name|Update
name|update
init|=
operator|new
name|Update
argument_list|()
decl_stmt|;
name|update
operator|.
name|log
operator|=
name|oldLog
expr_stmt|;
name|update
operator|.
name|pointer
operator|=
name|reader
operator|.
name|position
argument_list|()
expr_stmt|;
name|update
operator|.
name|version
operator|=
name|version
expr_stmt|;
name|updatesForLog
operator|.
name|add
argument_list|(
name|update
argument_list|)
expr_stmt|;
name|updates
operator|.
name|put
argument_list|(
name|version
argument_list|,
name|update
argument_list|)
expr_stmt|;
if|if
condition|(
name|oper
operator|==
name|UpdateLog
operator|.
name|DELETE_BY_QUERY
condition|)
block|{
name|deleteByQueryList
operator|.
name|add
argument_list|(
name|update
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|oper
operator|==
name|UpdateLog
operator|.
name|DELETE
condition|)
block|{
name|deleteList
operator|.
name|add
argument_list|(
operator|new
name|DeleteUpdate
argument_list|(
name|version
argument_list|,
operator|(
name|byte
index|[]
operator|)
name|entry
operator|.
name|get
argument_list|(
literal|2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|UpdateLog
operator|.
name|COMMIT
case|:
break|break;
default|default:
throw|throw
operator|new
name|SolrException
argument_list|(
name|SolrException
operator|.
name|ErrorCode
operator|.
name|SERVER_ERROR
argument_list|,
literal|"Unknown Operation! "
operator|+
name|oper
argument_list|)
throw|;
block|}
block|}
catch|catch
parameter_list|(
name|ClassCastException
name|cl
parameter_list|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Unexpected log entry or corrupt log.  Entry="
operator|+
name|o
argument_list|,
name|cl
argument_list|)
expr_stmt|;
comment|// would be caused by a corrupt transaction log
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Exception reverse reading log"
argument_list|,
name|ex
argument_list|)
expr_stmt|;
break|break;
block|}
name|numUpdates
operator|++
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|// failure to read a log record isn't fatal
name|log
operator|.
name|error
argument_list|(
literal|"Exception reading versions from log"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
name|reader
operator|!=
literal|null
condition|)
name|reader
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
name|updateList
operator|.
name|add
argument_list|(
name|updatesForLog
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|close
specifier|public
name|void
name|close
parameter_list|()
block|{
for|for
control|(
name|TransactionLog
name|log
range|:
name|logList
control|)
block|{
name|log
operator|.
name|decref
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/** The RecentUpdates object returned must be closed after use */
DECL|method|getRecentUpdates
specifier|public
name|RecentUpdates
name|getRecentUpdates
parameter_list|()
block|{
name|Deque
argument_list|<
name|TransactionLog
argument_list|>
name|logList
decl_stmt|;
synchronized|synchronized
init|(
name|this
init|)
block|{
name|logList
operator|=
operator|new
name|LinkedList
argument_list|<
name|TransactionLog
argument_list|>
argument_list|(
name|logs
argument_list|)
expr_stmt|;
for|for
control|(
name|TransactionLog
name|log
range|:
name|logList
control|)
block|{
name|log
operator|.
name|incref
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|prevTlog
operator|!=
literal|null
condition|)
block|{
name|prevTlog
operator|.
name|incref
argument_list|()
expr_stmt|;
name|logList
operator|.
name|addFirst
argument_list|(
name|prevTlog
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tlog
operator|!=
literal|null
condition|)
block|{
name|tlog
operator|.
name|incref
argument_list|()
expr_stmt|;
name|logList
operator|.
name|addFirst
argument_list|(
name|tlog
argument_list|)
expr_stmt|;
block|}
block|}
comment|// TODO: what if I hand out a list of updates, then do an update, then hand out another list (and
comment|// one of the updates I originally handed out fell off the list).  Over-request?
name|boolean
name|success
init|=
literal|false
decl_stmt|;
name|RecentUpdates
name|recentUpdates
init|=
literal|null
decl_stmt|;
try|try
block|{
name|recentUpdates
operator|=
operator|new
name|RecentUpdates
argument_list|()
expr_stmt|;
name|recentUpdates
operator|.
name|logList
operator|=
name|logList
expr_stmt|;
name|recentUpdates
operator|.
name|update
argument_list|()
expr_stmt|;
name|success
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
comment|// defensive: if some unknown exception is thrown,
comment|// make sure we close so that the tlogs are decref'd
if|if
condition|(
operator|!
name|success
operator|&&
name|recentUpdates
operator|!=
literal|null
condition|)
block|{
name|recentUpdates
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|recentUpdates
return|;
block|}
DECL|method|bufferUpdates
specifier|public
name|void
name|bufferUpdates
parameter_list|()
block|{
comment|// recovery trips this assert under some race - even when
comment|// it checks the state first
comment|// assert state == State.ACTIVE;
name|recoveryInfo
operator|=
operator|new
name|RecoveryInfo
argument_list|()
expr_stmt|;
comment|// block all updates to eliminate race conditions
comment|// reading state and acting on it in the update processor
name|versionInfo
operator|.
name|blockUpdates
argument_list|()
expr_stmt|;
try|try
block|{
if|if
condition|(
name|state
operator|!=
name|State
operator|.
name|ACTIVE
condition|)
return|return;
if|if
condition|(
name|log
operator|.
name|isInfoEnabled
argument_list|()
condition|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"Starting to buffer updates. "
operator|+
name|this
argument_list|)
expr_stmt|;
block|}
comment|// since we blocked updates, this synchronization shouldn't strictly be necessary.
synchronized|synchronized
init|(
name|this
init|)
block|{
name|recoveryInfo
operator|.
name|positionOfStart
operator|=
name|tlog
operator|==
literal|null
condition|?
literal|0
else|:
name|tlog
operator|.
name|snapshot
argument_list|()
expr_stmt|;
block|}
name|state
operator|=
name|State
operator|.
name|BUFFERING
expr_stmt|;
comment|// currently, buffering is only called by recovery, meaning that there is most likely a gap in updates
name|operationFlags
operator||=
name|FLAG_GAP
expr_stmt|;
block|}
finally|finally
block|{
name|versionInfo
operator|.
name|unblockUpdates
argument_list|()
expr_stmt|;
block|}
block|}
comment|/** Returns true if we were able to drop buffered updates and return to the ACTIVE state */
DECL|method|dropBufferedUpdates
specifier|public
name|boolean
name|dropBufferedUpdates
parameter_list|()
block|{
name|versionInfo
operator|.
name|blockUpdates
argument_list|()
expr_stmt|;
try|try
block|{
if|if
condition|(
name|state
operator|!=
name|State
operator|.
name|BUFFERING
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|log
operator|.
name|isInfoEnabled
argument_list|()
condition|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"Dropping buffered updates "
operator|+
name|this
argument_list|)
expr_stmt|;
block|}
comment|// since we blocked updates, this synchronization shouldn't strictly be necessary.
synchronized|synchronized
init|(
name|this
init|)
block|{
if|if
condition|(
name|tlog
operator|!=
literal|null
condition|)
block|{
name|tlog
operator|.
name|rollback
argument_list|(
name|recoveryInfo
operator|.
name|positionOfStart
argument_list|)
expr_stmt|;
block|}
block|}
name|state
operator|=
name|State
operator|.
name|ACTIVE
expr_stmt|;
name|operationFlags
operator|&=
operator|~
name|FLAG_GAP
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|SolrException
operator|.
name|log
argument_list|(
name|log
argument_list|,
literal|"Error attempting to roll back log"
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
finally|finally
block|{
name|versionInfo
operator|.
name|unblockUpdates
argument_list|()
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
comment|/** Returns the Future to wait on, or null if no replay was needed */
DECL|method|applyBufferedUpdates
specifier|public
name|Future
argument_list|<
name|RecoveryInfo
argument_list|>
name|applyBufferedUpdates
parameter_list|()
block|{
comment|// recovery trips this assert under some race - even when
comment|// it checks the state first
comment|// assert state == State.BUFFERING;
comment|// block all updates to eliminate race conditions
comment|// reading state and acting on it in the update processor
name|versionInfo
operator|.
name|blockUpdates
argument_list|()
expr_stmt|;
try|try
block|{
name|cancelApplyBufferUpdate
operator|=
literal|false
expr_stmt|;
if|if
condition|(
name|state
operator|!=
name|State
operator|.
name|BUFFERING
condition|)
return|return
literal|null
return|;
name|operationFlags
operator|&=
operator|~
name|FLAG_GAP
expr_stmt|;
comment|// handle case when no log was even created because no updates
comment|// were received.
if|if
condition|(
name|tlog
operator|==
literal|null
condition|)
block|{
name|state
operator|=
name|State
operator|.
name|ACTIVE
expr_stmt|;
return|return
literal|null
return|;
block|}
name|tlog
operator|.
name|incref
argument_list|()
expr_stmt|;
name|state
operator|=
name|State
operator|.
name|APPLYING_BUFFERED
expr_stmt|;
block|}
finally|finally
block|{
name|versionInfo
operator|.
name|unblockUpdates
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|recoveryExecutor
operator|.
name|isShutdown
argument_list|()
condition|)
block|{
name|tlog
operator|.
name|decref
argument_list|()
expr_stmt|;
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"executor is not running..."
argument_list|)
throw|;
block|}
name|ExecutorCompletionService
argument_list|<
name|RecoveryInfo
argument_list|>
name|cs
init|=
operator|new
name|ExecutorCompletionService
argument_list|<
name|RecoveryInfo
argument_list|>
argument_list|(
name|recoveryExecutor
argument_list|)
decl_stmt|;
name|LogReplayer
name|replayer
init|=
operator|new
name|LogReplayer
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
operator|new
name|TransactionLog
index|[]
block|{
name|tlog
block|}
argument_list|)
argument_list|,
literal|true
argument_list|)
decl_stmt|;
return|return
name|cs
operator|.
name|submit
argument_list|(
name|replayer
argument_list|,
name|recoveryInfo
argument_list|)
return|;
block|}
DECL|method|getState
specifier|public
name|State
name|getState
parameter_list|()
block|{
return|return
name|state
return|;
block|}
annotation|@
name|Override
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"FSUpdateLog{state="
operator|+
name|getState
argument_list|()
operator|+
literal|", tlog="
operator|+
name|tlog
operator|+
literal|"}"
return|;
block|}
DECL|field|testing_logReplayHook
specifier|public
specifier|static
name|Runnable
name|testing_logReplayHook
decl_stmt|;
comment|// called before each log read
DECL|field|testing_logReplayFinishHook
specifier|public
specifier|static
name|Runnable
name|testing_logReplayFinishHook
decl_stmt|;
comment|// called when log replay has finished
DECL|field|recoveryInfo
specifier|protected
name|RecoveryInfo
name|recoveryInfo
decl_stmt|;
DECL|class|LogReplayer
class|class
name|LogReplayer
implements|implements
name|Runnable
block|{
DECL|field|loglog
specifier|private
name|Logger
name|loglog
init|=
name|log
decl_stmt|;
comment|// set to something different?
DECL|field|translogs
name|Deque
argument_list|<
name|TransactionLog
argument_list|>
name|translogs
decl_stmt|;
DECL|field|tlogReader
name|TransactionLog
operator|.
name|LogReader
name|tlogReader
decl_stmt|;
DECL|field|activeLog
name|boolean
name|activeLog
decl_stmt|;
DECL|field|finishing
name|boolean
name|finishing
init|=
literal|false
decl_stmt|;
comment|// state where we lock out other updates and finish those updates that snuck in before we locked
DECL|field|debug
name|boolean
name|debug
init|=
name|loglog
operator|.
name|isDebugEnabled
argument_list|()
decl_stmt|;
DECL|method|LogReplayer
specifier|public
name|LogReplayer
parameter_list|(
name|List
argument_list|<
name|TransactionLog
argument_list|>
name|translogs
parameter_list|,
name|boolean
name|activeLog
parameter_list|)
block|{
name|this
operator|.
name|translogs
operator|=
operator|new
name|LinkedList
argument_list|<
name|TransactionLog
argument_list|>
argument_list|()
expr_stmt|;
name|this
operator|.
name|translogs
operator|.
name|addAll
argument_list|(
name|translogs
argument_list|)
expr_stmt|;
name|this
operator|.
name|activeLog
operator|=
name|activeLog
expr_stmt|;
block|}
DECL|field|req
specifier|private
name|SolrQueryRequest
name|req
decl_stmt|;
DECL|field|rsp
specifier|private
name|SolrQueryResponse
name|rsp
decl_stmt|;
annotation|@
name|Override
DECL|method|run
specifier|public
name|void
name|run
parameter_list|()
block|{
name|ModifiableSolrParams
name|params
init|=
operator|new
name|ModifiableSolrParams
argument_list|()
decl_stmt|;
name|params
operator|.
name|set
argument_list|(
name|DISTRIB_UPDATE_PARAM
argument_list|,
name|FROMLEADER
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|params
operator|.
name|set
argument_list|(
name|DistributedUpdateProcessor
operator|.
name|LOG_REPLAY
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
name|req
operator|=
operator|new
name|LocalSolrQueryRequest
argument_list|(
name|uhandler
operator|.
name|core
argument_list|,
name|params
argument_list|)
expr_stmt|;
name|rsp
operator|=
operator|new
name|SolrQueryResponse
argument_list|()
expr_stmt|;
name|SolrRequestInfo
operator|.
name|setRequestInfo
argument_list|(
operator|new
name|SolrRequestInfo
argument_list|(
name|req
argument_list|,
name|rsp
argument_list|)
argument_list|)
expr_stmt|;
comment|// setting request info will help logging
try|try
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
name|TransactionLog
name|translog
init|=
name|translogs
operator|.
name|pollFirst
argument_list|()
decl_stmt|;
if|if
condition|(
name|translog
operator|==
literal|null
condition|)
break|break;
name|doReplay
argument_list|(
name|translog
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|SolrException
name|e
parameter_list|)
block|{
if|if
condition|(
name|e
operator|.
name|code
argument_list|()
operator|==
name|ErrorCode
operator|.
name|SERVICE_UNAVAILABLE
operator|.
name|code
condition|)
block|{
name|SolrException
operator|.
name|log
argument_list|(
name|log
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|recoveryInfo
operator|.
name|failed
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|recoveryInfo
operator|.
name|errors
operator|++
expr_stmt|;
name|SolrException
operator|.
name|log
argument_list|(
name|log
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|recoveryInfo
operator|.
name|errors
operator|++
expr_stmt|;
name|SolrException
operator|.
name|log
argument_list|(
name|log
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
comment|// change the state while updates are still blocked to prevent races
name|state
operator|=
name|State
operator|.
name|ACTIVE
expr_stmt|;
if|if
condition|(
name|finishing
condition|)
block|{
name|versionInfo
operator|.
name|unblockUpdates
argument_list|()
expr_stmt|;
block|}
comment|// clean up in case we hit some unexpected exception and didn't get
comment|// to more transaction logs
for|for
control|(
name|TransactionLog
name|translog
range|:
name|translogs
control|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"ERROR: didn't get to recover from tlog "
operator|+
name|translog
argument_list|)
expr_stmt|;
name|translog
operator|.
name|decref
argument_list|()
expr_stmt|;
block|}
block|}
name|loglog
operator|.
name|warn
argument_list|(
literal|"Log replay finished. recoveryInfo="
operator|+
name|recoveryInfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|testing_logReplayFinishHook
operator|!=
literal|null
condition|)
name|testing_logReplayFinishHook
operator|.
name|run
argument_list|()
expr_stmt|;
name|SolrRequestInfo
operator|.
name|clearRequestInfo
argument_list|()
expr_stmt|;
block|}
DECL|method|doReplay
specifier|public
name|void
name|doReplay
parameter_list|(
name|TransactionLog
name|translog
parameter_list|)
block|{
try|try
block|{
name|loglog
operator|.
name|warn
argument_list|(
literal|"Starting log replay "
operator|+
name|translog
operator|+
literal|" active="
operator|+
name|activeLog
operator|+
literal|" starting pos="
operator|+
name|recoveryInfo
operator|.
name|positionOfStart
argument_list|)
expr_stmt|;
name|tlogReader
operator|=
name|translog
operator|.
name|getReader
argument_list|(
name|recoveryInfo
operator|.
name|positionOfStart
argument_list|)
expr_stmt|;
comment|// NOTE: we don't currently handle a core reload during recovery.  This would cause the core
comment|// to change underneath us.
name|UpdateRequestProcessorChain
name|processorChain
init|=
name|req
operator|.
name|getCore
argument_list|()
operator|.
name|getUpdateProcessingChain
argument_list|(
literal|null
argument_list|)
decl_stmt|;
name|UpdateRequestProcessor
name|proc
init|=
name|processorChain
operator|.
name|createProcessor
argument_list|(
name|req
argument_list|,
name|rsp
argument_list|)
decl_stmt|;
name|long
name|commitVersion
init|=
literal|0
decl_stmt|;
name|int
name|operationAndFlags
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|Object
name|o
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|cancelApplyBufferUpdate
condition|)
break|break;
try|try
block|{
if|if
condition|(
name|testing_logReplayHook
operator|!=
literal|null
condition|)
name|testing_logReplayHook
operator|.
name|run
argument_list|()
expr_stmt|;
name|o
operator|=
literal|null
expr_stmt|;
name|o
operator|=
name|tlogReader
operator|.
name|next
argument_list|()
expr_stmt|;
if|if
condition|(
name|o
operator|==
literal|null
operator|&&
name|activeLog
condition|)
block|{
if|if
condition|(
operator|!
name|finishing
condition|)
block|{
comment|// block to prevent new adds, but don't immediately unlock since
comment|// we could be starved from ever completing recovery.  Only unlock
comment|// after we've finished this recovery.
comment|// NOTE: our own updates won't be blocked since the thread holding a write lock can
comment|// lock a read lock.
name|versionInfo
operator|.
name|blockUpdates
argument_list|()
expr_stmt|;
name|finishing
operator|=
literal|true
expr_stmt|;
name|o
operator|=
name|tlogReader
operator|.
name|next
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|// we had previously blocked updates, so this "null" from the log is final.
comment|// Wait until our final commit to change the state and unlock.
comment|// This is only so no new updates are written to the current log file, and is
comment|// only an issue if we crash before the commit (and we are paying attention
comment|// to incomplete log files).
comment|//
comment|// versionInfo.unblockUpdates();
block|}
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|SolrException
operator|.
name|log
argument_list|(
name|log
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|SolrException
operator|.
name|log
argument_list|(
name|log
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|SolrException
operator|.
name|log
argument_list|(
name|log
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|o
operator|==
literal|null
condition|)
break|break;
try|try
block|{
comment|// should currently be a List<Oper,Ver,Doc/Id>
name|List
name|entry
init|=
operator|(
name|List
operator|)
name|o
decl_stmt|;
name|operationAndFlags
operator|=
operator|(
name|Integer
operator|)
name|entry
operator|.
name|get
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|int
name|oper
init|=
name|operationAndFlags
operator|&
name|OPERATION_MASK
decl_stmt|;
name|long
name|version
init|=
operator|(
name|Long
operator|)
name|entry
operator|.
name|get
argument_list|(
literal|1
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|oper
condition|)
block|{
case|case
name|UpdateLog
operator|.
name|ADD
case|:
block|{
name|recoveryInfo
operator|.
name|adds
operator|++
expr_stmt|;
comment|// byte[] idBytes = (byte[]) entry.get(2);
name|SolrInputDocument
name|sdoc
init|=
operator|(
name|SolrInputDocument
operator|)
name|entry
operator|.
name|get
argument_list|(
name|entry
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
decl_stmt|;
name|AddUpdateCommand
name|cmd
init|=
operator|new
name|AddUpdateCommand
argument_list|(
name|req
argument_list|)
decl_stmt|;
comment|// cmd.setIndexedId(new BytesRef(idBytes));
name|cmd
operator|.
name|solrDoc
operator|=
name|sdoc
expr_stmt|;
name|cmd
operator|.
name|setVersion
argument_list|(
name|version
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|setFlags
argument_list|(
name|UpdateCommand
operator|.
name|REPLAY
operator||
name|UpdateCommand
operator|.
name|IGNORE_AUTOCOMMIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|log
operator|.
name|debug
argument_list|(
literal|"add "
operator|+
name|cmd
argument_list|)
expr_stmt|;
name|proc
operator|.
name|processAdd
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|UpdateLog
operator|.
name|DELETE
case|:
block|{
name|recoveryInfo
operator|.
name|deletes
operator|++
expr_stmt|;
name|byte
index|[]
name|idBytes
init|=
operator|(
name|byte
index|[]
operator|)
name|entry
operator|.
name|get
argument_list|(
literal|2
argument_list|)
decl_stmt|;
name|DeleteUpdateCommand
name|cmd
init|=
operator|new
name|DeleteUpdateCommand
argument_list|(
name|req
argument_list|)
decl_stmt|;
name|cmd
operator|.
name|setIndexedId
argument_list|(
operator|new
name|BytesRef
argument_list|(
name|idBytes
argument_list|)
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|setVersion
argument_list|(
name|version
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|setFlags
argument_list|(
name|UpdateCommand
operator|.
name|REPLAY
operator||
name|UpdateCommand
operator|.
name|IGNORE_AUTOCOMMIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|log
operator|.
name|debug
argument_list|(
literal|"delete "
operator|+
name|cmd
argument_list|)
expr_stmt|;
name|proc
operator|.
name|processDelete
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|UpdateLog
operator|.
name|DELETE_BY_QUERY
case|:
block|{
name|recoveryInfo
operator|.
name|deleteByQuery
operator|++
expr_stmt|;
name|String
name|query
init|=
operator|(
name|String
operator|)
name|entry
operator|.
name|get
argument_list|(
literal|2
argument_list|)
decl_stmt|;
name|DeleteUpdateCommand
name|cmd
init|=
operator|new
name|DeleteUpdateCommand
argument_list|(
name|req
argument_list|)
decl_stmt|;
name|cmd
operator|.
name|query
operator|=
name|query
expr_stmt|;
name|cmd
operator|.
name|setVersion
argument_list|(
name|version
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|setFlags
argument_list|(
name|UpdateCommand
operator|.
name|REPLAY
operator||
name|UpdateCommand
operator|.
name|IGNORE_AUTOCOMMIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|log
operator|.
name|debug
argument_list|(
literal|"deleteByQuery "
operator|+
name|cmd
argument_list|)
expr_stmt|;
name|proc
operator|.
name|processDelete
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|UpdateLog
operator|.
name|COMMIT
case|:
block|{
name|commitVersion
operator|=
name|version
expr_stmt|;
break|break;
block|}
default|default:
throw|throw
operator|new
name|SolrException
argument_list|(
name|SolrException
operator|.
name|ErrorCode
operator|.
name|SERVER_ERROR
argument_list|,
literal|"Unknown Operation! "
operator|+
name|oper
argument_list|)
throw|;
block|}
if|if
condition|(
name|rsp
operator|.
name|getException
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|loglog
operator|.
name|error
argument_list|(
literal|"REPLAY_ERR: Exception replaying log"
argument_list|,
name|rsp
operator|.
name|getException
argument_list|()
argument_list|)
expr_stmt|;
throw|throw
name|rsp
operator|.
name|getException
argument_list|()
throw|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
name|recoveryInfo
operator|.
name|errors
operator|++
expr_stmt|;
name|loglog
operator|.
name|warn
argument_list|(
literal|"REYPLAY_ERR: IOException reading log"
argument_list|,
name|ex
argument_list|)
expr_stmt|;
comment|// could be caused by an incomplete flush if recovering from log
block|}
catch|catch
parameter_list|(
name|ClassCastException
name|cl
parameter_list|)
block|{
name|recoveryInfo
operator|.
name|errors
operator|++
expr_stmt|;
name|loglog
operator|.
name|warn
argument_list|(
literal|"REPLAY_ERR: Unexpected log entry or corrupt log.  Entry="
operator|+
name|o
argument_list|,
name|cl
argument_list|)
expr_stmt|;
comment|// would be caused by a corrupt transaction log
block|}
catch|catch
parameter_list|(
name|SolrException
name|ex
parameter_list|)
block|{
if|if
condition|(
name|ex
operator|.
name|code
argument_list|()
operator|==
name|ErrorCode
operator|.
name|SERVICE_UNAVAILABLE
operator|.
name|code
condition|)
block|{
throw|throw
name|ex
throw|;
block|}
name|recoveryInfo
operator|.
name|errors
operator|++
expr_stmt|;
name|loglog
operator|.
name|warn
argument_list|(
literal|"REYPLAY_ERR: IOException reading log"
argument_list|,
name|ex
argument_list|)
expr_stmt|;
comment|// could be caused by an incomplete flush if recovering from log
block|}
catch|catch
parameter_list|(
name|Throwable
name|ex
parameter_list|)
block|{
name|recoveryInfo
operator|.
name|errors
operator|++
expr_stmt|;
name|loglog
operator|.
name|warn
argument_list|(
literal|"REPLAY_ERR: Exception replaying log"
argument_list|,
name|ex
argument_list|)
expr_stmt|;
comment|// something wrong with the request?
block|}
block|}
name|CommitUpdateCommand
name|cmd
init|=
operator|new
name|CommitUpdateCommand
argument_list|(
name|req
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|cmd
operator|.
name|setVersion
argument_list|(
name|commitVersion
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|softCommit
operator|=
literal|false
expr_stmt|;
name|cmd
operator|.
name|waitSearcher
operator|=
literal|true
expr_stmt|;
name|cmd
operator|.
name|setFlags
argument_list|(
name|UpdateCommand
operator|.
name|REPLAY
argument_list|)
expr_stmt|;
try|try
block|{
if|if
condition|(
name|debug
condition|)
name|log
operator|.
name|debug
argument_list|(
literal|"commit "
operator|+
name|cmd
argument_list|)
expr_stmt|;
name|uhandler
operator|.
name|commit
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
comment|// this should cause a commit to be added to the incomplete log and avoid it being replayed again after a restart.
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
name|recoveryInfo
operator|.
name|errors
operator|++
expr_stmt|;
name|loglog
operator|.
name|error
argument_list|(
literal|"Replay exception: final commit."
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|activeLog
condition|)
block|{
comment|// if we are replaying an old tlog file, we need to add a commit to the end
comment|// so we don't replay it again if we restart right after.
comment|// if the last operation we replayed had FLAG_GAP set, we want to use that again so we don't lose it
comment|// as the flag on the last operation.
name|translog
operator|.
name|writeCommit
argument_list|(
name|cmd
argument_list|,
name|operationFlags
operator||
operator|(
name|operationAndFlags
operator|&
operator|~
name|OPERATION_MASK
operator|)
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|proc
operator|.
name|finish
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
name|recoveryInfo
operator|.
name|errors
operator|++
expr_stmt|;
name|loglog
operator|.
name|error
argument_list|(
literal|"Replay exception: finish()"
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
if|if
condition|(
name|tlogReader
operator|!=
literal|null
condition|)
name|tlogReader
operator|.
name|close
argument_list|()
expr_stmt|;
name|translog
operator|.
name|decref
argument_list|()
expr_stmt|;
block|}
block|}
block|}
DECL|method|cancelApplyBufferedUpdates
specifier|public
name|void
name|cancelApplyBufferedUpdates
parameter_list|()
block|{
name|this
operator|.
name|cancelApplyBufferUpdate
operator|=
literal|true
expr_stmt|;
block|}
DECL|field|recoveryExecutor
name|ThreadPoolExecutor
name|recoveryExecutor
init|=
operator|new
name|ThreadPoolExecutor
argument_list|(
literal|0
argument_list|,
name|Integer
operator|.
name|MAX_VALUE
argument_list|,
literal|1
argument_list|,
name|TimeUnit
operator|.
name|SECONDS
argument_list|,
operator|new
name|SynchronousQueue
argument_list|<
name|Runnable
argument_list|>
argument_list|()
argument_list|,
operator|new
name|DefaultSolrThreadFactory
argument_list|(
literal|"recoveryExecutor"
argument_list|)
argument_list|)
decl_stmt|;
DECL|method|deleteFile
specifier|public
specifier|static
name|void
name|deleteFile
parameter_list|(
name|File
name|file
parameter_list|)
block|{
name|boolean
name|success
init|=
literal|false
decl_stmt|;
try|try
block|{
name|success
operator|=
name|file
operator|.
name|delete
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|success
condition|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"Error deleting file: "
operator|+
name|file
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"Error deleting file: "
operator|+
name|file
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|success
condition|)
block|{
try|try
block|{
name|file
operator|.
name|deleteOnExit
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"Error deleting file on exit: "
operator|+
name|file
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|getTlogDir
specifier|protected
name|String
name|getTlogDir
parameter_list|(
name|SolrCore
name|core
parameter_list|,
name|PluginInfo
name|info
parameter_list|)
block|{
name|String
name|dataDir
init|=
operator|(
name|String
operator|)
name|info
operator|.
name|initArgs
operator|.
name|get
argument_list|(
literal|"dir"
argument_list|)
decl_stmt|;
name|String
name|ulogDir
init|=
name|core
operator|.
name|getCoreDescriptor
argument_list|()
operator|.
name|getUlogDir
argument_list|()
decl_stmt|;
if|if
condition|(
name|ulogDir
operator|!=
literal|null
condition|)
block|{
name|dataDir
operator|=
name|ulogDir
expr_stmt|;
block|}
if|if
condition|(
name|dataDir
operator|==
literal|null
operator|||
name|dataDir
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
block|{
name|dataDir
operator|=
name|core
operator|.
name|getDataDir
argument_list|()
expr_stmt|;
block|}
return|return
name|dataDir
operator|+
literal|"/"
operator|+
name|TLOG_NAME
return|;
block|}
comment|/**    * Clears the logs on the file system. Only call before init.    *     * @param core the SolrCore    * @param ulogPluginInfo the init info for the UpdateHandler    */
DECL|method|clearLog
specifier|public
name|void
name|clearLog
parameter_list|(
name|SolrCore
name|core
parameter_list|,
name|PluginInfo
name|ulogPluginInfo
parameter_list|)
block|{
if|if
condition|(
name|ulogPluginInfo
operator|==
literal|null
condition|)
return|return;
name|File
name|tlogDir
init|=
operator|new
name|File
argument_list|(
name|getTlogDir
argument_list|(
name|core
argument_list|,
name|ulogPluginInfo
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|tlogDir
operator|.
name|exists
argument_list|()
condition|)
block|{
name|String
index|[]
name|files
init|=
name|getLogList
argument_list|(
name|tlogDir
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|file
range|:
name|files
control|)
block|{
name|File
name|f
init|=
operator|new
name|File
argument_list|(
name|tlogDir
argument_list|,
name|file
argument_list|)
decl_stmt|;
name|boolean
name|s
init|=
name|f
operator|.
name|delete
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|s
condition|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"Could not remove tlog file:"
operator|+
name|f
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
end_class
end_unit
