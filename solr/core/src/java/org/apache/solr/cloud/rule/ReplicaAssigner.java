begin_unit
begin_package
DECL|package|org.apache.solr.cloud.rule
package|package
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|cloud
operator|.
name|rule
package|;
end_package
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|BitSet
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashMap
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicInteger
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicReference
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|SolrException
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|cloud
operator|.
name|ClusterState
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|cloud
operator|.
name|DocCollection
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|cloud
operator|.
name|Replica
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|cloud
operator|.
name|Slice
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|cloud
operator|.
name|ZkStateReader
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|util
operator|.
name|StrUtils
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|core
operator|.
name|CoreContainer
import|;
end_import
begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import
begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import
begin_import
import|import static
name|java
operator|.
name|util
operator|.
name|Collections
operator|.
name|singletonList
import|;
end_import
begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|cloud
operator|.
name|rule
operator|.
name|Rule
operator|.
name|MatchStatus
operator|.
name|NODE_CAN_BE_ASSIGNED
import|;
end_import
begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|cloud
operator|.
name|rule
operator|.
name|Rule
operator|.
name|Phase
operator|.
name|ASSIGN
import|;
end_import
begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|cloud
operator|.
name|rule
operator|.
name|Rule
operator|.
name|Phase
operator|.
name|FUZZY_ASSIGN
import|;
end_import
begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|cloud
operator|.
name|rule
operator|.
name|Rule
operator|.
name|Phase
operator|.
name|FUZZY_VERIFY
import|;
end_import
begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|cloud
operator|.
name|rule
operator|.
name|Rule
operator|.
name|Phase
operator|.
name|VERIFY
import|;
end_import
begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|util
operator|.
name|StrUtils
operator|.
name|formatString
import|;
end_import
begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|core
operator|.
name|RequestParams
operator|.
name|getDeepCopy
import|;
end_import
begin_class
DECL|class|ReplicaAssigner
specifier|public
class|class
name|ReplicaAssigner
block|{
DECL|field|log
specifier|public
specifier|static
specifier|final
name|Logger
name|log
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|ReplicaAssigner
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|rules
name|List
argument_list|<
name|Rule
argument_list|>
name|rules
decl_stmt|;
DECL|field|shardVsReplicaCount
name|Map
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|shardVsReplicaCount
decl_stmt|;
DECL|field|nodeVsTags
name|Map
argument_list|<
name|String
argument_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
argument_list|>
name|nodeVsTags
decl_stmt|;
DECL|field|shardVsNodes
name|Map
argument_list|<
name|String
argument_list|,
name|HashMap
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
argument_list|>
name|shardVsNodes
decl_stmt|;
DECL|field|liveNodes
name|List
argument_list|<
name|String
argument_list|>
name|liveNodes
decl_stmt|;
DECL|field|tagNames
name|Set
argument_list|<
name|String
argument_list|>
name|tagNames
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
DECL|field|nodeVsCores
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|AtomicInteger
argument_list|>
name|nodeVsCores
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
DECL|class|Position
specifier|public
specifier|static
class|class
name|Position
implements|implements
name|Comparable
argument_list|<
name|Position
argument_list|>
block|{
DECL|field|shard
specifier|public
specifier|final
name|String
name|shard
decl_stmt|;
DECL|field|index
specifier|public
specifier|final
name|int
name|index
decl_stmt|;
DECL|method|Position
specifier|public
name|Position
parameter_list|(
name|String
name|shard
parameter_list|,
name|int
name|replicaIdx
parameter_list|)
block|{
name|this
operator|.
name|shard
operator|=
name|shard
expr_stmt|;
name|this
operator|.
name|index
operator|=
name|replicaIdx
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|compareTo
specifier|public
name|int
name|compareTo
parameter_list|(
name|Position
name|that
parameter_list|)
block|{
comment|//this is to ensure that we try one replica from each shard first instead of
comment|// all replicas from same shard
return|return
name|that
operator|.
name|index
operator|>
name|index
condition|?
operator|-
literal|1
else|:
name|that
operator|.
name|index
operator|==
name|index
condition|?
literal|0
else|:
literal|1
return|;
block|}
annotation|@
name|Override
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|shard
operator|+
literal|":"
operator|+
name|index
return|;
block|}
block|}
comment|/**    * @param shardVsReplicaCount shard names vs no:of replicas required for each of those shards    * @param snitches            snitches details    * @param shardVsNodes        The current state of the system. can be an empty map if no nodes    *                            are created in this collection till now    */
DECL|method|ReplicaAssigner
specifier|public
name|ReplicaAssigner
parameter_list|(
name|List
argument_list|<
name|Rule
argument_list|>
name|rules
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|shardVsReplicaCount
parameter_list|,
name|List
name|snitches
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
argument_list|>
name|shardVsNodes
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|liveNodes
parameter_list|,
name|CoreContainer
name|cc
parameter_list|,
name|ClusterState
name|clusterState
parameter_list|)
block|{
name|this
operator|.
name|rules
operator|=
name|rules
expr_stmt|;
for|for
control|(
name|Rule
name|rule
range|:
name|rules
control|)
name|tagNames
operator|.
name|add
argument_list|(
name|rule
operator|.
name|tag
operator|.
name|name
argument_list|)
expr_stmt|;
name|this
operator|.
name|shardVsReplicaCount
operator|=
name|shardVsReplicaCount
expr_stmt|;
name|this
operator|.
name|liveNodes
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|liveNodes
argument_list|)
expr_stmt|;
name|this
operator|.
name|nodeVsTags
operator|=
name|getTagsForNodes
argument_list|(
name|cc
argument_list|,
name|snitches
argument_list|)
expr_stmt|;
name|this
operator|.
name|shardVsNodes
operator|=
name|getDeepCopy
argument_list|(
name|shardVsNodes
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|validateTags
argument_list|(
name|nodeVsTags
argument_list|)
expr_stmt|;
if|if
condition|(
name|clusterState
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|String
name|s
range|:
name|clusterState
operator|.
name|getCollections
argument_list|()
control|)
block|{
name|DocCollection
name|coll
init|=
name|clusterState
operator|.
name|getCollection
argument_list|(
name|s
argument_list|)
decl_stmt|;
for|for
control|(
name|Slice
name|slice
range|:
name|coll
operator|.
name|getSlices
argument_list|()
control|)
block|{
for|for
control|(
name|Replica
name|replica
range|:
name|slice
operator|.
name|getReplicas
argument_list|()
control|)
block|{
name|AtomicInteger
name|count
init|=
name|nodeVsCores
operator|.
name|get
argument_list|(
name|replica
operator|.
name|getNodeName
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|count
operator|==
literal|null
condition|)
name|nodeVsCores
operator|.
name|put
argument_list|(
name|replica
operator|.
name|getNodeName
argument_list|()
argument_list|,
name|count
operator|=
operator|new
name|AtomicInteger
argument_list|()
argument_list|)
expr_stmt|;
name|count
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
DECL|method|getNodeVsTags
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
argument_list|>
name|getNodeVsTags
parameter_list|()
block|{
return|return
name|nodeVsTags
return|;
block|}
comment|/**    * For each shard return a new set of nodes where the replicas need to be created satisfying    * the specified rule    */
DECL|method|getNodeMappings
specifier|public
name|Map
argument_list|<
name|Position
argument_list|,
name|String
argument_list|>
name|getNodeMappings
parameter_list|()
block|{
name|Map
argument_list|<
name|Position
argument_list|,
name|String
argument_list|>
name|result
init|=
name|getNodeMappings0
argument_list|()
decl_stmt|;
if|if
condition|(
name|result
operator|==
literal|null
condition|)
block|{
name|String
name|msg
init|=
literal|"Could not identify nodes matching the rules "
operator|+
name|rules
decl_stmt|;
if|if
condition|(
operator|!
name|failedNodes
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|failedNodes
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|SnitchContext
argument_list|>
name|e
range|:
name|this
operator|.
name|failedNodes
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|failedNodes
operator|.
name|put
argument_list|(
name|e
operator|.
name|getKey
argument_list|()
argument_list|,
name|e
operator|.
name|getValue
argument_list|()
operator|.
name|getErrMsg
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|msg
operator|+=
literal|" Some nodes where excluded from assigning replicas because tags could not be obtained from them "
operator|+
name|failedNodes
expr_stmt|;
block|}
name|msg
operator|+=
literal|"\n tag values"
operator|+
name|ZkStateReader
operator|.
name|toJSONString
argument_list|(
name|getNodeVsTags
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|shardVsNodes
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|msg
operator|+=
literal|"\nInitial state for the coll : "
operator|+
name|ZkStateReader
operator|.
name|toJSONString
argument_list|(
name|shardVsNodes
argument_list|)
expr_stmt|;
block|}
throw|throw
operator|new
name|SolrException
argument_list|(
name|SolrException
operator|.
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
name|msg
argument_list|)
throw|;
block|}
return|return
name|result
return|;
block|}
DECL|method|getNodeMappings0
name|Map
argument_list|<
name|Position
argument_list|,
name|String
argument_list|>
name|getNodeMappings0
parameter_list|()
block|{
name|List
argument_list|<
name|String
argument_list|>
name|shardNames
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|shardVsReplicaCount
operator|.
name|keySet
argument_list|()
argument_list|)
decl_stmt|;
name|int
index|[]
name|shardOrder
init|=
operator|new
name|int
index|[
name|shardNames
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|shardNames
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
name|shardOrder
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
name|boolean
name|hasFuzzyRules
init|=
literal|false
decl_stmt|;
name|int
name|nonWildCardShardRules
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Rule
name|r
range|:
name|rules
control|)
block|{
if|if
condition|(
name|r
operator|.
name|isFuzzy
argument_list|()
condition|)
name|hasFuzzyRules
operator|=
literal|true
expr_stmt|;
if|if
condition|(
operator|!
name|r
operator|.
name|shard
operator|.
name|isWildCard
argument_list|()
condition|)
block|{
name|nonWildCardShardRules
operator|++
expr_stmt|;
comment|//we will have to try all combinations
if|if
condition|(
name|shardNames
operator|.
name|size
argument_list|()
operator|>
literal|10
condition|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|SolrException
operator|.
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
literal|"Max 10 shards allowed if there is a non wild card shard specified in rule"
argument_list|)
throw|;
block|}
block|}
block|}
name|Map
argument_list|<
name|Position
argument_list|,
name|String
argument_list|>
name|result
init|=
name|tryAllPermutations
argument_list|(
name|shardNames
argument_list|,
name|shardOrder
argument_list|,
name|nonWildCardShardRules
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|==
literal|null
operator|&&
name|hasFuzzyRules
condition|)
block|{
name|result
operator|=
name|tryAllPermutations
argument_list|(
name|shardNames
argument_list|,
name|shardOrder
argument_list|,
name|nonWildCardShardRules
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
DECL|method|tryAllPermutations
specifier|private
name|Map
argument_list|<
name|Position
argument_list|,
name|String
argument_list|>
name|tryAllPermutations
parameter_list|(
name|List
argument_list|<
name|String
argument_list|>
name|shardNames
parameter_list|,
name|int
index|[]
name|shardOrder
parameter_list|,
name|int
name|nonWildCardShardRules
parameter_list|,
name|boolean
name|fuzzyPhase
parameter_list|)
block|{
name|Iterator
argument_list|<
name|int
index|[]
argument_list|>
name|shardPermutations
init|=
name|nonWildCardShardRules
operator|>
literal|0
condition|?
name|permutations
argument_list|(
name|shardNames
operator|.
name|size
argument_list|()
argument_list|)
else|:
name|singletonList
argument_list|(
name|shardOrder
argument_list|)
operator|.
name|iterator
argument_list|()
decl_stmt|;
for|for
control|(
init|;
name|shardPermutations
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|int
index|[]
name|p
init|=
name|shardPermutations
operator|.
name|next
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|p
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|List
argument_list|<
name|Position
argument_list|>
name|positions
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|pos
range|:
name|p
control|)
block|{
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|shardVsReplicaCount
operator|.
name|get
argument_list|(
name|shardNames
operator|.
name|get
argument_list|(
name|pos
argument_list|)
argument_list|)
condition|;
name|j
operator|++
control|)
block|{
name|positions
operator|.
name|add
argument_list|(
operator|new
name|Position
argument_list|(
name|shardNames
operator|.
name|get
argument_list|(
name|pos
argument_list|)
argument_list|,
name|j
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|Collections
operator|.
name|sort
argument_list|(
name|positions
argument_list|)
expr_stmt|;
for|for
control|(
name|Iterator
argument_list|<
name|int
index|[]
argument_list|>
name|it
init|=
name|permutations
argument_list|(
name|rules
operator|.
name|size
argument_list|()
argument_list|)
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|int
index|[]
name|permutation
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|Position
argument_list|,
name|String
argument_list|>
name|result
init|=
name|tryAPermutationOfRules
argument_list|(
name|permutation
argument_list|,
name|positions
argument_list|,
name|fuzzyPhase
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|!=
literal|null
condition|)
return|return
name|result
return|;
block|}
block|}
block|}
return|return
literal|null
return|;
block|}
DECL|method|tryAPermutationOfRules
specifier|private
name|Map
argument_list|<
name|Position
argument_list|,
name|String
argument_list|>
name|tryAPermutationOfRules
parameter_list|(
name|int
index|[]
name|rulePermutation
parameter_list|,
name|List
argument_list|<
name|Position
argument_list|>
name|positions
parameter_list|,
name|boolean
name|fuzzyPhase
parameter_list|)
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
argument_list|>
name|nodeVsTagsCopy
init|=
name|getDeepCopy
argument_list|(
name|nodeVsTags
argument_list|,
literal|2
argument_list|)
decl_stmt|;
name|Map
argument_list|<
name|Position
argument_list|,
name|String
argument_list|>
name|result
init|=
operator|new
name|LinkedHashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|int
name|startPosition
init|=
literal|0
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
argument_list|>
name|copyOfCurrentState
init|=
name|getDeepCopy
argument_list|(
name|shardVsNodes
argument_list|,
literal|2
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|sortedLiveNodes
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|this
operator|.
name|liveNodes
argument_list|)
decl_stmt|;
name|Collections
operator|.
name|sort
argument_list|(
name|sortedLiveNodes
argument_list|,
operator|new
name|Comparator
argument_list|<
name|String
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|int
name|compare
parameter_list|(
name|String
name|n1
parameter_list|,
name|String
name|n2
parameter_list|)
block|{
name|int
name|result
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|rulePermutation
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|Rule
name|rule
init|=
name|rules
operator|.
name|get
argument_list|(
name|rulePermutation
index|[
name|i
index|]
argument_list|)
decl_stmt|;
name|int
name|val
init|=
name|rule
operator|.
name|compare
argument_list|(
name|n1
argument_list|,
name|n2
argument_list|,
name|nodeVsTagsCopy
argument_list|,
name|copyOfCurrentState
argument_list|)
decl_stmt|;
if|if
condition|(
name|val
operator|!=
literal|0
condition|)
block|{
comment|//atleast one non-zero compare break now
name|result
operator|=
name|val
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|result
operator|==
literal|0
condition|)
block|{
comment|//if all else is equal, prefer nodes with fewer cores
name|AtomicInteger
name|n1Count
init|=
name|nodeVsCores
operator|.
name|get
argument_list|(
name|n1
argument_list|)
decl_stmt|;
name|AtomicInteger
name|n2Count
init|=
name|nodeVsCores
operator|.
name|get
argument_list|(
name|n2
argument_list|)
decl_stmt|;
name|int
name|a
init|=
name|n1Count
operator|==
literal|null
condition|?
literal|0
else|:
name|n1Count
operator|.
name|get
argument_list|()
decl_stmt|;
name|int
name|b
init|=
name|n2Count
operator|==
literal|null
condition|?
literal|0
else|:
name|n2Count
operator|.
name|get
argument_list|()
decl_stmt|;
name|result
operator|=
name|a
operator|>
name|b
condition|?
literal|1
else|:
name|a
operator|==
name|b
condition|?
literal|0
else|:
operator|-
literal|1
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
block|}
argument_list|)
expr_stmt|;
name|forEachPosition
label|:
for|for
control|(
name|Position
name|position
range|:
name|positions
control|)
block|{
comment|//trying to assign a node by verifying each rule in this rulePermutation
name|forEachNode
label|:
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|sortedLiveNodes
operator|.
name|size
argument_list|()
condition|;
name|j
operator|++
control|)
block|{
name|String
name|liveNode
init|=
name|sortedLiveNodes
operator|.
name|get
argument_list|(
name|startPosition
operator|%
name|sortedLiveNodes
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
name|startPosition
operator|++
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|rulePermutation
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|Rule
name|rule
init|=
name|rules
operator|.
name|get
argument_list|(
name|rulePermutation
index|[
name|i
index|]
argument_list|)
decl_stmt|;
comment|//trying to assign a replica into this node in this shard
name|Rule
operator|.
name|MatchStatus
name|status
init|=
name|rule
operator|.
name|tryAssignNodeToShard
argument_list|(
name|liveNode
argument_list|,
name|copyOfCurrentState
argument_list|,
name|nodeVsTagsCopy
argument_list|,
name|position
operator|.
name|shard
argument_list|,
name|fuzzyPhase
condition|?
name|FUZZY_ASSIGN
else|:
name|ASSIGN
argument_list|)
decl_stmt|;
if|if
condition|(
name|status
operator|==
name|Rule
operator|.
name|MatchStatus
operator|.
name|CANNOT_ASSIGN_FAIL
condition|)
block|{
continue|continue
name|forEachNode
continue|;
comment|//try another node for this position
block|}
block|}
comment|//We have reached this far means this node can be applied to this position
comment|//and all rules are fine. So let us change the currentState
name|result
operator|.
name|put
argument_list|(
name|position
argument_list|,
name|liveNode
argument_list|)
expr_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|nodeNames
init|=
name|copyOfCurrentState
operator|.
name|get
argument_list|(
name|position
operator|.
name|shard
argument_list|)
decl_stmt|;
if|if
condition|(
name|nodeNames
operator|==
literal|null
condition|)
name|copyOfCurrentState
operator|.
name|put
argument_list|(
name|position
operator|.
name|shard
argument_list|,
name|nodeNames
operator|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
argument_list|)
expr_stmt|;
name|Integer
name|n
init|=
name|nodeNames
operator|.
name|get
argument_list|(
name|liveNode
argument_list|)
decl_stmt|;
name|n
operator|=
name|n
operator|==
literal|null
condition|?
literal|1
else|:
name|n
operator|+
literal|1
expr_stmt|;
name|nodeNames
operator|.
name|put
argument_list|(
name|liveNode
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|Number
name|coreCount
init|=
operator|(
name|Number
operator|)
name|nodeVsTagsCopy
operator|.
name|get
argument_list|(
name|liveNode
argument_list|)
operator|.
name|get
argument_list|(
name|ImplicitSnitch
operator|.
name|CORES
argument_list|)
decl_stmt|;
if|if
condition|(
name|coreCount
operator|!=
literal|null
condition|)
block|{
name|nodeVsTagsCopy
operator|.
name|get
argument_list|(
name|liveNode
argument_list|)
operator|.
name|put
argument_list|(
name|ImplicitSnitch
operator|.
name|CORES
argument_list|,
name|coreCount
operator|.
name|intValue
argument_list|()
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
continue|continue
name|forEachPosition
continue|;
block|}
comment|//if it reached here, we could not find a node for this position
return|return
literal|null
return|;
block|}
if|if
condition|(
name|positions
operator|.
name|size
argument_list|()
operator|>
name|result
operator|.
name|size
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|Position
argument_list|,
name|String
argument_list|>
name|e
range|:
name|result
operator|.
name|entrySet
argument_list|()
control|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|rulePermutation
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|Rule
name|rule
init|=
name|rules
operator|.
name|get
argument_list|(
name|rulePermutation
index|[
name|i
index|]
argument_list|)
decl_stmt|;
name|Rule
operator|.
name|MatchStatus
name|matchStatus
init|=
name|rule
operator|.
name|tryAssignNodeToShard
argument_list|(
name|e
operator|.
name|getValue
argument_list|()
argument_list|,
name|copyOfCurrentState
argument_list|,
name|nodeVsTagsCopy
argument_list|,
name|e
operator|.
name|getKey
argument_list|()
operator|.
name|shard
argument_list|,
name|fuzzyPhase
condition|?
name|FUZZY_VERIFY
else|:
name|VERIFY
argument_list|)
decl_stmt|;
if|if
condition|(
name|matchStatus
operator|!=
name|NODE_CAN_BE_ASSIGNED
condition|)
return|return
literal|null
return|;
block|}
block|}
return|return
name|result
return|;
block|}
DECL|method|validateTags
specifier|private
name|void
name|validateTags
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
argument_list|>
name|nodeVsTags
parameter_list|)
block|{
name|List
argument_list|<
name|String
argument_list|>
name|errors
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|Rule
name|rule
range|:
name|rules
control|)
block|{
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
argument_list|>
name|e
range|:
name|nodeVsTags
operator|.
name|entrySet
argument_list|()
control|)
block|{
if|if
condition|(
name|e
operator|.
name|getValue
argument_list|()
operator|.
name|get
argument_list|(
name|rule
operator|.
name|tag
operator|.
name|name
argument_list|)
operator|==
literal|null
condition|)
block|{
name|errors
operator|.
name|add
argument_list|(
name|formatString
argument_list|(
literal|"The value for tag {0} is not available for node {}"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|errors
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|SolrException
operator|.
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
name|StrUtils
operator|.
name|join
argument_list|(
name|errors
argument_list|,
literal|','
argument_list|)
argument_list|)
throw|;
block|}
block|}
comment|/**    * get all permutations for the int[] whose items are 0..level    */
DECL|method|permutations
specifier|public
specifier|static
name|Iterator
argument_list|<
name|int
index|[]
argument_list|>
name|permutations
parameter_list|(
specifier|final
name|int
name|level
parameter_list|)
block|{
return|return
operator|new
name|Iterator
argument_list|<
name|int
index|[]
argument_list|>
argument_list|()
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
name|int
index|[]
name|next
decl_stmt|;
annotation|@
name|Override
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
name|AtomicReference
argument_list|<
name|int
index|[]
argument_list|>
name|nthval
init|=
operator|new
name|AtomicReference
argument_list|<>
argument_list|()
decl_stmt|;
name|permute
argument_list|(
literal|0
argument_list|,
operator|new
name|int
index|[
name|level
index|]
argument_list|,
operator|new
name|BitSet
argument_list|(
name|level
argument_list|)
argument_list|,
name|nthval
argument_list|,
name|i
argument_list|,
operator|new
name|AtomicInteger
argument_list|()
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
name|next
operator|=
name|nthval
operator|.
name|get
argument_list|()
expr_stmt|;
return|return
name|next
operator|!=
literal|null
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
index|[]
name|next
parameter_list|()
block|{
return|return
name|next
return|;
block|}
block|}
return|;
block|}
DECL|method|permute
specifier|private
specifier|static
name|void
name|permute
parameter_list|(
name|int
name|level
parameter_list|,
name|int
index|[]
name|permuted
parameter_list|,
name|BitSet
name|used
parameter_list|,
name|AtomicReference
argument_list|<
name|int
index|[]
argument_list|>
name|nthval
parameter_list|,
name|int
name|requestedIdx
parameter_list|,
name|AtomicInteger
name|seenSoFar
parameter_list|)
block|{
if|if
condition|(
name|level
operator|==
name|permuted
operator|.
name|length
condition|)
block|{
if|if
condition|(
name|seenSoFar
operator|.
name|get
argument_list|()
operator|==
name|requestedIdx
condition|)
name|nthval
operator|.
name|set
argument_list|(
name|permuted
argument_list|)
expr_stmt|;
else|else
name|seenSoFar
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|permuted
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|used
operator|.
name|get
argument_list|(
name|i
argument_list|)
condition|)
block|{
name|used
operator|.
name|set
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|permuted
index|[
name|level
index|]
operator|=
name|i
expr_stmt|;
name|permute
argument_list|(
name|level
operator|+
literal|1
argument_list|,
name|permuted
argument_list|,
name|used
argument_list|,
name|nthval
argument_list|,
name|requestedIdx
argument_list|,
name|seenSoFar
argument_list|)
expr_stmt|;
if|if
condition|(
name|nthval
operator|.
name|get
argument_list|()
operator|!=
literal|null
condition|)
break|break;
name|used
operator|.
name|set
argument_list|(
name|i
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
DECL|field|failedNodes
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|SnitchContext
argument_list|>
name|failedNodes
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
DECL|class|SnitchInfoImpl
specifier|static
class|class
name|SnitchInfoImpl
extends|extends
name|SnitchContext
operator|.
name|SnitchInfo
block|{
DECL|field|snitch
specifier|final
name|Snitch
name|snitch
decl_stmt|;
DECL|field|myTags
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|myTags
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
DECL|field|nodeVsContext
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|SnitchContext
argument_list|>
name|nodeVsContext
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
DECL|field|cc
specifier|private
specifier|final
name|CoreContainer
name|cc
decl_stmt|;
DECL|method|SnitchInfoImpl
name|SnitchInfoImpl
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|conf
parameter_list|,
name|Snitch
name|snitch
parameter_list|,
name|CoreContainer
name|cc
parameter_list|)
block|{
name|super
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|this
operator|.
name|snitch
operator|=
name|snitch
expr_stmt|;
name|this
operator|.
name|cc
operator|=
name|cc
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|getTagNames
specifier|public
name|Set
argument_list|<
name|String
argument_list|>
name|getTagNames
parameter_list|()
block|{
return|return
name|myTags
return|;
block|}
annotation|@
name|Override
DECL|method|getCoreContainer
specifier|public
name|CoreContainer
name|getCoreContainer
parameter_list|()
block|{
return|return
name|cc
return|;
block|}
block|}
comment|/**    * This method uses the snitches and get the tags for all the nodes    */
DECL|method|getTagsForNodes
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
argument_list|>
name|getTagsForNodes
parameter_list|(
specifier|final
name|CoreContainer
name|cc
parameter_list|,
name|List
name|snitchConf
parameter_list|)
block|{
name|Map
argument_list|<
name|Class
argument_list|,
name|SnitchInfoImpl
argument_list|>
name|snitches
init|=
name|getSnitchInfos
argument_list|(
name|cc
argument_list|,
name|snitchConf
argument_list|)
decl_stmt|;
for|for
control|(
name|Class
name|c
range|:
name|Snitch
operator|.
name|WELL_KNOWN_SNITCHES
control|)
block|{
if|if
condition|(
name|snitches
operator|.
name|containsKey
argument_list|(
name|c
argument_list|)
condition|)
continue|continue;
comment|// it is already specified explicitly , ignore
try|try
block|{
name|snitches
operator|.
name|put
argument_list|(
name|c
argument_list|,
operator|new
name|SnitchInfoImpl
argument_list|(
name|Collections
operator|.
name|EMPTY_MAP
argument_list|,
operator|(
name|Snitch
operator|)
name|c
operator|.
name|newInstance
argument_list|()
argument_list|,
name|cc
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|SolrException
operator|.
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
literal|"Error instantiating Snitch "
operator|+
name|c
operator|.
name|getName
argument_list|()
argument_list|)
throw|;
block|}
block|}
for|for
control|(
name|String
name|tagName
range|:
name|tagNames
control|)
block|{
comment|//identify which snitch is going to provide values for a given tag
name|boolean
name|foundProvider
init|=
literal|false
decl_stmt|;
for|for
control|(
name|SnitchInfoImpl
name|info
range|:
name|snitches
operator|.
name|values
argument_list|()
control|)
block|{
if|if
condition|(
name|info
operator|.
name|snitch
operator|.
name|isKnownTag
argument_list|(
name|tagName
argument_list|)
condition|)
block|{
name|foundProvider
operator|=
literal|true
expr_stmt|;
name|info
operator|.
name|myTags
operator|.
name|add
argument_list|(
name|tagName
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|foundProvider
condition|)
throw|throw
operator|new
name|SolrException
argument_list|(
name|SolrException
operator|.
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
literal|"Unknown tag in rules "
operator|+
name|tagName
argument_list|)
throw|;
block|}
for|for
control|(
name|String
name|node
range|:
name|liveNodes
control|)
block|{
comment|//now use the Snitch to get the tags
for|for
control|(
name|SnitchInfoImpl
name|info
range|:
name|snitches
operator|.
name|values
argument_list|()
control|)
block|{
if|if
condition|(
operator|!
name|info
operator|.
name|myTags
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|SnitchContext
name|context
init|=
operator|new
name|SnitchContext
argument_list|(
name|info
argument_list|,
name|node
argument_list|)
decl_stmt|;
name|info
operator|.
name|nodeVsContext
operator|.
name|put
argument_list|(
name|node
argument_list|,
name|context
argument_list|)
expr_stmt|;
try|try
block|{
name|info
operator|.
name|snitch
operator|.
name|getTags
argument_list|(
name|node
argument_list|,
name|info
operator|.
name|myTags
argument_list|,
name|context
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|context
operator|.
name|exception
operator|=
name|e
expr_stmt|;
block|}
block|}
block|}
block|}
name|Map
argument_list|<
name|String
argument_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
argument_list|>
name|result
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|SnitchInfoImpl
name|info
range|:
name|snitches
operator|.
name|values
argument_list|()
control|)
block|{
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|SnitchContext
argument_list|>
name|e
range|:
name|info
operator|.
name|nodeVsContext
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|SnitchContext
name|context
init|=
name|e
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|String
name|node
init|=
name|e
operator|.
name|getKey
argument_list|()
decl_stmt|;
if|if
condition|(
name|context
operator|.
name|exception
operator|!=
literal|null
condition|)
block|{
name|failedNodes
operator|.
name|put
argument_list|(
name|node
argument_list|,
name|context
argument_list|)
expr_stmt|;
name|liveNodes
operator|.
name|remove
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|log
operator|.
name|warn
argument_list|(
literal|"Not all tags were obtained from node "
operator|+
name|node
argument_list|)
expr_stmt|;
name|context
operator|.
name|exception
operator|=
operator|new
name|SolrException
argument_list|(
name|SolrException
operator|.
name|ErrorCode
operator|.
name|SERVER_ERROR
argument_list|,
literal|"Not all tags were obtained from node "
operator|+
name|node
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|context
operator|.
name|getTags
argument_list|()
operator|.
name|keySet
argument_list|()
operator|.
name|containsAll
argument_list|(
name|context
operator|.
name|snitchInfo
operator|.
name|getTagNames
argument_list|()
argument_list|)
condition|)
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|tags
init|=
name|result
operator|.
name|get
argument_list|(
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
name|tags
operator|==
literal|null
condition|)
block|{
name|tags
operator|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
expr_stmt|;
name|result
operator|.
name|put
argument_list|(
name|node
argument_list|,
name|tags
argument_list|)
expr_stmt|;
block|}
name|tags
operator|.
name|putAll
argument_list|(
name|context
operator|.
name|getTags
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|liveNodes
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|SolrException
operator|.
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
literal|"Could not get all tags for any nodes"
argument_list|)
throw|;
block|}
return|return
name|result
return|;
block|}
DECL|method|verifySnitchConf
specifier|public
specifier|static
name|void
name|verifySnitchConf
parameter_list|(
name|CoreContainer
name|cc
parameter_list|,
name|List
name|snitchConf
parameter_list|)
block|{
name|getSnitchInfos
argument_list|(
name|cc
argument_list|,
name|snitchConf
argument_list|)
expr_stmt|;
block|}
DECL|method|getSnitchInfos
specifier|static
name|Map
argument_list|<
name|Class
argument_list|,
name|SnitchInfoImpl
argument_list|>
name|getSnitchInfos
parameter_list|(
name|CoreContainer
name|cc
parameter_list|,
name|List
name|snitchConf
parameter_list|)
block|{
if|if
condition|(
name|snitchConf
operator|==
literal|null
condition|)
name|snitchConf
operator|=
name|Collections
operator|.
name|emptyList
argument_list|()
expr_stmt|;
name|Map
argument_list|<
name|Class
argument_list|,
name|SnitchInfoImpl
argument_list|>
name|snitches
init|=
operator|new
name|LinkedHashMap
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|Object
name|o
range|:
name|snitchConf
control|)
block|{
comment|//instantiating explicitly specified snitches
name|String
name|klas
init|=
literal|null
decl_stmt|;
name|Map
name|map
init|=
name|Collections
operator|.
name|emptyMap
argument_list|()
decl_stmt|;
if|if
condition|(
name|o
operator|instanceof
name|Map
condition|)
block|{
comment|//it can be a Map
name|map
operator|=
operator|(
name|Map
operator|)
name|o
expr_stmt|;
name|klas
operator|=
operator|(
name|String
operator|)
name|map
operator|.
name|get
argument_list|(
literal|"class"
argument_list|)
expr_stmt|;
if|if
condition|(
name|klas
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|SolrException
operator|.
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
literal|"snitch must have  a class attribute"
argument_list|)
throw|;
block|}
block|}
else|else
block|{
comment|//or just the snitch name
name|klas
operator|=
name|o
operator|.
name|toString
argument_list|()
expr_stmt|;
block|}
try|try
block|{
if|if
condition|(
name|klas
operator|.
name|indexOf
argument_list|(
literal|'.'
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|klas
operator|=
name|Snitch
operator|.
name|class
operator|.
name|getPackage
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|"."
operator|+
name|klas
expr_stmt|;
name|Snitch
name|inst
init|=
name|cc
operator|==
literal|null
condition|?
operator|(
name|Snitch
operator|)
name|Snitch
operator|.
name|class
operator|.
name|getClassLoader
argument_list|()
operator|.
name|loadClass
argument_list|(
name|klas
argument_list|)
operator|.
name|newInstance
argument_list|()
else|:
name|cc
operator|.
name|getResourceLoader
argument_list|()
operator|.
name|newInstance
argument_list|(
name|klas
argument_list|,
name|Snitch
operator|.
name|class
argument_list|)
decl_stmt|;
name|snitches
operator|.
name|put
argument_list|(
name|inst
operator|.
name|getClass
argument_list|()
argument_list|,
operator|new
name|SnitchInfoImpl
argument_list|(
name|map
argument_list|,
name|inst
argument_list|,
name|cc
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|SolrException
operator|.
name|ErrorCode
operator|.
name|SERVER_ERROR
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
return|return
name|snitches
return|;
block|}
block|}
end_class
end_unit
