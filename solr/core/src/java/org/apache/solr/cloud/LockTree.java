begin_unit
begin_package
DECL|package|org.apache.solr.cloud
package|package
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|cloud
package|;
end_package
begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|invoke
operator|.
name|MethodHandles
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedList
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|cloud
operator|.
name|OverseerMessageHandler
operator|.
name|Lock
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|params
operator|.
name|CollectionParams
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|params
operator|.
name|CollectionParams
operator|.
name|LockLevel
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|util
operator|.
name|StrUtils
import|;
end_import
begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import
begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_comment
comment|/**  * This is a utility class that offers fine grained locking for various Collection Operations  * This class is designed for single threaded operation. It's safe for multiple threads to use it  * but internally it is synchronized so that only one thread can perform any operation.  */
end_comment
begin_class
DECL|class|LockTree
specifier|public
class|class
name|LockTree
block|{
DECL|field|LOG
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|MethodHandles
operator|.
name|lookup
argument_list|()
operator|.
name|lookupClass
argument_list|()
argument_list|)
decl_stmt|;
DECL|field|root
specifier|private
specifier|final
name|Node
name|root
init|=
operator|new
name|Node
argument_list|(
literal|null
argument_list|,
name|LockLevel
operator|.
name|CLUSTER
argument_list|,
literal|null
argument_list|)
decl_stmt|;
DECL|method|clear
specifier|public
name|void
name|clear
parameter_list|()
block|{
synchronized|synchronized
init|(
name|this
init|)
block|{
name|root
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
block|}
DECL|class|LockImpl
specifier|private
class|class
name|LockImpl
implements|implements
name|Lock
block|{
DECL|field|node
specifier|final
name|Node
name|node
decl_stmt|;
DECL|method|LockImpl
name|LockImpl
parameter_list|(
name|Node
name|node
parameter_list|)
block|{
name|this
operator|.
name|node
operator|=
name|node
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|unlock
specifier|public
name|void
name|unlock
parameter_list|()
block|{
synchronized|synchronized
init|(
name|LockTree
operator|.
name|this
init|)
block|{
name|node
operator|.
name|unlock
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|StrUtils
operator|.
name|join
argument_list|(
name|node
operator|.
name|constructPath
argument_list|(
operator|new
name|LinkedList
argument_list|<>
argument_list|()
argument_list|)
argument_list|,
literal|'/'
argument_list|)
return|;
block|}
block|}
DECL|class|Session
specifier|public
class|class
name|Session
block|{
DECL|field|root
specifier|private
name|SessionNode
name|root
init|=
operator|new
name|SessionNode
argument_list|(
name|LockLevel
operator|.
name|CLUSTER
argument_list|)
decl_stmt|;
DECL|method|lock
specifier|public
name|Lock
name|lock
parameter_list|(
name|CollectionParams
operator|.
name|CollectionAction
name|action
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|path
parameter_list|)
block|{
synchronized|synchronized
init|(
name|LockTree
operator|.
name|this
init|)
block|{
if|if
condition|(
name|action
operator|.
name|lockLevel
operator|==
name|LockLevel
operator|.
name|NONE
condition|)
return|return
name|FREELOCK
return|;
if|if
condition|(
name|root
operator|.
name|isBusy
argument_list|(
name|action
operator|.
name|lockLevel
argument_list|,
name|path
argument_list|)
condition|)
return|return
literal|null
return|;
name|Lock
name|lockObject
init|=
name|LockTree
operator|.
name|this
operator|.
name|root
operator|.
name|lock
argument_list|(
name|action
operator|.
name|lockLevel
argument_list|,
name|path
argument_list|)
decl_stmt|;
if|if
condition|(
name|lockObject
operator|==
literal|null
condition|)
name|root
operator|.
name|markBusy
argument_list|(
name|path
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|lockObject
return|;
block|}
block|}
block|}
DECL|class|SessionNode
specifier|private
specifier|static
class|class
name|SessionNode
block|{
DECL|field|level
specifier|final
name|LockLevel
name|level
decl_stmt|;
DECL|field|kids
name|Map
argument_list|<
name|String
argument_list|,
name|SessionNode
argument_list|>
name|kids
decl_stmt|;
DECL|field|busy
name|boolean
name|busy
init|=
literal|false
decl_stmt|;
DECL|method|SessionNode
name|SessionNode
parameter_list|(
name|LockLevel
name|level
parameter_list|)
block|{
name|this
operator|.
name|level
operator|=
name|level
expr_stmt|;
block|}
DECL|method|markBusy
name|void
name|markBusy
parameter_list|(
name|List
argument_list|<
name|String
argument_list|>
name|path
parameter_list|,
name|int
name|depth
parameter_list|)
block|{
if|if
condition|(
name|path
operator|.
name|size
argument_list|()
operator|==
name|depth
condition|)
block|{
name|busy
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|String
name|s
init|=
name|path
operator|.
name|get
argument_list|(
name|depth
argument_list|)
decl_stmt|;
if|if
condition|(
name|kids
operator|==
literal|null
condition|)
name|kids
operator|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
expr_stmt|;
name|SessionNode
name|node
init|=
name|kids
operator|.
name|get
argument_list|(
name|s
argument_list|)
decl_stmt|;
if|if
condition|(
name|node
operator|==
literal|null
condition|)
name|kids
operator|.
name|put
argument_list|(
name|s
argument_list|,
name|node
operator|=
operator|new
name|SessionNode
argument_list|(
name|level
operator|.
name|getChild
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|node
operator|.
name|markBusy
argument_list|(
name|path
argument_list|,
name|depth
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|isBusy
name|boolean
name|isBusy
parameter_list|(
name|LockLevel
name|lockLevel
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|path
parameter_list|)
block|{
if|if
condition|(
name|lockLevel
operator|.
name|isHigherOrEqual
argument_list|(
name|level
argument_list|)
condition|)
block|{
if|if
condition|(
name|busy
condition|)
return|return
literal|true
return|;
name|String
name|s
init|=
name|path
operator|.
name|get
argument_list|(
name|level
operator|.
name|level
argument_list|)
decl_stmt|;
if|if
condition|(
name|kids
operator|==
literal|null
operator|||
name|kids
operator|.
name|get
argument_list|(
name|s
argument_list|)
operator|==
literal|null
condition|)
return|return
literal|false
return|;
return|return
name|kids
operator|.
name|get
argument_list|(
name|s
argument_list|)
operator|.
name|isBusy
argument_list|(
name|lockLevel
argument_list|,
name|path
argument_list|)
return|;
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
block|}
block|}
DECL|method|getSession
specifier|public
name|Session
name|getSession
parameter_list|()
block|{
return|return
operator|new
name|Session
argument_list|()
return|;
block|}
DECL|class|Node
specifier|private
class|class
name|Node
block|{
DECL|field|name
specifier|final
name|String
name|name
decl_stmt|;
DECL|field|mom
specifier|final
name|Node
name|mom
decl_stmt|;
DECL|field|level
specifier|final
name|LockLevel
name|level
decl_stmt|;
DECL|field|children
name|HashMap
argument_list|<
name|String
argument_list|,
name|Node
argument_list|>
name|children
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
DECL|field|myLock
name|LockImpl
name|myLock
decl_stmt|;
DECL|method|Node
name|Node
parameter_list|(
name|String
name|name
parameter_list|,
name|LockLevel
name|level
parameter_list|,
name|Node
name|mom
parameter_list|)
block|{
name|this
operator|.
name|name
operator|=
name|name
expr_stmt|;
name|this
operator|.
name|level
operator|=
name|level
expr_stmt|;
name|this
operator|.
name|mom
operator|=
name|mom
expr_stmt|;
block|}
comment|//if this or any of its children are locked
DECL|method|isLocked
name|boolean
name|isLocked
parameter_list|()
block|{
if|if
condition|(
name|myLock
operator|!=
literal|null
condition|)
return|return
literal|true
return|;
for|for
control|(
name|Node
name|node
range|:
name|children
operator|.
name|values
argument_list|()
control|)
if|if
condition|(
name|node
operator|.
name|isLocked
argument_list|()
condition|)
return|return
literal|true
return|;
return|return
literal|false
return|;
block|}
DECL|method|unlock
name|void
name|unlock
parameter_list|(
name|LockImpl
name|lockObject
parameter_list|)
block|{
if|if
condition|(
name|myLock
operator|==
name|lockObject
condition|)
name|myLock
operator|=
literal|null
expr_stmt|;
else|else
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Unlocked multiple times : {}"
argument_list|,
name|lockObject
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|lock
name|Lock
name|lock
parameter_list|(
name|LockLevel
name|lockLevel
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|path
parameter_list|)
block|{
if|if
condition|(
name|myLock
operator|!=
literal|null
condition|)
return|return
literal|null
return|;
comment|//I'm already locked. no need to go any further
if|if
condition|(
name|lockLevel
operator|==
name|level
condition|)
block|{
comment|//lock is supposed to be acquired at this level
comment|//If I am locked or any of my children or grandchildren are locked
comment|// it is not possible to acquire a lock
if|if
condition|(
name|isLocked
argument_list|()
condition|)
return|return
literal|null
return|;
return|return
name|myLock
operator|=
operator|new
name|LockImpl
argument_list|(
name|this
argument_list|)
return|;
block|}
else|else
block|{
name|String
name|childName
init|=
name|path
operator|.
name|get
argument_list|(
name|level
operator|.
name|level
argument_list|)
decl_stmt|;
name|Node
name|child
init|=
name|children
operator|.
name|get
argument_list|(
name|childName
argument_list|)
decl_stmt|;
if|if
condition|(
name|child
operator|==
literal|null
condition|)
name|children
operator|.
name|put
argument_list|(
name|childName
argument_list|,
name|child
operator|=
operator|new
name|Node
argument_list|(
name|childName
argument_list|,
name|LockLevel
operator|.
name|getLevel
argument_list|(
name|level
operator|.
name|level
operator|+
literal|1
argument_list|)
argument_list|,
name|this
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|child
operator|.
name|lock
argument_list|(
name|lockLevel
argument_list|,
name|path
argument_list|)
return|;
block|}
block|}
DECL|method|constructPath
name|LinkedList
argument_list|<
name|String
argument_list|>
name|constructPath
parameter_list|(
name|LinkedList
argument_list|<
name|String
argument_list|>
name|collect
parameter_list|)
block|{
if|if
condition|(
name|name
operator|!=
literal|null
condition|)
name|collect
operator|.
name|addFirst
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|mom
operator|!=
literal|null
condition|)
name|mom
operator|.
name|constructPath
argument_list|(
name|collect
argument_list|)
expr_stmt|;
return|return
name|collect
return|;
block|}
DECL|method|clear
name|void
name|clear
parameter_list|()
block|{
if|if
condition|(
name|myLock
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"lock_is_leaked at"
operator|+
name|constructPath
argument_list|(
operator|new
name|LinkedList
argument_list|<>
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|myLock
operator|=
literal|null
expr_stmt|;
block|}
for|for
control|(
name|Node
name|node
range|:
name|children
operator|.
name|values
argument_list|()
control|)
name|node
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
block|}
DECL|field|FREELOCK
specifier|static
specifier|final
name|Lock
name|FREELOCK
init|=
parameter_list|()
lambda|->
block|{}
decl_stmt|;
block|}
end_class
end_unit
