begin_unit
begin_package
DECL|package|org.apache.solr.cloud
package|package
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|cloud
package|;
end_package
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Closeable
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeMap
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Callable
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ExecutorService
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|client
operator|.
name|solrj
operator|.
name|impl
operator|.
name|HttpSolrServer
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|client
operator|.
name|solrj
operator|.
name|request
operator|.
name|CoreAdminRequest
operator|.
name|Create
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|SolrException
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|cloud
operator|.
name|ClusterState
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|cloud
operator|.
name|ClusterStateUtil
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|cloud
operator|.
name|DocCollection
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|cloud
operator|.
name|Replica
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|cloud
operator|.
name|Slice
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|cloud
operator|.
name|ZkStateReader
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|core
operator|.
name|ConfigSolr
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|update
operator|.
name|UpdateShardHandler
import|;
end_import
begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import
begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import
begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|cache
operator|.
name|Cache
import|;
end_import
begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|cache
operator|.
name|CacheBuilder
import|;
end_import
begin_comment
comment|// TODO: how to tmp exclude nodes?
end_comment
begin_comment
comment|// TODO: more fine grained failover rules?
end_comment
begin_comment
comment|// TODO: test with lots of collections
end_comment
begin_comment
comment|// TODO: add config for only failover if replicas is< N
end_comment
begin_comment
comment|// TODO: general support for non shared filesystems
end_comment
begin_comment
comment|// this is specialized for a shared file system, but it should
end_comment
begin_comment
comment|// not be much work to generalize
end_comment
begin_comment
comment|// NOTE: using replication can slow down failover if a whole
end_comment
begin_comment
comment|// shard is lost.
end_comment
begin_comment
comment|/**  *  * In this simple initial implementation we are limited in how quickly we detect  * a failure by a worst case of roughly zk session timeout + WAIT_AFTER_EXPIRATION_SECONDS + WORK_LOOP_DELAY_MS  * and best case of roughly zk session timeout + WAIT_AFTER_EXPIRATION_SECONDS. Also, consider the time to  * create the SolrCore, do any recovery necessary, and warm up the readers.  *   * NOTE: this will only work with collections created via the collections api because they will have defined  * replicationFactor and maxShardsPerNode.  *   * @lucene.experimental  */
end_comment
begin_class
DECL|class|OverseerAutoReplicaFailoverThread
specifier|public
class|class
name|OverseerAutoReplicaFailoverThread
implements|implements
name|Runnable
implements|,
name|Closeable
block|{
DECL|field|log
specifier|private
specifier|static
name|Logger
name|log
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|OverseerAutoReplicaFailoverThread
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|lastClusterStateVersion
specifier|private
name|Integer
name|lastClusterStateVersion
decl_stmt|;
DECL|field|updateExecutor
specifier|private
specifier|final
name|ExecutorService
name|updateExecutor
decl_stmt|;
DECL|field|isClosed
specifier|private
specifier|volatile
name|boolean
name|isClosed
decl_stmt|;
DECL|field|zkStateReader
specifier|private
name|ZkStateReader
name|zkStateReader
decl_stmt|;
DECL|field|baseUrlForBadNodes
specifier|private
specifier|final
name|Cache
argument_list|<
name|String
argument_list|,
name|Long
argument_list|>
name|baseUrlForBadNodes
decl_stmt|;
DECL|field|workLoopDelay
specifier|private
specifier|final
name|int
name|workLoopDelay
decl_stmt|;
DECL|field|waitAfterExpiration
specifier|private
specifier|final
name|int
name|waitAfterExpiration
decl_stmt|;
DECL|method|OverseerAutoReplicaFailoverThread
specifier|public
name|OverseerAutoReplicaFailoverThread
parameter_list|(
name|ConfigSolr
name|config
parameter_list|,
name|ZkStateReader
name|zkStateReader
parameter_list|,
name|UpdateShardHandler
name|updateShardHandler
parameter_list|)
block|{
name|this
operator|.
name|zkStateReader
operator|=
name|zkStateReader
expr_stmt|;
name|this
operator|.
name|workLoopDelay
operator|=
name|config
operator|.
name|getAutoReplicaFailoverWorkLoopDelay
argument_list|()
expr_stmt|;
name|this
operator|.
name|waitAfterExpiration
operator|=
name|config
operator|.
name|getAutoReplicaFailoverWaitAfterExpiration
argument_list|()
expr_stmt|;
name|int
name|badNodeExpiration
init|=
name|config
operator|.
name|getAutoReplicaFailoverBadNodeExpiration
argument_list|()
decl_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Starting "
operator|+
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|" autoReplicaFailoverWorkLoopDelay={} autoReplicaFailoverWaitAfterExpiration={} autoReplicaFailoverBadNodeExpiration={}"
argument_list|,
name|workLoopDelay
argument_list|,
name|waitAfterExpiration
argument_list|,
name|badNodeExpiration
argument_list|)
expr_stmt|;
name|baseUrlForBadNodes
operator|=
name|CacheBuilder
operator|.
name|newBuilder
argument_list|()
operator|.
name|concurrencyLevel
argument_list|(
literal|1
argument_list|)
operator|.
name|expireAfterWrite
argument_list|(
name|badNodeExpiration
argument_list|,
name|TimeUnit
operator|.
name|MILLISECONDS
argument_list|)
operator|.
name|build
argument_list|()
expr_stmt|;
comment|// TODO: Speed up our work loop when live_nodes changes??
name|updateExecutor
operator|=
name|updateShardHandler
operator|.
name|getUpdateExecutor
argument_list|()
expr_stmt|;
comment|// TODO: perhaps do a health ping periodically to each node (scaryish)
comment|// And/OR work on JIRA issue around self health checks (SOLR-5805)
block|}
annotation|@
name|Override
DECL|method|run
specifier|public
name|void
name|run
parameter_list|()
block|{
while|while
condition|(
operator|!
name|this
operator|.
name|isClosed
condition|)
block|{
comment|// work loop
name|log
operator|.
name|debug
argument_list|(
literal|"do "
operator|+
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|" work loop"
argument_list|)
expr_stmt|;
comment|// every n, look at state and make add / remove calls
try|try
block|{
name|doWork
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|SolrException
operator|.
name|log
argument_list|(
name|log
argument_list|,
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|" had an error it's thread work loop."
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|this
operator|.
name|isClosed
condition|)
block|{
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
name|workLoopDelay
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
DECL|method|doWork
specifier|private
name|void
name|doWork
parameter_list|()
block|{
comment|// TODO: extract to configurable strategy class ??
name|ClusterState
name|clusterState
init|=
name|zkStateReader
operator|.
name|getClusterState
argument_list|()
decl_stmt|;
if|if
condition|(
name|clusterState
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|lastClusterStateVersion
operator|==
name|clusterState
operator|.
name|getZkClusterStateVersion
argument_list|()
operator|&&
name|baseUrlForBadNodes
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
comment|// nothing has changed, no work to do
return|return;
block|}
name|lastClusterStateVersion
operator|=
name|clusterState
operator|.
name|getZkClusterStateVersion
argument_list|()
expr_stmt|;
name|Set
argument_list|<
name|String
argument_list|>
name|collections
init|=
name|clusterState
operator|.
name|getCollections
argument_list|()
decl_stmt|;
for|for
control|(
specifier|final
name|String
name|collection
range|:
name|collections
control|)
block|{
name|DocCollection
name|docCollection
init|=
name|clusterState
operator|.
name|getCollection
argument_list|(
name|collection
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|docCollection
operator|.
name|getAutoAddReplicas
argument_list|()
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|docCollection
operator|.
name|getReplicationFactor
argument_list|()
operator|==
literal|null
condition|)
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"Skipping collection because it has no defined replicationFactor, name={}"
argument_list|,
name|docCollection
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|log
operator|.
name|debug
argument_list|(
literal|"Found collection, name={} replicationFactor="
argument_list|,
name|collection
argument_list|,
name|docCollection
operator|.
name|getReplicationFactor
argument_list|()
argument_list|)
expr_stmt|;
name|Collection
argument_list|<
name|Slice
argument_list|>
name|slices
init|=
name|docCollection
operator|.
name|getSlices
argument_list|()
decl_stmt|;
for|for
control|(
name|Slice
name|slice
range|:
name|slices
control|)
block|{
if|if
condition|(
name|slice
operator|.
name|getState
argument_list|()
operator|.
name|equals
argument_list|(
name|Slice
operator|.
name|ACTIVE
argument_list|)
condition|)
block|{
specifier|final
name|Collection
argument_list|<
name|DownReplica
argument_list|>
name|downReplicas
init|=
operator|new
name|ArrayList
argument_list|<
name|DownReplica
argument_list|>
argument_list|()
decl_stmt|;
name|int
name|goodReplicas
init|=
name|findDownReplicasInSlice
argument_list|(
name|clusterState
argument_list|,
name|docCollection
argument_list|,
name|slice
argument_list|,
name|downReplicas
argument_list|)
decl_stmt|;
name|log
operator|.
name|debug
argument_list|(
literal|"replicationFactor={} goodReplicaCount={}"
argument_list|,
name|docCollection
operator|.
name|getReplicationFactor
argument_list|()
argument_list|,
name|goodReplicas
argument_list|)
expr_stmt|;
if|if
condition|(
name|downReplicas
operator|.
name|size
argument_list|()
operator|>
literal|0
operator|&&
name|goodReplicas
operator|<
name|docCollection
operator|.
name|getReplicationFactor
argument_list|()
condition|)
block|{
comment|// badReplicaMap.put(collection, badReplicas);
name|processBadReplicas
argument_list|(
name|collection
argument_list|,
name|downReplicas
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|goodReplicas
operator|>
name|docCollection
operator|.
name|getReplicationFactor
argument_list|()
condition|)
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"There are too many replicas"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
block|}
DECL|method|processBadReplicas
specifier|private
name|void
name|processBadReplicas
parameter_list|(
specifier|final
name|String
name|collection
parameter_list|,
specifier|final
name|Collection
argument_list|<
name|DownReplica
argument_list|>
name|badReplicas
parameter_list|)
block|{
for|for
control|(
name|DownReplica
name|badReplica
range|:
name|badReplicas
control|)
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"process down replica {}"
argument_list|,
name|badReplica
operator|.
name|replica
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|String
name|baseUrl
init|=
name|badReplica
operator|.
name|replica
operator|.
name|getStr
argument_list|(
name|ZkStateReader
operator|.
name|BASE_URL_PROP
argument_list|)
decl_stmt|;
name|Long
name|wentBadAtNS
init|=
name|baseUrlForBadNodes
operator|.
name|getIfPresent
argument_list|(
name|baseUrl
argument_list|)
decl_stmt|;
if|if
condition|(
name|wentBadAtNS
operator|==
literal|null
condition|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Replica {} may need to failover."
argument_list|,
name|badReplica
operator|.
name|replica
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|baseUrlForBadNodes
operator|.
name|put
argument_list|(
name|baseUrl
argument_list|,
name|System
operator|.
name|nanoTime
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|long
name|elasped
init|=
name|System
operator|.
name|nanoTime
argument_list|()
operator|-
name|wentBadAtNS
decl_stmt|;
if|if
condition|(
name|elasped
operator|<
name|TimeUnit
operator|.
name|NANOSECONDS
operator|.
name|convert
argument_list|(
name|waitAfterExpiration
argument_list|,
name|TimeUnit
operator|.
name|MILLISECONDS
argument_list|)
condition|)
block|{
comment|// protect against ZK 'flapping', startup and shutdown
name|log
operator|.
name|debug
argument_list|(
literal|"Looks troublesome...continue. Elapsed={}"
argument_list|,
name|elasped
operator|+
literal|"ns"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"We need to add a replica. Elapsed={}"
argument_list|,
name|elasped
operator|+
literal|"ns"
argument_list|)
expr_stmt|;
if|if
condition|(
name|addReplica
argument_list|(
name|collection
argument_list|,
name|badReplica
argument_list|)
condition|)
block|{
name|baseUrlForBadNodes
operator|.
name|invalidate
argument_list|(
name|baseUrl
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
DECL|method|addReplica
specifier|private
name|boolean
name|addReplica
parameter_list|(
specifier|final
name|String
name|collection
parameter_list|,
name|DownReplica
name|badReplica
parameter_list|)
block|{
comment|// first find best home - first strategy, sort by number of cores
comment|// hosted where maxCoresPerNode is not violated
specifier|final
name|String
name|createUrl
init|=
name|getBestCreateUrl
argument_list|(
name|zkStateReader
argument_list|,
name|badReplica
argument_list|)
decl_stmt|;
if|if
condition|(
name|createUrl
operator|==
literal|null
condition|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Could not find a node to create new replica on."
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
comment|// NOTE: we send the absolute path, which will slightly change
comment|// behavior of these cores as they won't respond to changes
comment|// in the solr.hdfs.home sys prop as they would have.
specifier|final
name|String
name|dataDir
init|=
name|badReplica
operator|.
name|replica
operator|.
name|getStr
argument_list|(
literal|"dataDir"
argument_list|)
decl_stmt|;
specifier|final
name|String
name|ulogDir
init|=
name|badReplica
operator|.
name|replica
operator|.
name|getStr
argument_list|(
literal|"ulogDir"
argument_list|)
decl_stmt|;
specifier|final
name|String
name|coreNodeName
init|=
name|badReplica
operator|.
name|replica
operator|.
name|getName
argument_list|()
decl_stmt|;
if|if
condition|(
name|dataDir
operator|!=
literal|null
condition|)
block|{
comment|// need an async request - full shard goes down leader election
specifier|final
name|String
name|coreName
init|=
name|badReplica
operator|.
name|replica
operator|.
name|getStr
argument_list|(
name|ZkStateReader
operator|.
name|CORE_NAME_PROP
argument_list|)
decl_stmt|;
name|log
operator|.
name|debug
argument_list|(
literal|"submit call to {}"
argument_list|,
name|createUrl
argument_list|)
expr_stmt|;
name|updateExecutor
operator|.
name|submit
argument_list|(
operator|new
name|Callable
argument_list|<
name|Boolean
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Boolean
name|call
parameter_list|()
block|{
return|return
name|createSolrCore
argument_list|(
name|collection
argument_list|,
name|createUrl
argument_list|,
name|dataDir
argument_list|,
name|ulogDir
argument_list|,
name|coreNodeName
argument_list|,
name|coreName
argument_list|)
return|;
block|}
block|}
argument_list|)
expr_stmt|;
comment|// wait to see state for core we just created
name|boolean
name|success
init|=
name|ClusterStateUtil
operator|.
name|waitToSeeLive
argument_list|(
name|zkStateReader
argument_list|,
name|collection
argument_list|,
name|coreNodeName
argument_list|,
name|createUrl
argument_list|,
literal|30000
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|success
condition|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"Creating new replica appears to have failed, timed out waiting to see created SolrCore register in the clusterstate."
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
name|log
operator|.
name|warn
argument_list|(
literal|"Could not find dataDir or ulogDir in cluster state."
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
DECL|method|findDownReplicasInSlice
specifier|private
specifier|static
name|int
name|findDownReplicasInSlice
parameter_list|(
name|ClusterState
name|clusterState
parameter_list|,
name|DocCollection
name|collection
parameter_list|,
name|Slice
name|slice
parameter_list|,
specifier|final
name|Collection
argument_list|<
name|DownReplica
argument_list|>
name|badReplicas
parameter_list|)
block|{
name|int
name|goodReplicas
init|=
literal|0
decl_stmt|;
name|Collection
argument_list|<
name|Replica
argument_list|>
name|replicas
init|=
name|slice
operator|.
name|getReplicas
argument_list|()
decl_stmt|;
if|if
condition|(
name|replicas
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|Replica
name|replica
range|:
name|replicas
control|)
block|{
comment|// on a live node?
name|boolean
name|live
init|=
name|clusterState
operator|.
name|liveNodesContain
argument_list|(
name|replica
operator|.
name|getNodeName
argument_list|()
argument_list|)
decl_stmt|;
name|String
name|state
init|=
name|replica
operator|.
name|getStr
argument_list|(
name|ZkStateReader
operator|.
name|STATE_PROP
argument_list|)
decl_stmt|;
name|boolean
name|okayState
init|=
operator|(
name|state
operator|.
name|equals
argument_list|(
name|ZkStateReader
operator|.
name|DOWN
argument_list|)
operator|||
name|state
operator|.
name|equals
argument_list|(
name|ZkStateReader
operator|.
name|RECOVERING
argument_list|)
operator|||
name|state
operator|.
name|equals
argument_list|(
name|ZkStateReader
operator|.
name|ACTIVE
argument_list|)
operator|)
decl_stmt|;
name|log
operator|.
name|debug
argument_list|(
literal|"Process replica name={} live={} state={}"
argument_list|,
name|replica
operator|.
name|getName
argument_list|()
argument_list|,
name|live
argument_list|,
name|state
argument_list|)
expr_stmt|;
if|if
condition|(
name|live
operator|&&
name|okayState
condition|)
block|{
name|goodReplicas
operator|++
expr_stmt|;
block|}
else|else
block|{
name|DownReplica
name|badReplica
init|=
operator|new
name|DownReplica
argument_list|()
decl_stmt|;
name|badReplica
operator|.
name|replica
operator|=
name|replica
expr_stmt|;
name|badReplica
operator|.
name|slice
operator|=
name|slice
expr_stmt|;
name|badReplica
operator|.
name|collection
operator|=
name|collection
expr_stmt|;
name|badReplicas
operator|.
name|add
argument_list|(
name|badReplica
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|log
operator|.
name|debug
argument_list|(
literal|"bad replicas for slice {}"
argument_list|,
name|badReplicas
argument_list|)
expr_stmt|;
return|return
name|goodReplicas
return|;
block|}
comment|/**    *     * @return the best node to replace the badReplica on or null if there is no    *         such node    */
DECL|method|getBestCreateUrl
specifier|static
name|String
name|getBestCreateUrl
parameter_list|(
name|ZkStateReader
name|zkStateReader
parameter_list|,
name|DownReplica
name|badReplica
parameter_list|)
block|{
assert|assert
name|badReplica
operator|!=
literal|null
assert|;
assert|assert
name|badReplica
operator|.
name|collection
operator|!=
literal|null
assert|;
assert|assert
name|badReplica
operator|.
name|slice
operator|!=
literal|null
assert|;
name|Map
argument_list|<
name|String
argument_list|,
name|Counts
argument_list|>
name|counts
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|ValueComparator
name|vc
init|=
operator|new
name|ValueComparator
argument_list|(
name|counts
argument_list|)
decl_stmt|;
name|Set
argument_list|<
name|String
argument_list|>
name|liveNodes
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|(
name|zkStateReader
operator|.
name|getClusterState
argument_list|()
operator|.
name|getLiveNodes
argument_list|()
argument_list|)
decl_stmt|;
name|ClusterState
name|clusterState
init|=
name|zkStateReader
operator|.
name|getClusterState
argument_list|()
decl_stmt|;
if|if
condition|(
name|clusterState
operator|!=
literal|null
condition|)
block|{
name|Set
argument_list|<
name|String
argument_list|>
name|collections
init|=
name|clusterState
operator|.
name|getCollections
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|collection
range|:
name|collections
control|)
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"look at collection {} as possible create candidate"
argument_list|,
name|collection
argument_list|)
expr_stmt|;
name|DocCollection
name|docCollection
init|=
name|clusterState
operator|.
name|getCollection
argument_list|(
name|collection
argument_list|)
decl_stmt|;
comment|// TODO - only operate on collections with sharedfs failover = true ??
name|Collection
argument_list|<
name|Slice
argument_list|>
name|slices
init|=
name|docCollection
operator|.
name|getSlices
argument_list|()
decl_stmt|;
for|for
control|(
name|Slice
name|slice
range|:
name|slices
control|)
block|{
comment|// only look at active shards
if|if
condition|(
name|slice
operator|.
name|getState
argument_list|()
operator|.
name|equals
argument_list|(
name|Slice
operator|.
name|ACTIVE
argument_list|)
condition|)
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"look at slice {} as possible create candidate"
argument_list|,
name|slice
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|Collection
argument_list|<
name|Replica
argument_list|>
name|replicas
init|=
name|slice
operator|.
name|getReplicas
argument_list|()
decl_stmt|;
for|for
control|(
name|Replica
name|replica
range|:
name|replicas
control|)
block|{
name|liveNodes
operator|.
name|remove
argument_list|(
name|replica
operator|.
name|getNodeName
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|replica
operator|.
name|getStr
argument_list|(
name|ZkStateReader
operator|.
name|BASE_URL_PROP
argument_list|)
operator|.
name|equals
argument_list|(
name|badReplica
operator|.
name|replica
operator|.
name|getStr
argument_list|(
name|ZkStateReader
operator|.
name|BASE_URL_PROP
argument_list|)
argument_list|)
condition|)
block|{
continue|continue;
block|}
name|String
name|baseUrl
init|=
name|replica
operator|.
name|getStr
argument_list|(
name|ZkStateReader
operator|.
name|BASE_URL_PROP
argument_list|)
decl_stmt|;
comment|// on a live node?
name|log
operator|.
name|debug
argument_list|(
literal|"nodename={} livenodes={}"
argument_list|,
name|replica
operator|.
name|getNodeName
argument_list|()
argument_list|,
name|clusterState
operator|.
name|getLiveNodes
argument_list|()
argument_list|)
expr_stmt|;
name|boolean
name|live
init|=
name|clusterState
operator|.
name|liveNodesContain
argument_list|(
name|replica
operator|.
name|getNodeName
argument_list|()
argument_list|)
decl_stmt|;
name|log
operator|.
name|debug
argument_list|(
literal|"look at replica {} as possible create candidate, live={}"
argument_list|,
name|replica
operator|.
name|getName
argument_list|()
argument_list|,
name|live
argument_list|)
expr_stmt|;
if|if
condition|(
name|live
condition|)
block|{
name|Counts
name|cnt
init|=
name|counts
operator|.
name|get
argument_list|(
name|baseUrl
argument_list|)
decl_stmt|;
if|if
condition|(
name|cnt
operator|==
literal|null
condition|)
block|{
name|cnt
operator|=
operator|new
name|Counts
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|badReplica
operator|.
name|collection
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
name|collection
argument_list|)
condition|)
block|{
name|cnt
operator|.
name|negRankingWeight
operator|+=
literal|3
expr_stmt|;
name|cnt
operator|.
name|collectionShardsOnNode
operator|+=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|cnt
operator|.
name|negRankingWeight
operator|+=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|badReplica
operator|.
name|collection
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
name|collection
argument_list|)
operator|&&
name|badReplica
operator|.
name|slice
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
name|slice
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
block|{
name|cnt
operator|.
name|ourReplicas
operator|++
expr_stmt|;
block|}
comment|// TODO: this is collection wide and we want to take into
comment|// account cluster wide - use new cluster sys prop
name|int
name|maxShardsPerNode
init|=
name|docCollection
operator|.
name|getMaxShardsPerNode
argument_list|()
decl_stmt|;
name|log
operator|.
name|debug
argument_list|(
literal|"max shards per node={} good replicas={}"
argument_list|,
name|maxShardsPerNode
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
name|Collection
argument_list|<
name|Replica
argument_list|>
name|badSliceReplicas
init|=
literal|null
decl_stmt|;
name|DocCollection
name|c
init|=
name|clusterState
operator|.
name|getCollection
argument_list|(
name|badReplica
operator|.
name|collection
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|!=
literal|null
condition|)
block|{
name|Slice
name|s
init|=
name|c
operator|.
name|getSlice
argument_list|(
name|badReplica
operator|.
name|slice
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|s
operator|!=
literal|null
condition|)
block|{
name|badSliceReplicas
operator|=
name|s
operator|.
name|getReplicas
argument_list|()
expr_stmt|;
block|}
block|}
name|boolean
name|alreadyExistsOnNode
init|=
name|replicaAlreadyExistsOnNode
argument_list|(
name|zkStateReader
operator|.
name|getClusterState
argument_list|()
argument_list|,
name|badSliceReplicas
argument_list|,
name|badReplica
argument_list|,
name|baseUrl
argument_list|)
decl_stmt|;
if|if
condition|(
name|alreadyExistsOnNode
operator|||
name|cnt
operator|.
name|collectionShardsOnNode
operator|>=
name|maxShardsPerNode
condition|)
block|{
name|counts
operator|.
name|remove
argument_list|(
name|replica
operator|.
name|getStr
argument_list|(
name|ZkStateReader
operator|.
name|BASE_URL_PROP
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|counts
operator|.
name|put
argument_list|(
name|replica
operator|.
name|getStr
argument_list|(
name|ZkStateReader
operator|.
name|BASE_URL_PROP
argument_list|)
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
block|}
block|}
for|for
control|(
name|String
name|node
range|:
name|liveNodes
control|)
block|{
name|counts
operator|.
name|put
argument_list|(
name|zkStateReader
operator|.
name|getBaseUrlForNodeName
argument_list|(
name|node
argument_list|)
argument_list|,
operator|new
name|Counts
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|counts
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
literal|null
return|;
block|}
name|Map
argument_list|<
name|String
argument_list|,
name|Counts
argument_list|>
name|sortedCounts
init|=
operator|new
name|TreeMap
argument_list|<>
argument_list|(
name|vc
argument_list|)
decl_stmt|;
name|sortedCounts
operator|.
name|putAll
argument_list|(
name|counts
argument_list|)
expr_stmt|;
name|log
operator|.
name|debug
argument_list|(
literal|"empty nodes={}"
argument_list|,
name|liveNodes
argument_list|)
expr_stmt|;
name|log
operator|.
name|debug
argument_list|(
literal|"sorted hosts={}"
argument_list|,
name|sortedCounts
argument_list|)
expr_stmt|;
return|return
name|sortedCounts
operator|.
name|keySet
argument_list|()
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
return|;
block|}
DECL|method|replicaAlreadyExistsOnNode
specifier|private
specifier|static
name|boolean
name|replicaAlreadyExistsOnNode
parameter_list|(
name|ClusterState
name|clusterState
parameter_list|,
name|Collection
argument_list|<
name|Replica
argument_list|>
name|replicas
parameter_list|,
name|DownReplica
name|badReplica
parameter_list|,
name|String
name|baseUrl
parameter_list|)
block|{
if|if
condition|(
name|replicas
operator|!=
literal|null
condition|)
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"check if replica already exists on node using replicas {}"
argument_list|,
name|getNames
argument_list|(
name|replicas
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|Replica
name|replica
range|:
name|replicas
control|)
block|{
if|if
condition|(
operator|!
name|replica
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
name|badReplica
operator|.
name|replica
operator|.
name|getName
argument_list|()
argument_list|)
operator|&&
name|replica
operator|.
name|getStr
argument_list|(
name|ZkStateReader
operator|.
name|BASE_URL_PROP
argument_list|)
operator|.
name|equals
argument_list|(
name|baseUrl
argument_list|)
operator|&&
name|clusterState
operator|.
name|liveNodesContain
argument_list|(
name|replica
operator|.
name|getNodeName
argument_list|()
argument_list|)
operator|&&
operator|(
name|replica
operator|.
name|getStr
argument_list|(
name|ZkStateReader
operator|.
name|STATE_PROP
argument_list|)
operator|.
name|equals
argument_list|(
name|ZkStateReader
operator|.
name|ACTIVE
argument_list|)
operator|||
name|replica
operator|.
name|getStr
argument_list|(
name|ZkStateReader
operator|.
name|STATE_PROP
argument_list|)
operator|.
name|equals
argument_list|(
name|ZkStateReader
operator|.
name|DOWN
argument_list|)
operator|||
name|replica
operator|.
name|getStr
argument_list|(
name|ZkStateReader
operator|.
name|STATE_PROP
argument_list|)
operator|.
name|equals
argument_list|(
name|ZkStateReader
operator|.
name|RECOVERING
argument_list|)
operator|)
condition|)
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"replica already exists on node, bad replica={}, existing replica={}, node name={}"
argument_list|,
name|badReplica
operator|.
name|replica
operator|.
name|getName
argument_list|()
argument_list|,
name|replica
operator|.
name|getName
argument_list|()
argument_list|,
name|replica
operator|.
name|getNodeName
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
block|}
name|log
operator|.
name|debug
argument_list|(
literal|"replica does not yet exist on node: {}"
argument_list|,
name|baseUrl
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
DECL|method|getNames
specifier|private
specifier|static
name|Object
name|getNames
parameter_list|(
name|Collection
argument_list|<
name|Replica
argument_list|>
name|replicas
parameter_list|)
block|{
name|Set
argument_list|<
name|String
argument_list|>
name|names
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|(
name|replicas
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|Replica
name|replica
range|:
name|replicas
control|)
block|{
name|names
operator|.
name|add
argument_list|(
name|replica
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|names
return|;
block|}
DECL|method|createSolrCore
specifier|private
name|boolean
name|createSolrCore
parameter_list|(
specifier|final
name|String
name|collection
parameter_list|,
specifier|final
name|String
name|createUrl
parameter_list|,
specifier|final
name|String
name|dataDir
parameter_list|,
specifier|final
name|String
name|ulogDir
parameter_list|,
specifier|final
name|String
name|coreNodeName
parameter_list|,
specifier|final
name|String
name|coreName
parameter_list|)
block|{
name|HttpSolrServer
name|server
init|=
literal|null
decl_stmt|;
try|try
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"create url={}"
argument_list|,
name|createUrl
argument_list|)
expr_stmt|;
name|server
operator|=
operator|new
name|HttpSolrServer
argument_list|(
name|createUrl
argument_list|)
expr_stmt|;
name|server
operator|.
name|setConnectionTimeout
argument_list|(
literal|30000
argument_list|)
expr_stmt|;
name|server
operator|.
name|setSoTimeout
argument_list|(
literal|60000
argument_list|)
expr_stmt|;
name|Create
name|createCmd
init|=
operator|new
name|Create
argument_list|()
decl_stmt|;
name|createCmd
operator|.
name|setCollection
argument_list|(
name|collection
argument_list|)
expr_stmt|;
name|createCmd
operator|.
name|setCoreNodeName
argument_list|(
name|coreNodeName
argument_list|)
expr_stmt|;
comment|// TODO: how do we ensure unique coreName
comment|// for now, the collections API will use unique names
name|createCmd
operator|.
name|setCoreName
argument_list|(
name|coreName
argument_list|)
expr_stmt|;
name|createCmd
operator|.
name|setDataDir
argument_list|(
name|dataDir
argument_list|)
expr_stmt|;
name|createCmd
operator|.
name|setUlogDir
argument_list|(
name|ulogDir
argument_list|)
expr_stmt|;
name|server
operator|.
name|request
argument_list|(
name|createCmd
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|SolrException
operator|.
name|log
argument_list|(
name|log
argument_list|,
literal|"Exception trying to create new replica on "
operator|+
name|createUrl
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
finally|finally
block|{
if|if
condition|(
name|server
operator|!=
literal|null
condition|)
block|{
name|server
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
block|}
return|return
literal|true
return|;
block|}
DECL|class|ValueComparator
specifier|private
specifier|static
class|class
name|ValueComparator
implements|implements
name|Comparator
argument_list|<
name|String
argument_list|>
block|{
DECL|field|map
name|Map
argument_list|<
name|String
argument_list|,
name|Counts
argument_list|>
name|map
decl_stmt|;
DECL|method|ValueComparator
specifier|public
name|ValueComparator
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|Counts
argument_list|>
name|map
parameter_list|)
block|{
name|this
operator|.
name|map
operator|=
name|map
expr_stmt|;
block|}
DECL|method|compare
specifier|public
name|int
name|compare
parameter_list|(
name|String
name|a
parameter_list|,
name|String
name|b
parameter_list|)
block|{
if|if
condition|(
name|map
operator|.
name|get
argument_list|(
name|a
argument_list|)
operator|.
name|negRankingWeight
operator|>=
name|map
operator|.
name|get
argument_list|(
name|b
argument_list|)
operator|.
name|negRankingWeight
condition|)
block|{
return|return
literal|1
return|;
block|}
else|else
block|{
return|return
operator|-
literal|1
return|;
block|}
block|}
block|}
annotation|@
name|Override
DECL|method|close
specifier|public
name|void
name|close
parameter_list|()
block|{
name|isClosed
operator|=
literal|true
expr_stmt|;
block|}
DECL|method|isClosed
specifier|public
name|boolean
name|isClosed
parameter_list|()
block|{
return|return
name|isClosed
return|;
block|}
DECL|class|Counts
specifier|private
specifier|static
class|class
name|Counts
block|{
DECL|field|collectionShardsOnNode
name|int
name|collectionShardsOnNode
init|=
literal|0
decl_stmt|;
DECL|field|negRankingWeight
name|int
name|negRankingWeight
init|=
literal|0
decl_stmt|;
DECL|field|ourReplicas
name|int
name|ourReplicas
init|=
literal|0
decl_stmt|;
DECL|method|Counts
specifier|private
name|Counts
parameter_list|()
block|{            }
DECL|method|Counts
specifier|private
name|Counts
parameter_list|(
name|int
name|totalReplicas
parameter_list|,
name|int
name|ourReplicas
parameter_list|)
block|{
name|this
operator|.
name|negRankingWeight
operator|=
name|totalReplicas
expr_stmt|;
name|this
operator|.
name|ourReplicas
operator|=
name|ourReplicas
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"Counts [negRankingWeight="
operator|+
name|negRankingWeight
operator|+
literal|", sameSliceCount="
operator|+
name|ourReplicas
operator|+
literal|"]"
return|;
block|}
block|}
DECL|class|DownReplica
specifier|static
class|class
name|DownReplica
block|{
DECL|field|replica
name|Replica
name|replica
decl_stmt|;
DECL|field|slice
name|Slice
name|slice
decl_stmt|;
DECL|field|collection
name|DocCollection
name|collection
decl_stmt|;
annotation|@
name|Override
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"DownReplica [replica="
operator|+
name|replica
operator|.
name|getName
argument_list|()
operator|+
literal|", slice="
operator|+
name|slice
operator|.
name|getName
argument_list|()
operator|+
literal|", collection="
operator|+
name|collection
operator|.
name|getName
argument_list|()
operator|+
literal|"]"
return|;
block|}
block|}
block|}
end_class
end_unit
