begin_unit
begin_package
DECL|package|org.apache.solr.cloud
package|package
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|cloud
package|;
end_package
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements. See the NOTICE file distributed with this  * work for additional information regarding copyright ownership. The ASF  * licenses this file to You under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *   * http://www.apache.org/licenses/LICENSE-2.0  *   * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT  * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the  * License for the specific language governing permissions and limitations under  * the License.  */
end_comment
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Closeable
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedList
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ListIterator
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Locale
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Random
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentHashMap
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicInteger
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|lang
operator|.
name|StringUtils
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|client
operator|.
name|solrj
operator|.
name|SolrResponse
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|cloud
operator|.
name|overseer
operator|.
name|ClusterStateMutator
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|cloud
operator|.
name|overseer
operator|.
name|CollectionMutator
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|cloud
operator|.
name|overseer
operator|.
name|OverseerAction
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|cloud
operator|.
name|overseer
operator|.
name|ReplicaMutator
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|cloud
operator|.
name|overseer
operator|.
name|SliceMutator
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|cloud
operator|.
name|overseer
operator|.
name|ZkStateWriter
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|cloud
operator|.
name|overseer
operator|.
name|ZkWriteCommand
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|SolrException
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|cloud
operator|.
name|ClusterState
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|cloud
operator|.
name|DocCollection
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|cloud
operator|.
name|Replica
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|cloud
operator|.
name|Slice
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|cloud
operator|.
name|SolrZkClient
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|cloud
operator|.
name|ZkNodeProps
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|cloud
operator|.
name|ZkStateReader
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|params
operator|.
name|CollectionParams
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|util
operator|.
name|IOUtils
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|util
operator|.
name|Utils
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|core
operator|.
name|CloudConfig
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|handler
operator|.
name|admin
operator|.
name|CollectionsHandler
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|handler
operator|.
name|component
operator|.
name|ShardHandler
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|update
operator|.
name|UpdateShardHandler
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|util
operator|.
name|stats
operator|.
name|Clock
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|util
operator|.
name|stats
operator|.
name|Timer
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|util
operator|.
name|stats
operator|.
name|TimerContext
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|CreateMode
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|KeeperException
import|;
end_import
begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import
begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import
begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|cloud
operator|.
name|OverseerCollectionMessageHandler
operator|.
name|ONLY_ACTIVE_NODES
import|;
end_import
begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|cloud
operator|.
name|OverseerCollectionMessageHandler
operator|.
name|SHARD_UNIQUE
import|;
end_import
begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|params
operator|.
name|CollectionParams
operator|.
name|CollectionAction
operator|.
name|BALANCESHARDUNIQUE
import|;
end_import
begin_comment
comment|/**  * Cluster leader. Responsible for processing state updates, node assignments, creating/deleting  * collections, shards, replicas and setting various properties.  */
end_comment
begin_class
DECL|class|Overseer
specifier|public
class|class
name|Overseer
implements|implements
name|Closeable
block|{
DECL|field|QUEUE_OPERATION
specifier|public
specifier|static
specifier|final
name|String
name|QUEUE_OPERATION
init|=
literal|"operation"
decl_stmt|;
DECL|field|STATE_UPDATE_DELAY
specifier|public
specifier|static
specifier|final
name|int
name|STATE_UPDATE_DELAY
init|=
literal|1500
decl_stmt|;
comment|// delay between cloud state updates
DECL|field|NUM_RESPONSES_TO_STORE
specifier|public
specifier|static
specifier|final
name|int
name|NUM_RESPONSES_TO_STORE
init|=
literal|10000
decl_stmt|;
DECL|field|log
specifier|private
specifier|static
name|Logger
name|log
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|Overseer
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|enum|LeaderStatus
DECL|enum constant|DONT_KNOW
DECL|enum constant|NO
DECL|enum constant|YES
enum|enum
name|LeaderStatus
block|{
name|DONT_KNOW
block|,
name|NO
block|,
name|YES
block|}
DECL|class|ClusterStateUpdater
specifier|private
class|class
name|ClusterStateUpdater
implements|implements
name|Runnable
implements|,
name|Closeable
block|{
DECL|field|reader
specifier|private
specifier|final
name|ZkStateReader
name|reader
decl_stmt|;
DECL|field|zkClient
specifier|private
specifier|final
name|SolrZkClient
name|zkClient
decl_stmt|;
DECL|field|myId
specifier|private
specifier|final
name|String
name|myId
decl_stmt|;
comment|//queue where everybody can throw tasks
DECL|field|stateUpdateQueue
specifier|private
specifier|final
name|DistributedQueue
name|stateUpdateQueue
decl_stmt|;
comment|//Internal queue where overseer stores events that have not yet been published into cloudstate
comment|//If Overseer dies while extracting the main queue a new overseer will start from this queue
DECL|field|workQueue
specifier|private
specifier|final
name|DistributedQueue
name|workQueue
decl_stmt|;
comment|// Internal map which holds the information about running tasks.
DECL|field|runningMap
specifier|private
specifier|final
name|DistributedMap
name|runningMap
decl_stmt|;
comment|// Internal map which holds the information about successfully completed tasks.
DECL|field|completedMap
specifier|private
specifier|final
name|DistributedMap
name|completedMap
decl_stmt|;
comment|// Internal map which holds the information about failed tasks.
DECL|field|failureMap
specifier|private
specifier|final
name|DistributedMap
name|failureMap
decl_stmt|;
DECL|field|zkStats
specifier|private
specifier|final
name|Stats
name|zkStats
decl_stmt|;
DECL|field|isClosed
specifier|private
name|boolean
name|isClosed
init|=
literal|false
decl_stmt|;
DECL|method|ClusterStateUpdater
specifier|public
name|ClusterStateUpdater
parameter_list|(
specifier|final
name|ZkStateReader
name|reader
parameter_list|,
specifier|final
name|String
name|myId
parameter_list|,
name|Stats
name|zkStats
parameter_list|)
block|{
name|this
operator|.
name|zkClient
operator|=
name|reader
operator|.
name|getZkClient
argument_list|()
expr_stmt|;
name|this
operator|.
name|zkStats
operator|=
name|zkStats
expr_stmt|;
name|this
operator|.
name|stateUpdateQueue
operator|=
name|getInQueue
argument_list|(
name|zkClient
argument_list|,
name|zkStats
argument_list|)
expr_stmt|;
name|this
operator|.
name|workQueue
operator|=
name|getInternalQueue
argument_list|(
name|zkClient
argument_list|,
name|zkStats
argument_list|)
expr_stmt|;
name|this
operator|.
name|failureMap
operator|=
name|getFailureMap
argument_list|(
name|zkClient
argument_list|)
expr_stmt|;
name|this
operator|.
name|runningMap
operator|=
name|getRunningMap
argument_list|(
name|zkClient
argument_list|)
expr_stmt|;
name|this
operator|.
name|completedMap
operator|=
name|getCompletedMap
argument_list|(
name|zkClient
argument_list|)
expr_stmt|;
name|this
operator|.
name|myId
operator|=
name|myId
expr_stmt|;
name|this
operator|.
name|reader
operator|=
name|reader
expr_stmt|;
block|}
DECL|method|getStateUpdateQueueStats
specifier|public
name|Stats
name|getStateUpdateQueueStats
parameter_list|()
block|{
return|return
name|stateUpdateQueue
operator|.
name|getStats
argument_list|()
return|;
block|}
DECL|method|getWorkQueueStats
specifier|public
name|Stats
name|getWorkQueueStats
parameter_list|()
block|{
return|return
name|workQueue
operator|.
name|getStats
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|run
specifier|public
name|void
name|run
parameter_list|()
block|{
name|LeaderStatus
name|isLeader
init|=
name|amILeader
argument_list|()
decl_stmt|;
while|while
condition|(
name|isLeader
operator|==
name|LeaderStatus
operator|.
name|DONT_KNOW
condition|)
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"am_i_leader unclear {}"
argument_list|,
name|isLeader
argument_list|)
expr_stmt|;
name|isLeader
operator|=
name|amILeader
argument_list|()
expr_stmt|;
comment|// not a no, not a yes, try ask again
block|}
name|log
operator|.
name|info
argument_list|(
literal|"Starting to work on the main queue"
argument_list|)
expr_stmt|;
try|try
block|{
name|ZkStateWriter
name|zkStateWriter
init|=
operator|new
name|ZkStateWriter
argument_list|(
name|reader
argument_list|,
name|stats
argument_list|)
decl_stmt|;
name|ClusterState
name|clusterState
init|=
literal|null
decl_stmt|;
name|boolean
name|refreshClusterState
init|=
literal|true
decl_stmt|;
comment|// let's refresh in the first iteration
while|while
condition|(
operator|!
name|this
operator|.
name|isClosed
condition|)
block|{
name|isLeader
operator|=
name|amILeader
argument_list|()
expr_stmt|;
if|if
condition|(
name|LeaderStatus
operator|.
name|NO
operator|==
name|isLeader
condition|)
block|{
break|break;
block|}
elseif|else
if|if
condition|(
name|LeaderStatus
operator|.
name|YES
operator|!=
name|isLeader
condition|)
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"am_i_leader unclear {}"
argument_list|,
name|isLeader
argument_list|)
expr_stmt|;
continue|continue;
comment|// not a no, not a yes, try ask again
block|}
if|if
condition|(
name|refreshClusterState
condition|)
block|{
try|try
block|{
name|reader
operator|.
name|updateClusterState
argument_list|()
expr_stmt|;
name|clusterState
operator|=
name|reader
operator|.
name|getClusterState
argument_list|()
expr_stmt|;
name|refreshClusterState
operator|=
literal|false
expr_stmt|;
comment|// if there were any errors while processing
comment|// the state queue, items would have been left in the
comment|// work queue so let's process those first
name|byte
index|[]
name|data
init|=
name|workQueue
operator|.
name|peek
argument_list|()
decl_stmt|;
name|boolean
name|hadWorkItems
init|=
name|data
operator|!=
literal|null
decl_stmt|;
while|while
condition|(
name|data
operator|!=
literal|null
condition|)
block|{
specifier|final
name|ZkNodeProps
name|message
init|=
name|ZkNodeProps
operator|.
name|load
argument_list|(
name|data
argument_list|)
decl_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"processMessage: workQueueSize: {}, message = {}"
argument_list|,
name|workQueue
operator|.
name|getStats
argument_list|()
operator|.
name|getQueueLength
argument_list|()
argument_list|,
name|message
argument_list|)
expr_stmt|;
comment|// force flush to ZK after each message because there is no fallback if workQueue items
comment|// are removed from workQueue but fail to be written to ZK
name|clusterState
operator|=
name|processQueueItem
argument_list|(
name|message
argument_list|,
name|clusterState
argument_list|,
name|zkStateWriter
argument_list|,
literal|false
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|workQueue
operator|.
name|poll
argument_list|()
expr_stmt|;
comment|// poll-ing removes the element we got by peek-ing
name|data
operator|=
name|workQueue
operator|.
name|peek
argument_list|()
expr_stmt|;
block|}
comment|// force flush at the end of the loop
if|if
condition|(
name|hadWorkItems
condition|)
block|{
name|clusterState
operator|=
name|zkStateWriter
operator|.
name|writePendingUpdates
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|KeeperException
name|e
parameter_list|)
block|{
if|if
condition|(
name|e
operator|.
name|code
argument_list|()
operator|==
name|KeeperException
operator|.
name|Code
operator|.
name|SESSIONEXPIRED
condition|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Solr cannot talk to ZK, exiting Overseer work queue loop"
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return;
block|}
name|log
operator|.
name|error
argument_list|(
literal|"Exception in Overseer work queue loop"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
return|return;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"Exception in Overseer work queue loop"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
name|DistributedQueue
operator|.
name|QueueEvent
name|head
init|=
literal|null
decl_stmt|;
try|try
block|{
name|head
operator|=
name|stateUpdateQueue
operator|.
name|peek
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|KeeperException
name|e
parameter_list|)
block|{
if|if
condition|(
name|e
operator|.
name|code
argument_list|()
operator|==
name|KeeperException
operator|.
name|Code
operator|.
name|SESSIONEXPIRED
condition|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Solr cannot talk to ZK, exiting Overseer main queue loop"
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return;
block|}
name|log
operator|.
name|error
argument_list|(
literal|"Exception in Overseer main queue loop"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
return|return;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"Exception in Overseer main queue loop"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
try|try
block|{
while|while
condition|(
name|head
operator|!=
literal|null
condition|)
block|{
specifier|final
name|byte
index|[]
name|data
init|=
name|head
operator|.
name|getBytes
argument_list|()
decl_stmt|;
specifier|final
name|ZkNodeProps
name|message
init|=
name|ZkNodeProps
operator|.
name|load
argument_list|(
name|head
operator|.
name|getBytes
argument_list|()
argument_list|)
decl_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"processMessage: queueSize: {}, message = {} current state version: {}"
argument_list|,
name|stateUpdateQueue
operator|.
name|getStats
argument_list|()
operator|.
name|getQueueLength
argument_list|()
argument_list|,
name|message
argument_list|,
name|clusterState
operator|.
name|getZkClusterStateVersion
argument_list|()
argument_list|)
expr_stmt|;
comment|// we can batch here because workQueue is our fallback in case a ZK write failed
name|clusterState
operator|=
name|processQueueItem
argument_list|(
name|message
argument_list|,
name|clusterState
argument_list|,
name|zkStateWriter
argument_list|,
literal|true
argument_list|,
operator|new
name|ZkStateWriter
operator|.
name|ZkWriteCallback
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|onEnqueue
parameter_list|()
throws|throws
name|Exception
block|{
name|workQueue
operator|.
name|offer
argument_list|(
name|data
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|onWrite
parameter_list|()
throws|throws
name|Exception
block|{
comment|// remove everything from workQueue
while|while
condition|(
name|workQueue
operator|.
name|poll
argument_list|()
operator|!=
literal|null
condition|)
empty_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
comment|// it is safer to keep this poll here because an invalid message might never be queued
comment|// and therefore we can't rely on the ZkWriteCallback to remove the item
name|stateUpdateQueue
operator|.
name|poll
argument_list|()
expr_stmt|;
if|if
condition|(
name|isClosed
condition|)
break|break;
comment|// if an event comes in the next 100ms batch it together
name|head
operator|=
name|stateUpdateQueue
operator|.
name|peek
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
comment|// we should force write all pending updates because the next iteration might sleep until there
comment|// are more items in the main queue
name|clusterState
operator|=
name|zkStateWriter
operator|.
name|writePendingUpdates
argument_list|()
expr_stmt|;
comment|// clean work queue
while|while
condition|(
name|workQueue
operator|.
name|poll
argument_list|()
operator|!=
literal|null
condition|)
empty_stmt|;
block|}
catch|catch
parameter_list|(
name|KeeperException
name|e
parameter_list|)
block|{
if|if
condition|(
name|e
operator|.
name|code
argument_list|()
operator|==
name|KeeperException
operator|.
name|Code
operator|.
name|SESSIONEXPIRED
condition|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Solr cannot talk to ZK, exiting Overseer main queue loop"
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return;
block|}
name|log
operator|.
name|error
argument_list|(
literal|"Exception in Overseer main queue loop"
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|refreshClusterState
operator|=
literal|true
expr_stmt|;
comment|// it might have been a bad version error
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
return|return;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"Exception in Overseer main queue loop"
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|refreshClusterState
operator|=
literal|true
expr_stmt|;
comment|// it might have been a bad version error
block|}
block|}
block|}
finally|finally
block|{
name|log
operator|.
name|info
argument_list|(
literal|"Overseer Loop exiting : {}"
argument_list|,
name|LeaderElector
operator|.
name|getNodeName
argument_list|(
name|myId
argument_list|)
argument_list|)
expr_stmt|;
operator|new
name|Thread
argument_list|(
literal|"OverseerExitThread"
argument_list|)
block|{
comment|//do this in a separate thread because any wait is interrupted in this main thread
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
name|checkIfIamStillLeader
argument_list|()
expr_stmt|;
block|}
block|}
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|processQueueItem
specifier|private
name|ClusterState
name|processQueueItem
parameter_list|(
name|ZkNodeProps
name|message
parameter_list|,
name|ClusterState
name|clusterState
parameter_list|,
name|ZkStateWriter
name|zkStateWriter
parameter_list|,
name|boolean
name|enableBatching
parameter_list|,
name|ZkStateWriter
operator|.
name|ZkWriteCallback
name|callback
parameter_list|)
throws|throws
name|Exception
block|{
specifier|final
name|String
name|operation
init|=
name|message
operator|.
name|getStr
argument_list|(
name|QUEUE_OPERATION
argument_list|)
decl_stmt|;
name|ZkWriteCommand
name|zkWriteCommand
init|=
literal|null
decl_stmt|;
specifier|final
name|TimerContext
name|timerContext
init|=
name|stats
operator|.
name|time
argument_list|(
name|operation
argument_list|)
decl_stmt|;
try|try
block|{
name|zkWriteCommand
operator|=
name|processMessage
argument_list|(
name|clusterState
argument_list|,
name|message
argument_list|,
name|operation
argument_list|)
expr_stmt|;
name|stats
operator|.
name|success
argument_list|(
name|operation
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
comment|// generally there is nothing we can do - in most cases, we have
comment|// an issue that will fail again on retry or we cannot communicate with     a
comment|// ZooKeeper in which case another Overseer should take over
comment|// TODO: if ordering for the message is not important, we could
comment|// track retries and put it back on the end of the queue
name|log
operator|.
name|error
argument_list|(
literal|"Overseer could not process the current clusterstate state update message, skipping the message."
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|stats
operator|.
name|error
argument_list|(
name|operation
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|timerContext
operator|.
name|stop
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|zkWriteCommand
operator|!=
literal|null
condition|)
block|{
name|clusterState
operator|=
name|zkStateWriter
operator|.
name|enqueueUpdate
argument_list|(
name|clusterState
argument_list|,
name|zkWriteCommand
argument_list|,
name|callback
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|enableBatching
condition|)
block|{
name|clusterState
operator|=
name|zkStateWriter
operator|.
name|writePendingUpdates
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|clusterState
return|;
block|}
DECL|method|checkIfIamStillLeader
specifier|private
name|void
name|checkIfIamStillLeader
parameter_list|()
block|{
if|if
condition|(
name|zkController
operator|!=
literal|null
operator|&&
name|zkController
operator|.
name|getCoreContainer
argument_list|()
operator|.
name|isShutDown
argument_list|()
condition|)
return|return;
comment|//shutting down no need to go further
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|data
operator|.
name|Stat
name|stat
init|=
operator|new
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|data
operator|.
name|Stat
argument_list|()
decl_stmt|;
name|String
name|path
init|=
literal|"/overseer_elect/leader"
decl_stmt|;
name|byte
index|[]
name|data
init|=
literal|null
decl_stmt|;
try|try
block|{
name|data
operator|=
name|zkClient
operator|.
name|getData
argument_list|(
name|path
argument_list|,
literal|null
argument_list|,
name|stat
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"could not read the data"
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return;
block|}
try|try
block|{
name|Map
name|m
init|=
operator|(
name|Map
operator|)
name|Utils
operator|.
name|fromJSON
argument_list|(
name|data
argument_list|)
decl_stmt|;
name|String
name|id
init|=
operator|(
name|String
operator|)
name|m
operator|.
name|get
argument_list|(
literal|"id"
argument_list|)
decl_stmt|;
if|if
condition|(
name|overseerCollectionProcessor
operator|.
name|getId
argument_list|()
operator|.
name|equals
argument_list|(
name|id
argument_list|)
condition|)
block|{
try|try
block|{
name|log
operator|.
name|info
argument_list|(
literal|"I'm exiting , but I'm still the leader"
argument_list|)
expr_stmt|;
name|zkClient
operator|.
name|delete
argument_list|(
name|path
argument_list|,
name|stat
operator|.
name|getVersion
argument_list|()
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|KeeperException
operator|.
name|BadVersionException
name|e
parameter_list|)
block|{
comment|//no problem ignore it some other Overseer has already taken over
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"Could not delete my leader node "
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|log
operator|.
name|info
argument_list|(
literal|"somebody else has already taken up the overseer position"
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
comment|//if I am not shutting down, Then I need to rejoin election
try|try
block|{
if|if
condition|(
name|zkController
operator|!=
literal|null
operator|&&
operator|!
name|zkController
operator|.
name|getCoreContainer
argument_list|()
operator|.
name|isShutDown
argument_list|()
condition|)
block|{
name|zkController
operator|.
name|rejoinOverseerElection
argument_list|(
literal|null
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Unable to rejoinElection "
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|processMessage
specifier|private
name|ZkWriteCommand
name|processMessage
parameter_list|(
name|ClusterState
name|clusterState
parameter_list|,
specifier|final
name|ZkNodeProps
name|message
parameter_list|,
specifier|final
name|String
name|operation
parameter_list|)
block|{
name|CollectionParams
operator|.
name|CollectionAction
name|collectionAction
init|=
name|CollectionParams
operator|.
name|CollectionAction
operator|.
name|get
argument_list|(
name|operation
argument_list|)
decl_stmt|;
if|if
condition|(
name|collectionAction
operator|!=
literal|null
condition|)
block|{
switch|switch
condition|(
name|collectionAction
condition|)
block|{
case|case
name|CREATE
case|:
return|return
operator|new
name|ClusterStateMutator
argument_list|(
name|getZkStateReader
argument_list|()
argument_list|)
operator|.
name|createCollection
argument_list|(
name|clusterState
argument_list|,
name|message
argument_list|)
return|;
case|case
name|DELETE
case|:
return|return
operator|new
name|ClusterStateMutator
argument_list|(
name|getZkStateReader
argument_list|()
argument_list|)
operator|.
name|deleteCollection
argument_list|(
name|clusterState
argument_list|,
name|message
argument_list|)
return|;
case|case
name|CREATESHARD
case|:
return|return
operator|new
name|CollectionMutator
argument_list|(
name|getZkStateReader
argument_list|()
argument_list|)
operator|.
name|createShard
argument_list|(
name|clusterState
argument_list|,
name|message
argument_list|)
return|;
case|case
name|DELETESHARD
case|:
return|return
operator|new
name|CollectionMutator
argument_list|(
name|getZkStateReader
argument_list|()
argument_list|)
operator|.
name|deleteShard
argument_list|(
name|clusterState
argument_list|,
name|message
argument_list|)
return|;
case|case
name|ADDREPLICA
case|:
return|return
operator|new
name|SliceMutator
argument_list|(
name|getZkStateReader
argument_list|()
argument_list|)
operator|.
name|addReplica
argument_list|(
name|clusterState
argument_list|,
name|message
argument_list|)
return|;
case|case
name|ADDREPLICAPROP
case|:
return|return
operator|new
name|ReplicaMutator
argument_list|(
name|getZkStateReader
argument_list|()
argument_list|)
operator|.
name|addReplicaProperty
argument_list|(
name|clusterState
argument_list|,
name|message
argument_list|)
return|;
case|case
name|DELETEREPLICAPROP
case|:
return|return
operator|new
name|ReplicaMutator
argument_list|(
name|getZkStateReader
argument_list|()
argument_list|)
operator|.
name|deleteReplicaProperty
argument_list|(
name|clusterState
argument_list|,
name|message
argument_list|)
return|;
case|case
name|BALANCESHARDUNIQUE
case|:
name|ExclusiveSliceProperty
name|dProp
init|=
operator|new
name|ExclusiveSliceProperty
argument_list|(
name|clusterState
argument_list|,
name|message
argument_list|)
decl_stmt|;
if|if
condition|(
name|dProp
operator|.
name|balanceProperty
argument_list|()
condition|)
block|{
name|String
name|collName
init|=
name|message
operator|.
name|getStr
argument_list|(
name|ZkStateReader
operator|.
name|COLLECTION_PROP
argument_list|)
decl_stmt|;
return|return
operator|new
name|ZkWriteCommand
argument_list|(
name|collName
argument_list|,
name|dProp
operator|.
name|getDocCollection
argument_list|()
argument_list|)
return|;
block|}
break|break;
case|case
name|MODIFYCOLLECTION
case|:
name|CollectionsHandler
operator|.
name|verifyRuleParams
argument_list|(
name|zkController
operator|.
name|getCoreContainer
argument_list|()
argument_list|,
name|message
operator|.
name|getProperties
argument_list|()
argument_list|)
expr_stmt|;
return|return
operator|new
name|CollectionMutator
argument_list|(
name|reader
argument_list|)
operator|.
name|modifyCollection
argument_list|(
name|clusterState
argument_list|,
name|message
argument_list|)
return|;
default|default:
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"unknown operation:"
operator|+
name|operation
operator|+
literal|" contents:"
operator|+
name|message
operator|.
name|getProperties
argument_list|()
argument_list|)
throw|;
block|}
block|}
else|else
block|{
name|OverseerAction
name|overseerAction
init|=
name|OverseerAction
operator|.
name|get
argument_list|(
name|operation
argument_list|)
decl_stmt|;
if|if
condition|(
name|overseerAction
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"unknown operation:"
operator|+
name|operation
operator|+
literal|" contents:"
operator|+
name|message
operator|.
name|getProperties
argument_list|()
argument_list|)
throw|;
block|}
switch|switch
condition|(
name|overseerAction
condition|)
block|{
case|case
name|STATE
case|:
return|return
operator|new
name|ReplicaMutator
argument_list|(
name|getZkStateReader
argument_list|()
argument_list|)
operator|.
name|setState
argument_list|(
name|clusterState
argument_list|,
name|message
argument_list|)
return|;
case|case
name|LEADER
case|:
return|return
operator|new
name|SliceMutator
argument_list|(
name|getZkStateReader
argument_list|()
argument_list|)
operator|.
name|setShardLeader
argument_list|(
name|clusterState
argument_list|,
name|message
argument_list|)
return|;
case|case
name|DELETECORE
case|:
return|return
operator|new
name|SliceMutator
argument_list|(
name|getZkStateReader
argument_list|()
argument_list|)
operator|.
name|removeReplica
argument_list|(
name|clusterState
argument_list|,
name|message
argument_list|)
return|;
case|case
name|ADDROUTINGRULE
case|:
return|return
operator|new
name|SliceMutator
argument_list|(
name|getZkStateReader
argument_list|()
argument_list|)
operator|.
name|addRoutingRule
argument_list|(
name|clusterState
argument_list|,
name|message
argument_list|)
return|;
case|case
name|REMOVEROUTINGRULE
case|:
return|return
operator|new
name|SliceMutator
argument_list|(
name|getZkStateReader
argument_list|()
argument_list|)
operator|.
name|removeRoutingRule
argument_list|(
name|clusterState
argument_list|,
name|message
argument_list|)
return|;
case|case
name|UPDATESHARDSTATE
case|:
return|return
operator|new
name|SliceMutator
argument_list|(
name|getZkStateReader
argument_list|()
argument_list|)
operator|.
name|updateShardState
argument_list|(
name|clusterState
argument_list|,
name|message
argument_list|)
return|;
case|case
name|QUIT
case|:
if|if
condition|(
name|myId
operator|.
name|equals
argument_list|(
name|message
operator|.
name|get
argument_list|(
literal|"id"
argument_list|)
argument_list|)
condition|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"Quit command received {}"
argument_list|,
name|LeaderElector
operator|.
name|getNodeName
argument_list|(
name|myId
argument_list|)
argument_list|)
expr_stmt|;
name|overseerCollectionProcessor
operator|.
name|close
argument_list|()
expr_stmt|;
name|close
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Overseer received wrong QUIT message {}"
argument_list|,
name|message
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"unknown operation:"
operator|+
name|operation
operator|+
literal|" contents:"
operator|+
name|message
operator|.
name|getProperties
argument_list|()
argument_list|)
throw|;
block|}
block|}
return|return
name|ZkStateWriter
operator|.
name|NO_OP
return|;
block|}
DECL|method|amILeader
specifier|private
name|LeaderStatus
name|amILeader
parameter_list|()
block|{
name|TimerContext
name|timerContext
init|=
name|stats
operator|.
name|time
argument_list|(
literal|"am_i_leader"
argument_list|)
decl_stmt|;
name|boolean
name|success
init|=
literal|true
decl_stmt|;
try|try
block|{
name|ZkNodeProps
name|props
init|=
name|ZkNodeProps
operator|.
name|load
argument_list|(
name|zkClient
operator|.
name|getData
argument_list|(
literal|"/overseer_elect/leader"
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|true
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|myId
operator|.
name|equals
argument_list|(
name|props
operator|.
name|getStr
argument_list|(
literal|"id"
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|LeaderStatus
operator|.
name|YES
return|;
block|}
block|}
catch|catch
parameter_list|(
name|KeeperException
name|e
parameter_list|)
block|{
name|success
operator|=
literal|false
expr_stmt|;
if|if
condition|(
name|e
operator|.
name|code
argument_list|()
operator|==
name|KeeperException
operator|.
name|Code
operator|.
name|CONNECTIONLOSS
condition|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|""
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
name|LeaderStatus
operator|.
name|DONT_KNOW
return|;
block|}
elseif|else
if|if
condition|(
name|e
operator|.
name|code
argument_list|()
operator|==
name|KeeperException
operator|.
name|Code
operator|.
name|SESSIONEXPIRED
condition|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|""
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|log
operator|.
name|warn
argument_list|(
literal|""
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|success
operator|=
literal|false
expr_stmt|;
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|timerContext
operator|.
name|stop
argument_list|()
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|stats
operator|.
name|success
argument_list|(
literal|"am_i_leader"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|stats
operator|.
name|error
argument_list|(
literal|"am_i_leader"
argument_list|)
expr_stmt|;
block|}
block|}
name|log
operator|.
name|info
argument_list|(
literal|"According to ZK I (id="
operator|+
name|myId
operator|+
literal|") am no longer a leader."
argument_list|)
expr_stmt|;
return|return
name|LeaderStatus
operator|.
name|NO
return|;
block|}
annotation|@
name|Override
DECL|method|close
specifier|public
name|void
name|close
parameter_list|()
block|{
name|this
operator|.
name|isClosed
operator|=
literal|true
expr_stmt|;
block|}
block|}
comment|// Class to encapsulate processing replica properties that have at most one replica hosting a property per slice.
DECL|class|ExclusiveSliceProperty
specifier|private
class|class
name|ExclusiveSliceProperty
block|{
DECL|field|clusterState
specifier|private
name|ClusterState
name|clusterState
decl_stmt|;
DECL|field|onlyActiveNodes
specifier|private
specifier|final
name|boolean
name|onlyActiveNodes
decl_stmt|;
DECL|field|property
specifier|private
specifier|final
name|String
name|property
decl_stmt|;
DECL|field|collection
specifier|private
specifier|final
name|DocCollection
name|collection
decl_stmt|;
DECL|field|collectionName
specifier|private
specifier|final
name|String
name|collectionName
decl_stmt|;
comment|// Key structure. For each node, list all replicas on it regardless of whether they have the property or not.
DECL|field|nodesHostingReplicas
specifier|private
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|SliceReplica
argument_list|>
argument_list|>
name|nodesHostingReplicas
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
comment|// Key structure. For each node, a list of the replicas _currently_ hosting the property.
DECL|field|nodesHostingProp
specifier|private
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|SliceReplica
argument_list|>
argument_list|>
name|nodesHostingProp
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
DECL|field|shardsNeedingHosts
name|Set
argument_list|<
name|String
argument_list|>
name|shardsNeedingHosts
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
DECL|field|changedSlices
name|Map
argument_list|<
name|String
argument_list|,
name|Slice
argument_list|>
name|changedSlices
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
comment|// Work on copies rather than the underlying cluster state.
DECL|field|origMaxPropPerNode
specifier|private
name|int
name|origMaxPropPerNode
init|=
literal|0
decl_stmt|;
DECL|field|origModulo
specifier|private
name|int
name|origModulo
init|=
literal|0
decl_stmt|;
DECL|field|tmpMaxPropPerNode
specifier|private
name|int
name|tmpMaxPropPerNode
init|=
literal|0
decl_stmt|;
DECL|field|tmpModulo
specifier|private
name|int
name|tmpModulo
init|=
literal|0
decl_stmt|;
DECL|field|rand
name|Random
name|rand
init|=
operator|new
name|Random
argument_list|()
decl_stmt|;
DECL|field|assigned
specifier|private
name|int
name|assigned
init|=
literal|0
decl_stmt|;
DECL|method|ExclusiveSliceProperty
name|ExclusiveSliceProperty
parameter_list|(
name|ClusterState
name|clusterState
parameter_list|,
name|ZkNodeProps
name|message
parameter_list|)
block|{
name|this
operator|.
name|clusterState
operator|=
name|clusterState
expr_stmt|;
name|String
name|tmp
init|=
name|message
operator|.
name|getStr
argument_list|(
name|ZkStateReader
operator|.
name|PROPERTY_PROP
argument_list|)
decl_stmt|;
if|if
condition|(
name|StringUtils
operator|.
name|startsWith
argument_list|(
name|tmp
argument_list|,
name|OverseerCollectionMessageHandler
operator|.
name|COLL_PROP_PREFIX
argument_list|)
operator|==
literal|false
condition|)
block|{
name|tmp
operator|=
name|OverseerCollectionMessageHandler
operator|.
name|COLL_PROP_PREFIX
operator|+
name|tmp
expr_stmt|;
block|}
name|this
operator|.
name|property
operator|=
name|tmp
operator|.
name|toLowerCase
argument_list|(
name|Locale
operator|.
name|ROOT
argument_list|)
expr_stmt|;
name|collectionName
operator|=
name|message
operator|.
name|getStr
argument_list|(
name|ZkStateReader
operator|.
name|COLLECTION_PROP
argument_list|)
expr_stmt|;
if|if
condition|(
name|StringUtils
operator|.
name|isBlank
argument_list|(
name|collectionName
argument_list|)
operator|||
name|StringUtils
operator|.
name|isBlank
argument_list|(
name|property
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|SolrException
operator|.
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
literal|"Overseer '"
operator|+
name|message
operator|.
name|getStr
argument_list|(
name|QUEUE_OPERATION
argument_list|)
operator|+
literal|"'  requires both the '"
operator|+
name|ZkStateReader
operator|.
name|COLLECTION_PROP
operator|+
literal|"' and '"
operator|+
name|ZkStateReader
operator|.
name|PROPERTY_PROP
operator|+
literal|"' parameters. No action taken "
argument_list|)
throw|;
block|}
name|Boolean
name|shardUnique
init|=
name|Boolean
operator|.
name|parseBoolean
argument_list|(
name|message
operator|.
name|getStr
argument_list|(
name|SHARD_UNIQUE
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|shardUnique
operator|==
literal|false
operator|&&
name|SliceMutator
operator|.
name|SLICE_UNIQUE_BOOLEAN_PROPERTIES
operator|.
name|contains
argument_list|(
name|this
operator|.
name|property
argument_list|)
operator|==
literal|false
condition|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|SolrException
operator|.
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
literal|"Balancing properties amongst replicas in a slice requires that"
operator|+
literal|" the property be a pre-defined property (e.g. 'preferredLeader') or that 'shardUnique' be set to 'true' "
operator|+
literal|" Property: "
operator|+
name|this
operator|.
name|property
operator|+
literal|" shardUnique: "
operator|+
name|Boolean
operator|.
name|toString
argument_list|(
name|shardUnique
argument_list|)
argument_list|)
throw|;
block|}
name|collection
operator|=
name|clusterState
operator|.
name|getCollection
argument_list|(
name|collectionName
argument_list|)
expr_stmt|;
if|if
condition|(
name|collection
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|SolrException
operator|.
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
literal|"Could not find collection ' "
operator|+
name|collectionName
operator|+
literal|"' for overseer operation '"
operator|+
name|message
operator|.
name|getStr
argument_list|(
name|QUEUE_OPERATION
argument_list|)
operator|+
literal|"'. No action taken."
argument_list|)
throw|;
block|}
name|onlyActiveNodes
operator|=
name|Boolean
operator|.
name|parseBoolean
argument_list|(
name|message
operator|.
name|getStr
argument_list|(
name|ONLY_ACTIVE_NODES
argument_list|,
literal|"true"
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|getDocCollection
specifier|private
name|DocCollection
name|getDocCollection
parameter_list|()
block|{
return|return
name|collection
return|;
block|}
DECL|method|isActive
specifier|private
name|boolean
name|isActive
parameter_list|(
name|Replica
name|replica
parameter_list|)
block|{
return|return
name|replica
operator|.
name|getState
argument_list|()
operator|==
name|Replica
operator|.
name|State
operator|.
name|ACTIVE
return|;
block|}
comment|// Collect a list of all the nodes that _can_ host the indicated property. Along the way, also collect any of
comment|// the replicas on that node that _already_ host the property as well as any slices that do _not_ have the
comment|// property hosted.
comment|//
comment|// Return true if anything node needs it's property reassigned. False if the property is already balanced for
comment|// the collection.
DECL|method|collectCurrentPropStats
specifier|private
name|boolean
name|collectCurrentPropStats
parameter_list|()
block|{
name|int
name|maxAssigned
init|=
literal|0
decl_stmt|;
comment|// Get a list of potential replicas that can host the property _and_ their counts
comment|// Move any obvious entries to a list of replicas to change the property on
name|Set
argument_list|<
name|String
argument_list|>
name|allHosts
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|Slice
name|slice
range|:
name|collection
operator|.
name|getSlices
argument_list|()
control|)
block|{
name|boolean
name|sliceHasProp
init|=
literal|false
decl_stmt|;
for|for
control|(
name|Replica
name|replica
range|:
name|slice
operator|.
name|getReplicas
argument_list|()
control|)
block|{
if|if
condition|(
name|onlyActiveNodes
operator|&&
name|isActive
argument_list|(
name|replica
argument_list|)
operator|==
literal|false
condition|)
block|{
if|if
condition|(
name|StringUtils
operator|.
name|isNotBlank
argument_list|(
name|replica
operator|.
name|getStr
argument_list|(
name|property
argument_list|)
argument_list|)
condition|)
block|{
name|removeProp
argument_list|(
name|slice
argument_list|,
name|replica
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
comment|// Note, we won't be committing this to ZK until later.
block|}
continue|continue;
block|}
name|allHosts
operator|.
name|add
argument_list|(
name|replica
operator|.
name|getNodeName
argument_list|()
argument_list|)
expr_stmt|;
name|String
name|nodeName
init|=
name|replica
operator|.
name|getNodeName
argument_list|()
decl_stmt|;
if|if
condition|(
name|StringUtils
operator|.
name|isNotBlank
argument_list|(
name|replica
operator|.
name|getStr
argument_list|(
name|property
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|sliceHasProp
condition|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|SolrException
operator|.
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
literal|"'"
operator|+
name|BALANCESHARDUNIQUE
operator|+
literal|"' should only be called for properties that have at most one member "
operator|+
literal|"in any slice with the property set. No action taken."
argument_list|)
throw|;
block|}
if|if
condition|(
name|nodesHostingProp
operator|.
name|containsKey
argument_list|(
name|nodeName
argument_list|)
operator|==
literal|false
condition|)
block|{
name|nodesHostingProp
operator|.
name|put
argument_list|(
name|nodeName
argument_list|,
operator|new
name|ArrayList
argument_list|<
name|SliceReplica
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|nodesHostingProp
operator|.
name|get
argument_list|(
name|nodeName
argument_list|)
operator|.
name|add
argument_list|(
operator|new
name|SliceReplica
argument_list|(
name|slice
argument_list|,
name|replica
argument_list|)
argument_list|)
expr_stmt|;
operator|++
name|assigned
expr_stmt|;
name|maxAssigned
operator|=
name|Math
operator|.
name|max
argument_list|(
name|maxAssigned
argument_list|,
name|nodesHostingProp
operator|.
name|get
argument_list|(
name|nodeName
argument_list|)
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|sliceHasProp
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|nodesHostingReplicas
operator|.
name|containsKey
argument_list|(
name|nodeName
argument_list|)
operator|==
literal|false
condition|)
block|{
name|nodesHostingReplicas
operator|.
name|put
argument_list|(
name|nodeName
argument_list|,
operator|new
name|ArrayList
argument_list|<
name|SliceReplica
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|nodesHostingReplicas
operator|.
name|get
argument_list|(
name|nodeName
argument_list|)
operator|.
name|add
argument_list|(
operator|new
name|SliceReplica
argument_list|(
name|slice
argument_list|,
name|replica
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|// If the total number of already-hosted properties assigned to nodes
comment|// that have potential to host leaders is equal to the slice count _AND_ none of the current nodes has more than
comment|// the max number of properties, there's nothing to do.
name|origMaxPropPerNode
operator|=
name|collection
operator|.
name|getSlices
argument_list|()
operator|.
name|size
argument_list|()
operator|/
name|allHosts
operator|.
name|size
argument_list|()
expr_stmt|;
comment|// Some nodes can have one more of the proeprty if the numbers aren't exactly even.
name|origModulo
operator|=
name|collection
operator|.
name|getSlices
argument_list|()
operator|.
name|size
argument_list|()
operator|%
name|allHosts
operator|.
name|size
argument_list|()
expr_stmt|;
if|if
condition|(
name|origModulo
operator|>
literal|0
condition|)
block|{
name|origMaxPropPerNode
operator|++
expr_stmt|;
comment|// have to have some nodes with 1 more property.
block|}
comment|// We can say for sure that we need to rebalance if we don't have as many assigned properties as slices.
if|if
condition|(
name|assigned
operator|!=
name|collection
operator|.
name|getSlices
argument_list|()
operator|.
name|size
argument_list|()
condition|)
block|{
return|return
literal|true
return|;
block|}
comment|// Make sure there are no more slices at the limit than the "leftovers"
comment|// Let's say there's 7 slices and 3 nodes. We need to distribute the property as 3 on node1, 2 on node2 and 2 on node3
comment|// (3, 2, 2) We need to be careful to not distribute them as 3, 3, 1. that's what this check is all about.
name|int
name|counter
init|=
name|origModulo
decl_stmt|;
for|for
control|(
name|List
argument_list|<
name|SliceReplica
argument_list|>
name|list
range|:
name|nodesHostingProp
operator|.
name|values
argument_list|()
control|)
block|{
if|if
condition|(
name|list
operator|.
name|size
argument_list|()
operator|==
name|origMaxPropPerNode
condition|)
operator|--
name|counter
expr_stmt|;
block|}
if|if
condition|(
name|counter
operator|==
literal|0
condition|)
return|return
literal|false
return|;
comment|// nodes with 1 extra leader are exactly the needed number
return|return
literal|true
return|;
block|}
DECL|method|removeSliceAlreadyHostedFromPossibles
specifier|private
name|void
name|removeSliceAlreadyHostedFromPossibles
parameter_list|(
name|String
name|sliceName
parameter_list|)
block|{
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|SliceReplica
argument_list|>
argument_list|>
name|entReplica
range|:
name|nodesHostingReplicas
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|ListIterator
argument_list|<
name|SliceReplica
argument_list|>
name|iter
init|=
name|entReplica
operator|.
name|getValue
argument_list|()
operator|.
name|listIterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|iter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|SliceReplica
name|sr
init|=
name|iter
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|sr
operator|.
name|slice
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
name|sliceName
argument_list|)
condition|)
name|iter
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
block|}
block|}
DECL|method|balanceUnassignedReplicas
specifier|private
name|void
name|balanceUnassignedReplicas
parameter_list|()
block|{
name|tmpMaxPropPerNode
operator|=
name|origMaxPropPerNode
expr_stmt|;
comment|// A bit clumsy, but don't want to duplicate code.
name|tmpModulo
operator|=
name|origModulo
expr_stmt|;
comment|// Get the nodeName and shardName for the node that has the least room for this
while|while
condition|(
name|shardsNeedingHosts
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|String
name|nodeName
init|=
literal|""
decl_stmt|;
name|int
name|minSize
init|=
name|Integer
operator|.
name|MAX_VALUE
decl_stmt|;
name|SliceReplica
name|srToChange
init|=
literal|null
decl_stmt|;
for|for
control|(
name|String
name|slice
range|:
name|shardsNeedingHosts
control|)
block|{
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|SliceReplica
argument_list|>
argument_list|>
name|ent
range|:
name|nodesHostingReplicas
operator|.
name|entrySet
argument_list|()
control|)
block|{
comment|// A little tricky. If we don't set this to something below, then it means all possible places to
comment|// put this property are full up, so just put it somewhere.
if|if
condition|(
name|srToChange
operator|==
literal|null
operator|&&
name|ent
operator|.
name|getValue
argument_list|()
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|srToChange
operator|=
name|ent
operator|.
name|getValue
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|ListIterator
argument_list|<
name|SliceReplica
argument_list|>
name|iter
init|=
name|ent
operator|.
name|getValue
argument_list|()
operator|.
name|listIterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|iter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|SliceReplica
name|sr
init|=
name|iter
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|StringUtils
operator|.
name|equals
argument_list|(
name|slice
argument_list|,
name|sr
operator|.
name|slice
operator|.
name|getName
argument_list|()
argument_list|)
operator|==
literal|false
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|nodesHostingProp
operator|.
name|containsKey
argument_list|(
name|ent
operator|.
name|getKey
argument_list|()
argument_list|)
operator|==
literal|false
condition|)
block|{
name|nodesHostingProp
operator|.
name|put
argument_list|(
name|ent
operator|.
name|getKey
argument_list|()
argument_list|,
operator|new
name|ArrayList
argument_list|<
name|SliceReplica
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|minSize
operator|>
name|nodesHostingReplicas
operator|.
name|get
argument_list|(
name|ent
operator|.
name|getKey
argument_list|()
argument_list|)
operator|.
name|size
argument_list|()
operator|&&
name|nodesHostingProp
operator|.
name|get
argument_list|(
name|ent
operator|.
name|getKey
argument_list|()
argument_list|)
operator|.
name|size
argument_list|()
operator|<
name|tmpMaxPropPerNode
condition|)
block|{
name|minSize
operator|=
name|nodesHostingReplicas
operator|.
name|get
argument_list|(
name|ent
operator|.
name|getKey
argument_list|()
argument_list|)
operator|.
name|size
argument_list|()
expr_stmt|;
name|srToChange
operator|=
name|sr
expr_stmt|;
name|nodeName
operator|=
name|ent
operator|.
name|getKey
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
comment|// Now, you have a slice and node to put it on
name|shardsNeedingHosts
operator|.
name|remove
argument_list|(
name|srToChange
operator|.
name|slice
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|nodesHostingProp
operator|.
name|containsKey
argument_list|(
name|nodeName
argument_list|)
operator|==
literal|false
condition|)
block|{
name|nodesHostingProp
operator|.
name|put
argument_list|(
name|nodeName
argument_list|,
operator|new
name|ArrayList
argument_list|<
name|SliceReplica
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|nodesHostingProp
operator|.
name|get
argument_list|(
name|nodeName
argument_list|)
operator|.
name|add
argument_list|(
name|srToChange
argument_list|)
expr_stmt|;
name|adjustLimits
argument_list|(
name|nodesHostingProp
operator|.
name|get
argument_list|(
name|nodeName
argument_list|)
argument_list|)
expr_stmt|;
name|removeSliceAlreadyHostedFromPossibles
argument_list|(
name|srToChange
operator|.
name|slice
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|addProp
argument_list|(
name|srToChange
operator|.
name|slice
argument_list|,
name|srToChange
operator|.
name|replica
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Adjust the min/max counts per allowed per node. Special handling here for dealing with the fact
comment|// that no node should have more than 1 more replica with this property than any other.
DECL|method|adjustLimits
specifier|private
name|void
name|adjustLimits
parameter_list|(
name|List
argument_list|<
name|SliceReplica
argument_list|>
name|changeList
parameter_list|)
block|{
if|if
condition|(
name|changeList
operator|.
name|size
argument_list|()
operator|==
name|tmpMaxPropPerNode
condition|)
block|{
if|if
condition|(
name|tmpModulo
operator|<
literal|0
condition|)
return|return;
operator|--
name|tmpModulo
expr_stmt|;
if|if
condition|(
name|tmpModulo
operator|==
literal|0
condition|)
block|{
operator|--
name|tmpMaxPropPerNode
expr_stmt|;
operator|--
name|tmpModulo
expr_stmt|;
comment|// Prevent dropping tmpMaxPropPerNode again.
block|}
block|}
block|}
comment|// Go through the list of presently-hosted proeprties and remove any that have too many replicas that host the property
DECL|method|removeOverallocatedReplicas
specifier|private
name|void
name|removeOverallocatedReplicas
parameter_list|()
block|{
name|tmpMaxPropPerNode
operator|=
name|origMaxPropPerNode
expr_stmt|;
comment|// A bit clumsy, but don't want to duplicate code.
name|tmpModulo
operator|=
name|origModulo
expr_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|SliceReplica
argument_list|>
argument_list|>
name|ent
range|:
name|nodesHostingProp
operator|.
name|entrySet
argument_list|()
control|)
block|{
while|while
condition|(
name|ent
operator|.
name|getValue
argument_list|()
operator|.
name|size
argument_list|()
operator|>
name|tmpMaxPropPerNode
condition|)
block|{
comment|// remove delta nodes
name|ent
operator|.
name|getValue
argument_list|()
operator|.
name|remove
argument_list|(
name|rand
operator|.
name|nextInt
argument_list|(
name|ent
operator|.
name|getValue
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|adjustLimits
argument_list|(
name|ent
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|removeProp
specifier|private
name|void
name|removeProp
parameter_list|(
name|Slice
name|origSlice
parameter_list|,
name|String
name|replicaName
parameter_list|)
block|{
name|getReplicaFromChanged
argument_list|(
name|origSlice
argument_list|,
name|replicaName
argument_list|)
operator|.
name|getProperties
argument_list|()
operator|.
name|remove
argument_list|(
name|property
argument_list|)
expr_stmt|;
block|}
DECL|method|addProp
specifier|private
name|void
name|addProp
parameter_list|(
name|Slice
name|origSlice
parameter_list|,
name|String
name|replicaName
parameter_list|)
block|{
name|getReplicaFromChanged
argument_list|(
name|origSlice
argument_list|,
name|replicaName
argument_list|)
operator|.
name|getProperties
argument_list|()
operator|.
name|put
argument_list|(
name|property
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
block|}
comment|// Just a place to encapsulate the fact that we need to have new slices (copy) to update before we
comment|// put this all in the cluster state.
DECL|method|getReplicaFromChanged
specifier|private
name|Replica
name|getReplicaFromChanged
parameter_list|(
name|Slice
name|origSlice
parameter_list|,
name|String
name|replicaName
parameter_list|)
block|{
name|Slice
name|newSlice
init|=
name|changedSlices
operator|.
name|get
argument_list|(
name|origSlice
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
name|Replica
name|replica
decl_stmt|;
if|if
condition|(
name|newSlice
operator|!=
literal|null
condition|)
block|{
name|replica
operator|=
name|newSlice
operator|.
name|getReplica
argument_list|(
name|replicaName
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|newSlice
operator|=
operator|new
name|Slice
argument_list|(
name|origSlice
operator|.
name|getName
argument_list|()
argument_list|,
name|origSlice
operator|.
name|getReplicasCopy
argument_list|()
argument_list|,
name|origSlice
operator|.
name|shallowCopy
argument_list|()
argument_list|)
expr_stmt|;
name|changedSlices
operator|.
name|put
argument_list|(
name|origSlice
operator|.
name|getName
argument_list|()
argument_list|,
name|newSlice
argument_list|)
expr_stmt|;
name|replica
operator|=
name|newSlice
operator|.
name|getReplica
argument_list|(
name|replicaName
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|replica
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|SolrException
operator|.
name|ErrorCode
operator|.
name|INVALID_STATE
argument_list|,
literal|"Should have been able to find replica '"
operator|+
name|replicaName
operator|+
literal|"' in slice '"
operator|+
name|origSlice
operator|.
name|getName
argument_list|()
operator|+
literal|"'. No action taken"
argument_list|)
throw|;
block|}
return|return
name|replica
return|;
block|}
comment|// Main entry point for carrying out the action. Returns "true" if we have actually moved properties around.
DECL|method|balanceProperty
specifier|private
name|boolean
name|balanceProperty
parameter_list|()
block|{
if|if
condition|(
name|collectCurrentPropStats
argument_list|()
operator|==
literal|false
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|// we have two lists based on nodeName
comment|// 1> all the nodes that _could_ host a property for the slice
comment|// 2> all the nodes that _currently_ host a property for the slice.
comment|// So, remove a replica from the nodes that have too many
name|removeOverallocatedReplicas
argument_list|()
expr_stmt|;
comment|// prune replicas belonging to a slice that have the property currently assigned from the list of replicas
comment|// that could host the property.
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|SliceReplica
argument_list|>
argument_list|>
name|entProp
range|:
name|nodesHostingProp
operator|.
name|entrySet
argument_list|()
control|)
block|{
for|for
control|(
name|SliceReplica
name|srHosting
range|:
name|entProp
operator|.
name|getValue
argument_list|()
control|)
block|{
name|removeSliceAlreadyHostedFromPossibles
argument_list|(
name|srHosting
operator|.
name|slice
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Assemble the list of slices that do not have any replica hosting the property:
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|SliceReplica
argument_list|>
argument_list|>
name|ent
range|:
name|nodesHostingReplicas
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|ListIterator
argument_list|<
name|SliceReplica
argument_list|>
name|iter
init|=
name|ent
operator|.
name|getValue
argument_list|()
operator|.
name|listIterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|iter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|SliceReplica
name|sr
init|=
name|iter
operator|.
name|next
argument_list|()
decl_stmt|;
name|shardsNeedingHosts
operator|.
name|add
argument_list|(
name|sr
operator|.
name|slice
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|// At this point, nodesHostingProp should contain _only_ lists of replicas that belong to slices that do _not_
comment|// have any replica hosting the property. So let's assign them.
name|balanceUnassignedReplicas
argument_list|()
expr_stmt|;
for|for
control|(
name|Slice
name|newSlice
range|:
name|changedSlices
operator|.
name|values
argument_list|()
control|)
block|{
name|DocCollection
name|docCollection
init|=
name|CollectionMutator
operator|.
name|updateSlice
argument_list|(
name|collectionName
argument_list|,
name|clusterState
operator|.
name|getCollection
argument_list|(
name|collectionName
argument_list|)
argument_list|,
name|newSlice
argument_list|)
decl_stmt|;
name|clusterState
operator|=
name|ClusterStateMutator
operator|.
name|newState
argument_list|(
name|clusterState
argument_list|,
name|collectionName
argument_list|,
name|docCollection
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
block|}
DECL|class|SliceReplica
specifier|private
class|class
name|SliceReplica
block|{
DECL|field|slice
specifier|private
name|Slice
name|slice
decl_stmt|;
DECL|field|replica
specifier|private
name|Replica
name|replica
decl_stmt|;
DECL|method|SliceReplica
name|SliceReplica
parameter_list|(
name|Slice
name|slice
parameter_list|,
name|Replica
name|replica
parameter_list|)
block|{
name|this
operator|.
name|slice
operator|=
name|slice
expr_stmt|;
name|this
operator|.
name|replica
operator|=
name|replica
expr_stmt|;
block|}
block|}
DECL|class|OverseerThread
class|class
name|OverseerThread
extends|extends
name|Thread
implements|implements
name|Closeable
block|{
DECL|field|isClosed
specifier|protected
specifier|volatile
name|boolean
name|isClosed
decl_stmt|;
DECL|field|thread
specifier|private
name|Closeable
name|thread
decl_stmt|;
DECL|method|OverseerThread
specifier|public
name|OverseerThread
parameter_list|(
name|ThreadGroup
name|tg
parameter_list|,
name|Closeable
name|thread
parameter_list|)
block|{
name|super
argument_list|(
name|tg
argument_list|,
operator|(
name|Runnable
operator|)
name|thread
argument_list|)
expr_stmt|;
name|this
operator|.
name|thread
operator|=
name|thread
expr_stmt|;
block|}
DECL|method|OverseerThread
specifier|public
name|OverseerThread
parameter_list|(
name|ThreadGroup
name|ccTg
parameter_list|,
name|Closeable
name|thread
parameter_list|,
name|String
name|name
parameter_list|)
block|{
name|super
argument_list|(
name|ccTg
argument_list|,
operator|(
name|Runnable
operator|)
name|thread
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|this
operator|.
name|thread
operator|=
name|thread
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|close
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
name|thread
operator|.
name|close
argument_list|()
expr_stmt|;
name|this
operator|.
name|isClosed
operator|=
literal|true
expr_stmt|;
block|}
DECL|method|isClosed
specifier|public
name|boolean
name|isClosed
parameter_list|()
block|{
return|return
name|this
operator|.
name|isClosed
return|;
block|}
block|}
DECL|field|ccThread
specifier|private
name|OverseerThread
name|ccThread
decl_stmt|;
DECL|field|updaterThread
specifier|private
name|OverseerThread
name|updaterThread
decl_stmt|;
DECL|field|arfoThread
specifier|private
name|OverseerThread
name|arfoThread
decl_stmt|;
DECL|field|reader
specifier|private
specifier|final
name|ZkStateReader
name|reader
decl_stmt|;
DECL|field|shardHandler
specifier|private
specifier|final
name|ShardHandler
name|shardHandler
decl_stmt|;
DECL|field|updateShardHandler
specifier|private
specifier|final
name|UpdateShardHandler
name|updateShardHandler
decl_stmt|;
DECL|field|adminPath
specifier|private
specifier|final
name|String
name|adminPath
decl_stmt|;
DECL|field|overseerCollectionProcessor
specifier|private
name|OverseerCollectionProcessor
name|overseerCollectionProcessor
decl_stmt|;
DECL|field|zkController
specifier|private
name|ZkController
name|zkController
decl_stmt|;
DECL|field|stats
specifier|private
name|Stats
name|stats
decl_stmt|;
DECL|field|id
specifier|private
name|String
name|id
decl_stmt|;
DECL|field|closed
specifier|private
name|boolean
name|closed
decl_stmt|;
DECL|field|config
specifier|private
name|CloudConfig
name|config
decl_stmt|;
comment|// overseer not responsible for closing reader
DECL|method|Overseer
specifier|public
name|Overseer
parameter_list|(
name|ShardHandler
name|shardHandler
parameter_list|,
name|UpdateShardHandler
name|updateShardHandler
parameter_list|,
name|String
name|adminPath
parameter_list|,
specifier|final
name|ZkStateReader
name|reader
parameter_list|,
name|ZkController
name|zkController
parameter_list|,
name|CloudConfig
name|config
parameter_list|)
throws|throws
name|KeeperException
throws|,
name|InterruptedException
block|{
name|this
operator|.
name|reader
operator|=
name|reader
expr_stmt|;
name|this
operator|.
name|shardHandler
operator|=
name|shardHandler
expr_stmt|;
name|this
operator|.
name|updateShardHandler
operator|=
name|updateShardHandler
expr_stmt|;
name|this
operator|.
name|adminPath
operator|=
name|adminPath
expr_stmt|;
name|this
operator|.
name|zkController
operator|=
name|zkController
expr_stmt|;
name|this
operator|.
name|stats
operator|=
operator|new
name|Stats
argument_list|()
expr_stmt|;
name|this
operator|.
name|config
operator|=
name|config
expr_stmt|;
block|}
DECL|method|start
specifier|public
specifier|synchronized
name|void
name|start
parameter_list|(
name|String
name|id
parameter_list|)
block|{
name|this
operator|.
name|id
operator|=
name|id
expr_stmt|;
name|closed
operator|=
literal|false
expr_stmt|;
name|doClose
argument_list|()
expr_stmt|;
name|stats
operator|=
operator|new
name|Stats
argument_list|()
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Overseer (id="
operator|+
name|id
operator|+
literal|") starting"
argument_list|)
expr_stmt|;
name|createOverseerNode
argument_list|(
name|reader
operator|.
name|getZkClient
argument_list|()
argument_list|)
expr_stmt|;
comment|//launch cluster state updater thread
name|ThreadGroup
name|tg
init|=
operator|new
name|ThreadGroup
argument_list|(
literal|"Overseer state updater."
argument_list|)
decl_stmt|;
name|updaterThread
operator|=
operator|new
name|OverseerThread
argument_list|(
name|tg
argument_list|,
operator|new
name|ClusterStateUpdater
argument_list|(
name|reader
argument_list|,
name|id
argument_list|,
name|stats
argument_list|)
argument_list|,
literal|"OverseerStateUpdate-"
operator|+
name|id
argument_list|)
expr_stmt|;
name|updaterThread
operator|.
name|setDaemon
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|ThreadGroup
name|ccTg
init|=
operator|new
name|ThreadGroup
argument_list|(
literal|"Overseer collection creation process."
argument_list|)
decl_stmt|;
name|OverseerNodePrioritizer
name|overseerPrioritizer
init|=
operator|new
name|OverseerNodePrioritizer
argument_list|(
name|reader
argument_list|,
name|adminPath
argument_list|,
name|shardHandler
operator|.
name|getShardHandlerFactory
argument_list|()
argument_list|)
decl_stmt|;
name|overseerCollectionProcessor
operator|=
operator|new
name|OverseerCollectionProcessor
argument_list|(
name|reader
argument_list|,
name|id
argument_list|,
name|shardHandler
argument_list|,
name|adminPath
argument_list|,
name|stats
argument_list|,
name|Overseer
operator|.
name|this
argument_list|,
name|overseerPrioritizer
argument_list|)
expr_stmt|;
name|ccThread
operator|=
operator|new
name|OverseerThread
argument_list|(
name|ccTg
argument_list|,
name|overseerCollectionProcessor
argument_list|,
literal|"OverseerCollectionProcessor-"
operator|+
name|id
argument_list|)
expr_stmt|;
name|ccThread
operator|.
name|setDaemon
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|ThreadGroup
name|ohcfTg
init|=
operator|new
name|ThreadGroup
argument_list|(
literal|"Overseer Hdfs SolrCore Failover Thread."
argument_list|)
decl_stmt|;
name|OverseerAutoReplicaFailoverThread
name|autoReplicaFailoverThread
init|=
operator|new
name|OverseerAutoReplicaFailoverThread
argument_list|(
name|config
argument_list|,
name|reader
argument_list|,
name|updateShardHandler
argument_list|)
decl_stmt|;
name|arfoThread
operator|=
operator|new
name|OverseerThread
argument_list|(
name|ohcfTg
argument_list|,
name|autoReplicaFailoverThread
argument_list|,
literal|"OverseerHdfsCoreFailoverThread-"
operator|+
name|id
argument_list|)
expr_stmt|;
name|arfoThread
operator|.
name|setDaemon
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|updaterThread
operator|.
name|start
argument_list|()
expr_stmt|;
name|ccThread
operator|.
name|start
argument_list|()
expr_stmt|;
name|arfoThread
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
DECL|method|getStats
specifier|public
name|Stats
name|getStats
parameter_list|()
block|{
return|return
name|stats
return|;
block|}
DECL|method|getZkController
name|ZkController
name|getZkController
parameter_list|()
block|{
return|return
name|zkController
return|;
block|}
comment|/**    * For tests.    *     * @lucene.internal    * @return state updater thread    */
DECL|method|getUpdaterThread
specifier|public
specifier|synchronized
name|OverseerThread
name|getUpdaterThread
parameter_list|()
block|{
return|return
name|updaterThread
return|;
block|}
DECL|method|close
specifier|public
specifier|synchronized
name|void
name|close
parameter_list|()
block|{
if|if
condition|(
name|closed
condition|)
return|return;
name|log
operator|.
name|info
argument_list|(
literal|"Overseer (id="
operator|+
name|id
operator|+
literal|") closing"
argument_list|)
expr_stmt|;
name|doClose
argument_list|()
expr_stmt|;
name|this
operator|.
name|closed
operator|=
literal|true
expr_stmt|;
block|}
DECL|method|doClose
specifier|private
name|void
name|doClose
parameter_list|()
block|{
if|if
condition|(
name|updaterThread
operator|!=
literal|null
condition|)
block|{
name|IOUtils
operator|.
name|closeQuietly
argument_list|(
name|updaterThread
argument_list|)
expr_stmt|;
name|updaterThread
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|ccThread
operator|!=
literal|null
condition|)
block|{
name|IOUtils
operator|.
name|closeQuietly
argument_list|(
name|ccThread
argument_list|)
expr_stmt|;
name|ccThread
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|arfoThread
operator|!=
literal|null
condition|)
block|{
name|IOUtils
operator|.
name|closeQuietly
argument_list|(
name|arfoThread
argument_list|)
expr_stmt|;
name|arfoThread
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
name|updaterThread
operator|=
literal|null
expr_stmt|;
name|ccThread
operator|=
literal|null
expr_stmt|;
name|arfoThread
operator|=
literal|null
expr_stmt|;
block|}
comment|/**    * Get queue that can be used to send messages to Overseer.    */
DECL|method|getInQueue
specifier|public
specifier|static
name|DistributedQueue
name|getInQueue
parameter_list|(
specifier|final
name|SolrZkClient
name|zkClient
parameter_list|)
block|{
return|return
name|getInQueue
argument_list|(
name|zkClient
argument_list|,
operator|new
name|Stats
argument_list|()
argument_list|)
return|;
block|}
DECL|method|getInQueue
specifier|static
name|DistributedQueue
name|getInQueue
parameter_list|(
specifier|final
name|SolrZkClient
name|zkClient
parameter_list|,
name|Stats
name|zkStats
parameter_list|)
block|{
name|createOverseerNode
argument_list|(
name|zkClient
argument_list|)
expr_stmt|;
return|return
operator|new
name|DistributedQueue
argument_list|(
name|zkClient
argument_list|,
literal|"/overseer/queue"
argument_list|,
name|zkStats
argument_list|)
return|;
block|}
comment|/* Internal queue, not to be used outside of Overseer */
DECL|method|getInternalQueue
specifier|static
name|DistributedQueue
name|getInternalQueue
parameter_list|(
specifier|final
name|SolrZkClient
name|zkClient
parameter_list|,
name|Stats
name|zkStats
parameter_list|)
block|{
name|createOverseerNode
argument_list|(
name|zkClient
argument_list|)
expr_stmt|;
return|return
operator|new
name|DistributedQueue
argument_list|(
name|zkClient
argument_list|,
literal|"/overseer/queue-work"
argument_list|,
name|zkStats
argument_list|)
return|;
block|}
comment|/* Internal map for failed tasks, not to be used outside of the Overseer */
DECL|method|getRunningMap
specifier|static
name|DistributedMap
name|getRunningMap
parameter_list|(
specifier|final
name|SolrZkClient
name|zkClient
parameter_list|)
block|{
name|createOverseerNode
argument_list|(
name|zkClient
argument_list|)
expr_stmt|;
return|return
operator|new
name|DistributedMap
argument_list|(
name|zkClient
argument_list|,
literal|"/overseer/collection-map-running"
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/* Size-limited map for successfully completed tasks*/
DECL|method|getCompletedMap
specifier|static
name|DistributedMap
name|getCompletedMap
parameter_list|(
specifier|final
name|SolrZkClient
name|zkClient
parameter_list|)
block|{
name|createOverseerNode
argument_list|(
name|zkClient
argument_list|)
expr_stmt|;
return|return
operator|new
name|SizeLimitedDistributedMap
argument_list|(
name|zkClient
argument_list|,
literal|"/overseer/collection-map-completed"
argument_list|,
literal|null
argument_list|,
name|NUM_RESPONSES_TO_STORE
argument_list|)
return|;
block|}
comment|/* Map for failed tasks, not to be used outside of the Overseer */
DECL|method|getFailureMap
specifier|static
name|DistributedMap
name|getFailureMap
parameter_list|(
specifier|final
name|SolrZkClient
name|zkClient
parameter_list|)
block|{
name|createOverseerNode
argument_list|(
name|zkClient
argument_list|)
expr_stmt|;
return|return
operator|new
name|SizeLimitedDistributedMap
argument_list|(
name|zkClient
argument_list|,
literal|"/overseer/collection-map-failure"
argument_list|,
literal|null
argument_list|,
name|NUM_RESPONSES_TO_STORE
argument_list|)
return|;
block|}
comment|/* Collection creation queue */
DECL|method|getCollectionQueue
specifier|static
name|DistributedQueue
name|getCollectionQueue
parameter_list|(
specifier|final
name|SolrZkClient
name|zkClient
parameter_list|)
block|{
return|return
name|getCollectionQueue
argument_list|(
name|zkClient
argument_list|,
operator|new
name|Stats
argument_list|()
argument_list|)
return|;
block|}
DECL|method|getCollectionQueue
specifier|static
name|DistributedQueue
name|getCollectionQueue
parameter_list|(
specifier|final
name|SolrZkClient
name|zkClient
parameter_list|,
name|Stats
name|zkStats
parameter_list|)
block|{
name|createOverseerNode
argument_list|(
name|zkClient
argument_list|)
expr_stmt|;
return|return
operator|new
name|DistributedQueue
argument_list|(
name|zkClient
argument_list|,
literal|"/overseer/collection-queue-work"
argument_list|,
name|zkStats
argument_list|)
return|;
block|}
DECL|method|createOverseerNode
specifier|private
specifier|static
name|void
name|createOverseerNode
parameter_list|(
specifier|final
name|SolrZkClient
name|zkClient
parameter_list|)
block|{
try|try
block|{
name|zkClient
operator|.
name|create
argument_list|(
literal|"/overseer"
argument_list|,
operator|new
name|byte
index|[
literal|0
index|]
argument_list|,
name|CreateMode
operator|.
name|PERSISTENT
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|KeeperException
operator|.
name|NodeExistsException
name|e
parameter_list|)
block|{
comment|//ok
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"Could not create Overseer node"
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|KeeperException
name|e
parameter_list|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"Could not create Overseer node"
argument_list|,
name|e
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
DECL|method|isLegacy
specifier|public
specifier|static
name|boolean
name|isLegacy
parameter_list|(
name|Map
name|clusterProps
parameter_list|)
block|{
return|return
operator|!
literal|"false"
operator|.
name|equals
argument_list|(
name|clusterProps
operator|.
name|get
argument_list|(
name|ZkStateReader
operator|.
name|LEGACY_CLOUD
argument_list|)
argument_list|)
return|;
block|}
DECL|method|getZkStateReader
specifier|public
name|ZkStateReader
name|getZkStateReader
parameter_list|()
block|{
return|return
name|reader
return|;
block|}
comment|/**    * Used to hold statistics about overseer operations. It will be exposed    * to the OverseerCollectionProcessor to return statistics.    *    * This is experimental API and subject to change.    */
DECL|class|Stats
specifier|public
specifier|static
class|class
name|Stats
block|{
DECL|field|MAX_STORED_FAILURES
specifier|static
specifier|final
name|int
name|MAX_STORED_FAILURES
init|=
literal|10
decl_stmt|;
DECL|field|stats
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|Stat
argument_list|>
name|stats
init|=
operator|new
name|ConcurrentHashMap
argument_list|<>
argument_list|()
decl_stmt|;
DECL|field|queueLength
specifier|private
specifier|volatile
name|int
name|queueLength
decl_stmt|;
DECL|method|getStats
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|Stat
argument_list|>
name|getStats
parameter_list|()
block|{
return|return
name|stats
return|;
block|}
DECL|method|getSuccessCount
specifier|public
name|int
name|getSuccessCount
parameter_list|(
name|String
name|operation
parameter_list|)
block|{
name|Stat
name|stat
init|=
name|stats
operator|.
name|get
argument_list|(
name|operation
operator|.
name|toLowerCase
argument_list|(
name|Locale
operator|.
name|ROOT
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|stat
operator|==
literal|null
condition|?
literal|0
else|:
name|stat
operator|.
name|success
operator|.
name|get
argument_list|()
return|;
block|}
DECL|method|getErrorCount
specifier|public
name|int
name|getErrorCount
parameter_list|(
name|String
name|operation
parameter_list|)
block|{
name|Stat
name|stat
init|=
name|stats
operator|.
name|get
argument_list|(
name|operation
operator|.
name|toLowerCase
argument_list|(
name|Locale
operator|.
name|ROOT
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|stat
operator|==
literal|null
condition|?
literal|0
else|:
name|stat
operator|.
name|errors
operator|.
name|get
argument_list|()
return|;
block|}
DECL|method|success
specifier|public
name|void
name|success
parameter_list|(
name|String
name|operation
parameter_list|)
block|{
name|String
name|op
init|=
name|operation
operator|.
name|toLowerCase
argument_list|(
name|Locale
operator|.
name|ROOT
argument_list|)
decl_stmt|;
name|Stat
name|stat
init|=
name|stats
operator|.
name|get
argument_list|(
name|op
argument_list|)
decl_stmt|;
if|if
condition|(
name|stat
operator|==
literal|null
condition|)
block|{
name|stat
operator|=
operator|new
name|Stat
argument_list|()
expr_stmt|;
name|stats
operator|.
name|put
argument_list|(
name|op
argument_list|,
name|stat
argument_list|)
expr_stmt|;
block|}
name|stat
operator|.
name|success
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
block|}
DECL|method|error
specifier|public
name|void
name|error
parameter_list|(
name|String
name|operation
parameter_list|)
block|{
name|String
name|op
init|=
name|operation
operator|.
name|toLowerCase
argument_list|(
name|Locale
operator|.
name|ROOT
argument_list|)
decl_stmt|;
name|Stat
name|stat
init|=
name|stats
operator|.
name|get
argument_list|(
name|op
argument_list|)
decl_stmt|;
if|if
condition|(
name|stat
operator|==
literal|null
condition|)
block|{
name|stat
operator|=
operator|new
name|Stat
argument_list|()
expr_stmt|;
name|stats
operator|.
name|put
argument_list|(
name|op
argument_list|,
name|stat
argument_list|)
expr_stmt|;
block|}
name|stat
operator|.
name|errors
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
block|}
DECL|method|time
specifier|public
name|TimerContext
name|time
parameter_list|(
name|String
name|operation
parameter_list|)
block|{
name|String
name|op
init|=
name|operation
operator|.
name|toLowerCase
argument_list|(
name|Locale
operator|.
name|ROOT
argument_list|)
decl_stmt|;
name|Stat
name|stat
init|=
name|stats
operator|.
name|get
argument_list|(
name|op
argument_list|)
decl_stmt|;
if|if
condition|(
name|stat
operator|==
literal|null
condition|)
block|{
name|stat
operator|=
operator|new
name|Stat
argument_list|()
expr_stmt|;
name|stats
operator|.
name|put
argument_list|(
name|op
argument_list|,
name|stat
argument_list|)
expr_stmt|;
block|}
return|return
name|stat
operator|.
name|requestTime
operator|.
name|time
argument_list|()
return|;
block|}
DECL|method|storeFailureDetails
specifier|public
name|void
name|storeFailureDetails
parameter_list|(
name|String
name|operation
parameter_list|,
name|ZkNodeProps
name|request
parameter_list|,
name|SolrResponse
name|resp
parameter_list|)
block|{
name|String
name|op
init|=
name|operation
operator|.
name|toLowerCase
argument_list|(
name|Locale
operator|.
name|ROOT
argument_list|)
decl_stmt|;
name|Stat
name|stat
init|=
name|stats
operator|.
name|get
argument_list|(
name|op
argument_list|)
decl_stmt|;
if|if
condition|(
name|stat
operator|==
literal|null
condition|)
block|{
name|stat
operator|=
operator|new
name|Stat
argument_list|()
expr_stmt|;
name|stats
operator|.
name|put
argument_list|(
name|op
argument_list|,
name|stat
argument_list|)
expr_stmt|;
block|}
name|LinkedList
argument_list|<
name|FailedOp
argument_list|>
name|failedOps
init|=
name|stat
operator|.
name|failureDetails
decl_stmt|;
synchronized|synchronized
init|(
name|failedOps
init|)
block|{
if|if
condition|(
name|failedOps
operator|.
name|size
argument_list|()
operator|>=
name|MAX_STORED_FAILURES
condition|)
block|{
name|failedOps
operator|.
name|removeFirst
argument_list|()
expr_stmt|;
block|}
name|failedOps
operator|.
name|addLast
argument_list|(
operator|new
name|FailedOp
argument_list|(
name|request
argument_list|,
name|resp
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|getFailureDetails
specifier|public
name|List
argument_list|<
name|FailedOp
argument_list|>
name|getFailureDetails
parameter_list|(
name|String
name|operation
parameter_list|)
block|{
name|Stat
name|stat
init|=
name|stats
operator|.
name|get
argument_list|(
name|operation
operator|.
name|toLowerCase
argument_list|(
name|Locale
operator|.
name|ROOT
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|stat
operator|==
literal|null
operator|||
name|stat
operator|.
name|failureDetails
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
literal|null
return|;
name|LinkedList
argument_list|<
name|FailedOp
argument_list|>
name|failedOps
init|=
name|stat
operator|.
name|failureDetails
decl_stmt|;
synchronized|synchronized
init|(
name|failedOps
init|)
block|{
name|ArrayList
argument_list|<
name|FailedOp
argument_list|>
name|ret
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|failedOps
argument_list|)
decl_stmt|;
return|return
name|ret
return|;
block|}
block|}
DECL|method|getQueueLength
specifier|public
name|int
name|getQueueLength
parameter_list|()
block|{
return|return
name|queueLength
return|;
block|}
DECL|method|setQueueLength
specifier|public
name|void
name|setQueueLength
parameter_list|(
name|int
name|queueLength
parameter_list|)
block|{
name|this
operator|.
name|queueLength
operator|=
name|queueLength
expr_stmt|;
block|}
DECL|method|clear
specifier|public
name|void
name|clear
parameter_list|()
block|{
name|stats
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
block|}
DECL|class|Stat
specifier|public
specifier|static
class|class
name|Stat
block|{
DECL|field|success
specifier|public
specifier|final
name|AtomicInteger
name|success
decl_stmt|;
DECL|field|errors
specifier|public
specifier|final
name|AtomicInteger
name|errors
decl_stmt|;
DECL|field|requestTime
specifier|public
specifier|final
name|Timer
name|requestTime
decl_stmt|;
DECL|field|failureDetails
specifier|public
specifier|final
name|LinkedList
argument_list|<
name|FailedOp
argument_list|>
name|failureDetails
decl_stmt|;
DECL|method|Stat
specifier|public
name|Stat
parameter_list|()
block|{
name|this
operator|.
name|success
operator|=
operator|new
name|AtomicInteger
argument_list|()
expr_stmt|;
name|this
operator|.
name|errors
operator|=
operator|new
name|AtomicInteger
argument_list|()
expr_stmt|;
name|this
operator|.
name|requestTime
operator|=
operator|new
name|Timer
argument_list|(
name|TimeUnit
operator|.
name|MILLISECONDS
argument_list|,
name|TimeUnit
operator|.
name|MINUTES
argument_list|,
name|Clock
operator|.
name|defaultClock
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|failureDetails
operator|=
operator|new
name|LinkedList
argument_list|<>
argument_list|()
expr_stmt|;
block|}
block|}
DECL|class|FailedOp
specifier|public
specifier|static
class|class
name|FailedOp
block|{
DECL|field|req
specifier|public
specifier|final
name|ZkNodeProps
name|req
decl_stmt|;
DECL|field|resp
specifier|public
specifier|final
name|SolrResponse
name|resp
decl_stmt|;
DECL|method|FailedOp
specifier|public
name|FailedOp
parameter_list|(
name|ZkNodeProps
name|req
parameter_list|,
name|SolrResponse
name|resp
parameter_list|)
block|{
name|this
operator|.
name|req
operator|=
name|req
expr_stmt|;
name|this
operator|.
name|resp
operator|=
name|resp
expr_stmt|;
block|}
block|}
block|}
end_class
end_unit
