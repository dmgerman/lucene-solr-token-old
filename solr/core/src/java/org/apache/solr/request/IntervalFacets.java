begin_unit
begin_package
DECL|package|org.apache.solr.request
package|package
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|request
package|;
end_package
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Date
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Locale
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|document
operator|.
name|FieldType
operator|.
name|NumericType
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|LeafReaderContext
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|DocValues
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|NumericDocValues
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|SortedDocValues
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|SortedSetDocValues
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|DocIdSet
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|DocIdSetIterator
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|Filter
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|Bits
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|BytesRef
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|NumericUtils
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|SolrException
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|params
operator|.
name|CommonParams
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|params
operator|.
name|SolrParams
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|request
operator|.
name|IntervalFacets
operator|.
name|FacetInterval
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|schema
operator|.
name|FieldType
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|schema
operator|.
name|SchemaField
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|schema
operator|.
name|TrieDateField
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|search
operator|.
name|DocIterator
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|search
operator|.
name|DocSet
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|search
operator|.
name|QueryParsing
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|search
operator|.
name|SolrIndexSearcher
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|search
operator|.
name|SyntaxError
import|;
end_import
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_comment
comment|/**  * Computes interval facets for docvalues field (single or multivalued).  *<p>  * Given a set of intervals for a field and a DocSet, it calculates the number  * of documents that match each of the intervals provided. The final count for  * each interval should be exactly the same as the number of results of a range  * query using the DocSet and the range as filters. This means that the count  * of {@code facet.query=field:[A TO B]} should be the same as the count of  * {@code f.field.facet.interval.set=[A,B]}, however, this method will usually  * be faster in cases where there are a larger number of intervals per field.  *<p>  * To use this class, create an instance using  * {@link #IntervalFacets(SchemaField, SolrIndexSearcher, DocSet, String[], SolrParams)}  * and then iterate the {@link FacetInterval} using {@link #iterator()}  *<p>  * Intervals Format<br>  * Intervals must begin with either '(' or '[', be followed by the start value,  * then a comma ',', the end value, and finally ')' or ']'. For example:  *<ul>  *<li> (1,10) -&gt; will include values greater than 1 and lower than 10  *<li> [1,10) -&gt; will include values greater or equal to 1 and lower than 10  *<li> [1,10] -&gt; will include values greater or equal to 1 and lower or equal to 10  *</ul>  * The initial and end values can't be empty, if the interval needs to be unbounded,  * the special character '*' can be used for both, start and end limit. When using  * '*', '(' and '[', and ')' and ']' will be treated equal. [*,*] will include all  * documents with a value in the field<p>  * The interval limits may be strings, there is no need to add quotes, all the text  * until the comma will be treated as the start limit, and the text after that will be  * the end limit, for example: [Buenos Aires,New York]. Keep in mind that a string-like  * comparison will be done to match documents in string intervals (case-sensitive). The  * comparator can't be changed.  * Commas, brackets and square brackets can be escaped by using '\' in front of them.  * Whitespaces before and after the values will be omitted. Start limit can't be grater  * than the end limit. Equal limits are allowed.<p>  * As with facet.query, the key used to display the result can be set by using local params  * syntax, for example:<p>  *<code>{!key='First Half'}[0,5)</code>  *<p>  * To use this class:  *<pre>  * IntervalFacets intervalFacets = new IntervalFacets(schemaField, searcher, docs, intervalStrs, params);  * for (FacetInterval interval : intervalFacets) {  *     results.add(interval.getKey(), interval.getCount());  * }  *</pre>  */
end_comment
begin_class
DECL|class|IntervalFacets
specifier|public
class|class
name|IntervalFacets
implements|implements
name|Iterable
argument_list|<
name|FacetInterval
argument_list|>
block|{
DECL|field|schemaField
specifier|private
specifier|final
name|SchemaField
name|schemaField
decl_stmt|;
DECL|field|searcher
specifier|private
specifier|final
name|SolrIndexSearcher
name|searcher
decl_stmt|;
DECL|field|docs
specifier|private
specifier|final
name|DocSet
name|docs
decl_stmt|;
DECL|field|intervals
specifier|private
specifier|final
name|FacetInterval
index|[]
name|intervals
decl_stmt|;
comment|/**    * Constructor that accepts un-parsed intervals using "interval faceting" syntax. See {@link IntervalFacets} for syntax.    * Intervals don't need to be in order.    */
DECL|method|IntervalFacets
specifier|public
name|IntervalFacets
parameter_list|(
name|SchemaField
name|schemaField
parameter_list|,
name|SolrIndexSearcher
name|searcher
parameter_list|,
name|DocSet
name|docs
parameter_list|,
name|String
index|[]
name|intervals
parameter_list|,
name|SolrParams
name|params
parameter_list|)
throws|throws
name|SyntaxError
throws|,
name|IOException
block|{
name|this
operator|.
name|schemaField
operator|=
name|schemaField
expr_stmt|;
name|this
operator|.
name|searcher
operator|=
name|searcher
expr_stmt|;
name|this
operator|.
name|docs
operator|=
name|docs
expr_stmt|;
name|this
operator|.
name|intervals
operator|=
name|getSortedIntervals
argument_list|(
name|intervals
argument_list|,
name|params
argument_list|)
expr_stmt|;
name|doCount
argument_list|()
expr_stmt|;
block|}
comment|/**    * Constructor that accepts an already constructed array of {@link FacetInterval} objects. This array needs to be sorted    * by start value in weakly ascending order. null values are not allowed in the array.    */
DECL|method|IntervalFacets
name|IntervalFacets
parameter_list|(
name|SchemaField
name|schemaField
parameter_list|,
name|SolrIndexSearcher
name|searcher
parameter_list|,
name|DocSet
name|docs
parameter_list|,
name|FacetInterval
index|[]
name|intervals
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|schemaField
operator|=
name|schemaField
expr_stmt|;
name|this
operator|.
name|searcher
operator|=
name|searcher
expr_stmt|;
name|this
operator|.
name|docs
operator|=
name|docs
expr_stmt|;
name|this
operator|.
name|intervals
operator|=
name|intervals
expr_stmt|;
name|doCount
argument_list|()
expr_stmt|;
block|}
DECL|method|getSortedIntervals
specifier|private
name|FacetInterval
index|[]
name|getSortedIntervals
parameter_list|(
name|String
index|[]
name|intervals
parameter_list|,
name|SolrParams
name|params
parameter_list|)
throws|throws
name|SyntaxError
block|{
name|FacetInterval
index|[]
name|sortedIntervals
init|=
operator|new
name|FacetInterval
index|[
name|intervals
operator|.
name|length
index|]
decl_stmt|;
name|int
name|idx
init|=
literal|0
decl_stmt|;
for|for
control|(
name|String
name|intervalStr
range|:
name|intervals
control|)
block|{
name|sortedIntervals
index|[
name|idx
operator|++
index|]
operator|=
operator|new
name|FacetInterval
argument_list|(
name|schemaField
argument_list|,
name|intervalStr
argument_list|,
name|params
argument_list|)
expr_stmt|;
block|}
comment|/*      * This comparator sorts the intervals by start value from lower to greater      */
name|Arrays
operator|.
name|sort
argument_list|(
name|sortedIntervals
argument_list|,
operator|new
name|Comparator
argument_list|<
name|FacetInterval
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|int
name|compare
parameter_list|(
name|FacetInterval
name|o1
parameter_list|,
name|FacetInterval
name|o2
parameter_list|)
block|{
assert|assert
name|o1
operator|!=
literal|null
assert|;
assert|assert
name|o2
operator|!=
literal|null
assert|;
return|return
name|compareStart
argument_list|(
name|o1
argument_list|,
name|o2
argument_list|)
return|;
block|}
specifier|private
name|int
name|compareStart
parameter_list|(
name|FacetInterval
name|o1
parameter_list|,
name|FacetInterval
name|o2
parameter_list|)
block|{
if|if
condition|(
name|o1
operator|.
name|start
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|o2
operator|.
name|start
operator|==
literal|null
condition|)
block|{
return|return
literal|0
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|o2
operator|.
name|start
operator|==
literal|null
condition|)
block|{
return|return
literal|1
return|;
block|}
return|return
name|o1
operator|.
name|start
operator|.
name|compareTo
argument_list|(
name|o2
operator|.
name|start
argument_list|)
return|;
block|}
block|}
argument_list|)
expr_stmt|;
return|return
name|sortedIntervals
return|;
block|}
DECL|method|doCount
specifier|private
name|void
name|doCount
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|schemaField
operator|.
name|getType
argument_list|()
operator|.
name|getNumericType
argument_list|()
operator|!=
literal|null
operator|&&
operator|!
name|schemaField
operator|.
name|multiValued
argument_list|()
condition|)
block|{
name|getCountNumeric
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|getCountString
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|getCountNumeric
specifier|private
name|void
name|getCountNumeric
parameter_list|()
throws|throws
name|IOException
block|{
specifier|final
name|FieldType
name|ft
init|=
name|schemaField
operator|.
name|getType
argument_list|()
decl_stmt|;
specifier|final
name|String
name|fieldName
init|=
name|schemaField
operator|.
name|getName
argument_list|()
decl_stmt|;
specifier|final
name|NumericType
name|numericType
init|=
name|ft
operator|.
name|getNumericType
argument_list|()
decl_stmt|;
if|if
condition|(
name|numericType
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|()
throw|;
block|}
specifier|final
name|List
argument_list|<
name|LeafReaderContext
argument_list|>
name|leaves
init|=
name|searcher
operator|.
name|getIndexReader
argument_list|()
operator|.
name|leaves
argument_list|()
decl_stmt|;
specifier|final
name|Iterator
argument_list|<
name|LeafReaderContext
argument_list|>
name|ctxIt
init|=
name|leaves
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|LeafReaderContext
name|ctx
init|=
literal|null
decl_stmt|;
name|NumericDocValues
name|longs
init|=
literal|null
decl_stmt|;
name|Bits
name|docsWithField
init|=
literal|null
decl_stmt|;
for|for
control|(
name|DocIterator
name|docsIt
init|=
name|docs
operator|.
name|iterator
argument_list|()
init|;
name|docsIt
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
specifier|final
name|int
name|doc
init|=
name|docsIt
operator|.
name|nextDoc
argument_list|()
decl_stmt|;
if|if
condition|(
name|ctx
operator|==
literal|null
operator|||
name|doc
operator|>=
name|ctx
operator|.
name|docBase
operator|+
name|ctx
operator|.
name|reader
argument_list|()
operator|.
name|maxDoc
argument_list|()
condition|)
block|{
do|do
block|{
name|ctx
operator|=
name|ctxIt
operator|.
name|next
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
name|ctx
operator|==
literal|null
operator|||
name|doc
operator|>=
name|ctx
operator|.
name|docBase
operator|+
name|ctx
operator|.
name|reader
argument_list|()
operator|.
name|maxDoc
argument_list|()
condition|)
do|;
assert|assert
name|doc
operator|>=
name|ctx
operator|.
name|docBase
assert|;
switch|switch
condition|(
name|numericType
condition|)
block|{
case|case
name|LONG
case|:
name|longs
operator|=
name|DocValues
operator|.
name|getNumeric
argument_list|(
name|ctx
operator|.
name|reader
argument_list|()
argument_list|,
name|fieldName
argument_list|)
expr_stmt|;
break|break;
case|case
name|INT
case|:
name|longs
operator|=
name|DocValues
operator|.
name|getNumeric
argument_list|(
name|ctx
operator|.
name|reader
argument_list|()
argument_list|,
name|fieldName
argument_list|)
expr_stmt|;
break|break;
case|case
name|FLOAT
case|:
specifier|final
name|NumericDocValues
name|floats
init|=
name|DocValues
operator|.
name|getNumeric
argument_list|(
name|ctx
operator|.
name|reader
argument_list|()
argument_list|,
name|fieldName
argument_list|)
decl_stmt|;
comment|// TODO: this bit flipping should probably be moved to tie-break in the PQ comparator
name|longs
operator|=
operator|new
name|NumericDocValues
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|long
name|get
parameter_list|(
name|int
name|docID
parameter_list|)
block|{
name|long
name|bits
init|=
name|floats
operator|.
name|get
argument_list|(
name|docID
argument_list|)
decl_stmt|;
if|if
condition|(
name|bits
operator|<
literal|0
condition|)
name|bits
operator|^=
literal|0x7fffffffffffffffL
expr_stmt|;
return|return
name|bits
return|;
block|}
block|}
expr_stmt|;
break|break;
case|case
name|DOUBLE
case|:
specifier|final
name|NumericDocValues
name|doubles
init|=
name|DocValues
operator|.
name|getNumeric
argument_list|(
name|ctx
operator|.
name|reader
argument_list|()
argument_list|,
name|fieldName
argument_list|)
decl_stmt|;
comment|// TODO: this bit flipping should probably be moved to tie-break in the PQ comparator
name|longs
operator|=
operator|new
name|NumericDocValues
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|long
name|get
parameter_list|(
name|int
name|docID
parameter_list|)
block|{
name|long
name|bits
init|=
name|doubles
operator|.
name|get
argument_list|(
name|docID
argument_list|)
decl_stmt|;
if|if
condition|(
name|bits
operator|<
literal|0
condition|)
name|bits
operator|^=
literal|0x7fffffffffffffffL
expr_stmt|;
return|return
name|bits
return|;
block|}
block|}
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|AssertionError
argument_list|()
throw|;
block|}
name|docsWithField
operator|=
name|DocValues
operator|.
name|getDocsWithField
argument_list|(
name|ctx
operator|.
name|reader
argument_list|()
argument_list|,
name|schemaField
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|long
name|v
init|=
name|longs
operator|.
name|get
argument_list|(
name|doc
operator|-
name|ctx
operator|.
name|docBase
argument_list|)
decl_stmt|;
if|if
condition|(
name|v
operator|!=
literal|0
operator|||
name|docsWithField
operator|.
name|get
argument_list|(
name|doc
operator|-
name|ctx
operator|.
name|docBase
argument_list|)
condition|)
block|{
name|accumIntervalWithValue
argument_list|(
name|v
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|getCountString
specifier|private
name|void
name|getCountString
parameter_list|()
throws|throws
name|IOException
block|{
name|Filter
name|filter
init|=
name|docs
operator|.
name|getTopFilter
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|LeafReaderContext
argument_list|>
name|leaves
init|=
name|searcher
operator|.
name|getTopReaderContext
argument_list|()
operator|.
name|leaves
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|subIndex
init|=
literal|0
init|;
name|subIndex
operator|<
name|leaves
operator|.
name|size
argument_list|()
condition|;
name|subIndex
operator|++
control|)
block|{
name|LeafReaderContext
name|leaf
init|=
name|leaves
operator|.
name|get
argument_list|(
name|subIndex
argument_list|)
decl_stmt|;
name|DocIdSet
name|dis
init|=
name|filter
operator|.
name|getDocIdSet
argument_list|(
name|leaf
argument_list|,
literal|null
argument_list|)
decl_stmt|;
comment|// solr docsets already exclude any deleted docs
if|if
condition|(
name|dis
operator|==
literal|null
condition|)
block|{
continue|continue;
block|}
name|DocIdSetIterator
name|disi
init|=
name|dis
operator|.
name|iterator
argument_list|()
decl_stmt|;
if|if
condition|(
name|disi
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|schemaField
operator|.
name|multiValued
argument_list|()
condition|)
block|{
name|SortedSetDocValues
name|sub
init|=
name|leaf
operator|.
name|reader
argument_list|()
operator|.
name|getSortedSetDocValues
argument_list|(
name|schemaField
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|sub
operator|==
literal|null
condition|)
block|{
continue|continue;
block|}
specifier|final
name|SortedDocValues
name|singleton
init|=
name|DocValues
operator|.
name|unwrapSingleton
argument_list|(
name|sub
argument_list|)
decl_stmt|;
if|if
condition|(
name|singleton
operator|!=
literal|null
condition|)
block|{
comment|// some codecs may optimize SORTED_SET storage for single-valued fields
name|accumIntervalsSingle
argument_list|(
name|singleton
argument_list|,
name|disi
argument_list|,
name|dis
operator|.
name|bits
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|accumIntervalsMulti
argument_list|(
name|sub
argument_list|,
name|disi
argument_list|,
name|dis
operator|.
name|bits
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|SortedDocValues
name|sub
init|=
name|leaf
operator|.
name|reader
argument_list|()
operator|.
name|getSortedDocValues
argument_list|(
name|schemaField
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|sub
operator|==
literal|null
condition|)
block|{
continue|continue;
block|}
name|accumIntervalsSingle
argument_list|(
name|sub
argument_list|,
name|disi
argument_list|,
name|dis
operator|.
name|bits
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
DECL|method|accumIntervalsMulti
specifier|private
name|void
name|accumIntervalsMulti
parameter_list|(
name|SortedSetDocValues
name|ssdv
parameter_list|,
name|DocIdSetIterator
name|disi
parameter_list|,
name|Bits
name|bits
parameter_list|)
throws|throws
name|IOException
block|{
comment|// First update the ordinals in the intervals for this segment
for|for
control|(
name|FacetInterval
name|interval
range|:
name|intervals
control|)
block|{
name|interval
operator|.
name|updateContext
argument_list|(
name|ssdv
argument_list|)
expr_stmt|;
block|}
name|int
name|doc
decl_stmt|;
while|while
condition|(
operator|(
name|doc
operator|=
name|disi
operator|.
name|nextDoc
argument_list|()
operator|)
operator|!=
name|DocIdSetIterator
operator|.
name|NO_MORE_DOCS
condition|)
block|{
if|if
condition|(
name|bits
operator|!=
literal|null
operator|&&
name|bits
operator|.
name|get
argument_list|(
name|doc
argument_list|)
operator|==
literal|false
condition|)
block|{
continue|continue;
block|}
name|ssdv
operator|.
name|setDocument
argument_list|(
name|doc
argument_list|)
expr_stmt|;
name|long
name|currOrd
decl_stmt|;
name|int
name|currentInterval
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|(
name|currOrd
operator|=
name|ssdv
operator|.
name|nextOrd
argument_list|()
operator|)
operator|!=
name|SortedSetDocValues
operator|.
name|NO_MORE_ORDS
condition|)
block|{
name|boolean
name|evaluateNextInterval
init|=
literal|true
decl_stmt|;
while|while
condition|(
name|evaluateNextInterval
operator|&&
name|currentInterval
operator|<
name|intervals
operator|.
name|length
condition|)
block|{
name|IntervalCompareResult
name|result
init|=
name|intervals
index|[
name|currentInterval
index|]
operator|.
name|includes
argument_list|(
name|currOrd
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|result
condition|)
block|{
case|case
name|INCLUDED
case|:
comment|/*                * Increment the current interval and move to the next one using                * the same value                */
name|intervals
index|[
name|currentInterval
index|]
operator|.
name|incCount
argument_list|()
expr_stmt|;
name|currentInterval
operator|++
expr_stmt|;
break|break;
case|case
name|LOWER_THAN_START
case|:
comment|/*                * None of the next intervals will match this value (all of them have                 * higher start value). Move to the next value for this document.                 */
name|evaluateNextInterval
operator|=
literal|false
expr_stmt|;
break|break;
case|case
name|GREATER_THAN_END
case|:
comment|/*                * Next interval may match this value                */
name|currentInterval
operator|++
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
block|}
DECL|method|accumIntervalsSingle
specifier|private
name|void
name|accumIntervalsSingle
parameter_list|(
name|SortedDocValues
name|sdv
parameter_list|,
name|DocIdSetIterator
name|disi
parameter_list|,
name|Bits
name|bits
parameter_list|)
throws|throws
name|IOException
block|{
comment|// First update the ordinals in the intervals to this segment
for|for
control|(
name|FacetInterval
name|interval
range|:
name|intervals
control|)
block|{
name|interval
operator|.
name|updateContext
argument_list|(
name|sdv
argument_list|)
expr_stmt|;
block|}
name|int
name|doc
decl_stmt|;
while|while
condition|(
operator|(
name|doc
operator|=
name|disi
operator|.
name|nextDoc
argument_list|()
operator|)
operator|!=
name|DocIdSetIterator
operator|.
name|NO_MORE_DOCS
condition|)
block|{
if|if
condition|(
name|bits
operator|!=
literal|null
operator|&&
name|bits
operator|.
name|get
argument_list|(
name|doc
argument_list|)
operator|==
literal|false
condition|)
block|{
continue|continue;
block|}
name|int
name|ord
init|=
name|sdv
operator|.
name|getOrd
argument_list|(
name|doc
argument_list|)
decl_stmt|;
if|if
condition|(
name|ord
operator|>=
literal|0
condition|)
block|{
name|accumInterval
argument_list|(
name|ord
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|accumInterval
specifier|private
name|void
name|accumInterval
parameter_list|(
name|int
name|ordinal
parameter_list|)
block|{
assert|assert
name|ordinal
operator|>=
literal|0
assert|;
name|accumIntervalWithValue
argument_list|(
name|ordinal
argument_list|)
expr_stmt|;
block|}
DECL|method|accumIntervalWithValue
specifier|private
name|void
name|accumIntervalWithValue
parameter_list|(
name|long
name|value
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|intervals
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|FacetInterval
name|interval
init|=
name|intervals
index|[
name|i
index|]
decl_stmt|;
name|IntervalCompareResult
name|result
init|=
name|interval
operator|.
name|includes
argument_list|(
name|value
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|==
name|IntervalCompareResult
operator|.
name|INCLUDED
condition|)
block|{
name|interval
operator|.
name|incCount
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|result
operator|==
name|IntervalCompareResult
operator|.
name|LOWER_THAN_START
condition|)
block|{
comment|// All intervals after this will have equal or grater start value,
comment|// we can skip them
break|break;
block|}
block|}
block|}
DECL|enum|IntervalCompareResult
specifier|static
enum|enum
name|IntervalCompareResult
block|{
DECL|enum constant|LOWER_THAN_START
name|LOWER_THAN_START
block|,
DECL|enum constant|INCLUDED
name|INCLUDED
block|,
DECL|enum constant|GREATER_THAN_END
name|GREATER_THAN_END
block|,   }
comment|/**    * Helper class to match and count of documents in specified intervals    */
DECL|class|FacetInterval
specifier|static
class|class
name|FacetInterval
block|{
comment|/**      * Key to represent this interval      */
DECL|field|key
specifier|private
specifier|final
name|String
name|key
decl_stmt|;
comment|/**      * Start value for this interval as indicated in the request      */
DECL|field|start
specifier|final
name|BytesRef
name|start
decl_stmt|;
comment|/**      * End value for this interval as indicated in the request      */
DECL|field|end
specifier|final
name|BytesRef
name|end
decl_stmt|;
comment|/**      * Whether or not this interval includes or not the lower limit      */
DECL|field|startOpen
specifier|private
specifier|final
name|boolean
name|startOpen
decl_stmt|;
comment|/**      * Whether or not this interval includes or not the upper limit      */
DECL|field|endOpen
specifier|private
specifier|final
name|boolean
name|endOpen
decl_stmt|;
comment|/**      * Lower limit to which compare a document value. If the field in which we      * are faceting is single value numeric, then this number will be the      * {@code long} representation of {@link #start}, and in this case      * the limit doesn't need to be updated once it is set (will be set in the      * constructor and remain equal for the life of this object). If the field      * is multivalued and/or non-numeric, then this number will be the lower limit      * ordinal for a value to be included in this interval. In this case,      * {@link #startLimit} needs to be set using either {@link #updateContext(SortedDocValues)} or      * {@link #updateContext(SortedSetDocValues)} (depending on the field type) for      * every segment before calling {@link #includes(long)} for any document in the      * segment.      */
DECL|field|startLimit
specifier|private
name|long
name|startLimit
decl_stmt|;
comment|/**      * Upper limit to which compare a document value. If the field in which we      * are faceting is single value numeric, then this number will be the      * {@code long} representation of {@link #end}, and in this case      * the limit doesn't need to be updated once it is set (will be set in the      * constructor and remain equal for the life of this object). If the field      * is multivalued and/or non-numeric, then this number will be the upper limit      * ordinal for a value to be included in this interval. In this case,      * {@link #endLimit} needs to be set using either {@link #updateContext(SortedDocValues)} or      * {@link #updateContext(SortedSetDocValues)} (depending on the field type) for      * every segment before calling {@link #includes(long)} for any document in the      * segment.      */
DECL|field|endLimit
specifier|private
name|long
name|endLimit
decl_stmt|;
comment|/**      * The current count of documents in that match this interval      */
DECL|field|count
specifier|private
name|int
name|count
decl_stmt|;
comment|/**      *       * Constructor that accepts un-parsed interval faceting syntax. See {@link IntervalFacets} for details      *       * @param schemaField schemaField for this range      * @param intervalStr String the interval. See {@link IntervalFacets} for syntax      * @param params SolrParams of this request, mostly used to get local params      */
DECL|method|FacetInterval
name|FacetInterval
parameter_list|(
name|SchemaField
name|schemaField
parameter_list|,
name|String
name|intervalStr
parameter_list|,
name|SolrParams
name|params
parameter_list|)
throws|throws
name|SyntaxError
block|{
if|if
condition|(
name|intervalStr
operator|==
literal|null
condition|)
throw|throw
operator|new
name|SyntaxError
argument_list|(
literal|"empty facet interval"
argument_list|)
throw|;
name|intervalStr
operator|=
name|intervalStr
operator|.
name|trim
argument_list|()
expr_stmt|;
if|if
condition|(
name|intervalStr
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
throw|throw
operator|new
name|SyntaxError
argument_list|(
literal|"empty facet interval"
argument_list|)
throw|;
try|try
block|{
name|SolrParams
name|localParams
init|=
name|QueryParsing
operator|.
name|getLocalParams
argument_list|(
name|intervalStr
argument_list|,
name|params
argument_list|)
decl_stmt|;
if|if
condition|(
name|localParams
operator|!=
literal|null
condition|)
block|{
name|int
name|localParamEndIdx
init|=
literal|2
decl_stmt|;
comment|// omit index of {!
while|while
condition|(
literal|true
condition|)
block|{
name|localParamEndIdx
operator|=
name|intervalStr
operator|.
name|indexOf
argument_list|(
name|QueryParsing
operator|.
name|LOCALPARAM_END
argument_list|,
name|localParamEndIdx
argument_list|)
expr_stmt|;
comment|// Local param could be escaping '}'
if|if
condition|(
name|intervalStr
operator|.
name|charAt
argument_list|(
name|localParamEndIdx
operator|-
literal|1
argument_list|)
operator|!=
literal|'\\'
condition|)
block|{
break|break;
block|}
name|localParamEndIdx
operator|++
expr_stmt|;
block|}
name|intervalStr
operator|=
name|intervalStr
operator|.
name|substring
argument_list|(
name|localParamEndIdx
operator|+
literal|1
argument_list|)
expr_stmt|;
name|key
operator|=
name|localParams
operator|.
name|get
argument_list|(
name|CommonParams
operator|.
name|OUTPUT_KEY
argument_list|,
name|intervalStr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|key
operator|=
name|intervalStr
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|SyntaxError
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|SolrException
operator|.
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
name|e
argument_list|)
throw|;
block|}
if|if
condition|(
name|intervalStr
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
operator|==
literal|'('
condition|)
block|{
name|startOpen
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|intervalStr
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
operator|==
literal|'['
condition|)
block|{
name|startOpen
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|SyntaxError
argument_list|(
literal|"Invalid start character "
operator|+
name|intervalStr
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
operator|+
literal|" in facet interval "
operator|+
name|intervalStr
argument_list|)
throw|;
block|}
specifier|final
name|int
name|lastNdx
init|=
name|intervalStr
operator|.
name|length
argument_list|()
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|intervalStr
operator|.
name|charAt
argument_list|(
name|lastNdx
argument_list|)
operator|==
literal|')'
condition|)
block|{
name|endOpen
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|intervalStr
operator|.
name|charAt
argument_list|(
name|lastNdx
argument_list|)
operator|==
literal|']'
condition|)
block|{
name|endOpen
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|SyntaxError
argument_list|(
literal|"Invalid end character "
operator|+
name|intervalStr
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
operator|+
literal|" in facet interval "
operator|+
name|intervalStr
argument_list|)
throw|;
block|}
name|StringBuilder
name|startStr
init|=
operator|new
name|StringBuilder
argument_list|(
name|lastNdx
argument_list|)
decl_stmt|;
name|int
name|i
init|=
name|unescape
argument_list|(
name|intervalStr
argument_list|,
literal|1
argument_list|,
name|lastNdx
argument_list|,
name|startStr
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|==
name|lastNdx
condition|)
block|{
if|if
condition|(
name|intervalStr
operator|.
name|charAt
argument_list|(
name|lastNdx
operator|-
literal|1
argument_list|)
operator|==
literal|','
condition|)
block|{
throw|throw
operator|new
name|SyntaxError
argument_list|(
literal|"Empty interval limit"
argument_list|)
throw|;
block|}
throw|throw
operator|new
name|SyntaxError
argument_list|(
literal|"Missing unescaped comma separating interval ends in "
operator|+
name|intervalStr
argument_list|)
throw|;
block|}
try|try
block|{
name|start
operator|=
name|getLimitFromString
argument_list|(
name|schemaField
argument_list|,
name|startStr
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SyntaxError
decl||
name|SolrException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SyntaxError
argument_list|(
name|String
operator|.
name|format
argument_list|(
name|Locale
operator|.
name|ROOT
argument_list|,
literal|"Invalid start interval for key '%s': %s"
argument_list|,
name|key
argument_list|,
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
argument_list|,
name|e
argument_list|)
throw|;
block|}
name|StringBuilder
name|endStr
init|=
operator|new
name|StringBuilder
argument_list|(
name|lastNdx
argument_list|)
decl_stmt|;
name|i
operator|=
name|unescape
argument_list|(
name|intervalStr
argument_list|,
name|i
argument_list|,
name|lastNdx
argument_list|,
name|endStr
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|lastNdx
condition|)
block|{
throw|throw
operator|new
name|SyntaxError
argument_list|(
literal|"Extra unescaped comma at index "
operator|+
name|i
operator|+
literal|" in interval "
operator|+
name|intervalStr
argument_list|)
throw|;
block|}
try|try
block|{
name|end
operator|=
name|getLimitFromString
argument_list|(
name|schemaField
argument_list|,
name|endStr
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SyntaxError
decl||
name|SolrException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SyntaxError
argument_list|(
name|String
operator|.
name|format
argument_list|(
name|Locale
operator|.
name|ROOT
argument_list|,
literal|"Invalid end interval for key '%s': %s"
argument_list|,
name|key
argument_list|,
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
argument_list|,
name|e
argument_list|)
throw|;
block|}
comment|// TODO: what about escaping star (*)?
comment|// TODO: escaping spaces on ends?
if|if
condition|(
name|schemaField
operator|.
name|getType
argument_list|()
operator|.
name|getNumericType
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|setNumericLimits
argument_list|(
name|schemaField
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|start
operator|!=
literal|null
operator|&&
name|end
operator|!=
literal|null
operator|&&
name|start
operator|.
name|compareTo
argument_list|(
name|end
argument_list|)
operator|>
literal|0
condition|)
block|{
throw|throw
operator|new
name|SyntaxError
argument_list|(
literal|"Start is higher than end in interval for key: "
operator|+
name|key
argument_list|)
throw|;
block|}
block|}
comment|/**      *       * Constructor that accepts already parsed values of start and end. This constructor      * can only be used with numeric field types.      *       * @param schemaField schemaField for this range      * @param startStr String representation of the start value of this interval. Can be a "*".      * @param endStr String representation of the end value of this interval. Can be a "*".      * @param includeLower Indicates weather this interval should include values equal to start      * @param includeUpper Indicates weather this interval should include values equal to end      * @param key String key of this interval      */
DECL|method|FacetInterval
name|FacetInterval
parameter_list|(
name|SchemaField
name|schemaField
parameter_list|,
name|String
name|startStr
parameter_list|,
name|String
name|endStr
parameter_list|,
name|boolean
name|includeLower
parameter_list|,
name|boolean
name|includeUpper
parameter_list|,
name|String
name|key
parameter_list|)
block|{
assert|assert
name|schemaField
operator|.
name|getType
argument_list|()
operator|.
name|getNumericType
argument_list|()
operator|!=
literal|null
operator|:
literal|"Only numeric fields supported with this constructor"
assert|;
name|this
operator|.
name|key
operator|=
name|key
expr_stmt|;
name|this
operator|.
name|startOpen
operator|=
operator|!
name|includeLower
expr_stmt|;
name|this
operator|.
name|endOpen
operator|=
operator|!
name|includeUpper
expr_stmt|;
name|this
operator|.
name|start
operator|=
name|getLimitFromString
argument_list|(
name|schemaField
argument_list|,
name|startStr
argument_list|)
expr_stmt|;
name|this
operator|.
name|end
operator|=
name|getLimitFromString
argument_list|(
name|schemaField
argument_list|,
name|endStr
argument_list|)
expr_stmt|;
assert|assert
name|start
operator|==
literal|null
operator|||
name|end
operator|==
literal|null
operator|||
name|start
operator|.
name|compareTo
argument_list|(
name|end
argument_list|)
operator|<
literal|0
operator|:
literal|"Bad start/end limits: "
operator|+
name|startStr
operator|+
literal|"/"
operator|+
name|endStr
assert|;
name|setNumericLimits
argument_list|(
name|schemaField
argument_list|)
expr_stmt|;
block|}
comment|/**      * Set startLimit and endLimit for numeric values. The limits in this case      * are going to be the<code>long</code> representation of the original      * value.<code>startLimit</code> will be incremented by one in case of the      * interval start being exclusive.<code>endLimit</code> will be decremented by      * one in case of the interval end being exclusive.      */
DECL|method|setNumericLimits
specifier|private
name|void
name|setNumericLimits
parameter_list|(
name|SchemaField
name|schemaField
parameter_list|)
block|{
if|if
condition|(
name|start
operator|==
literal|null
condition|)
block|{
name|startLimit
operator|=
name|Long
operator|.
name|MIN_VALUE
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|schemaField
operator|.
name|getType
argument_list|()
operator|.
name|getNumericType
argument_list|()
condition|)
block|{
case|case
name|LONG
case|:
if|if
condition|(
name|schemaField
operator|.
name|getType
argument_list|()
operator|instanceof
name|TrieDateField
condition|)
block|{
name|startLimit
operator|=
operator|(
operator|(
name|Date
operator|)
name|schemaField
operator|.
name|getType
argument_list|()
operator|.
name|toObject
argument_list|(
name|schemaField
argument_list|,
name|start
argument_list|)
operator|)
operator|.
name|getTime
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|startLimit
operator|=
operator|(
name|long
operator|)
name|schemaField
operator|.
name|getType
argument_list|()
operator|.
name|toObject
argument_list|(
name|schemaField
argument_list|,
name|start
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|INT
case|:
name|startLimit
operator|=
operator|(
operator|(
name|Integer
operator|)
name|schemaField
operator|.
name|getType
argument_list|()
operator|.
name|toObject
argument_list|(
name|schemaField
argument_list|,
name|start
argument_list|)
operator|)
operator|.
name|longValue
argument_list|()
expr_stmt|;
break|break;
case|case
name|FLOAT
case|:
name|startLimit
operator|=
name|NumericUtils
operator|.
name|floatToSortableInt
argument_list|(
operator|(
name|float
operator|)
name|schemaField
operator|.
name|getType
argument_list|()
operator|.
name|toObject
argument_list|(
name|schemaField
argument_list|,
name|start
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|DOUBLE
case|:
name|startLimit
operator|=
name|NumericUtils
operator|.
name|doubleToSortableLong
argument_list|(
operator|(
name|double
operator|)
name|schemaField
operator|.
name|getType
argument_list|()
operator|.
name|toObject
argument_list|(
name|schemaField
argument_list|,
name|start
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|AssertionError
argument_list|()
throw|;
block|}
if|if
condition|(
name|startOpen
condition|)
block|{
name|startLimit
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|end
operator|==
literal|null
condition|)
block|{
name|endLimit
operator|=
name|Long
operator|.
name|MAX_VALUE
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|schemaField
operator|.
name|getType
argument_list|()
operator|.
name|getNumericType
argument_list|()
condition|)
block|{
case|case
name|LONG
case|:
if|if
condition|(
name|schemaField
operator|.
name|getType
argument_list|()
operator|instanceof
name|TrieDateField
condition|)
block|{
name|endLimit
operator|=
operator|(
operator|(
name|Date
operator|)
name|schemaField
operator|.
name|getType
argument_list|()
operator|.
name|toObject
argument_list|(
name|schemaField
argument_list|,
name|end
argument_list|)
operator|)
operator|.
name|getTime
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|endLimit
operator|=
operator|(
name|long
operator|)
name|schemaField
operator|.
name|getType
argument_list|()
operator|.
name|toObject
argument_list|(
name|schemaField
argument_list|,
name|end
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|INT
case|:
name|endLimit
operator|=
operator|(
operator|(
name|Integer
operator|)
name|schemaField
operator|.
name|getType
argument_list|()
operator|.
name|toObject
argument_list|(
name|schemaField
argument_list|,
name|end
argument_list|)
operator|)
operator|.
name|longValue
argument_list|()
expr_stmt|;
break|break;
case|case
name|FLOAT
case|:
name|endLimit
operator|=
name|NumericUtils
operator|.
name|floatToSortableInt
argument_list|(
operator|(
name|float
operator|)
name|schemaField
operator|.
name|getType
argument_list|()
operator|.
name|toObject
argument_list|(
name|schemaField
argument_list|,
name|end
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|DOUBLE
case|:
name|endLimit
operator|=
name|NumericUtils
operator|.
name|doubleToSortableLong
argument_list|(
operator|(
name|double
operator|)
name|schemaField
operator|.
name|getType
argument_list|()
operator|.
name|toObject
argument_list|(
name|schemaField
argument_list|,
name|end
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|AssertionError
argument_list|()
throw|;
block|}
if|if
condition|(
name|endOpen
condition|)
block|{
name|endLimit
operator|--
expr_stmt|;
block|}
block|}
block|}
DECL|method|getLimitFromString
specifier|private
name|BytesRef
name|getLimitFromString
parameter_list|(
name|SchemaField
name|schemaField
parameter_list|,
name|StringBuilder
name|builder
parameter_list|)
throws|throws
name|SyntaxError
block|{
name|String
name|value
init|=
name|builder
operator|.
name|toString
argument_list|()
operator|.
name|trim
argument_list|()
decl_stmt|;
if|if
condition|(
name|value
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
block|{
throw|throw
operator|new
name|SyntaxError
argument_list|(
literal|"Empty interval limit"
argument_list|)
throw|;
block|}
return|return
name|getLimitFromString
argument_list|(
name|schemaField
argument_list|,
name|value
argument_list|)
return|;
block|}
DECL|method|getLimitFromString
specifier|private
name|BytesRef
name|getLimitFromString
parameter_list|(
name|SchemaField
name|schemaField
parameter_list|,
name|String
name|value
parameter_list|)
block|{
if|if
condition|(
literal|"*"
operator|.
name|equals
argument_list|(
name|value
argument_list|)
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
operator|new
name|BytesRef
argument_list|(
name|schemaField
operator|.
name|getType
argument_list|()
operator|.
name|toInternal
argument_list|(
name|value
argument_list|)
argument_list|)
return|;
block|}
comment|/**      * Update the ordinals based on the current reader. This method      * (or {@link #updateContext(SortedSetDocValues)} depending on the      * DocValues type) needs to be called for every reader before      * {@link #includes(long)} is called on any document of the reader.      *      * @param sdv DocValues for the current reader      */
DECL|method|updateContext
specifier|public
name|void
name|updateContext
parameter_list|(
name|SortedDocValues
name|sdv
parameter_list|)
block|{
if|if
condition|(
name|start
operator|==
literal|null
condition|)
block|{
comment|/*          * Unset start. All ordinals will be greater than -1.          */
name|startLimit
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|startLimit
operator|=
name|sdv
operator|.
name|lookupTerm
argument_list|(
name|start
argument_list|)
expr_stmt|;
if|if
condition|(
name|startLimit
operator|<
literal|0
condition|)
block|{
comment|/*            * The term was not found in this segment. We'll use inserting-point as            * start ordinal (then, to be included in the interval, an ordinal needs to be            * greater or equal to startLimit)            */
name|startLimit
operator|=
operator|(
name|startLimit
operator|*
operator|-
literal|1
operator|)
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/*            * The term exists in this segment, If the interval has start open (the limit is            * excluded), then we move one ordinal higher. Then, to be included in the             * interval, an ordinal needs to be greater or equal to startLimit            */
if|if
condition|(
name|startOpen
condition|)
block|{
name|startLimit
operator|++
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|end
operator|==
literal|null
condition|)
block|{
comment|/*          * Unset end. All ordinals will be lower than Long.MAX_VALUE.          */
name|endLimit
operator|=
name|Long
operator|.
name|MAX_VALUE
expr_stmt|;
block|}
else|else
block|{
name|endLimit
operator|=
name|sdv
operator|.
name|lookupTerm
argument_list|(
name|end
argument_list|)
expr_stmt|;
if|if
condition|(
name|endLimit
operator|<
literal|0
condition|)
block|{
comment|/*            * The term was not found in this segment. We'll use insertion-point -1 as            * endLimit. To be included in this interval, ordinals must be lower or             * equal to endLimit            */
name|endLimit
operator|=
operator|(
name|endLimit
operator|*
operator|-
literal|1
operator|)
operator|-
literal|2
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|endOpen
condition|)
block|{
comment|/*              * The term exists in this segment, If the interval has start open (the               * limit is excluded), then we move one ordinal lower. Then, to be              * included in the interval, an ordinal needs to be lower or equal to                * endLimit              */
name|endLimit
operator|--
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**      * Update the ordinals based on the current reader. This method      * (or {@link #updateContext(SortedDocValues)} depending on the      * DocValues type) needs to be called for every reader before      * {@link #includes(long)} is called on any document of the reader.      *      * @param sdv DocValues for the current reader      */
DECL|method|updateContext
specifier|public
name|void
name|updateContext
parameter_list|(
name|SortedSetDocValues
name|sdv
parameter_list|)
block|{
if|if
condition|(
name|start
operator|==
literal|null
condition|)
block|{
comment|/*          * Unset start. All ordinals will be greater than -1.          */
name|startLimit
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|startLimit
operator|=
name|sdv
operator|.
name|lookupTerm
argument_list|(
name|start
argument_list|)
expr_stmt|;
if|if
condition|(
name|startLimit
operator|<
literal|0
condition|)
block|{
comment|/*            * The term was not found in this segment. We'll use inserting-point as            * start ordinal (then, to be included in the interval, an ordinal needs to be            * greater or equal to startLimit)            */
name|startLimit
operator|=
operator|(
name|startLimit
operator|*
operator|-
literal|1
operator|)
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/*            * The term exists in this segment, If the interval has start open (the limit is            * excluded), then we move one ordinal higher. Then, to be included in the             * interval, an ordinal needs to be greater or equal to startLimit            */
if|if
condition|(
name|startOpen
condition|)
block|{
name|startLimit
operator|++
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|end
operator|==
literal|null
condition|)
block|{
comment|/*          * Unset end. All ordinals will be lower than Long.MAX_VALUE.          */
name|endLimit
operator|=
name|Long
operator|.
name|MAX_VALUE
expr_stmt|;
block|}
else|else
block|{
name|endLimit
operator|=
name|sdv
operator|.
name|lookupTerm
argument_list|(
name|end
argument_list|)
expr_stmt|;
if|if
condition|(
name|endLimit
operator|<
literal|0
condition|)
block|{
comment|/*            * The term was not found in this segment. We'll use insertion-point -1 as            * endLimit. To be included in this interval, ordinals must be lower or             * equal to endLimit            */
name|endLimit
operator|=
operator|(
name|endLimit
operator|*
operator|-
literal|1
operator|)
operator|-
literal|2
expr_stmt|;
block|}
else|else
block|{
comment|/*            * The term exists in this segment, If the interval has start open (the             * limit is excluded), then we move one ordinal lower. Then, to be            * included in the interval, an ordinal needs to be lower or equal to              * endLimit            */
if|if
condition|(
name|endOpen
condition|)
block|{
name|endLimit
operator|--
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**      * Method to use to check whether a document should be counted for      * an interval or not. Before calling this method on a multi-valued      * and/or non-numeric field make sure you call {@link #updateContext(SortedDocValues)}      * or {@link #updateContext(SortedSetDocValues)} (depending on the DV type). It      * is OK to call this method without other previous calls on numeric fields      * (with {@link NumericDocValues})      *      * @param value For numeric single value fields, this {@code value}      *              should be the {@code long} representation of the value of the document      *              in the specified field. For multi-valued and/or non-numeric fields, {@code value}      *              should be the ordinal of the term in the current segment      * @return<ul><li>{@link IntervalCompareResult#INCLUDED} if the value is included in the interval      *<li>{@link IntervalCompareResult#GREATER_THAN_END} if the value is greater than {@code endLimit}      *<li>{@link IntervalCompareResult#LOWER_THAN_START} if the value is lower than {@code startLimit}      *</ul>      * @see NumericUtils#floatToSortableInt(float)      * @see NumericUtils#doubleToSortableLong(double)      */
DECL|method|includes
specifier|public
name|IntervalCompareResult
name|includes
parameter_list|(
name|long
name|value
parameter_list|)
block|{
if|if
condition|(
name|startLimit
operator|>
name|value
condition|)
block|{
return|return
name|IntervalCompareResult
operator|.
name|LOWER_THAN_START
return|;
block|}
if|if
condition|(
name|endLimit
operator|<
name|value
condition|)
block|{
return|return
name|IntervalCompareResult
operator|.
name|GREATER_THAN_END
return|;
block|}
return|return
name|IntervalCompareResult
operator|.
name|INCLUDED
return|;
block|}
comment|/* Fill in sb with a string from i to the first unescaped comma, or n.        Return the index past the unescaped comma, or n if no unescaped comma exists */
DECL|method|unescape
specifier|private
name|int
name|unescape
parameter_list|(
name|String
name|s
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|n
parameter_list|,
name|StringBuilder
name|sb
parameter_list|)
throws|throws
name|SyntaxError
block|{
for|for
control|(
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
block|{
name|char
name|c
init|=
name|s
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
operator|++
name|i
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|n
condition|)
block|{
name|c
operator|=
name|s
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|SyntaxError
argument_list|(
literal|"Unfinished escape at index "
operator|+
name|i
operator|+
literal|" in facet interval "
operator|+
name|s
argument_list|)
throw|;
block|}
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|','
condition|)
block|{
return|return
name|i
operator|+
literal|1
return|;
block|}
name|sb
operator|.
name|append
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
return|return
name|n
return|;
block|}
annotation|@
name|Override
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|" [key="
operator|+
name|key
operator|+
literal|", start="
operator|+
name|start
operator|+
literal|", end="
operator|+
name|end
operator|+
literal|", startOpen="
operator|+
name|startOpen
operator|+
literal|", endOpen="
operator|+
name|endOpen
operator|+
literal|"]"
return|;
block|}
comment|/**      * @return The count of document that matched this interval      */
DECL|method|getCount
specifier|public
name|int
name|getCount
parameter_list|()
block|{
return|return
name|this
operator|.
name|count
return|;
block|}
comment|/**      * Increment the number of documents that match this interval      */
DECL|method|incCount
name|void
name|incCount
parameter_list|()
block|{
name|this
operator|.
name|count
operator|++
expr_stmt|;
block|}
comment|/**      * @return Human readable key for this interval      */
DECL|method|getKey
specifier|public
name|String
name|getKey
parameter_list|()
block|{
return|return
name|this
operator|.
name|key
return|;
block|}
block|}
comment|/**    * Iterate over all the intervals    */
annotation|@
name|Override
DECL|method|iterator
specifier|public
name|Iterator
argument_list|<
name|FacetInterval
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
operator|new
name|ArrayList
argument_list|<
name|FacetInterval
argument_list|>
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|intervals
argument_list|)
argument_list|)
operator|.
name|iterator
argument_list|()
return|;
block|}
block|}
end_class
end_unit
