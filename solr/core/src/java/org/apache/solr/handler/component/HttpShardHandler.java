begin_unit
begin_package
DECL|package|org.apache.solr.handler.component
package|package
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|handler
operator|.
name|component
package|;
end_package
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|invoke
operator|.
name|MethodHandles
import|;
end_import
begin_import
import|import
name|java
operator|.
name|net
operator|.
name|ConnectException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ListIterator
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Callable
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|CompletionService
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ExecutionException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Future
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|http
operator|.
name|client
operator|.
name|HttpClient
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|client
operator|.
name|solrj
operator|.
name|SolrClient
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|client
operator|.
name|solrj
operator|.
name|SolrRequest
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|client
operator|.
name|solrj
operator|.
name|SolrResponse
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|client
operator|.
name|solrj
operator|.
name|impl
operator|.
name|HttpSolrClient
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|client
operator|.
name|solrj
operator|.
name|impl
operator|.
name|LBHttpSolrClient
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|client
operator|.
name|solrj
operator|.
name|request
operator|.
name|QueryRequest
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|client
operator|.
name|solrj
operator|.
name|util
operator|.
name|ClientUtils
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|cloud
operator|.
name|CloudDescriptor
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|cloud
operator|.
name|ZkController
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|SolrException
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|cloud
operator|.
name|ClusterState
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|cloud
operator|.
name|DocCollection
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|cloud
operator|.
name|Replica
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|cloud
operator|.
name|Slice
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|cloud
operator|.
name|ZkCoreNodeProps
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|params
operator|.
name|CommonParams
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|params
operator|.
name|ModifiableSolrParams
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|params
operator|.
name|ShardParams
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|params
operator|.
name|SolrParams
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|util
operator|.
name|NamedList
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|util
operator|.
name|StrUtils
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|core
operator|.
name|CoreDescriptor
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|core
operator|.
name|SolrCore
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|request
operator|.
name|SolrQueryRequest
import|;
end_import
begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import
begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import
begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|MDC
import|;
end_import
begin_class
DECL|class|HttpShardHandler
specifier|public
class|class
name|HttpShardHandler
extends|extends
name|ShardHandler
block|{
DECL|field|httpShardHandlerFactory
specifier|private
name|HttpShardHandlerFactory
name|httpShardHandlerFactory
decl_stmt|;
DECL|field|completionService
specifier|private
name|CompletionService
argument_list|<
name|ShardResponse
argument_list|>
name|completionService
decl_stmt|;
DECL|field|pending
specifier|private
name|Set
argument_list|<
name|Future
argument_list|<
name|ShardResponse
argument_list|>
argument_list|>
name|pending
decl_stmt|;
DECL|field|shardToURLs
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|shardToURLs
decl_stmt|;
DECL|field|httpClient
specifier|private
name|HttpClient
name|httpClient
decl_stmt|;
DECL|field|log
specifier|private
specifier|static
specifier|final
name|Logger
name|log
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|MethodHandles
operator|.
name|lookup
argument_list|()
operator|.
name|lookupClass
argument_list|()
argument_list|)
decl_stmt|;
DECL|method|HttpShardHandler
specifier|public
name|HttpShardHandler
parameter_list|(
name|HttpShardHandlerFactory
name|httpShardHandlerFactory
parameter_list|,
name|HttpClient
name|httpClient
parameter_list|)
block|{
name|this
operator|.
name|httpClient
operator|=
name|httpClient
expr_stmt|;
name|this
operator|.
name|httpShardHandlerFactory
operator|=
name|httpShardHandlerFactory
expr_stmt|;
name|completionService
operator|=
name|httpShardHandlerFactory
operator|.
name|newCompletionService
argument_list|()
expr_stmt|;
name|pending
operator|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
expr_stmt|;
comment|// maps "localhost:8983|localhost:7574" to a shuffled List("http://localhost:8983","http://localhost:7574")
comment|// This is primarily to keep track of what order we should use to query the replicas of a shard
comment|// so that we use the same replica for all phases of a distributed request.
name|shardToURLs
operator|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
expr_stmt|;
block|}
DECL|class|SimpleSolrResponse
specifier|private
specifier|static
class|class
name|SimpleSolrResponse
extends|extends
name|SolrResponse
block|{
DECL|field|elapsedTime
name|long
name|elapsedTime
decl_stmt|;
DECL|field|nl
name|NamedList
argument_list|<
name|Object
argument_list|>
name|nl
decl_stmt|;
annotation|@
name|Override
DECL|method|getElapsedTime
specifier|public
name|long
name|getElapsedTime
parameter_list|()
block|{
return|return
name|elapsedTime
return|;
block|}
annotation|@
name|Override
DECL|method|getResponse
specifier|public
name|NamedList
argument_list|<
name|Object
argument_list|>
name|getResponse
parameter_list|()
block|{
return|return
name|nl
return|;
block|}
annotation|@
name|Override
DECL|method|setResponse
specifier|public
name|void
name|setResponse
parameter_list|(
name|NamedList
argument_list|<
name|Object
argument_list|>
name|rsp
parameter_list|)
block|{
name|nl
operator|=
name|rsp
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|setElapsedTime
specifier|public
name|void
name|setElapsedTime
parameter_list|(
name|long
name|elapsedTime
parameter_list|)
block|{
name|this
operator|.
name|elapsedTime
operator|=
name|elapsedTime
expr_stmt|;
block|}
block|}
comment|// Not thread safe... don't use in Callable.
comment|// Don't modify the returned URL list.
DECL|method|getURLs
specifier|private
name|List
argument_list|<
name|String
argument_list|>
name|getURLs
parameter_list|(
name|String
name|shard
parameter_list|,
name|String
name|preferredHostAddress
parameter_list|)
block|{
name|List
argument_list|<
name|String
argument_list|>
name|urls
init|=
name|shardToURLs
operator|.
name|get
argument_list|(
name|shard
argument_list|)
decl_stmt|;
if|if
condition|(
name|urls
operator|==
literal|null
condition|)
block|{
name|urls
operator|=
name|httpShardHandlerFactory
operator|.
name|makeURLList
argument_list|(
name|shard
argument_list|)
expr_stmt|;
if|if
condition|(
name|preferredHostAddress
operator|!=
literal|null
operator|&&
name|urls
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
name|preferCurrentHostForDistributedReq
argument_list|(
name|preferredHostAddress
argument_list|,
name|urls
argument_list|)
expr_stmt|;
block|}
name|shardToURLs
operator|.
name|put
argument_list|(
name|shard
argument_list|,
name|urls
argument_list|)
expr_stmt|;
block|}
return|return
name|urls
return|;
block|}
comment|/**    * A distributed request is made via {@link LBHttpSolrClient} to the first live server in the URL list.    * This means it is just as likely to choose current host as any of the other hosts.    * This function makes sure that the cores of current host are always put first in the URL list.    * If all nodes prefer local-cores then a bad/heavily-loaded node will receive less requests from healthy nodes.    * This will help prevent a distributed deadlock or timeouts in all the healthy nodes due to one bad node.    */
DECL|method|preferCurrentHostForDistributedReq
specifier|private
name|void
name|preferCurrentHostForDistributedReq
parameter_list|(
specifier|final
name|String
name|currentHostAddress
parameter_list|,
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|urls
parameter_list|)
block|{
if|if
condition|(
name|log
operator|.
name|isDebugEnabled
argument_list|()
condition|)
name|log
operator|.
name|debug
argument_list|(
literal|"Trying to prefer local shard on {} among the urls: {}"
argument_list|,
name|currentHostAddress
argument_list|,
name|Arrays
operator|.
name|toString
argument_list|(
name|urls
operator|.
name|toArray
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|ListIterator
argument_list|<
name|String
argument_list|>
name|itr
init|=
name|urls
operator|.
name|listIterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|itr
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|String
name|url
init|=
name|itr
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|url
operator|.
name|startsWith
argument_list|(
name|currentHostAddress
argument_list|)
condition|)
block|{
comment|// move current URL to the fore-front
name|itr
operator|.
name|remove
argument_list|()
expr_stmt|;
name|urls
operator|.
name|add
argument_list|(
literal|0
argument_list|,
name|url
argument_list|)
expr_stmt|;
if|if
condition|(
name|log
operator|.
name|isDebugEnabled
argument_list|()
condition|)
name|log
operator|.
name|debug
argument_list|(
literal|"Applied local shard preference for urls: {}"
argument_list|,
name|Arrays
operator|.
name|toString
argument_list|(
name|urls
operator|.
name|toArray
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
annotation|@
name|Override
DECL|method|submit
specifier|public
name|void
name|submit
parameter_list|(
specifier|final
name|ShardRequest
name|sreq
parameter_list|,
specifier|final
name|String
name|shard
parameter_list|,
specifier|final
name|ModifiableSolrParams
name|params
parameter_list|,
name|String
name|preferredHostAddress
parameter_list|)
block|{
comment|// do this outside of the callable for thread safety reasons
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|urls
init|=
name|getURLs
argument_list|(
name|shard
argument_list|,
name|preferredHostAddress
argument_list|)
decl_stmt|;
name|Callable
argument_list|<
name|ShardResponse
argument_list|>
name|task
init|=
operator|new
name|Callable
argument_list|<
name|ShardResponse
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|ShardResponse
name|call
parameter_list|()
throws|throws
name|Exception
block|{
name|ShardResponse
name|srsp
init|=
operator|new
name|ShardResponse
argument_list|()
decl_stmt|;
if|if
condition|(
name|sreq
operator|.
name|nodeName
operator|!=
literal|null
condition|)
block|{
name|srsp
operator|.
name|setNodeName
argument_list|(
name|sreq
operator|.
name|nodeName
argument_list|)
expr_stmt|;
block|}
name|srsp
operator|.
name|setShardRequest
argument_list|(
name|sreq
argument_list|)
expr_stmt|;
name|srsp
operator|.
name|setShard
argument_list|(
name|shard
argument_list|)
expr_stmt|;
name|SimpleSolrResponse
name|ssr
init|=
operator|new
name|SimpleSolrResponse
argument_list|()
decl_stmt|;
name|srsp
operator|.
name|setSolrResponse
argument_list|(
name|ssr
argument_list|)
expr_stmt|;
name|long
name|startTime
init|=
name|System
operator|.
name|nanoTime
argument_list|()
decl_stmt|;
try|try
block|{
name|params
operator|.
name|remove
argument_list|(
name|CommonParams
operator|.
name|WT
argument_list|)
expr_stmt|;
comment|// use default (currently javabin)
name|params
operator|.
name|remove
argument_list|(
name|CommonParams
operator|.
name|VERSION
argument_list|)
expr_stmt|;
name|QueryRequest
name|req
init|=
name|makeQueryRequest
argument_list|(
name|sreq
argument_list|,
name|params
argument_list|,
name|shard
argument_list|)
decl_stmt|;
name|req
operator|.
name|setMethod
argument_list|(
name|SolrRequest
operator|.
name|METHOD
operator|.
name|POST
argument_list|)
expr_stmt|;
comment|// no need to set the response parser as binary is the default
comment|// req.setResponseParser(new BinaryResponseParser());
comment|// if there are no shards available for a slice, urls.size()==0
if|if
condition|(
name|urls
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
comment|// TODO: what's the right error code here? We should use the same thing when
comment|// all of the servers for a shard are down.
throw|throw
operator|new
name|SolrException
argument_list|(
name|SolrException
operator|.
name|ErrorCode
operator|.
name|SERVICE_UNAVAILABLE
argument_list|,
literal|"no servers hosting shard: "
operator|+
name|shard
argument_list|)
throw|;
block|}
if|if
condition|(
name|urls
operator|.
name|size
argument_list|()
operator|<=
literal|1
condition|)
block|{
name|String
name|url
init|=
name|urls
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|srsp
operator|.
name|setShardAddress
argument_list|(
name|url
argument_list|)
expr_stmt|;
try|try
init|(
name|SolrClient
name|client
init|=
operator|new
name|HttpSolrClient
argument_list|(
name|url
argument_list|,
name|httpClient
argument_list|)
init|)
block|{
name|ssr
operator|.
name|nl
operator|=
name|client
operator|.
name|request
argument_list|(
name|req
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|LBHttpSolrClient
operator|.
name|Rsp
name|rsp
init|=
name|httpShardHandlerFactory
operator|.
name|makeLoadBalancedRequest
argument_list|(
name|req
argument_list|,
name|urls
argument_list|)
decl_stmt|;
name|ssr
operator|.
name|nl
operator|=
name|rsp
operator|.
name|getResponse
argument_list|()
expr_stmt|;
name|srsp
operator|.
name|setShardAddress
argument_list|(
name|rsp
operator|.
name|getServer
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|ConnectException
name|cex
parameter_list|)
block|{
name|srsp
operator|.
name|setException
argument_list|(
name|cex
argument_list|)
expr_stmt|;
comment|//????
block|}
catch|catch
parameter_list|(
name|Exception
name|th
parameter_list|)
block|{
name|srsp
operator|.
name|setException
argument_list|(
name|th
argument_list|)
expr_stmt|;
if|if
condition|(
name|th
operator|instanceof
name|SolrException
condition|)
block|{
name|srsp
operator|.
name|setResponseCode
argument_list|(
operator|(
operator|(
name|SolrException
operator|)
name|th
operator|)
operator|.
name|code
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|srsp
operator|.
name|setResponseCode
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|ssr
operator|.
name|elapsedTime
operator|=
name|TimeUnit
operator|.
name|MILLISECONDS
operator|.
name|convert
argument_list|(
name|System
operator|.
name|nanoTime
argument_list|()
operator|-
name|startTime
argument_list|,
name|TimeUnit
operator|.
name|NANOSECONDS
argument_list|)
expr_stmt|;
return|return
name|transfomResponse
argument_list|(
name|sreq
argument_list|,
name|srsp
argument_list|,
name|shard
argument_list|)
return|;
block|}
block|}
decl_stmt|;
try|try
block|{
if|if
condition|(
name|shard
operator|!=
literal|null
condition|)
block|{
name|MDC
operator|.
name|put
argument_list|(
literal|"ShardRequest.shards"
argument_list|,
name|shard
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|urls
operator|!=
literal|null
operator|&&
operator|!
name|urls
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|MDC
operator|.
name|put
argument_list|(
literal|"ShardRequest.urlList"
argument_list|,
name|urls
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|pending
operator|.
name|add
argument_list|(
name|completionService
operator|.
name|submit
argument_list|(
name|task
argument_list|)
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|MDC
operator|.
name|remove
argument_list|(
literal|"ShardRequest.shards"
argument_list|)
expr_stmt|;
name|MDC
operator|.
name|remove
argument_list|(
literal|"ShardRequest.urlList"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Subclasses could modify the request based on the shard    */
DECL|method|makeQueryRequest
specifier|protected
name|QueryRequest
name|makeQueryRequest
parameter_list|(
specifier|final
name|ShardRequest
name|sreq
parameter_list|,
name|ModifiableSolrParams
name|params
parameter_list|,
name|String
name|shard
parameter_list|)
block|{
comment|// use generic request to avoid extra processing of queries
return|return
operator|new
name|QueryRequest
argument_list|(
name|params
argument_list|)
return|;
block|}
comment|/**    * Subclasses could modify the Response based on the the shard    */
DECL|method|transfomResponse
specifier|protected
name|ShardResponse
name|transfomResponse
parameter_list|(
specifier|final
name|ShardRequest
name|sreq
parameter_list|,
name|ShardResponse
name|rsp
parameter_list|,
name|String
name|shard
parameter_list|)
block|{
return|return
name|rsp
return|;
block|}
comment|/** returns a ShardResponse of the last response correlated with a ShardRequest.  This won't     * return early if it runs into an error.      **/
annotation|@
name|Override
DECL|method|takeCompletedIncludingErrors
specifier|public
name|ShardResponse
name|takeCompletedIncludingErrors
parameter_list|()
block|{
return|return
name|take
argument_list|(
literal|false
argument_list|)
return|;
block|}
comment|/** returns a ShardResponse of the last response correlated with a ShardRequest,    * or immediately returns a ShardResponse if there was an error detected    */
annotation|@
name|Override
DECL|method|takeCompletedOrError
specifier|public
name|ShardResponse
name|takeCompletedOrError
parameter_list|()
block|{
return|return
name|take
argument_list|(
literal|true
argument_list|)
return|;
block|}
DECL|method|take
specifier|private
name|ShardResponse
name|take
parameter_list|(
name|boolean
name|bailOnError
parameter_list|)
block|{
while|while
condition|(
name|pending
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
try|try
block|{
name|Future
argument_list|<
name|ShardResponse
argument_list|>
name|future
init|=
name|completionService
operator|.
name|take
argument_list|()
decl_stmt|;
name|pending
operator|.
name|remove
argument_list|(
name|future
argument_list|)
expr_stmt|;
name|ShardResponse
name|rsp
init|=
name|future
operator|.
name|get
argument_list|()
decl_stmt|;
if|if
condition|(
name|bailOnError
operator|&&
name|rsp
operator|.
name|getException
argument_list|()
operator|!=
literal|null
condition|)
return|return
name|rsp
return|;
comment|// if exception, return immediately
comment|// add response to the response list... we do this after the take() and
comment|// not after the completion of "call" so we know when the last response
comment|// for a request was received.  Otherwise we might return the same
comment|// request more than once.
name|rsp
operator|.
name|getShardRequest
argument_list|()
operator|.
name|responses
operator|.
name|add
argument_list|(
name|rsp
argument_list|)
expr_stmt|;
if|if
condition|(
name|rsp
operator|.
name|getShardRequest
argument_list|()
operator|.
name|responses
operator|.
name|size
argument_list|()
operator|==
name|rsp
operator|.
name|getShardRequest
argument_list|()
operator|.
name|actualShards
operator|.
name|length
condition|)
block|{
return|return
name|rsp
return|;
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|SolrException
operator|.
name|ErrorCode
operator|.
name|SERVER_ERROR
argument_list|,
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|ExecutionException
name|e
parameter_list|)
block|{
comment|// should be impossible... the problem with catching the exception
comment|// at this level is we don't know what ShardRequest it applied to
throw|throw
operator|new
name|SolrException
argument_list|(
name|SolrException
operator|.
name|ErrorCode
operator|.
name|SERVER_ERROR
argument_list|,
literal|"Impossible Exception"
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
return|return
literal|null
return|;
block|}
annotation|@
name|Override
DECL|method|cancelAll
specifier|public
name|void
name|cancelAll
parameter_list|()
block|{
for|for
control|(
name|Future
argument_list|<
name|ShardResponse
argument_list|>
name|future
range|:
name|pending
control|)
block|{
name|future
operator|.
name|cancel
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|prepDistributed
specifier|public
name|void
name|prepDistributed
parameter_list|(
name|ResponseBuilder
name|rb
parameter_list|)
block|{
specifier|final
name|SolrQueryRequest
name|req
init|=
name|rb
operator|.
name|req
decl_stmt|;
specifier|final
name|SolrParams
name|params
init|=
name|req
operator|.
name|getParams
argument_list|()
decl_stmt|;
specifier|final
name|String
name|shards
init|=
name|params
operator|.
name|get
argument_list|(
name|ShardParams
operator|.
name|SHARDS
argument_list|)
decl_stmt|;
comment|// since the cost of grabbing cloud state is still up in the air, we grab it only
comment|// if we need it.
name|ClusterState
name|clusterState
init|=
literal|null
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|Slice
argument_list|>
name|slices
init|=
literal|null
decl_stmt|;
name|CoreDescriptor
name|coreDescriptor
init|=
name|req
operator|.
name|getCore
argument_list|()
operator|.
name|getCoreDescriptor
argument_list|()
decl_stmt|;
name|CloudDescriptor
name|cloudDescriptor
init|=
name|coreDescriptor
operator|.
name|getCloudDescriptor
argument_list|()
decl_stmt|;
name|ZkController
name|zkController
init|=
name|coreDescriptor
operator|.
name|getCoreContainer
argument_list|()
operator|.
name|getZkController
argument_list|()
decl_stmt|;
if|if
condition|(
name|params
operator|.
name|getBool
argument_list|(
name|CommonParams
operator|.
name|PREFER_LOCAL_SHARDS
argument_list|,
literal|false
argument_list|)
condition|)
block|{
name|rb
operator|.
name|preferredHostAddress
operator|=
operator|(
name|zkController
operator|!=
literal|null
operator|)
condition|?
name|zkController
operator|.
name|getBaseUrl
argument_list|()
else|:
literal|null
expr_stmt|;
if|if
condition|(
name|rb
operator|.
name|preferredHostAddress
operator|==
literal|null
condition|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Couldn't determine current host address to prefer local shards"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|shards
operator|!=
literal|null
condition|)
block|{
name|List
argument_list|<
name|String
argument_list|>
name|lst
init|=
name|StrUtils
operator|.
name|splitSmart
argument_list|(
name|shards
argument_list|,
literal|","
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|rb
operator|.
name|shards
operator|=
name|lst
operator|.
name|toArray
argument_list|(
operator|new
name|String
index|[
name|lst
operator|.
name|size
argument_list|()
index|]
argument_list|)
expr_stmt|;
name|rb
operator|.
name|slices
operator|=
operator|new
name|String
index|[
name|rb
operator|.
name|shards
operator|.
name|length
index|]
expr_stmt|;
if|if
condition|(
name|zkController
operator|!=
literal|null
condition|)
block|{
comment|// figure out which shards are slices
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|rb
operator|.
name|shards
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|rb
operator|.
name|shards
index|[
name|i
index|]
operator|.
name|indexOf
argument_list|(
literal|'/'
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|// this is a logical shard
name|rb
operator|.
name|slices
index|[
name|i
index|]
operator|=
name|rb
operator|.
name|shards
index|[
name|i
index|]
expr_stmt|;
name|rb
operator|.
name|shards
index|[
name|i
index|]
operator|=
literal|null
expr_stmt|;
block|}
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|zkController
operator|!=
literal|null
condition|)
block|{
comment|// we weren't provided with an explicit list of slices to query via "shards", so use the cluster state
name|clusterState
operator|=
name|zkController
operator|.
name|getClusterState
argument_list|()
expr_stmt|;
name|String
name|shardKeys
init|=
name|params
operator|.
name|get
argument_list|(
name|ShardParams
operator|.
name|_ROUTE_
argument_list|)
decl_stmt|;
comment|// This will be the complete list of slices we need to query for this request.
name|slices
operator|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
expr_stmt|;
comment|// we need to find out what collections this request is for.
comment|// A comma-separated list of specified collections.
comment|// Eg: "collection1,collection2,collection3"
name|String
name|collections
init|=
name|params
operator|.
name|get
argument_list|(
literal|"collection"
argument_list|)
decl_stmt|;
if|if
condition|(
name|collections
operator|!=
literal|null
condition|)
block|{
comment|// If there were one or more collections specified in the query, split
comment|// each parameter and store as a separate member of a List.
name|List
argument_list|<
name|String
argument_list|>
name|collectionList
init|=
name|StrUtils
operator|.
name|splitSmart
argument_list|(
name|collections
argument_list|,
literal|","
argument_list|,
literal|true
argument_list|)
decl_stmt|;
comment|// In turn, retrieve the slices that cover each collection from the
comment|// cloud state and add them to the Map 'slices'.
for|for
control|(
name|String
name|collectionName
range|:
name|collectionList
control|)
block|{
comment|// The original code produced<collection-name>_<shard-name> when the collections
comment|// parameter was specified (see ClientUtils.appendMap)
comment|// Is this necessary if ony one collection is specified?
comment|// i.e. should we change multiCollection to collectionList.size()> 1?
name|addSlices
argument_list|(
name|slices
argument_list|,
name|clusterState
argument_list|,
name|params
argument_list|,
name|collectionName
argument_list|,
name|shardKeys
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// just this collection
name|String
name|collectionName
init|=
name|cloudDescriptor
operator|.
name|getCollectionName
argument_list|()
decl_stmt|;
name|addSlices
argument_list|(
name|slices
argument_list|,
name|clusterState
argument_list|,
name|params
argument_list|,
name|collectionName
argument_list|,
name|shardKeys
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
comment|// Store the logical slices in the ResponseBuilder and create a new
comment|// String array to hold the physical shards (which will be mapped
comment|// later).
name|rb
operator|.
name|slices
operator|=
name|slices
operator|.
name|keySet
argument_list|()
operator|.
name|toArray
argument_list|(
operator|new
name|String
index|[
name|slices
operator|.
name|size
argument_list|()
index|]
argument_list|)
expr_stmt|;
name|rb
operator|.
name|shards
operator|=
operator|new
name|String
index|[
name|rb
operator|.
name|slices
operator|.
name|length
index|]
expr_stmt|;
block|}
comment|//
comment|// Map slices to shards
comment|//
if|if
condition|(
name|zkController
operator|!=
literal|null
condition|)
block|{
comment|// Are we hosting the shard that this request is for, and are we active? If so, then handle it ourselves
comment|// and make it a non-distributed request.
name|String
name|ourSlice
init|=
name|cloudDescriptor
operator|.
name|getShardId
argument_list|()
decl_stmt|;
name|String
name|ourCollection
init|=
name|cloudDescriptor
operator|.
name|getCollectionName
argument_list|()
decl_stmt|;
if|if
condition|(
name|rb
operator|.
name|slices
operator|.
name|length
operator|==
literal|1
operator|&&
name|rb
operator|.
name|slices
index|[
literal|0
index|]
operator|!=
literal|null
operator|&&
operator|(
name|rb
operator|.
name|slices
index|[
literal|0
index|]
operator|.
name|equals
argument_list|(
name|ourSlice
argument_list|)
operator|||
name|rb
operator|.
name|slices
index|[
literal|0
index|]
operator|.
name|equals
argument_list|(
name|ourCollection
operator|+
literal|"_"
operator|+
name|ourSlice
argument_list|)
operator|)
comment|// handle the<collection>_<slice> format
operator|&&
name|cloudDescriptor
operator|.
name|getLastPublished
argument_list|()
operator|==
name|Replica
operator|.
name|State
operator|.
name|ACTIVE
condition|)
block|{
name|boolean
name|shortCircuit
init|=
name|params
operator|.
name|getBool
argument_list|(
literal|"shortCircuit"
argument_list|,
literal|true
argument_list|)
decl_stmt|;
comment|// currently just a debugging parameter to check distrib search on a single node
name|String
name|targetHandler
init|=
name|params
operator|.
name|get
argument_list|(
name|ShardParams
operator|.
name|SHARDS_QT
argument_list|)
decl_stmt|;
name|shortCircuit
operator|=
name|shortCircuit
operator|&&
name|targetHandler
operator|==
literal|null
expr_stmt|;
comment|// if a different handler is specified, don't short-circuit
if|if
condition|(
name|shortCircuit
condition|)
block|{
name|rb
operator|.
name|isDistrib
operator|=
literal|false
expr_stmt|;
name|rb
operator|.
name|shortCircuitedURL
operator|=
name|ZkCoreNodeProps
operator|.
name|getCoreUrl
argument_list|(
name|zkController
operator|.
name|getBaseUrl
argument_list|()
argument_list|,
name|coreDescriptor
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// We shouldn't need to do anything to handle "shard.rows" since it was previously meant to be an optimization?
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|rb
operator|.
name|shards
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|rb
operator|.
name|shards
index|[
name|i
index|]
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|clusterState
operator|==
literal|null
condition|)
block|{
name|clusterState
operator|=
name|zkController
operator|.
name|getClusterState
argument_list|()
expr_stmt|;
name|slices
operator|=
name|clusterState
operator|.
name|getSlicesMap
argument_list|(
name|cloudDescriptor
operator|.
name|getCollectionName
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|String
name|sliceName
init|=
name|rb
operator|.
name|slices
index|[
name|i
index|]
decl_stmt|;
name|Slice
name|slice
init|=
name|slices
operator|.
name|get
argument_list|(
name|sliceName
argument_list|)
decl_stmt|;
if|if
condition|(
name|slice
operator|==
literal|null
condition|)
block|{
comment|// Treat this the same as "all servers down" for a slice, and let things continue
comment|// if partial results are acceptable
name|rb
operator|.
name|shards
index|[
name|i
index|]
operator|=
literal|""
expr_stmt|;
continue|continue;
comment|// throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, "no such shard: " + sliceName);
block|}
name|Map
argument_list|<
name|String
argument_list|,
name|Replica
argument_list|>
name|sliceShards
init|=
name|slice
operator|.
name|getReplicasMap
argument_list|()
decl_stmt|;
comment|// For now, recreate the | delimited list of equivalent servers
name|StringBuilder
name|sliceShardsStr
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|boolean
name|first
init|=
literal|true
decl_stmt|;
for|for
control|(
name|Replica
name|replica
range|:
name|sliceShards
operator|.
name|values
argument_list|()
control|)
block|{
if|if
condition|(
operator|!
name|clusterState
operator|.
name|liveNodesContain
argument_list|(
name|replica
operator|.
name|getNodeName
argument_list|()
argument_list|)
operator|||
name|replica
operator|.
name|getState
argument_list|()
operator|!=
name|Replica
operator|.
name|State
operator|.
name|ACTIVE
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|first
condition|)
block|{
name|first
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
name|sliceShardsStr
operator|.
name|append
argument_list|(
literal|'|'
argument_list|)
expr_stmt|;
block|}
name|String
name|url
init|=
name|ZkCoreNodeProps
operator|.
name|getCoreUrl
argument_list|(
name|replica
argument_list|)
decl_stmt|;
name|sliceShardsStr
operator|.
name|append
argument_list|(
name|url
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sliceShardsStr
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
block|{
name|boolean
name|tolerant
init|=
name|rb
operator|.
name|req
operator|.
name|getParams
argument_list|()
operator|.
name|getBool
argument_list|(
name|ShardParams
operator|.
name|SHARDS_TOLERANT
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|tolerant
condition|)
block|{
comment|// stop the check when there are no replicas available for a shard
throw|throw
operator|new
name|SolrException
argument_list|(
name|SolrException
operator|.
name|ErrorCode
operator|.
name|SERVICE_UNAVAILABLE
argument_list|,
literal|"no servers hosting shard: "
operator|+
name|rb
operator|.
name|slices
index|[
name|i
index|]
argument_list|)
throw|;
block|}
block|}
name|rb
operator|.
name|shards
index|[
name|i
index|]
operator|=
name|sliceShardsStr
operator|.
name|toString
argument_list|()
expr_stmt|;
block|}
block|}
block|}
name|String
name|shards_rows
init|=
name|params
operator|.
name|get
argument_list|(
name|ShardParams
operator|.
name|SHARDS_ROWS
argument_list|)
decl_stmt|;
if|if
condition|(
name|shards_rows
operator|!=
literal|null
condition|)
block|{
name|rb
operator|.
name|shards_rows
operator|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|shards_rows
argument_list|)
expr_stmt|;
block|}
name|String
name|shards_start
init|=
name|params
operator|.
name|get
argument_list|(
name|ShardParams
operator|.
name|SHARDS_START
argument_list|)
decl_stmt|;
if|if
condition|(
name|shards_start
operator|!=
literal|null
condition|)
block|{
name|rb
operator|.
name|shards_start
operator|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|shards_start
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|addSlices
specifier|private
name|void
name|addSlices
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|Slice
argument_list|>
name|target
parameter_list|,
name|ClusterState
name|state
parameter_list|,
name|SolrParams
name|params
parameter_list|,
name|String
name|collectionName
parameter_list|,
name|String
name|shardKeys
parameter_list|,
name|boolean
name|multiCollection
parameter_list|)
block|{
name|DocCollection
name|coll
init|=
name|state
operator|.
name|getCollection
argument_list|(
name|collectionName
argument_list|)
decl_stmt|;
name|Collection
argument_list|<
name|Slice
argument_list|>
name|slices
init|=
name|coll
operator|.
name|getRouter
argument_list|()
operator|.
name|getSearchSlices
argument_list|(
name|shardKeys
argument_list|,
name|params
argument_list|,
name|coll
argument_list|)
decl_stmt|;
name|ClientUtils
operator|.
name|addSlices
argument_list|(
name|target
argument_list|,
name|collectionName
argument_list|,
name|slices
argument_list|,
name|multiCollection
argument_list|)
expr_stmt|;
block|}
DECL|method|getShardHandlerFactory
specifier|public
name|ShardHandlerFactory
name|getShardHandlerFactory
parameter_list|()
block|{
return|return
name|httpShardHandlerFactory
return|;
block|}
block|}
end_class
end_unit
