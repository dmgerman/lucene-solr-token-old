begin_unit
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_package
DECL|package|org.apache.solr.handler.admin
package|package
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|handler
operator|.
name|admin
package|;
end_package
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|net
operator|.
name|MalformedURLException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URL
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|*
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|Analyzer
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|util
operator|.
name|CharFilterFactory
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|util
operator|.
name|TokenFilterFactory
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|util
operator|.
name|TokenizerFactory
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|document
operator|.
name|Document
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|document
operator|.
name|Field
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|*
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|FieldInfo
operator|.
name|IndexOptions
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|DocIdSetIterator
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|Directory
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|BytesRef
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|CharsRef
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|PriorityQueue
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|UnicodeUtil
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|analysis
operator|.
name|TokenizerChain
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|SolrException
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|SolrException
operator|.
name|ErrorCode
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|luke
operator|.
name|FieldFlag
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|params
operator|.
name|CommonParams
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|params
operator|.
name|SolrParams
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|util
operator|.
name|Base64
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|util
operator|.
name|NamedList
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|util
operator|.
name|SimpleOrderedMap
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|handler
operator|.
name|RequestHandlerBase
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|request
operator|.
name|SolrQueryRequest
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|response
operator|.
name|SolrQueryResponse
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|schema
operator|.
name|FieldType
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|update
operator|.
name|SolrIndexWriter
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|schema
operator|.
name|IndexSchema
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|schema
operator|.
name|SchemaField
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|search
operator|.
name|SolrIndexSearcher
import|;
end_import
begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import
begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import
begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|FieldInfo
operator|.
name|IndexOptions
operator|.
name|DOCS_AND_FREQS
import|;
end_import
begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|FieldInfo
operator|.
name|IndexOptions
operator|.
name|DOCS_ONLY
import|;
end_import
begin_comment
comment|/**  * This handler exposes the internal lucene index.  It is inspired by and   * modeled on Luke, the Lucene Index Browser by Andrzej Bialecki.  *   http://www.getopt.org/luke/  *  * For more documentation see:  *  http://wiki.apache.org/solr/LukeRequestHandler  *  * @since solr 1.2  */
end_comment
begin_class
DECL|class|LukeRequestHandler
specifier|public
class|class
name|LukeRequestHandler
extends|extends
name|RequestHandlerBase
block|{
DECL|field|log
specifier|private
specifier|static
name|Logger
name|log
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|LukeRequestHandler
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|NUMTERMS
specifier|public
specifier|static
specifier|final
name|String
name|NUMTERMS
init|=
literal|"numTerms"
decl_stmt|;
DECL|field|DOC_ID
specifier|public
specifier|static
specifier|final
name|String
name|DOC_ID
init|=
literal|"docId"
decl_stmt|;
DECL|field|ID
specifier|public
specifier|static
specifier|final
name|String
name|ID
init|=
literal|"id"
decl_stmt|;
DECL|field|DEFAULT_COUNT
specifier|public
specifier|static
specifier|final
name|int
name|DEFAULT_COUNT
init|=
literal|10
decl_stmt|;
DECL|field|HIST_ARRAY_SIZE
specifier|static
specifier|final
name|int
name|HIST_ARRAY_SIZE
init|=
literal|33
decl_stmt|;
DECL|enum|ShowStyle
specifier|private
specifier|static
enum|enum
name|ShowStyle
block|{
DECL|enum constant|ALL
name|ALL
block|,
DECL|enum constant|DOC
name|DOC
block|,
DECL|enum constant|SCHEMA
name|SCHEMA
block|,
DECL|enum constant|INDEX
name|INDEX
block|;
DECL|method|get
specifier|public
specifier|static
name|ShowStyle
name|get
parameter_list|(
name|String
name|v
parameter_list|)
block|{
if|if
condition|(
name|v
operator|==
literal|null
condition|)
return|return
literal|null
return|;
if|if
condition|(
literal|"schema"
operator|.
name|equalsIgnoreCase
argument_list|(
name|v
argument_list|)
condition|)
return|return
name|SCHEMA
return|;
if|if
condition|(
literal|"index"
operator|.
name|equalsIgnoreCase
argument_list|(
name|v
argument_list|)
condition|)
return|return
name|INDEX
return|;
if|if
condition|(
literal|"doc"
operator|.
name|equalsIgnoreCase
argument_list|(
name|v
argument_list|)
condition|)
return|return
name|DOC
return|;
if|if
condition|(
literal|"all"
operator|.
name|equalsIgnoreCase
argument_list|(
name|v
argument_list|)
condition|)
return|return
name|ALL
return|;
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
literal|"Unknown Show Style: "
operator|+
name|v
argument_list|)
throw|;
block|}
block|}
empty_stmt|;
annotation|@
name|Override
DECL|method|handleRequestBody
specifier|public
name|void
name|handleRequestBody
parameter_list|(
name|SolrQueryRequest
name|req
parameter_list|,
name|SolrQueryResponse
name|rsp
parameter_list|)
throws|throws
name|Exception
block|{
name|IndexSchema
name|schema
init|=
name|req
operator|.
name|getSchema
argument_list|()
decl_stmt|;
name|SolrIndexSearcher
name|searcher
init|=
name|req
operator|.
name|getSearcher
argument_list|()
decl_stmt|;
name|DirectoryReader
name|reader
init|=
name|searcher
operator|.
name|getIndexReader
argument_list|()
decl_stmt|;
name|SolrParams
name|params
init|=
name|req
operator|.
name|getParams
argument_list|()
decl_stmt|;
name|ShowStyle
name|style
init|=
name|ShowStyle
operator|.
name|get
argument_list|(
name|params
operator|.
name|get
argument_list|(
literal|"show"
argument_list|)
argument_list|)
decl_stmt|;
comment|// If no doc is given, show all fields and top terms
name|rsp
operator|.
name|add
argument_list|(
literal|"index"
argument_list|,
name|getIndexInfo
argument_list|(
name|reader
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ShowStyle
operator|.
name|INDEX
operator|==
name|style
condition|)
block|{
return|return;
comment|// that's all we need
block|}
name|Integer
name|docId
init|=
name|params
operator|.
name|getInt
argument_list|(
name|DOC_ID
argument_list|)
decl_stmt|;
if|if
condition|(
name|docId
operator|==
literal|null
operator|&&
name|params
operator|.
name|get
argument_list|(
name|ID
argument_list|)
operator|!=
literal|null
condition|)
block|{
comment|// Look for something with a given solr ID
name|SchemaField
name|uniqueKey
init|=
name|schema
operator|.
name|getUniqueKeyField
argument_list|()
decl_stmt|;
name|String
name|v
init|=
name|uniqueKey
operator|.
name|getType
argument_list|()
operator|.
name|toInternal
argument_list|(
name|params
operator|.
name|get
argument_list|(
name|ID
argument_list|)
argument_list|)
decl_stmt|;
name|Term
name|t
init|=
operator|new
name|Term
argument_list|(
name|uniqueKey
operator|.
name|getName
argument_list|()
argument_list|,
name|v
argument_list|)
decl_stmt|;
name|docId
operator|=
name|searcher
operator|.
name|getFirstMatch
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|docId
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|SolrException
operator|.
name|ErrorCode
operator|.
name|NOT_FOUND
argument_list|,
literal|"Can't find document: "
operator|+
name|params
operator|.
name|get
argument_list|(
name|ID
argument_list|)
argument_list|)
throw|;
block|}
block|}
comment|// Read the document from the index
if|if
condition|(
name|docId
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|style
operator|!=
literal|null
operator|&&
name|style
operator|!=
name|ShowStyle
operator|.
name|DOC
condition|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
literal|"missing doc param for doc style"
argument_list|)
throw|;
block|}
name|Document
name|doc
init|=
literal|null
decl_stmt|;
try|try
block|{
name|doc
operator|=
name|reader
operator|.
name|document
argument_list|(
name|docId
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{}
if|if
condition|(
name|doc
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|SolrException
operator|.
name|ErrorCode
operator|.
name|NOT_FOUND
argument_list|,
literal|"Can't find document: "
operator|+
name|docId
argument_list|)
throw|;
block|}
name|SimpleOrderedMap
argument_list|<
name|Object
argument_list|>
name|info
init|=
name|getDocumentFieldsInfo
argument_list|(
name|doc
argument_list|,
name|docId
argument_list|,
name|reader
argument_list|,
name|schema
argument_list|)
decl_stmt|;
name|SimpleOrderedMap
argument_list|<
name|Object
argument_list|>
name|docinfo
init|=
operator|new
name|SimpleOrderedMap
argument_list|<
name|Object
argument_list|>
argument_list|()
decl_stmt|;
name|docinfo
operator|.
name|add
argument_list|(
literal|"docId"
argument_list|,
name|docId
argument_list|)
expr_stmt|;
name|docinfo
operator|.
name|add
argument_list|(
literal|"lucene"
argument_list|,
name|info
argument_list|)
expr_stmt|;
name|docinfo
operator|.
name|add
argument_list|(
literal|"solr"
argument_list|,
name|doc
argument_list|)
expr_stmt|;
name|rsp
operator|.
name|add
argument_list|(
literal|"doc"
argument_list|,
name|docinfo
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ShowStyle
operator|.
name|SCHEMA
operator|==
name|style
condition|)
block|{
name|rsp
operator|.
name|add
argument_list|(
literal|"schema"
argument_list|,
name|getSchemaInfo
argument_list|(
name|req
operator|.
name|getSchema
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rsp
operator|.
name|add
argument_list|(
literal|"fields"
argument_list|,
name|getIndexedFieldsInfo
argument_list|(
name|req
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// Add some generally helpful information
name|NamedList
argument_list|<
name|Object
argument_list|>
name|info
init|=
operator|new
name|SimpleOrderedMap
argument_list|<
name|Object
argument_list|>
argument_list|()
decl_stmt|;
name|info
operator|.
name|add
argument_list|(
literal|"key"
argument_list|,
name|getFieldFlagsKey
argument_list|()
argument_list|)
expr_stmt|;
name|info
operator|.
name|add
argument_list|(
literal|"NOTE"
argument_list|,
literal|"Document Frequency (df) is not updated when a document is marked for deletion.  df values include deleted documents."
argument_list|)
expr_stmt|;
name|rsp
operator|.
name|add
argument_list|(
literal|"info"
argument_list|,
name|info
argument_list|)
expr_stmt|;
name|rsp
operator|.
name|setHttpCaching
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
comment|/**    * @return a string representing a IndexableField's flags.      */
DECL|method|getFieldFlags
specifier|private
specifier|static
name|String
name|getFieldFlags
parameter_list|(
name|IndexableField
name|f
parameter_list|)
block|{
name|IndexOptions
name|opts
init|=
operator|(
name|f
operator|==
literal|null
operator|)
condition|?
literal|null
else|:
name|f
operator|.
name|fieldType
argument_list|()
operator|.
name|indexOptions
argument_list|()
decl_stmt|;
name|StringBuilder
name|flags
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|flags
operator|.
name|append
argument_list|(
operator|(
name|f
operator|!=
literal|null
operator|&&
name|f
operator|.
name|fieldType
argument_list|()
operator|.
name|indexed
argument_list|()
operator|)
condition|?
name|FieldFlag
operator|.
name|INDEXED
operator|.
name|getAbbreviation
argument_list|()
else|:
literal|'-'
argument_list|)
expr_stmt|;
name|flags
operator|.
name|append
argument_list|(
operator|(
name|f
operator|!=
literal|null
operator|&&
name|f
operator|.
name|fieldType
argument_list|()
operator|.
name|tokenized
argument_list|()
operator|)
condition|?
name|FieldFlag
operator|.
name|TOKENIZED
operator|.
name|getAbbreviation
argument_list|()
else|:
literal|'-'
argument_list|)
expr_stmt|;
name|flags
operator|.
name|append
argument_list|(
operator|(
name|f
operator|!=
literal|null
operator|&&
name|f
operator|.
name|fieldType
argument_list|()
operator|.
name|stored
argument_list|()
operator|)
condition|?
name|FieldFlag
operator|.
name|STORED
operator|.
name|getAbbreviation
argument_list|()
else|:
literal|'-'
argument_list|)
expr_stmt|;
name|flags
operator|.
name|append
argument_list|(
operator|(
literal|false
operator|)
condition|?
name|FieldFlag
operator|.
name|MULTI_VALUED
operator|.
name|getAbbreviation
argument_list|()
else|:
literal|'-'
argument_list|)
expr_stmt|;
comment|// SchemaField Specific
name|flags
operator|.
name|append
argument_list|(
operator|(
name|f
operator|!=
literal|null
operator|&&
name|f
operator|.
name|fieldType
argument_list|()
operator|.
name|storeTermVectors
argument_list|()
operator|)
condition|?
name|FieldFlag
operator|.
name|TERM_VECTOR_STORED
operator|.
name|getAbbreviation
argument_list|()
else|:
literal|'-'
argument_list|)
expr_stmt|;
name|flags
operator|.
name|append
argument_list|(
operator|(
name|f
operator|!=
literal|null
operator|&&
name|f
operator|.
name|fieldType
argument_list|()
operator|.
name|storeTermVectorOffsets
argument_list|()
operator|)
condition|?
name|FieldFlag
operator|.
name|TERM_VECTOR_OFFSET
operator|.
name|getAbbreviation
argument_list|()
else|:
literal|'-'
argument_list|)
expr_stmt|;
name|flags
operator|.
name|append
argument_list|(
operator|(
name|f
operator|!=
literal|null
operator|&&
name|f
operator|.
name|fieldType
argument_list|()
operator|.
name|storeTermVectorPositions
argument_list|()
operator|)
condition|?
name|FieldFlag
operator|.
name|TERM_VECTOR_POSITION
operator|.
name|getAbbreviation
argument_list|()
else|:
literal|'-'
argument_list|)
expr_stmt|;
name|flags
operator|.
name|append
argument_list|(
operator|(
name|f
operator|!=
literal|null
operator|&&
name|f
operator|.
name|fieldType
argument_list|()
operator|.
name|omitNorms
argument_list|()
operator|)
condition|?
name|FieldFlag
operator|.
name|OMIT_NORMS
operator|.
name|getAbbreviation
argument_list|()
else|:
literal|'-'
argument_list|)
expr_stmt|;
name|flags
operator|.
name|append
argument_list|(
operator|(
name|f
operator|!=
literal|null
operator|&&
name|DOCS_ONLY
operator|==
name|opts
operator|)
condition|?
name|FieldFlag
operator|.
name|OMIT_TF
operator|.
name|getAbbreviation
argument_list|()
else|:
literal|'-'
argument_list|)
expr_stmt|;
name|flags
operator|.
name|append
argument_list|(
operator|(
name|f
operator|!=
literal|null
operator|&&
name|DOCS_AND_FREQS
operator|==
name|opts
operator|)
condition|?
name|FieldFlag
operator|.
name|OMIT_POSITIONS
operator|.
name|getAbbreviation
argument_list|()
else|:
literal|'-'
argument_list|)
expr_stmt|;
name|flags
operator|.
name|append
argument_list|(
operator|(
name|f
operator|!=
literal|null
operator|&&
name|f
operator|.
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
operator|.
name|equals
argument_list|(
literal|"LazyField"
argument_list|)
operator|)
condition|?
name|FieldFlag
operator|.
name|LAZY
operator|.
name|getAbbreviation
argument_list|()
else|:
literal|'-'
argument_list|)
expr_stmt|;
name|flags
operator|.
name|append
argument_list|(
operator|(
name|f
operator|!=
literal|null
operator|&&
name|f
operator|.
name|binaryValue
argument_list|()
operator|!=
literal|null
operator|)
condition|?
name|FieldFlag
operator|.
name|BINARY
operator|.
name|getAbbreviation
argument_list|()
else|:
literal|'-'
argument_list|)
expr_stmt|;
name|flags
operator|.
name|append
argument_list|(
operator|(
literal|false
operator|)
condition|?
name|FieldFlag
operator|.
name|SORT_MISSING_FIRST
operator|.
name|getAbbreviation
argument_list|()
else|:
literal|'-'
argument_list|)
expr_stmt|;
comment|// SchemaField Specific
name|flags
operator|.
name|append
argument_list|(
operator|(
literal|false
operator|)
condition|?
name|FieldFlag
operator|.
name|SORT_MISSING_LAST
operator|.
name|getAbbreviation
argument_list|()
else|:
literal|'-'
argument_list|)
expr_stmt|;
comment|// SchemaField Specific
return|return
name|flags
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**    * @return a string representing a SchemaField's flags.      */
DECL|method|getFieldFlags
specifier|private
specifier|static
name|String
name|getFieldFlags
parameter_list|(
name|SchemaField
name|f
parameter_list|)
block|{
name|FieldType
name|t
init|=
operator|(
name|f
operator|==
literal|null
operator|)
condition|?
literal|null
else|:
name|f
operator|.
name|getType
argument_list|()
decl_stmt|;
comment|// see: http://www.nabble.com/schema-field-properties-tf3437753.html#a9585549
name|boolean
name|lazy
init|=
literal|false
decl_stmt|;
comment|// "lazy" is purely a property of reading fields
name|boolean
name|binary
init|=
literal|false
decl_stmt|;
comment|// Currently not possible
name|StringBuilder
name|flags
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|flags
operator|.
name|append
argument_list|(
operator|(
name|f
operator|!=
literal|null
operator|&&
name|f
operator|.
name|indexed
argument_list|()
operator|)
condition|?
name|FieldFlag
operator|.
name|INDEXED
operator|.
name|getAbbreviation
argument_list|()
else|:
literal|'-'
argument_list|)
expr_stmt|;
name|flags
operator|.
name|append
argument_list|(
operator|(
name|t
operator|!=
literal|null
operator|&&
name|t
operator|.
name|isTokenized
argument_list|()
operator|)
condition|?
name|FieldFlag
operator|.
name|TOKENIZED
operator|.
name|getAbbreviation
argument_list|()
else|:
literal|'-'
argument_list|)
expr_stmt|;
name|flags
operator|.
name|append
argument_list|(
operator|(
name|f
operator|!=
literal|null
operator|&&
name|f
operator|.
name|stored
argument_list|()
operator|)
condition|?
name|FieldFlag
operator|.
name|STORED
operator|.
name|getAbbreviation
argument_list|()
else|:
literal|'-'
argument_list|)
expr_stmt|;
name|flags
operator|.
name|append
argument_list|(
operator|(
name|f
operator|!=
literal|null
operator|&&
name|f
operator|.
name|multiValued
argument_list|()
operator|)
condition|?
name|FieldFlag
operator|.
name|MULTI_VALUED
operator|.
name|getAbbreviation
argument_list|()
else|:
literal|'-'
argument_list|)
expr_stmt|;
name|flags
operator|.
name|append
argument_list|(
operator|(
name|f
operator|!=
literal|null
operator|&&
name|f
operator|.
name|storeTermVector
argument_list|()
operator|)
condition|?
name|FieldFlag
operator|.
name|TERM_VECTOR_STORED
operator|.
name|getAbbreviation
argument_list|()
else|:
literal|'-'
argument_list|)
expr_stmt|;
name|flags
operator|.
name|append
argument_list|(
operator|(
name|f
operator|!=
literal|null
operator|&&
name|f
operator|.
name|storeTermOffsets
argument_list|()
operator|)
condition|?
name|FieldFlag
operator|.
name|TERM_VECTOR_OFFSET
operator|.
name|getAbbreviation
argument_list|()
else|:
literal|'-'
argument_list|)
expr_stmt|;
name|flags
operator|.
name|append
argument_list|(
operator|(
name|f
operator|!=
literal|null
operator|&&
name|f
operator|.
name|storeTermPositions
argument_list|()
operator|)
condition|?
name|FieldFlag
operator|.
name|TERM_VECTOR_POSITION
operator|.
name|getAbbreviation
argument_list|()
else|:
literal|'-'
argument_list|)
expr_stmt|;
name|flags
operator|.
name|append
argument_list|(
operator|(
name|f
operator|!=
literal|null
operator|&&
name|f
operator|.
name|omitNorms
argument_list|()
operator|)
condition|?
name|FieldFlag
operator|.
name|OMIT_NORMS
operator|.
name|getAbbreviation
argument_list|()
else|:
literal|'-'
argument_list|)
expr_stmt|;
name|flags
operator|.
name|append
argument_list|(
operator|(
name|f
operator|!=
literal|null
operator|&&
name|f
operator|.
name|omitTermFreqAndPositions
argument_list|()
operator|)
condition|?
name|FieldFlag
operator|.
name|OMIT_TF
operator|.
name|getAbbreviation
argument_list|()
else|:
literal|'-'
argument_list|)
expr_stmt|;
name|flags
operator|.
name|append
argument_list|(
operator|(
name|f
operator|!=
literal|null
operator|&&
name|f
operator|.
name|omitPositions
argument_list|()
operator|)
condition|?
name|FieldFlag
operator|.
name|OMIT_POSITIONS
operator|.
name|getAbbreviation
argument_list|()
else|:
literal|'-'
argument_list|)
expr_stmt|;
name|flags
operator|.
name|append
argument_list|(
operator|(
name|lazy
operator|)
condition|?
name|FieldFlag
operator|.
name|LAZY
operator|.
name|getAbbreviation
argument_list|()
else|:
literal|'-'
argument_list|)
expr_stmt|;
name|flags
operator|.
name|append
argument_list|(
operator|(
name|binary
operator|)
condition|?
name|FieldFlag
operator|.
name|BINARY
operator|.
name|getAbbreviation
argument_list|()
else|:
literal|'-'
argument_list|)
expr_stmt|;
name|flags
operator|.
name|append
argument_list|(
operator|(
name|f
operator|!=
literal|null
operator|&&
name|f
operator|.
name|sortMissingFirst
argument_list|()
operator|)
condition|?
name|FieldFlag
operator|.
name|SORT_MISSING_FIRST
operator|.
name|getAbbreviation
argument_list|()
else|:
literal|'-'
argument_list|)
expr_stmt|;
name|flags
operator|.
name|append
argument_list|(
operator|(
name|f
operator|!=
literal|null
operator|&&
name|f
operator|.
name|sortMissingLast
argument_list|()
operator|)
condition|?
name|FieldFlag
operator|.
name|SORT_MISSING_LAST
operator|.
name|getAbbreviation
argument_list|()
else|:
literal|'-'
argument_list|)
expr_stmt|;
return|return
name|flags
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**    * @return a key to what each character means    */
DECL|method|getFieldFlagsKey
specifier|public
specifier|static
name|SimpleOrderedMap
argument_list|<
name|String
argument_list|>
name|getFieldFlagsKey
parameter_list|()
block|{
name|SimpleOrderedMap
argument_list|<
name|String
argument_list|>
name|key
init|=
operator|new
name|SimpleOrderedMap
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|FieldFlag
name|f
range|:
name|FieldFlag
operator|.
name|values
argument_list|()
control|)
block|{
name|key
operator|.
name|add
argument_list|(
name|String
operator|.
name|valueOf
argument_list|(
name|f
operator|.
name|getAbbreviation
argument_list|()
argument_list|)
argument_list|,
name|f
operator|.
name|getDisplay
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|key
return|;
block|}
DECL|method|getDocumentFieldsInfo
specifier|private
specifier|static
name|SimpleOrderedMap
argument_list|<
name|Object
argument_list|>
name|getDocumentFieldsInfo
parameter_list|(
name|Document
name|doc
parameter_list|,
name|int
name|docId
parameter_list|,
name|IndexReader
name|reader
parameter_list|,
name|IndexSchema
name|schema
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|CharsRef
name|spare
init|=
operator|new
name|CharsRef
argument_list|()
decl_stmt|;
name|SimpleOrderedMap
argument_list|<
name|Object
argument_list|>
name|finfo
init|=
operator|new
name|SimpleOrderedMap
argument_list|<
name|Object
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|Object
name|o
range|:
name|doc
operator|.
name|getFields
argument_list|()
control|)
block|{
name|Field
name|field
init|=
operator|(
name|Field
operator|)
name|o
decl_stmt|;
name|SimpleOrderedMap
argument_list|<
name|Object
argument_list|>
name|f
init|=
operator|new
name|SimpleOrderedMap
argument_list|<
name|Object
argument_list|>
argument_list|()
decl_stmt|;
name|SchemaField
name|sfield
init|=
name|schema
operator|.
name|getFieldOrNull
argument_list|(
name|field
operator|.
name|name
argument_list|()
argument_list|)
decl_stmt|;
name|FieldType
name|ftype
init|=
operator|(
name|sfield
operator|==
literal|null
operator|)
condition|?
literal|null
else|:
name|sfield
operator|.
name|getType
argument_list|()
decl_stmt|;
name|f
operator|.
name|add
argument_list|(
literal|"type"
argument_list|,
operator|(
name|ftype
operator|==
literal|null
operator|)
condition|?
literal|null
else|:
name|ftype
operator|.
name|getTypeName
argument_list|()
argument_list|)
expr_stmt|;
name|f
operator|.
name|add
argument_list|(
literal|"schema"
argument_list|,
name|getFieldFlags
argument_list|(
name|sfield
argument_list|)
argument_list|)
expr_stmt|;
name|f
operator|.
name|add
argument_list|(
literal|"flags"
argument_list|,
name|getFieldFlags
argument_list|(
name|field
argument_list|)
argument_list|)
expr_stmt|;
name|Term
name|t
init|=
operator|new
name|Term
argument_list|(
name|field
operator|.
name|name
argument_list|()
argument_list|,
name|ftype
operator|!=
literal|null
condition|?
name|ftype
operator|.
name|storedToIndexed
argument_list|(
name|field
argument_list|)
else|:
name|field
operator|.
name|stringValue
argument_list|()
argument_list|)
decl_stmt|;
name|f
operator|.
name|add
argument_list|(
literal|"value"
argument_list|,
operator|(
name|ftype
operator|==
literal|null
operator|)
condition|?
literal|null
else|:
name|ftype
operator|.
name|toExternal
argument_list|(
name|field
argument_list|)
argument_list|)
expr_stmt|;
comment|// TODO: this really should be "stored"
name|f
operator|.
name|add
argument_list|(
literal|"internal"
argument_list|,
name|field
operator|.
name|stringValue
argument_list|()
argument_list|)
expr_stmt|;
comment|// may be a binary number
name|BytesRef
name|bytes
init|=
name|field
operator|.
name|binaryValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|bytes
operator|!=
literal|null
condition|)
block|{
name|f
operator|.
name|add
argument_list|(
literal|"binary"
argument_list|,
name|Base64
operator|.
name|byteArrayToBase64
argument_list|(
name|bytes
operator|.
name|bytes
argument_list|,
name|bytes
operator|.
name|offset
argument_list|,
name|bytes
operator|.
name|length
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|f
operator|.
name|add
argument_list|(
literal|"boost"
argument_list|,
name|field
operator|.
name|boost
argument_list|()
argument_list|)
expr_stmt|;
name|f
operator|.
name|add
argument_list|(
literal|"docFreq"
argument_list|,
name|t
operator|.
name|text
argument_list|()
operator|==
literal|null
condition|?
literal|0
else|:
name|reader
operator|.
name|docFreq
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
comment|// this can be 0 for non-indexed fields
comment|// If we have a term vector, return that
if|if
condition|(
name|field
operator|.
name|fieldType
argument_list|()
operator|.
name|storeTermVectors
argument_list|()
condition|)
block|{
try|try
block|{
name|Terms
name|v
init|=
name|reader
operator|.
name|getTermVector
argument_list|(
name|docId
argument_list|,
name|field
operator|.
name|name
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|v
operator|!=
literal|null
condition|)
block|{
name|SimpleOrderedMap
argument_list|<
name|Integer
argument_list|>
name|tfv
init|=
operator|new
name|SimpleOrderedMap
argument_list|<
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
specifier|final
name|TermsEnum
name|termsEnum
init|=
name|v
operator|.
name|iterator
argument_list|(
literal|null
argument_list|)
decl_stmt|;
name|BytesRef
name|text
decl_stmt|;
while|while
condition|(
operator|(
name|text
operator|=
name|termsEnum
operator|.
name|next
argument_list|()
operator|)
operator|!=
literal|null
condition|)
block|{
specifier|final
name|int
name|freq
init|=
operator|(
name|int
operator|)
name|termsEnum
operator|.
name|totalTermFreq
argument_list|()
decl_stmt|;
name|UnicodeUtil
operator|.
name|UTF8toUTF16
argument_list|(
name|text
argument_list|,
name|spare
argument_list|)
expr_stmt|;
name|tfv
operator|.
name|add
argument_list|(
name|spare
operator|.
name|toString
argument_list|()
argument_list|,
name|freq
argument_list|)
expr_stmt|;
block|}
name|f
operator|.
name|add
argument_list|(
literal|"termVector"
argument_list|,
name|tfv
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"error writing term vector"
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
block|}
name|finfo
operator|.
name|add
argument_list|(
name|field
operator|.
name|name
argument_list|()
argument_list|,
name|f
argument_list|)
expr_stmt|;
block|}
return|return
name|finfo
return|;
block|}
DECL|method|getIndexedFieldsInfo
specifier|private
specifier|static
name|SimpleOrderedMap
argument_list|<
name|Object
argument_list|>
name|getIndexedFieldsInfo
parameter_list|(
name|SolrQueryRequest
name|req
parameter_list|)
throws|throws
name|Exception
block|{
name|SolrIndexSearcher
name|searcher
init|=
name|req
operator|.
name|getSearcher
argument_list|()
decl_stmt|;
name|SolrParams
name|params
init|=
name|req
operator|.
name|getParams
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|String
argument_list|>
name|fields
init|=
literal|null
decl_stmt|;
name|String
name|fl
init|=
name|params
operator|.
name|get
argument_list|(
name|CommonParams
operator|.
name|FL
argument_list|)
decl_stmt|;
if|if
condition|(
name|fl
operator|!=
literal|null
condition|)
block|{
name|fields
operator|=
operator|new
name|TreeSet
argument_list|<
name|String
argument_list|>
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|fl
operator|.
name|split
argument_list|(
literal|"[,\\s]+"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|AtomicReader
name|reader
init|=
name|searcher
operator|.
name|getAtomicReader
argument_list|()
decl_stmt|;
name|IndexSchema
name|schema
init|=
name|searcher
operator|.
name|getSchema
argument_list|()
decl_stmt|;
comment|// Don't be tempted to put this in the loop below, the whole point here is to alphabetize the fields!
name|Set
argument_list|<
name|String
argument_list|>
name|fieldNames
init|=
operator|new
name|TreeSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|FieldInfo
name|fieldInfo
range|:
name|reader
operator|.
name|getFieldInfos
argument_list|()
control|)
block|{
name|fieldNames
operator|.
name|add
argument_list|(
name|fieldInfo
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
comment|// Walk the term enum and keep a priority queue for each map in our set
name|SimpleOrderedMap
argument_list|<
name|Object
argument_list|>
name|finfo
init|=
operator|new
name|SimpleOrderedMap
argument_list|<
name|Object
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|fieldName
range|:
name|fieldNames
control|)
block|{
if|if
condition|(
name|fields
operator|!=
literal|null
operator|&&
operator|!
name|fields
operator|.
name|contains
argument_list|(
name|fieldName
argument_list|)
operator|&&
operator|!
name|fields
operator|.
name|contains
argument_list|(
literal|"*"
argument_list|)
condition|)
block|{
continue|continue;
comment|//we're not interested in this field Still an issue here
block|}
name|SimpleOrderedMap
argument_list|<
name|Object
argument_list|>
name|fieldMap
init|=
operator|new
name|SimpleOrderedMap
argument_list|<
name|Object
argument_list|>
argument_list|()
decl_stmt|;
name|SchemaField
name|sfield
init|=
name|schema
operator|.
name|getFieldOrNull
argument_list|(
name|fieldName
argument_list|)
decl_stmt|;
name|FieldType
name|ftype
init|=
operator|(
name|sfield
operator|==
literal|null
operator|)
condition|?
literal|null
else|:
name|sfield
operator|.
name|getType
argument_list|()
decl_stmt|;
name|fieldMap
operator|.
name|add
argument_list|(
literal|"type"
argument_list|,
operator|(
name|ftype
operator|==
literal|null
operator|)
condition|?
literal|null
else|:
name|ftype
operator|.
name|getTypeName
argument_list|()
argument_list|)
expr_stmt|;
name|fieldMap
operator|.
name|add
argument_list|(
literal|"schema"
argument_list|,
name|getFieldFlags
argument_list|(
name|sfield
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sfield
operator|!=
literal|null
operator|&&
name|schema
operator|.
name|isDynamicField
argument_list|(
name|sfield
operator|.
name|getName
argument_list|()
argument_list|)
operator|&&
name|schema
operator|.
name|getDynamicPattern
argument_list|(
name|sfield
operator|.
name|getName
argument_list|()
argument_list|)
operator|!=
literal|null
condition|)
block|{
name|fieldMap
operator|.
name|add
argument_list|(
literal|"dynamicBase"
argument_list|,
name|schema
operator|.
name|getDynamicPattern
argument_list|(
name|sfield
operator|.
name|getName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|Terms
name|terms
init|=
name|reader
operator|.
name|fields
argument_list|()
operator|.
name|terms
argument_list|(
name|fieldName
argument_list|)
decl_stmt|;
if|if
condition|(
name|terms
operator|==
literal|null
condition|)
block|{
comment|// Not indexed, so we need to report what we can (it made it through the fl param if specified)
name|finfo
operator|.
name|add
argument_list|(
name|fieldName
argument_list|,
name|fieldMap
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|sfield
operator|!=
literal|null
operator|&&
name|sfield
operator|.
name|indexed
argument_list|()
condition|)
block|{
comment|// In the pre-4.0 days, this did a veeeery expensive range query. But we can be much faster now,
comment|// so just do this all the time.
name|Document
name|doc
init|=
name|getFirstLiveDoc
argument_list|(
name|reader
argument_list|,
name|fieldName
argument_list|,
name|terms
argument_list|)
decl_stmt|;
if|if
condition|(
name|doc
operator|!=
literal|null
condition|)
block|{
comment|// Found a document with this field
try|try
block|{
name|IndexableField
name|fld
init|=
name|doc
operator|.
name|getField
argument_list|(
name|fieldName
argument_list|)
decl_stmt|;
if|if
condition|(
name|fld
operator|!=
literal|null
condition|)
block|{
name|fieldMap
operator|.
name|add
argument_list|(
literal|"index"
argument_list|,
name|getFieldFlags
argument_list|(
name|fld
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// it is a non-stored field...
name|fieldMap
operator|.
name|add
argument_list|(
literal|"index"
argument_list|,
literal|"(unstored field)"
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"error reading field: "
operator|+
name|fieldName
argument_list|)
expr_stmt|;
block|}
block|}
name|fieldMap
operator|.
name|add
argument_list|(
literal|"docs"
argument_list|,
name|terms
operator|.
name|getDocCount
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fields
operator|!=
literal|null
operator|&&
operator|(
name|fields
operator|.
name|contains
argument_list|(
name|fieldName
argument_list|)
operator|||
name|fields
operator|.
name|contains
argument_list|(
literal|"*"
argument_list|)
operator|)
condition|)
block|{
name|getDetailedFieldInfo
argument_list|(
name|req
argument_list|,
name|fieldName
argument_list|,
name|fieldMap
argument_list|)
expr_stmt|;
block|}
comment|// Add the field
name|finfo
operator|.
name|add
argument_list|(
name|fieldName
argument_list|,
name|fieldMap
argument_list|)
expr_stmt|;
block|}
return|return
name|finfo
return|;
block|}
comment|// Just get a document with the term in it, the first one will do!
comment|// Is there a better way to do this? Shouldn't actually be very costly
comment|// to do it this way.
DECL|method|getFirstLiveDoc
specifier|private
specifier|static
name|Document
name|getFirstLiveDoc
parameter_list|(
name|AtomicReader
name|reader
parameter_list|,
name|String
name|fieldName
parameter_list|,
name|Terms
name|terms
parameter_list|)
throws|throws
name|IOException
block|{
name|DocsEnum
name|docsEnum
init|=
literal|null
decl_stmt|;
name|TermsEnum
name|termsEnum
init|=
name|terms
operator|.
name|iterator
argument_list|(
literal|null
argument_list|)
decl_stmt|;
name|BytesRef
name|text
decl_stmt|;
comment|// Deal with the chance that the first bunch of terms are in deleted documents. Is there a better way?
for|for
control|(
name|int
name|idx
init|=
literal|0
init|;
name|idx
operator|<
literal|1000
operator|&&
name|docsEnum
operator|==
literal|null
condition|;
operator|++
name|idx
control|)
block|{
name|text
operator|=
name|termsEnum
operator|.
name|next
argument_list|()
expr_stmt|;
if|if
condition|(
name|text
operator|==
literal|null
condition|)
block|{
comment|// Ran off the end of the terms enum without finding any live docs with that field in them.
return|return
literal|null
return|;
block|}
name|Term
name|term
init|=
operator|new
name|Term
argument_list|(
name|fieldName
argument_list|,
name|text
argument_list|)
decl_stmt|;
name|docsEnum
operator|=
name|reader
operator|.
name|termDocsEnum
argument_list|(
name|reader
operator|.
name|getLiveDocs
argument_list|()
argument_list|,
name|term
operator|.
name|field
argument_list|()
argument_list|,
operator|new
name|BytesRef
argument_list|(
name|term
operator|.
name|text
argument_list|()
argument_list|)
argument_list|,
literal|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|docsEnum
operator|!=
literal|null
condition|)
block|{
name|int
name|docId
decl_stmt|;
if|if
condition|(
operator|(
name|docId
operator|=
name|docsEnum
operator|.
name|nextDoc
argument_list|()
operator|)
operator|!=
name|DocIdSetIterator
operator|.
name|NO_MORE_DOCS
condition|)
block|{
return|return
name|reader
operator|.
name|document
argument_list|(
name|docId
argument_list|)
return|;
block|}
block|}
block|}
return|return
literal|null
return|;
block|}
comment|/**    * Return info from the index    */
DECL|method|getSchemaInfo
specifier|private
specifier|static
name|SimpleOrderedMap
argument_list|<
name|Object
argument_list|>
name|getSchemaInfo
parameter_list|(
name|IndexSchema
name|schema
parameter_list|)
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|typeusemap
init|=
operator|new
name|TreeMap
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|fields
init|=
operator|new
name|TreeMap
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
argument_list|()
decl_stmt|;
name|SchemaField
name|uniqueField
init|=
name|schema
operator|.
name|getUniqueKeyField
argument_list|()
decl_stmt|;
for|for
control|(
name|SchemaField
name|f
range|:
name|schema
operator|.
name|getFields
argument_list|()
operator|.
name|values
argument_list|()
control|)
block|{
name|populateFieldInfo
argument_list|(
name|schema
argument_list|,
name|typeusemap
argument_list|,
name|fields
argument_list|,
name|uniqueField
argument_list|,
name|f
argument_list|)
expr_stmt|;
block|}
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|dynamicFields
init|=
operator|new
name|TreeMap
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|SchemaField
name|f
range|:
name|schema
operator|.
name|getDynamicFieldPrototypes
argument_list|()
control|)
block|{
name|populateFieldInfo
argument_list|(
name|schema
argument_list|,
name|typeusemap
argument_list|,
name|dynamicFields
argument_list|,
name|uniqueField
argument_list|,
name|f
argument_list|)
expr_stmt|;
block|}
name|SimpleOrderedMap
argument_list|<
name|Object
argument_list|>
name|types
init|=
operator|new
name|SimpleOrderedMap
argument_list|<
name|Object
argument_list|>
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|FieldType
argument_list|>
name|sortedTypes
init|=
operator|new
name|TreeMap
argument_list|<
name|String
argument_list|,
name|FieldType
argument_list|>
argument_list|(
name|schema
operator|.
name|getFieldTypes
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|FieldType
name|ft
range|:
name|sortedTypes
operator|.
name|values
argument_list|()
control|)
block|{
name|SimpleOrderedMap
argument_list|<
name|Object
argument_list|>
name|field
init|=
operator|new
name|SimpleOrderedMap
argument_list|<
name|Object
argument_list|>
argument_list|()
decl_stmt|;
name|field
operator|.
name|add
argument_list|(
literal|"fields"
argument_list|,
name|typeusemap
operator|.
name|get
argument_list|(
name|ft
operator|.
name|getTypeName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|field
operator|.
name|add
argument_list|(
literal|"tokenized"
argument_list|,
name|ft
operator|.
name|isTokenized
argument_list|()
argument_list|)
expr_stmt|;
name|field
operator|.
name|add
argument_list|(
literal|"className"
argument_list|,
name|ft
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|field
operator|.
name|add
argument_list|(
literal|"indexAnalyzer"
argument_list|,
name|getAnalyzerInfo
argument_list|(
name|ft
operator|.
name|getAnalyzer
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|field
operator|.
name|add
argument_list|(
literal|"queryAnalyzer"
argument_list|,
name|getAnalyzerInfo
argument_list|(
name|ft
operator|.
name|getQueryAnalyzer
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|types
operator|.
name|add
argument_list|(
name|ft
operator|.
name|getTypeName
argument_list|()
argument_list|,
name|field
argument_list|)
expr_stmt|;
block|}
comment|// Must go through this to maintain binary compatbility. Putting a TreeMap into a resp leads to casting errors
name|SimpleOrderedMap
argument_list|<
name|Object
argument_list|>
name|finfo
init|=
operator|new
name|SimpleOrderedMap
argument_list|<
name|Object
argument_list|>
argument_list|()
decl_stmt|;
name|SimpleOrderedMap
argument_list|<
name|Object
argument_list|>
name|fieldsSimple
init|=
operator|new
name|SimpleOrderedMap
argument_list|<
name|Object
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|ent
range|:
name|fields
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|fieldsSimple
operator|.
name|add
argument_list|(
name|ent
operator|.
name|getKey
argument_list|()
argument_list|,
name|ent
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|finfo
operator|.
name|add
argument_list|(
literal|"fields"
argument_list|,
name|fieldsSimple
argument_list|)
expr_stmt|;
name|SimpleOrderedMap
argument_list|<
name|Object
argument_list|>
name|dynamicSimple
init|=
operator|new
name|SimpleOrderedMap
argument_list|<
name|Object
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|ent
range|:
name|dynamicFields
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|dynamicSimple
operator|.
name|add
argument_list|(
name|ent
operator|.
name|getKey
argument_list|()
argument_list|,
name|ent
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|finfo
operator|.
name|add
argument_list|(
literal|"dynamicFields"
argument_list|,
name|dynamicSimple
argument_list|)
expr_stmt|;
name|finfo
operator|.
name|add
argument_list|(
literal|"uniqueKeyField"
argument_list|,
literal|null
operator|==
name|uniqueField
condition|?
literal|null
else|:
name|uniqueField
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|finfo
operator|.
name|add
argument_list|(
literal|"defaultSearchField"
argument_list|,
name|schema
operator|.
name|getDefaultSearchFieldName
argument_list|()
argument_list|)
expr_stmt|;
name|finfo
operator|.
name|add
argument_list|(
literal|"types"
argument_list|,
name|types
argument_list|)
expr_stmt|;
return|return
name|finfo
return|;
block|}
DECL|method|getAnalyzerInfo
specifier|private
specifier|static
name|SimpleOrderedMap
argument_list|<
name|Object
argument_list|>
name|getAnalyzerInfo
parameter_list|(
name|Analyzer
name|analyzer
parameter_list|)
block|{
name|SimpleOrderedMap
argument_list|<
name|Object
argument_list|>
name|aninfo
init|=
operator|new
name|SimpleOrderedMap
argument_list|<
name|Object
argument_list|>
argument_list|()
decl_stmt|;
name|aninfo
operator|.
name|add
argument_list|(
literal|"className"
argument_list|,
name|analyzer
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|analyzer
operator|instanceof
name|TokenizerChain
condition|)
block|{
name|TokenizerChain
name|tchain
init|=
operator|(
name|TokenizerChain
operator|)
name|analyzer
decl_stmt|;
name|CharFilterFactory
index|[]
name|cfiltfacs
init|=
name|tchain
operator|.
name|getCharFilterFactories
argument_list|()
decl_stmt|;
name|SimpleOrderedMap
argument_list|<
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
argument_list|>
name|cfilters
init|=
operator|new
name|SimpleOrderedMap
argument_list|<
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|CharFilterFactory
name|cfiltfac
range|:
name|cfiltfacs
control|)
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|tok
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
argument_list|()
decl_stmt|;
name|String
name|className
init|=
name|cfiltfac
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
decl_stmt|;
name|tok
operator|.
name|put
argument_list|(
literal|"className"
argument_list|,
name|className
argument_list|)
expr_stmt|;
name|tok
operator|.
name|put
argument_list|(
literal|"args"
argument_list|,
name|cfiltfac
operator|.
name|getArgs
argument_list|()
argument_list|)
expr_stmt|;
name|cfilters
operator|.
name|add
argument_list|(
name|className
operator|.
name|substring
argument_list|(
name|className
operator|.
name|lastIndexOf
argument_list|(
literal|'.'
argument_list|)
operator|+
literal|1
argument_list|)
argument_list|,
name|tok
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cfilters
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|aninfo
operator|.
name|add
argument_list|(
literal|"charFilters"
argument_list|,
name|cfilters
argument_list|)
expr_stmt|;
block|}
name|SimpleOrderedMap
argument_list|<
name|Object
argument_list|>
name|tokenizer
init|=
operator|new
name|SimpleOrderedMap
argument_list|<
name|Object
argument_list|>
argument_list|()
decl_stmt|;
name|TokenizerFactory
name|tfac
init|=
name|tchain
operator|.
name|getTokenizerFactory
argument_list|()
decl_stmt|;
name|tokenizer
operator|.
name|add
argument_list|(
literal|"className"
argument_list|,
name|tfac
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|tokenizer
operator|.
name|add
argument_list|(
literal|"args"
argument_list|,
name|tfac
operator|.
name|getArgs
argument_list|()
argument_list|)
expr_stmt|;
name|aninfo
operator|.
name|add
argument_list|(
literal|"tokenizer"
argument_list|,
name|tokenizer
argument_list|)
expr_stmt|;
name|TokenFilterFactory
index|[]
name|filtfacs
init|=
name|tchain
operator|.
name|getTokenFilterFactories
argument_list|()
decl_stmt|;
name|SimpleOrderedMap
argument_list|<
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
argument_list|>
name|filters
init|=
operator|new
name|SimpleOrderedMap
argument_list|<
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|TokenFilterFactory
name|filtfac
range|:
name|filtfacs
control|)
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|tok
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
argument_list|()
decl_stmt|;
name|String
name|className
init|=
name|filtfac
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
decl_stmt|;
name|tok
operator|.
name|put
argument_list|(
literal|"className"
argument_list|,
name|className
argument_list|)
expr_stmt|;
name|tok
operator|.
name|put
argument_list|(
literal|"args"
argument_list|,
name|filtfac
operator|.
name|getArgs
argument_list|()
argument_list|)
expr_stmt|;
name|filters
operator|.
name|add
argument_list|(
name|className
operator|.
name|substring
argument_list|(
name|className
operator|.
name|lastIndexOf
argument_list|(
literal|'.'
argument_list|)
operator|+
literal|1
argument_list|)
argument_list|,
name|tok
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|filters
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|aninfo
operator|.
name|add
argument_list|(
literal|"filters"
argument_list|,
name|filters
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|aninfo
return|;
block|}
DECL|method|populateFieldInfo
specifier|private
specifier|static
name|void
name|populateFieldInfo
parameter_list|(
name|IndexSchema
name|schema
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|typeusemap
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|fields
parameter_list|,
name|SchemaField
name|uniqueField
parameter_list|,
name|SchemaField
name|f
parameter_list|)
block|{
name|FieldType
name|ft
init|=
name|f
operator|.
name|getType
argument_list|()
decl_stmt|;
name|SimpleOrderedMap
argument_list|<
name|Object
argument_list|>
name|field
init|=
operator|new
name|SimpleOrderedMap
argument_list|<
name|Object
argument_list|>
argument_list|()
decl_stmt|;
name|field
operator|.
name|add
argument_list|(
literal|"type"
argument_list|,
name|ft
operator|.
name|getTypeName
argument_list|()
argument_list|)
expr_stmt|;
name|field
operator|.
name|add
argument_list|(
literal|"flags"
argument_list|,
name|getFieldFlags
argument_list|(
name|f
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|.
name|isRequired
argument_list|()
condition|)
block|{
name|field
operator|.
name|add
argument_list|(
literal|"required"
argument_list|,
name|f
operator|.
name|isRequired
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|f
operator|.
name|getDefaultValue
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|field
operator|.
name|add
argument_list|(
literal|"default"
argument_list|,
name|f
operator|.
name|getDefaultValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|f
operator|==
name|uniqueField
condition|)
block|{
name|field
operator|.
name|add
argument_list|(
literal|"uniqueKey"
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ft
operator|.
name|getAnalyzer
argument_list|()
operator|.
name|getPositionIncrementGap
argument_list|(
name|f
operator|.
name|getName
argument_list|()
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|field
operator|.
name|add
argument_list|(
literal|"positionIncrementGap"
argument_list|,
name|ft
operator|.
name|getAnalyzer
argument_list|()
operator|.
name|getPositionIncrementGap
argument_list|(
name|f
operator|.
name|getName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|field
operator|.
name|add
argument_list|(
literal|"copyDests"
argument_list|,
name|schema
operator|.
name|getCopyFieldsList
argument_list|(
name|f
operator|.
name|getName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|field
operator|.
name|add
argument_list|(
literal|"copySources"
argument_list|,
name|schema
operator|.
name|getCopySources
argument_list|(
name|f
operator|.
name|getName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|fields
operator|.
name|put
argument_list|(
name|f
operator|.
name|getName
argument_list|()
argument_list|,
name|field
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|v
init|=
name|typeusemap
operator|.
name|get
argument_list|(
name|ft
operator|.
name|getTypeName
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|v
operator|==
literal|null
condition|)
block|{
name|v
operator|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
expr_stmt|;
block|}
name|v
operator|.
name|add
argument_list|(
name|f
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|typeusemap
operator|.
name|put
argument_list|(
name|ft
operator|.
name|getTypeName
argument_list|()
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
comment|/**    * @deprecated use {@link #getIndexInfo(DirectoryReader)} since you now have to explicitly pass the "fl" prameter    * and this was always called with "false" anyway from CoreAdminHandler    */
DECL|method|getIndexInfo
specifier|public
specifier|static
name|SimpleOrderedMap
argument_list|<
name|Object
argument_list|>
name|getIndexInfo
parameter_list|(
name|DirectoryReader
name|reader
parameter_list|,
name|boolean
name|detail
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|getIndexInfo
argument_list|(
name|reader
argument_list|)
return|;
block|}
comment|// This method just gets the top-most level of information. This was conflated with getting detailed info
comment|// for *all* the fields, called from CoreAdminHandler etc.
DECL|method|getIndexInfo
specifier|public
specifier|static
name|SimpleOrderedMap
argument_list|<
name|Object
argument_list|>
name|getIndexInfo
parameter_list|(
name|DirectoryReader
name|reader
parameter_list|)
throws|throws
name|IOException
block|{
name|Directory
name|dir
init|=
name|reader
operator|.
name|directory
argument_list|()
decl_stmt|;
name|SimpleOrderedMap
argument_list|<
name|Object
argument_list|>
name|indexInfo
init|=
operator|new
name|SimpleOrderedMap
argument_list|<
name|Object
argument_list|>
argument_list|()
decl_stmt|;
name|indexInfo
operator|.
name|add
argument_list|(
literal|"numDocs"
argument_list|,
name|reader
operator|.
name|numDocs
argument_list|()
argument_list|)
expr_stmt|;
name|indexInfo
operator|.
name|add
argument_list|(
literal|"maxDoc"
argument_list|,
name|reader
operator|.
name|maxDoc
argument_list|()
argument_list|)
expr_stmt|;
name|indexInfo
operator|.
name|add
argument_list|(
literal|"version"
argument_list|,
name|reader
operator|.
name|getVersion
argument_list|()
argument_list|)
expr_stmt|;
comment|// TODO? Is this different then: IndexReader.getCurrentVersion( dir )?
name|indexInfo
operator|.
name|add
argument_list|(
literal|"segmentCount"
argument_list|,
name|reader
operator|.
name|getSequentialSubReaders
argument_list|()
operator|.
name|length
argument_list|)
expr_stmt|;
name|indexInfo
operator|.
name|add
argument_list|(
literal|"current"
argument_list|,
name|reader
operator|.
name|isCurrent
argument_list|()
argument_list|)
expr_stmt|;
name|indexInfo
operator|.
name|add
argument_list|(
literal|"hasDeletions"
argument_list|,
name|reader
operator|.
name|hasDeletions
argument_list|()
argument_list|)
expr_stmt|;
name|indexInfo
operator|.
name|add
argument_list|(
literal|"directory"
argument_list|,
name|dir
argument_list|)
expr_stmt|;
name|indexInfo
operator|.
name|add
argument_list|(
literal|"userData"
argument_list|,
name|reader
operator|.
name|getIndexCommit
argument_list|()
operator|.
name|getUserData
argument_list|()
argument_list|)
expr_stmt|;
name|String
name|s
init|=
name|reader
operator|.
name|getIndexCommit
argument_list|()
operator|.
name|getUserData
argument_list|()
operator|.
name|get
argument_list|(
name|SolrIndexWriter
operator|.
name|COMMIT_TIME_MSEC_KEY
argument_list|)
decl_stmt|;
if|if
condition|(
name|s
operator|!=
literal|null
condition|)
block|{
name|indexInfo
operator|.
name|add
argument_list|(
literal|"lastModified"
argument_list|,
operator|new
name|Date
argument_list|(
name|Long
operator|.
name|parseLong
argument_list|(
name|s
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|indexInfo
return|;
block|}
comment|// Get terribly detailed information about a particular field. This is a very expensive call, use it with caution
comment|// especially on large indexes!
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|getDetailedFieldInfo
specifier|private
specifier|static
name|void
name|getDetailedFieldInfo
parameter_list|(
name|SolrQueryRequest
name|req
parameter_list|,
name|String
name|field
parameter_list|,
name|SimpleOrderedMap
argument_list|<
name|Object
argument_list|>
name|fieldMap
parameter_list|)
throws|throws
name|IOException
block|{
name|SolrParams
name|params
init|=
name|req
operator|.
name|getParams
argument_list|()
decl_stmt|;
name|int
name|numTerms
init|=
name|params
operator|.
name|getInt
argument_list|(
name|NUMTERMS
argument_list|,
name|DEFAULT_COUNT
argument_list|)
decl_stmt|;
name|TopTermQueue
name|tiq
init|=
operator|new
name|TopTermQueue
argument_list|(
name|numTerms
operator|+
literal|1
argument_list|)
decl_stmt|;
comment|// Something to collect the top N terms in.
specifier|final
name|CharsRef
name|spare
init|=
operator|new
name|CharsRef
argument_list|()
decl_stmt|;
name|Fields
name|fields
init|=
name|MultiFields
operator|.
name|getFields
argument_list|(
name|req
operator|.
name|getSearcher
argument_list|()
operator|.
name|getIndexReader
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|fields
operator|==
literal|null
condition|)
block|{
comment|// No indexed fields
return|return;
block|}
name|Terms
name|terms
init|=
name|fields
operator|.
name|terms
argument_list|(
name|field
argument_list|)
decl_stmt|;
if|if
condition|(
name|terms
operator|==
literal|null
condition|)
block|{
comment|// No terms in the field.
return|return;
block|}
name|TermsEnum
name|termsEnum
init|=
name|terms
operator|.
name|iterator
argument_list|(
literal|null
argument_list|)
decl_stmt|;
name|BytesRef
name|text
decl_stmt|;
name|int
index|[]
name|buckets
init|=
operator|new
name|int
index|[
name|HIST_ARRAY_SIZE
index|]
decl_stmt|;
while|while
condition|(
operator|(
name|text
operator|=
name|termsEnum
operator|.
name|next
argument_list|()
operator|)
operator|!=
literal|null
condition|)
block|{
name|int
name|freq
init|=
name|termsEnum
operator|.
name|docFreq
argument_list|()
decl_stmt|;
comment|// This calculation seems odd, but it gives the same results as it used to.
name|int
name|slot
init|=
literal|32
operator|-
name|Integer
operator|.
name|numberOfLeadingZeros
argument_list|(
name|Math
operator|.
name|max
argument_list|(
literal|0
argument_list|,
name|freq
operator|-
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|buckets
index|[
name|slot
index|]
operator|=
name|buckets
index|[
name|slot
index|]
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|freq
operator|>
name|tiq
operator|.
name|minFreq
condition|)
block|{
name|UnicodeUtil
operator|.
name|UTF8toUTF16
argument_list|(
name|text
argument_list|,
name|spare
argument_list|)
expr_stmt|;
name|String
name|t
init|=
name|spare
operator|.
name|toString
argument_list|()
decl_stmt|;
name|tiq
operator|.
name|distinctTerms
operator|=
operator|new
name|Long
argument_list|(
name|terms
operator|.
name|size
argument_list|()
argument_list|)
operator|.
name|intValue
argument_list|()
expr_stmt|;
name|tiq
operator|.
name|add
argument_list|(
operator|new
name|TopTermQueue
operator|.
name|TermInfo
argument_list|(
operator|new
name|Term
argument_list|(
name|field
argument_list|,
name|t
argument_list|)
argument_list|,
name|termsEnum
operator|.
name|docFreq
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tiq
operator|.
name|size
argument_list|()
operator|>
name|numTerms
condition|)
block|{
comment|// if tiq full
name|tiq
operator|.
name|pop
argument_list|()
expr_stmt|;
comment|// remove lowest in tiq
name|tiq
operator|.
name|minFreq
operator|=
name|tiq
operator|.
name|getTopTermInfo
argument_list|()
operator|.
name|docFreq
expr_stmt|;
block|}
block|}
block|}
name|tiq
operator|.
name|histogram
operator|.
name|add
argument_list|(
name|buckets
argument_list|)
expr_stmt|;
name|fieldMap
operator|.
name|add
argument_list|(
literal|"distinct"
argument_list|,
name|tiq
operator|.
name|distinctTerms
argument_list|)
expr_stmt|;
comment|// Include top terms
name|fieldMap
operator|.
name|add
argument_list|(
literal|"topTerms"
argument_list|,
name|tiq
operator|.
name|toNamedList
argument_list|(
name|req
operator|.
name|getSearcher
argument_list|()
operator|.
name|getSchema
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
comment|// Add a histogram
name|fieldMap
operator|.
name|add
argument_list|(
literal|"histogram"
argument_list|,
name|tiq
operator|.
name|histogram
operator|.
name|toNamedList
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|//////////////////////// SolrInfoMBeans methods //////////////////////
annotation|@
name|Override
DECL|method|getDescription
specifier|public
name|String
name|getDescription
parameter_list|()
block|{
return|return
literal|"Lucene Index Browser.  Inspired and modeled after Luke: http://www.getopt.org/luke/"
return|;
block|}
annotation|@
name|Override
DECL|method|getSource
specifier|public
name|String
name|getSource
parameter_list|()
block|{
return|return
literal|"$URL$"
return|;
block|}
annotation|@
name|Override
DECL|method|getDocs
specifier|public
name|URL
index|[]
name|getDocs
parameter_list|()
block|{
try|try
block|{
return|return
operator|new
name|URL
index|[]
block|{
operator|new
name|URL
argument_list|(
literal|"http://wiki.apache.org/solr/LukeRequestHandler"
argument_list|)
block|}
return|;
block|}
catch|catch
parameter_list|(
name|MalformedURLException
name|ex
parameter_list|)
block|{
return|return
literal|null
return|;
block|}
block|}
comment|///////////////////////////////////////////////////////////////////////////////////////
DECL|class|TermHistogram
specifier|static
class|class
name|TermHistogram
block|{
DECL|field|_maxBucket
name|int
name|_maxBucket
init|=
operator|-
literal|1
decl_stmt|;
DECL|field|_buckets
name|int
name|_buckets
index|[]
init|=
operator|new
name|int
index|[
name|HIST_ARRAY_SIZE
index|]
decl_stmt|;
DECL|method|add
specifier|public
name|void
name|add
parameter_list|(
name|int
index|[]
name|buckets
parameter_list|)
block|{
for|for
control|(
name|int
name|idx
init|=
literal|0
init|;
name|idx
operator|<
name|buckets
operator|.
name|length
condition|;
operator|++
name|idx
control|)
block|{
if|if
condition|(
name|buckets
index|[
name|idx
index|]
operator|!=
literal|0
condition|)
name|_maxBucket
operator|=
name|idx
expr_stmt|;
block|}
for|for
control|(
name|int
name|idx
init|=
literal|0
init|;
name|idx
operator|<=
name|_maxBucket
condition|;
operator|++
name|idx
control|)
block|{
name|_buckets
index|[
name|idx
index|]
operator|=
name|buckets
index|[
name|idx
index|]
expr_stmt|;
block|}
block|}
comment|// TODO? should this be a list or a map?
DECL|method|toNamedList
specifier|public
name|NamedList
argument_list|<
name|Integer
argument_list|>
name|toNamedList
parameter_list|()
block|{
name|NamedList
argument_list|<
name|Integer
argument_list|>
name|nl
init|=
operator|new
name|NamedList
argument_list|<
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|bucket
init|=
literal|0
init|;
name|bucket
operator|<=
name|_maxBucket
condition|;
name|bucket
operator|++
control|)
block|{
name|nl
operator|.
name|add
argument_list|(
literal|""
operator|+
operator|(
literal|1
operator|<<
name|bucket
operator|)
argument_list|,
name|_buckets
index|[
name|bucket
index|]
argument_list|)
expr_stmt|;
block|}
return|return
name|nl
return|;
block|}
block|}
comment|/**    * Private internal class that counts up frequent terms    */
DECL|class|TopTermQueue
specifier|private
specifier|static
class|class
name|TopTermQueue
extends|extends
name|PriorityQueue
block|{
DECL|class|TermInfo
specifier|static
class|class
name|TermInfo
block|{
DECL|method|TermInfo
name|TermInfo
parameter_list|(
name|Term
name|t
parameter_list|,
name|int
name|df
parameter_list|)
block|{
name|term
operator|=
name|t
expr_stmt|;
name|docFreq
operator|=
name|df
expr_stmt|;
block|}
DECL|field|docFreq
name|int
name|docFreq
decl_stmt|;
DECL|field|term
name|Term
name|term
decl_stmt|;
block|}
DECL|field|minFreq
specifier|public
name|int
name|minFreq
init|=
literal|0
decl_stmt|;
DECL|field|distinctTerms
specifier|public
name|int
name|distinctTerms
init|=
literal|0
decl_stmt|;
DECL|field|histogram
specifier|public
name|TermHistogram
name|histogram
decl_stmt|;
DECL|method|TopTermQueue
name|TopTermQueue
parameter_list|(
name|int
name|size
parameter_list|)
block|{
name|super
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|histogram
operator|=
operator|new
name|TermHistogram
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|lessThan
specifier|protected
specifier|final
name|boolean
name|lessThan
parameter_list|(
name|Object
name|a
parameter_list|,
name|Object
name|b
parameter_list|)
block|{
name|TermInfo
name|termInfoA
init|=
operator|(
name|TermInfo
operator|)
name|a
decl_stmt|;
name|TermInfo
name|termInfoB
init|=
operator|(
name|TermInfo
operator|)
name|b
decl_stmt|;
return|return
name|termInfoA
operator|.
name|docFreq
operator|<
name|termInfoB
operator|.
name|docFreq
return|;
block|}
comment|/**      * This is a destructive call... the queue is empty at the end      */
DECL|method|toNamedList
specifier|public
name|NamedList
argument_list|<
name|Integer
argument_list|>
name|toNamedList
parameter_list|(
name|IndexSchema
name|schema
parameter_list|)
block|{
comment|// reverse the list..
name|List
argument_list|<
name|TermInfo
argument_list|>
name|aslist
init|=
operator|new
name|LinkedList
argument_list|<
name|TermInfo
argument_list|>
argument_list|()
decl_stmt|;
while|while
condition|(
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|aslist
operator|.
name|add
argument_list|(
literal|0
argument_list|,
operator|(
name|TermInfo
operator|)
name|pop
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|NamedList
argument_list|<
name|Integer
argument_list|>
name|list
init|=
operator|new
name|NamedList
argument_list|<
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|TermInfo
name|i
range|:
name|aslist
control|)
block|{
name|String
name|txt
init|=
name|i
operator|.
name|term
operator|.
name|text
argument_list|()
decl_stmt|;
name|SchemaField
name|ft
init|=
name|schema
operator|.
name|getFieldOrNull
argument_list|(
name|i
operator|.
name|term
operator|.
name|field
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|ft
operator|!=
literal|null
condition|)
block|{
name|txt
operator|=
name|ft
operator|.
name|getType
argument_list|()
operator|.
name|indexedToReadable
argument_list|(
name|txt
argument_list|)
expr_stmt|;
block|}
name|list
operator|.
name|add
argument_list|(
name|txt
argument_list|,
name|i
operator|.
name|docFreq
argument_list|)
expr_stmt|;
block|}
return|return
name|list
return|;
block|}
DECL|method|getTopTermInfo
specifier|public
name|TermInfo
name|getTopTermInfo
parameter_list|()
block|{
return|return
operator|(
name|TermInfo
operator|)
name|top
argument_list|()
return|;
block|}
block|}
block|}
end_class
end_unit
