begin_unit
begin_package
DECL|package|org.apache.solr.handler.component
package|package
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|handler
operator|.
name|component
package|;
end_package
begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|invoke
operator|.
name|MethodHandles
import|;
end_import
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Date
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|EnumSet
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashMap
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|SolrException
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|params
operator|.
name|FacetParams
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|params
operator|.
name|GroupParams
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|params
operator|.
name|RequiredSolrParams
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|params
operator|.
name|SolrParams
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|util
operator|.
name|NamedList
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|util
operator|.
name|SimpleOrderedMap
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|schema
operator|.
name|DateRangeField
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|schema
operator|.
name|FieldType
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|schema
operator|.
name|IndexSchema
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|schema
operator|.
name|SchemaField
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|schema
operator|.
name|TrieDateField
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|schema
operator|.
name|TrieField
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|util
operator|.
name|DateMathParser
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|util
operator|.
name|DateFormatUtil
import|;
end_import
begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import
begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import
begin_comment
comment|/**  * Encapsulates a single facet.range request along with all its parameters. This class  * calculates all the ranges (gaps) required to be counted.  */
end_comment
begin_class
DECL|class|RangeFacetRequest
specifier|public
class|class
name|RangeFacetRequest
extends|extends
name|FacetComponent
operator|.
name|FacetBase
block|{
DECL|field|log
specifier|private
specifier|static
specifier|final
name|Logger
name|log
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|MethodHandles
operator|.
name|lookup
argument_list|()
operator|.
name|lookupClass
argument_list|()
argument_list|)
decl_stmt|;
DECL|field|schemaField
specifier|protected
specifier|final
name|SchemaField
name|schemaField
decl_stmt|;
DECL|field|start
specifier|protected
specifier|final
name|String
name|start
decl_stmt|;
DECL|field|end
specifier|protected
specifier|final
name|String
name|end
decl_stmt|;
DECL|field|gap
specifier|protected
specifier|final
name|String
name|gap
decl_stmt|;
DECL|field|hardEnd
specifier|protected
specifier|final
name|boolean
name|hardEnd
decl_stmt|;
DECL|field|include
specifier|protected
specifier|final
name|EnumSet
argument_list|<
name|FacetParams
operator|.
name|FacetRangeInclude
argument_list|>
name|include
decl_stmt|;
DECL|field|others
specifier|protected
specifier|final
name|EnumSet
argument_list|<
name|FacetParams
operator|.
name|FacetRangeOther
argument_list|>
name|others
decl_stmt|;
DECL|field|method
specifier|protected
specifier|final
name|FacetParams
operator|.
name|FacetRangeMethod
name|method
decl_stmt|;
DECL|field|minCount
specifier|protected
specifier|final
name|int
name|minCount
decl_stmt|;
DECL|field|groupFacet
specifier|protected
specifier|final
name|boolean
name|groupFacet
decl_stmt|;
DECL|field|facetRanges
specifier|protected
specifier|final
name|List
argument_list|<
name|FacetRange
argument_list|>
name|facetRanges
decl_stmt|;
comment|/**    * The computed start value of this range    */
DECL|field|startObj
specifier|protected
specifier|final
name|Object
name|startObj
decl_stmt|;
comment|/**    * The computed end value of this range taking into account facet.range.hardend    */
DECL|field|endObj
specifier|protected
specifier|final
name|Object
name|endObj
decl_stmt|;
comment|/**    * The computed gap between each range    */
DECL|field|gapObj
specifier|protected
specifier|final
name|Object
name|gapObj
decl_stmt|;
DECL|method|RangeFacetRequest
specifier|public
name|RangeFacetRequest
parameter_list|(
name|ResponseBuilder
name|rb
parameter_list|,
name|String
name|f
parameter_list|)
block|{
name|super
argument_list|(
name|rb
argument_list|,
name|FacetParams
operator|.
name|FACET_RANGE
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|IndexSchema
name|schema
init|=
name|rb
operator|.
name|req
operator|.
name|getSchema
argument_list|()
decl_stmt|;
name|this
operator|.
name|schemaField
operator|=
name|schema
operator|.
name|getField
argument_list|(
name|facetOn
argument_list|)
expr_stmt|;
name|SolrParams
name|params
init|=
name|SolrParams
operator|.
name|wrapDefaults
argument_list|(
name|localParams
argument_list|,
name|rb
operator|.
name|req
operator|.
name|getParams
argument_list|()
argument_list|)
decl_stmt|;
name|SolrParams
name|required
init|=
operator|new
name|RequiredSolrParams
argument_list|(
name|params
argument_list|)
decl_stmt|;
name|String
name|methodStr
init|=
name|params
operator|.
name|get
argument_list|(
name|FacetParams
operator|.
name|FACET_RANGE_METHOD
argument_list|)
decl_stmt|;
name|FacetParams
operator|.
name|FacetRangeMethod
name|method
init|=
operator|(
name|methodStr
operator|==
literal|null
condition|?
name|FacetParams
operator|.
name|FacetRangeMethod
operator|.
name|getDefault
argument_list|()
else|:
name|FacetParams
operator|.
name|FacetRangeMethod
operator|.
name|get
argument_list|(
name|methodStr
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
operator|(
name|schemaField
operator|.
name|getType
argument_list|()
operator|instanceof
name|DateRangeField
operator|)
operator|&&
name|method
operator|.
name|equals
argument_list|(
name|FacetParams
operator|.
name|FacetRangeMethod
operator|.
name|DV
argument_list|)
condition|)
block|{
comment|// the user has explicitly selected the FacetRangeMethod.DV method
name|log
operator|.
name|warn
argument_list|(
literal|"Range facet method '"
operator|+
name|FacetParams
operator|.
name|FacetRangeMethod
operator|.
name|DV
operator|+
literal|"' is not supported together with field type '"
operator|+
name|DateRangeField
operator|.
name|class
operator|+
literal|"'. Will use method '"
operator|+
name|FacetParams
operator|.
name|FacetRangeMethod
operator|.
name|FILTER
operator|+
literal|"' instead"
argument_list|)
expr_stmt|;
name|method
operator|=
name|FacetParams
operator|.
name|FacetRangeMethod
operator|.
name|FILTER
expr_stmt|;
block|}
name|this
operator|.
name|start
operator|=
name|required
operator|.
name|getFieldParam
argument_list|(
name|facetOn
argument_list|,
name|FacetParams
operator|.
name|FACET_RANGE_START
argument_list|)
expr_stmt|;
name|this
operator|.
name|end
operator|=
name|required
operator|.
name|getFieldParam
argument_list|(
name|facetOn
argument_list|,
name|FacetParams
operator|.
name|FACET_RANGE_END
argument_list|)
expr_stmt|;
name|this
operator|.
name|gap
operator|=
name|required
operator|.
name|getFieldParam
argument_list|(
name|facetOn
argument_list|,
name|FacetParams
operator|.
name|FACET_RANGE_GAP
argument_list|)
expr_stmt|;
name|this
operator|.
name|minCount
operator|=
name|params
operator|.
name|getFieldInt
argument_list|(
name|facetOn
argument_list|,
name|FacetParams
operator|.
name|FACET_MINCOUNT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|this
operator|.
name|include
operator|=
name|FacetParams
operator|.
name|FacetRangeInclude
operator|.
name|parseParam
argument_list|(
name|params
operator|.
name|getFieldParams
argument_list|(
name|facetOn
argument_list|,
name|FacetParams
operator|.
name|FACET_RANGE_INCLUDE
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|hardEnd
operator|=
name|params
operator|.
name|getFieldBool
argument_list|(
name|facetOn
argument_list|,
name|FacetParams
operator|.
name|FACET_RANGE_HARD_END
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|this
operator|.
name|others
operator|=
name|EnumSet
operator|.
name|noneOf
argument_list|(
name|FacetParams
operator|.
name|FacetRangeOther
operator|.
name|class
argument_list|)
expr_stmt|;
specifier|final
name|String
index|[]
name|othersP
init|=
name|params
operator|.
name|getFieldParams
argument_list|(
name|facetOn
argument_list|,
name|FacetParams
operator|.
name|FACET_RANGE_OTHER
argument_list|)
decl_stmt|;
if|if
condition|(
name|othersP
operator|!=
literal|null
operator|&&
name|othersP
operator|.
name|length
operator|>
literal|0
condition|)
block|{
for|for
control|(
specifier|final
name|String
name|o
range|:
name|othersP
control|)
block|{
name|others
operator|.
name|add
argument_list|(
name|FacetParams
operator|.
name|FacetRangeOther
operator|.
name|get
argument_list|(
name|o
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|this
operator|.
name|groupFacet
operator|=
name|params
operator|.
name|getBool
argument_list|(
name|GroupParams
operator|.
name|GROUP_FACET
argument_list|,
literal|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|groupFacet
operator|&&
name|method
operator|.
name|equals
argument_list|(
name|FacetParams
operator|.
name|FacetRangeMethod
operator|.
name|DV
argument_list|)
condition|)
block|{
comment|// the user has explicitly selected the FacetRangeMethod.DV method
name|log
operator|.
name|warn
argument_list|(
literal|"Range facet method '"
operator|+
name|FacetParams
operator|.
name|FacetRangeMethod
operator|.
name|DV
operator|+
literal|"' is not supported together with '"
operator|+
name|GroupParams
operator|.
name|GROUP_FACET
operator|+
literal|"'. Will use method '"
operator|+
name|FacetParams
operator|.
name|FacetRangeMethod
operator|.
name|FILTER
operator|+
literal|"' instead"
argument_list|)
expr_stmt|;
name|method
operator|=
name|FacetParams
operator|.
name|FacetRangeMethod
operator|.
name|FILTER
expr_stmt|;
block|}
name|this
operator|.
name|method
operator|=
name|method
expr_stmt|;
name|RangeEndpointCalculator
argument_list|<
name|?
extends|extends
name|Comparable
argument_list|<
name|?
argument_list|>
argument_list|>
name|calculator
init|=
name|createCalculator
argument_list|()
decl_stmt|;
name|this
operator|.
name|facetRanges
operator|=
name|calculator
operator|.
name|computeRanges
argument_list|()
expr_stmt|;
name|this
operator|.
name|gapObj
operator|=
name|calculator
operator|.
name|getGap
argument_list|()
expr_stmt|;
name|this
operator|.
name|startObj
operator|=
name|calculator
operator|.
name|getStart
argument_list|()
expr_stmt|;
name|this
operator|.
name|endObj
operator|=
name|calculator
operator|.
name|getComputedEnd
argument_list|()
expr_stmt|;
block|}
comment|/**    * Creates the right instance of {@link org.apache.solr.handler.component.RangeFacetRequest.RangeEndpointCalculator}    * depending on the field type of the schema field    */
DECL|method|createCalculator
specifier|private
name|RangeEndpointCalculator
argument_list|<
name|?
extends|extends
name|Comparable
argument_list|<
name|?
argument_list|>
argument_list|>
name|createCalculator
parameter_list|()
block|{
name|RangeEndpointCalculator
argument_list|<
name|?
argument_list|>
name|calc
decl_stmt|;
name|FieldType
name|ft
init|=
name|schemaField
operator|.
name|getType
argument_list|()
decl_stmt|;
if|if
condition|(
name|ft
operator|instanceof
name|TrieField
condition|)
block|{
specifier|final
name|TrieField
name|trie
init|=
operator|(
name|TrieField
operator|)
name|ft
decl_stmt|;
switch|switch
condition|(
name|trie
operator|.
name|getType
argument_list|()
condition|)
block|{
case|case
name|FLOAT
case|:
name|calc
operator|=
operator|new
name|FloatRangeEndpointCalculator
argument_list|(
name|this
argument_list|)
expr_stmt|;
break|break;
case|case
name|DOUBLE
case|:
name|calc
operator|=
operator|new
name|DoubleRangeEndpointCalculator
argument_list|(
name|this
argument_list|)
expr_stmt|;
break|break;
case|case
name|INTEGER
case|:
name|calc
operator|=
operator|new
name|IntegerRangeEndpointCalculator
argument_list|(
name|this
argument_list|)
expr_stmt|;
break|break;
case|case
name|LONG
case|:
name|calc
operator|=
operator|new
name|LongRangeEndpointCalculator
argument_list|(
name|this
argument_list|)
expr_stmt|;
break|break;
case|case
name|DATE
case|:
name|calc
operator|=
operator|new
name|DateRangeEndpointCalculator
argument_list|(
name|this
argument_list|,
literal|null
argument_list|)
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|SolrException
argument_list|(
name|SolrException
operator|.
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
literal|"Unable to range facet on tried field of unexpected type:"
operator|+
name|this
operator|.
name|facetOn
argument_list|)
throw|;
block|}
block|}
elseif|else
if|if
condition|(
name|ft
operator|instanceof
name|DateRangeField
condition|)
block|{
name|calc
operator|=
operator|new
name|DateRangeFieldEndpointCalculator
argument_list|(
name|this
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|SolrException
operator|.
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
literal|"Unable to range facet on field:"
operator|+
name|schemaField
argument_list|)
throw|;
block|}
return|return
name|calc
return|;
block|}
comment|/**    * @return the start of this range as specified by {@link FacetParams#FACET_RANGE_START} parameter    */
DECL|method|getStart
specifier|public
name|String
name|getStart
parameter_list|()
block|{
return|return
name|start
return|;
block|}
comment|/**    * The end of this facet.range as specified by {@link FacetParams#FACET_RANGE_END} parameter    *<p>    * Note that the actual computed end value can be different depending on the    * {@link FacetParams#FACET_RANGE_HARD_END} parameter. See {@link #endObj}    */
DECL|method|getEnd
specifier|public
name|String
name|getEnd
parameter_list|()
block|{
return|return
name|end
return|;
block|}
comment|/**    * @return an {@link EnumSet} containing all the values specified via    * {@link FacetParams#FACET_RANGE_INCLUDE} parameter. Defaults to    * {@link org.apache.solr.common.params.FacetParams.FacetRangeInclude#LOWER} if no parameter    * is supplied. Includes all values from {@link org.apache.solr.common.params.FacetParams.FacetRangeInclude} enum    * if {@link FacetParams#FACET_RANGE_INCLUDE} includes    * {@link org.apache.solr.common.params.FacetParams.FacetRangeInclude#ALL}    */
DECL|method|getInclude
specifier|public
name|EnumSet
argument_list|<
name|FacetParams
operator|.
name|FacetRangeInclude
argument_list|>
name|getInclude
parameter_list|()
block|{
return|return
name|include
return|;
block|}
comment|/**    * @return the gap as specified by {@link FacetParams#FACET_RANGE_GAP} parameter    */
DECL|method|getGap
specifier|public
name|String
name|getGap
parameter_list|()
block|{
return|return
name|gap
return|;
block|}
comment|/**    * @return the computed gap object    */
DECL|method|getGapObj
specifier|public
name|Object
name|getGapObj
parameter_list|()
block|{
return|return
name|gapObj
return|;
block|}
comment|/**    * @return the boolean value of {@link FacetParams#FACET_RANGE_HARD_END} parameter    */
DECL|method|isHardEnd
specifier|public
name|boolean
name|isHardEnd
parameter_list|()
block|{
return|return
name|hardEnd
return|;
block|}
comment|/**    * @return an {@link EnumSet} of {@link org.apache.solr.common.params.FacetParams.FacetRangeOther} values    * specified by {@link FacetParams#FACET_RANGE_OTHER} parameter    */
DECL|method|getOthers
specifier|public
name|EnumSet
argument_list|<
name|FacetParams
operator|.
name|FacetRangeOther
argument_list|>
name|getOthers
parameter_list|()
block|{
return|return
name|others
return|;
block|}
comment|/**    * @return the {@link org.apache.solr.common.params.FacetParams.FacetRangeMethod} to be used for computing    * ranges determined either by the value of {@link FacetParams#FACET_RANGE_METHOD} parameter    * or other internal constraints.    */
DECL|method|getMethod
specifier|public
name|FacetParams
operator|.
name|FacetRangeMethod
name|getMethod
parameter_list|()
block|{
return|return
name|method
return|;
block|}
comment|/**    * @return the minimum allowed count for facet ranges as specified by {@link FacetParams#FACET_MINCOUNT}    */
DECL|method|getMinCount
specifier|public
name|int
name|getMinCount
parameter_list|()
block|{
return|return
name|minCount
return|;
block|}
comment|/**    * @return the {@link SchemaField} instance representing the field on which ranges have to be calculated    */
DECL|method|getSchemaField
specifier|public
name|SchemaField
name|getSchemaField
parameter_list|()
block|{
return|return
name|schemaField
return|;
block|}
comment|/**    * @return the boolean value specified by {@link GroupParams#GROUP_FACET} parameter    */
DECL|method|isGroupFacet
specifier|public
name|boolean
name|isGroupFacet
parameter_list|()
block|{
return|return
name|groupFacet
return|;
block|}
comment|/**    * @return a {@link List} of {@link org.apache.solr.handler.component.RangeFacetRequest.FacetRange} objects    * representing the ranges (gaps) for which range counts are to be calculated.    */
DECL|method|getFacetRanges
specifier|public
name|List
argument_list|<
name|FacetRange
argument_list|>
name|getFacetRanges
parameter_list|()
block|{
return|return
name|facetRanges
return|;
block|}
comment|/**    * @return The computed start value of this range    */
DECL|method|getStartObj
specifier|public
name|Object
name|getStartObj
parameter_list|()
block|{
return|return
name|startObj
return|;
block|}
comment|/**    * The end of this facet.range as calculated using the value of facet.range.end    * parameter and facet.range.hardend. This can be different from the    * value specified in facet.range.end if facet.range.hardend=true    */
DECL|method|getEndObj
specifier|public
name|Object
name|getEndObj
parameter_list|()
block|{
return|return
name|endObj
return|;
block|}
comment|/**    * Represents a range facet response combined from all shards.    * Provides helper methods to merge facet_ranges response from a shard.    * See {@link #mergeFacetRangesFromShardResponse(LinkedHashMap, SimpleOrderedMap)}    * and {@link #mergeContributionFromShard(SimpleOrderedMap)}    */
DECL|class|DistribRangeFacet
specifier|static
class|class
name|DistribRangeFacet
block|{
DECL|field|rangeFacet
specifier|public
name|SimpleOrderedMap
argument_list|<
name|Object
argument_list|>
name|rangeFacet
decl_stmt|;
DECL|method|DistribRangeFacet
specifier|public
name|DistribRangeFacet
parameter_list|(
name|SimpleOrderedMap
argument_list|<
name|Object
argument_list|>
name|rangeFacet
parameter_list|)
block|{
name|this
operator|.
name|rangeFacet
operator|=
name|rangeFacet
expr_stmt|;
block|}
comment|/**      * Helper method to merge range facet values from a shard's response to already accumulated      * values for each range.      *      * @param rangeCounts a {@link LinkedHashMap} containing the accumulated values for each range      *                    keyed by the 'key' of the facet.range. Must not be null.      * @param shardRanges the facet_ranges response from a shard. Must not be null.      */
DECL|method|mergeFacetRangesFromShardResponse
specifier|public
specifier|static
name|void
name|mergeFacetRangesFromShardResponse
parameter_list|(
name|LinkedHashMap
argument_list|<
name|String
argument_list|,
name|DistribRangeFacet
argument_list|>
name|rangeCounts
parameter_list|,
name|SimpleOrderedMap
argument_list|<
name|SimpleOrderedMap
argument_list|<
name|Object
argument_list|>
argument_list|>
name|shardRanges
parameter_list|)
block|{
assert|assert
name|shardRanges
operator|!=
literal|null
assert|;
assert|assert
name|rangeCounts
operator|!=
literal|null
assert|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|SimpleOrderedMap
argument_list|<
name|Object
argument_list|>
argument_list|>
name|entry
range|:
name|shardRanges
control|)
block|{
name|String
name|rangeKey
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|RangeFacetRequest
operator|.
name|DistribRangeFacet
name|existing
init|=
name|rangeCounts
operator|.
name|get
argument_list|(
name|rangeKey
argument_list|)
decl_stmt|;
if|if
condition|(
name|existing
operator|==
literal|null
condition|)
block|{
name|rangeCounts
operator|.
name|put
argument_list|(
name|rangeKey
argument_list|,
operator|new
name|RangeFacetRequest
operator|.
name|DistribRangeFacet
argument_list|(
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|existing
operator|.
name|mergeContributionFromShard
argument_list|(
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Accumulates an individual facet_ranges count from a shard into global counts.      *<p>      * The implementation below uses the first encountered shard's      * facet_ranges as the basis for subsequent shards' data to be merged.      *      * @param rangeFromShard the facet_ranges response from a shard      */
DECL|method|mergeContributionFromShard
specifier|public
name|void
name|mergeContributionFromShard
parameter_list|(
name|SimpleOrderedMap
argument_list|<
name|Object
argument_list|>
name|rangeFromShard
parameter_list|)
block|{
if|if
condition|(
name|rangeFacet
operator|==
literal|null
condition|)
block|{
name|rangeFacet
operator|=
name|rangeFromShard
expr_stmt|;
return|return;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|NamedList
argument_list|<
name|Integer
argument_list|>
name|shardFieldValues
init|=
operator|(
name|NamedList
argument_list|<
name|Integer
argument_list|>
operator|)
name|rangeFromShard
operator|.
name|get
argument_list|(
literal|"counts"
argument_list|)
decl_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|NamedList
argument_list|<
name|Integer
argument_list|>
name|existFieldValues
init|=
operator|(
name|NamedList
argument_list|<
name|Integer
argument_list|>
operator|)
name|rangeFacet
operator|.
name|get
argument_list|(
literal|"counts"
argument_list|)
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|existPair
range|:
name|existFieldValues
control|)
block|{
specifier|final
name|String
name|key
init|=
name|existPair
operator|.
name|getKey
argument_list|()
decl_stmt|;
comment|// can be null if inconsistencies in shards responses
name|Integer
name|newValue
init|=
name|shardFieldValues
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
literal|null
operator|!=
name|newValue
condition|)
block|{
name|Integer
name|oldValue
init|=
name|existPair
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|existPair
operator|.
name|setValue
argument_list|(
name|oldValue
operator|+
name|newValue
argument_list|)
expr_stmt|;
block|}
block|}
comment|// merge facet.other=before/between/after/all if they exist
for|for
control|(
name|FacetParams
operator|.
name|FacetRangeOther
name|otherKey
range|:
name|FacetParams
operator|.
name|FacetRangeOther
operator|.
name|values
argument_list|()
control|)
block|{
if|if
condition|(
name|otherKey
operator|==
name|FacetParams
operator|.
name|FacetRangeOther
operator|.
name|NONE
condition|)
continue|continue;
name|String
name|name
init|=
name|otherKey
operator|.
name|toString
argument_list|()
decl_stmt|;
name|Integer
name|shardValue
init|=
operator|(
name|Integer
operator|)
name|rangeFromShard
operator|.
name|get
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|shardValue
operator|!=
literal|null
operator|&&
name|shardValue
operator|>
literal|0
condition|)
block|{
name|Integer
name|existingValue
init|=
operator|(
name|Integer
operator|)
name|rangeFacet
operator|.
name|get
argument_list|(
name|name
argument_list|)
decl_stmt|;
comment|// shouldn't be null
name|int
name|idx
init|=
name|rangeFacet
operator|.
name|indexOf
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rangeFacet
operator|.
name|setVal
argument_list|(
name|idx
argument_list|,
name|existingValue
operator|+
name|shardValue
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Removes all counts under the given minCount from the accumulated facet_ranges.      *<p>      * Note: this method should only be called after all shard responses have been      * accumulated using {@link #mergeContributionFromShard(SimpleOrderedMap)}      *      * @param minCount the minimum allowed count for any range      */
DECL|method|removeRangeFacetsUnderLimits
specifier|public
name|void
name|removeRangeFacetsUnderLimits
parameter_list|(
name|int
name|minCount
parameter_list|)
block|{
name|boolean
name|replace
init|=
literal|false
decl_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|NamedList
argument_list|<
name|Number
argument_list|>
name|vals
init|=
operator|(
name|NamedList
argument_list|<
name|Number
argument_list|>
operator|)
name|rangeFacet
operator|.
name|get
argument_list|(
literal|"counts"
argument_list|)
decl_stmt|;
name|NamedList
argument_list|<
name|Number
argument_list|>
name|newList
init|=
operator|new
name|NamedList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|Number
argument_list|>
name|pair
range|:
name|vals
control|)
block|{
if|if
condition|(
name|pair
operator|.
name|getValue
argument_list|()
operator|.
name|longValue
argument_list|()
operator|>=
name|minCount
condition|)
block|{
name|newList
operator|.
name|add
argument_list|(
name|pair
operator|.
name|getKey
argument_list|()
argument_list|,
name|pair
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|replace
operator|=
literal|true
expr_stmt|;
block|}
block|}
if|if
condition|(
name|replace
condition|)
block|{
name|vals
operator|.
name|clear
argument_list|()
expr_stmt|;
name|vals
operator|.
name|addAll
argument_list|(
name|newList
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Perhaps someday instead of having a giant "instanceof" case    * statement to pick an impl, we can add a "RangeFacetable" marker    * interface to FieldTypes and they can return instances of these    * directly from some method -- but until then, keep this locked down    * and private.    */
DECL|class|RangeEndpointCalculator
specifier|private
specifier|static
specifier|abstract
class|class
name|RangeEndpointCalculator
parameter_list|<
name|T
extends|extends
name|Comparable
parameter_list|<
name|T
parameter_list|>
parameter_list|>
block|{
DECL|field|rfr
specifier|protected
specifier|final
name|RangeFacetRequest
name|rfr
decl_stmt|;
DECL|field|field
specifier|protected
specifier|final
name|SchemaField
name|field
decl_stmt|;
comment|/**      * The end of the facet.range as determined by this calculator.      * This can be different from the facet.range.end depending on the      * facet.range.hardend parameter      */
DECL|field|computedEnd
specifier|protected
name|T
name|computedEnd
decl_stmt|;
DECL|field|start
specifier|protected
name|T
name|start
decl_stmt|;
DECL|field|gap
specifier|protected
name|Object
name|gap
decl_stmt|;
DECL|field|computed
specifier|protected
name|boolean
name|computed
init|=
literal|false
decl_stmt|;
DECL|method|RangeEndpointCalculator
specifier|public
name|RangeEndpointCalculator
parameter_list|(
name|RangeFacetRequest
name|rfr
parameter_list|)
block|{
name|this
operator|.
name|rfr
operator|=
name|rfr
expr_stmt|;
name|this
operator|.
name|field
operator|=
name|rfr
operator|.
name|getSchemaField
argument_list|()
expr_stmt|;
block|}
DECL|method|getComputedEnd
specifier|public
name|T
name|getComputedEnd
parameter_list|()
block|{
assert|assert
name|computed
assert|;
return|return
name|computedEnd
return|;
block|}
DECL|method|getStart
specifier|public
name|T
name|getStart
parameter_list|()
block|{
assert|assert
name|computed
assert|;
return|return
name|start
return|;
block|}
comment|/**      * @return the parsed value of {@link FacetParams#FACET_RANGE_GAP} parameter. This type      * of the returned object is the boxed type of the schema field type's primitive counterpart      * except in the case of Dates in which case the returned type is just a string (because in      * case of dates the gap can either be a date or a DateMath string).      */
DECL|method|getGap
specifier|public
name|Object
name|getGap
parameter_list|()
block|{
assert|assert
name|computed
assert|;
return|return
name|gap
return|;
block|}
comment|/**      * Formats a Range endpoint for use as a range label name in the response.      * Default Impl just uses toString()      */
DECL|method|formatValue
specifier|public
name|String
name|formatValue
parameter_list|(
specifier|final
name|T
name|val
parameter_list|)
block|{
return|return
name|val
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**      * Parses a String param into an Range endpoint value throwing      * a useful exception if not possible      */
DECL|method|getValue
specifier|public
specifier|final
name|T
name|getValue
parameter_list|(
specifier|final
name|String
name|rawval
parameter_list|)
block|{
try|try
block|{
return|return
name|parseVal
argument_list|(
name|rawval
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|SolrException
operator|.
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
literal|"Can't parse value "
operator|+
name|rawval
operator|+
literal|" for field: "
operator|+
name|field
operator|.
name|getName
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**      * Parses a String param into an Range endpoint.      * Can throw a low level format exception as needed.      */
DECL|method|parseVal
specifier|protected
specifier|abstract
name|T
name|parseVal
parameter_list|(
specifier|final
name|String
name|rawval
parameter_list|)
throws|throws
name|java
operator|.
name|text
operator|.
name|ParseException
function_decl|;
comment|/**      * Parses a String param into a value that represents the gap and      * can be included in the response, throwing      * a useful exception if not possible.      *<p>      * Note: uses Object as the return type instead of T for things like      * Date where gap is just a DateMathParser string      */
DECL|method|getGap
specifier|protected
specifier|final
name|Object
name|getGap
parameter_list|(
specifier|final
name|String
name|gap
parameter_list|)
block|{
try|try
block|{
return|return
name|parseGap
argument_list|(
name|gap
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|SolrException
operator|.
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
literal|"Can't parse gap "
operator|+
name|gap
operator|+
literal|" for field: "
operator|+
name|field
operator|.
name|getName
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**      * Parses a String param into a value that represents the gap and      * can be included in the response.      * Can throw a low level format exception as needed.      *<p>      * Default Impl calls parseVal      */
DECL|method|parseGap
specifier|protected
name|Object
name|parseGap
parameter_list|(
specifier|final
name|String
name|rawval
parameter_list|)
throws|throws
name|java
operator|.
name|text
operator|.
name|ParseException
block|{
return|return
name|parseVal
argument_list|(
name|rawval
argument_list|)
return|;
block|}
comment|/**      * Adds the String gap param to a low Range endpoint value to determine      * the corresponding high Range endpoint value, throwing      * a useful exception if not possible.      */
DECL|method|addGap
specifier|public
specifier|final
name|T
name|addGap
parameter_list|(
name|T
name|value
parameter_list|,
name|String
name|gap
parameter_list|)
block|{
try|try
block|{
return|return
name|parseAndAddGap
argument_list|(
name|value
argument_list|,
name|gap
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|SolrException
operator|.
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
literal|"Can't add gap "
operator|+
name|gap
operator|+
literal|" to value "
operator|+
name|value
operator|+
literal|" for field: "
operator|+
name|field
operator|.
name|getName
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**      * Adds the String gap param to a low Range endpoint value to determine      * the corrisponding high Range endpoint value.      * Can throw a low level format exception as needed.      */
DECL|method|parseAndAddGap
specifier|protected
specifier|abstract
name|T
name|parseAndAddGap
parameter_list|(
name|T
name|value
parameter_list|,
name|String
name|gap
parameter_list|)
throws|throws
name|java
operator|.
name|text
operator|.
name|ParseException
function_decl|;
DECL|method|computeRanges
specifier|public
name|List
argument_list|<
name|FacetRange
argument_list|>
name|computeRanges
parameter_list|()
block|{
name|List
argument_list|<
name|FacetRange
argument_list|>
name|ranges
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|this
operator|.
name|gap
operator|=
name|getGap
argument_list|(
name|rfr
operator|.
name|getGap
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|start
operator|=
name|getValue
argument_list|(
name|rfr
operator|.
name|getStart
argument_list|()
argument_list|)
expr_stmt|;
comment|// not final, hardend may change this
name|T
name|end
init|=
name|getValue
argument_list|(
name|rfr
operator|.
name|getEnd
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|end
operator|.
name|compareTo
argument_list|(
name|start
argument_list|)
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|SolrException
operator|.
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
literal|"range facet 'end' comes before 'start': "
operator|+
name|end
operator|+
literal|"< "
operator|+
name|start
argument_list|)
throw|;
block|}
specifier|final
name|EnumSet
argument_list|<
name|FacetParams
operator|.
name|FacetRangeInclude
argument_list|>
name|include
init|=
name|rfr
operator|.
name|getInclude
argument_list|()
decl_stmt|;
name|T
name|low
init|=
name|start
decl_stmt|;
while|while
condition|(
name|low
operator|.
name|compareTo
argument_list|(
name|end
argument_list|)
operator|<
literal|0
condition|)
block|{
name|T
name|high
init|=
name|addGap
argument_list|(
name|low
argument_list|,
name|rfr
operator|.
name|getGap
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|end
operator|.
name|compareTo
argument_list|(
name|high
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|rfr
operator|.
name|isHardEnd
argument_list|()
condition|)
block|{
name|high
operator|=
name|end
expr_stmt|;
block|}
else|else
block|{
name|end
operator|=
name|high
expr_stmt|;
block|}
block|}
if|if
condition|(
name|high
operator|.
name|compareTo
argument_list|(
name|low
argument_list|)
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|SolrException
operator|.
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
literal|"range facet infinite loop (is gap negative? did the math overflow?)"
argument_list|)
throw|;
block|}
if|if
condition|(
name|high
operator|.
name|compareTo
argument_list|(
name|low
argument_list|)
operator|==
literal|0
condition|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|SolrException
operator|.
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
literal|"range facet infinite loop: gap is either zero, or too small relative start/end and caused underflow: "
operator|+
name|low
operator|+
literal|" + "
operator|+
name|rfr
operator|.
name|getGap
argument_list|()
operator|+
literal|" = "
operator|+
name|high
argument_list|)
throw|;
block|}
specifier|final
name|boolean
name|includeLower
init|=
operator|(
name|include
operator|.
name|contains
argument_list|(
name|FacetParams
operator|.
name|FacetRangeInclude
operator|.
name|LOWER
argument_list|)
operator|||
operator|(
name|include
operator|.
name|contains
argument_list|(
name|FacetParams
operator|.
name|FacetRangeInclude
operator|.
name|EDGE
argument_list|)
operator|&&
literal|0
operator|==
name|low
operator|.
name|compareTo
argument_list|(
name|start
argument_list|)
operator|)
operator|)
decl_stmt|;
specifier|final
name|boolean
name|includeUpper
init|=
operator|(
name|include
operator|.
name|contains
argument_list|(
name|FacetParams
operator|.
name|FacetRangeInclude
operator|.
name|UPPER
argument_list|)
operator|||
operator|(
name|include
operator|.
name|contains
argument_list|(
name|FacetParams
operator|.
name|FacetRangeInclude
operator|.
name|EDGE
argument_list|)
operator|&&
literal|0
operator|==
name|high
operator|.
name|compareTo
argument_list|(
name|end
argument_list|)
operator|)
operator|)
decl_stmt|;
specifier|final
name|String
name|lowS
init|=
name|formatValue
argument_list|(
name|low
argument_list|)
decl_stmt|;
specifier|final
name|String
name|highS
init|=
name|formatValue
argument_list|(
name|high
argument_list|)
decl_stmt|;
name|ranges
operator|.
name|add
argument_list|(
operator|new
name|FacetRange
argument_list|(
name|lowS
argument_list|,
name|lowS
argument_list|,
name|highS
argument_list|,
name|includeLower
argument_list|,
name|includeUpper
argument_list|)
argument_list|)
expr_stmt|;
name|low
operator|=
name|high
expr_stmt|;
block|}
comment|// we must update the end value in RangeFacetRequest because the end is returned
comment|// as a separate element in the range facet response
name|this
operator|.
name|computedEnd
operator|=
name|end
expr_stmt|;
name|this
operator|.
name|computed
operator|=
literal|true
expr_stmt|;
comment|// no matter what other values are listed, we don't do
comment|// anything if "none" is specified.
if|if
condition|(
operator|!
name|rfr
operator|.
name|getOthers
argument_list|()
operator|.
name|contains
argument_list|(
name|FacetParams
operator|.
name|FacetRangeOther
operator|.
name|NONE
argument_list|)
condition|)
block|{
name|boolean
name|all
init|=
name|rfr
operator|.
name|getOthers
argument_list|()
operator|.
name|contains
argument_list|(
name|FacetParams
operator|.
name|FacetRangeOther
operator|.
name|ALL
argument_list|)
decl_stmt|;
specifier|final
name|String
name|startS
init|=
name|formatValue
argument_list|(
name|start
argument_list|)
decl_stmt|;
specifier|final
name|String
name|endS
init|=
name|formatValue
argument_list|(
name|end
argument_list|)
decl_stmt|;
if|if
condition|(
name|all
operator|||
name|rfr
operator|.
name|getOthers
argument_list|()
operator|.
name|contains
argument_list|(
name|FacetParams
operator|.
name|FacetRangeOther
operator|.
name|BEFORE
argument_list|)
condition|)
block|{
comment|// include upper bound if "outer" or if first gap doesn't already include it
name|ranges
operator|.
name|add
argument_list|(
operator|new
name|FacetRange
argument_list|(
name|FacetParams
operator|.
name|FacetRangeOther
operator|.
name|BEFORE
argument_list|,
literal|null
argument_list|,
name|startS
argument_list|,
literal|false
argument_list|,
name|include
operator|.
name|contains
argument_list|(
name|FacetParams
operator|.
name|FacetRangeInclude
operator|.
name|OUTER
argument_list|)
operator|||
name|include
operator|.
name|contains
argument_list|(
name|FacetParams
operator|.
name|FacetRangeInclude
operator|.
name|ALL
argument_list|)
operator|||
operator|!
operator|(
name|include
operator|.
name|contains
argument_list|(
name|FacetParams
operator|.
name|FacetRangeInclude
operator|.
name|LOWER
argument_list|)
operator|||
name|include
operator|.
name|contains
argument_list|(
name|FacetParams
operator|.
name|FacetRangeInclude
operator|.
name|EDGE
argument_list|)
operator|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|all
operator|||
name|rfr
operator|.
name|getOthers
argument_list|()
operator|.
name|contains
argument_list|(
name|FacetParams
operator|.
name|FacetRangeOther
operator|.
name|AFTER
argument_list|)
condition|)
block|{
comment|// include lower bound if "outer" or if last gap doesn't already include it
name|ranges
operator|.
name|add
argument_list|(
operator|new
name|FacetRange
argument_list|(
name|FacetParams
operator|.
name|FacetRangeOther
operator|.
name|AFTER
argument_list|,
name|endS
argument_list|,
literal|null
argument_list|,
name|include
operator|.
name|contains
argument_list|(
name|FacetParams
operator|.
name|FacetRangeInclude
operator|.
name|OUTER
argument_list|)
operator|||
name|include
operator|.
name|contains
argument_list|(
name|FacetParams
operator|.
name|FacetRangeInclude
operator|.
name|ALL
argument_list|)
operator|||
operator|!
operator|(
name|include
operator|.
name|contains
argument_list|(
name|FacetParams
operator|.
name|FacetRangeInclude
operator|.
name|UPPER
argument_list|)
operator|||
name|include
operator|.
name|contains
argument_list|(
name|FacetParams
operator|.
name|FacetRangeInclude
operator|.
name|EDGE
argument_list|)
operator|)
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|all
operator|||
name|rfr
operator|.
name|getOthers
argument_list|()
operator|.
name|contains
argument_list|(
name|FacetParams
operator|.
name|FacetRangeOther
operator|.
name|BETWEEN
argument_list|)
condition|)
block|{
name|ranges
operator|.
name|add
argument_list|(
operator|new
name|FacetRange
argument_list|(
name|FacetParams
operator|.
name|FacetRangeOther
operator|.
name|BETWEEN
argument_list|,
name|startS
argument_list|,
name|endS
argument_list|,
name|include
operator|.
name|contains
argument_list|(
name|FacetParams
operator|.
name|FacetRangeInclude
operator|.
name|LOWER
argument_list|)
operator|||
name|include
operator|.
name|contains
argument_list|(
name|FacetParams
operator|.
name|FacetRangeInclude
operator|.
name|EDGE
argument_list|)
operator|||
name|include
operator|.
name|contains
argument_list|(
name|FacetParams
operator|.
name|FacetRangeInclude
operator|.
name|ALL
argument_list|)
argument_list|,
name|include
operator|.
name|contains
argument_list|(
name|FacetParams
operator|.
name|FacetRangeInclude
operator|.
name|UPPER
argument_list|)
operator|||
name|include
operator|.
name|contains
argument_list|(
name|FacetParams
operator|.
name|FacetRangeInclude
operator|.
name|EDGE
argument_list|)
operator|||
name|include
operator|.
name|contains
argument_list|(
name|FacetParams
operator|.
name|FacetRangeInclude
operator|.
name|ALL
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|ranges
return|;
block|}
block|}
DECL|class|FloatRangeEndpointCalculator
specifier|private
specifier|static
class|class
name|FloatRangeEndpointCalculator
extends|extends
name|RangeEndpointCalculator
argument_list|<
name|Float
argument_list|>
block|{
DECL|method|FloatRangeEndpointCalculator
specifier|public
name|FloatRangeEndpointCalculator
parameter_list|(
specifier|final
name|RangeFacetRequest
name|rangeFacetRequest
parameter_list|)
block|{
name|super
argument_list|(
name|rangeFacetRequest
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|parseVal
specifier|protected
name|Float
name|parseVal
parameter_list|(
name|String
name|rawval
parameter_list|)
block|{
return|return
name|Float
operator|.
name|valueOf
argument_list|(
name|rawval
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|parseAndAddGap
specifier|public
name|Float
name|parseAndAddGap
parameter_list|(
name|Float
name|value
parameter_list|,
name|String
name|gap
parameter_list|)
block|{
return|return
operator|new
name|Float
argument_list|(
name|value
operator|.
name|floatValue
argument_list|()
operator|+
name|Float
operator|.
name|valueOf
argument_list|(
name|gap
argument_list|)
operator|.
name|floatValue
argument_list|()
argument_list|)
return|;
block|}
block|}
DECL|class|DoubleRangeEndpointCalculator
specifier|private
specifier|static
class|class
name|DoubleRangeEndpointCalculator
extends|extends
name|RangeEndpointCalculator
argument_list|<
name|Double
argument_list|>
block|{
DECL|method|DoubleRangeEndpointCalculator
specifier|public
name|DoubleRangeEndpointCalculator
parameter_list|(
specifier|final
name|RangeFacetRequest
name|rangeFacetRequest
parameter_list|)
block|{
name|super
argument_list|(
name|rangeFacetRequest
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|parseVal
specifier|protected
name|Double
name|parseVal
parameter_list|(
name|String
name|rawval
parameter_list|)
block|{
return|return
name|Double
operator|.
name|valueOf
argument_list|(
name|rawval
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|parseAndAddGap
specifier|public
name|Double
name|parseAndAddGap
parameter_list|(
name|Double
name|value
parameter_list|,
name|String
name|gap
parameter_list|)
block|{
return|return
operator|new
name|Double
argument_list|(
name|value
operator|.
name|doubleValue
argument_list|()
operator|+
name|Double
operator|.
name|valueOf
argument_list|(
name|gap
argument_list|)
operator|.
name|doubleValue
argument_list|()
argument_list|)
return|;
block|}
block|}
DECL|class|IntegerRangeEndpointCalculator
specifier|private
specifier|static
class|class
name|IntegerRangeEndpointCalculator
extends|extends
name|RangeEndpointCalculator
argument_list|<
name|Integer
argument_list|>
block|{
DECL|method|IntegerRangeEndpointCalculator
specifier|public
name|IntegerRangeEndpointCalculator
parameter_list|(
specifier|final
name|RangeFacetRequest
name|rangeFacetRequest
parameter_list|)
block|{
name|super
argument_list|(
name|rangeFacetRequest
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|parseVal
specifier|protected
name|Integer
name|parseVal
parameter_list|(
name|String
name|rawval
parameter_list|)
block|{
return|return
name|Integer
operator|.
name|valueOf
argument_list|(
name|rawval
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|parseAndAddGap
specifier|public
name|Integer
name|parseAndAddGap
parameter_list|(
name|Integer
name|value
parameter_list|,
name|String
name|gap
parameter_list|)
block|{
return|return
operator|new
name|Integer
argument_list|(
name|value
operator|.
name|intValue
argument_list|()
operator|+
name|Integer
operator|.
name|valueOf
argument_list|(
name|gap
argument_list|)
operator|.
name|intValue
argument_list|()
argument_list|)
return|;
block|}
block|}
DECL|class|LongRangeEndpointCalculator
specifier|private
specifier|static
class|class
name|LongRangeEndpointCalculator
extends|extends
name|RangeEndpointCalculator
argument_list|<
name|Long
argument_list|>
block|{
DECL|method|LongRangeEndpointCalculator
specifier|public
name|LongRangeEndpointCalculator
parameter_list|(
specifier|final
name|RangeFacetRequest
name|rangeFacetRequest
parameter_list|)
block|{
name|super
argument_list|(
name|rangeFacetRequest
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|parseVal
specifier|protected
name|Long
name|parseVal
parameter_list|(
name|String
name|rawval
parameter_list|)
block|{
return|return
name|Long
operator|.
name|valueOf
argument_list|(
name|rawval
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|parseAndAddGap
specifier|public
name|Long
name|parseAndAddGap
parameter_list|(
name|Long
name|value
parameter_list|,
name|String
name|gap
parameter_list|)
block|{
return|return
operator|new
name|Long
argument_list|(
name|value
operator|.
name|longValue
argument_list|()
operator|+
name|Long
operator|.
name|valueOf
argument_list|(
name|gap
argument_list|)
operator|.
name|longValue
argument_list|()
argument_list|)
return|;
block|}
block|}
DECL|class|DateRangeEndpointCalculator
specifier|private
specifier|static
class|class
name|DateRangeEndpointCalculator
extends|extends
name|RangeEndpointCalculator
argument_list|<
name|Date
argument_list|>
block|{
DECL|field|TYPE_ERR_MSG
specifier|private
specifier|static
specifier|final
name|String
name|TYPE_ERR_MSG
init|=
literal|"SchemaField must use field type extending TrieDateField or DateRangeField"
decl_stmt|;
DECL|field|now
specifier|private
specifier|final
name|Date
name|now
decl_stmt|;
DECL|method|DateRangeEndpointCalculator
specifier|public
name|DateRangeEndpointCalculator
parameter_list|(
specifier|final
name|RangeFacetRequest
name|rangeFacetRequest
parameter_list|,
specifier|final
name|Date
name|now
parameter_list|)
block|{
name|super
argument_list|(
name|rangeFacetRequest
argument_list|)
expr_stmt|;
name|this
operator|.
name|now
operator|=
name|now
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|field
operator|.
name|getType
argument_list|()
operator|instanceof
name|TrieDateField
operator|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
name|TYPE_ERR_MSG
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
DECL|method|formatValue
specifier|public
name|String
name|formatValue
parameter_list|(
name|Date
name|val
parameter_list|)
block|{
return|return
name|DateFormatUtil
operator|.
name|formatExternal
argument_list|(
name|val
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|parseVal
specifier|protected
name|Date
name|parseVal
parameter_list|(
name|String
name|rawval
parameter_list|)
block|{
return|return
name|DateFormatUtil
operator|.
name|parseMath
argument_list|(
name|now
argument_list|,
name|rawval
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|parseGap
specifier|protected
name|Object
name|parseGap
parameter_list|(
specifier|final
name|String
name|rawval
parameter_list|)
block|{
return|return
name|rawval
return|;
block|}
annotation|@
name|Override
DECL|method|parseAndAddGap
specifier|public
name|Date
name|parseAndAddGap
parameter_list|(
name|Date
name|value
parameter_list|,
name|String
name|gap
parameter_list|)
throws|throws
name|java
operator|.
name|text
operator|.
name|ParseException
block|{
specifier|final
name|DateMathParser
name|dmp
init|=
operator|new
name|DateMathParser
argument_list|()
decl_stmt|;
name|dmp
operator|.
name|setNow
argument_list|(
name|value
argument_list|)
expr_stmt|;
return|return
name|dmp
operator|.
name|parseMath
argument_list|(
name|gap
argument_list|)
return|;
block|}
block|}
DECL|class|DateRangeFieldEndpointCalculator
specifier|private
specifier|static
class|class
name|DateRangeFieldEndpointCalculator
extends|extends
name|RangeEndpointCalculator
argument_list|<
name|Date
argument_list|>
block|{
DECL|field|now
specifier|private
specifier|final
name|Date
name|now
decl_stmt|;
DECL|method|DateRangeFieldEndpointCalculator
specifier|public
name|DateRangeFieldEndpointCalculator
parameter_list|(
specifier|final
name|RangeFacetRequest
name|rangeFacetRequest
parameter_list|,
specifier|final
name|Date
name|now
parameter_list|)
block|{
name|super
argument_list|(
name|rangeFacetRequest
argument_list|)
expr_stmt|;
name|this
operator|.
name|now
operator|=
name|now
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|field
operator|.
name|getType
argument_list|()
operator|instanceof
name|DateRangeField
operator|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
name|DateRangeEndpointCalculator
operator|.
name|TYPE_ERR_MSG
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
DECL|method|formatValue
specifier|public
name|String
name|formatValue
parameter_list|(
name|Date
name|val
parameter_list|)
block|{
return|return
name|DateFormatUtil
operator|.
name|formatExternal
argument_list|(
name|val
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|parseVal
specifier|protected
name|Date
name|parseVal
parameter_list|(
name|String
name|rawval
parameter_list|)
block|{
return|return
operator|(
operator|(
name|DateRangeField
operator|)
name|field
operator|.
name|getType
argument_list|()
operator|)
operator|.
name|parseMath
argument_list|(
name|now
argument_list|,
name|rawval
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|parseGap
specifier|protected
name|Object
name|parseGap
parameter_list|(
specifier|final
name|String
name|rawval
parameter_list|)
block|{
return|return
name|rawval
return|;
block|}
annotation|@
name|Override
DECL|method|parseAndAddGap
specifier|public
name|Date
name|parseAndAddGap
parameter_list|(
name|Date
name|value
parameter_list|,
name|String
name|gap
parameter_list|)
throws|throws
name|java
operator|.
name|text
operator|.
name|ParseException
block|{
specifier|final
name|DateMathParser
name|dmp
init|=
operator|new
name|DateMathParser
argument_list|()
decl_stmt|;
name|dmp
operator|.
name|setNow
argument_list|(
name|value
argument_list|)
expr_stmt|;
return|return
name|dmp
operator|.
name|parseMath
argument_list|(
name|gap
argument_list|)
return|;
block|}
block|}
comment|/**    * Represents a single facet range (or gap) for which the count is to be calculated    */
DECL|class|FacetRange
specifier|public
specifier|static
class|class
name|FacetRange
block|{
DECL|field|other
specifier|public
specifier|final
name|FacetParams
operator|.
name|FacetRangeOther
name|other
decl_stmt|;
DECL|field|name
specifier|public
specifier|final
name|String
name|name
decl_stmt|;
DECL|field|lower
specifier|public
specifier|final
name|String
name|lower
decl_stmt|;
DECL|field|upper
specifier|public
specifier|final
name|String
name|upper
decl_stmt|;
DECL|field|includeLower
specifier|public
specifier|final
name|boolean
name|includeLower
decl_stmt|;
DECL|field|includeUpper
specifier|public
specifier|final
name|boolean
name|includeUpper
decl_stmt|;
DECL|method|FacetRange
specifier|private
name|FacetRange
parameter_list|(
name|FacetParams
operator|.
name|FacetRangeOther
name|other
parameter_list|,
name|String
name|name
parameter_list|,
name|String
name|lower
parameter_list|,
name|String
name|upper
parameter_list|,
name|boolean
name|includeLower
parameter_list|,
name|boolean
name|includeUpper
parameter_list|)
block|{
name|this
operator|.
name|other
operator|=
name|other
expr_stmt|;
name|this
operator|.
name|name
operator|=
name|name
expr_stmt|;
name|this
operator|.
name|lower
operator|=
name|lower
expr_stmt|;
name|this
operator|.
name|upper
operator|=
name|upper
expr_stmt|;
name|this
operator|.
name|includeLower
operator|=
name|includeLower
expr_stmt|;
name|this
operator|.
name|includeUpper
operator|=
name|includeUpper
expr_stmt|;
block|}
comment|/**      * Construct a facet range for a {@link org.apache.solr.common.params.FacetParams.FacetRangeOther} instance      */
DECL|method|FacetRange
specifier|public
name|FacetRange
parameter_list|(
name|FacetParams
operator|.
name|FacetRangeOther
name|other
parameter_list|,
name|String
name|lower
parameter_list|,
name|String
name|upper
parameter_list|,
name|boolean
name|includeLower
parameter_list|,
name|boolean
name|includeUpper
parameter_list|)
block|{
name|this
argument_list|(
name|other
argument_list|,
name|other
operator|.
name|toString
argument_list|()
argument_list|,
name|lower
argument_list|,
name|upper
argument_list|,
name|includeLower
argument_list|,
name|includeUpper
argument_list|)
expr_stmt|;
block|}
comment|/**      * Construct a facet range for the give name      */
DECL|method|FacetRange
specifier|public
name|FacetRange
parameter_list|(
name|String
name|name
parameter_list|,
name|String
name|lower
parameter_list|,
name|String
name|upper
parameter_list|,
name|boolean
name|includeLower
parameter_list|,
name|boolean
name|includeUpper
parameter_list|)
block|{
name|this
argument_list|(
literal|null
argument_list|,
name|name
argument_list|,
name|lower
argument_list|,
name|upper
argument_list|,
name|includeLower
argument_list|,
name|includeUpper
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_class
end_unit
