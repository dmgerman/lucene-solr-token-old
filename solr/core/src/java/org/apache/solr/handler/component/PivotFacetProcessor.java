begin_unit
begin_package
DECL|package|org.apache.solr.handler.component
package|package
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|handler
operator|.
name|component
package|;
end_package
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|BytesRefBuilder
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|schema
operator|.
name|SchemaField
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|schema
operator|.
name|FieldType
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|search
operator|.
name|SolrIndexSearcher
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|search
operator|.
name|DocSet
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|search
operator|.
name|SyntaxError
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|util
operator|.
name|PivotListEntry
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|SolrException
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|util
operator|.
name|NamedList
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|util
operator|.
name|SimpleOrderedMap
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|util
operator|.
name|StrUtils
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|SolrException
operator|.
name|ErrorCode
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|params
operator|.
name|SolrParams
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|params
operator|.
name|ShardParams
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|params
operator|.
name|FacetParams
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|params
operator|.
name|StatsParams
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|request
operator|.
name|SimpleFacets
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|request
operator|.
name|SolrQueryRequest
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|Query
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Deque
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashMap
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedList
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import
begin_comment
comment|/**  * Processes all Pivot facet logic for a single node -- both non-distrib, and per-shard  */
end_comment
begin_class
DECL|class|PivotFacetProcessor
specifier|public
class|class
name|PivotFacetProcessor
extends|extends
name|SimpleFacets
block|{
DECL|field|params
specifier|protected
name|SolrParams
name|params
decl_stmt|;
DECL|method|PivotFacetProcessor
specifier|public
name|PivotFacetProcessor
parameter_list|(
name|SolrQueryRequest
name|req
parameter_list|,
name|DocSet
name|docs
parameter_list|,
name|SolrParams
name|params
parameter_list|,
name|ResponseBuilder
name|rb
parameter_list|)
block|{
name|super
argument_list|(
name|req
argument_list|,
name|docs
argument_list|,
name|params
argument_list|,
name|rb
argument_list|)
expr_stmt|;
name|this
operator|.
name|params
operator|=
name|params
expr_stmt|;
block|}
comment|/**    * Processes all of the specified {@link FacetParams#FACET_PIVOT} strings, generating     * a completel response tree for each pivot.  The values in this response will either     * be the complete tree of fields and values for the specified pivot in the local index,     * or the requested refinements if the pivot params include the {@link PivotFacet#REFINE_PARAM}    */
DECL|method|process
specifier|public
name|SimpleOrderedMap
argument_list|<
name|List
argument_list|<
name|NamedList
argument_list|<
name|Object
argument_list|>
argument_list|>
argument_list|>
name|process
parameter_list|(
name|String
index|[]
name|pivots
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|rb
operator|.
name|doFacets
operator|||
name|pivots
operator|==
literal|null
condition|)
return|return
literal|null
return|;
comment|// rb._statsInfo may be null if stats=false, ie: refine requests
comment|// if that's the case, but we need to refine w/stats, then we'll lazy init our
comment|// own instance of StatsInfo
name|StatsInfo
name|statsInfo
init|=
name|rb
operator|.
name|_statsInfo
decl_stmt|;
name|SimpleOrderedMap
argument_list|<
name|List
argument_list|<
name|NamedList
argument_list|<
name|Object
argument_list|>
argument_list|>
argument_list|>
name|pivotResponse
init|=
operator|new
name|SimpleOrderedMap
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|pivotList
range|:
name|pivots
control|)
block|{
try|try
block|{
comment|// NOTE: this sets localParams (SimpleFacets is stateful)
name|this
operator|.
name|parseParams
argument_list|(
name|FacetParams
operator|.
name|FACET_PIVOT
argument_list|,
name|pivotList
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SyntaxError
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
name|e
argument_list|)
throw|;
block|}
name|List
argument_list|<
name|String
argument_list|>
name|pivotFields
init|=
name|StrUtils
operator|.
name|splitSmart
argument_list|(
name|facetValue
argument_list|,
literal|","
argument_list|,
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
name|pivotFields
operator|.
name|size
argument_list|()
operator|<
literal|1
condition|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
literal|"Pivot Facet needs at least one field name: "
operator|+
name|pivotList
argument_list|)
throw|;
block|}
else|else
block|{
name|SolrIndexSearcher
name|searcher
init|=
name|rb
operator|.
name|req
operator|.
name|getSearcher
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|fieldName
range|:
name|pivotFields
control|)
block|{
name|SchemaField
name|sfield
init|=
name|searcher
operator|.
name|getSchema
argument_list|()
operator|.
name|getField
argument_list|(
name|fieldName
argument_list|)
decl_stmt|;
if|if
condition|(
name|sfield
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
literal|"\""
operator|+
name|fieldName
operator|+
literal|"\" is not a valid field name in pivot: "
operator|+
name|pivotList
argument_list|)
throw|;
block|}
block|}
block|}
comment|// start by assuing no local params...
name|String
name|refineKey
init|=
literal|null
decl_stmt|;
comment|// no local => no refinement
name|List
argument_list|<
name|StatsField
argument_list|>
name|statsFields
init|=
name|Collections
operator|.
name|emptyList
argument_list|()
decl_stmt|;
comment|// no local => no stats
if|if
condition|(
literal|null
operator|!=
name|localParams
condition|)
block|{
comment|// we might be refining..
name|refineKey
operator|=
name|localParams
operator|.
name|get
argument_list|(
name|PivotFacet
operator|.
name|REFINE_PARAM
argument_list|)
expr_stmt|;
name|String
name|statsLocalParam
init|=
name|localParams
operator|.
name|get
argument_list|(
name|StatsParams
operator|.
name|STATS
argument_list|)
decl_stmt|;
if|if
condition|(
literal|null
operator|!=
name|refineKey
operator|&&
literal|null
operator|!=
name|statsLocalParam
operator|&&
literal|null
operator|==
name|statsInfo
condition|)
block|{
comment|// we are refining and need to compute stats,
comment|// but stats component hasn't inited StatsInfo (because we
comment|// don't need/want top level stats when refining) so we lazy init
comment|// our own copy of StatsInfo
name|statsInfo
operator|=
operator|new
name|StatsInfo
argument_list|(
name|rb
argument_list|)
expr_stmt|;
block|}
name|statsFields
operator|=
name|getTaggedStatsFields
argument_list|(
name|statsInfo
argument_list|,
name|statsLocalParam
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
literal|null
operator|!=
name|refineKey
condition|)
block|{
name|String
index|[]
name|refinementValuesByField
init|=
name|params
operator|.
name|getParams
argument_list|(
name|PivotFacet
operator|.
name|REFINE_PARAM
operator|+
name|refineKey
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|refinements
range|:
name|refinementValuesByField
control|)
block|{
name|pivotResponse
operator|.
name|addAll
argument_list|(
name|processSingle
argument_list|(
name|pivotFields
argument_list|,
name|refinements
argument_list|,
name|statsFields
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|pivotResponse
operator|.
name|addAll
argument_list|(
name|processSingle
argument_list|(
name|pivotFields
argument_list|,
literal|null
argument_list|,
name|statsFields
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|pivotResponse
return|;
block|}
comment|/**    * Process a single branch of refinement values for a specific pivot    * @param pivotFields the ordered list of fields in this pivot    * @param refinements the comma seperate list of refinement values corrisponding to each field in the pivot, or null if there are no refinements    * @param statsFields List of {@link StatsField} instances to compute for each pivot value    */
DECL|method|processSingle
specifier|private
name|SimpleOrderedMap
argument_list|<
name|List
argument_list|<
name|NamedList
argument_list|<
name|Object
argument_list|>
argument_list|>
argument_list|>
name|processSingle
parameter_list|(
name|List
argument_list|<
name|String
argument_list|>
name|pivotFields
parameter_list|,
name|String
name|refinements
parameter_list|,
name|List
argument_list|<
name|StatsField
argument_list|>
name|statsFields
parameter_list|)
throws|throws
name|IOException
block|{
name|SolrIndexSearcher
name|searcher
init|=
name|rb
operator|.
name|req
operator|.
name|getSearcher
argument_list|()
decl_stmt|;
name|SimpleOrderedMap
argument_list|<
name|List
argument_list|<
name|NamedList
argument_list|<
name|Object
argument_list|>
argument_list|>
argument_list|>
name|pivotResponse
init|=
operator|new
name|SimpleOrderedMap
argument_list|<>
argument_list|()
decl_stmt|;
name|String
name|field
init|=
name|pivotFields
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|SchemaField
name|sfield
init|=
name|searcher
operator|.
name|getSchema
argument_list|()
operator|.
name|getField
argument_list|(
name|field
argument_list|)
decl_stmt|;
name|Deque
argument_list|<
name|String
argument_list|>
name|fnames
init|=
operator|new
name|LinkedList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|pivotFields
operator|.
name|size
argument_list|()
operator|-
literal|1
init|;
name|i
operator|>
literal|1
condition|;
name|i
operator|--
control|)
block|{
name|fnames
operator|.
name|push
argument_list|(
name|pivotFields
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|NamedList
argument_list|<
name|Integer
argument_list|>
name|facetCounts
decl_stmt|;
name|Deque
argument_list|<
name|String
argument_list|>
name|vnames
init|=
operator|new
name|LinkedList
argument_list|<>
argument_list|()
decl_stmt|;
if|if
condition|(
literal|null
operator|!=
name|refinements
condition|)
block|{
comment|// All values, split by the field they should go to
name|List
argument_list|<
name|String
argument_list|>
name|refinementValuesByField
init|=
name|PivotFacetHelper
operator|.
name|decodeRefinementValuePath
argument_list|(
name|refinements
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|refinementValuesByField
operator|.
name|size
argument_list|()
operator|-
literal|1
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|vnames
operator|.
name|push
argument_list|(
name|refinementValuesByField
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
comment|//Only for [1] and on
block|}
name|String
name|firstFieldsValues
init|=
name|refinementValuesByField
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|facetCounts
operator|=
operator|new
name|NamedList
argument_list|<
name|Integer
argument_list|>
argument_list|()
expr_stmt|;
name|facetCounts
operator|.
name|add
argument_list|(
name|firstFieldsValues
argument_list|,
name|getSubsetSize
argument_list|(
name|this
operator|.
name|docs
argument_list|,
name|sfield
argument_list|,
name|firstFieldsValues
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// no refinements needed
name|facetCounts
operator|=
name|this
operator|.
name|getTermCountsForPivots
argument_list|(
name|field
argument_list|,
name|this
operator|.
name|docs
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pivotFields
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
name|String
name|subField
init|=
name|pivotFields
operator|.
name|get
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|pivotResponse
operator|.
name|add
argument_list|(
name|key
argument_list|,
name|doPivots
argument_list|(
name|facetCounts
argument_list|,
name|field
argument_list|,
name|subField
argument_list|,
name|fnames
argument_list|,
name|vnames
argument_list|,
name|this
operator|.
name|docs
argument_list|,
name|statsFields
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pivotResponse
operator|.
name|add
argument_list|(
name|key
argument_list|,
name|doPivots
argument_list|(
name|facetCounts
argument_list|,
name|field
argument_list|,
literal|null
argument_list|,
name|fnames
argument_list|,
name|vnames
argument_list|,
name|this
operator|.
name|docs
argument_list|,
name|statsFields
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|pivotResponse
return|;
block|}
comment|/**    * returns the {@link StatsField} instances that should be computed for a pivot    * based on the 'stats' local params used.    *    * @return A list of StatsFields to comput for this pivot, or the empty list if none    */
DECL|method|getTaggedStatsFields
specifier|private
specifier|static
name|List
argument_list|<
name|StatsField
argument_list|>
name|getTaggedStatsFields
parameter_list|(
name|StatsInfo
name|statsInfo
parameter_list|,
name|String
name|statsLocalParam
parameter_list|)
block|{
if|if
condition|(
literal|null
operator|==
name|statsLocalParam
operator|||
literal|null
operator|==
name|statsInfo
condition|)
block|{
return|return
name|Collections
operator|.
name|emptyList
argument_list|()
return|;
block|}
name|List
argument_list|<
name|StatsField
argument_list|>
name|fields
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
literal|7
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|statsAr
init|=
name|StrUtils
operator|.
name|splitSmart
argument_list|(
name|statsLocalParam
argument_list|,
literal|','
argument_list|)
decl_stmt|;
comment|// TODO: for now, we only support a single tag name - we reserve using
comment|// ',' as a possible delimeter for logic related to only computing stats
comment|// at certain levels -- see SOLR-6663
if|if
condition|(
literal|1
operator|<
name|statsAr
operator|.
name|size
argument_list|()
condition|)
block|{
name|String
name|msg
init|=
name|StatsParams
operator|.
name|STATS
operator|+
literal|" local param of "
operator|+
name|FacetParams
operator|.
name|FACET_PIVOT
operator|+
literal|"may not include tags separated by a comma - please use a common tag on all "
operator|+
name|StatsParams
operator|.
name|STATS_FIELD
operator|+
literal|" params you wish to compute under this pivot"
decl_stmt|;
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
name|msg
argument_list|)
throw|;
block|}
for|for
control|(
name|String
name|stat
range|:
name|statsAr
control|)
block|{
name|fields
operator|.
name|addAll
argument_list|(
name|statsInfo
operator|.
name|getStatsFieldsByTag
argument_list|(
name|stat
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|fields
return|;
block|}
comment|/**    * Recursive function to compute all the pivot counts for the values under teh specified field    */
DECL|method|doPivots
specifier|protected
name|List
argument_list|<
name|NamedList
argument_list|<
name|Object
argument_list|>
argument_list|>
name|doPivots
parameter_list|(
name|NamedList
argument_list|<
name|Integer
argument_list|>
name|superFacets
parameter_list|,
name|String
name|field
parameter_list|,
name|String
name|subField
parameter_list|,
name|Deque
argument_list|<
name|String
argument_list|>
name|fnames
parameter_list|,
name|Deque
argument_list|<
name|String
argument_list|>
name|vnames
parameter_list|,
name|DocSet
name|docs
parameter_list|,
name|List
argument_list|<
name|StatsField
argument_list|>
name|statsFields
parameter_list|)
throws|throws
name|IOException
block|{
name|boolean
name|isShard
init|=
name|rb
operator|.
name|req
operator|.
name|getParams
argument_list|()
operator|.
name|getBool
argument_list|(
name|ShardParams
operator|.
name|IS_SHARD
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|SolrIndexSearcher
name|searcher
init|=
name|rb
operator|.
name|req
operator|.
name|getSearcher
argument_list|()
decl_stmt|;
comment|// TODO: optimize to avoid converting to an external string and then having to convert back to internal below
name|SchemaField
name|sfield
init|=
name|searcher
operator|.
name|getSchema
argument_list|()
operator|.
name|getField
argument_list|(
name|field
argument_list|)
decl_stmt|;
name|FieldType
name|ftype
init|=
name|sfield
operator|.
name|getType
argument_list|()
decl_stmt|;
name|String
name|nextField
init|=
name|fnames
operator|.
name|poll
argument_list|()
decl_stmt|;
comment|// re-useable BytesRefBuilder for conversion of term values to Objects
name|BytesRefBuilder
name|termval
init|=
operator|new
name|BytesRefBuilder
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|NamedList
argument_list|<
name|Object
argument_list|>
argument_list|>
name|values
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|superFacets
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|kv
range|:
name|superFacets
control|)
block|{
comment|// Only sub-facet if parent facet has positive count - still may not be any values for the sub-field though
if|if
condition|(
name|kv
operator|.
name|getValue
argument_list|()
operator|>=
name|getMinCountForField
argument_list|(
name|field
argument_list|)
condition|)
block|{
specifier|final
name|String
name|fieldValue
init|=
name|kv
operator|.
name|getKey
argument_list|()
decl_stmt|;
specifier|final
name|int
name|pivotCount
init|=
name|kv
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|SimpleOrderedMap
argument_list|<
name|Object
argument_list|>
name|pivot
init|=
operator|new
name|SimpleOrderedMap
argument_list|<>
argument_list|()
decl_stmt|;
name|pivot
operator|.
name|add
argument_list|(
literal|"field"
argument_list|,
name|field
argument_list|)
expr_stmt|;
if|if
condition|(
literal|null
operator|==
name|fieldValue
condition|)
block|{
name|pivot
operator|.
name|add
argument_list|(
literal|"value"
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ftype
operator|.
name|readableToIndexed
argument_list|(
name|fieldValue
argument_list|,
name|termval
argument_list|)
expr_stmt|;
name|pivot
operator|.
name|add
argument_list|(
literal|"value"
argument_list|,
name|ftype
operator|.
name|toObject
argument_list|(
name|sfield
argument_list|,
name|termval
operator|.
name|get
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|pivot
operator|.
name|add
argument_list|(
literal|"count"
argument_list|,
name|pivotCount
argument_list|)
expr_stmt|;
name|DocSet
name|subset
init|=
name|getSubset
argument_list|(
name|docs
argument_list|,
name|sfield
argument_list|,
name|fieldValue
argument_list|)
decl_stmt|;
if|if
condition|(
name|subField
operator|!=
literal|null
condition|)
block|{
name|NamedList
argument_list|<
name|Integer
argument_list|>
name|facetCounts
decl_stmt|;
if|if
condition|(
operator|!
name|vnames
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|String
name|val
init|=
name|vnames
operator|.
name|pop
argument_list|()
decl_stmt|;
name|facetCounts
operator|=
operator|new
name|NamedList
argument_list|<
name|Integer
argument_list|>
argument_list|()
expr_stmt|;
name|facetCounts
operator|.
name|add
argument_list|(
name|val
argument_list|,
name|getSubsetSize
argument_list|(
name|subset
argument_list|,
name|searcher
operator|.
name|getSchema
argument_list|()
operator|.
name|getField
argument_list|(
name|subField
argument_list|)
argument_list|,
name|val
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|facetCounts
operator|=
name|this
operator|.
name|getTermCountsForPivots
argument_list|(
name|subField
argument_list|,
name|subset
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|facetCounts
operator|.
name|size
argument_list|()
operator|>=
literal|1
condition|)
block|{
name|pivot
operator|.
name|add
argument_list|(
literal|"pivot"
argument_list|,
name|doPivots
argument_list|(
name|facetCounts
argument_list|,
name|subField
argument_list|,
name|nextField
argument_list|,
name|fnames
argument_list|,
name|vnames
argument_list|,
name|subset
argument_list|,
name|statsFields
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|isShard
operator|||
literal|0
operator|<
name|pivotCount
operator|)
operator|&&
operator|!
name|statsFields
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|StatsValues
argument_list|>
name|stv
init|=
operator|new
name|LinkedHashMap
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|StatsField
name|statsField
range|:
name|statsFields
control|)
block|{
name|stv
operator|.
name|put
argument_list|(
name|statsField
operator|.
name|getOutputKey
argument_list|()
argument_list|,
name|statsField
operator|.
name|computeLocalStatsValues
argument_list|(
name|subset
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// for pivots, we *always* include requested stats - even if 'empty'
name|pivot
operator|.
name|add
argument_list|(
literal|"stats"
argument_list|,
name|StatsComponent
operator|.
name|convertToResponse
argument_list|(
literal|true
argument_list|,
name|stv
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|values
operator|.
name|add
argument_list|(
name|pivot
argument_list|)
expr_stmt|;
block|}
block|}
comment|// put the field back on the list
name|fnames
operator|.
name|push
argument_list|(
name|nextField
argument_list|)
expr_stmt|;
return|return
name|values
return|;
block|}
comment|/**    * Given a base docset, computes the size of the subset of documents corrisponding to the specified pivotValue    *    * @param base the set of documents to evalute relative to    * @param field the field type used by the pivotValue    * @param pivotValue String representation of the value, may be null (ie: "missing")    */
DECL|method|getSubsetSize
specifier|private
name|int
name|getSubsetSize
parameter_list|(
name|DocSet
name|base
parameter_list|,
name|SchemaField
name|field
parameter_list|,
name|String
name|pivotValue
parameter_list|)
throws|throws
name|IOException
block|{
name|FieldType
name|ft
init|=
name|field
operator|.
name|getType
argument_list|()
decl_stmt|;
if|if
condition|(
literal|null
operator|==
name|pivotValue
condition|)
block|{
name|Query
name|query
init|=
name|ft
operator|.
name|getRangeQuery
argument_list|(
literal|null
argument_list|,
name|field
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|DocSet
name|hasVal
init|=
name|searcher
operator|.
name|getDocSet
argument_list|(
name|query
argument_list|)
decl_stmt|;
return|return
name|base
operator|.
name|andNotSize
argument_list|(
name|hasVal
argument_list|)
return|;
block|}
else|else
block|{
name|Query
name|query
init|=
name|ft
operator|.
name|getFieldQuery
argument_list|(
literal|null
argument_list|,
name|field
argument_list|,
name|pivotValue
argument_list|)
decl_stmt|;
return|return
name|searcher
operator|.
name|numDocs
argument_list|(
name|query
argument_list|,
name|base
argument_list|)
return|;
block|}
block|}
comment|/**    * Given a base docset, computes the subset of documents corrisponding to the specified pivotValue    *    * @param base the set of documents to evalute relative to    * @param field the field type used by the pivotValue    * @param pivotValue String representation of the value, may be null (ie: "missing")    */
DECL|method|getSubset
specifier|private
name|DocSet
name|getSubset
parameter_list|(
name|DocSet
name|base
parameter_list|,
name|SchemaField
name|field
parameter_list|,
name|String
name|pivotValue
parameter_list|)
throws|throws
name|IOException
block|{
name|FieldType
name|ft
init|=
name|field
operator|.
name|getType
argument_list|()
decl_stmt|;
if|if
condition|(
literal|null
operator|==
name|pivotValue
condition|)
block|{
name|Query
name|query
init|=
name|ft
operator|.
name|getRangeQuery
argument_list|(
literal|null
argument_list|,
name|field
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|DocSet
name|hasVal
init|=
name|searcher
operator|.
name|getDocSet
argument_list|(
name|query
argument_list|)
decl_stmt|;
return|return
name|base
operator|.
name|andNot
argument_list|(
name|hasVal
argument_list|)
return|;
block|}
else|else
block|{
name|Query
name|query
init|=
name|ft
operator|.
name|getFieldQuery
argument_list|(
literal|null
argument_list|,
name|field
argument_list|,
name|pivotValue
argument_list|)
decl_stmt|;
return|return
name|searcher
operator|.
name|getDocSet
argument_list|(
name|query
argument_list|,
name|base
argument_list|)
return|;
block|}
block|}
DECL|method|getMinCountForField
specifier|private
name|int
name|getMinCountForField
parameter_list|(
name|String
name|fieldname
parameter_list|)
block|{
return|return
name|params
operator|.
name|getFieldInt
argument_list|(
name|fieldname
argument_list|,
name|FacetParams
operator|.
name|FACET_PIVOT_MINCOUNT
argument_list|,
literal|1
argument_list|)
return|;
block|}
block|}
end_class
end_unit
