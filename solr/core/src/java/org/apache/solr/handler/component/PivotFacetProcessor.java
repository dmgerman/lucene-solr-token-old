begin_unit
begin_package
DECL|package|org.apache.solr.handler.component
package|package
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|handler
operator|.
name|component
package|;
end_package
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|BytesRefBuilder
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|schema
operator|.
name|SchemaField
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|schema
operator|.
name|FieldType
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|search
operator|.
name|SolrIndexSearcher
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|search
operator|.
name|DocSet
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|search
operator|.
name|SyntaxError
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|SolrException
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|util
operator|.
name|NamedList
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|util
operator|.
name|SimpleOrderedMap
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|util
operator|.
name|StrUtils
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|SolrException
operator|.
name|ErrorCode
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|params
operator|.
name|SolrParams
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|params
operator|.
name|FacetParams
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|request
operator|.
name|SimpleFacets
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|request
operator|.
name|SolrQueryRequest
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|Query
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Deque
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedList
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import
begin_comment
comment|/**  * Processes all Pivot facet logic for a single node -- both non-distrib, and per-shard  */
end_comment
begin_class
DECL|class|PivotFacetProcessor
specifier|public
class|class
name|PivotFacetProcessor
extends|extends
name|SimpleFacets
block|{
DECL|field|params
specifier|protected
name|SolrParams
name|params
decl_stmt|;
DECL|method|PivotFacetProcessor
specifier|public
name|PivotFacetProcessor
parameter_list|(
name|SolrQueryRequest
name|req
parameter_list|,
name|DocSet
name|docs
parameter_list|,
name|SolrParams
name|params
parameter_list|,
name|ResponseBuilder
name|rb
parameter_list|)
block|{
name|super
argument_list|(
name|req
argument_list|,
name|docs
argument_list|,
name|params
argument_list|,
name|rb
argument_list|)
expr_stmt|;
name|this
operator|.
name|params
operator|=
name|params
expr_stmt|;
block|}
comment|/**    * Processes all of the specified {@link FacetParams#FACET_PIVOT} strings, generating     * a completel response tree for each pivot.  The values in this response will either     * be the complete tree of fields and values for the specified pivot in the local index,     * or the requested refinements if the pivot params include the {@link PivotFacet#REFINE_PARAM}    */
DECL|method|process
specifier|public
name|SimpleOrderedMap
argument_list|<
name|List
argument_list|<
name|NamedList
argument_list|<
name|Object
argument_list|>
argument_list|>
argument_list|>
name|process
parameter_list|(
name|String
index|[]
name|pivots
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|rb
operator|.
name|doFacets
operator|||
name|pivots
operator|==
literal|null
condition|)
return|return
literal|null
return|;
name|SimpleOrderedMap
argument_list|<
name|List
argument_list|<
name|NamedList
argument_list|<
name|Object
argument_list|>
argument_list|>
argument_list|>
name|pivotResponse
init|=
operator|new
name|SimpleOrderedMap
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|pivotList
range|:
name|pivots
control|)
block|{
try|try
block|{
name|this
operator|.
name|parseParams
argument_list|(
name|FacetParams
operator|.
name|FACET_PIVOT
argument_list|,
name|pivotList
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SyntaxError
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
name|e
argument_list|)
throw|;
block|}
name|List
argument_list|<
name|String
argument_list|>
name|pivotFields
init|=
name|StrUtils
operator|.
name|splitSmart
argument_list|(
name|facetValue
argument_list|,
literal|","
argument_list|,
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
name|pivotFields
operator|.
name|size
argument_list|()
operator|<
literal|1
condition|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
literal|"Pivot Facet needs at least one field name: "
operator|+
name|pivotList
argument_list|)
throw|;
block|}
else|else
block|{
name|SolrIndexSearcher
name|searcher
init|=
name|rb
operator|.
name|req
operator|.
name|getSearcher
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|fieldName
range|:
name|pivotFields
control|)
block|{
name|SchemaField
name|sfield
init|=
name|searcher
operator|.
name|getSchema
argument_list|()
operator|.
name|getField
argument_list|(
name|fieldName
argument_list|)
decl_stmt|;
if|if
condition|(
name|sfield
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
literal|"\""
operator|+
name|fieldName
operator|+
literal|"\" is not a valid field name in pivot: "
operator|+
name|pivotList
argument_list|)
throw|;
block|}
block|}
block|}
comment|//REFINEMENT
name|String
name|fieldValueKey
init|=
name|localParams
operator|==
literal|null
condition|?
literal|null
else|:
name|localParams
operator|.
name|get
argument_list|(
name|PivotFacet
operator|.
name|REFINE_PARAM
argument_list|)
decl_stmt|;
if|if
condition|(
name|fieldValueKey
operator|!=
literal|null
condition|)
block|{
name|String
index|[]
name|refinementValuesByField
init|=
name|params
operator|.
name|getParams
argument_list|(
name|PivotFacet
operator|.
name|REFINE_PARAM
operator|+
name|fieldValueKey
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|refinements
range|:
name|refinementValuesByField
control|)
block|{
name|pivotResponse
operator|.
name|addAll
argument_list|(
name|processSingle
argument_list|(
name|pivotFields
argument_list|,
name|refinements
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|pivotResponse
operator|.
name|addAll
argument_list|(
name|processSingle
argument_list|(
name|pivotFields
argument_list|,
literal|null
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|pivotResponse
return|;
block|}
comment|/**    * Process a single branch of refinement values for a specific pivot    * @param pivotFields the ordered list of fields in this pivot    * @param refinements the comma seperate list of refinement values corrisponding to each field in the pivot, or null if there are no refinements    */
DECL|method|processSingle
specifier|private
name|SimpleOrderedMap
argument_list|<
name|List
argument_list|<
name|NamedList
argument_list|<
name|Object
argument_list|>
argument_list|>
argument_list|>
name|processSingle
parameter_list|(
name|List
argument_list|<
name|String
argument_list|>
name|pivotFields
parameter_list|,
name|String
name|refinements
parameter_list|)
throws|throws
name|IOException
block|{
name|SolrIndexSearcher
name|searcher
init|=
name|rb
operator|.
name|req
operator|.
name|getSearcher
argument_list|()
decl_stmt|;
name|SimpleOrderedMap
argument_list|<
name|List
argument_list|<
name|NamedList
argument_list|<
name|Object
argument_list|>
argument_list|>
argument_list|>
name|pivotResponse
init|=
operator|new
name|SimpleOrderedMap
argument_list|<>
argument_list|()
decl_stmt|;
name|String
name|field
init|=
name|pivotFields
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|SchemaField
name|sfield
init|=
name|searcher
operator|.
name|getSchema
argument_list|()
operator|.
name|getField
argument_list|(
name|field
argument_list|)
decl_stmt|;
name|Deque
argument_list|<
name|String
argument_list|>
name|fnames
init|=
operator|new
name|LinkedList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|pivotFields
operator|.
name|size
argument_list|()
operator|-
literal|1
init|;
name|i
operator|>
literal|1
condition|;
name|i
operator|--
control|)
block|{
name|fnames
operator|.
name|push
argument_list|(
name|pivotFields
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|NamedList
argument_list|<
name|Integer
argument_list|>
name|facetCounts
decl_stmt|;
name|Deque
argument_list|<
name|String
argument_list|>
name|vnames
init|=
operator|new
name|LinkedList
argument_list|<>
argument_list|()
decl_stmt|;
if|if
condition|(
literal|null
operator|!=
name|refinements
condition|)
block|{
comment|// All values, split by the field they should go to
name|List
argument_list|<
name|String
argument_list|>
name|refinementValuesByField
init|=
name|PivotFacetHelper
operator|.
name|decodeRefinementValuePath
argument_list|(
name|refinements
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|refinementValuesByField
operator|.
name|size
argument_list|()
operator|-
literal|1
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|vnames
operator|.
name|push
argument_list|(
name|refinementValuesByField
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
comment|//Only for [1] and on
block|}
name|String
name|firstFieldsValues
init|=
name|refinementValuesByField
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|facetCounts
operator|=
operator|new
name|NamedList
argument_list|<
name|Integer
argument_list|>
argument_list|()
expr_stmt|;
name|facetCounts
operator|.
name|add
argument_list|(
name|firstFieldsValues
argument_list|,
name|getSubsetSize
argument_list|(
name|this
operator|.
name|docs
argument_list|,
name|sfield
argument_list|,
name|firstFieldsValues
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// no refinements needed
name|facetCounts
operator|=
name|this
operator|.
name|getTermCountsForPivots
argument_list|(
name|field
argument_list|,
name|this
operator|.
name|docs
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pivotFields
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
name|String
name|subField
init|=
name|pivotFields
operator|.
name|get
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|pivotResponse
operator|.
name|add
argument_list|(
name|key
argument_list|,
name|doPivots
argument_list|(
name|facetCounts
argument_list|,
name|field
argument_list|,
name|subField
argument_list|,
name|fnames
argument_list|,
name|vnames
argument_list|,
name|this
operator|.
name|docs
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pivotResponse
operator|.
name|add
argument_list|(
name|key
argument_list|,
name|doPivots
argument_list|(
name|facetCounts
argument_list|,
name|field
argument_list|,
literal|null
argument_list|,
name|fnames
argument_list|,
name|vnames
argument_list|,
name|this
operator|.
name|docs
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|pivotResponse
return|;
block|}
comment|/**    * Recursive function to compute all the pivot counts for the values under teh specified field    */
DECL|method|doPivots
specifier|protected
name|List
argument_list|<
name|NamedList
argument_list|<
name|Object
argument_list|>
argument_list|>
name|doPivots
parameter_list|(
name|NamedList
argument_list|<
name|Integer
argument_list|>
name|superFacets
parameter_list|,
name|String
name|field
parameter_list|,
name|String
name|subField
parameter_list|,
name|Deque
argument_list|<
name|String
argument_list|>
name|fnames
parameter_list|,
name|Deque
argument_list|<
name|String
argument_list|>
name|vnames
parameter_list|,
name|DocSet
name|docs
parameter_list|)
throws|throws
name|IOException
block|{
name|SolrIndexSearcher
name|searcher
init|=
name|rb
operator|.
name|req
operator|.
name|getSearcher
argument_list|()
decl_stmt|;
comment|// TODO: optimize to avoid converting to an external string and then having to convert back to internal below
name|SchemaField
name|sfield
init|=
name|searcher
operator|.
name|getSchema
argument_list|()
operator|.
name|getField
argument_list|(
name|field
argument_list|)
decl_stmt|;
name|FieldType
name|ftype
init|=
name|sfield
operator|.
name|getType
argument_list|()
decl_stmt|;
name|String
name|nextField
init|=
name|fnames
operator|.
name|poll
argument_list|()
decl_stmt|;
comment|// re-useable BytesRefBuilder for conversion of term values to Objects
name|BytesRefBuilder
name|termval
init|=
operator|new
name|BytesRefBuilder
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|NamedList
argument_list|<
name|Object
argument_list|>
argument_list|>
name|values
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|superFacets
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|kv
range|:
name|superFacets
control|)
block|{
comment|// Only sub-facet if parent facet has positive count - still may not be any values for the sub-field though
if|if
condition|(
name|kv
operator|.
name|getValue
argument_list|()
operator|>=
name|getMinCountForField
argument_list|(
name|field
argument_list|)
condition|)
block|{
specifier|final
name|String
name|fieldValue
init|=
name|kv
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|SimpleOrderedMap
argument_list|<
name|Object
argument_list|>
name|pivot
init|=
operator|new
name|SimpleOrderedMap
argument_list|<>
argument_list|()
decl_stmt|;
name|pivot
operator|.
name|add
argument_list|(
literal|"field"
argument_list|,
name|field
argument_list|)
expr_stmt|;
if|if
condition|(
literal|null
operator|==
name|fieldValue
condition|)
block|{
name|pivot
operator|.
name|add
argument_list|(
literal|"value"
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ftype
operator|.
name|readableToIndexed
argument_list|(
name|fieldValue
argument_list|,
name|termval
argument_list|)
expr_stmt|;
name|pivot
operator|.
name|add
argument_list|(
literal|"value"
argument_list|,
name|ftype
operator|.
name|toObject
argument_list|(
name|sfield
argument_list|,
name|termval
operator|.
name|get
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|pivot
operator|.
name|add
argument_list|(
literal|"count"
argument_list|,
name|kv
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
name|DocSet
name|subset
init|=
name|getSubset
argument_list|(
name|docs
argument_list|,
name|sfield
argument_list|,
name|fieldValue
argument_list|)
decl_stmt|;
if|if
condition|(
name|subField
operator|!=
literal|null
condition|)
block|{
name|NamedList
argument_list|<
name|Integer
argument_list|>
name|facetCounts
decl_stmt|;
if|if
condition|(
operator|!
name|vnames
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|String
name|val
init|=
name|vnames
operator|.
name|pop
argument_list|()
decl_stmt|;
name|facetCounts
operator|=
operator|new
name|NamedList
argument_list|<
name|Integer
argument_list|>
argument_list|()
expr_stmt|;
name|facetCounts
operator|.
name|add
argument_list|(
name|val
argument_list|,
name|getSubsetSize
argument_list|(
name|subset
argument_list|,
name|searcher
operator|.
name|getSchema
argument_list|()
operator|.
name|getField
argument_list|(
name|subField
argument_list|)
argument_list|,
name|val
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|facetCounts
operator|=
name|this
operator|.
name|getTermCountsForPivots
argument_list|(
name|subField
argument_list|,
name|subset
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|facetCounts
operator|.
name|size
argument_list|()
operator|>=
literal|1
condition|)
block|{
name|pivot
operator|.
name|add
argument_list|(
literal|"pivot"
argument_list|,
name|doPivots
argument_list|(
name|facetCounts
argument_list|,
name|subField
argument_list|,
name|nextField
argument_list|,
name|fnames
argument_list|,
name|vnames
argument_list|,
name|subset
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|values
operator|.
name|add
argument_list|(
name|pivot
argument_list|)
expr_stmt|;
block|}
block|}
comment|// put the field back on the list
name|fnames
operator|.
name|push
argument_list|(
name|nextField
argument_list|)
expr_stmt|;
return|return
name|values
return|;
block|}
comment|/**    * Given a base docset, computes the size of the subset of documents corrisponding to the specified pivotValue    *    * @param base the set of documents to evalute relative to    * @param field the field type used by the pivotValue    * @param pivotValue String representation of the value, may be null (ie: "missing")    */
DECL|method|getSubsetSize
specifier|private
name|int
name|getSubsetSize
parameter_list|(
name|DocSet
name|base
parameter_list|,
name|SchemaField
name|field
parameter_list|,
name|String
name|pivotValue
parameter_list|)
throws|throws
name|IOException
block|{
name|FieldType
name|ft
init|=
name|field
operator|.
name|getType
argument_list|()
decl_stmt|;
if|if
condition|(
literal|null
operator|==
name|pivotValue
condition|)
block|{
name|Query
name|query
init|=
name|ft
operator|.
name|getRangeQuery
argument_list|(
literal|null
argument_list|,
name|field
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|DocSet
name|hasVal
init|=
name|searcher
operator|.
name|getDocSet
argument_list|(
name|query
argument_list|)
decl_stmt|;
return|return
name|base
operator|.
name|andNotSize
argument_list|(
name|hasVal
argument_list|)
return|;
block|}
else|else
block|{
name|Query
name|query
init|=
name|ft
operator|.
name|getFieldQuery
argument_list|(
literal|null
argument_list|,
name|field
argument_list|,
name|pivotValue
argument_list|)
decl_stmt|;
return|return
name|searcher
operator|.
name|numDocs
argument_list|(
name|query
argument_list|,
name|base
argument_list|)
return|;
block|}
block|}
comment|/**    * Given a base docset, computes the subset of documents corrisponding to the specified pivotValue    *    * @param base the set of documents to evalute relative to    * @param field the field type used by the pivotValue    * @param pivotValue String representation of the value, may be null (ie: "missing")    */
DECL|method|getSubset
specifier|private
name|DocSet
name|getSubset
parameter_list|(
name|DocSet
name|base
parameter_list|,
name|SchemaField
name|field
parameter_list|,
name|String
name|pivotValue
parameter_list|)
throws|throws
name|IOException
block|{
name|FieldType
name|ft
init|=
name|field
operator|.
name|getType
argument_list|()
decl_stmt|;
if|if
condition|(
literal|null
operator|==
name|pivotValue
condition|)
block|{
name|Query
name|query
init|=
name|ft
operator|.
name|getRangeQuery
argument_list|(
literal|null
argument_list|,
name|field
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|DocSet
name|hasVal
init|=
name|searcher
operator|.
name|getDocSet
argument_list|(
name|query
argument_list|)
decl_stmt|;
return|return
name|base
operator|.
name|andNot
argument_list|(
name|hasVal
argument_list|)
return|;
block|}
else|else
block|{
name|Query
name|query
init|=
name|ft
operator|.
name|getFieldQuery
argument_list|(
literal|null
argument_list|,
name|field
argument_list|,
name|pivotValue
argument_list|)
decl_stmt|;
return|return
name|searcher
operator|.
name|getDocSet
argument_list|(
name|query
argument_list|,
name|base
argument_list|)
return|;
block|}
block|}
DECL|method|getMinCountForField
specifier|private
name|int
name|getMinCountForField
parameter_list|(
name|String
name|fieldname
parameter_list|)
block|{
return|return
name|params
operator|.
name|getFieldInt
argument_list|(
name|fieldname
argument_list|,
name|FacetParams
operator|.
name|FACET_PIVOT_MINCOUNT
argument_list|,
literal|1
argument_list|)
return|;
block|}
block|}
end_class
end_unit
