begin_unit
begin_package
DECL|package|org.apache.solr.handler.component
package|package
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|handler
operator|.
name|component
package|;
end_package
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_import
import|import
name|javax
operator|.
name|imageio
operator|.
name|ImageIO
import|;
end_import
begin_import
import|import
name|javax
operator|.
name|imageio
operator|.
name|ImageReader
import|;
end_import
begin_import
import|import
name|javax
operator|.
name|imageio
operator|.
name|spi
operator|.
name|ImageReaderSpi
import|;
end_import
begin_import
import|import
name|javax
operator|.
name|imageio
operator|.
name|stream
operator|.
name|ImageInputStream
import|;
end_import
begin_import
import|import
name|javax
operator|.
name|imageio
operator|.
name|stream
operator|.
name|ImageInputStreamImpl
import|;
end_import
begin_import
import|import
name|java
operator|.
name|awt
operator|.
name|image
operator|.
name|BufferedImage
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ByteArrayOutputStream
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|invoke
operator|.
name|MethodHandles
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|AbstractList
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashMap
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import
begin_import
import|import
name|com
operator|.
name|spatial4j
operator|.
name|core
operator|.
name|context
operator|.
name|SpatialContext
import|;
end_import
begin_import
import|import
name|com
operator|.
name|spatial4j
operator|.
name|core
operator|.
name|shape
operator|.
name|Shape
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|spatial
operator|.
name|prefix
operator|.
name|HeatmapFacetCounter
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|spatial
operator|.
name|prefix
operator|.
name|PrefixTreeStrategy
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|spatial
operator|.
name|query
operator|.
name|SpatialArgs
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|spatial
operator|.
name|query
operator|.
name|SpatialOperation
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|SolrException
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|params
operator|.
name|CommonParams
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|params
operator|.
name|FacetParams
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|params
operator|.
name|SolrParams
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|util
operator|.
name|NamedList
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|util
operator|.
name|SimpleOrderedMap
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|schema
operator|.
name|AbstractSpatialPrefixTreeFieldType
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|schema
operator|.
name|FieldType
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|schema
operator|.
name|SchemaField
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|schema
operator|.
name|SpatialRecursivePrefixTreeFieldType
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|search
operator|.
name|DocSet
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|search
operator|.
name|QueryParsing
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|util
operator|.
name|SpatialUtils
import|;
end_import
begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import
begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import
begin_comment
comment|/** A 2D spatial faceting summary of a rectangular region. Used by {@link org.apache.solr.handler.component.FacetComponent}  * and {@link org.apache.solr.request.SimpleFacets}. */
end_comment
begin_class
DECL|class|SpatialHeatmapFacets
specifier|public
class|class
name|SpatialHeatmapFacets
block|{
DECL|field|log
specifier|private
specifier|static
specifier|final
name|Logger
name|log
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|MethodHandles
operator|.
name|lookup
argument_list|()
operator|.
name|lookupClass
argument_list|()
argument_list|)
decl_stmt|;
comment|//underneath facet_counts we put this here:
DECL|field|RESPONSE_KEY
specifier|public
specifier|static
specifier|final
name|String
name|RESPONSE_KEY
init|=
literal|"facet_heatmaps"
decl_stmt|;
DECL|field|FORMAT_PNG
specifier|public
specifier|static
specifier|final
name|String
name|FORMAT_PNG
init|=
literal|"png"
decl_stmt|;
DECL|field|FORMAT_INTS2D
specifier|public
specifier|static
specifier|final
name|String
name|FORMAT_INTS2D
init|=
literal|"ints2D"
decl_stmt|;
comment|//note: if we change or add more formats, remember to update the javadoc on the format param
comment|//TODO for more format ideas, see formatCountsAndAddToNL
DECL|field|DEFAULT_DIST_ERR_PCT
specifier|public
specifier|static
specifier|final
name|double
name|DEFAULT_DIST_ERR_PCT
init|=
literal|0.15
decl_stmt|;
comment|/** Called by {@link org.apache.solr.request.SimpleFacets} to compute heatmap facets. */
DECL|method|getHeatmapForField
specifier|public
specifier|static
name|NamedList
argument_list|<
name|Object
argument_list|>
name|getHeatmapForField
parameter_list|(
name|String
name|fieldKey
parameter_list|,
name|String
name|fieldName
parameter_list|,
name|ResponseBuilder
name|rb
parameter_list|,
name|SolrParams
name|params
parameter_list|,
name|DocSet
name|docSet
parameter_list|)
throws|throws
name|IOException
block|{
comment|//get the strategy from the field type
specifier|final
name|SchemaField
name|schemaField
init|=
name|rb
operator|.
name|req
operator|.
name|getSchema
argument_list|()
operator|.
name|getField
argument_list|(
name|fieldName
argument_list|)
decl_stmt|;
specifier|final
name|FieldType
name|type
init|=
name|schemaField
operator|.
name|getType
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|type
operator|instanceof
name|AbstractSpatialPrefixTreeFieldType
operator|)
condition|)
block|{
comment|//FYI we support the term query one too but few people use that one
throw|throw
operator|new
name|SolrException
argument_list|(
name|SolrException
operator|.
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
literal|"heatmap field needs to be of type "
operator|+
name|SpatialRecursivePrefixTreeFieldType
operator|.
name|class
argument_list|)
throw|;
block|}
name|AbstractSpatialPrefixTreeFieldType
name|rptType
init|=
operator|(
name|AbstractSpatialPrefixTreeFieldType
operator|)
name|type
decl_stmt|;
specifier|final
name|PrefixTreeStrategy
name|strategy
init|=
operator|(
name|PrefixTreeStrategy
operator|)
name|rptType
operator|.
name|getStrategy
argument_list|(
name|fieldName
argument_list|)
decl_stmt|;
specifier|final
name|SpatialContext
name|ctx
init|=
name|strategy
operator|.
name|getSpatialContext
argument_list|()
decl_stmt|;
comment|//get the bbox (query Rectangle)
name|String
name|geomStr
init|=
name|params
operator|.
name|getFieldParam
argument_list|(
name|fieldKey
argument_list|,
name|FacetParams
operator|.
name|FACET_HEATMAP_GEOM
argument_list|)
decl_stmt|;
specifier|final
name|Shape
name|boundsShape
init|=
name|geomStr
operator|==
literal|null
condition|?
name|ctx
operator|.
name|getWorldBounds
argument_list|()
else|:
name|SpatialUtils
operator|.
name|parseGeomSolrException
argument_list|(
name|geomStr
argument_list|,
name|ctx
argument_list|)
decl_stmt|;
comment|//get the grid level (possibly indirectly via distErr or distErrPct)
specifier|final
name|int
name|gridLevel
decl_stmt|;
name|Integer
name|gridLevelObj
init|=
name|params
operator|.
name|getFieldInt
argument_list|(
name|fieldKey
argument_list|,
name|FacetParams
operator|.
name|FACET_HEATMAP_LEVEL
argument_list|)
decl_stmt|;
specifier|final
name|int
name|maxGridLevel
init|=
name|strategy
operator|.
name|getGrid
argument_list|()
operator|.
name|getMaxLevels
argument_list|()
decl_stmt|;
if|if
condition|(
name|gridLevelObj
operator|!=
literal|null
condition|)
block|{
name|gridLevel
operator|=
name|gridLevelObj
expr_stmt|;
if|if
condition|(
name|gridLevel
operator|<=
literal|0
operator|||
name|gridLevel
operator|>
name|maxGridLevel
condition|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|SolrException
operator|.
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
name|FacetParams
operator|.
name|FACET_HEATMAP_LEVEL
operator|+
literal|" should be> 0 and<= "
operator|+
name|maxGridLevel
argument_list|)
throw|;
block|}
block|}
else|else
block|{
comment|//SpatialArgs has utility methods to resolve a 'distErr' from optionally set distErr& distErrPct. Arguably that
comment|// should be refactored to feel less weird than using it like this.
name|SpatialArgs
name|spatialArgs
init|=
operator|new
name|SpatialArgs
argument_list|(
name|SpatialOperation
operator|.
name|Intersects
comment|/*ignored*/
argument_list|,
name|boundsShape
operator|==
literal|null
condition|?
name|ctx
operator|.
name|getWorldBounds
argument_list|()
else|:
name|boundsShape
argument_list|)
decl_stmt|;
specifier|final
name|Double
name|distErrObj
init|=
name|params
operator|.
name|getFieldDouble
argument_list|(
name|fieldKey
argument_list|,
name|FacetParams
operator|.
name|FACET_HEATMAP_DIST_ERR
argument_list|)
decl_stmt|;
if|if
condition|(
name|distErrObj
operator|!=
literal|null
condition|)
block|{
comment|// convert distErr units based on configured units
name|spatialArgs
operator|.
name|setDistErr
argument_list|(
name|distErrObj
operator|*
name|rptType
operator|.
name|getDistanceUnits
argument_list|()
operator|.
name|multiplierFromThisUnitToDegrees
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|spatialArgs
operator|.
name|setDistErrPct
argument_list|(
name|params
operator|.
name|getFieldDouble
argument_list|(
name|fieldKey
argument_list|,
name|FacetParams
operator|.
name|FACET_HEATMAP_DIST_ERR_PCT
argument_list|)
argument_list|)
expr_stmt|;
name|double
name|distErr
init|=
name|spatialArgs
operator|.
name|resolveDistErr
argument_list|(
name|ctx
argument_list|,
name|DEFAULT_DIST_ERR_PCT
argument_list|)
decl_stmt|;
if|if
condition|(
name|distErr
operator|<=
literal|0
condition|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|SolrException
operator|.
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
name|FacetParams
operator|.
name|FACET_HEATMAP_DIST_ERR_PCT
operator|+
literal|" or "
operator|+
name|FacetParams
operator|.
name|FACET_HEATMAP_DIST_ERR
operator|+
literal|" should be> 0 or instead provide "
operator|+
name|FacetParams
operator|.
name|FACET_HEATMAP_LEVEL
operator|+
literal|"="
operator|+
name|maxGridLevel
operator|+
literal|" if you insist on maximum detail"
argument_list|)
throw|;
block|}
comment|//The SPT (grid) can lookup a grid level satisfying an error distance constraint
name|gridLevel
operator|=
name|strategy
operator|.
name|getGrid
argument_list|()
operator|.
name|getLevelForDistance
argument_list|(
name|distErr
argument_list|)
expr_stmt|;
block|}
comment|//Compute!
specifier|final
name|HeatmapFacetCounter
operator|.
name|Heatmap
name|heatmap
decl_stmt|;
try|try
block|{
name|heatmap
operator|=
name|HeatmapFacetCounter
operator|.
name|calcFacets
argument_list|(
name|strategy
argument_list|,
name|rb
operator|.
name|req
operator|.
name|getSearcher
argument_list|()
operator|.
name|getTopReaderContext
argument_list|()
argument_list|,
name|docSet
operator|.
name|getTopFilter
argument_list|()
argument_list|,
name|boundsShape
argument_list|,
name|gridLevel
argument_list|,
name|params
operator|.
name|getFieldInt
argument_list|(
name|fieldKey
argument_list|,
name|FacetParams
operator|.
name|FACET_HEATMAP_MAX_CELLS
argument_list|,
literal|100_000
argument_list|)
comment|// will throw if exceeded
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|e
parameter_list|)
block|{
comment|//e.g. too many cells
throw|throw
operator|new
name|SolrException
argument_list|(
name|SolrException
operator|.
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
name|e
operator|.
name|toString
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
comment|//Populate response
name|NamedList
argument_list|<
name|Object
argument_list|>
name|result
init|=
operator|new
name|NamedList
argument_list|<>
argument_list|()
decl_stmt|;
name|result
operator|.
name|add
argument_list|(
literal|"gridLevel"
argument_list|,
name|gridLevel
argument_list|)
expr_stmt|;
name|result
operator|.
name|add
argument_list|(
literal|"columns"
argument_list|,
name|heatmap
operator|.
name|columns
argument_list|)
expr_stmt|;
name|result
operator|.
name|add
argument_list|(
literal|"rows"
argument_list|,
name|heatmap
operator|.
name|rows
argument_list|)
expr_stmt|;
name|result
operator|.
name|add
argument_list|(
literal|"minX"
argument_list|,
name|heatmap
operator|.
name|region
operator|.
name|getMinX
argument_list|()
argument_list|)
expr_stmt|;
name|result
operator|.
name|add
argument_list|(
literal|"maxX"
argument_list|,
name|heatmap
operator|.
name|region
operator|.
name|getMaxX
argument_list|()
argument_list|)
expr_stmt|;
name|result
operator|.
name|add
argument_list|(
literal|"minY"
argument_list|,
name|heatmap
operator|.
name|region
operator|.
name|getMinY
argument_list|()
argument_list|)
expr_stmt|;
name|result
operator|.
name|add
argument_list|(
literal|"maxY"
argument_list|,
name|heatmap
operator|.
name|region
operator|.
name|getMaxY
argument_list|()
argument_list|)
expr_stmt|;
name|boolean
name|hasNonZero
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|count
range|:
name|heatmap
operator|.
name|counts
control|)
block|{
if|if
condition|(
name|count
operator|>
literal|0
condition|)
block|{
name|hasNonZero
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
name|formatCountsAndAddToNL
argument_list|(
name|fieldKey
argument_list|,
name|rb
argument_list|,
name|params
argument_list|,
name|heatmap
operator|.
name|columns
argument_list|,
name|heatmap
operator|.
name|rows
argument_list|,
name|hasNonZero
condition|?
name|heatmap
operator|.
name|counts
else|:
literal|null
argument_list|,
name|result
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
DECL|method|formatCountsAndAddToNL
specifier|private
specifier|static
name|void
name|formatCountsAndAddToNL
parameter_list|(
name|String
name|fieldKey
parameter_list|,
name|ResponseBuilder
name|rb
parameter_list|,
name|SolrParams
name|params
parameter_list|,
name|int
name|columns
parameter_list|,
name|int
name|rows
parameter_list|,
name|int
index|[]
name|counts
parameter_list|,
name|NamedList
argument_list|<
name|Object
argument_list|>
name|result
parameter_list|)
block|{
specifier|final
name|String
name|format
init|=
name|params
operator|.
name|getFieldParam
argument_list|(
name|fieldKey
argument_list|,
name|FacetParams
operator|.
name|FACET_HEATMAP_FORMAT
argument_list|,
name|FORMAT_INTS2D
argument_list|)
decl_stmt|;
specifier|final
name|Object
name|countsVal
decl_stmt|;
switch|switch
condition|(
name|format
condition|)
block|{
case|case
name|FORMAT_INTS2D
case|:
comment|//A List of List of Integers. Good for small heatmaps and ease of consumption
name|countsVal
operator|=
name|counts
operator|!=
literal|null
condition|?
name|asInts2D
argument_list|(
name|columns
argument_list|,
name|rows
argument_list|,
name|counts
argument_list|)
else|:
literal|null
expr_stmt|;
break|break;
case|case
name|FORMAT_PNG
case|:
comment|//A PNG graphic; compressed.  Good for large& dense heatmaps; hard to consume.
name|countsVal
operator|=
name|counts
operator|!=
literal|null
condition|?
name|asPngBytes
argument_list|(
name|columns
argument_list|,
name|rows
argument_list|,
name|counts
argument_list|,
name|rb
argument_list|)
else|:
literal|null
expr_stmt|;
break|break;
comment|//TODO  case skipList: //A sequence of values; negative values are actually how many 0's to insert.
comment|//            Good for small or large but sparse heatmaps.
comment|//TODO    auto choose png or skipList; use skipList when< ~25% full or<= ~512 cells
comment|//  remember to augment error list below when we add more formats.
default|default:
throw|throw
operator|new
name|SolrException
argument_list|(
name|SolrException
operator|.
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
literal|"format should be "
operator|+
name|FORMAT_INTS2D
operator|+
literal|" or "
operator|+
name|FORMAT_PNG
argument_list|)
throw|;
block|}
name|result
operator|.
name|add
argument_list|(
literal|"counts_"
operator|+
name|format
argument_list|,
name|countsVal
argument_list|)
expr_stmt|;
block|}
DECL|method|asInts2D
specifier|static
name|List
argument_list|<
name|List
argument_list|<
name|Integer
argument_list|>
argument_list|>
name|asInts2D
parameter_list|(
specifier|final
name|int
name|columns
parameter_list|,
specifier|final
name|int
name|rows
parameter_list|,
specifier|final
name|int
index|[]
name|counts
parameter_list|)
block|{
comment|//Returns a view versus returning a copy. This saves memory.
comment|//The data is oriented naturally for human/developer viewing: one row at a time top-down
return|return
operator|new
name|AbstractList
argument_list|<
name|List
argument_list|<
name|Integer
argument_list|>
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|List
argument_list|<
name|Integer
argument_list|>
name|get
parameter_list|(
specifier|final
name|int
name|rowIdx
parameter_list|)
block|{
comment|//top-down remember; the heatmap.counts is bottom up
comment|//check if all zeroes and return null if so
name|boolean
name|hasNonZero
init|=
literal|false
decl_stmt|;
name|int
name|y
init|=
name|rows
operator|-
name|rowIdx
operator|-
literal|1
decl_stmt|;
comment|//flip direction for 'y'
for|for
control|(
name|int
name|c
init|=
literal|0
init|;
name|c
operator|<
name|columns
condition|;
name|c
operator|++
control|)
block|{
if|if
condition|(
name|counts
index|[
name|c
operator|*
name|rows
operator|+
name|y
index|]
operator|>
literal|0
condition|)
block|{
name|hasNonZero
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|hasNonZero
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
operator|new
name|AbstractList
argument_list|<
name|Integer
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Integer
name|get
parameter_list|(
name|int
name|columnIdx
parameter_list|)
block|{
return|return
name|counts
index|[
name|columnIdx
operator|*
name|rows
operator|+
name|y
index|]
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|columns
return|;
block|}
block|}
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|rows
return|;
block|}
block|}
return|;
block|}
comment|//package access for tests
DECL|method|asPngBytes
specifier|static
name|byte
index|[]
name|asPngBytes
parameter_list|(
specifier|final
name|int
name|columns
parameter_list|,
specifier|final
name|int
name|rows
parameter_list|,
specifier|final
name|int
index|[]
name|counts
parameter_list|,
name|ResponseBuilder
name|rb
parameter_list|)
block|{
name|long
name|startTimeNano
init|=
name|System
operator|.
name|nanoTime
argument_list|()
decl_stmt|;
name|BufferedImage
name|image
init|=
name|PngHelper
operator|.
name|newImage
argument_list|(
name|columns
argument_list|,
name|rows
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|c
init|=
literal|0
init|;
name|c
operator|<
name|columns
condition|;
name|c
operator|++
control|)
block|{
for|for
control|(
name|int
name|r
init|=
literal|0
init|;
name|r
operator|<
name|rows
condition|;
name|r
operator|++
control|)
block|{
name|PngHelper
operator|.
name|writeCountAtColumnRow
argument_list|(
name|image
argument_list|,
name|rows
argument_list|,
name|c
argument_list|,
name|r
argument_list|,
name|counts
index|[
name|c
operator|*
name|rows
operator|+
name|r
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|byte
index|[]
name|bytes
init|=
name|PngHelper
operator|.
name|writeImage
argument_list|(
name|image
argument_list|)
decl_stmt|;
name|long
name|durationMs
init|=
name|TimeUnit
operator|.
name|NANOSECONDS
operator|.
name|toMillis
argument_list|(
name|System
operator|.
name|nanoTime
argument_list|()
operator|-
name|startTimeNano
argument_list|)
decl_stmt|;
name|log
operator|.
name|debug
argument_list|(
literal|"heatmap nativeSize={} pngSize={} pngTime={}"
argument_list|,
operator|(
name|counts
operator|.
name|length
operator|*
literal|4
operator|)
argument_list|,
name|bytes
operator|.
name|length
argument_list|,
name|durationMs
argument_list|)
expr_stmt|;
if|if
condition|(
name|rb
operator|!=
literal|null
operator|&&
name|rb
operator|.
name|isDebugTimings
argument_list|()
condition|)
block|{
name|rb
operator|.
name|addDebug
argument_list|(
name|durationMs
argument_list|,
literal|"timing"
argument_list|,
literal|"heatmap png generation"
argument_list|)
expr_stmt|;
block|}
return|return
name|bytes
return|;
block|}
comment|//
comment|// Distributed Support
comment|//
comment|/** Parses request to "HeatmapFacet" instances. */
DECL|method|distribParse
specifier|public
specifier|static
name|LinkedHashMap
argument_list|<
name|String
argument_list|,
name|HeatmapFacet
argument_list|>
name|distribParse
parameter_list|(
name|SolrParams
name|params
parameter_list|,
name|ResponseBuilder
name|rb
parameter_list|)
block|{
specifier|final
name|LinkedHashMap
argument_list|<
name|String
argument_list|,
name|HeatmapFacet
argument_list|>
name|heatmapFacets
init|=
operator|new
name|LinkedHashMap
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|String
index|[]
name|heatmapFields
init|=
name|params
operator|.
name|getParams
argument_list|(
name|FacetParams
operator|.
name|FACET_HEATMAP
argument_list|)
decl_stmt|;
if|if
condition|(
name|heatmapFields
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|String
name|heatmapField
range|:
name|heatmapFields
control|)
block|{
name|HeatmapFacet
name|facet
init|=
operator|new
name|HeatmapFacet
argument_list|(
name|rb
argument_list|,
name|heatmapField
argument_list|)
decl_stmt|;
name|heatmapFacets
operator|.
name|put
argument_list|(
name|facet
operator|.
name|getKey
argument_list|()
argument_list|,
name|facet
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|heatmapFacets
return|;
block|}
comment|/** Called by FacetComponent's impl of    * {@link org.apache.solr.handler.component.SearchComponent#modifyRequest(ResponseBuilder, SearchComponent, ShardRequest)}. */
DECL|method|distribModifyRequest
specifier|public
specifier|static
name|void
name|distribModifyRequest
parameter_list|(
name|ShardRequest
name|sreq
parameter_list|,
name|LinkedHashMap
argument_list|<
name|String
argument_list|,
name|HeatmapFacet
argument_list|>
name|heatmapFacets
parameter_list|)
block|{
comment|// Set the format to PNG because it's compressed and it's the only format we have code to read at the moment.
comment|//  Changing a param is sadly tricky because field-specific params can show up as local-params (highest precedence)
comment|//  or as f.key.facet.heatmap.whatever. Ugh. So we re-write the facet.heatmap list with the local-params
comment|//  moved out to the "f.key." prefix, but we need to keep the key local-param because that's the only way to
comment|//  set an output key. This approach means we only need to know about the parameter we're changing, not of
comment|//  all possible heatmap params.
comment|//Remove existing heatmap field param vals; we will rewrite
name|sreq
operator|.
name|params
operator|.
name|remove
argument_list|(
name|FacetParams
operator|.
name|FACET_HEATMAP
argument_list|)
expr_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|HeatmapFacet
argument_list|>
name|entry
range|:
name|heatmapFacets
operator|.
name|entrySet
argument_list|()
control|)
block|{
specifier|final
name|String
name|key
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
specifier|final
name|HeatmapFacet
name|facet
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
comment|//add heatmap field param
if|if
condition|(
operator|!
name|key
operator|.
name|equals
argument_list|(
name|facet
operator|.
name|facetOn
argument_list|)
condition|)
block|{
name|sreq
operator|.
name|params
operator|.
name|add
argument_list|(
name|FacetParams
operator|.
name|FACET_HEATMAP
argument_list|,
literal|"{!"
operator|+
name|CommonParams
operator|.
name|OUTPUT_KEY
operator|+
literal|"="
operator|+
name|QueryParsing
operator|.
name|encodeLocalParamVal
argument_list|(
name|key
argument_list|)
operator|+
literal|"}"
operator|+
name|facet
operator|.
name|facetOn
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sreq
operator|.
name|params
operator|.
name|add
argument_list|(
name|FacetParams
operator|.
name|FACET_HEATMAP
argument_list|,
name|facet
operator|.
name|facetOn
argument_list|)
expr_stmt|;
block|}
comment|// Turn local-params into top-level f.key.param=value style params
if|if
condition|(
name|facet
operator|.
name|localParams
operator|!=
literal|null
condition|)
block|{
specifier|final
name|Iterator
argument_list|<
name|String
argument_list|>
name|localNameIter
init|=
name|facet
operator|.
name|localParams
operator|.
name|getParameterNamesIterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|localNameIter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|String
name|pname
init|=
name|localNameIter
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|pname
operator|.
name|startsWith
argument_list|(
name|FacetParams
operator|.
name|FACET_HEATMAP
argument_list|)
condition|)
block|{
continue|continue;
comment|// could be 'key', or 'v' even
block|}
name|String
name|pval
init|=
name|facet
operator|.
name|localParams
operator|.
name|get
argument_list|(
name|pname
argument_list|)
decl_stmt|;
name|sreq
operator|.
name|params
operator|.
name|set
argument_list|(
literal|"f."
operator|+
name|key
operator|+
literal|"."
operator|+
name|pname
argument_list|,
name|pval
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Set format to PNG; it's the only one we parse
name|sreq
operator|.
name|params
operator|.
name|set
argument_list|(
literal|"f."
operator|+
name|key
operator|+
literal|"."
operator|+
name|FacetParams
operator|.
name|FACET_HEATMAP_FORMAT
argument_list|,
name|FORMAT_PNG
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Called by FacetComponent.countFacets which is in turn called by FC's impl of    * {@link org.apache.solr.handler.component.SearchComponent#handleResponses(ResponseBuilder, ShardRequest)}. */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|distribHandleResponse
specifier|public
specifier|static
name|void
name|distribHandleResponse
parameter_list|(
name|LinkedHashMap
argument_list|<
name|String
argument_list|,
name|HeatmapFacet
argument_list|>
name|heatmapFacets
parameter_list|,
name|NamedList
name|srsp_facet_counts
parameter_list|)
block|{
name|NamedList
argument_list|<
name|NamedList
argument_list|<
name|Object
argument_list|>
argument_list|>
name|facet_heatmaps
init|=
operator|(
name|NamedList
argument_list|<
name|NamedList
argument_list|<
name|Object
argument_list|>
argument_list|>
operator|)
name|srsp_facet_counts
operator|.
name|get
argument_list|(
name|RESPONSE_KEY
argument_list|)
decl_stmt|;
if|if
condition|(
name|facet_heatmaps
operator|==
literal|null
condition|)
block|{
return|return;
block|}
comment|// (should the caller handle the above logic?  Arguably yes.)
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|NamedList
argument_list|<
name|Object
argument_list|>
argument_list|>
name|entry
range|:
name|facet_heatmaps
control|)
block|{
name|String
name|fieldKey
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|NamedList
argument_list|<
name|Object
argument_list|>
name|shardNamedList
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
specifier|final
name|HeatmapFacet
name|facet
init|=
name|heatmapFacets
operator|.
name|get
argument_list|(
name|fieldKey
argument_list|)
decl_stmt|;
if|if
condition|(
name|facet
operator|==
literal|null
condition|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"received heatmap for field/key {} that we weren't expecting"
argument_list|,
name|fieldKey
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|facet
operator|.
name|counts
operator|=
name|addPngToIntArray
argument_list|(
operator|(
name|byte
index|[]
operator|)
name|shardNamedList
operator|.
name|remove
argument_list|(
literal|"counts_"
operator|+
name|FORMAT_PNG
argument_list|)
argument_list|,
name|facet
operator|.
name|counts
argument_list|)
expr_stmt|;
if|if
condition|(
name|facet
operator|.
name|namedList
operator|==
literal|null
condition|)
block|{
comment|// First shard
name|facet
operator|.
name|namedList
operator|=
name|shardNamedList
expr_stmt|;
block|}
else|else
block|{
assert|assert
name|facet
operator|.
name|namedList
operator|.
name|equals
argument_list|(
name|shardNamedList
argument_list|)
assert|;
block|}
block|}
block|}
comment|//package access for tests
DECL|method|addPngToIntArray
specifier|static
name|int
index|[]
name|addPngToIntArray
parameter_list|(
name|byte
index|[]
name|pngBytes
parameter_list|,
name|int
index|[]
name|counts
parameter_list|)
block|{
if|if
condition|(
name|pngBytes
operator|==
literal|null
condition|)
block|{
return|return
name|counts
return|;
block|}
comment|//read PNG
specifier|final
name|BufferedImage
name|image
init|=
name|PngHelper
operator|.
name|readImage
argument_list|(
name|pngBytes
argument_list|)
decl_stmt|;
name|int
name|columns
init|=
name|image
operator|.
name|getWidth
argument_list|()
decl_stmt|;
name|int
name|rows
init|=
name|image
operator|.
name|getHeight
argument_list|()
decl_stmt|;
if|if
condition|(
name|counts
operator|==
literal|null
condition|)
block|{
name|counts
operator|=
operator|new
name|int
index|[
name|columns
operator|*
name|rows
index|]
expr_stmt|;
block|}
else|else
block|{
assert|assert
name|counts
operator|.
name|length
operator|==
name|columns
operator|*
name|rows
assert|;
block|}
for|for
control|(
name|int
name|c
init|=
literal|0
init|;
name|c
operator|<
name|columns
condition|;
name|c
operator|++
control|)
block|{
for|for
control|(
name|int
name|r
init|=
literal|0
init|;
name|r
operator|<
name|rows
condition|;
name|r
operator|++
control|)
block|{
name|counts
index|[
name|c
operator|*
name|rows
operator|+
name|r
index|]
operator|+=
name|PngHelper
operator|.
name|getCountAtColumnRow
argument_list|(
name|image
argument_list|,
name|rows
argument_list|,
name|c
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|counts
return|;
block|}
comment|/** Called by FacetComponent's impl of    * {@link org.apache.solr.handler.component.SearchComponent#finishStage(ResponseBuilder)}. */
DECL|method|distribFinish
specifier|public
specifier|static
name|NamedList
name|distribFinish
parameter_list|(
name|LinkedHashMap
argument_list|<
name|String
argument_list|,
name|HeatmapFacet
argument_list|>
name|heatmapInfos
parameter_list|,
name|ResponseBuilder
name|rb
parameter_list|)
block|{
name|NamedList
argument_list|<
name|NamedList
argument_list|<
name|Object
argument_list|>
argument_list|>
name|result
init|=
operator|new
name|SimpleOrderedMap
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|HeatmapFacet
argument_list|>
name|entry
range|:
name|heatmapInfos
operator|.
name|entrySet
argument_list|()
control|)
block|{
specifier|final
name|HeatmapFacet
name|facet
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
specifier|final
name|NamedList
argument_list|<
name|Object
argument_list|>
name|namedList
init|=
name|facet
operator|.
name|namedList
decl_stmt|;
if|if
condition|(
name|namedList
operator|==
literal|null
condition|)
block|{
continue|continue;
comment|//should never happen but play it safe
block|}
name|formatCountsAndAddToNL
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|rb
argument_list|,
name|SolrParams
operator|.
name|wrapDefaults
argument_list|(
name|facet
operator|.
name|localParams
argument_list|,
name|rb
operator|.
name|req
operator|.
name|getParams
argument_list|()
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|namedList
operator|.
name|get
argument_list|(
literal|"columns"
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|namedList
operator|.
name|get
argument_list|(
literal|"rows"
argument_list|)
argument_list|,
name|facet
operator|.
name|counts
argument_list|,
name|namedList
argument_list|)
expr_stmt|;
name|result
operator|.
name|add
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|namedList
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
comment|/** Goes in {@link org.apache.solr.handler.component.FacetComponent.FacetInfo#heatmapFacets}, created by    * {@link #distribParse(org.apache.solr.common.params.SolrParams, ResponseBuilder)}. */
DECL|class|HeatmapFacet
specifier|public
specifier|static
class|class
name|HeatmapFacet
extends|extends
name|FacetComponent
operator|.
name|FacetBase
block|{
comment|//note: 'public' following-suit with FacetBase& existing subclasses... though should this really be?
comment|//Holds response NamedList for this field, with counts pulled out. Taken from 1st shard response.
DECL|field|namedList
specifier|public
name|NamedList
argument_list|<
name|Object
argument_list|>
name|namedList
decl_stmt|;
comment|//Like Heatmap.counts in Lucene spatial, although null if it would be all-0.
DECL|field|counts
specifier|public
name|int
index|[]
name|counts
decl_stmt|;
DECL|method|HeatmapFacet
specifier|public
name|HeatmapFacet
parameter_list|(
name|ResponseBuilder
name|rb
parameter_list|,
name|String
name|facetStr
parameter_list|)
block|{
name|super
argument_list|(
name|rb
argument_list|,
name|FacetParams
operator|.
name|FACET_HEATMAP
argument_list|,
name|facetStr
argument_list|)
expr_stmt|;
comment|//note: logic in super (FacetBase) is partially redundant with SimpleFacet.parseParams :-(
block|}
block|}
comment|//
comment|// PngHelper
comment|//
comment|//package access for tests
DECL|class|PngHelper
specifier|static
class|class
name|PngHelper
block|{
DECL|field|imageReaderSpi
specifier|static
specifier|final
name|ImageReaderSpi
name|imageReaderSpi
decl_stmt|;
comment|//thread-safe
static|static
block|{
specifier|final
name|Iterator
argument_list|<
name|ImageReader
argument_list|>
name|imageReaders
init|=
name|ImageIO
operator|.
name|getImageReadersByFormatName
argument_list|(
literal|"png"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|imageReaders
operator|.
name|hasNext
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|SolrException
operator|.
name|ErrorCode
operator|.
name|SERVER_ERROR
argument_list|,
literal|"Can't find png image reader, neaded for heatmaps!"
argument_list|)
throw|;
block|}
name|ImageReader
name|imageReader
init|=
name|imageReaders
operator|.
name|next
argument_list|()
decl_stmt|;
name|imageReaderSpi
operator|=
name|imageReader
operator|.
name|getOriginatingProvider
argument_list|()
expr_stmt|;
block|}
DECL|method|readImage
specifier|static
name|BufferedImage
name|readImage
parameter_list|(
specifier|final
name|byte
index|[]
name|bytes
parameter_list|)
block|{
comment|// Wrap ImageInputStream around the bytes.  We could use MemoryCacheImageInputStream but it will
comment|// cache the data which is quite unnecessary given we have it all in-memory already.
name|ImageInputStream
name|imageInputStream
init|=
operator|new
name|ImageInputStreamImpl
argument_list|()
block|{
comment|//TODO re-use this instance; superclass has 8KB buffer.
annotation|@
name|Override
specifier|public
name|int
name|read
parameter_list|()
throws|throws
name|IOException
block|{
name|checkClosed
argument_list|()
expr_stmt|;
name|bitOffset
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|streamPos
operator|>=
name|bytes
operator|.
name|length
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
else|else
block|{
return|return
name|bytes
index|[
operator|(
name|int
operator|)
name|streamPos
operator|++
index|]
return|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|int
name|read
parameter_list|(
name|byte
index|[]
name|b
parameter_list|,
name|int
name|off
parameter_list|,
name|int
name|len
parameter_list|)
throws|throws
name|IOException
block|{
name|checkClosed
argument_list|()
expr_stmt|;
name|bitOffset
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|streamPos
operator|>=
name|bytes
operator|.
name|length
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
else|else
block|{
name|int
name|copyLen
init|=
name|Math
operator|.
name|min
argument_list|(
name|len
argument_list|,
name|bytes
operator|.
name|length
operator|-
operator|(
name|int
operator|)
name|streamPos
argument_list|)
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|bytes
argument_list|,
operator|(
name|int
operator|)
name|streamPos
argument_list|,
name|b
argument_list|,
name|off
argument_list|,
name|copyLen
argument_list|)
expr_stmt|;
name|streamPos
operator|+=
name|copyLen
expr_stmt|;
return|return
name|copyLen
return|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|long
name|length
parameter_list|()
block|{
return|return
name|bytes
operator|.
name|length
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|isCached
parameter_list|()
block|{
return|return
literal|true
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|isCachedMemory
parameter_list|()
block|{
return|return
literal|true
return|;
block|}
block|}
decl_stmt|;
try|try
block|{
comment|//TODO can/should we re-use an imageReader instance on FacetInfo?
name|ImageReader
name|imageReader
init|=
name|imageReaderSpi
operator|.
name|createReaderInstance
argument_list|()
decl_stmt|;
name|imageReader
operator|.
name|setInput
argument_list|(
name|imageInputStream
argument_list|,
literal|false
argument_list|,
comment|//forwardOnly
literal|true
argument_list|)
expr_stmt|;
comment|//ignoreMetadata
return|return
name|imageReader
operator|.
name|read
argument_list|(
literal|0
argument_list|)
return|;
comment|//read first& only image
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|SolrException
operator|.
name|ErrorCode
operator|.
name|SERVER_ERROR
argument_list|,
literal|"Problem reading png heatmap: "
operator|+
name|e
argument_list|)
throw|;
block|}
block|}
DECL|method|writeImage
specifier|static
name|byte
index|[]
name|writeImage
parameter_list|(
name|BufferedImage
name|image
parameter_list|)
block|{
name|ByteArrayOutputStream
name|baos
init|=
operator|new
name|ByteArrayOutputStream
argument_list|(
comment|// initialize to roughly 1/4th the size a native int would take per-pixel
name|image
operator|.
name|getWidth
argument_list|()
operator|*
name|image
operator|.
name|getHeight
argument_list|()
operator|+
literal|1024
argument_list|)
decl_stmt|;
try|try
block|{
name|ImageIO
operator|.
name|write
argument_list|(
name|image
argument_list|,
name|FORMAT_PNG
argument_list|,
name|baos
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|SolrException
operator|.
name|ErrorCode
operator|.
name|SERVER_ERROR
argument_list|,
literal|"While generating PNG: "
operator|+
name|e
argument_list|)
throw|;
block|}
comment|//too bad we can't access the raw byte[]; this copies to a new one
return|return
name|baos
operator|.
name|toByteArray
argument_list|()
return|;
block|}
comment|// We abuse the image for storing integers (4 bytes), and so we need a 4-byte ABGR.
comment|// first (low) byte is blue, next byte is green, next byte red, and last (high) byte is alpha.
DECL|method|newImage
specifier|static
name|BufferedImage
name|newImage
parameter_list|(
name|int
name|columns
parameter_list|,
name|int
name|rows
parameter_list|)
block|{
return|return
operator|new
name|BufferedImage
argument_list|(
name|columns
argument_list|,
name|rows
argument_list|,
name|BufferedImage
operator|.
name|TYPE_4BYTE_ABGR
argument_list|)
return|;
block|}
comment|// 'y' dimension goes top-down, so invert.
comment|// Alpha chanel is high byte; 0 means transparent. So XOR those bits with '1' so that we need
comment|//  to have counts> 16M before the picture starts to fade
DECL|method|writeCountAtColumnRow
specifier|static
name|void
name|writeCountAtColumnRow
parameter_list|(
name|BufferedImage
name|image
parameter_list|,
name|int
name|rows
parameter_list|,
name|int
name|c
parameter_list|,
name|int
name|r
parameter_list|,
name|int
name|val
parameter_list|)
block|{
name|image
operator|.
name|setRGB
argument_list|(
name|c
argument_list|,
name|rows
operator|-
literal|1
operator|-
name|r
argument_list|,
name|val
operator|^
literal|0xFF_00_00_00
argument_list|)
expr_stmt|;
block|}
DECL|method|getCountAtColumnRow
specifier|static
name|int
name|getCountAtColumnRow
parameter_list|(
name|BufferedImage
name|image
parameter_list|,
name|int
name|rows
parameter_list|,
name|int
name|c
parameter_list|,
name|int
name|r
parameter_list|)
block|{
return|return
name|image
operator|.
name|getRGB
argument_list|(
name|c
argument_list|,
name|rows
operator|-
literal|1
operator|-
name|r
argument_list|)
operator|^
literal|0xFF_00_00_00
return|;
block|}
block|}
block|}
end_class
end_unit
