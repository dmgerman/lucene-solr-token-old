begin_unit
begin_package
DECL|package|org.apache.solr.core
package|package
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|core
package|;
end_package
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|io
operator|.
name|IOUtils
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|lang
operator|.
name|StringUtils
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|cloud
operator|.
name|ZkController
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|SolrException
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|util
operator|.
name|NamedList
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|handler
operator|.
name|component
operator|.
name|HttpShardHandlerFactory
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|handler
operator|.
name|component
operator|.
name|ShardHandlerFactory
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|util
operator|.
name|PropertiesUtil
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|util
operator|.
name|SystemIdResolver
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|util
operator|.
name|plugin
operator|.
name|PluginInfoInitialized
import|;
end_import
begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import
begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import
begin_import
import|import
name|org
operator|.
name|xml
operator|.
name|sax
operator|.
name|InputSource
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ByteArrayInputStream
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileInputStream
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileOutputStream
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStream
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Properties
import|;
end_import
begin_comment
comment|/**  * This is the new way of dealing with solr properties replacing solr.xml. This is simply a high-level set of  * properties. Cores are no longer defined in the solr.xml file, they are discovered by enumerating all of the  * directories under the base path and creating cores as necessary.  *  * @since Solr 4.2  */
end_comment
begin_class
DECL|class|SolrProperties
specifier|public
class|class
name|SolrProperties
implements|implements
name|ConfigSolr
block|{
DECL|field|SOLR_PROPERTIES_FILE
specifier|public
specifier|final
specifier|static
name|String
name|SOLR_PROPERTIES_FILE
init|=
literal|"solr.properties"
decl_stmt|;
DECL|field|SOLR_XML_FILE
specifier|public
specifier|final
specifier|static
name|String
name|SOLR_XML_FILE
init|=
literal|"solr.xml"
decl_stmt|;
DECL|field|CORE_PROP_FILE
specifier|final
specifier|static
name|String
name|CORE_PROP_FILE
init|=
literal|"core.properties"
decl_stmt|;
DECL|field|SHARD_HANDLER_FACTORY
specifier|private
specifier|final
specifier|static
name|String
name|SHARD_HANDLER_FACTORY
init|=
literal|"shardHandlerFactory"
decl_stmt|;
DECL|field|SHARD_HANDLER_NAME
specifier|private
specifier|final
specifier|static
name|String
name|SHARD_HANDLER_NAME
init|=
name|SHARD_HANDLER_FACTORY
operator|+
literal|".name"
decl_stmt|;
DECL|field|SHARD_HANDLER_CLASS
specifier|private
specifier|final
specifier|static
name|String
name|SHARD_HANDLER_CLASS
init|=
name|SHARD_HANDLER_FACTORY
operator|+
literal|".class"
decl_stmt|;
DECL|field|log
specifier|public
specifier|static
specifier|final
name|Logger
name|log
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|SolrProperties
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|container
specifier|protected
specifier|final
name|CoreContainer
name|container
decl_stmt|;
DECL|field|solrProperties
specifier|protected
name|Properties
name|solrProperties
init|=
operator|new
name|Properties
argument_list|()
decl_stmt|;
DECL|field|origsolrprops
specifier|protected
specifier|final
name|Properties
name|origsolrprops
init|=
operator|new
name|Properties
argument_list|()
decl_stmt|;
DECL|field|name
specifier|protected
name|String
name|name
decl_stmt|;
DECL|field|loader
specifier|protected
name|SolrResourceLoader
name|loader
decl_stmt|;
DECL|field|coreDescriptorPlusMap
specifier|private
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|CoreDescriptorPlus
argument_list|>
name|coreDescriptorPlusMap
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|CoreDescriptorPlus
argument_list|>
argument_list|()
decl_stmt|;
DECL|field|prefixesprefixes
specifier|private
specifier|static
name|Map
argument_list|<
name|ConfLevel
argument_list|,
name|String
argument_list|>
name|prefixesprefixes
decl_stmt|;
static|static
block|{
name|prefixesprefixes
operator|=
operator|new
name|HashMap
argument_list|<
name|ConfLevel
argument_list|,
name|String
argument_list|>
argument_list|()
expr_stmt|;
name|prefixesprefixes
operator|.
name|put
argument_list|(
name|ConfLevel
operator|.
name|SOLR_CORES
argument_list|,
literal|"cores."
argument_list|)
expr_stmt|;
name|prefixesprefixes
operator|.
name|put
argument_list|(
name|ConfLevel
operator|.
name|SOLR_LOGGING
argument_list|,
literal|"logging."
argument_list|)
expr_stmt|;
name|prefixesprefixes
operator|.
name|put
argument_list|(
name|ConfLevel
operator|.
name|SOLR_LOGGING_WATCHER
argument_list|,
literal|"logging.watcher."
argument_list|)
expr_stmt|;
block|}
comment|/**    * Create a SolrProperties object given just the resource loader    *    * @param container - the container for this Solr instance. There should be one and only one...    * @param loader    - Solr resource loader    * @param solrCfg   - a config file whose values will be transferred to the properties object that can be changed    * @throws IOException - It's possible to walk a very deep tree, if that process goes awry, or if reading any    *                     of the files found doesn't work, you'll get an IO exception    */
DECL|method|SolrProperties
name|SolrProperties
parameter_list|(
name|CoreContainer
name|container
parameter_list|,
name|SolrResourceLoader
name|loader
parameter_list|,
name|SolrProperties
name|solrCfg
parameter_list|)
throws|throws
name|IOException
block|{
name|origsolrprops
operator|.
name|putAll
argument_list|(
name|solrCfg
operator|.
name|getOriginalProperties
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|loader
operator|=
name|loader
expr_stmt|;
name|this
operator|.
name|container
operator|=
name|container
expr_stmt|;
name|init
argument_list|(
name|solrCfg
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
comment|/**    * Create a SolrProperties object from an opened input stream, useful for creating defaults    *    * @param container - the container for this Solr instance. There should be one and only one...    * @param loader    - Solr resource loader    * @param is        - Input stream for loading properties.    * @param fileName  - the name for this properties object.    * @throws IOException - It's possible to walk a very deep tree, if that process goes awry, or if reading any    *                     of the files found doesn't work, you'll get an IO exception    */
DECL|method|SolrProperties
specifier|public
name|SolrProperties
parameter_list|(
name|CoreContainer
name|container
parameter_list|,
name|SolrResourceLoader
name|loader
parameter_list|,
name|InputStream
name|is
parameter_list|,
name|String
name|fileName
parameter_list|)
throws|throws
name|IOException
block|{
name|origsolrprops
operator|.
name|load
argument_list|(
name|is
argument_list|)
expr_stmt|;
name|this
operator|.
name|loader
operator|=
name|loader
expr_stmt|;
name|this
operator|.
name|container
operator|=
name|container
expr_stmt|;
name|init
argument_list|(
name|fileName
argument_list|)
expr_stmt|;
block|}
comment|//Just localize the common constructor operations
DECL|method|init
specifier|private
name|void
name|init
parameter_list|(
name|String
name|name
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|name
operator|=
name|name
expr_stmt|;
for|for
control|(
name|String
name|s
range|:
name|origsolrprops
operator|.
name|stringPropertyNames
argument_list|()
control|)
block|{
name|solrProperties
operator|.
name|put
argument_list|(
name|s
argument_list|,
name|System
operator|.
name|getProperty
argument_list|(
name|s
argument_list|,
name|origsolrprops
operator|.
name|getProperty
argument_list|(
name|s
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
synchronized|synchronized
init|(
name|coreDescriptorPlusMap
init|)
block|{
name|walkFromHere
argument_list|(
operator|new
name|File
argument_list|(
name|container
operator|.
name|getSolrHome
argument_list|()
argument_list|)
argument_list|,
name|container
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Just localizes default substitution and the ability to log an error if the value isn't present.
DECL|method|getVal
specifier|private
name|String
name|getVal
parameter_list|(
name|String
name|path
parameter_list|,
name|boolean
name|errIfMissing
parameter_list|,
name|String
name|defVal
parameter_list|)
block|{
name|String
name|val
init|=
name|solrProperties
operator|.
name|getProperty
argument_list|(
name|path
argument_list|,
name|defVal
argument_list|)
decl_stmt|;
if|if
condition|(
name|StringUtils
operator|.
name|isNotBlank
argument_list|(
name|val
argument_list|)
condition|)
block|{
name|log
operator|.
name|debug
argument_list|(
name|name
operator|+
literal|' '
operator|+
name|path
operator|+
name|val
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
if|if
condition|(
operator|!
name|errIfMissing
condition|)
block|{
name|log
operator|.
name|debug
argument_list|(
name|name
operator|+
literal|"missing optional "
operator|+
name|path
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|name
operator|+
literal|" missing "
operator|+
name|path
argument_list|)
throw|;
block|}
comment|/**    * Get a property and convert it to a boolean value. Does not log a message if the value is absent    *    * @param prop     - name of the property to fetch    * @param defValue - value to return if the property is absent    * @return property value or default if property is not present.    */
DECL|method|getBool
specifier|public
name|boolean
name|getBool
parameter_list|(
name|String
name|prop
parameter_list|,
name|boolean
name|defValue
parameter_list|)
block|{
name|String
name|def
init|=
name|defValue
condition|?
literal|"true"
else|:
literal|"false"
decl_stmt|;
name|String
name|val
init|=
name|getVal
argument_list|(
name|prop
argument_list|,
literal|false
argument_list|,
name|def
argument_list|)
decl_stmt|;
return|return
operator|(
name|StringUtils
operator|.
name|equalsIgnoreCase
argument_list|(
name|val
argument_list|,
literal|"true"
argument_list|)
operator|)
return|;
block|}
comment|/**    * Fetch a string value, for the given property. Does not log a message if the valued is absent.    *    * @param prop - the property name to fetch    * @param def  - the default value to return if not present    * @return - the fetched property or the default value if the property is absent    */
DECL|method|get
specifier|public
name|String
name|get
parameter_list|(
name|String
name|prop
parameter_list|,
name|String
name|def
parameter_list|)
block|{
name|String
name|val
init|=
name|getVal
argument_list|(
name|prop
argument_list|,
literal|false
argument_list|,
name|def
argument_list|)
decl_stmt|;
if|if
condition|(
name|val
operator|==
literal|null
operator|||
name|val
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
name|def
return|;
block|}
return|return
name|val
return|;
block|}
comment|/**    * Fetch the string value of the property. May log a message and returns null if absent    *    * @param prop         - the name of the property to fetch    * @param errIfMissing - if true, log a message that the property is not present    * @return - the property value or null if absent    */
DECL|method|getVal
specifier|public
name|String
name|getVal
parameter_list|(
name|String
name|prop
parameter_list|,
name|boolean
name|errIfMissing
parameter_list|)
block|{
return|return
name|getVal
argument_list|(
name|prop
argument_list|,
name|errIfMissing
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/**    * Returns a property as an integer    *    * @param prop   - the name of the property to fetch    * @param defVal - the value to return if the property is missing    * @return - the fetch property as an int or the def value if absent    */
DECL|method|getInt
specifier|public
name|int
name|getInt
parameter_list|(
name|String
name|prop
parameter_list|,
name|int
name|defVal
parameter_list|)
block|{
name|String
name|val
init|=
name|getVal
argument_list|(
name|prop
argument_list|,
literal|false
argument_list|,
name|Integer
operator|.
name|toString
argument_list|(
name|defVal
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|Integer
operator|.
name|parseInt
argument_list|(
name|val
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|getInt
specifier|public
name|int
name|getInt
parameter_list|(
name|ConfLevel
name|level
parameter_list|,
name|String
name|tag
parameter_list|,
name|int
name|def
parameter_list|)
block|{
return|return
name|getInt
argument_list|(
name|prefixesprefixes
operator|.
name|get
argument_list|(
name|level
argument_list|)
operator|+
name|tag
argument_list|,
name|def
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|getBool
specifier|public
name|boolean
name|getBool
parameter_list|(
name|ConfLevel
name|level
parameter_list|,
name|String
name|tag
parameter_list|,
name|boolean
name|defValue
parameter_list|)
block|{
return|return
name|getBool
argument_list|(
name|prefixesprefixes
operator|.
name|get
argument_list|(
name|level
argument_list|)
operator|+
name|tag
argument_list|,
name|defValue
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|get
specifier|public
name|String
name|get
parameter_list|(
name|ConfLevel
name|level
parameter_list|,
name|String
name|tag
parameter_list|,
name|String
name|def
parameter_list|)
block|{
return|return
name|get
argument_list|(
name|prefixesprefixes
operator|.
name|get
argument_list|(
name|level
argument_list|)
operator|+
name|tag
argument_list|,
name|def
argument_list|)
return|;
block|}
comment|/**    * For all values in the properties structure, find if any system properties are defined and substitute them.    */
DECL|method|substituteProperties
specifier|public
name|void
name|substituteProperties
parameter_list|()
block|{
for|for
control|(
name|String
name|prop
range|:
name|solrProperties
operator|.
name|stringPropertyNames
argument_list|()
control|)
block|{
name|String
name|subProp
init|=
name|PropertiesUtil
operator|.
name|substituteProperty
argument_list|(
name|solrProperties
operator|.
name|getProperty
argument_list|(
name|prop
argument_list|)
argument_list|,
name|solrProperties
argument_list|)
decl_stmt|;
if|if
condition|(
name|subProp
operator|!=
literal|null
operator|&&
operator|!
name|subProp
operator|.
name|equals
argument_list|(
name|solrProperties
operator|.
name|getProperty
argument_list|(
name|prop
argument_list|)
argument_list|)
condition|)
block|{
name|solrProperties
operator|.
name|put
argument_list|(
name|prop
argument_list|,
name|subProp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Fetches the properties as originally read from the properties file without any system variable substitution    *    * @return - a copy of the original properties.    */
DECL|method|getOriginalProperties
specifier|public
name|Properties
name|getOriginalProperties
parameter_list|()
block|{
name|Properties
name|ret
init|=
operator|new
name|Properties
argument_list|()
decl_stmt|;
name|ret
operator|.
name|putAll
argument_list|(
name|origsolrprops
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
annotation|@
name|Override
DECL|method|initShardHandler
specifier|public
name|ShardHandlerFactory
name|initShardHandler
parameter_list|(
comment|/*boolean isTest*/
parameter_list|)
block|{
name|PluginInfo
name|info
init|=
literal|null
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|attrs
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|NamedList
name|args
init|=
operator|new
name|NamedList
argument_list|()
decl_stmt|;
name|boolean
name|haveHandler
init|=
literal|false
decl_stmt|;
for|for
control|(
name|String
name|s
range|:
name|solrProperties
operator|.
name|stringPropertyNames
argument_list|()
control|)
block|{
name|String
name|val
init|=
name|solrProperties
operator|.
name|getProperty
argument_list|(
name|s
argument_list|)
decl_stmt|;
name|int
name|index
init|=
name|s
operator|.
name|indexOf
argument_list|(
name|SHARD_HANDLER_FACTORY
argument_list|)
decl_stmt|;
if|if
condition|(
name|index
operator|!=
operator|-
literal|1
condition|)
block|{
name|haveHandler
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|SHARD_HANDLER_NAME
operator|.
name|equals
argument_list|(
name|s
argument_list|)
operator|||
name|SHARD_HANDLER_CLASS
operator|.
name|equals
argument_list|(
name|s
argument_list|)
condition|)
block|{
comment|// remove shardHandlerFactory. prefix
name|attrs
operator|.
name|put
argument_list|(
name|s
operator|.
name|substring
argument_list|(
name|SHARD_HANDLER_FACTORY
operator|.
name|length
argument_list|()
operator|+
literal|1
argument_list|)
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// remove shardHandlerFactory. prefix
name|args
operator|.
name|add
argument_list|(
name|s
operator|.
name|substring
argument_list|(
name|SHARD_HANDLER_FACTORY
operator|.
name|length
argument_list|()
operator|+
literal|1
argument_list|)
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|haveHandler
condition|)
block|{
name|info
operator|=
operator|new
name|PluginInfo
argument_list|(
name|SHARD_HANDLER_FACTORY
argument_list|,
name|attrs
argument_list|,
name|args
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Map
name|m
init|=
operator|new
name|HashMap
argument_list|()
decl_stmt|;
name|m
operator|.
name|put
argument_list|(
literal|"class"
argument_list|,
name|HttpShardHandlerFactory
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|info
operator|=
operator|new
name|PluginInfo
argument_list|(
literal|"shardHandlerFactory"
argument_list|,
name|m
argument_list|,
literal|null
argument_list|,
name|Collections
operator|.
expr|<
name|PluginInfo
operator|>
name|emptyList
argument_list|()
argument_list|)
expr_stmt|;
block|}
assert|assert
name|loader
operator|!=
literal|null
assert|;
name|ShardHandlerFactory
name|fac
decl_stmt|;
try|try
block|{
name|fac
operator|=
name|loader
operator|.
name|findClass
argument_list|(
name|info
operator|.
name|className
argument_list|,
name|ShardHandlerFactory
operator|.
name|class
argument_list|)
operator|.
name|newInstance
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|SolrException
operator|.
name|ErrorCode
operator|.
name|SERVER_ERROR
argument_list|,
name|e
argument_list|)
throw|;
block|}
if|if
condition|(
name|fac
operator|instanceof
name|PluginInfoInitialized
condition|)
block|{
operator|(
operator|(
name|PluginInfoInitialized
operator|)
name|fac
operator|)
operator|.
name|init
argument_list|(
name|info
argument_list|)
expr_stmt|;
block|}
return|return
name|fac
return|;
block|}
comment|// Strictly for compatibility with i'face. TODO: remove for 5.0
annotation|@
name|Override
DECL|method|getSolrProperties
specifier|public
name|Properties
name|getSolrProperties
parameter_list|(
name|ConfigSolr
name|cfg
parameter_list|,
name|String
name|context
parameter_list|)
block|{
return|return
name|getSolrProperties
argument_list|()
return|;
block|}
comment|/**    * Return the original properties that were defined, without substitutions from solr.properties    *    * @return - the Properties as originally defined.    */
DECL|method|getSolrProperties
specifier|public
name|Properties
name|getSolrProperties
parameter_list|()
block|{
return|return
name|solrProperties
return|;
block|}
comment|/**    * given a core and attributes, find the core.properties file from whence it came and update it with the current    *<p/>    * Note, when the cores were discovered, we stored away the path that it came from for reference later. Remember    * that these cores aren't necessarily loaded all the time, they may be transient.    * It's not clear what the magic is that the calling methods (see CoreContainer) are doing, but they seem to be    * "doing the right thing" so that the attribs properties are the ones that contain the correct data. All the    * tests pass, but it's magic at this point.    *    * @param coreName - the core whose attributes we are to change    * @param attribs  - the attribs to change to, see note above.    * @param props    - ignored, here to make the i'face work in combination with ConfigSolrXmlBackCompat    */
annotation|@
name|Override
DECL|method|addPersistCore
specifier|public
name|void
name|addPersistCore
parameter_list|(
name|String
name|coreName
parameter_list|,
name|Properties
name|attribs
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|props
parameter_list|)
block|{
name|String
name|val
init|=
name|container
operator|.
name|getContainerProperties
argument_list|()
operator|.
name|getProperty
argument_list|(
literal|"solr.persistent"
argument_list|,
literal|"false"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|Boolean
operator|.
name|parseBoolean
argument_list|(
name|val
argument_list|)
condition|)
return|return;
name|CoreDescriptorPlus
name|plus
decl_stmt|;
name|plus
operator|=
name|coreDescriptorPlusMap
operator|.
name|get
argument_list|(
name|coreName
argument_list|)
expr_stmt|;
if|if
condition|(
name|plus
operator|==
literal|null
condition|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"Expected to find core for persisting, but we did not. Core: "
operator|+
name|coreName
argument_list|)
expr_stmt|;
return|return;
block|}
name|Properties
name|outProps
init|=
operator|new
name|Properties
argument_list|()
decl_stmt|;
comment|// I don't quite get this, but somehow the attribs passed in are the originals (plus any newly-added ones). Never
comment|// one to look a gift horse in the mouth I'll just use that.
comment|// Take care NOT to write out properties like ${blah blah blah}
name|outProps
operator|.
name|putAll
argument_list|(
name|attribs
argument_list|)
expr_stmt|;
name|Properties
name|corePropsOrig
init|=
name|plus
operator|.
name|getPropsOrig
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|prop
range|:
name|corePropsOrig
operator|.
name|stringPropertyNames
argument_list|()
control|)
block|{
name|val
operator|=
name|corePropsOrig
operator|.
name|getProperty
argument_list|(
name|prop
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|.
name|indexOf
argument_list|(
literal|"$"
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
comment|// it was originally a system property, keep it so
name|outProps
operator|.
name|put
argument_list|(
name|prop
argument_list|,
name|val
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|// Make sure anything that used to be in the properties file still is.
if|if
condition|(
name|outProps
operator|.
name|getProperty
argument_list|(
name|prop
argument_list|)
operator|==
literal|null
condition|)
block|{
name|outProps
operator|.
name|put
argument_list|(
name|prop
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Any of our standard properties that weren't in the original properties file should NOT be persisted, I think
for|for
control|(
name|String
name|prop
range|:
name|CoreDescriptor
operator|.
name|standardPropNames
control|)
block|{
if|if
condition|(
name|corePropsOrig
operator|.
name|getProperty
argument_list|(
name|prop
argument_list|)
operator|==
literal|null
condition|)
block|{
name|outProps
operator|.
name|remove
argument_list|(
name|prop
argument_list|)
expr_stmt|;
block|}
block|}
name|OutputStream
name|os
init|=
literal|null
decl_stmt|;
try|try
block|{
name|os
operator|=
operator|new
name|FileOutputStream
argument_list|(
name|plus
operator|.
name|getFilePath
argument_list|()
argument_list|)
expr_stmt|;
name|outProps
operator|.
name|store
argument_list|(
name|os
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"Failed to persist core {}, filepath {}"
argument_list|,
name|coreName
argument_list|,
name|plus
operator|.
name|getFilePath
argument_list|()
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|IOUtils
operator|.
name|closeQuietly
argument_list|(
name|os
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * PersistSolrProperties persists the Solr.properties file only,    *<p/>    * The old version (i.e. using solr.xml) persisted _everything_ in a single file. This version will just    * persist the solr.properties file for an individual core.    * The individual cores were persisted in addPersistCore calls above.    */
comment|// It seems like a lot of this could be done by using the Properties defaults
comment|/**    * PersistSolrProperties persists the Solr.properties file only,    *<p/>    * The old version (i.e. using solr.xml) persisted _everything_ in a single file. This version will just    * persist the solr.properties file for an individual core.    * The individual cores were persisted in addPersistCore calls above.    *<p/>    * TODO: Remove all parameters for 5.0 when we obsolete ConfigSolrXmlBackCompat    *    * @param containerProperties - ignored, here for back compat.    * @param rootSolrAttribs     - ignored, here for back compat.    * @param coresAttribs        - ignored, here for back compat.    * @param file                - ignored, here for back compat.    */
annotation|@
name|Override
DECL|method|addPersistAllCores
specifier|public
name|void
name|addPersistAllCores
parameter_list|(
name|Properties
name|containerProperties
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|rootSolrAttribs
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|coresAttribs
parameter_list|,
name|File
name|file
parameter_list|)
block|{
name|String
name|val
init|=
name|container
operator|.
name|getContainerProperties
argument_list|()
operator|.
name|getProperty
argument_list|(
literal|"solr.persistent"
argument_list|,
literal|"false"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|Boolean
operator|.
name|parseBoolean
argument_list|(
name|val
argument_list|)
condition|)
return|return;
comment|// First persist solr.properties
name|File
name|parent
init|=
operator|new
name|File
argument_list|(
name|container
operator|.
name|getSolrHome
argument_list|()
argument_list|)
decl_stmt|;
name|File
name|props
init|=
operator|new
name|File
argument_list|(
name|parent
argument_list|,
name|SOLR_PROPERTIES_FILE
argument_list|)
decl_stmt|;
name|Properties
name|propsOut
init|=
operator|new
name|Properties
argument_list|()
decl_stmt|;
name|propsOut
operator|.
name|putAll
argument_list|(
name|container
operator|.
name|getContainerProperties
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|String
name|prop
range|:
name|origsolrprops
operator|.
name|stringPropertyNames
argument_list|()
control|)
block|{
name|String
name|toTest
init|=
name|origsolrprops
operator|.
name|getProperty
argument_list|(
name|prop
argument_list|)
decl_stmt|;
if|if
condition|(
name|toTest
operator|.
name|indexOf
argument_list|(
literal|"$"
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
comment|// Don't store away things that should be system properties
name|propsOut
operator|.
name|put
argument_list|(
name|prop
argument_list|,
name|toTest
argument_list|)
expr_stmt|;
block|}
block|}
name|OutputStream
name|os
init|=
literal|null
decl_stmt|;
try|try
block|{
name|os
operator|=
operator|new
name|FileOutputStream
argument_list|(
name|props
argument_list|)
expr_stmt|;
name|propsOut
operator|.
name|store
argument_list|(
name|os
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"Failed to persist file "
operator|+
name|props
operator|.
name|getAbsolutePath
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|IOUtils
operator|.
name|closeQuietly
argument_list|(
name|os
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Copied verbatim from the old code, presumably this will be tested when we eliminate solr.xml
annotation|@
name|Override
DECL|method|getSolrConfigFromZk
specifier|public
name|SolrConfig
name|getSolrConfigFromZk
parameter_list|(
name|ZkController
name|zkController
parameter_list|,
name|String
name|zkConfigName
parameter_list|,
name|String
name|solrConfigFileName
parameter_list|,
name|SolrResourceLoader
name|resourceLoader
parameter_list|)
block|{
name|SolrConfig
name|cfg
init|=
literal|null
decl_stmt|;
try|try
block|{
name|byte
index|[]
name|config
init|=
name|zkController
operator|.
name|getConfigFileData
argument_list|(
name|zkConfigName
argument_list|,
name|solrConfigFileName
argument_list|)
decl_stmt|;
name|InputSource
name|is
init|=
operator|new
name|InputSource
argument_list|(
operator|new
name|ByteArrayInputStream
argument_list|(
name|config
argument_list|)
argument_list|)
decl_stmt|;
name|is
operator|.
name|setSystemId
argument_list|(
name|SystemIdResolver
operator|.
name|createSystemIdFromResourceName
argument_list|(
name|solrConfigFileName
argument_list|)
argument_list|)
expr_stmt|;
name|cfg
operator|=
name|solrConfigFileName
operator|==
literal|null
condition|?
operator|new
name|SolrConfig
argument_list|(
name|resourceLoader
argument_list|,
name|SolrConfig
operator|.
name|DEFAULT_CONF_FILE
argument_list|,
name|is
argument_list|)
else|:
operator|new
name|SolrConfig
argument_list|(
name|resourceLoader
argument_list|,
name|solrConfigFileName
argument_list|,
name|is
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|SolrException
operator|.
name|ErrorCode
operator|.
name|SERVER_ERROR
argument_list|,
literal|"getSolrConfigFromZK failed for "
operator|+
name|zkConfigName
operator|+
literal|" "
operator|+
name|solrConfigFileName
argument_list|,
name|e
argument_list|)
throw|;
block|}
return|return
name|cfg
return|;
block|}
annotation|@
name|Override
DECL|method|initPersist
specifier|public
name|void
name|initPersist
parameter_list|()
block|{
comment|//NOOP
block|}
comment|// Basic recursive tree walking, looking for "core.properties" files. Once one is found, we'll stop going any
comment|// deeper in the tree.
comment|//
comment|// @param file - the directory we're to either read the properties file from or recurse into.
DECL|method|walkFromHere
specifier|private
name|void
name|walkFromHere
parameter_list|(
name|File
name|file
parameter_list|,
name|CoreContainer
name|container
parameter_list|)
throws|throws
name|IOException
block|{
name|log
operator|.
name|info
argument_list|(
literal|"Looking for cores in "
operator|+
name|file
operator|.
name|getAbsolutePath
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|File
name|childFile
range|:
name|file
operator|.
name|listFiles
argument_list|()
control|)
block|{
comment|// This is a little tricky, we are asking if core.properties exists in a child directory of the directory passed
comment|// in. In other words we're looking for core.properties in the grandchild directories of the parameter passed
comment|// in. That allows us to gracefully top recursing deep but continue looking wide.
name|File
name|propFile
init|=
operator|new
name|File
argument_list|(
name|childFile
argument_list|,
name|CORE_PROP_FILE
argument_list|)
decl_stmt|;
if|if
condition|(
name|propFile
operator|.
name|exists
argument_list|()
condition|)
block|{
comment|// Stop looking after processing this file!
name|log
operator|.
name|info
argument_list|(
literal|"Discovered properties file {}, adding to cores"
argument_list|,
name|propFile
operator|.
name|getAbsolutePath
argument_list|()
argument_list|)
expr_stmt|;
name|Properties
name|propsOrig
init|=
operator|new
name|Properties
argument_list|()
decl_stmt|;
name|InputStream
name|is
init|=
operator|new
name|FileInputStream
argument_list|(
name|propFile
argument_list|)
decl_stmt|;
try|try
block|{
name|propsOrig
operator|.
name|load
argument_list|(
name|is
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|IOUtils
operator|.
name|closeQuietly
argument_list|(
name|is
argument_list|)
expr_stmt|;
block|}
name|Properties
name|props
init|=
operator|new
name|Properties
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|prop
range|:
name|propsOrig
operator|.
name|stringPropertyNames
argument_list|()
control|)
block|{
name|props
operator|.
name|put
argument_list|(
name|prop
argument_list|,
name|PropertiesUtil
operator|.
name|substituteProperty
argument_list|(
name|propsOrig
operator|.
name|getProperty
argument_list|(
name|prop
argument_list|)
argument_list|,
literal|null
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|props
operator|.
name|getProperty
argument_list|(
name|CoreDescriptor
operator|.
name|CORE_INSTDIR
argument_list|)
operator|==
literal|null
condition|)
block|{
name|props
operator|.
name|setProperty
argument_list|(
name|CoreDescriptor
operator|.
name|CORE_INSTDIR
argument_list|,
name|childFile
operator|.
name|getPath
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|props
operator|.
name|getProperty
argument_list|(
name|CoreDescriptor
operator|.
name|CORE_NAME
argument_list|)
operator|==
literal|null
condition|)
block|{
comment|// Should default to this directory
name|props
operator|.
name|setProperty
argument_list|(
name|CoreDescriptor
operator|.
name|CORE_NAME
argument_list|,
name|childFile
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|CoreDescriptor
name|desc
init|=
operator|new
name|CoreDescriptor
argument_list|(
name|container
argument_list|,
name|props
argument_list|)
decl_stmt|;
name|CoreDescriptorPlus
name|plus
init|=
operator|new
name|CoreDescriptorPlus
argument_list|(
name|propFile
operator|.
name|getAbsolutePath
argument_list|()
argument_list|,
name|desc
argument_list|,
name|propsOrig
argument_list|)
decl_stmt|;
name|coreDescriptorPlusMap
operator|.
name|put
argument_list|(
name|desc
operator|.
name|getName
argument_list|()
argument_list|,
name|plus
argument_list|)
expr_stmt|;
continue|continue;
comment|// Go on to the sibling directory
block|}
if|if
condition|(
name|childFile
operator|.
name|isDirectory
argument_list|()
condition|)
block|{
name|walkFromHere
argument_list|(
name|childFile
argument_list|,
name|container
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|getCoreProperties
specifier|static
name|Properties
name|getCoreProperties
parameter_list|(
name|String
name|instanceDir
parameter_list|,
name|CoreDescriptor
name|dcore
parameter_list|)
block|{
name|String
name|file
init|=
name|dcore
operator|.
name|getPropertiesName
argument_list|()
decl_stmt|;
if|if
condition|(
name|file
operator|==
literal|null
condition|)
name|file
operator|=
literal|"conf"
operator|+
name|File
operator|.
name|separator
operator|+
literal|"solrcore.properties"
expr_stmt|;
name|File
name|corePropsFile
init|=
operator|new
name|File
argument_list|(
name|file
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|corePropsFile
operator|.
name|isAbsolute
argument_list|()
condition|)
block|{
name|corePropsFile
operator|=
operator|new
name|File
argument_list|(
name|instanceDir
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
name|Properties
name|p
init|=
name|dcore
operator|.
name|getCoreProperties
argument_list|()
decl_stmt|;
if|if
condition|(
name|corePropsFile
operator|.
name|exists
argument_list|()
operator|&&
name|corePropsFile
operator|.
name|isFile
argument_list|()
condition|)
block|{
name|p
operator|=
operator|new
name|Properties
argument_list|(
name|dcore
operator|.
name|getCoreProperties
argument_list|()
argument_list|)
expr_stmt|;
name|InputStream
name|is
init|=
literal|null
decl_stmt|;
try|try
block|{
name|is
operator|=
operator|new
name|FileInputStream
argument_list|(
name|corePropsFile
argument_list|)
expr_stmt|;
name|p
operator|.
name|load
argument_list|(
name|is
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Error loading properties "
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|IOUtils
operator|.
name|closeQuietly
argument_list|(
name|is
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|p
return|;
block|}
annotation|@
name|Override
DECL|method|getCoreNameFromOrig
specifier|public
name|String
name|getCoreNameFromOrig
parameter_list|(
name|String
name|origCoreName
parameter_list|,
name|SolrResourceLoader
name|loader
parameter_list|,
name|String
name|coreName
parameter_list|)
block|{
comment|// first look for an exact match
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|CoreDescriptorPlus
argument_list|>
name|ent
range|:
name|coreDescriptorPlusMap
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|String
name|name
init|=
name|ent
operator|.
name|getValue
argument_list|()
operator|.
name|getCoreDescriptor
argument_list|()
operator|.
name|getProperty
argument_list|(
name|CoreDescriptor
operator|.
name|CORE_NAME
argument_list|,
literal|null
argument_list|)
decl_stmt|;
if|if
condition|(
name|origCoreName
operator|.
name|equals
argument_list|(
name|name
argument_list|)
condition|)
block|{
if|if
condition|(
name|coreName
operator|.
name|equals
argument_list|(
name|origCoreName
argument_list|)
condition|)
block|{
return|return
name|name
return|;
block|}
return|return
name|coreName
return|;
block|}
block|}
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|CoreDescriptorPlus
argument_list|>
name|ent
range|:
name|coreDescriptorPlusMap
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|String
name|name
init|=
name|ent
operator|.
name|getValue
argument_list|()
operator|.
name|getCoreDescriptor
argument_list|()
operator|.
name|getProperty
argument_list|(
name|CoreDescriptor
operator|.
name|CORE_NAME
argument_list|,
literal|null
argument_list|)
decl_stmt|;
comment|// see if we match with substitution
if|if
condition|(
name|origCoreName
operator|.
name|equals
argument_list|(
name|PropertiesUtil
operator|.
name|substituteProperty
argument_list|(
name|name
argument_list|,
name|loader
operator|.
name|getCoreProperties
argument_list|()
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|coreName
operator|.
name|equals
argument_list|(
name|origCoreName
argument_list|)
condition|)
block|{
return|return
name|name
return|;
block|}
return|return
name|coreName
return|;
block|}
block|}
return|return
literal|null
return|;
block|}
annotation|@
name|Override
DECL|method|getAllCoreNames
specifier|public
name|List
argument_list|<
name|String
argument_list|>
name|getAllCoreNames
parameter_list|()
block|{
name|List
argument_list|<
name|String
argument_list|>
name|ret
decl_stmt|;
name|ret
operator|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|(
name|coreDescriptorPlusMap
operator|.
name|keySet
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
annotation|@
name|Override
DECL|method|getProperty
specifier|public
name|String
name|getProperty
parameter_list|(
name|String
name|coreName
parameter_list|,
name|String
name|property
parameter_list|,
name|String
name|defaultVal
parameter_list|)
block|{
name|CoreDescriptorPlus
name|plus
init|=
name|coreDescriptorPlusMap
operator|.
name|get
argument_list|(
name|coreName
argument_list|)
decl_stmt|;
if|if
condition|(
name|plus
operator|==
literal|null
condition|)
return|return
name|defaultVal
return|;
name|CoreDescriptor
name|desc
init|=
name|plus
operator|.
name|getCoreDescriptor
argument_list|()
decl_stmt|;
if|if
condition|(
name|desc
operator|==
literal|null
condition|)
return|return
name|defaultVal
return|;
return|return
name|desc
operator|.
name|getProperty
argument_list|(
name|property
argument_list|,
name|defaultVal
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|readCoreProperties
specifier|public
name|Properties
name|readCoreProperties
parameter_list|(
name|String
name|coreName
parameter_list|)
block|{
name|CoreDescriptorPlus
name|plus
init|=
name|coreDescriptorPlusMap
operator|.
name|get
argument_list|(
name|coreName
argument_list|)
decl_stmt|;
if|if
condition|(
name|plus
operator|==
literal|null
condition|)
return|return
literal|null
return|;
return|return
operator|new
name|Properties
argument_list|(
name|plus
operator|.
name|getCoreDescriptor
argument_list|()
operator|.
name|getCoreProperties
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|readCoreAttributes
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|readCoreAttributes
parameter_list|(
name|String
name|coreName
parameter_list|)
block|{
return|return
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|()
return|;
comment|// Should be a no-op.
block|}
block|}
end_class
begin_comment
comment|// It's mightily convenient to have all of the original path names and property values when persisting cores, so
end_comment
begin_comment
comment|// this little convenience class is just for that.
end_comment
begin_comment
comment|// Also, let's keep track of anything we added here, especially the instance dir for persistence purposes. We don't
end_comment
begin_comment
comment|// want, for instance, to persist instanceDir if it was not specified originally.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// I suspect that for persistence purposes, we may want to expand this idea to record, say, ${blah}
end_comment
begin_class
DECL|class|CoreDescriptorPlus
class|class
name|CoreDescriptorPlus
block|{
DECL|field|coreDescriptor
specifier|private
name|CoreDescriptor
name|coreDescriptor
decl_stmt|;
DECL|field|filePath
specifier|private
name|String
name|filePath
decl_stmt|;
DECL|field|propsOrig
specifier|private
name|Properties
name|propsOrig
decl_stmt|;
DECL|method|CoreDescriptorPlus
name|CoreDescriptorPlus
parameter_list|(
name|String
name|filePath
parameter_list|,
name|CoreDescriptor
name|descriptor
parameter_list|,
name|Properties
name|propsOrig
parameter_list|)
block|{
name|coreDescriptor
operator|=
name|descriptor
expr_stmt|;
name|this
operator|.
name|filePath
operator|=
name|filePath
expr_stmt|;
name|this
operator|.
name|propsOrig
operator|=
name|propsOrig
expr_stmt|;
block|}
DECL|method|getCoreDescriptor
name|CoreDescriptor
name|getCoreDescriptor
parameter_list|()
block|{
return|return
name|coreDescriptor
return|;
block|}
DECL|method|getFilePath
name|String
name|getFilePath
parameter_list|()
block|{
return|return
name|filePath
return|;
block|}
DECL|method|getPropsOrig
name|Properties
name|getPropsOrig
parameter_list|()
block|{
return|return
name|propsOrig
return|;
block|}
block|}
end_class
end_unit
