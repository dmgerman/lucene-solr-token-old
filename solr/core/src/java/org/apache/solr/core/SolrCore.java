begin_unit
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_package
DECL|package|org.apache.solr.core
package|package
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|core
package|;
end_package
begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|parsers
operator|.
name|ParserConfigurationException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Closeable
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileNotFoundException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStreamReader
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStream
import|;
end_import
begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Constructor
import|;
end_import
begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URL
import|;
end_import
begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|charset
operator|.
name|StandardCharsets
import|;
end_import
begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|NoSuchFileException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Date
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|IdentityHashMap
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashMap
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedList
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Locale
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Properties
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|StringTokenizer
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Callable
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentHashMap
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|CopyOnWriteArrayList
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|CountDownLatch
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ExecutorService
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Executors
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Future
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicInteger
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicLong
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|ReentrantLock
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|io
operator|.
name|FileUtils
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|util
operator|.
name|ResourceLoader
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|codecs
operator|.
name|Codec
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|DirectoryReader
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|IndexDeletionPolicy
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|IndexWriter
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|BooleanQuery
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|Directory
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|IOContext
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|IndexInput
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|LockObtainFailedException
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|client
operator|.
name|solrj
operator|.
name|impl
operator|.
name|BinaryResponseParser
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|cloud
operator|.
name|CloudDescriptor
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|cloud
operator|.
name|ZkSolrResourceLoader
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|SolrException
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|cloud
operator|.
name|ClusterState
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|cloud
operator|.
name|Slice
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|cloud
operator|.
name|SolrZkClient
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|params
operator|.
name|CommonParams
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|params
operator|.
name|CommonParams
operator|.
name|EchoParamStyle
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|params
operator|.
name|SolrParams
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|params
operator|.
name|UpdateParams
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|util
operator|.
name|ExecutorUtil
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|util
operator|.
name|IOUtils
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|util
operator|.
name|NamedList
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|util
operator|.
name|SimpleOrderedMap
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|core
operator|.
name|DirectoryFactory
operator|.
name|DirContext
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|handler
operator|.
name|IndexFetcher
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|handler
operator|.
name|ReplicationHandler
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|handler
operator|.
name|RequestHandlerBase
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|handler
operator|.
name|admin
operator|.
name|ShowFileRequestHandler
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|handler
operator|.
name|component
operator|.
name|HighlightComponent
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|handler
operator|.
name|component
operator|.
name|SearchComponent
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|request
operator|.
name|SolrQueryRequest
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|request
operator|.
name|SolrRequestHandler
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|response
operator|.
name|BinaryResponseWriter
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|response
operator|.
name|CSVResponseWriter
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|response
operator|.
name|JSONResponseWriter
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|response
operator|.
name|PHPResponseWriter
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|response
operator|.
name|PHPSerializedResponseWriter
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|response
operator|.
name|PythonResponseWriter
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|response
operator|.
name|QueryResponseWriter
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|response
operator|.
name|RawResponseWriter
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|response
operator|.
name|RubyResponseWriter
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|response
operator|.
name|SchemaXmlResponseWriter
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|response
operator|.
name|SolrQueryResponse
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|response
operator|.
name|SortingResponseWriter
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|response
operator|.
name|XMLResponseWriter
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|response
operator|.
name|transform
operator|.
name|TransformerFactory
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|rest
operator|.
name|ManagedResourceStorage
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|rest
operator|.
name|ManagedResourceStorage
operator|.
name|StorageIO
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|rest
operator|.
name|RestManager
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|schema
operator|.
name|FieldType
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|schema
operator|.
name|IndexSchema
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|schema
operator|.
name|IndexSchemaFactory
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|schema
operator|.
name|ManagedIndexSchema
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|schema
operator|.
name|SimilarityFactory
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|search
operator|.
name|QParserPlugin
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|search
operator|.
name|SolrFieldCacheMBean
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|search
operator|.
name|SolrIndexSearcher
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|search
operator|.
name|ValueSourceParser
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|search
operator|.
name|stats
operator|.
name|LocalStatsCache
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|search
operator|.
name|stats
operator|.
name|StatsCache
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|update
operator|.
name|DefaultSolrCoreState
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|update
operator|.
name|DirectUpdateHandler2
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|update
operator|.
name|SolrCoreState
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|update
operator|.
name|SolrCoreState
operator|.
name|IndexWriterCloser
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|update
operator|.
name|SolrIndexWriter
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|update
operator|.
name|UpdateHandler
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|update
operator|.
name|VersionInfo
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|update
operator|.
name|processor
operator|.
name|DistributedUpdateProcessorFactory
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|update
operator|.
name|processor
operator|.
name|LogUpdateProcessorFactory
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|update
operator|.
name|processor
operator|.
name|RunUpdateProcessorFactory
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|update
operator|.
name|processor
operator|.
name|UpdateRequestProcessorChain
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|update
operator|.
name|processor
operator|.
name|UpdateRequestProcessorChain
operator|.
name|ProcessorInfo
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|update
operator|.
name|processor
operator|.
name|UpdateRequestProcessorFactory
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|util
operator|.
name|ConcurrentLRUCache
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|util
operator|.
name|DefaultSolrThreadFactory
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|util
operator|.
name|PropertiesInputStream
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|util
operator|.
name|RefCounted
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|util
operator|.
name|plugin
operator|.
name|NamedListInitializedPlugin
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|util
operator|.
name|plugin
operator|.
name|PluginInfoInitialized
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|util
operator|.
name|plugin
operator|.
name|SolrCoreAware
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|KeeperException
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|data
operator|.
name|Stat
import|;
end_import
begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import
begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import
begin_import
import|import
name|org
operator|.
name|xml
operator|.
name|sax
operator|.
name|SAXException
import|;
end_import
begin_comment
comment|/**  *  */
end_comment
begin_class
DECL|class|SolrCore
specifier|public
specifier|final
class|class
name|SolrCore
implements|implements
name|SolrInfoMBean
implements|,
name|Closeable
block|{
DECL|field|version
specifier|public
specifier|static
specifier|final
name|String
name|version
init|=
literal|"1.0"
decl_stmt|;
comment|// These should *only* be used for debugging or monitoring purposes
DECL|field|numOpens
specifier|public
specifier|static
specifier|final
name|AtomicLong
name|numOpens
init|=
operator|new
name|AtomicLong
argument_list|()
decl_stmt|;
DECL|field|numCloses
specifier|public
specifier|static
specifier|final
name|AtomicLong
name|numCloses
init|=
operator|new
name|AtomicLong
argument_list|()
decl_stmt|;
DECL|field|openHandles
specifier|public
specifier|static
name|Map
argument_list|<
name|SolrCore
argument_list|,
name|Exception
argument_list|>
name|openHandles
init|=
name|Collections
operator|.
name|synchronizedMap
argument_list|(
operator|new
name|IdentityHashMap
argument_list|<
name|SolrCore
argument_list|,
name|Exception
argument_list|>
argument_list|()
argument_list|)
decl_stmt|;
DECL|field|log
specifier|public
specifier|static
specifier|final
name|Logger
name|log
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|SolrCore
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|requestLog
specifier|public
specifier|static
specifier|final
name|Logger
name|requestLog
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|SolrCore
operator|.
name|class
operator|.
name|getName
argument_list|()
operator|+
literal|".Request"
argument_list|)
decl_stmt|;
DECL|field|name
specifier|private
name|String
name|name
decl_stmt|;
DECL|field|logid
specifier|private
name|String
name|logid
decl_stmt|;
comment|// used to show what name is set
DECL|field|coreDescriptor
specifier|private
name|CoreDescriptor
name|coreDescriptor
decl_stmt|;
DECL|field|isReloaded
specifier|private
name|boolean
name|isReloaded
init|=
literal|false
decl_stmt|;
DECL|field|statsCache
specifier|private
name|StatsCache
name|statsCache
decl_stmt|;
DECL|field|solrConfig
specifier|private
specifier|final
name|SolrConfig
name|solrConfig
decl_stmt|;
DECL|field|resourceLoader
specifier|private
specifier|final
name|SolrResourceLoader
name|resourceLoader
decl_stmt|;
DECL|field|schema
specifier|private
specifier|volatile
name|IndexSchema
name|schema
decl_stmt|;
DECL|field|dataDir
specifier|private
specifier|final
name|String
name|dataDir
decl_stmt|;
DECL|field|ulogDir
specifier|private
specifier|final
name|String
name|ulogDir
decl_stmt|;
DECL|field|updateHandler
specifier|private
specifier|final
name|UpdateHandler
name|updateHandler
decl_stmt|;
DECL|field|solrCoreState
specifier|private
specifier|final
name|SolrCoreState
name|solrCoreState
decl_stmt|;
DECL|field|startTime
specifier|private
specifier|final
name|long
name|startTime
decl_stmt|;
DECL|field|reqHandlers
specifier|private
specifier|final
name|RequestHandlers
name|reqHandlers
decl_stmt|;
DECL|field|searchComponents
specifier|private
specifier|final
name|PluginBag
argument_list|<
name|SearchComponent
argument_list|>
name|searchComponents
init|=
operator|new
name|PluginBag
argument_list|<>
argument_list|(
name|SearchComponent
operator|.
name|class
argument_list|,
name|this
argument_list|)
decl_stmt|;
DECL|field|updateProcessors
specifier|private
specifier|final
name|PluginBag
argument_list|<
name|UpdateRequestProcessorFactory
argument_list|>
name|updateProcessors
init|=
operator|new
name|PluginBag
argument_list|<>
argument_list|(
name|UpdateRequestProcessorFactory
operator|.
name|class
argument_list|,
name|this
argument_list|)
decl_stmt|;
DECL|field|updateProcessorChains
specifier|private
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|UpdateRequestProcessorChain
argument_list|>
name|updateProcessorChains
decl_stmt|;
DECL|field|infoRegistry
specifier|private
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|SolrInfoMBean
argument_list|>
name|infoRegistry
decl_stmt|;
DECL|field|solrDelPolicy
specifier|private
name|IndexDeletionPolicyWrapper
name|solrDelPolicy
decl_stmt|;
DECL|field|directoryFactory
specifier|private
name|DirectoryFactory
name|directoryFactory
decl_stmt|;
DECL|field|indexReaderFactory
specifier|private
name|IndexReaderFactory
name|indexReaderFactory
decl_stmt|;
DECL|field|codec
specifier|private
specifier|final
name|Codec
name|codec
decl_stmt|;
DECL|field|memClassLoader
specifier|private
specifier|final
name|MemClassLoader
name|memClassLoader
decl_stmt|;
DECL|field|confListeners
specifier|private
specifier|final
name|List
argument_list|<
name|Runnable
argument_list|>
name|confListeners
init|=
operator|new
name|CopyOnWriteArrayList
argument_list|<>
argument_list|()
decl_stmt|;
DECL|field|ruleExpiryLock
specifier|private
specifier|final
name|ReentrantLock
name|ruleExpiryLock
decl_stmt|;
DECL|method|getStartTime
specifier|public
name|long
name|getStartTime
parameter_list|()
block|{
return|return
name|startTime
return|;
block|}
DECL|field|restManager
specifier|private
name|RestManager
name|restManager
decl_stmt|;
DECL|method|getRestManager
specifier|public
name|RestManager
name|getRestManager
parameter_list|()
block|{
return|return
name|restManager
return|;
block|}
DECL|field|boolean_query_max_clause_count
specifier|static
name|int
name|boolean_query_max_clause_count
init|=
name|Integer
operator|.
name|MIN_VALUE
decl_stmt|;
comment|// only change the BooleanQuery maxClauseCount once for ALL cores...
DECL|method|booleanQueryMaxClauseCount
name|void
name|booleanQueryMaxClauseCount
parameter_list|()
block|{
synchronized|synchronized
init|(
name|SolrCore
operator|.
name|class
init|)
block|{
if|if
condition|(
name|boolean_query_max_clause_count
operator|==
name|Integer
operator|.
name|MIN_VALUE
condition|)
block|{
name|boolean_query_max_clause_count
operator|=
name|solrConfig
operator|.
name|booleanQueryMaxClauseCount
expr_stmt|;
name|BooleanQuery
operator|.
name|setMaxClauseCount
argument_list|(
name|boolean_query_max_clause_count
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|boolean_query_max_clause_count
operator|!=
name|solrConfig
operator|.
name|booleanQueryMaxClauseCount
condition|)
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"BooleanQuery.maxClauseCount= "
operator|+
name|boolean_query_max_clause_count
operator|+
literal|", ignoring "
operator|+
name|solrConfig
operator|.
name|booleanQueryMaxClauseCount
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * The SolrResourceLoader used to load all resources for this core.    * @since solr 1.3    */
DECL|method|getResourceLoader
specifier|public
name|SolrResourceLoader
name|getResourceLoader
parameter_list|()
block|{
return|return
name|resourceLoader
return|;
block|}
comment|/**    * Gets the configuration resource name used by this core instance.    * @since solr 1.3    */
DECL|method|getConfigResource
specifier|public
name|String
name|getConfigResource
parameter_list|()
block|{
return|return
name|solrConfig
operator|.
name|getResourceName
argument_list|()
return|;
block|}
comment|/**    * Gets the configuration object used by this core instance.    */
DECL|method|getSolrConfig
specifier|public
name|SolrConfig
name|getSolrConfig
parameter_list|()
block|{
return|return
name|solrConfig
return|;
block|}
comment|/**    * Gets the schema resource name used by this core instance.    * @since solr 1.3    */
DECL|method|getSchemaResource
specifier|public
name|String
name|getSchemaResource
parameter_list|()
block|{
return|return
name|getLatestSchema
argument_list|()
operator|.
name|getResourceName
argument_list|()
return|;
block|}
comment|/** @return the latest snapshot of the schema used by this core instance. */
DECL|method|getLatestSchema
specifier|public
name|IndexSchema
name|getLatestSchema
parameter_list|()
block|{
return|return
name|schema
return|;
block|}
comment|/** Sets the latest schema snapshot to be used by this core instance. */
DECL|method|setLatestSchema
specifier|public
name|void
name|setLatestSchema
parameter_list|(
name|IndexSchema
name|replacementSchema
parameter_list|)
block|{
name|schema
operator|=
name|replacementSchema
expr_stmt|;
block|}
DECL|method|getDataDir
specifier|public
name|String
name|getDataDir
parameter_list|()
block|{
return|return
name|dataDir
return|;
block|}
DECL|method|getUlogDir
specifier|public
name|String
name|getUlogDir
parameter_list|()
block|{
return|return
name|ulogDir
return|;
block|}
DECL|method|getIndexDir
specifier|public
name|String
name|getIndexDir
parameter_list|()
block|{
synchronized|synchronized
init|(
name|searcherLock
init|)
block|{
if|if
condition|(
name|_searcher
operator|==
literal|null
condition|)
return|return
name|getNewIndexDir
argument_list|()
return|;
name|SolrIndexSearcher
name|searcher
init|=
name|_searcher
operator|.
name|get
argument_list|()
decl_stmt|;
return|return
name|searcher
operator|.
name|getPath
argument_list|()
operator|==
literal|null
condition|?
name|dataDir
operator|+
literal|"index/"
else|:
name|searcher
operator|.
name|getPath
argument_list|()
return|;
block|}
block|}
comment|/**    * Returns the indexdir as given in index.properties. If index.properties exists in dataDir and    * there is a property<i>index</i> available and it points to a valid directory    * in dataDir that is returned Else dataDir/index is returned. Only called for creating new indexSearchers    * and indexwriters. Use the getIndexDir() method to know the active index directory    *    * @return the indexdir as given in index.properties    */
DECL|method|getNewIndexDir
specifier|public
name|String
name|getNewIndexDir
parameter_list|()
block|{
name|String
name|result
init|=
name|dataDir
operator|+
literal|"index/"
decl_stmt|;
name|Properties
name|p
init|=
operator|new
name|Properties
argument_list|()
decl_stmt|;
name|Directory
name|dir
init|=
literal|null
decl_stmt|;
try|try
block|{
name|dir
operator|=
name|getDirectoryFactory
argument_list|()
operator|.
name|get
argument_list|(
name|getDataDir
argument_list|()
argument_list|,
name|DirContext
operator|.
name|META_DATA
argument_list|,
name|getSolrConfig
argument_list|()
operator|.
name|indexConfig
operator|.
name|lockType
argument_list|)
expr_stmt|;
name|IndexInput
name|input
decl_stmt|;
try|try
block|{
name|input
operator|=
name|dir
operator|.
name|openInput
argument_list|(
name|IndexFetcher
operator|.
name|INDEX_PROPERTIES
argument_list|,
name|IOContext
operator|.
name|DEFAULT
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|FileNotFoundException
decl||
name|NoSuchFileException
name|e
parameter_list|)
block|{
name|input
operator|=
literal|null
expr_stmt|;
block|}
if|if
condition|(
name|input
operator|!=
literal|null
condition|)
block|{
specifier|final
name|InputStream
name|is
init|=
operator|new
name|PropertiesInputStream
argument_list|(
name|input
argument_list|)
decl_stmt|;
try|try
block|{
name|p
operator|.
name|load
argument_list|(
operator|new
name|InputStreamReader
argument_list|(
name|is
argument_list|,
name|StandardCharsets
operator|.
name|UTF_8
argument_list|)
argument_list|)
expr_stmt|;
name|String
name|s
init|=
name|p
operator|.
name|getProperty
argument_list|(
literal|"index"
argument_list|)
decl_stmt|;
if|if
condition|(
name|s
operator|!=
literal|null
operator|&&
name|s
operator|.
name|trim
argument_list|()
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
name|result
operator|=
name|dataDir
operator|+
name|s
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"Unable to load "
operator|+
name|IndexFetcher
operator|.
name|INDEX_PROPERTIES
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|IOUtils
operator|.
name|closeQuietly
argument_list|(
name|is
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|SolrException
operator|.
name|log
argument_list|(
name|log
argument_list|,
literal|""
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
name|dir
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|getDirectoryFactory
argument_list|()
operator|.
name|release
argument_list|(
name|dir
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|SolrException
operator|.
name|log
argument_list|(
name|log
argument_list|,
literal|""
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|result
operator|.
name|equals
argument_list|(
name|lastNewIndexDir
argument_list|)
condition|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"New index directory detected: old="
operator|+
name|lastNewIndexDir
operator|+
literal|" new="
operator|+
name|result
argument_list|)
expr_stmt|;
block|}
name|lastNewIndexDir
operator|=
name|result
expr_stmt|;
return|return
name|result
return|;
block|}
DECL|field|lastNewIndexDir
specifier|private
name|String
name|lastNewIndexDir
decl_stmt|;
comment|// for debugging purposes only... access not synchronized, but that's ok
DECL|method|getDirectoryFactory
specifier|public
name|DirectoryFactory
name|getDirectoryFactory
parameter_list|()
block|{
return|return
name|directoryFactory
return|;
block|}
DECL|method|getIndexReaderFactory
specifier|public
name|IndexReaderFactory
name|getIndexReaderFactory
parameter_list|()
block|{
return|return
name|indexReaderFactory
return|;
block|}
annotation|@
name|Override
DECL|method|getName
specifier|public
name|String
name|getName
parameter_list|()
block|{
return|return
name|name
return|;
block|}
DECL|method|setName
specifier|public
name|void
name|setName
parameter_list|(
name|String
name|v
parameter_list|)
block|{
name|this
operator|.
name|name
operator|=
name|v
expr_stmt|;
name|this
operator|.
name|logid
operator|=
operator|(
name|v
operator|==
literal|null
operator|)
condition|?
literal|""
else|:
operator|(
literal|"["
operator|+
name|v
operator|+
literal|"] "
operator|)
expr_stmt|;
name|this
operator|.
name|coreDescriptor
operator|=
operator|new
name|CoreDescriptor
argument_list|(
name|v
argument_list|,
name|this
operator|.
name|coreDescriptor
argument_list|)
expr_stmt|;
block|}
DECL|method|getLogId
specifier|public
name|String
name|getLogId
parameter_list|()
block|{
return|return
name|this
operator|.
name|logid
return|;
block|}
comment|/**    * Returns a Map of name vs SolrInfoMBean objects. The returned map is an instance of    * a ConcurrentHashMap and therefore no synchronization is needed for putting, removing    * or iterating over it.    *    * @return the Info Registry map which contains SolrInfoMBean objects keyed by name    * @since solr 1.3    */
DECL|method|getInfoRegistry
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|SolrInfoMBean
argument_list|>
name|getInfoRegistry
parameter_list|()
block|{
return|return
name|infoRegistry
return|;
block|}
DECL|method|initDeletionPolicy
specifier|private
name|void
name|initDeletionPolicy
parameter_list|()
block|{
name|PluginInfo
name|info
init|=
name|solrConfig
operator|.
name|getPluginInfo
argument_list|(
name|IndexDeletionPolicy
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
name|IndexDeletionPolicy
name|delPolicy
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|info
operator|!=
literal|null
condition|)
block|{
name|delPolicy
operator|=
name|createInstance
argument_list|(
name|info
operator|.
name|className
argument_list|,
name|IndexDeletionPolicy
operator|.
name|class
argument_list|,
literal|"Deletion Policy for SOLR"
argument_list|,
name|this
argument_list|,
name|getResourceLoader
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|delPolicy
operator|instanceof
name|NamedListInitializedPlugin
condition|)
block|{
operator|(
operator|(
name|NamedListInitializedPlugin
operator|)
name|delPolicy
operator|)
operator|.
name|init
argument_list|(
name|info
operator|.
name|initArgs
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|delPolicy
operator|=
operator|new
name|SolrDeletionPolicy
argument_list|()
expr_stmt|;
block|}
name|solrDelPolicy
operator|=
operator|new
name|IndexDeletionPolicyWrapper
argument_list|(
name|delPolicy
argument_list|)
expr_stmt|;
block|}
DECL|method|initListeners
specifier|private
name|void
name|initListeners
parameter_list|()
block|{
specifier|final
name|Class
argument_list|<
name|SolrEventListener
argument_list|>
name|clazz
init|=
name|SolrEventListener
operator|.
name|class
decl_stmt|;
specifier|final
name|String
name|label
init|=
literal|"Event Listener"
decl_stmt|;
for|for
control|(
name|PluginInfo
name|info
range|:
name|solrConfig
operator|.
name|getPluginInfos
argument_list|(
name|SolrEventListener
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
control|)
block|{
name|String
name|event
init|=
name|info
operator|.
name|attributes
operator|.
name|get
argument_list|(
literal|"event"
argument_list|)
decl_stmt|;
if|if
condition|(
literal|"firstSearcher"
operator|.
name|equals
argument_list|(
name|event
argument_list|)
condition|)
block|{
name|SolrEventListener
name|obj
init|=
name|createInitInstance
argument_list|(
name|info
argument_list|,
name|clazz
argument_list|,
name|label
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|firstSearcherListeners
operator|.
name|add
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
name|logid
operator|+
literal|"Added SolrEventListener for firstSearcher: "
operator|+
name|obj
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|"newSearcher"
operator|.
name|equals
argument_list|(
name|event
argument_list|)
condition|)
block|{
name|SolrEventListener
name|obj
init|=
name|createInitInstance
argument_list|(
name|info
argument_list|,
name|clazz
argument_list|,
name|label
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|newSearcherListeners
operator|.
name|add
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
name|logid
operator|+
literal|"Added SolrEventListener for newSearcher: "
operator|+
name|obj
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|field|firstSearcherListeners
specifier|final
name|List
argument_list|<
name|SolrEventListener
argument_list|>
name|firstSearcherListeners
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
DECL|field|newSearcherListeners
specifier|final
name|List
argument_list|<
name|SolrEventListener
argument_list|>
name|newSearcherListeners
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
comment|/**    * NOTE: this function is not thread safe.  However, it is safe to call within the    *<code>inform( SolrCore core )</code> function for<code>SolrCoreAware</code> classes.    * Outside<code>inform</code>, this could potentially throw a ConcurrentModificationException    *    * @see SolrCoreAware    */
DECL|method|registerFirstSearcherListener
specifier|public
name|void
name|registerFirstSearcherListener
parameter_list|(
name|SolrEventListener
name|listener
parameter_list|)
block|{
name|firstSearcherListeners
operator|.
name|add
argument_list|(
name|listener
argument_list|)
expr_stmt|;
block|}
comment|/**    * NOTE: this function is not thread safe.  However, it is safe to call within the    *<code>inform( SolrCore core )</code> function for<code>SolrCoreAware</code> classes.    * Outside<code>inform</code>, this could potentially throw a ConcurrentModificationException    *    * @see SolrCoreAware    */
DECL|method|registerNewSearcherListener
specifier|public
name|void
name|registerNewSearcherListener
parameter_list|(
name|SolrEventListener
name|listener
parameter_list|)
block|{
name|newSearcherListeners
operator|.
name|add
argument_list|(
name|listener
argument_list|)
expr_stmt|;
block|}
comment|/**    * NOTE: this function is not thread safe.  However, it is safe to call within the    *<code>inform( SolrCore core )</code> function for<code>SolrCoreAware</code> classes.    * Outside<code>inform</code>, this could potentially throw a ConcurrentModificationException    *    * @see SolrCoreAware    */
DECL|method|registerResponseWriter
specifier|public
name|QueryResponseWriter
name|registerResponseWriter
parameter_list|(
name|String
name|name
parameter_list|,
name|QueryResponseWriter
name|responseWriter
parameter_list|)
block|{
return|return
name|responseWriters
operator|.
name|put
argument_list|(
name|name
argument_list|,
name|responseWriter
argument_list|)
return|;
block|}
DECL|method|reload
specifier|public
name|SolrCore
name|reload
parameter_list|(
name|ConfigSet
name|coreConfig
parameter_list|)
throws|throws
name|IOException
throws|,
name|ParserConfigurationException
throws|,
name|SAXException
block|{
name|solrCoreState
operator|.
name|increfSolrCoreState
argument_list|()
expr_stmt|;
name|SolrCore
name|currentCore
decl_stmt|;
name|boolean
name|indexDirChange
init|=
operator|!
name|getNewIndexDir
argument_list|()
operator|.
name|equals
argument_list|(
name|getIndexDir
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|indexDirChange
condition|)
block|{
comment|// the directory is changing, don't pass on state
name|currentCore
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
name|currentCore
operator|=
name|this
expr_stmt|;
block|}
name|SolrCore
name|core
init|=
operator|new
name|SolrCore
argument_list|(
name|getName
argument_list|()
argument_list|,
name|getDataDir
argument_list|()
argument_list|,
name|coreConfig
operator|.
name|getSolrConfig
argument_list|()
argument_list|,
name|coreConfig
operator|.
name|getIndexSchema
argument_list|()
argument_list|,
name|coreDescriptor
argument_list|,
name|updateHandler
argument_list|,
name|this
operator|.
name|solrDelPolicy
argument_list|,
name|currentCore
argument_list|)
decl_stmt|;
name|core
operator|.
name|solrDelPolicy
operator|=
name|this
operator|.
name|solrDelPolicy
expr_stmt|;
comment|// we open a new indexwriter to pick up the latest config
name|core
operator|.
name|getUpdateHandler
argument_list|()
operator|.
name|getSolrCoreState
argument_list|()
operator|.
name|newIndexWriter
argument_list|(
name|core
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|core
operator|.
name|getSearcher
argument_list|(
literal|true
argument_list|,
literal|false
argument_list|,
literal|null
argument_list|,
literal|true
argument_list|)
expr_stmt|;
return|return
name|core
return|;
block|}
DECL|method|initDirectoryFactory
specifier|private
name|void
name|initDirectoryFactory
parameter_list|()
block|{
name|DirectoryFactory
name|dirFactory
decl_stmt|;
name|PluginInfo
name|info
init|=
name|solrConfig
operator|.
name|getPluginInfo
argument_list|(
name|DirectoryFactory
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|info
operator|!=
literal|null
condition|)
block|{
name|log
operator|.
name|info
argument_list|(
name|info
operator|.
name|className
argument_list|)
expr_stmt|;
name|dirFactory
operator|=
name|getResourceLoader
argument_list|()
operator|.
name|newInstance
argument_list|(
name|info
operator|.
name|className
argument_list|,
name|DirectoryFactory
operator|.
name|class
argument_list|)
expr_stmt|;
name|dirFactory
operator|.
name|init
argument_list|(
name|info
operator|.
name|initArgs
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|log
operator|.
name|info
argument_list|(
literal|"solr.NRTCachingDirectoryFactory"
argument_list|)
expr_stmt|;
name|dirFactory
operator|=
operator|new
name|NRTCachingDirectoryFactory
argument_list|()
expr_stmt|;
block|}
comment|// And set it
name|directoryFactory
operator|=
name|dirFactory
expr_stmt|;
block|}
DECL|method|initIndexReaderFactory
specifier|private
name|void
name|initIndexReaderFactory
parameter_list|()
block|{
name|IndexReaderFactory
name|indexReaderFactory
decl_stmt|;
name|PluginInfo
name|info
init|=
name|solrConfig
operator|.
name|getPluginInfo
argument_list|(
name|IndexReaderFactory
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|info
operator|!=
literal|null
condition|)
block|{
name|indexReaderFactory
operator|=
name|resourceLoader
operator|.
name|newInstance
argument_list|(
name|info
operator|.
name|className
argument_list|,
name|IndexReaderFactory
operator|.
name|class
argument_list|)
expr_stmt|;
name|indexReaderFactory
operator|.
name|init
argument_list|(
name|info
operator|.
name|initArgs
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|indexReaderFactory
operator|=
operator|new
name|StandardIndexReaderFactory
argument_list|()
expr_stmt|;
block|}
name|this
operator|.
name|indexReaderFactory
operator|=
name|indexReaderFactory
expr_stmt|;
block|}
comment|// protect via synchronized(SolrCore.class)
DECL|field|dirs
specifier|private
specifier|static
name|Set
argument_list|<
name|String
argument_list|>
name|dirs
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
DECL|method|initIndex
name|void
name|initIndex
parameter_list|(
name|boolean
name|reload
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|indexDir
init|=
name|getNewIndexDir
argument_list|()
decl_stmt|;
name|boolean
name|indexExists
init|=
name|getDirectoryFactory
argument_list|()
operator|.
name|exists
argument_list|(
name|indexDir
argument_list|)
decl_stmt|;
name|boolean
name|firstTime
decl_stmt|;
synchronized|synchronized
init|(
name|SolrCore
operator|.
name|class
init|)
block|{
name|firstTime
operator|=
name|dirs
operator|.
name|add
argument_list|(
name|getDirectoryFactory
argument_list|()
operator|.
name|normalize
argument_list|(
name|indexDir
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|boolean
name|removeLocks
init|=
name|solrConfig
operator|.
name|unlockOnStartup
decl_stmt|;
name|initIndexReaderFactory
argument_list|()
expr_stmt|;
if|if
condition|(
name|indexExists
operator|&&
name|firstTime
operator|&&
operator|!
name|reload
condition|)
block|{
name|Directory
name|dir
init|=
name|directoryFactory
operator|.
name|get
argument_list|(
name|indexDir
argument_list|,
name|DirContext
operator|.
name|DEFAULT
argument_list|,
name|getSolrConfig
argument_list|()
operator|.
name|indexConfig
operator|.
name|lockType
argument_list|)
decl_stmt|;
try|try
block|{
if|if
condition|(
name|IndexWriter
operator|.
name|isLocked
argument_list|(
name|dir
argument_list|)
condition|)
block|{
if|if
condition|(
name|removeLocks
condition|)
block|{
name|log
operator|.
name|warn
argument_list|(
name|logid
operator|+
literal|"WARNING: Solr index directory '{}' is locked.  Unlocking..."
argument_list|,
name|indexDir
argument_list|)
expr_stmt|;
name|dir
operator|.
name|makeLock
argument_list|(
name|IndexWriter
operator|.
name|WRITE_LOCK_NAME
argument_list|)
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|log
operator|.
name|error
argument_list|(
name|logid
operator|+
literal|"Solr index directory '{}' is locked.  Throwing exception"
argument_list|,
name|indexDir
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|LockObtainFailedException
argument_list|(
literal|"Index locked for write for core "
operator|+
name|name
argument_list|)
throw|;
block|}
block|}
block|}
finally|finally
block|{
name|directoryFactory
operator|.
name|release
argument_list|(
name|dir
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Create the index if it doesn't exist.
if|if
condition|(
operator|!
name|indexExists
condition|)
block|{
name|log
operator|.
name|warn
argument_list|(
name|logid
operator|+
literal|"Solr index directory '"
operator|+
operator|new
name|File
argument_list|(
name|indexDir
argument_list|)
operator|+
literal|"' doesn't exist."
operator|+
literal|" Creating new index..."
argument_list|)
expr_stmt|;
name|SolrIndexWriter
name|writer
init|=
name|SolrIndexWriter
operator|.
name|create
argument_list|(
name|this
argument_list|,
literal|"SolrCore.initIndex"
argument_list|,
name|indexDir
argument_list|,
name|getDirectoryFactory
argument_list|()
argument_list|,
literal|true
argument_list|,
name|getLatestSchema
argument_list|()
argument_list|,
name|solrConfig
operator|.
name|indexConfig
argument_list|,
name|solrDelPolicy
argument_list|,
name|codec
argument_list|)
decl_stmt|;
name|writer
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Creates an instance by trying a constructor that accepts a SolrCore before    * trying the default (no arg) constructor.    *    * @param className the instance class to create    * @param cast      the class or interface that the instance should extend or implement    * @param msg       a message helping compose the exception error if any occurs.    * @param core      The SolrCore instance for which this object needs to be loaded    * @return the desired instance    * @throws SolrException if the object could not be instantiated    */
DECL|method|createInstance
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|T
name|createInstance
parameter_list|(
name|String
name|className
parameter_list|,
name|Class
argument_list|<
name|T
argument_list|>
name|cast
parameter_list|,
name|String
name|msg
parameter_list|,
name|SolrCore
name|core
parameter_list|,
name|ResourceLoader
name|resourceLoader
parameter_list|)
block|{
name|Class
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|clazz
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|msg
operator|==
literal|null
condition|)
name|msg
operator|=
literal|"SolrCore Object"
expr_stmt|;
try|try
block|{
name|clazz
operator|=
name|resourceLoader
operator|.
name|findClass
argument_list|(
name|className
argument_list|,
name|cast
argument_list|)
expr_stmt|;
comment|//most of the classes do not have constructors which takes SolrCore argument. It is recommended to obtain SolrCore by implementing SolrCoreAware.
comment|// So invariably always it will cause a  NoSuchMethodException. So iterate though the list of available constructors
name|Constructor
argument_list|<
name|?
argument_list|>
index|[]
name|cons
init|=
name|clazz
operator|.
name|getConstructors
argument_list|()
decl_stmt|;
for|for
control|(
name|Constructor
argument_list|<
name|?
argument_list|>
name|con
range|:
name|cons
control|)
block|{
name|Class
argument_list|<
name|?
argument_list|>
index|[]
name|types
init|=
name|con
operator|.
name|getParameterTypes
argument_list|()
decl_stmt|;
if|if
condition|(
name|types
operator|.
name|length
operator|==
literal|1
operator|&&
name|types
index|[
literal|0
index|]
operator|==
name|SolrCore
operator|.
name|class
condition|)
block|{
return|return
name|cast
operator|.
name|cast
argument_list|(
name|con
operator|.
name|newInstance
argument_list|(
name|core
argument_list|)
argument_list|)
return|;
block|}
block|}
return|return
name|resourceLoader
operator|.
name|newInstance
argument_list|(
name|className
argument_list|,
name|cast
argument_list|)
return|;
comment|//use the empty constructor
block|}
catch|catch
parameter_list|(
name|SolrException
name|e
parameter_list|)
block|{
throw|throw
name|e
throw|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
comment|// The JVM likes to wrap our helpful SolrExceptions in things like
comment|// "InvocationTargetException" that have no useful getMessage
if|if
condition|(
literal|null
operator|!=
name|e
operator|.
name|getCause
argument_list|()
operator|&&
name|e
operator|.
name|getCause
argument_list|()
operator|instanceof
name|SolrException
condition|)
block|{
name|SolrException
name|inner
init|=
operator|(
name|SolrException
operator|)
name|e
operator|.
name|getCause
argument_list|()
decl_stmt|;
throw|throw
name|inner
throw|;
block|}
throw|throw
operator|new
name|SolrException
argument_list|(
name|SolrException
operator|.
name|ErrorCode
operator|.
name|SERVER_ERROR
argument_list|,
literal|"Error Instantiating "
operator|+
name|msg
operator|+
literal|", "
operator|+
name|className
operator|+
literal|" failed to instantiate "
operator|+
name|cast
operator|.
name|getName
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
DECL|method|createReloadedUpdateHandler
specifier|private
name|UpdateHandler
name|createReloadedUpdateHandler
parameter_list|(
name|String
name|className
parameter_list|,
name|String
name|msg
parameter_list|,
name|UpdateHandler
name|updateHandler
parameter_list|)
block|{
name|Class
argument_list|<
name|?
extends|extends
name|UpdateHandler
argument_list|>
name|clazz
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|msg
operator|==
literal|null
condition|)
name|msg
operator|=
literal|"SolrCore Object"
expr_stmt|;
try|try
block|{
name|clazz
operator|=
name|getResourceLoader
argument_list|()
operator|.
name|findClass
argument_list|(
name|className
argument_list|,
name|UpdateHandler
operator|.
name|class
argument_list|)
expr_stmt|;
comment|//most of the classes do not have constructors which takes SolrCore argument. It is recommended to obtain SolrCore by implementing SolrCoreAware.
comment|// So invariably always it will cause a  NoSuchMethodException. So iterate though the list of available constructors
name|Constructor
argument_list|<
name|?
argument_list|>
index|[]
name|cons
init|=
name|clazz
operator|.
name|getConstructors
argument_list|()
decl_stmt|;
for|for
control|(
name|Constructor
argument_list|<
name|?
argument_list|>
name|con
range|:
name|cons
control|)
block|{
name|Class
argument_list|<
name|?
argument_list|>
index|[]
name|types
init|=
name|con
operator|.
name|getParameterTypes
argument_list|()
decl_stmt|;
if|if
condition|(
name|types
operator|.
name|length
operator|==
literal|2
operator|&&
name|types
index|[
literal|0
index|]
operator|==
name|SolrCore
operator|.
name|class
operator|&&
name|types
index|[
literal|1
index|]
operator|==
name|UpdateHandler
operator|.
name|class
condition|)
block|{
return|return
name|UpdateHandler
operator|.
name|class
operator|.
name|cast
argument_list|(
name|con
operator|.
name|newInstance
argument_list|(
name|this
argument_list|,
name|updateHandler
argument_list|)
argument_list|)
return|;
block|}
block|}
throw|throw
operator|new
name|SolrException
argument_list|(
name|SolrException
operator|.
name|ErrorCode
operator|.
name|SERVER_ERROR
argument_list|,
literal|"Error Instantiating "
operator|+
name|msg
operator|+
literal|", "
operator|+
name|className
operator|+
literal|" could not find proper constructor for "
operator|+
name|UpdateHandler
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|SolrException
name|e
parameter_list|)
block|{
throw|throw
name|e
throw|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
comment|// The JVM likes to wrap our helpful SolrExceptions in things like
comment|// "InvocationTargetException" that have no useful getMessage
if|if
condition|(
literal|null
operator|!=
name|e
operator|.
name|getCause
argument_list|()
operator|&&
name|e
operator|.
name|getCause
argument_list|()
operator|instanceof
name|SolrException
condition|)
block|{
name|SolrException
name|inner
init|=
operator|(
name|SolrException
operator|)
name|e
operator|.
name|getCause
argument_list|()
decl_stmt|;
throw|throw
name|inner
throw|;
block|}
throw|throw
operator|new
name|SolrException
argument_list|(
name|SolrException
operator|.
name|ErrorCode
operator|.
name|SERVER_ERROR
argument_list|,
literal|"Error Instantiating "
operator|+
name|msg
operator|+
literal|", "
operator|+
name|className
operator|+
literal|" failed to instantiate "
operator|+
name|UpdateHandler
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
DECL|method|createInitInstance
specifier|public
parameter_list|<
name|T
extends|extends
name|Object
parameter_list|>
name|T
name|createInitInstance
parameter_list|(
name|PluginInfo
name|info
parameter_list|,
name|Class
argument_list|<
name|T
argument_list|>
name|cast
parameter_list|,
name|String
name|msg
parameter_list|,
name|String
name|defClassName
parameter_list|)
block|{
if|if
condition|(
name|info
operator|==
literal|null
condition|)
return|return
literal|null
return|;
name|T
name|o
init|=
name|createInstance
argument_list|(
name|info
operator|.
name|className
operator|==
literal|null
condition|?
name|defClassName
else|:
name|info
operator|.
name|className
argument_list|,
name|cast
argument_list|,
name|msg
argument_list|,
name|this
argument_list|,
name|getResourceLoader
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|o
operator|instanceof
name|PluginInfoInitialized
condition|)
block|{
operator|(
operator|(
name|PluginInfoInitialized
operator|)
name|o
operator|)
operator|.
name|init
argument_list|(
name|info
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|o
operator|instanceof
name|NamedListInitializedPlugin
condition|)
block|{
operator|(
operator|(
name|NamedListInitializedPlugin
operator|)
name|o
operator|)
operator|.
name|init
argument_list|(
name|info
operator|.
name|initArgs
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|o
operator|instanceof
name|SearchComponent
condition|)
block|{
operator|(
operator|(
name|SearchComponent
operator|)
name|o
operator|)
operator|.
name|setName
argument_list|(
name|info
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
return|return
name|o
return|;
block|}
DECL|method|createUpdateHandler
specifier|private
name|UpdateHandler
name|createUpdateHandler
parameter_list|(
name|String
name|className
parameter_list|)
block|{
return|return
name|createInstance
argument_list|(
name|className
argument_list|,
name|UpdateHandler
operator|.
name|class
argument_list|,
literal|"Update Handler"
argument_list|,
name|this
argument_list|,
name|getResourceLoader
argument_list|()
argument_list|)
return|;
block|}
DECL|method|createUpdateHandler
specifier|private
name|UpdateHandler
name|createUpdateHandler
parameter_list|(
name|String
name|className
parameter_list|,
name|UpdateHandler
name|updateHandler
parameter_list|)
block|{
return|return
name|createReloadedUpdateHandler
argument_list|(
name|className
argument_list|,
literal|"Update Handler"
argument_list|,
name|updateHandler
argument_list|)
return|;
block|}
comment|/**    * Creates a new core and register it in the list of cores.    * If a core with the same name already exists, it will be stopped and replaced by this one.    *    * @param dataDir the index directory    * @param config a solr config instance    * @param schema a solr schema instance    *    * @since solr 1.3    */
DECL|method|SolrCore
specifier|public
name|SolrCore
parameter_list|(
name|String
name|name
parameter_list|,
name|String
name|dataDir
parameter_list|,
name|SolrConfig
name|config
parameter_list|,
name|IndexSchema
name|schema
parameter_list|,
name|CoreDescriptor
name|cd
parameter_list|)
block|{
name|this
argument_list|(
name|name
argument_list|,
name|dataDir
argument_list|,
name|config
argument_list|,
name|schema
argument_list|,
name|cd
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
DECL|method|SolrCore
specifier|public
name|SolrCore
parameter_list|(
name|CoreDescriptor
name|cd
parameter_list|,
name|ConfigSet
name|coreConfig
parameter_list|)
block|{
name|this
argument_list|(
name|cd
operator|.
name|getName
argument_list|()
argument_list|,
literal|null
argument_list|,
name|coreConfig
operator|.
name|getSolrConfig
argument_list|()
argument_list|,
name|coreConfig
operator|.
name|getIndexSchema
argument_list|()
argument_list|,
name|cd
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/**    * Creates a new core that is to be loaded lazily. i.e. lazyLoad="true" in solr.xml    * @since solr 4.1    */
DECL|method|SolrCore
specifier|public
name|SolrCore
parameter_list|(
name|String
name|name
parameter_list|,
name|CoreDescriptor
name|cd
parameter_list|)
block|{
name|coreDescriptor
operator|=
name|cd
expr_stmt|;
name|this
operator|.
name|setName
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|this
operator|.
name|schema
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|dataDir
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|ulogDir
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|solrConfig
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|startTime
operator|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
expr_stmt|;
name|this
operator|.
name|maxWarmingSearchers
operator|=
literal|2
expr_stmt|;
comment|// we don't have a config yet, just pick a number.
name|this
operator|.
name|slowQueryThresholdMillis
operator|=
operator|-
literal|1
expr_stmt|;
name|this
operator|.
name|resourceLoader
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|updateHandler
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|isReloaded
operator|=
literal|true
expr_stmt|;
name|this
operator|.
name|reqHandlers
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|updateProcessorChains
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|infoRegistry
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|codec
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|ruleExpiryLock
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|memClassLoader
operator|=
literal|null
expr_stmt|;
name|solrCoreState
operator|=
literal|null
expr_stmt|;
block|}
comment|/**    * Creates a new core and register it in the list of cores.    * If a core with the same name already exists, it will be stopped and replaced by this one.    *@param dataDir the index directory    *@param config a solr config instance    *@param schema a solr schema instance    *    *@since solr 1.3    */
DECL|method|SolrCore
specifier|public
name|SolrCore
parameter_list|(
name|String
name|name
parameter_list|,
name|String
name|dataDir
parameter_list|,
name|SolrConfig
name|config
parameter_list|,
name|IndexSchema
name|schema
parameter_list|,
name|CoreDescriptor
name|cd
parameter_list|,
name|UpdateHandler
name|updateHandler
parameter_list|,
name|IndexDeletionPolicyWrapper
name|delPolicy
parameter_list|,
name|SolrCore
name|prev
parameter_list|)
block|{
name|coreDescriptor
operator|=
name|cd
expr_stmt|;
name|this
operator|.
name|setName
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|resourceLoader
operator|=
name|config
operator|.
name|getResourceLoader
argument_list|()
expr_stmt|;
name|this
operator|.
name|solrConfig
operator|=
name|config
expr_stmt|;
if|if
condition|(
name|updateHandler
operator|==
literal|null
condition|)
block|{
name|initDirectoryFactory
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|dataDir
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|cd
operator|.
name|usingDefaultDataDir
argument_list|()
condition|)
name|dataDir
operator|=
name|config
operator|.
name|getDataDir
argument_list|()
expr_stmt|;
if|if
condition|(
name|dataDir
operator|==
literal|null
condition|)
block|{
try|try
block|{
name|dataDir
operator|=
name|cd
operator|.
name|getDataDir
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|directoryFactory
operator|.
name|isAbsolute
argument_list|(
name|dataDir
argument_list|)
condition|)
block|{
name|dataDir
operator|=
name|directoryFactory
operator|.
name|getDataHome
argument_list|(
name|cd
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|SolrException
operator|.
name|ErrorCode
operator|.
name|SERVER_ERROR
argument_list|,
literal|null
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
block|}
name|dataDir
operator|=
name|SolrResourceLoader
operator|.
name|normalizeDir
argument_list|(
name|dataDir
argument_list|)
expr_stmt|;
name|String
name|updateLogDir
init|=
name|cd
operator|.
name|getUlogDir
argument_list|()
decl_stmt|;
if|if
condition|(
name|updateLogDir
operator|==
literal|null
condition|)
block|{
name|updateLogDir
operator|=
name|dataDir
expr_stmt|;
if|if
condition|(
operator|new
name|File
argument_list|(
name|updateLogDir
argument_list|)
operator|.
name|isAbsolute
argument_list|()
operator|==
literal|false
condition|)
block|{
name|updateLogDir
operator|=
name|SolrResourceLoader
operator|.
name|normalizeDir
argument_list|(
name|cd
operator|.
name|getInstanceDir
argument_list|()
argument_list|)
operator|+
name|updateLogDir
expr_stmt|;
block|}
block|}
name|ulogDir
operator|=
name|updateLogDir
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
name|logid
operator|+
literal|"Opening new SolrCore at "
operator|+
name|resourceLoader
operator|.
name|getInstanceDir
argument_list|()
operator|+
literal|", dataDir="
operator|+
name|dataDir
argument_list|)
expr_stmt|;
if|if
condition|(
literal|null
operator|!=
name|cd
operator|&&
literal|null
operator|!=
name|cd
operator|.
name|getCloudDescriptor
argument_list|()
condition|)
block|{
comment|// we are evidently running in cloud mode.
comment|//
comment|// In cloud mode, version field is required for correct consistency
comment|// ideally this check would be more fine grained, and individual features
comment|// would assert it when they initialize, but DistributedUpdateProcessor
comment|// is currently a big ball of wax that does more then just distributing
comment|// updates (ie: partial document updates), so it needs to work in no cloud
comment|// mode as well, and can't assert version field support on init.
try|try
block|{
name|VersionInfo
operator|.
name|getAndCheckVersionField
argument_list|(
name|schema
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SolrException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|SolrException
operator|.
name|ErrorCode
operator|.
name|SERVER_ERROR
argument_list|,
literal|"Schema will not work with SolrCloud mode: "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
comment|//Initialize JMX
if|if
condition|(
name|config
operator|.
name|jmxConfig
operator|.
name|enabled
condition|)
block|{
name|infoRegistry
operator|=
operator|new
name|JmxMonitoredMap
argument_list|<
name|String
argument_list|,
name|SolrInfoMBean
argument_list|>
argument_list|(
name|name
argument_list|,
name|String
operator|.
name|valueOf
argument_list|(
name|this
operator|.
name|hashCode
argument_list|()
argument_list|)
argument_list|,
name|config
operator|.
name|jmxConfig
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|log
operator|.
name|info
argument_list|(
literal|"JMX monitoring not detected for core: "
operator|+
name|name
argument_list|)
expr_stmt|;
name|infoRegistry
operator|=
operator|new
name|ConcurrentHashMap
argument_list|<>
argument_list|()
expr_stmt|;
block|}
name|infoRegistry
operator|.
name|put
argument_list|(
literal|"fieldCache"
argument_list|,
operator|new
name|SolrFieldCacheMBean
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|schema
operator|==
literal|null
condition|)
block|{
name|schema
operator|=
name|IndexSchemaFactory
operator|.
name|buildIndexSchema
argument_list|(
name|IndexSchema
operator|.
name|DEFAULT_SCHEMA_FILE
argument_list|,
name|config
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|schema
operator|=
name|schema
expr_stmt|;
specifier|final
name|SimilarityFactory
name|similarityFactory
init|=
name|schema
operator|.
name|getSimilarityFactory
argument_list|()
decl_stmt|;
if|if
condition|(
name|similarityFactory
operator|instanceof
name|SolrCoreAware
condition|)
block|{
comment|// Similarity needs SolrCore before inform() is called on all registered SolrCoreAware listeners below
operator|(
operator|(
name|SolrCoreAware
operator|)
name|similarityFactory
operator|)
operator|.
name|inform
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|dataDir
operator|=
name|dataDir
expr_stmt|;
name|this
operator|.
name|startTime
operator|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
expr_stmt|;
name|this
operator|.
name|maxWarmingSearchers
operator|=
name|config
operator|.
name|maxWarmingSearchers
expr_stmt|;
name|this
operator|.
name|slowQueryThresholdMillis
operator|=
name|config
operator|.
name|slowQueryThresholdMillis
expr_stmt|;
name|booleanQueryMaxClauseCount
argument_list|()
expr_stmt|;
specifier|final
name|CountDownLatch
name|latch
init|=
operator|new
name|CountDownLatch
argument_list|(
literal|1
argument_list|)
decl_stmt|;
try|try
block|{
name|initListeners
argument_list|()
expr_stmt|;
if|if
condition|(
name|delPolicy
operator|==
literal|null
condition|)
block|{
name|initDeletionPolicy
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|this
operator|.
name|solrDelPolicy
operator|=
name|delPolicy
expr_stmt|;
block|}
name|this
operator|.
name|codec
operator|=
name|initCodec
argument_list|(
name|solrConfig
argument_list|,
name|schema
argument_list|)
expr_stmt|;
if|if
condition|(
name|updateHandler
operator|==
literal|null
condition|)
block|{
name|solrCoreState
operator|=
operator|new
name|DefaultSolrCoreState
argument_list|(
name|getDirectoryFactory
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|solrCoreState
operator|=
name|updateHandler
operator|.
name|getSolrCoreState
argument_list|()
expr_stmt|;
name|directoryFactory
operator|=
name|solrCoreState
operator|.
name|getDirectoryFactory
argument_list|()
expr_stmt|;
name|this
operator|.
name|isReloaded
operator|=
literal|true
expr_stmt|;
block|}
name|memClassLoader
operator|=
operator|new
name|MemClassLoader
argument_list|(
name|PluginBag
operator|.
name|RuntimeLib
operator|.
name|getLibObjects
argument_list|(
name|this
argument_list|,
name|solrConfig
operator|.
name|getPluginInfos
argument_list|(
name|PluginBag
operator|.
name|RuntimeLib
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
argument_list|)
argument_list|,
name|getResourceLoader
argument_list|()
argument_list|)
expr_stmt|;
name|initIndex
argument_list|(
name|prev
operator|!=
literal|null
argument_list|)
expr_stmt|;
name|initWriters
argument_list|()
expr_stmt|;
name|qParserPlugins
operator|.
name|init
argument_list|(
name|createInstances
argument_list|(
name|QParserPlugin
operator|.
name|standardPlugins
argument_list|)
argument_list|,
name|this
argument_list|)
expr_stmt|;
name|valueSourceParsers
operator|.
name|init
argument_list|(
name|ValueSourceParser
operator|.
name|standardValueSourceParsers
argument_list|,
name|this
argument_list|)
expr_stmt|;
name|transformerFactories
operator|.
name|init
argument_list|(
name|TransformerFactory
operator|.
name|defaultFactories
argument_list|,
name|this
argument_list|)
expr_stmt|;
name|loadSearchComponents
argument_list|()
expr_stmt|;
name|updateProcessors
operator|.
name|init
argument_list|(
name|Collections
operator|.
name|EMPTY_MAP
argument_list|,
name|this
argument_list|)
expr_stmt|;
comment|// Processors initialized before the handlers
name|updateProcessorChains
operator|=
name|loadUpdateProcessorChains
argument_list|()
expr_stmt|;
name|reqHandlers
operator|=
operator|new
name|RequestHandlers
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|reqHandlers
operator|.
name|initHandlersFromConfig
argument_list|(
name|solrConfig
argument_list|)
expr_stmt|;
comment|// Handle things that should eventually go away
name|initDeprecatedSupport
argument_list|()
expr_stmt|;
name|statsCache
operator|=
name|initStatsCache
argument_list|()
expr_stmt|;
comment|// cause the executor to stall so firstSearcher events won't fire
comment|// until after inform() has been called for all components.
comment|// searchExecutor must be single-threaded for this to work
name|searcherExecutor
operator|.
name|submit
argument_list|(
operator|new
name|Callable
argument_list|<
name|Void
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Void
name|call
parameter_list|()
throws|throws
name|Exception
block|{
name|latch
operator|.
name|await
argument_list|()
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
argument_list|)
expr_stmt|;
comment|// use the (old) writer to open the first searcher
name|RefCounted
argument_list|<
name|IndexWriter
argument_list|>
name|iwRef
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|prev
operator|!=
literal|null
condition|)
block|{
name|iwRef
operator|=
name|prev
operator|.
name|getUpdateHandler
argument_list|()
operator|.
name|getSolrCoreState
argument_list|()
operator|.
name|getIndexWriter
argument_list|(
literal|null
argument_list|)
expr_stmt|;
if|if
condition|(
name|iwRef
operator|!=
literal|null
condition|)
block|{
specifier|final
name|IndexWriter
name|iw
init|=
name|iwRef
operator|.
name|get
argument_list|()
decl_stmt|;
specifier|final
name|SolrCore
name|core
init|=
name|this
decl_stmt|;
name|newReaderCreator
operator|=
operator|new
name|Callable
argument_list|<
name|DirectoryReader
argument_list|>
argument_list|()
block|{
comment|// this is used during a core reload
annotation|@
name|Override
specifier|public
name|DirectoryReader
name|call
parameter_list|()
throws|throws
name|Exception
block|{
return|return
name|indexReaderFactory
operator|.
name|newReader
argument_list|(
name|iw
argument_list|,
name|core
argument_list|)
return|;
block|}
block|}
expr_stmt|;
block|}
block|}
name|String
name|updateHandlerClass
init|=
name|solrConfig
operator|.
name|getUpdateHandlerInfo
argument_list|()
operator|.
name|className
decl_stmt|;
if|if
condition|(
name|updateHandler
operator|==
literal|null
condition|)
block|{
name|this
operator|.
name|updateHandler
operator|=
name|createUpdateHandler
argument_list|(
name|updateHandlerClass
operator|==
literal|null
condition|?
name|DirectUpdateHandler2
operator|.
name|class
operator|.
name|getName
argument_list|()
else|:
name|updateHandlerClass
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|this
operator|.
name|updateHandler
operator|=
name|createUpdateHandler
argument_list|(
name|updateHandlerClass
operator|==
literal|null
condition|?
name|DirectUpdateHandler2
operator|.
name|class
operator|.
name|getName
argument_list|()
else|:
name|updateHandlerClass
argument_list|,
name|updateHandler
argument_list|)
expr_stmt|;
block|}
name|infoRegistry
operator|.
name|put
argument_list|(
literal|"updateHandler"
argument_list|,
name|this
operator|.
name|updateHandler
argument_list|)
expr_stmt|;
try|try
block|{
name|getSearcher
argument_list|(
literal|false
argument_list|,
literal|false
argument_list|,
literal|null
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|newReaderCreator
operator|=
literal|null
expr_stmt|;
if|if
condition|(
name|iwRef
operator|!=
literal|null
condition|)
name|iwRef
operator|.
name|decref
argument_list|()
expr_stmt|;
block|}
comment|// Initialize the RestManager
name|restManager
operator|=
name|initRestManager
argument_list|()
expr_stmt|;
comment|// Finally tell anyone who wants to know
name|resourceLoader
operator|.
name|inform
argument_list|(
name|resourceLoader
argument_list|)
expr_stmt|;
name|resourceLoader
operator|.
name|inform
argument_list|(
name|this
argument_list|)
expr_stmt|;
comment|// last call before the latch is released.
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|latch
operator|.
name|countDown
argument_list|()
expr_stmt|;
comment|//release the latch, otherwise we block trying to do the close.  This should be fine, since counting down on a latch of 0 is still fine
comment|//close down the searcher and any other resources, if it exists, as this is not recoverable
if|if
condition|(
name|e
operator|instanceof
name|OutOfMemoryError
condition|)
block|{
throw|throw
operator|(
name|OutOfMemoryError
operator|)
name|e
throw|;
block|}
try|try
block|{
name|this
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
if|if
condition|(
name|t
operator|instanceof
name|OutOfMemoryError
condition|)
block|{
throw|throw
operator|(
name|OutOfMemoryError
operator|)
name|t
throw|;
block|}
name|log
operator|.
name|error
argument_list|(
literal|"Error while closing"
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
throw|throw
operator|new
name|SolrException
argument_list|(
name|SolrException
operator|.
name|ErrorCode
operator|.
name|SERVER_ERROR
argument_list|,
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
finally|finally
block|{
comment|// allow firstSearcher events to fire and make sure it is released
name|latch
operator|.
name|countDown
argument_list|()
expr_stmt|;
block|}
name|infoRegistry
operator|.
name|put
argument_list|(
literal|"core"
argument_list|,
name|this
argument_list|)
expr_stmt|;
comment|// register any SolrInfoMBeans SolrResourceLoader initialized
comment|//
comment|// this must happen after the latch is released, because a JMX server impl may
comment|// choose to block on registering until properties can be fetched from an MBean,
comment|// and a SolrCoreAware MBean may have properties that depend on getting a Searcher
comment|// from the core.
name|resourceLoader
operator|.
name|inform
argument_list|(
name|infoRegistry
argument_list|)
expr_stmt|;
name|CoreContainer
name|cc
init|=
name|cd
operator|.
name|getCoreContainer
argument_list|()
decl_stmt|;
if|if
condition|(
name|cc
operator|!=
literal|null
operator|&&
name|cc
operator|.
name|isZooKeeperAware
argument_list|()
condition|)
block|{
name|SolrRequestHandler
name|realtimeGetHandler
init|=
name|reqHandlers
operator|.
name|get
argument_list|(
literal|"/get"
argument_list|)
decl_stmt|;
if|if
condition|(
name|realtimeGetHandler
operator|==
literal|null
condition|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"WARNING: RealTimeGetHandler is not registered at /get. "
operator|+
literal|"SolrCloud will always use full index replication instead of the more efficient PeerSync method."
argument_list|)
expr_stmt|;
block|}
comment|// ZK pre-Register would have already happened so we read slice properties now
name|ClusterState
name|clusterState
init|=
name|cc
operator|.
name|getZkController
argument_list|()
operator|.
name|getClusterState
argument_list|()
decl_stmt|;
name|Slice
name|slice
init|=
name|clusterState
operator|.
name|getSlice
argument_list|(
name|cd
operator|.
name|getCloudDescriptor
argument_list|()
operator|.
name|getCollectionName
argument_list|()
argument_list|,
name|cd
operator|.
name|getCloudDescriptor
argument_list|()
operator|.
name|getShardId
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|Slice
operator|.
name|CONSTRUCTION
operator|.
name|equals
argument_list|(
name|slice
operator|.
name|getState
argument_list|()
argument_list|)
condition|)
block|{
comment|// set update log to buffer before publishing the core
name|getUpdateHandler
argument_list|()
operator|.
name|getUpdateLog
argument_list|()
operator|.
name|bufferUpdates
argument_list|()
expr_stmt|;
block|}
block|}
comment|// For debugging
comment|//    numOpens.incrementAndGet();
comment|//    openHandles.put(this, new RuntimeException("unclosed core - name:" + getName() + " refs: " + refCount.get()));
name|ruleExpiryLock
operator|=
operator|new
name|ReentrantLock
argument_list|()
expr_stmt|;
name|registerConfListener
argument_list|()
expr_stmt|;
block|}
DECL|method|initCodec
specifier|private
name|Codec
name|initCodec
parameter_list|(
name|SolrConfig
name|solrConfig
parameter_list|,
specifier|final
name|IndexSchema
name|schema
parameter_list|)
block|{
specifier|final
name|PluginInfo
name|info
init|=
name|solrConfig
operator|.
name|getPluginInfo
argument_list|(
name|CodecFactory
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|CodecFactory
name|factory
decl_stmt|;
if|if
condition|(
name|info
operator|!=
literal|null
condition|)
block|{
name|factory
operator|=
name|schema
operator|.
name|getResourceLoader
argument_list|()
operator|.
name|newInstance
argument_list|(
name|info
operator|.
name|className
argument_list|,
name|CodecFactory
operator|.
name|class
argument_list|)
expr_stmt|;
name|factory
operator|.
name|init
argument_list|(
name|info
operator|.
name|initArgs
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|factory
operator|=
operator|new
name|CodecFactory
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Codec
name|getCodec
parameter_list|()
block|{
return|return
name|Codec
operator|.
name|getDefault
argument_list|()
return|;
block|}
block|}
expr_stmt|;
block|}
if|if
condition|(
name|factory
operator|instanceof
name|SolrCoreAware
condition|)
block|{
comment|// CodecFactory needs SolrCore before inform() is called on all registered
comment|// SolrCoreAware listeners, at the end of the SolrCore constructor
operator|(
operator|(
name|SolrCoreAware
operator|)
name|factory
operator|)
operator|.
name|inform
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|FieldType
name|ft
range|:
name|schema
operator|.
name|getFieldTypes
argument_list|()
operator|.
name|values
argument_list|()
control|)
block|{
if|if
condition|(
literal|null
operator|!=
name|ft
operator|.
name|getPostingsFormat
argument_list|()
condition|)
block|{
name|String
name|msg
init|=
literal|"FieldType '"
operator|+
name|ft
operator|.
name|getTypeName
argument_list|()
operator|+
literal|"' is configured with a postings format, but the codec does not support it: "
operator|+
name|factory
operator|.
name|getClass
argument_list|()
decl_stmt|;
name|log
operator|.
name|error
argument_list|(
name|msg
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|SolrException
argument_list|(
name|SolrException
operator|.
name|ErrorCode
operator|.
name|SERVER_ERROR
argument_list|,
name|msg
argument_list|)
throw|;
block|}
if|if
condition|(
literal|null
operator|!=
name|ft
operator|.
name|getDocValuesFormat
argument_list|()
condition|)
block|{
name|String
name|msg
init|=
literal|"FieldType '"
operator|+
name|ft
operator|.
name|getTypeName
argument_list|()
operator|+
literal|"' is configured with a docValues format, but the codec does not support it: "
operator|+
name|factory
operator|.
name|getClass
argument_list|()
decl_stmt|;
name|log
operator|.
name|error
argument_list|(
name|msg
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|SolrException
argument_list|(
name|SolrException
operator|.
name|ErrorCode
operator|.
name|SERVER_ERROR
argument_list|,
name|msg
argument_list|)
throw|;
block|}
block|}
block|}
return|return
name|factory
operator|.
name|getCodec
argument_list|()
return|;
block|}
DECL|method|initStatsCache
specifier|private
name|StatsCache
name|initStatsCache
parameter_list|()
block|{
specifier|final
name|StatsCache
name|cache
decl_stmt|;
name|PluginInfo
name|pluginInfo
init|=
name|solrConfig
operator|.
name|getPluginInfo
argument_list|(
name|StatsCache
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|pluginInfo
operator|!=
literal|null
operator|&&
name|pluginInfo
operator|.
name|className
operator|!=
literal|null
operator|&&
name|pluginInfo
operator|.
name|className
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
name|cache
operator|=
name|createInitInstance
argument_list|(
name|pluginInfo
argument_list|,
name|StatsCache
operator|.
name|class
argument_list|,
literal|null
argument_list|,
name|LocalStatsCache
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Using statsCache impl: "
operator|+
name|cache
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|log
operator|.
name|info
argument_list|(
literal|"Using default statsCache cache: "
operator|+
name|LocalStatsCache
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|cache
operator|=
operator|new
name|LocalStatsCache
argument_list|()
expr_stmt|;
block|}
return|return
name|cache
return|;
block|}
comment|/**    * Get the StatsCache.    */
DECL|method|getStatsCache
specifier|public
name|StatsCache
name|getStatsCache
parameter_list|()
block|{
return|return
name|statsCache
return|;
block|}
comment|/**    * Load the request processors    */
DECL|method|loadUpdateProcessorChains
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|UpdateRequestProcessorChain
argument_list|>
name|loadUpdateProcessorChains
parameter_list|()
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|UpdateRequestProcessorChain
argument_list|>
name|map
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|UpdateRequestProcessorChain
name|def
init|=
name|initPlugins
argument_list|(
name|map
argument_list|,
name|UpdateRequestProcessorChain
operator|.
name|class
argument_list|,
name|UpdateRequestProcessorChain
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|def
operator|==
literal|null
condition|)
block|{
name|def
operator|=
name|map
operator|.
name|get
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|def
operator|==
literal|null
condition|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"no updateRequestProcessorChain defined as default, creating implicit default"
argument_list|)
expr_stmt|;
comment|// construct the default chain
name|UpdateRequestProcessorFactory
index|[]
name|factories
init|=
operator|new
name|UpdateRequestProcessorFactory
index|[]
block|{
operator|new
name|LogUpdateProcessorFactory
argument_list|()
block|,
operator|new
name|DistributedUpdateProcessorFactory
argument_list|()
block|,
operator|new
name|RunUpdateProcessorFactory
argument_list|()
block|}
decl_stmt|;
name|def
operator|=
operator|new
name|UpdateRequestProcessorChain
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|factories
argument_list|)
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
name|map
operator|.
name|put
argument_list|(
literal|null
argument_list|,
name|def
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
literal|""
argument_list|,
name|def
argument_list|)
expr_stmt|;
return|return
name|map
return|;
block|}
DECL|method|getSolrCoreState
specifier|public
name|SolrCoreState
name|getSolrCoreState
parameter_list|()
block|{
return|return
name|solrCoreState
return|;
block|}
comment|/**    * @return an update processor registered to the given name.  Throw an exception if this chain is undefined    */
DECL|method|getUpdateProcessingChain
specifier|public
name|UpdateRequestProcessorChain
name|getUpdateProcessingChain
parameter_list|(
specifier|final
name|String
name|name
parameter_list|)
block|{
name|UpdateRequestProcessorChain
name|chain
init|=
name|updateProcessorChains
operator|.
name|get
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|chain
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|SolrException
operator|.
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
literal|"unknown UpdateRequestProcessorChain: "
operator|+
name|name
argument_list|)
throw|;
block|}
return|return
name|chain
return|;
block|}
DECL|method|getUpdateProcessorChain
specifier|public
name|UpdateRequestProcessorChain
name|getUpdateProcessorChain
parameter_list|(
name|SolrParams
name|params
parameter_list|)
block|{
name|String
name|chainName
init|=
name|params
operator|.
name|get
argument_list|(
name|UpdateParams
operator|.
name|UPDATE_CHAIN
argument_list|)
decl_stmt|;
name|UpdateRequestProcessorChain
name|defaultUrp
init|=
name|getUpdateProcessingChain
argument_list|(
name|chainName
argument_list|)
decl_stmt|;
name|ProcessorInfo
name|processorInfo
init|=
operator|new
name|ProcessorInfo
argument_list|(
name|params
argument_list|)
decl_stmt|;
if|if
condition|(
name|processorInfo
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|defaultUrp
return|;
return|return
name|UpdateRequestProcessorChain
operator|.
name|constructChain
argument_list|(
name|defaultUrp
argument_list|,
name|processorInfo
argument_list|,
name|this
argument_list|)
return|;
block|}
DECL|method|getUpdateProcessors
specifier|public
name|PluginBag
argument_list|<
name|UpdateRequestProcessorFactory
argument_list|>
name|getUpdateProcessors
parameter_list|()
block|{
return|return
name|updateProcessors
return|;
block|}
comment|// this core current usage count
DECL|field|refCount
specifier|private
specifier|final
name|AtomicInteger
name|refCount
init|=
operator|new
name|AtomicInteger
argument_list|(
literal|1
argument_list|)
decl_stmt|;
comment|/** expert: increments the core reference count */
DECL|method|open
specifier|public
name|void
name|open
parameter_list|()
block|{
name|refCount
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
block|}
comment|/**    * Close all resources allocated by the core if it is no longer in use...    *<ul>    *<li>searcher</li>    *<li>updateHandler</li>    *<li>all CloseHooks will be notified</li>    *<li>All MBeans will be unregistered from MBeanServer if JMX was enabled    *</li>    *</ul>    *<p>    * The behavior of this method is determined by the result of decrementing    * the core's reference count (A core is created with a reference count of 1)...    *</p>    *<ul>    *<li>If reference count is&gt; 0, the usage count is decreased by 1 and no    *       resources are released.    *</li>    *<li>If reference count is == 0, the resources are released.    *<li>If reference count is&lt; 0, and error is logged and no further action    *       is taken.    *</li>    *</ul>    * @see #isClosed()    */
DECL|method|close
specifier|public
name|void
name|close
parameter_list|()
block|{
name|int
name|count
init|=
name|refCount
operator|.
name|decrementAndGet
argument_list|()
decl_stmt|;
if|if
condition|(
name|count
operator|>
literal|0
condition|)
return|return;
comment|// close is called often, and only actually closes if nothing is using it.
if|if
condition|(
name|count
operator|<
literal|0
condition|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"Too many close [count:{}] on {}. Please report this exception to solr-user@lucene.apache.org"
argument_list|,
name|count
argument_list|,
name|this
argument_list|)
expr_stmt|;
assert|assert
literal|false
operator|:
literal|"Too many closes on SolrCore"
assert|;
return|return;
block|}
name|log
operator|.
name|info
argument_list|(
name|logid
operator|+
literal|" CLOSING SolrCore "
operator|+
name|this
argument_list|)
expr_stmt|;
if|if
condition|(
name|closeHooks
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|CloseHook
name|hook
range|:
name|closeHooks
control|)
block|{
try|try
block|{
name|hook
operator|.
name|preClose
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|SolrException
operator|.
name|log
argument_list|(
name|log
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|instanceof
name|Error
condition|)
block|{
throw|throw
operator|(
name|Error
operator|)
name|e
throw|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|reqHandlers
operator|!=
literal|null
condition|)
name|reqHandlers
operator|.
name|close
argument_list|()
expr_stmt|;
name|responseWriters
operator|.
name|close
argument_list|()
expr_stmt|;
name|searchComponents
operator|.
name|close
argument_list|()
expr_stmt|;
name|qParserPlugins
operator|.
name|close
argument_list|()
expr_stmt|;
name|valueSourceParsers
operator|.
name|close
argument_list|()
expr_stmt|;
name|transformerFactories
operator|.
name|close
argument_list|()
expr_stmt|;
if|if
condition|(
name|memClassLoader
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|memClassLoader
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{       }
block|}
try|try
block|{
if|if
condition|(
literal|null
operator|!=
name|updateHandler
condition|)
block|{
name|updateHandler
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|SolrException
operator|.
name|log
argument_list|(
name|log
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|instanceof
name|Error
condition|)
block|{
throw|throw
operator|(
name|Error
operator|)
name|e
throw|;
block|}
block|}
name|boolean
name|coreStateClosed
init|=
literal|false
decl_stmt|;
try|try
block|{
if|if
condition|(
name|solrCoreState
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|updateHandler
operator|instanceof
name|IndexWriterCloser
condition|)
block|{
name|coreStateClosed
operator|=
name|solrCoreState
operator|.
name|decrefSolrCoreState
argument_list|(
operator|(
name|IndexWriterCloser
operator|)
name|updateHandler
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|coreStateClosed
operator|=
name|solrCoreState
operator|.
name|decrefSolrCoreState
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|SolrException
operator|.
name|log
argument_list|(
name|log
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|instanceof
name|Error
condition|)
block|{
throw|throw
operator|(
name|Error
operator|)
name|e
throw|;
block|}
block|}
try|try
block|{
name|ExecutorUtil
operator|.
name|shutdownAndAwaitTermination
argument_list|(
name|searcherExecutor
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|SolrException
operator|.
name|log
argument_list|(
name|log
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|instanceof
name|Error
condition|)
block|{
throw|throw
operator|(
name|Error
operator|)
name|e
throw|;
block|}
block|}
try|try
block|{
comment|// Since we waited for the searcherExecutor to shut down,
comment|// there should be no more searchers warming in the background
comment|// that we need to take care of.
comment|//
comment|// For the case that a searcher was registered *before* warming
comment|// then the searchExecutor will throw an exception when getSearcher()
comment|// tries to use it, and the exception handling code should close it.
name|closeSearcher
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|SolrException
operator|.
name|log
argument_list|(
name|log
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|instanceof
name|Error
condition|)
block|{
throw|throw
operator|(
name|Error
operator|)
name|e
throw|;
block|}
block|}
try|try
block|{
name|infoRegistry
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|SolrException
operator|.
name|log
argument_list|(
name|log
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|instanceof
name|Error
condition|)
block|{
throw|throw
operator|(
name|Error
operator|)
name|e
throw|;
block|}
block|}
if|if
condition|(
name|coreStateClosed
condition|)
block|{
try|try
block|{
name|directoryFactory
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|SolrException
operator|.
name|log
argument_list|(
name|log
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|instanceof
name|Error
condition|)
block|{
throw|throw
operator|(
name|Error
operator|)
name|e
throw|;
block|}
block|}
block|}
if|if
condition|(
name|closeHooks
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|CloseHook
name|hook
range|:
name|closeHooks
control|)
block|{
try|try
block|{
name|hook
operator|.
name|postClose
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|SolrException
operator|.
name|log
argument_list|(
name|log
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|instanceof
name|Error
condition|)
block|{
throw|throw
operator|(
name|Error
operator|)
name|e
throw|;
block|}
block|}
block|}
block|}
comment|// For debugging
comment|//    numCloses.incrementAndGet();
comment|//    openHandles.remove(this);
block|}
comment|/** Current core usage count. */
DECL|method|getOpenCount
specifier|public
name|int
name|getOpenCount
parameter_list|()
block|{
return|return
name|refCount
operator|.
name|get
argument_list|()
return|;
block|}
comment|/** Whether this core is closed. */
DECL|method|isClosed
specifier|public
name|boolean
name|isClosed
parameter_list|()
block|{
return|return
name|refCount
operator|.
name|get
argument_list|()
operator|<=
literal|0
return|;
block|}
annotation|@
name|Override
DECL|method|finalize
specifier|protected
name|void
name|finalize
parameter_list|()
throws|throws
name|Throwable
block|{
try|try
block|{
if|if
condition|(
name|getOpenCount
argument_list|()
operator|!=
literal|0
condition|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"REFCOUNT ERROR: unreferenced "
operator|+
name|this
operator|+
literal|" ("
operator|+
name|getName
argument_list|()
operator|+
literal|") has a reference count of "
operator|+
name|getOpenCount
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|super
operator|.
name|finalize
argument_list|()
expr_stmt|;
block|}
block|}
DECL|field|closeHooks
specifier|private
name|Collection
argument_list|<
name|CloseHook
argument_list|>
name|closeHooks
init|=
literal|null
decl_stmt|;
comment|/**     * Add a close callback hook     */
DECL|method|addCloseHook
specifier|public
name|void
name|addCloseHook
parameter_list|(
name|CloseHook
name|hook
parameter_list|)
block|{
if|if
condition|(
name|closeHooks
operator|==
literal|null
condition|)
block|{
name|closeHooks
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
expr_stmt|;
block|}
name|closeHooks
operator|.
name|add
argument_list|(
name|hook
argument_list|)
expr_stmt|;
block|}
comment|/** @lucene.internal    *  Debugging aid only.  No non-test code should be released with uncommented verbose() calls.  */
DECL|field|VERBOSE
specifier|public
specifier|static
name|boolean
name|VERBOSE
init|=
name|Boolean
operator|.
name|parseBoolean
argument_list|(
name|System
operator|.
name|getProperty
argument_list|(
literal|"tests.verbose"
argument_list|,
literal|"false"
argument_list|)
argument_list|)
decl_stmt|;
DECL|method|verbose
specifier|public
specifier|static
name|void
name|verbose
parameter_list|(
name|Object
modifier|...
name|args
parameter_list|)
block|{
if|if
condition|(
operator|!
name|VERBOSE
condition|)
return|return;
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|(
literal|"VERBOSE:"
argument_list|)
decl_stmt|;
comment|//    sb.append(Thread.currentThread().getName());
comment|//    sb.append(':');
for|for
control|(
name|Object
name|o
range|:
name|args
control|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|o
operator|==
literal|null
condition|?
literal|"(null)"
else|:
name|o
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// System.out.println(sb.toString());
name|log
operator|.
name|info
argument_list|(
name|sb
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|////////////////////////////////////////////////////////////////////////////////
comment|// Request Handler
comment|////////////////////////////////////////////////////////////////////////////////
comment|/**    * Get the request handler registered to a given name.    *    * This function is thread safe.    */
DECL|method|getRequestHandler
specifier|public
name|SolrRequestHandler
name|getRequestHandler
parameter_list|(
name|String
name|handlerName
parameter_list|)
block|{
return|return
name|RequestHandlerBase
operator|.
name|getRequestHandler
argument_list|(
name|RequestHandlers
operator|.
name|normalize
argument_list|(
name|handlerName
argument_list|)
argument_list|,
name|reqHandlers
operator|.
name|handlers
argument_list|)
return|;
block|}
comment|/**    * Returns an unmodifiable Map containing the registered handlers    */
DECL|method|getRequestHandlers
specifier|public
name|PluginBag
argument_list|<
name|SolrRequestHandler
argument_list|>
name|getRequestHandlers
parameter_list|()
block|{
return|return
name|reqHandlers
operator|.
name|handlers
return|;
block|}
comment|/**    * Registers a handler at the specified location.  If one exists there, it will be replaced.    * To remove a handler, register<code>null</code> at its path    *    * Once registered the handler can be accessed through:    *<pre>    *   http://${host}:${port}/${context}/${handlerName}    * or:    *   http://${host}:${port}/${context}/select?qt=${handlerName}    *</pre>    *    * Handlers<em>must</em> be initialized before getting registered.  Registered    * handlers can immediately accept requests.    *    * This call is thread safe.    *    * @return the previous<code>SolrRequestHandler</code> registered to this name<code>null</code> if none.    */
DECL|method|registerRequestHandler
specifier|public
name|SolrRequestHandler
name|registerRequestHandler
parameter_list|(
name|String
name|handlerName
parameter_list|,
name|SolrRequestHandler
name|handler
parameter_list|)
block|{
return|return
name|reqHandlers
operator|.
name|register
argument_list|(
name|handlerName
argument_list|,
name|handler
argument_list|)
return|;
block|}
comment|/**    * Register the default search components    */
DECL|method|loadSearchComponents
specifier|private
name|void
name|loadSearchComponents
parameter_list|()
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|SearchComponent
argument_list|>
name|instances
init|=
name|createInstances
argument_list|(
name|SearchComponent
operator|.
name|standard_components
argument_list|)
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|SearchComponent
argument_list|>
name|e
range|:
name|instances
operator|.
name|entrySet
argument_list|()
control|)
name|e
operator|.
name|getValue
argument_list|()
operator|.
name|setName
argument_list|(
name|e
operator|.
name|getKey
argument_list|()
argument_list|)
expr_stmt|;
name|searchComponents
operator|.
name|init
argument_list|(
name|instances
argument_list|,
name|this
argument_list|)
expr_stmt|;
for|for
control|(
name|String
name|name
range|:
name|searchComponents
operator|.
name|keySet
argument_list|()
control|)
block|{
if|if
condition|(
name|searchComponents
operator|.
name|isLoaded
argument_list|(
name|name
argument_list|)
operator|&&
name|searchComponents
operator|.
name|get
argument_list|(
name|name
argument_list|)
operator|instanceof
name|HighlightComponent
condition|)
block|{
if|if
condition|(
operator|!
name|HighlightComponent
operator|.
name|COMPONENT_NAME
operator|.
name|equals
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|searchComponents
operator|.
name|put
argument_list|(
name|HighlightComponent
operator|.
name|COMPONENT_NAME
argument_list|,
name|searchComponents
operator|.
name|getRegistry
argument_list|()
operator|.
name|get
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
block|}
comment|/**    * @return a Search Component registered to a given name.  Throw an exception if the component is undefined    */
DECL|method|getSearchComponent
specifier|public
name|SearchComponent
name|getSearchComponent
parameter_list|(
name|String
name|name
parameter_list|)
block|{
return|return
name|searchComponents
operator|.
name|get
argument_list|(
name|name
argument_list|)
return|;
block|}
comment|/**    * Accessor for all the Search Components    * @return An unmodifiable Map of Search Components    */
DECL|method|getSearchComponents
specifier|public
name|PluginBag
argument_list|<
name|SearchComponent
argument_list|>
name|getSearchComponents
parameter_list|()
block|{
return|return
name|searchComponents
return|;
block|}
comment|////////////////////////////////////////////////////////////////////////////////
comment|// Update Handler
comment|////////////////////////////////////////////////////////////////////////////////
comment|/**    * RequestHandlers need access to the updateHandler so they can all talk to the    * same RAM indexer.    */
DECL|method|getUpdateHandler
specifier|public
name|UpdateHandler
name|getUpdateHandler
parameter_list|()
block|{
return|return
name|updateHandler
return|;
block|}
comment|////////////////////////////////////////////////////////////////////////////////
comment|// Searcher Control
comment|////////////////////////////////////////////////////////////////////////////////
comment|// The current searcher used to service queries.
comment|// Don't access this directly!!!! use getSearcher() to
comment|// get it (and it will increment the ref count at the same time).
comment|// This reference is protected by searcherLock.
DECL|field|_searcher
specifier|private
name|RefCounted
argument_list|<
name|SolrIndexSearcher
argument_list|>
name|_searcher
decl_stmt|;
comment|// All of the normal open searchers.  Don't access this directly.
comment|// protected by synchronizing on searcherLock.
DECL|field|_searchers
specifier|private
specifier|final
name|LinkedList
argument_list|<
name|RefCounted
argument_list|<
name|SolrIndexSearcher
argument_list|>
argument_list|>
name|_searchers
init|=
operator|new
name|LinkedList
argument_list|<>
argument_list|()
decl_stmt|;
DECL|field|_realtimeSearchers
specifier|private
specifier|final
name|LinkedList
argument_list|<
name|RefCounted
argument_list|<
name|SolrIndexSearcher
argument_list|>
argument_list|>
name|_realtimeSearchers
init|=
operator|new
name|LinkedList
argument_list|<>
argument_list|()
decl_stmt|;
DECL|field|searcherExecutor
specifier|final
name|ExecutorService
name|searcherExecutor
init|=
name|Executors
operator|.
name|newSingleThreadExecutor
argument_list|(
operator|new
name|DefaultSolrThreadFactory
argument_list|(
literal|"searcherExecutor"
argument_list|)
argument_list|)
decl_stmt|;
DECL|field|onDeckSearchers
specifier|private
name|int
name|onDeckSearchers
decl_stmt|;
comment|// number of searchers preparing
comment|// Lock ordering: one can acquire the openSearcherLock and then the searcherLock, but not vice-versa.
DECL|field|searcherLock
specifier|private
name|Object
name|searcherLock
init|=
operator|new
name|Object
argument_list|()
decl_stmt|;
comment|// the sync object for the searcher
DECL|field|openSearcherLock
specifier|private
name|ReentrantLock
name|openSearcherLock
init|=
operator|new
name|ReentrantLock
argument_list|(
literal|true
argument_list|)
decl_stmt|;
comment|// used to serialize opens/reopens for absolute ordering
DECL|field|maxWarmingSearchers
specifier|private
specifier|final
name|int
name|maxWarmingSearchers
decl_stmt|;
comment|// max number of on-deck searchers allowed
DECL|field|slowQueryThresholdMillis
specifier|private
specifier|final
name|int
name|slowQueryThresholdMillis
decl_stmt|;
comment|// threshold above which a query is considered slow
DECL|field|realtimeSearcher
specifier|private
name|RefCounted
argument_list|<
name|SolrIndexSearcher
argument_list|>
name|realtimeSearcher
decl_stmt|;
DECL|field|newReaderCreator
specifier|private
name|Callable
argument_list|<
name|DirectoryReader
argument_list|>
name|newReaderCreator
decl_stmt|;
comment|/**   * Return a registered {@link RefCounted}&lt;{@link SolrIndexSearcher}&gt; with   * the reference count incremented.  It<b>must</b> be decremented when no longer needed.   * This method should not be called from SolrCoreAware.inform() since it can result   * in a deadlock if useColdSearcher==false.   * If handling a normal request, the searcher should be obtained from    * {@link org.apache.solr.request.SolrQueryRequest#getSearcher()} instead.   */
DECL|method|getSearcher
specifier|public
name|RefCounted
argument_list|<
name|SolrIndexSearcher
argument_list|>
name|getSearcher
parameter_list|()
block|{
return|return
name|getSearcher
argument_list|(
literal|false
argument_list|,
literal|true
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/**   * Returns the current registered searcher with its reference count incremented, or null if none are registered.   */
DECL|method|getRegisteredSearcher
specifier|public
name|RefCounted
argument_list|<
name|SolrIndexSearcher
argument_list|>
name|getRegisteredSearcher
parameter_list|()
block|{
synchronized|synchronized
init|(
name|searcherLock
init|)
block|{
if|if
condition|(
name|_searcher
operator|!=
literal|null
condition|)
block|{
name|_searcher
operator|.
name|incref
argument_list|()
expr_stmt|;
block|}
return|return
name|_searcher
return|;
block|}
block|}
comment|/**    * Return the newest normal {@link RefCounted}&lt;{@link SolrIndexSearcher}&gt; with    * the reference count incremented.  It<b>must</b> be decremented when no longer needed.    * If no searcher is currently open, then if openNew==true a new searcher will be opened,    * or null is returned if openNew==false.    */
DECL|method|getNewestSearcher
specifier|public
name|RefCounted
argument_list|<
name|SolrIndexSearcher
argument_list|>
name|getNewestSearcher
parameter_list|(
name|boolean
name|openNew
parameter_list|)
block|{
synchronized|synchronized
init|(
name|searcherLock
init|)
block|{
if|if
condition|(
operator|!
name|_searchers
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|RefCounted
argument_list|<
name|SolrIndexSearcher
argument_list|>
name|newest
init|=
name|_searchers
operator|.
name|getLast
argument_list|()
decl_stmt|;
name|newest
operator|.
name|incref
argument_list|()
expr_stmt|;
return|return
name|newest
return|;
block|}
block|}
return|return
name|openNew
condition|?
name|getRealtimeSearcher
argument_list|()
else|:
literal|null
return|;
block|}
comment|/** Gets the latest real-time searcher w/o forcing open a new searcher if one already exists.    * The reference count will be incremented.    */
DECL|method|getRealtimeSearcher
specifier|public
name|RefCounted
argument_list|<
name|SolrIndexSearcher
argument_list|>
name|getRealtimeSearcher
parameter_list|()
block|{
synchronized|synchronized
init|(
name|searcherLock
init|)
block|{
if|if
condition|(
name|realtimeSearcher
operator|!=
literal|null
condition|)
block|{
name|realtimeSearcher
operator|.
name|incref
argument_list|()
expr_stmt|;
return|return
name|realtimeSearcher
return|;
block|}
block|}
comment|// use the searcher lock to prevent multiple people from trying to open at once
name|openSearcherLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
comment|// try again
synchronized|synchronized
init|(
name|searcherLock
init|)
block|{
if|if
condition|(
name|realtimeSearcher
operator|!=
literal|null
condition|)
block|{
name|realtimeSearcher
operator|.
name|incref
argument_list|()
expr_stmt|;
return|return
name|realtimeSearcher
return|;
block|}
block|}
comment|// force a new searcher open
return|return
name|openNewSearcher
argument_list|(
literal|true
argument_list|,
literal|true
argument_list|)
return|;
block|}
finally|finally
block|{
name|openSearcherLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|getSearcher
specifier|public
name|RefCounted
argument_list|<
name|SolrIndexSearcher
argument_list|>
name|getSearcher
parameter_list|(
name|boolean
name|forceNew
parameter_list|,
name|boolean
name|returnSearcher
parameter_list|,
specifier|final
name|Future
index|[]
name|waitSearcher
parameter_list|)
block|{
return|return
name|getSearcher
argument_list|(
name|forceNew
argument_list|,
name|returnSearcher
argument_list|,
name|waitSearcher
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/** Opens a new searcher and returns a RefCounted&lt;SolrIndexSearcher&gt; with its reference incremented.    *    * "realtime" means that we need to open quickly for a realtime view of the index, hence don't do any    * autowarming and add to the _realtimeSearchers queue rather than the _searchers queue (so it won't    * be used for autowarming by a future normal searcher).  A "realtime" searcher will currently never    * become "registered" (since it currently lacks caching).    *    * realtimeSearcher is updated to the latest opened searcher, regardless of the value of "realtime".    *    * This method acquires openSearcherLock - do not call with searckLock held!    */
DECL|method|openNewSearcher
specifier|public
name|RefCounted
argument_list|<
name|SolrIndexSearcher
argument_list|>
name|openNewSearcher
parameter_list|(
name|boolean
name|updateHandlerReopens
parameter_list|,
name|boolean
name|realtime
parameter_list|)
block|{
if|if
condition|(
name|isClosed
argument_list|()
condition|)
block|{
comment|// catch some errors quicker
throw|throw
operator|new
name|SolrException
argument_list|(
name|SolrException
operator|.
name|ErrorCode
operator|.
name|SERVER_ERROR
argument_list|,
literal|"openNewSearcher called on closed core"
argument_list|)
throw|;
block|}
name|SolrIndexSearcher
name|tmp
decl_stmt|;
name|RefCounted
argument_list|<
name|SolrIndexSearcher
argument_list|>
name|newestSearcher
init|=
literal|null
decl_stmt|;
name|openSearcherLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|String
name|newIndexDir
init|=
name|getNewIndexDir
argument_list|()
decl_stmt|;
name|String
name|indexDirFile
init|=
literal|null
decl_stmt|;
name|String
name|newIndexDirFile
init|=
literal|null
decl_stmt|;
comment|// if it's not a normal near-realtime update, check that paths haven't changed.
if|if
condition|(
operator|!
name|updateHandlerReopens
condition|)
block|{
name|indexDirFile
operator|=
name|getDirectoryFactory
argument_list|()
operator|.
name|normalize
argument_list|(
name|getIndexDir
argument_list|()
argument_list|)
expr_stmt|;
name|newIndexDirFile
operator|=
name|getDirectoryFactory
argument_list|()
operator|.
name|normalize
argument_list|(
name|newIndexDir
argument_list|)
expr_stmt|;
block|}
synchronized|synchronized
init|(
name|searcherLock
init|)
block|{
name|newestSearcher
operator|=
name|realtimeSearcher
expr_stmt|;
if|if
condition|(
name|newestSearcher
operator|!=
literal|null
condition|)
block|{
name|newestSearcher
operator|.
name|incref
argument_list|()
expr_stmt|;
comment|// the matching decref is in the finally block
block|}
block|}
if|if
condition|(
name|newestSearcher
operator|!=
literal|null
operator|&&
operator|(
name|updateHandlerReopens
operator|||
name|indexDirFile
operator|.
name|equals
argument_list|(
name|newIndexDirFile
argument_list|)
operator|)
condition|)
block|{
name|DirectoryReader
name|newReader
decl_stmt|;
name|DirectoryReader
name|currentReader
init|=
name|newestSearcher
operator|.
name|get
argument_list|()
operator|.
name|getRawReader
argument_list|()
decl_stmt|;
comment|// SolrCore.verbose("start reopen from",previousSearcher,"writer=",writer);
name|RefCounted
argument_list|<
name|IndexWriter
argument_list|>
name|writer
init|=
name|getUpdateHandler
argument_list|()
operator|.
name|getSolrCoreState
argument_list|()
operator|.
name|getIndexWriter
argument_list|(
literal|null
argument_list|)
decl_stmt|;
try|try
block|{
if|if
condition|(
name|writer
operator|!=
literal|null
condition|)
block|{
comment|// if in NRT mode, open from the writer
name|newReader
operator|=
name|DirectoryReader
operator|.
name|openIfChanged
argument_list|(
name|currentReader
argument_list|,
name|writer
operator|.
name|get
argument_list|()
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// verbose("start reopen without writer, reader=", currentReader);
name|newReader
operator|=
name|DirectoryReader
operator|.
name|openIfChanged
argument_list|(
name|currentReader
argument_list|)
expr_stmt|;
comment|// verbose("reopen result", newReader);
block|}
block|}
finally|finally
block|{
if|if
condition|(
name|writer
operator|!=
literal|null
condition|)
block|{
name|writer
operator|.
name|decref
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|newReader
operator|==
literal|null
condition|)
block|{
comment|// the underlying index has not changed at all
if|if
condition|(
name|realtime
condition|)
block|{
comment|// if this is a request for a realtime searcher, just return the same searcher
name|newestSearcher
operator|.
name|incref
argument_list|()
expr_stmt|;
return|return
name|newestSearcher
return|;
block|}
elseif|else
if|if
condition|(
name|newestSearcher
operator|.
name|get
argument_list|()
operator|.
name|isCachingEnabled
argument_list|()
operator|&&
name|newestSearcher
operator|.
name|get
argument_list|()
operator|.
name|getSchema
argument_list|()
operator|==
name|getLatestSchema
argument_list|()
condition|)
block|{
comment|// absolutely nothing has changed, can use the same searcher
comment|// but log a message about it to minimize confusion
name|newestSearcher
operator|.
name|incref
argument_list|()
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"SolrIndexSearcher has not changed - not re-opening: "
operator|+
name|newestSearcher
operator|.
name|get
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|newestSearcher
return|;
block|}
comment|// ELSE: open a new searcher against the old reader...
name|currentReader
operator|.
name|incRef
argument_list|()
expr_stmt|;
name|newReader
operator|=
name|currentReader
expr_stmt|;
block|}
comment|// for now, turn off caches if this is for a realtime reader
comment|// (caches take a little while to instantiate)
specifier|final
name|boolean
name|useCaches
init|=
operator|!
name|realtime
decl_stmt|;
specifier|final
name|String
name|newName
init|=
name|realtime
condition|?
literal|"realtime"
else|:
literal|"main"
decl_stmt|;
name|tmp
operator|=
operator|new
name|SolrIndexSearcher
argument_list|(
name|this
argument_list|,
name|newIndexDir
argument_list|,
name|getLatestSchema
argument_list|()
argument_list|,
name|newName
argument_list|,
name|newReader
argument_list|,
literal|true
argument_list|,
name|useCaches
argument_list|,
literal|true
argument_list|,
name|directoryFactory
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// newestSearcher == null at this point
if|if
condition|(
name|newReaderCreator
operator|!=
literal|null
condition|)
block|{
comment|// this is set in the constructor if there is a currently open index writer
comment|// so that we pick up any uncommitted changes and so we don't go backwards
comment|// in time on a core reload
name|DirectoryReader
name|newReader
init|=
name|newReaderCreator
operator|.
name|call
argument_list|()
decl_stmt|;
name|tmp
operator|=
operator|new
name|SolrIndexSearcher
argument_list|(
name|this
argument_list|,
name|newIndexDir
argument_list|,
name|getLatestSchema
argument_list|()
argument_list|,
operator|(
name|realtime
condition|?
literal|"realtime"
else|:
literal|"main"
operator|)
argument_list|,
name|newReader
argument_list|,
literal|true
argument_list|,
operator|!
name|realtime
argument_list|,
literal|true
argument_list|,
name|directoryFactory
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|RefCounted
argument_list|<
name|IndexWriter
argument_list|>
name|writer
init|=
name|getUpdateHandler
argument_list|()
operator|.
name|getSolrCoreState
argument_list|()
operator|.
name|getIndexWriter
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|DirectoryReader
name|newReader
init|=
literal|null
decl_stmt|;
try|try
block|{
name|newReader
operator|=
name|indexReaderFactory
operator|.
name|newReader
argument_list|(
name|writer
operator|.
name|get
argument_list|()
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|writer
operator|.
name|decref
argument_list|()
expr_stmt|;
block|}
name|tmp
operator|=
operator|new
name|SolrIndexSearcher
argument_list|(
name|this
argument_list|,
name|newIndexDir
argument_list|,
name|getLatestSchema
argument_list|()
argument_list|,
operator|(
name|realtime
condition|?
literal|"realtime"
else|:
literal|"main"
operator|)
argument_list|,
name|newReader
argument_list|,
literal|true
argument_list|,
operator|!
name|realtime
argument_list|,
literal|true
argument_list|,
name|directoryFactory
argument_list|)
expr_stmt|;
block|}
block|}
name|List
argument_list|<
name|RefCounted
argument_list|<
name|SolrIndexSearcher
argument_list|>
argument_list|>
name|searcherList
init|=
name|realtime
condition|?
name|_realtimeSearchers
else|:
name|_searchers
decl_stmt|;
name|RefCounted
argument_list|<
name|SolrIndexSearcher
argument_list|>
name|newSearcher
init|=
name|newHolder
argument_list|(
name|tmp
argument_list|,
name|searcherList
argument_list|)
decl_stmt|;
comment|// refcount now at 1
comment|// Increment reference again for "realtimeSearcher" variable.  It should be at 2 after.
comment|// When it's decremented by both the caller of this method, and by realtimeSearcher being replaced,
comment|// it will be closed.
name|newSearcher
operator|.
name|incref
argument_list|()
expr_stmt|;
synchronized|synchronized
init|(
name|searcherLock
init|)
block|{
if|if
condition|(
name|realtimeSearcher
operator|!=
literal|null
condition|)
block|{
name|realtimeSearcher
operator|.
name|decref
argument_list|()
expr_stmt|;
block|}
name|realtimeSearcher
operator|=
name|newSearcher
expr_stmt|;
name|searcherList
operator|.
name|add
argument_list|(
name|realtimeSearcher
argument_list|)
expr_stmt|;
block|}
return|return
name|newSearcher
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|SolrException
operator|.
name|ErrorCode
operator|.
name|SERVER_ERROR
argument_list|,
literal|"Error opening new searcher"
argument_list|,
name|e
argument_list|)
throw|;
block|}
finally|finally
block|{
name|openSearcherLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
if|if
condition|(
name|newestSearcher
operator|!=
literal|null
condition|)
block|{
name|newestSearcher
operator|.
name|decref
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Get a {@link SolrIndexSearcher} or start the process of creating a new one.    *<p>    * The registered searcher is the default searcher used to service queries.    * A searcher will normally be registered after all of the warming    * and event handlers (newSearcher or firstSearcher events) have run.    * In the case where there is no registered searcher, the newly created searcher will    * be registered before running the event handlers (a slow searcher is better than no searcher).    *    *<p>    * These searchers contain read-only IndexReaders. To access a non read-only IndexReader,    * see newSearcher(String name, boolean readOnly).    *    *<p>    * If<tt>forceNew==true</tt> then    *  A new searcher will be opened and registered regardless of whether there is already    *    a registered searcher or other searchers in the process of being created.    *<p>    * If<tt>forceNew==false</tt> then:<ul>    *<li>If a searcher is already registered, that searcher will be returned</li>    *<li>If no searcher is currently registered, but at least one is in the process of being created, then    * this call will block until the first searcher is registered</li>    *<li>If no searcher is currently registered, and no searchers in the process of being registered, a new    * searcher will be created.</li>    *</ul>    *<p>    * If<tt>returnSearcher==true</tt> then a {@link RefCounted}&lt;{@link SolrIndexSearcher}&gt; will be returned with    * the reference count incremented.  It<b>must</b> be decremented when no longer needed.    *<p>    * If<tt>waitSearcher!=null</tt> and a new {@link SolrIndexSearcher} was created,    * then it is filled in with a Future that will return after the searcher is registered.  The Future may be set to    *<tt>null</tt> in which case the SolrIndexSearcher created has already been registered at the time    * this method returned.    *<p>    * @param forceNew             if true, force the open of a new index searcher regardless if there is already one open.    * @param returnSearcher       if true, returns a {@link SolrIndexSearcher} holder with the refcount already incremented.    * @param waitSearcher         if non-null, will be filled in with a {@link Future} that will return after the new searcher is registered.    * @param updateHandlerReopens if true, the UpdateHandler will be used when reopening a {@link SolrIndexSearcher}.    */
DECL|method|getSearcher
specifier|public
name|RefCounted
argument_list|<
name|SolrIndexSearcher
argument_list|>
name|getSearcher
parameter_list|(
name|boolean
name|forceNew
parameter_list|,
name|boolean
name|returnSearcher
parameter_list|,
specifier|final
name|Future
index|[]
name|waitSearcher
parameter_list|,
name|boolean
name|updateHandlerReopens
parameter_list|)
block|{
comment|// it may take some time to open an index.... we may need to make
comment|// sure that two threads aren't trying to open one at the same time
comment|// if it isn't necessary.
synchronized|synchronized
init|(
name|searcherLock
init|)
block|{
comment|// see if we can return the current searcher
if|if
condition|(
name|_searcher
operator|!=
literal|null
operator|&&
operator|!
name|forceNew
condition|)
block|{
if|if
condition|(
name|returnSearcher
condition|)
block|{
name|_searcher
operator|.
name|incref
argument_list|()
expr_stmt|;
return|return
name|_searcher
return|;
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
comment|// check to see if we can wait for someone else's searcher to be set
if|if
condition|(
name|onDeckSearchers
operator|>
literal|0
operator|&&
operator|!
name|forceNew
operator|&&
name|_searcher
operator|==
literal|null
condition|)
block|{
try|try
block|{
name|searcherLock
operator|.
name|wait
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|log
operator|.
name|info
argument_list|(
name|SolrException
operator|.
name|toStr
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|// check again: see if we can return right now
if|if
condition|(
name|_searcher
operator|!=
literal|null
operator|&&
operator|!
name|forceNew
condition|)
block|{
if|if
condition|(
name|returnSearcher
condition|)
block|{
name|_searcher
operator|.
name|incref
argument_list|()
expr_stmt|;
return|return
name|_searcher
return|;
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
comment|// At this point, we know we need to open a new searcher...
comment|// first: increment count to signal other threads that we are
comment|//        opening a new searcher.
name|onDeckSearchers
operator|++
expr_stmt|;
if|if
condition|(
name|onDeckSearchers
operator|<
literal|1
condition|)
block|{
comment|// should never happen... just a sanity check
name|log
operator|.
name|error
argument_list|(
name|logid
operator|+
literal|"ERROR!!! onDeckSearchers is "
operator|+
name|onDeckSearchers
argument_list|)
expr_stmt|;
name|onDeckSearchers
operator|=
literal|1
expr_stmt|;
comment|// reset
block|}
elseif|else
if|if
condition|(
name|onDeckSearchers
operator|>
name|maxWarmingSearchers
condition|)
block|{
name|onDeckSearchers
operator|--
expr_stmt|;
name|String
name|msg
init|=
literal|"Error opening new searcher. exceeded limit of maxWarmingSearchers="
operator|+
name|maxWarmingSearchers
operator|+
literal|", try again later."
decl_stmt|;
name|log
operator|.
name|warn
argument_list|(
name|logid
operator|+
literal|""
operator|+
name|msg
argument_list|)
expr_stmt|;
comment|// HTTP 503==service unavailable, or 409==Conflict
throw|throw
operator|new
name|SolrException
argument_list|(
name|SolrException
operator|.
name|ErrorCode
operator|.
name|SERVICE_UNAVAILABLE
argument_list|,
name|msg
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
name|onDeckSearchers
operator|>
literal|1
condition|)
block|{
name|log
operator|.
name|warn
argument_list|(
name|logid
operator|+
literal|"PERFORMANCE WARNING: Overlapping onDeckSearchers="
operator|+
name|onDeckSearchers
argument_list|)
expr_stmt|;
block|}
block|}
comment|// a signal to decrement onDeckSearchers if something goes wrong.
specifier|final
name|boolean
index|[]
name|decrementOnDeckCount
init|=
operator|new
name|boolean
index|[]
block|{
literal|true
block|}
decl_stmt|;
name|RefCounted
argument_list|<
name|SolrIndexSearcher
argument_list|>
name|currSearcherHolder
init|=
literal|null
decl_stmt|;
comment|// searcher we are autowarming from
name|RefCounted
argument_list|<
name|SolrIndexSearcher
argument_list|>
name|searchHolder
init|=
literal|null
decl_stmt|;
name|boolean
name|success
init|=
literal|false
decl_stmt|;
name|openSearcherLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|searchHolder
operator|=
name|openNewSearcher
argument_list|(
name|updateHandlerReopens
argument_list|,
literal|false
argument_list|)
expr_stmt|;
comment|// the searchHolder will be incremented once already (and it will eventually be assigned to _searcher when registered)
comment|// increment it again if we are going to return it to the caller.
if|if
condition|(
name|returnSearcher
condition|)
block|{
name|searchHolder
operator|.
name|incref
argument_list|()
expr_stmt|;
block|}
specifier|final
name|RefCounted
argument_list|<
name|SolrIndexSearcher
argument_list|>
name|newSearchHolder
init|=
name|searchHolder
decl_stmt|;
specifier|final
name|SolrIndexSearcher
name|newSearcher
init|=
name|newSearchHolder
operator|.
name|get
argument_list|()
decl_stmt|;
name|boolean
name|alreadyRegistered
init|=
literal|false
decl_stmt|;
synchronized|synchronized
init|(
name|searcherLock
init|)
block|{
if|if
condition|(
name|_searcher
operator|==
literal|null
condition|)
block|{
comment|// if there isn't a current searcher then we may
comment|// want to register this one before warming is complete instead of waiting.
if|if
condition|(
name|solrConfig
operator|.
name|useColdSearcher
condition|)
block|{
name|registerSearcher
argument_list|(
name|newSearchHolder
argument_list|)
expr_stmt|;
name|decrementOnDeckCount
index|[
literal|0
index|]
operator|=
literal|false
expr_stmt|;
name|alreadyRegistered
operator|=
literal|true
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// get a reference to the current searcher for purposes of autowarming.
name|currSearcherHolder
operator|=
name|_searcher
expr_stmt|;
name|currSearcherHolder
operator|.
name|incref
argument_list|()
expr_stmt|;
block|}
block|}
specifier|final
name|SolrIndexSearcher
name|currSearcher
init|=
name|currSearcherHolder
operator|==
literal|null
condition|?
literal|null
else|:
name|currSearcherHolder
operator|.
name|get
argument_list|()
decl_stmt|;
name|Future
name|future
init|=
literal|null
decl_stmt|;
comment|// if the underlying seracher has not changed, no warming is needed
if|if
condition|(
name|newSearcher
operator|!=
name|currSearcher
condition|)
block|{
comment|// warm the new searcher based on the current searcher.
comment|// should this go before the other event handlers or after?
if|if
condition|(
name|currSearcher
operator|!=
literal|null
condition|)
block|{
name|future
operator|=
name|searcherExecutor
operator|.
name|submit
argument_list|(
operator|new
name|Callable
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Object
name|call
parameter_list|()
throws|throws
name|Exception
block|{
try|try
block|{
name|newSearcher
operator|.
name|warm
argument_list|(
name|currSearcher
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|SolrException
operator|.
name|log
argument_list|(
name|log
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|instanceof
name|Error
condition|)
block|{
throw|throw
operator|(
name|Error
operator|)
name|e
throw|;
block|}
block|}
return|return
literal|null
return|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|currSearcher
operator|==
literal|null
condition|)
block|{
name|future
operator|=
name|searcherExecutor
operator|.
name|submit
argument_list|(
operator|new
name|Callable
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Object
name|call
parameter_list|()
throws|throws
name|Exception
block|{
try|try
block|{
for|for
control|(
name|SolrEventListener
name|listener
range|:
name|firstSearcherListeners
control|)
block|{
name|listener
operator|.
name|newSearcher
argument_list|(
name|newSearcher
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|SolrException
operator|.
name|log
argument_list|(
name|log
argument_list|,
literal|null
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|instanceof
name|Error
condition|)
block|{
throw|throw
operator|(
name|Error
operator|)
name|e
throw|;
block|}
block|}
return|return
literal|null
return|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|currSearcher
operator|!=
literal|null
condition|)
block|{
name|future
operator|=
name|searcherExecutor
operator|.
name|submit
argument_list|(
operator|new
name|Callable
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Object
name|call
parameter_list|()
throws|throws
name|Exception
block|{
try|try
block|{
for|for
control|(
name|SolrEventListener
name|listener
range|:
name|newSearcherListeners
control|)
block|{
name|listener
operator|.
name|newSearcher
argument_list|(
name|newSearcher
argument_list|,
name|currSearcher
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|SolrException
operator|.
name|log
argument_list|(
name|log
argument_list|,
literal|null
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|instanceof
name|Error
condition|)
block|{
throw|throw
operator|(
name|Error
operator|)
name|e
throw|;
block|}
block|}
return|return
literal|null
return|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
block|}
comment|// WARNING: this code assumes a single threaded executor (that all tasks
comment|// queued will finish first).
specifier|final
name|RefCounted
argument_list|<
name|SolrIndexSearcher
argument_list|>
name|currSearcherHolderF
init|=
name|currSearcherHolder
decl_stmt|;
if|if
condition|(
operator|!
name|alreadyRegistered
condition|)
block|{
name|future
operator|=
name|searcherExecutor
operator|.
name|submit
argument_list|(
operator|new
name|Callable
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Object
name|call
parameter_list|()
throws|throws
name|Exception
block|{
try|try
block|{
comment|// registerSearcher will decrement onDeckSearchers and
comment|// do a notify, even if it fails.
name|registerSearcher
argument_list|(
name|newSearchHolder
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|SolrException
operator|.
name|log
argument_list|(
name|log
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|instanceof
name|Error
condition|)
block|{
throw|throw
operator|(
name|Error
operator|)
name|e
throw|;
block|}
block|}
finally|finally
block|{
comment|// we are all done with the old searcher we used
comment|// for warming...
if|if
condition|(
name|currSearcherHolderF
operator|!=
literal|null
condition|)
name|currSearcherHolderF
operator|.
name|decref
argument_list|()
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|waitSearcher
operator|!=
literal|null
condition|)
block|{
name|waitSearcher
index|[
literal|0
index|]
operator|=
name|future
expr_stmt|;
block|}
name|success
operator|=
literal|true
expr_stmt|;
comment|// Return the searcher as the warming tasks run in parallel
comment|// callers may wait on the waitSearcher future returned.
return|return
name|returnSearcher
condition|?
name|newSearchHolder
else|:
literal|null
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
if|if
condition|(
name|e
operator|instanceof
name|SolrException
condition|)
throw|throw
operator|(
name|SolrException
operator|)
name|e
throw|;
throw|throw
operator|new
name|SolrException
argument_list|(
name|SolrException
operator|.
name|ErrorCode
operator|.
name|SERVER_ERROR
argument_list|,
name|e
argument_list|)
throw|;
block|}
finally|finally
block|{
if|if
condition|(
operator|!
name|success
condition|)
block|{
synchronized|synchronized
init|(
name|searcherLock
init|)
block|{
name|onDeckSearchers
operator|--
expr_stmt|;
if|if
condition|(
name|onDeckSearchers
operator|<
literal|0
condition|)
block|{
comment|// sanity check... should never happen
name|log
operator|.
name|error
argument_list|(
name|logid
operator|+
literal|"ERROR!!! onDeckSearchers after decrement="
operator|+
name|onDeckSearchers
argument_list|)
expr_stmt|;
name|onDeckSearchers
operator|=
literal|0
expr_stmt|;
comment|// try and recover
block|}
comment|// if we failed, we need to wake up at least one waiter to continue the process
name|searcherLock
operator|.
name|notify
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|currSearcherHolder
operator|!=
literal|null
condition|)
block|{
name|currSearcherHolder
operator|.
name|decref
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|searchHolder
operator|!=
literal|null
condition|)
block|{
name|searchHolder
operator|.
name|decref
argument_list|()
expr_stmt|;
comment|// decrement 1 for _searcher (searchHolder will never become _searcher now)
if|if
condition|(
name|returnSearcher
condition|)
block|{
name|searchHolder
operator|.
name|decref
argument_list|()
expr_stmt|;
comment|// decrement 1 because we won't be returning the searcher to the user
block|}
block|}
block|}
comment|// we want to do this after we decrement onDeckSearchers so another thread
comment|// doesn't increment first and throw a false warning.
name|openSearcherLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|newHolder
specifier|private
name|RefCounted
argument_list|<
name|SolrIndexSearcher
argument_list|>
name|newHolder
parameter_list|(
name|SolrIndexSearcher
name|newSearcher
parameter_list|,
specifier|final
name|List
argument_list|<
name|RefCounted
argument_list|<
name|SolrIndexSearcher
argument_list|>
argument_list|>
name|searcherList
parameter_list|)
block|{
name|RefCounted
argument_list|<
name|SolrIndexSearcher
argument_list|>
name|holder
init|=
operator|new
name|RefCounted
argument_list|<
name|SolrIndexSearcher
argument_list|>
argument_list|(
name|newSearcher
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|void
name|close
parameter_list|()
block|{
try|try
block|{
synchronized|synchronized
init|(
name|searcherLock
init|)
block|{
comment|// it's possible for someone to get a reference via the _searchers queue
comment|// and increment the refcount while RefCounted.close() is being called.
comment|// we check the refcount again to see if this has happened and abort the close.
comment|// This relies on the RefCounted class allowing close() to be called every
comment|// time the counter hits zero.
if|if
condition|(
name|refcount
operator|.
name|get
argument_list|()
operator|>
literal|0
condition|)
return|return;
name|searcherList
operator|.
name|remove
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
name|resource
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
comment|// do not allow decref() operations to fail since they are typically called in finally blocks
comment|// and throwing another exception would be very unexpected.
name|SolrException
operator|.
name|log
argument_list|(
name|log
argument_list|,
literal|"Error closing searcher:"
operator|+
name|this
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
decl_stmt|;
name|holder
operator|.
name|incref
argument_list|()
expr_stmt|;
comment|// set ref count to 1 to account for this._searcher
return|return
name|holder
return|;
block|}
DECL|method|isReloaded
specifier|public
name|boolean
name|isReloaded
parameter_list|()
block|{
return|return
name|isReloaded
return|;
block|}
comment|// Take control of newSearcherHolder (which should have a reference count of at
comment|// least 1 already.  If the caller wishes to use the newSearcherHolder directly
comment|// after registering it, then they should increment the reference count *before*
comment|// calling this method.
comment|//
comment|// onDeckSearchers will also be decremented (it should have been incremented
comment|// as a result of opening a new searcher).
DECL|method|registerSearcher
specifier|private
name|void
name|registerSearcher
parameter_list|(
name|RefCounted
argument_list|<
name|SolrIndexSearcher
argument_list|>
name|newSearcherHolder
parameter_list|)
block|{
synchronized|synchronized
init|(
name|searcherLock
init|)
block|{
try|try
block|{
if|if
condition|(
name|_searcher
operator|==
name|newSearcherHolder
condition|)
block|{
comment|// trying to re-register the same searcher... this can now happen when a commit has been done but
comment|// there were no changes to the index.
name|newSearcherHolder
operator|.
name|decref
argument_list|()
expr_stmt|;
comment|// decref since the caller should have still incref'd (since they didn't know the searcher was the same)
return|return;
comment|// still execute the finally block to notify anyone waiting.
block|}
if|if
condition|(
name|_searcher
operator|!=
literal|null
condition|)
block|{
name|_searcher
operator|.
name|decref
argument_list|()
expr_stmt|;
comment|// dec refcount for this._searcher
name|_searcher
operator|=
literal|null
expr_stmt|;
block|}
name|_searcher
operator|=
name|newSearcherHolder
expr_stmt|;
name|SolrIndexSearcher
name|newSearcher
init|=
name|newSearcherHolder
operator|.
name|get
argument_list|()
decl_stmt|;
comment|/***         // a searcher may have been warming asynchronously while the core was being closed.         // if this happens, just close the searcher.         if (isClosed()) {           // NOTE: this should not happen now - see close() for details.           // *BUT* if we left it enabled, this could still happen before           // close() stopped the executor - so disable this test for now.           log.error("Ignoring searcher register on closed core:" + newSearcher);           _searcher.decref();         }         ***/
name|newSearcher
operator|.
name|register
argument_list|()
expr_stmt|;
comment|// register subitems (caches)
name|log
operator|.
name|info
argument_list|(
name|logid
operator|+
literal|"Registered new searcher "
operator|+
name|newSearcher
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
comment|// an exception in register() shouldn't be fatal.
name|log
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
comment|// wake up anyone waiting for a searcher
comment|// even in the face of errors.
name|onDeckSearchers
operator|--
expr_stmt|;
name|searcherLock
operator|.
name|notifyAll
argument_list|()
expr_stmt|;
block|}
block|}
block|}
DECL|method|closeSearcher
specifier|public
name|void
name|closeSearcher
parameter_list|()
block|{
name|log
operator|.
name|info
argument_list|(
name|logid
operator|+
literal|"Closing main searcher on request."
argument_list|)
expr_stmt|;
synchronized|synchronized
init|(
name|searcherLock
init|)
block|{
if|if
condition|(
name|realtimeSearcher
operator|!=
literal|null
condition|)
block|{
name|realtimeSearcher
operator|.
name|decref
argument_list|()
expr_stmt|;
name|realtimeSearcher
operator|=
literal|null
expr_stmt|;
block|}
if|if
condition|(
name|_searcher
operator|!=
literal|null
condition|)
block|{
name|_searcher
operator|.
name|decref
argument_list|()
expr_stmt|;
comment|// dec refcount for this._searcher
name|_searcher
operator|=
literal|null
expr_stmt|;
comment|// isClosed() does check this
name|infoRegistry
operator|.
name|remove
argument_list|(
literal|"currentSearcher"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|execute
specifier|public
name|void
name|execute
parameter_list|(
name|SolrRequestHandler
name|handler
parameter_list|,
name|SolrQueryRequest
name|req
parameter_list|,
name|SolrQueryResponse
name|rsp
parameter_list|)
block|{
if|if
condition|(
name|handler
operator|==
literal|null
condition|)
block|{
name|String
name|msg
init|=
literal|"Null Request Handler '"
operator|+
name|req
operator|.
name|getParams
argument_list|()
operator|.
name|get
argument_list|(
name|CommonParams
operator|.
name|QT
argument_list|)
operator|+
literal|"'"
decl_stmt|;
if|if
condition|(
name|log
operator|.
name|isWarnEnabled
argument_list|()
condition|)
name|log
operator|.
name|warn
argument_list|(
name|logid
operator|+
name|msg
operator|+
literal|":"
operator|+
name|req
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|SolrException
argument_list|(
name|SolrException
operator|.
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
name|msg
argument_list|)
throw|;
block|}
name|preDecorateResponse
argument_list|(
name|req
argument_list|,
name|rsp
argument_list|)
expr_stmt|;
if|if
condition|(
name|requestLog
operator|.
name|isDebugEnabled
argument_list|()
operator|&&
name|rsp
operator|.
name|getToLog
argument_list|()
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
comment|// log request at debug in case something goes wrong and we aren't able to log later
name|requestLog
operator|.
name|debug
argument_list|(
name|rsp
operator|.
name|getToLogAsString
argument_list|(
name|logid
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// TODO: this doesn't seem to be working correctly and causes problems with the example server and distrib (for example /spell)
comment|// if (req.getParams().getBool(ShardParams.IS_SHARD,false)&& !(handler instanceof SearchHandler))
comment|//   throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,"isShard is only acceptable with search handlers");
name|handler
operator|.
name|handleRequest
argument_list|(
name|req
argument_list|,
name|rsp
argument_list|)
expr_stmt|;
name|postDecorateResponse
argument_list|(
name|handler
argument_list|,
name|req
argument_list|,
name|rsp
argument_list|)
expr_stmt|;
if|if
condition|(
name|rsp
operator|.
name|getToLog
argument_list|()
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|requestLog
operator|.
name|isInfoEnabled
argument_list|()
condition|)
block|{
name|requestLog
operator|.
name|info
argument_list|(
name|rsp
operator|.
name|getToLogAsString
argument_list|(
name|logid
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|log
operator|.
name|isWarnEnabled
argument_list|()
operator|&&
name|slowQueryThresholdMillis
operator|>=
literal|0
condition|)
block|{
specifier|final
name|long
name|qtime
init|=
call|(
name|long
call|)
argument_list|(
name|req
operator|.
name|getRequestTimer
argument_list|()
operator|.
name|getTime
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|qtime
operator|>=
name|slowQueryThresholdMillis
condition|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"slow: "
operator|+
name|rsp
operator|.
name|getToLogAsString
argument_list|(
name|logid
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
DECL|method|preDecorateResponse
specifier|public
specifier|static
name|void
name|preDecorateResponse
parameter_list|(
name|SolrQueryRequest
name|req
parameter_list|,
name|SolrQueryResponse
name|rsp
parameter_list|)
block|{
comment|// setup response header
specifier|final
name|NamedList
argument_list|<
name|Object
argument_list|>
name|responseHeader
init|=
operator|new
name|SimpleOrderedMap
argument_list|<>
argument_list|()
decl_stmt|;
name|rsp
operator|.
name|add
argument_list|(
literal|"responseHeader"
argument_list|,
name|responseHeader
argument_list|)
expr_stmt|;
comment|// toLog is a local ref to the same NamedList used by the response
name|NamedList
argument_list|<
name|Object
argument_list|>
name|toLog
init|=
name|rsp
operator|.
name|getToLog
argument_list|()
decl_stmt|;
comment|// for back compat, we set these now just in case other code
comment|// are expecting them during handleRequest
name|toLog
operator|.
name|add
argument_list|(
literal|"webapp"
argument_list|,
name|req
operator|.
name|getContext
argument_list|()
operator|.
name|get
argument_list|(
literal|"webapp"
argument_list|)
argument_list|)
expr_stmt|;
name|toLog
operator|.
name|add
argument_list|(
literal|"path"
argument_list|,
name|req
operator|.
name|getContext
argument_list|()
operator|.
name|get
argument_list|(
literal|"path"
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|SolrParams
name|params
init|=
name|req
operator|.
name|getParams
argument_list|()
decl_stmt|;
specifier|final
name|String
name|lpList
init|=
name|params
operator|.
name|get
argument_list|(
name|CommonParams
operator|.
name|LOG_PARAMS_LIST
argument_list|)
decl_stmt|;
if|if
condition|(
name|lpList
operator|==
literal|null
condition|)
block|{
name|toLog
operator|.
name|add
argument_list|(
literal|"params"
argument_list|,
literal|"{"
operator|+
name|req
operator|.
name|getParamString
argument_list|()
operator|+
literal|"}"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lpList
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
name|toLog
operator|.
name|add
argument_list|(
literal|"params"
argument_list|,
literal|"{"
operator|+
name|params
operator|.
name|toFilteredSolrParams
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|lpList
operator|.
name|split
argument_list|(
literal|","
argument_list|)
argument_list|)
argument_list|)
operator|.
name|toString
argument_list|()
operator|+
literal|"}"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Put status, QTime, and possibly request handler and params, in the response header */
DECL|method|postDecorateResponse
specifier|public
specifier|static
name|void
name|postDecorateResponse
parameter_list|(
name|SolrRequestHandler
name|handler
parameter_list|,
name|SolrQueryRequest
name|req
parameter_list|,
name|SolrQueryResponse
name|rsp
parameter_list|)
block|{
comment|// TODO should check that responseHeader has not been replaced by handler
name|NamedList
argument_list|<
name|Object
argument_list|>
name|responseHeader
init|=
name|rsp
operator|.
name|getResponseHeader
argument_list|()
decl_stmt|;
specifier|final
name|int
name|qtime
init|=
call|(
name|int
call|)
argument_list|(
name|req
operator|.
name|getRequestTimer
argument_list|()
operator|.
name|getTime
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|status
init|=
literal|0
decl_stmt|;
name|Exception
name|exception
init|=
name|rsp
operator|.
name|getException
argument_list|()
decl_stmt|;
if|if
condition|(
name|exception
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|exception
operator|instanceof
name|SolrException
condition|)
name|status
operator|=
operator|(
operator|(
name|SolrException
operator|)
name|exception
operator|)
operator|.
name|code
argument_list|()
expr_stmt|;
else|else
name|status
operator|=
literal|500
expr_stmt|;
block|}
name|responseHeader
operator|.
name|add
argument_list|(
literal|"status"
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|responseHeader
operator|.
name|add
argument_list|(
literal|"QTime"
argument_list|,
name|qtime
argument_list|)
expr_stmt|;
if|if
condition|(
name|rsp
operator|.
name|getToLog
argument_list|()
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|rsp
operator|.
name|getToLog
argument_list|()
operator|.
name|add
argument_list|(
literal|"status"
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|rsp
operator|.
name|getToLog
argument_list|()
operator|.
name|add
argument_list|(
literal|"QTime"
argument_list|,
name|qtime
argument_list|)
expr_stmt|;
block|}
name|SolrParams
name|params
init|=
name|req
operator|.
name|getParams
argument_list|()
decl_stmt|;
if|if
condition|(
literal|null
operator|!=
name|handler
operator|&&
name|params
operator|.
name|getBool
argument_list|(
name|CommonParams
operator|.
name|HEADER_ECHO_HANDLER
argument_list|,
literal|false
argument_list|)
condition|)
block|{
name|responseHeader
operator|.
name|add
argument_list|(
literal|"handler"
argument_list|,
name|handler
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// Values for echoParams... false/true/all or false/explicit/all ???
name|String
name|ep
init|=
name|params
operator|.
name|get
argument_list|(
name|CommonParams
operator|.
name|HEADER_ECHO_PARAMS
argument_list|,
literal|null
argument_list|)
decl_stmt|;
if|if
condition|(
name|ep
operator|!=
literal|null
condition|)
block|{
name|EchoParamStyle
name|echoParams
init|=
name|EchoParamStyle
operator|.
name|get
argument_list|(
name|ep
argument_list|)
decl_stmt|;
if|if
condition|(
name|echoParams
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|SolrException
operator|.
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
literal|"Invalid value '"
operator|+
name|ep
operator|+
literal|"' for "
operator|+
name|CommonParams
operator|.
name|HEADER_ECHO_PARAMS
operator|+
literal|" parameter, use '"
operator|+
name|EchoParamStyle
operator|.
name|EXPLICIT
operator|+
literal|"' or '"
operator|+
name|EchoParamStyle
operator|.
name|ALL
operator|+
literal|"'"
argument_list|)
throw|;
block|}
if|if
condition|(
name|echoParams
operator|==
name|EchoParamStyle
operator|.
name|EXPLICIT
condition|)
block|{
name|responseHeader
operator|.
name|add
argument_list|(
literal|"params"
argument_list|,
name|req
operator|.
name|getOriginalParams
argument_list|()
operator|.
name|toNamedList
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|echoParams
operator|==
name|EchoParamStyle
operator|.
name|ALL
condition|)
block|{
name|responseHeader
operator|.
name|add
argument_list|(
literal|"params"
argument_list|,
name|req
operator|.
name|getParams
argument_list|()
operator|.
name|toNamedList
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|log
specifier|final
specifier|public
specifier|static
name|void
name|log
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|SolrException
operator|.
name|log
argument_list|(
name|log
argument_list|,
literal|null
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
DECL|method|getResponseWriters
specifier|public
name|PluginBag
argument_list|<
name|QueryResponseWriter
argument_list|>
name|getResponseWriters
parameter_list|()
block|{
return|return
name|responseWriters
return|;
block|}
DECL|field|responseWriters
specifier|private
specifier|final
name|PluginBag
argument_list|<
name|QueryResponseWriter
argument_list|>
name|responseWriters
init|=
operator|new
name|PluginBag
argument_list|<>
argument_list|(
name|QueryResponseWriter
operator|.
name|class
argument_list|,
name|this
argument_list|)
decl_stmt|;
DECL|field|DEFAULT_RESPONSE_WRITERS
specifier|public
specifier|static
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|QueryResponseWriter
argument_list|>
name|DEFAULT_RESPONSE_WRITERS
decl_stmt|;
static|static
block|{
name|HashMap
argument_list|<
name|String
argument_list|,
name|QueryResponseWriter
argument_list|>
name|m
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|m
operator|.
name|put
argument_list|(
literal|"xml"
argument_list|,
operator|new
name|XMLResponseWriter
argument_list|()
argument_list|)
expr_stmt|;
name|m
operator|.
name|put
argument_list|(
literal|"standard"
argument_list|,
name|m
operator|.
name|get
argument_list|(
literal|"xml"
argument_list|)
argument_list|)
expr_stmt|;
name|m
operator|.
name|put
argument_list|(
literal|"json"
argument_list|,
operator|new
name|JSONResponseWriter
argument_list|()
argument_list|)
expr_stmt|;
name|m
operator|.
name|put
argument_list|(
literal|"python"
argument_list|,
operator|new
name|PythonResponseWriter
argument_list|()
argument_list|)
expr_stmt|;
name|m
operator|.
name|put
argument_list|(
literal|"php"
argument_list|,
operator|new
name|PHPResponseWriter
argument_list|()
argument_list|)
expr_stmt|;
name|m
operator|.
name|put
argument_list|(
literal|"phps"
argument_list|,
operator|new
name|PHPSerializedResponseWriter
argument_list|()
argument_list|)
expr_stmt|;
name|m
operator|.
name|put
argument_list|(
literal|"ruby"
argument_list|,
operator|new
name|RubyResponseWriter
argument_list|()
argument_list|)
expr_stmt|;
name|m
operator|.
name|put
argument_list|(
literal|"raw"
argument_list|,
operator|new
name|RawResponseWriter
argument_list|()
argument_list|)
expr_stmt|;
name|m
operator|.
name|put
argument_list|(
literal|"javabin"
argument_list|,
operator|new
name|BinaryResponseWriter
argument_list|()
argument_list|)
expr_stmt|;
name|m
operator|.
name|put
argument_list|(
literal|"csv"
argument_list|,
operator|new
name|CSVResponseWriter
argument_list|()
argument_list|)
expr_stmt|;
name|m
operator|.
name|put
argument_list|(
literal|"xsort"
argument_list|,
operator|new
name|SortingResponseWriter
argument_list|()
argument_list|)
expr_stmt|;
name|m
operator|.
name|put
argument_list|(
literal|"schema.xml"
argument_list|,
operator|new
name|SchemaXmlResponseWriter
argument_list|()
argument_list|)
expr_stmt|;
name|m
operator|.
name|put
argument_list|(
name|ReplicationHandler
operator|.
name|FILE_STREAM
argument_list|,
name|getFileStreamWriter
argument_list|()
argument_list|)
expr_stmt|;
name|DEFAULT_RESPONSE_WRITERS
operator|=
name|Collections
operator|.
name|unmodifiableMap
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
DECL|method|getFileStreamWriter
specifier|private
specifier|static
name|BinaryResponseWriter
name|getFileStreamWriter
parameter_list|()
block|{
return|return
operator|new
name|BinaryResponseWriter
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|write
parameter_list|(
name|OutputStream
name|out
parameter_list|,
name|SolrQueryRequest
name|req
parameter_list|,
name|SolrQueryResponse
name|response
parameter_list|)
throws|throws
name|IOException
block|{
name|RawWriter
name|rawWriter
init|=
operator|(
name|RawWriter
operator|)
name|response
operator|.
name|getValues
argument_list|()
operator|.
name|get
argument_list|(
name|ReplicationHandler
operator|.
name|FILE_STREAM
argument_list|)
decl_stmt|;
if|if
condition|(
name|rawWriter
operator|!=
literal|null
condition|)
name|rawWriter
operator|.
name|write
argument_list|(
name|out
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|getContentType
parameter_list|(
name|SolrQueryRequest
name|request
parameter_list|,
name|SolrQueryResponse
name|response
parameter_list|)
block|{
return|return
name|BinaryResponseParser
operator|.
name|BINARY_CONTENT_TYPE
return|;
block|}
block|}
return|;
block|}
DECL|method|getMemClassLoader
specifier|public
name|MemClassLoader
name|getMemClassLoader
parameter_list|()
block|{
return|return
name|memClassLoader
return|;
block|}
DECL|interface|RawWriter
specifier|public
interface|interface
name|RawWriter
block|{
DECL|method|write
specifier|public
name|void
name|write
parameter_list|(
name|OutputStream
name|os
parameter_list|)
throws|throws
name|IOException
function_decl|;
block|}
comment|/** Configure the query response writers. There will always be a default writer; additional    * writers may also be configured. */
DECL|method|initWriters
specifier|private
name|void
name|initWriters
parameter_list|()
block|{
name|responseWriters
operator|.
name|init
argument_list|(
name|DEFAULT_RESPONSE_WRITERS
argument_list|,
name|this
argument_list|)
expr_stmt|;
comment|// configure the default response writer; this one should never be null
if|if
condition|(
name|responseWriters
operator|.
name|getDefault
argument_list|()
operator|==
literal|null
condition|)
name|responseWriters
operator|.
name|setDefault
argument_list|(
literal|"standard"
argument_list|)
expr_stmt|;
block|}
comment|/** Finds a writer by name, or returns the default writer if not found. */
DECL|method|getQueryResponseWriter
specifier|public
specifier|final
name|QueryResponseWriter
name|getQueryResponseWriter
parameter_list|(
name|String
name|writerName
parameter_list|)
block|{
return|return
name|responseWriters
operator|.
name|get
argument_list|(
name|writerName
argument_list|,
literal|true
argument_list|)
return|;
block|}
comment|/** Returns the appropriate writer for a request. If the request specifies a writer via the    * 'wt' parameter, attempts to find that one; otherwise return the default writer.    */
DECL|method|getQueryResponseWriter
specifier|public
specifier|final
name|QueryResponseWriter
name|getQueryResponseWriter
parameter_list|(
name|SolrQueryRequest
name|request
parameter_list|)
block|{
return|return
name|getQueryResponseWriter
argument_list|(
name|request
operator|.
name|getParams
argument_list|()
operator|.
name|get
argument_list|(
name|CommonParams
operator|.
name|WT
argument_list|)
argument_list|)
return|;
block|}
DECL|field|qParserPlugins
specifier|private
specifier|final
name|PluginBag
argument_list|<
name|QParserPlugin
argument_list|>
name|qParserPlugins
init|=
operator|new
name|PluginBag
argument_list|<>
argument_list|(
name|QParserPlugin
operator|.
name|class
argument_list|,
name|this
argument_list|)
decl_stmt|;
DECL|method|getQueryPlugin
specifier|public
name|QParserPlugin
name|getQueryPlugin
parameter_list|(
name|String
name|parserName
parameter_list|)
block|{
return|return
name|qParserPlugins
operator|.
name|get
argument_list|(
name|parserName
argument_list|)
return|;
block|}
DECL|field|valueSourceParsers
specifier|private
specifier|final
name|PluginBag
argument_list|<
name|ValueSourceParser
argument_list|>
name|valueSourceParsers
init|=
operator|new
name|PluginBag
argument_list|<>
argument_list|(
name|ValueSourceParser
operator|.
name|class
argument_list|,
name|this
argument_list|)
decl_stmt|;
DECL|field|transformerFactories
specifier|private
specifier|final
name|PluginBag
argument_list|<
name|TransformerFactory
argument_list|>
name|transformerFactories
init|=
operator|new
name|PluginBag
argument_list|<>
argument_list|(
name|TransformerFactory
operator|.
name|class
argument_list|,
name|this
argument_list|)
decl_stmt|;
DECL|method|createInstances
parameter_list|<
name|T
parameter_list|>
name|Map
argument_list|<
name|String
argument_list|,
name|T
argument_list|>
name|createInstances
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|Class
argument_list|<
name|?
extends|extends
name|T
argument_list|>
argument_list|>
name|map
parameter_list|)
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|T
argument_list|>
name|result
init|=
operator|new
name|LinkedHashMap
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|Class
argument_list|<
name|?
extends|extends
name|T
argument_list|>
argument_list|>
name|e
range|:
name|map
operator|.
name|entrySet
argument_list|()
control|)
block|{
try|try
block|{
name|Object
name|o
init|=
name|getResourceLoader
argument_list|()
operator|.
name|newInstance
argument_list|(
name|e
operator|.
name|getValue
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|e
operator|.
name|getValue
argument_list|()
argument_list|)
decl_stmt|;
name|result
operator|.
name|put
argument_list|(
name|e
operator|.
name|getKey
argument_list|()
argument_list|,
operator|(
name|T
operator|)
name|o
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|exp
parameter_list|)
block|{
comment|//should never happen
throw|throw
operator|new
name|SolrException
argument_list|(
name|SolrException
operator|.
name|ErrorCode
operator|.
name|SERVER_ERROR
argument_list|,
literal|"Unbale to instantiate class"
argument_list|,
name|exp
argument_list|)
throw|;
block|}
block|}
return|return
name|result
return|;
block|}
DECL|method|getTransformerFactory
specifier|public
name|TransformerFactory
name|getTransformerFactory
parameter_list|(
name|String
name|name
parameter_list|)
block|{
return|return
name|transformerFactories
operator|.
name|get
argument_list|(
name|name
argument_list|)
return|;
block|}
DECL|method|addTransformerFactory
specifier|public
name|void
name|addTransformerFactory
parameter_list|(
name|String
name|name
parameter_list|,
name|TransformerFactory
name|factory
parameter_list|)
block|{
name|transformerFactories
operator|.
name|put
argument_list|(
name|name
argument_list|,
name|factory
argument_list|)
expr_stmt|;
block|}
comment|/**    * @param registry The map to which the instance should be added to. The key is the name attribute    * @param type the class or interface that the instance should extend or implement.    * @param defClassName If PluginInfo does not have a classname, use this as the classname    * @return The default instance . The one with (default=true)    */
DECL|method|initPlugins
specifier|private
parameter_list|<
name|T
parameter_list|>
name|T
name|initPlugins
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|T
argument_list|>
name|registry
parameter_list|,
name|Class
argument_list|<
name|T
argument_list|>
name|type
parameter_list|,
name|String
name|defClassName
parameter_list|)
block|{
return|return
name|initPlugins
argument_list|(
name|solrConfig
operator|.
name|getPluginInfos
argument_list|(
name|type
operator|.
name|getName
argument_list|()
argument_list|)
argument_list|,
name|registry
argument_list|,
name|type
argument_list|,
name|defClassName
argument_list|)
return|;
block|}
DECL|method|initPlugins
specifier|public
parameter_list|<
name|T
parameter_list|>
name|T
name|initPlugins
parameter_list|(
name|List
argument_list|<
name|PluginInfo
argument_list|>
name|pluginInfos
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|T
argument_list|>
name|registry
parameter_list|,
name|Class
argument_list|<
name|T
argument_list|>
name|type
parameter_list|,
name|String
name|defClassName
parameter_list|)
block|{
name|T
name|def
init|=
literal|null
decl_stmt|;
for|for
control|(
name|PluginInfo
name|info
range|:
name|pluginInfos
control|)
block|{
name|T
name|o
init|=
name|createInitInstance
argument_list|(
name|info
argument_list|,
name|type
argument_list|,
name|type
operator|.
name|getSimpleName
argument_list|()
argument_list|,
name|defClassName
argument_list|)
decl_stmt|;
name|registry
operator|.
name|put
argument_list|(
name|info
operator|.
name|name
argument_list|,
name|o
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|.
name|isDefault
argument_list|()
condition|)
block|{
name|def
operator|=
name|o
expr_stmt|;
block|}
block|}
return|return
name|def
return|;
block|}
comment|/**For a given List of PluginInfo return the instances as a List    * @param defClassName The default classname if PluginInfo#className == null    * @return The instances initialized    */
DECL|method|initPlugins
specifier|public
parameter_list|<
name|T
parameter_list|>
name|List
argument_list|<
name|T
argument_list|>
name|initPlugins
parameter_list|(
name|List
argument_list|<
name|PluginInfo
argument_list|>
name|pluginInfos
parameter_list|,
name|Class
argument_list|<
name|T
argument_list|>
name|type
parameter_list|,
name|String
name|defClassName
parameter_list|)
block|{
if|if
condition|(
name|pluginInfos
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|Collections
operator|.
name|emptyList
argument_list|()
return|;
name|List
argument_list|<
name|T
argument_list|>
name|result
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|PluginInfo
name|info
range|:
name|pluginInfos
control|)
name|result
operator|.
name|add
argument_list|(
name|createInitInstance
argument_list|(
name|info
argument_list|,
name|type
argument_list|,
name|type
operator|.
name|getSimpleName
argument_list|()
argument_list|,
name|defClassName
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
comment|/**    *    * @param registry The map to which the instance should be added to. The key is the name attribute    * @param type The type of the Plugin. These should be standard ones registered by type.getName() in SolrConfig    * @return     The default if any    */
DECL|method|initPlugins
specifier|public
parameter_list|<
name|T
parameter_list|>
name|T
name|initPlugins
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|T
argument_list|>
name|registry
parameter_list|,
name|Class
argument_list|<
name|T
argument_list|>
name|type
parameter_list|)
block|{
return|return
name|initPlugins
argument_list|(
name|registry
argument_list|,
name|type
argument_list|,
literal|null
argument_list|)
return|;
block|}
DECL|method|getValueSourceParser
specifier|public
name|ValueSourceParser
name|getValueSourceParser
parameter_list|(
name|String
name|parserName
parameter_list|)
block|{
return|return
name|valueSourceParsers
operator|.
name|get
argument_list|(
name|parserName
argument_list|)
return|;
block|}
comment|/**    * Manage anything that should be taken care of in case configs change    */
DECL|method|initDeprecatedSupport
specifier|private
name|void
name|initDeprecatedSupport
parameter_list|()
block|{
comment|// TODO -- this should be removed in deprecation release...
name|String
name|gettable
init|=
name|solrConfig
operator|.
name|get
argument_list|(
literal|"admin/gettableFiles"
argument_list|,
literal|null
argument_list|)
decl_stmt|;
if|if
condition|(
name|gettable
operator|!=
literal|null
condition|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"solrconfig.xml uses deprecated<admin/gettableFiles>, Please "
operator|+
literal|"update your config to use the ShowFileRequestHandler."
argument_list|)
expr_stmt|;
if|if
condition|(
name|getRequestHandler
argument_list|(
literal|"/admin/file"
argument_list|)
operator|==
literal|null
condition|)
block|{
name|NamedList
argument_list|<
name|String
argument_list|>
name|invariants
init|=
operator|new
name|NamedList
argument_list|<>
argument_list|()
decl_stmt|;
comment|// Hide everything...
name|Set
argument_list|<
name|String
argument_list|>
name|hide
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|file
range|:
name|solrConfig
operator|.
name|getResourceLoader
argument_list|()
operator|.
name|listConfigDir
argument_list|()
control|)
block|{
name|hide
operator|.
name|add
argument_list|(
name|file
operator|.
name|toUpperCase
argument_list|(
name|Locale
operator|.
name|ROOT
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// except the "gettable" list
name|StringTokenizer
name|st
init|=
operator|new
name|StringTokenizer
argument_list|(
name|gettable
argument_list|)
decl_stmt|;
while|while
condition|(
name|st
operator|.
name|hasMoreTokens
argument_list|()
condition|)
block|{
name|hide
operator|.
name|remove
argument_list|(
name|st
operator|.
name|nextToken
argument_list|()
operator|.
name|toUpperCase
argument_list|(
name|Locale
operator|.
name|ROOT
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|String
name|s
range|:
name|hide
control|)
block|{
name|invariants
operator|.
name|add
argument_list|(
name|ShowFileRequestHandler
operator|.
name|HIDDEN
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
name|NamedList
argument_list|<
name|Object
argument_list|>
name|args
init|=
operator|new
name|NamedList
argument_list|<>
argument_list|()
decl_stmt|;
name|args
operator|.
name|add
argument_list|(
literal|"invariants"
argument_list|,
name|invariants
argument_list|)
expr_stmt|;
name|ShowFileRequestHandler
name|handler
init|=
operator|new
name|ShowFileRequestHandler
argument_list|()
decl_stmt|;
name|handler
operator|.
name|init
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|reqHandlers
operator|.
name|register
argument_list|(
literal|"/admin/file"
argument_list|,
name|handler
argument_list|)
expr_stmt|;
name|log
operator|.
name|warn
argument_list|(
literal|"adding ShowFileRequestHandler with hidden files: "
operator|+
name|hide
argument_list|)
expr_stmt|;
block|}
block|}
name|String
name|facetSort
init|=
name|solrConfig
operator|.
name|get
argument_list|(
literal|"//bool[@name='facet.sort']"
argument_list|,
literal|null
argument_list|)
decl_stmt|;
if|if
condition|(
name|facetSort
operator|!=
literal|null
condition|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"solrconfig.xml uses deprecated<bool name='facet.sort'>. Please "
operator|+
literal|"update your config to use<string name='facet.sort'>."
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Creates and initializes a RestManager based on configuration args in solrconfig.xml.    * RestManager provides basic storage support for managed resource data, such as to    * persist stopwords to ZooKeeper if running in SolrCloud mode.    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|initRestManager
specifier|protected
name|RestManager
name|initRestManager
parameter_list|()
throws|throws
name|SolrException
block|{
name|PluginInfo
name|restManagerPluginInfo
init|=
name|getSolrConfig
argument_list|()
operator|.
name|getPluginInfo
argument_list|(
name|RestManager
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
name|NamedList
argument_list|<
name|String
argument_list|>
name|initArgs
init|=
literal|null
decl_stmt|;
name|RestManager
name|mgr
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|restManagerPluginInfo
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|restManagerPluginInfo
operator|.
name|className
operator|!=
literal|null
condition|)
block|{
name|mgr
operator|=
name|resourceLoader
operator|.
name|newInstance
argument_list|(
name|restManagerPluginInfo
operator|.
name|className
argument_list|,
name|RestManager
operator|.
name|class
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|restManagerPluginInfo
operator|.
name|initArgs
operator|!=
literal|null
condition|)
block|{
name|initArgs
operator|=
operator|(
name|NamedList
argument_list|<
name|String
argument_list|>
operator|)
name|restManagerPluginInfo
operator|.
name|initArgs
expr_stmt|;
block|}
block|}
if|if
condition|(
name|mgr
operator|==
literal|null
condition|)
name|mgr
operator|=
operator|new
name|RestManager
argument_list|()
expr_stmt|;
if|if
condition|(
name|initArgs
operator|==
literal|null
condition|)
name|initArgs
operator|=
operator|new
name|NamedList
argument_list|<>
argument_list|()
expr_stmt|;
name|String
name|collection
init|=
name|coreDescriptor
operator|.
name|getCollectionName
argument_list|()
decl_stmt|;
name|StorageIO
name|storageIO
init|=
name|ManagedResourceStorage
operator|.
name|newStorageIO
argument_list|(
name|collection
argument_list|,
name|resourceLoader
argument_list|,
name|initArgs
argument_list|)
decl_stmt|;
name|mgr
operator|.
name|init
argument_list|(
name|resourceLoader
argument_list|,
name|initArgs
argument_list|,
name|storageIO
argument_list|)
expr_stmt|;
return|return
name|mgr
return|;
block|}
DECL|method|getCoreDescriptor
specifier|public
name|CoreDescriptor
name|getCoreDescriptor
parameter_list|()
block|{
return|return
name|coreDescriptor
return|;
block|}
DECL|method|getDeletionPolicy
specifier|public
name|IndexDeletionPolicyWrapper
name|getDeletionPolicy
parameter_list|()
block|{
return|return
name|solrDelPolicy
return|;
block|}
DECL|method|getRuleExpiryLock
specifier|public
name|ReentrantLock
name|getRuleExpiryLock
parameter_list|()
block|{
return|return
name|ruleExpiryLock
return|;
block|}
comment|/////////////////////////////////////////////////////////////////////
comment|// SolrInfoMBean stuff: Statistics and Module Info
comment|/////////////////////////////////////////////////////////////////////
annotation|@
name|Override
DECL|method|getVersion
specifier|public
name|String
name|getVersion
parameter_list|()
block|{
return|return
name|SolrCore
operator|.
name|version
return|;
block|}
annotation|@
name|Override
DECL|method|getDescription
specifier|public
name|String
name|getDescription
parameter_list|()
block|{
return|return
literal|"SolrCore"
return|;
block|}
annotation|@
name|Override
DECL|method|getCategory
specifier|public
name|Category
name|getCategory
parameter_list|()
block|{
return|return
name|Category
operator|.
name|CORE
return|;
block|}
annotation|@
name|Override
DECL|method|getSource
specifier|public
name|String
name|getSource
parameter_list|()
block|{
return|return
literal|null
return|;
block|}
annotation|@
name|Override
DECL|method|getDocs
specifier|public
name|URL
index|[]
name|getDocs
parameter_list|()
block|{
return|return
literal|null
return|;
block|}
annotation|@
name|Override
DECL|method|getStatistics
specifier|public
name|NamedList
name|getStatistics
parameter_list|()
block|{
name|NamedList
argument_list|<
name|Object
argument_list|>
name|lst
init|=
operator|new
name|SimpleOrderedMap
argument_list|<>
argument_list|()
decl_stmt|;
name|lst
operator|.
name|add
argument_list|(
literal|"coreName"
argument_list|,
name|name
operator|==
literal|null
condition|?
literal|"(null)"
else|:
name|name
argument_list|)
expr_stmt|;
name|lst
operator|.
name|add
argument_list|(
literal|"startTime"
argument_list|,
operator|new
name|Date
argument_list|(
name|startTime
argument_list|)
argument_list|)
expr_stmt|;
name|lst
operator|.
name|add
argument_list|(
literal|"refCount"
argument_list|,
name|getOpenCount
argument_list|()
argument_list|)
expr_stmt|;
name|lst
operator|.
name|add
argument_list|(
literal|"instanceDir"
argument_list|,
name|resourceLoader
operator|.
name|getInstanceDir
argument_list|()
argument_list|)
expr_stmt|;
name|lst
operator|.
name|add
argument_list|(
literal|"indexDir"
argument_list|,
name|getIndexDir
argument_list|()
argument_list|)
expr_stmt|;
name|CoreDescriptor
name|cd
init|=
name|getCoreDescriptor
argument_list|()
decl_stmt|;
if|if
condition|(
name|cd
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
literal|null
operator|!=
name|cd
operator|&&
name|cd
operator|.
name|getCoreContainer
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|lst
operator|.
name|add
argument_list|(
literal|"aliases"
argument_list|,
name|getCoreDescriptor
argument_list|()
operator|.
name|getCoreContainer
argument_list|()
operator|.
name|getCoreNames
argument_list|(
name|this
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|CloudDescriptor
name|cloudDesc
init|=
name|cd
operator|.
name|getCloudDescriptor
argument_list|()
decl_stmt|;
if|if
condition|(
name|cloudDesc
operator|!=
literal|null
condition|)
block|{
name|String
name|collection
init|=
name|cloudDesc
operator|.
name|getCollectionName
argument_list|()
decl_stmt|;
if|if
condition|(
name|collection
operator|==
literal|null
condition|)
block|{
name|collection
operator|=
literal|"_notset_"
expr_stmt|;
block|}
name|lst
operator|.
name|add
argument_list|(
literal|"collection"
argument_list|,
name|collection
argument_list|)
expr_stmt|;
name|String
name|shard
init|=
name|cloudDesc
operator|.
name|getShardId
argument_list|()
decl_stmt|;
if|if
condition|(
name|shard
operator|==
literal|null
condition|)
block|{
name|shard
operator|=
literal|"_auto_"
expr_stmt|;
block|}
name|lst
operator|.
name|add
argument_list|(
literal|"shard"
argument_list|,
name|shard
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|lst
return|;
block|}
DECL|method|getCodec
specifier|public
name|Codec
name|getCodec
parameter_list|()
block|{
return|return
name|codec
return|;
block|}
DECL|method|unloadOnClose
specifier|public
name|void
name|unloadOnClose
parameter_list|(
name|boolean
name|deleteIndexDir
parameter_list|,
name|boolean
name|deleteDataDir
parameter_list|,
name|boolean
name|deleteInstanceDir
parameter_list|)
block|{
if|if
condition|(
name|deleteIndexDir
condition|)
block|{
try|try
block|{
name|directoryFactory
operator|.
name|remove
argument_list|(
name|getIndexDir
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|SolrException
operator|.
name|log
argument_list|(
name|log
argument_list|,
literal|"Failed to flag index dir for removal for core:"
operator|+
name|name
operator|+
literal|" dir:"
operator|+
name|getIndexDir
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|deleteDataDir
condition|)
block|{
try|try
block|{
name|directoryFactory
operator|.
name|remove
argument_list|(
name|getDataDir
argument_list|()
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|SolrException
operator|.
name|log
argument_list|(
name|log
argument_list|,
literal|"Failed to flag data dir for removal for core:"
operator|+
name|name
operator|+
literal|" dir:"
operator|+
name|getDataDir
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|deleteInstanceDir
condition|)
block|{
name|addCloseHook
argument_list|(
operator|new
name|CloseHook
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|preClose
parameter_list|(
name|SolrCore
name|core
parameter_list|)
block|{         }
annotation|@
name|Override
specifier|public
name|void
name|postClose
parameter_list|(
name|SolrCore
name|core
parameter_list|)
block|{
name|CoreDescriptor
name|cd
init|=
name|core
operator|.
name|getCoreDescriptor
argument_list|()
decl_stmt|;
if|if
condition|(
name|cd
operator|!=
literal|null
condition|)
block|{
name|File
name|instanceDir
init|=
operator|new
name|File
argument_list|(
name|cd
operator|.
name|getInstanceDir
argument_list|()
argument_list|)
decl_stmt|;
try|try
block|{
name|FileUtils
operator|.
name|deleteDirectory
argument_list|(
name|instanceDir
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|SolrException
operator|.
name|log
argument_list|(
name|log
argument_list|,
literal|"Failed to delete instance dir for core:"
operator|+
name|core
operator|.
name|getName
argument_list|()
operator|+
literal|" dir:"
operator|+
name|instanceDir
operator|.
name|getAbsolutePath
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|deleteUnloadedCore
specifier|public
specifier|static
name|void
name|deleteUnloadedCore
parameter_list|(
name|CoreDescriptor
name|cd
parameter_list|,
name|boolean
name|deleteDataDir
parameter_list|,
name|boolean
name|deleteInstanceDir
parameter_list|)
block|{
if|if
condition|(
name|deleteDataDir
condition|)
block|{
name|File
name|dataDir
init|=
operator|new
name|File
argument_list|(
name|cd
operator|.
name|getDataDir
argument_list|()
argument_list|)
decl_stmt|;
try|try
block|{
name|FileUtils
operator|.
name|deleteDirectory
argument_list|(
name|dataDir
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|SolrException
operator|.
name|log
argument_list|(
name|log
argument_list|,
literal|"Failed to delete data dir for unloaded core:"
operator|+
name|cd
operator|.
name|getName
argument_list|()
operator|+
literal|" dir:"
operator|+
name|dataDir
operator|.
name|getAbsolutePath
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|deleteInstanceDir
condition|)
block|{
name|File
name|instanceDir
init|=
operator|new
name|File
argument_list|(
name|cd
operator|.
name|getInstanceDir
argument_list|()
argument_list|)
decl_stmt|;
try|try
block|{
name|FileUtils
operator|.
name|deleteDirectory
argument_list|(
name|instanceDir
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|SolrException
operator|.
name|log
argument_list|(
name|log
argument_list|,
literal|"Failed to delete instance dir for unloaded core:"
operator|+
name|cd
operator|.
name|getName
argument_list|()
operator|+
literal|" dir:"
operator|+
name|instanceDir
operator|.
name|getAbsolutePath
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**Register to notify for any file change in the conf directory.    * If the file change results in a core reload , then the listener    * is not fired    */
DECL|method|addConfListener
specifier|public
name|void
name|addConfListener
parameter_list|(
name|Runnable
name|runnable
parameter_list|)
block|{
name|confListeners
operator|.
name|add
argument_list|(
name|runnable
argument_list|)
expr_stmt|;
block|}
comment|/**Remove a listener    * */
DECL|method|removeConfListener
specifier|public
name|boolean
name|removeConfListener
parameter_list|(
name|Runnable
name|runnable
parameter_list|)
block|{
return|return
name|confListeners
operator|.
name|remove
argument_list|(
name|runnable
argument_list|)
return|;
block|}
comment|/**This registers one listener for the entire conf directory. In zookeeper    * there is no event fired when children are modified. So , we expect everyone    * to 'touch' the /conf directory by setting some data  so that events are triggered.    */
DECL|method|registerConfListener
specifier|private
name|void
name|registerConfListener
parameter_list|()
block|{
if|if
condition|(
operator|!
operator|(
name|resourceLoader
operator|instanceof
name|ZkSolrResourceLoader
operator|)
condition|)
return|return;
specifier|final
name|ZkSolrResourceLoader
name|zkSolrResourceLoader
init|=
operator|(
name|ZkSolrResourceLoader
operator|)
name|resourceLoader
decl_stmt|;
if|if
condition|(
name|zkSolrResourceLoader
operator|!=
literal|null
condition|)
name|zkSolrResourceLoader
operator|.
name|getZkController
argument_list|()
operator|.
name|registerConfListenerForCore
argument_list|(
name|zkSolrResourceLoader
operator|.
name|getConfigSetZkPath
argument_list|()
argument_list|,
name|this
argument_list|,
name|getListener
argument_list|(
name|this
argument_list|,
name|zkSolrResourceLoader
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|getListener
specifier|private
specifier|static
name|Runnable
name|getListener
parameter_list|(
name|SolrCore
name|core
parameter_list|,
name|ZkSolrResourceLoader
name|zkSolrResourceLoader
parameter_list|)
block|{
specifier|final
name|String
name|coreName
init|=
name|core
operator|.
name|getName
argument_list|()
decl_stmt|;
specifier|final
name|CoreContainer
name|cc
init|=
name|core
operator|.
name|getCoreDescriptor
argument_list|()
operator|.
name|getCoreContainer
argument_list|()
decl_stmt|;
specifier|final
name|String
name|overlayPath
init|=
name|zkSolrResourceLoader
operator|.
name|getConfigSetZkPath
argument_list|()
operator|+
literal|"/"
operator|+
name|ConfigOverlay
operator|.
name|RESOURCE_NAME
decl_stmt|;
specifier|final
name|String
name|solrConfigPath
init|=
name|zkSolrResourceLoader
operator|.
name|getConfigSetZkPath
argument_list|()
operator|+
literal|"/"
operator|+
name|core
operator|.
name|getSolrConfig
argument_list|()
operator|.
name|getName
argument_list|()
decl_stmt|;
name|String
name|schemaRes
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|core
operator|.
name|getLatestSchema
argument_list|()
operator|.
name|isMutable
argument_list|()
operator|&&
name|core
operator|.
name|getLatestSchema
argument_list|()
operator|instanceof
name|ManagedIndexSchema
condition|)
block|{
name|ManagedIndexSchema
name|mis
init|=
operator|(
name|ManagedIndexSchema
operator|)
name|core
operator|.
name|getLatestSchema
argument_list|()
decl_stmt|;
name|schemaRes
operator|=
name|mis
operator|.
name|getResourceName
argument_list|()
expr_stmt|;
block|}
specifier|final
name|String
name|managedSchmaResourcePath
init|=
name|schemaRes
operator|==
literal|null
condition|?
literal|null
else|:
name|zkSolrResourceLoader
operator|.
name|getConfigSetZkPath
argument_list|()
operator|+
literal|"/"
operator|+
name|schemaRes
decl_stmt|;
return|return
operator|new
name|Runnable
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
name|log
operator|.
name|info
argument_list|(
literal|"config update listener called for core {}"
argument_list|,
name|coreName
argument_list|)
expr_stmt|;
name|SolrZkClient
name|zkClient
init|=
name|cc
operator|.
name|getZkController
argument_list|()
operator|.
name|getZkClient
argument_list|()
decl_stmt|;
name|int
name|solrConfigversion
decl_stmt|,
name|overlayVersion
decl_stmt|,
name|managedSchemaVersion
init|=
literal|0
decl_stmt|;
name|SolrConfig
name|cfg
init|=
literal|null
decl_stmt|;
try|try
init|(
name|SolrCore
name|core
init|=
name|cc
operator|.
name|solrCores
operator|.
name|getCoreFromAnyList
argument_list|(
name|coreName
argument_list|,
literal|true
argument_list|)
init|)
block|{
if|if
condition|(
name|core
operator|==
literal|null
operator|||
name|core
operator|.
name|isClosed
argument_list|()
condition|)
return|return;
name|cfg
operator|=
name|core
operator|.
name|getSolrConfig
argument_list|()
expr_stmt|;
name|solrConfigversion
operator|=
name|core
operator|.
name|getSolrConfig
argument_list|()
operator|.
name|getOverlay
argument_list|()
operator|.
name|getZnodeVersion
argument_list|()
expr_stmt|;
name|overlayVersion
operator|=
name|core
operator|.
name|getSolrConfig
argument_list|()
operator|.
name|getZnodeVersion
argument_list|()
expr_stmt|;
if|if
condition|(
name|managedSchmaResourcePath
operator|!=
literal|null
condition|)
block|{
name|managedSchemaVersion
operator|=
operator|(
operator|(
name|ManagedIndexSchema
operator|)
name|core
operator|.
name|getLatestSchema
argument_list|()
operator|)
operator|.
name|getSchemaZkVersion
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|cfg
operator|!=
literal|null
condition|)
block|{
name|cfg
operator|.
name|refreshRequestParams
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|checkStale
argument_list|(
name|zkClient
argument_list|,
name|overlayPath
argument_list|,
name|solrConfigversion
argument_list|)
operator|||
name|checkStale
argument_list|(
name|zkClient
argument_list|,
name|solrConfigPath
argument_list|,
name|overlayVersion
argument_list|)
operator|||
name|checkStale
argument_list|(
name|zkClient
argument_list|,
name|managedSchmaResourcePath
argument_list|,
name|managedSchemaVersion
argument_list|)
condition|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"core reload {}"
argument_list|,
name|coreName
argument_list|)
expr_stmt|;
name|cc
operator|.
name|reload
argument_list|(
name|coreName
argument_list|)
expr_stmt|;
return|return;
block|}
comment|//some files in conf directoy has changed other than schema.xml,
comment|// solrconfig.xml. so fire event listeners
try|try
init|(
name|SolrCore
name|core
init|=
name|cc
operator|.
name|solrCores
operator|.
name|getCoreFromAnyList
argument_list|(
name|coreName
argument_list|,
literal|true
argument_list|)
init|)
block|{
if|if
condition|(
name|core
operator|==
literal|null
operator|||
name|core
operator|.
name|isClosed
argument_list|()
condition|)
return|return;
for|for
control|(
name|Runnable
name|listener
range|:
name|core
operator|.
name|confListeners
control|)
block|{
try|try
block|{
name|listener
operator|.
name|run
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"Error in listener "
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
return|;
block|}
DECL|method|registerInfoBean
specifier|public
name|void
name|registerInfoBean
parameter_list|(
name|String
name|name
parameter_list|,
name|SolrInfoMBean
name|solrInfoMBean
parameter_list|)
block|{
name|infoRegistry
operator|.
name|put
argument_list|(
name|name
argument_list|,
name|solrInfoMBean
argument_list|)
expr_stmt|;
block|}
DECL|method|checkStale
specifier|private
specifier|static
name|boolean
name|checkStale
parameter_list|(
name|SolrZkClient
name|zkClient
parameter_list|,
name|String
name|zkPath
parameter_list|,
name|int
name|currentVersion
parameter_list|)
block|{
if|if
condition|(
name|zkPath
operator|==
literal|null
condition|)
return|return
literal|false
return|;
try|try
block|{
name|Stat
name|stat
init|=
name|zkClient
operator|.
name|exists
argument_list|(
name|zkPath
argument_list|,
literal|null
argument_list|,
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
name|stat
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|currentVersion
operator|>
operator|-
literal|1
condition|)
return|return
literal|true
return|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|stat
operator|.
name|getVersion
argument_list|()
operator|>
name|currentVersion
condition|)
block|{
name|log
operator|.
name|info
argument_list|(
name|zkPath
operator|+
literal|" is stale will need an update from {} to {}"
argument_list|,
name|currentVersion
argument_list|,
name|stat
operator|.
name|getVersion
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
catch|catch
parameter_list|(
name|KeeperException
operator|.
name|NoNodeException
name|nne
parameter_list|)
block|{
comment|//no problem
block|}
catch|catch
parameter_list|(
name|KeeperException
name|e
parameter_list|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"error refreshing solrconfig "
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|isInterrupted
argument_list|()
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
block|}
end_class
end_unit
