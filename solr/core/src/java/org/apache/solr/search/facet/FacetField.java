begin_unit
begin_package
DECL|package|org.apache.solr.search.facet
package|package
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|search
operator|.
name|facet
package|;
end_package
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Closeable
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|Fields
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|LeafReaderContext
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|MultiPostingsEnum
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|PostingsEnum
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|SortedDocValues
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|Term
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|Terms
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|TermsEnum
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|DocIdSetIterator
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|TermQuery
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|BytesRef
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|BytesRefBuilder
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|PriorityQueue
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|StringHelper
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|UnicodeUtil
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|SolrException
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|util
operator|.
name|SimpleOrderedMap
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|request
operator|.
name|SimpleFacets
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|schema
operator|.
name|FieldType
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|schema
operator|.
name|SchemaField
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|search
operator|.
name|DocIterator
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|search
operator|.
name|DocSet
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|search
operator|.
name|HashDocSet
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|search
operator|.
name|SolrIndexSearcher
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|search
operator|.
name|SortedIntDocSet
import|;
end_import
begin_class
DECL|class|FacetField
specifier|public
class|class
name|FacetField
extends|extends
name|FacetRequest
block|{
DECL|field|field
name|String
name|field
decl_stmt|;
DECL|field|offset
name|long
name|offset
decl_stmt|;
DECL|field|limit
name|long
name|limit
init|=
literal|10
decl_stmt|;
DECL|field|mincount
name|long
name|mincount
init|=
literal|1
decl_stmt|;
DECL|field|missing
name|boolean
name|missing
decl_stmt|;
DECL|field|numBuckets
name|boolean
name|numBuckets
decl_stmt|;
DECL|field|prefix
name|String
name|prefix
decl_stmt|;
DECL|field|sortVariable
name|String
name|sortVariable
decl_stmt|;
DECL|field|sortDirection
name|SortDirection
name|sortDirection
decl_stmt|;
DECL|field|method
name|FacetMethod
name|method
decl_stmt|;
DECL|field|allBuckets
name|boolean
name|allBuckets
decl_stmt|;
comment|// show cumulative stats across all buckets (this can be different than non-bucketed stats across all docs because of multi-valued docs)
DECL|field|cacheDf
name|int
name|cacheDf
decl_stmt|;
comment|// 0 means "default", -1 means "never cache"
comment|// TODO: put this somewhere more generic?
DECL|enum|SortDirection
specifier|public
specifier|static
enum|enum
name|SortDirection
block|{
DECL|enum constant|asc
name|asc
argument_list|(
operator|-
literal|1
argument_list|)
block|,
DECL|enum constant|desc
name|desc
argument_list|(
literal|1
argument_list|)
block|;
DECL|field|multiplier
specifier|private
specifier|final
name|int
name|multiplier
decl_stmt|;
DECL|method|SortDirection
specifier|private
name|SortDirection
parameter_list|(
name|int
name|multiplier
parameter_list|)
block|{
name|this
operator|.
name|multiplier
operator|=
name|multiplier
expr_stmt|;
block|}
comment|// asc==-1, desc==1
DECL|method|getMultiplier
specifier|public
name|int
name|getMultiplier
parameter_list|()
block|{
return|return
name|multiplier
return|;
block|}
block|}
DECL|enum|FacetMethod
specifier|public
specifier|static
enum|enum
name|FacetMethod
block|{
DECL|enum constant|ENUM
name|ENUM
block|,
DECL|enum constant|STREAM
name|STREAM
block|,
DECL|enum constant|FIELDCACHE
name|FIELDCACHE
block|,
DECL|enum constant|SMART
name|SMART
block|,     ;
DECL|method|fromString
specifier|public
specifier|static
name|FacetMethod
name|fromString
parameter_list|(
name|String
name|method
parameter_list|)
block|{
if|if
condition|(
name|method
operator|==
literal|null
operator|||
name|method
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
return|return
literal|null
return|;
if|if
condition|(
literal|"enum"
operator|.
name|equals
argument_list|(
name|method
argument_list|)
condition|)
block|{
return|return
name|ENUM
return|;
block|}
elseif|else
if|if
condition|(
literal|"fc"
operator|.
name|equals
argument_list|(
name|method
argument_list|)
operator|||
literal|"fieldcache"
operator|.
name|equals
argument_list|(
name|method
argument_list|)
condition|)
block|{
return|return
name|FIELDCACHE
return|;
block|}
elseif|else
if|if
condition|(
literal|"smart"
operator|.
name|equals
argument_list|(
name|method
argument_list|)
condition|)
block|{
return|return
name|SMART
return|;
block|}
elseif|else
if|if
condition|(
literal|"stream"
operator|.
name|equals
argument_list|(
name|method
argument_list|)
condition|)
block|{
return|return
name|STREAM
return|;
block|}
throw|throw
operator|new
name|SolrException
argument_list|(
name|SolrException
operator|.
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
literal|"Unknown FacetField method "
operator|+
name|method
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
DECL|method|createFacetProcessor
specifier|public
name|FacetProcessor
name|createFacetProcessor
parameter_list|(
name|FacetContext
name|fcontext
parameter_list|)
block|{
name|SchemaField
name|sf
init|=
name|fcontext
operator|.
name|searcher
operator|.
name|getSchema
argument_list|()
operator|.
name|getField
argument_list|(
name|field
argument_list|)
decl_stmt|;
name|FieldType
name|ft
init|=
name|sf
operator|.
name|getType
argument_list|()
decl_stmt|;
name|boolean
name|multiToken
init|=
name|sf
operator|.
name|multiValued
argument_list|()
operator|||
name|ft
operator|.
name|multiValuedFieldCache
argument_list|()
decl_stmt|;
if|if
condition|(
name|method
operator|==
name|FacetMethod
operator|.
name|ENUM
operator|&&
name|sf
operator|.
name|indexed
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
elseif|else
if|if
condition|(
name|method
operator|==
name|FacetMethod
operator|.
name|STREAM
operator|&&
name|sf
operator|.
name|indexed
argument_list|()
condition|)
block|{
return|return
operator|new
name|FacetFieldProcessorStream
argument_list|(
name|fcontext
argument_list|,
name|this
argument_list|,
name|sf
argument_list|)
return|;
block|}
if|if
condition|(
name|multiToken
condition|)
block|{
return|return
operator|new
name|FacetFieldProcessorUIF
argument_list|(
name|fcontext
argument_list|,
name|this
argument_list|,
name|sf
argument_list|)
return|;
block|}
else|else
block|{
comment|// single valued string
return|return
operator|new
name|FacetFieldProcessorFC
argument_list|(
name|fcontext
argument_list|,
name|this
argument_list|,
name|sf
argument_list|)
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|createFacetMerger
specifier|public
name|FacetMerger
name|createFacetMerger
parameter_list|(
name|Object
name|prototype
parameter_list|)
block|{
return|return
operator|new
name|FacetFieldMerger
argument_list|(
name|this
argument_list|)
return|;
block|}
block|}
end_class
begin_class
DECL|class|FacetFieldProcessor
specifier|abstract
class|class
name|FacetFieldProcessor
extends|extends
name|FacetProcessor
argument_list|<
name|FacetField
argument_list|>
block|{
DECL|field|sf
name|SchemaField
name|sf
decl_stmt|;
DECL|field|sortAcc
name|SlotAcc
name|sortAcc
decl_stmt|;
DECL|method|FacetFieldProcessor
name|FacetFieldProcessor
parameter_list|(
name|FacetContext
name|fcontext
parameter_list|,
name|FacetField
name|freq
parameter_list|,
name|SchemaField
name|sf
parameter_list|)
block|{
name|super
argument_list|(
name|fcontext
argument_list|,
name|freq
argument_list|)
expr_stmt|;
name|this
operator|.
name|sf
operator|=
name|sf
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|getResponse
specifier|public
name|Object
name|getResponse
parameter_list|()
block|{
return|return
name|response
return|;
block|}
DECL|method|setSortAcc
name|void
name|setSortAcc
parameter_list|(
name|int
name|numSlots
parameter_list|)
block|{
name|String
name|sortKey
init|=
name|freq
operator|.
name|sortVariable
decl_stmt|;
name|sortAcc
operator|=
name|accMap
operator|.
name|get
argument_list|(
name|sortKey
argument_list|)
expr_stmt|;
if|if
condition|(
name|sortAcc
operator|==
literal|null
condition|)
block|{
if|if
condition|(
literal|"count"
operator|.
name|equals
argument_list|(
name|sortKey
argument_list|)
condition|)
block|{
name|sortAcc
operator|=
name|countAcc
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|"index"
operator|.
name|equals
argument_list|(
name|sortKey
argument_list|)
condition|)
block|{
name|sortAcc
operator|=
operator|new
name|SortSlotAcc
argument_list|(
name|fcontext
argument_list|)
expr_stmt|;
comment|// This sorting accumulator just goes by the slot number, so does not need to be collected
comment|// and hence does not need to find it's way into the accMap or accs array.
block|}
block|}
block|}
DECL|class|Slot
specifier|static
class|class
name|Slot
block|{
DECL|field|slot
name|int
name|slot
decl_stmt|;
block|}
block|}
end_class
begin_comment
comment|// base class for FC style of facet counting (single and multi-valued strings)
end_comment
begin_class
DECL|class|FacetFieldProcessorFCBase
specifier|abstract
class|class
name|FacetFieldProcessorFCBase
extends|extends
name|FacetFieldProcessor
block|{
DECL|field|prefixRef
name|BytesRefBuilder
name|prefixRef
decl_stmt|;
DECL|field|startTermIndex
name|int
name|startTermIndex
decl_stmt|;
DECL|field|endTermIndex
name|int
name|endTermIndex
decl_stmt|;
DECL|field|nTerms
name|int
name|nTerms
decl_stmt|;
DECL|field|nDocs
name|int
name|nDocs
decl_stmt|;
DECL|field|maxSlots
name|int
name|maxSlots
decl_stmt|;
DECL|field|allBucketsSlot
name|int
name|allBucketsSlot
decl_stmt|;
DECL|method|FacetFieldProcessorFCBase
specifier|public
name|FacetFieldProcessorFCBase
parameter_list|(
name|FacetContext
name|fcontext
parameter_list|,
name|FacetField
name|freq
parameter_list|,
name|SchemaField
name|sf
parameter_list|)
block|{
name|super
argument_list|(
name|fcontext
argument_list|,
name|freq
argument_list|,
name|sf
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|process
specifier|public
name|void
name|process
parameter_list|()
throws|throws
name|IOException
block|{
name|sf
operator|=
name|fcontext
operator|.
name|searcher
operator|.
name|getSchema
argument_list|()
operator|.
name|getField
argument_list|(
name|freq
operator|.
name|field
argument_list|)
expr_stmt|;
name|response
operator|=
name|getFieldCacheCounts
argument_list|()
expr_stmt|;
block|}
DECL|method|lookupOrd
specifier|abstract
specifier|protected
name|BytesRef
name|lookupOrd
parameter_list|(
name|int
name|ord
parameter_list|)
throws|throws
name|IOException
function_decl|;
DECL|method|findStartAndEndOrds
specifier|abstract
specifier|protected
name|void
name|findStartAndEndOrds
parameter_list|()
throws|throws
name|IOException
function_decl|;
DECL|method|collectDocs
specifier|abstract
specifier|protected
name|void
name|collectDocs
parameter_list|()
throws|throws
name|IOException
function_decl|;
DECL|method|getFieldCacheCounts
specifier|public
name|SimpleOrderedMap
argument_list|<
name|Object
argument_list|>
name|getFieldCacheCounts
parameter_list|()
throws|throws
name|IOException
block|{
name|String
name|prefix
init|=
name|freq
operator|.
name|prefix
decl_stmt|;
if|if
condition|(
name|prefix
operator|==
literal|null
operator|||
name|prefix
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
block|{
name|prefixRef
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
name|prefixRef
operator|=
operator|new
name|BytesRefBuilder
argument_list|()
expr_stmt|;
name|prefixRef
operator|.
name|copyChars
argument_list|(
name|prefix
argument_list|)
expr_stmt|;
block|}
name|findStartAndEndOrds
argument_list|()
expr_stmt|;
comment|// if we need an extra slot for the "missing" bucket, and it wasn't able to be tacked onto the beginning,
comment|// then lets add room for it at the end.
name|maxSlots
operator|=
operator|(
name|freq
operator|.
name|missing
operator|&&
name|startTermIndex
operator|!=
operator|-
literal|1
operator|)
condition|?
name|nTerms
operator|+
literal|1
else|:
name|nTerms
expr_stmt|;
if|if
condition|(
name|freq
operator|.
name|allBuckets
condition|)
block|{
name|allBucketsSlot
operator|=
name|maxSlots
expr_stmt|;
name|maxSlots
operator|++
expr_stmt|;
block|}
else|else
block|{
name|allBucketsSlot
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|createAccs
argument_list|(
name|nDocs
argument_list|,
name|maxSlots
argument_list|)
expr_stmt|;
name|setSortAcc
argument_list|(
name|maxSlots
argument_list|)
expr_stmt|;
name|prepareForCollection
argument_list|()
expr_stmt|;
name|collectDocs
argument_list|()
expr_stmt|;
return|return
name|findTopSlots
argument_list|()
return|;
block|}
DECL|method|findTopSlots
specifier|protected
name|SimpleOrderedMap
argument_list|<
name|Object
argument_list|>
name|findTopSlots
parameter_list|()
throws|throws
name|IOException
block|{
name|SimpleOrderedMap
argument_list|<
name|Object
argument_list|>
name|res
init|=
operator|new
name|SimpleOrderedMap
argument_list|<>
argument_list|()
decl_stmt|;
name|int
name|numBuckets
init|=
literal|0
decl_stmt|;
name|List
argument_list|<
name|Object
argument_list|>
name|bucketVals
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|freq
operator|.
name|numBuckets
operator|&&
name|fcontext
operator|.
name|isShard
argument_list|()
condition|)
block|{
name|bucketVals
operator|=
operator|new
name|ArrayList
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
name|int
name|off
init|=
name|fcontext
operator|.
name|isShard
argument_list|()
condition|?
literal|0
else|:
operator|(
name|int
operator|)
name|freq
operator|.
name|offset
decl_stmt|;
comment|// add a modest amount of over-request if this is a shard request
name|int
name|lim
init|=
name|freq
operator|.
name|limit
operator|>=
literal|0
condition|?
operator|(
name|fcontext
operator|.
name|isShard
argument_list|()
condition|?
call|(
name|int
call|)
argument_list|(
name|freq
operator|.
name|limit
operator|*
literal|1.1
operator|+
literal|4
argument_list|)
else|:
operator|(
name|int
operator|)
name|freq
operator|.
name|limit
operator|)
else|:
name|Integer
operator|.
name|MAX_VALUE
decl_stmt|;
name|int
name|maxsize
init|=
name|freq
operator|.
name|limit
operator|>
literal|0
condition|?
name|off
operator|+
name|lim
else|:
name|Integer
operator|.
name|MAX_VALUE
operator|-
literal|1
decl_stmt|;
name|maxsize
operator|=
name|Math
operator|.
name|min
argument_list|(
name|maxsize
argument_list|,
name|nTerms
argument_list|)
expr_stmt|;
specifier|final
name|int
name|sortMul
init|=
name|freq
operator|.
name|sortDirection
operator|.
name|getMultiplier
argument_list|()
decl_stmt|;
specifier|final
name|SlotAcc
name|sortAcc
init|=
name|this
operator|.
name|sortAcc
decl_stmt|;
name|PriorityQueue
argument_list|<
name|Slot
argument_list|>
name|queue
init|=
operator|new
name|PriorityQueue
argument_list|<
name|Slot
argument_list|>
argument_list|(
name|maxsize
argument_list|)
block|{
annotation|@
name|Override
specifier|protected
name|boolean
name|lessThan
parameter_list|(
name|Slot
name|a
parameter_list|,
name|Slot
name|b
parameter_list|)
block|{
name|int
name|cmp
init|=
name|sortAcc
operator|.
name|compare
argument_list|(
name|a
operator|.
name|slot
argument_list|,
name|b
operator|.
name|slot
argument_list|)
operator|*
name|sortMul
decl_stmt|;
return|return
name|cmp
operator|==
literal|0
condition|?
name|b
operator|.
name|slot
operator|<
name|a
operator|.
name|slot
else|:
name|cmp
operator|<
literal|0
return|;
block|}
block|}
decl_stmt|;
name|Slot
name|bottom
init|=
literal|null
decl_stmt|;
name|int
name|effectiveMincount
init|=
call|(
name|int
call|)
argument_list|(
name|fcontext
operator|.
name|isShard
argument_list|()
condition|?
name|Math
operator|.
name|min
argument_list|(
literal|1
argument_list|,
name|freq
operator|.
name|mincount
argument_list|)
else|:
name|freq
operator|.
name|mincount
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
operator|(
name|startTermIndex
operator|==
operator|-
literal|1
operator|)
condition|?
literal|1
else|:
literal|0
init|;
name|i
operator|<
name|nTerms
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|countAcc
operator|.
name|getCount
argument_list|(
name|i
argument_list|)
operator|<
name|effectiveMincount
condition|)
block|{
continue|continue;
block|}
name|numBuckets
operator|++
expr_stmt|;
if|if
condition|(
name|bucketVals
operator|!=
literal|null
operator|&&
name|bucketVals
operator|.
name|size
argument_list|()
operator|<
literal|100
condition|)
block|{
name|int
name|ord
init|=
name|startTermIndex
operator|+
name|i
decl_stmt|;
name|BytesRef
name|br
init|=
name|lookupOrd
argument_list|(
name|ord
argument_list|)
decl_stmt|;
name|Object
name|val
init|=
name|sf
operator|.
name|getType
argument_list|()
operator|.
name|toObject
argument_list|(
name|sf
argument_list|,
name|br
argument_list|)
decl_stmt|;
name|bucketVals
operator|.
name|add
argument_list|(
name|val
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bottom
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|sortAcc
operator|.
name|compare
argument_list|(
name|bottom
operator|.
name|slot
argument_list|,
name|i
argument_list|)
operator|*
name|sortMul
operator|<
literal|0
condition|)
block|{
name|bottom
operator|.
name|slot
operator|=
name|i
expr_stmt|;
name|bottom
operator|=
name|queue
operator|.
name|updateTop
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// queue not full
name|Slot
name|s
init|=
operator|new
name|Slot
argument_list|()
decl_stmt|;
name|s
operator|.
name|slot
operator|=
name|i
expr_stmt|;
name|queue
operator|.
name|add
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|queue
operator|.
name|size
argument_list|()
operator|>=
name|maxsize
condition|)
block|{
name|bottom
operator|=
name|queue
operator|.
name|top
argument_list|()
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|freq
operator|.
name|numBuckets
condition|)
block|{
if|if
condition|(
operator|!
name|fcontext
operator|.
name|isShard
argument_list|()
condition|)
block|{
name|res
operator|.
name|add
argument_list|(
literal|"numBuckets"
argument_list|,
name|numBuckets
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SimpleOrderedMap
name|map
init|=
operator|new
name|SimpleOrderedMap
argument_list|(
literal|2
argument_list|)
decl_stmt|;
name|map
operator|.
name|add
argument_list|(
literal|"numBuckets"
argument_list|,
name|numBuckets
argument_list|)
expr_stmt|;
name|map
operator|.
name|add
argument_list|(
literal|"vals"
argument_list|,
name|bucketVals
argument_list|)
expr_stmt|;
name|res
operator|.
name|add
argument_list|(
literal|"numBuckets"
argument_list|,
name|map
argument_list|)
expr_stmt|;
block|}
block|}
comment|// if we are deep paging, we don't have to order the highest "offset" counts.
name|int
name|collectCount
init|=
name|Math
operator|.
name|max
argument_list|(
literal|0
argument_list|,
name|queue
operator|.
name|size
argument_list|()
operator|-
name|off
argument_list|)
decl_stmt|;
assert|assert
name|collectCount
operator|<=
name|lim
assert|;
name|int
index|[]
name|sortedSlots
init|=
operator|new
name|int
index|[
name|collectCount
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|collectCount
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|sortedSlots
index|[
name|i
index|]
operator|=
name|queue
operator|.
name|pop
argument_list|()
operator|.
name|slot
expr_stmt|;
block|}
if|if
condition|(
name|freq
operator|.
name|allBuckets
condition|)
block|{
name|SimpleOrderedMap
argument_list|<
name|Object
argument_list|>
name|allBuckets
init|=
operator|new
name|SimpleOrderedMap
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|SlotAcc
name|acc
range|:
name|accs
control|)
block|{
name|countAcc
operator|.
name|setValues
argument_list|(
name|allBuckets
argument_list|,
name|allBucketsSlot
argument_list|)
expr_stmt|;
name|acc
operator|.
name|setValues
argument_list|(
name|allBuckets
argument_list|,
name|allBucketsSlot
argument_list|)
expr_stmt|;
block|}
name|res
operator|.
name|add
argument_list|(
literal|"allBuckets"
argument_list|,
name|allBuckets
argument_list|)
expr_stmt|;
block|}
name|ArrayList
name|bucketList
init|=
operator|new
name|ArrayList
argument_list|(
name|collectCount
argument_list|)
decl_stmt|;
name|res
operator|.
name|add
argument_list|(
literal|"buckets"
argument_list|,
name|bucketList
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|slotNum
range|:
name|sortedSlots
control|)
block|{
name|SimpleOrderedMap
argument_list|<
name|Object
argument_list|>
name|bucket
init|=
operator|new
name|SimpleOrderedMap
argument_list|<>
argument_list|()
decl_stmt|;
comment|// get the ord of the slot...
name|int
name|ord
init|=
name|startTermIndex
operator|+
name|slotNum
decl_stmt|;
name|BytesRef
name|br
init|=
name|lookupOrd
argument_list|(
name|ord
argument_list|)
decl_stmt|;
name|Object
name|val
init|=
name|sf
operator|.
name|getType
argument_list|()
operator|.
name|toObject
argument_list|(
name|sf
argument_list|,
name|br
argument_list|)
decl_stmt|;
name|bucket
operator|.
name|add
argument_list|(
literal|"val"
argument_list|,
name|val
argument_list|)
expr_stmt|;
comment|// add stats for this bucket
name|addStats
argument_list|(
name|bucket
argument_list|,
name|slotNum
argument_list|)
expr_stmt|;
comment|// handle sub-facets for this bucket
if|if
condition|(
name|freq
operator|.
name|getSubFacets
argument_list|()
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|FacetContext
name|subContext
init|=
name|fcontext
operator|.
name|sub
argument_list|()
decl_stmt|;
name|subContext
operator|.
name|base
operator|=
name|fcontext
operator|.
name|searcher
operator|.
name|getDocSet
argument_list|(
operator|new
name|TermQuery
argument_list|(
operator|new
name|Term
argument_list|(
name|sf
operator|.
name|getName
argument_list|()
argument_list|,
name|br
operator|.
name|clone
argument_list|()
argument_list|)
argument_list|)
argument_list|,
name|fcontext
operator|.
name|base
argument_list|)
expr_stmt|;
try|try
block|{
name|fillBucketSubs
argument_list|(
name|bucket
argument_list|,
name|subContext
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
comment|// subContext.base.decref();  // OFF-HEAP
comment|// subContext.base = null;  // do not modify context after creation... there may be deferred execution (i.e. streaming)
block|}
block|}
name|bucketList
operator|.
name|add
argument_list|(
name|bucket
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|freq
operator|.
name|missing
condition|)
block|{
name|SimpleOrderedMap
argument_list|<
name|Object
argument_list|>
name|missingBucket
init|=
operator|new
name|SimpleOrderedMap
argument_list|<>
argument_list|()
decl_stmt|;
name|DocSet
name|missingDocSet
init|=
literal|null
decl_stmt|;
try|try
block|{
if|if
condition|(
name|startTermIndex
operator|==
operator|-
literal|1
condition|)
block|{
name|addStats
argument_list|(
name|missingBucket
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|missingDocSet
operator|=
name|getFieldMissing
argument_list|(
name|fcontext
operator|.
name|searcher
argument_list|,
name|fcontext
operator|.
name|base
argument_list|,
name|freq
operator|.
name|field
argument_list|)
expr_stmt|;
comment|// an extra slot was added to the end for this missing bucket
name|countAcc
operator|.
name|incrementCount
argument_list|(
name|nTerms
argument_list|,
name|missingDocSet
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|collect
argument_list|(
name|missingDocSet
argument_list|,
name|nTerms
argument_list|)
expr_stmt|;
name|addStats
argument_list|(
name|missingBucket
argument_list|,
name|nTerms
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|freq
operator|.
name|getSubFacets
argument_list|()
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|FacetContext
name|subContext
init|=
name|fcontext
operator|.
name|sub
argument_list|()
decl_stmt|;
comment|// TODO: we can do better than this!
if|if
condition|(
name|missingDocSet
operator|==
literal|null
condition|)
block|{
name|missingDocSet
operator|=
name|getFieldMissing
argument_list|(
name|fcontext
operator|.
name|searcher
argument_list|,
name|fcontext
operator|.
name|base
argument_list|,
name|freq
operator|.
name|field
argument_list|)
expr_stmt|;
block|}
name|subContext
operator|.
name|base
operator|=
name|missingDocSet
expr_stmt|;
name|fillBucketSubs
argument_list|(
name|missingBucket
argument_list|,
name|subContext
argument_list|)
expr_stmt|;
block|}
name|res
operator|.
name|add
argument_list|(
literal|"missing"
argument_list|,
name|missingBucket
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
name|missingDocSet
operator|!=
literal|null
condition|)
block|{
comment|// missingDocSet.decref(); // OFF-HEAP
name|missingDocSet
operator|=
literal|null
expr_stmt|;
block|}
block|}
block|}
return|return
name|res
return|;
block|}
block|}
end_class
begin_class
DECL|class|FacetFieldProcessorFC
class|class
name|FacetFieldProcessorFC
extends|extends
name|FacetFieldProcessorFCBase
block|{
DECL|field|sortedDocValues
name|SortedDocValues
name|sortedDocValues
decl_stmt|;
DECL|method|FacetFieldProcessorFC
specifier|public
name|FacetFieldProcessorFC
parameter_list|(
name|FacetContext
name|fcontext
parameter_list|,
name|FacetField
name|freq
parameter_list|,
name|SchemaField
name|sf
parameter_list|)
block|{
name|super
argument_list|(
name|fcontext
argument_list|,
name|freq
argument_list|,
name|sf
argument_list|)
expr_stmt|;
block|}
DECL|method|lookupOrd
specifier|protected
name|BytesRef
name|lookupOrd
parameter_list|(
name|int
name|ord
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|sortedDocValues
operator|.
name|lookupOrd
argument_list|(
name|ord
argument_list|)
return|;
block|}
DECL|method|findStartAndEndOrds
specifier|protected
name|void
name|findStartAndEndOrds
parameter_list|()
throws|throws
name|IOException
block|{
name|sortedDocValues
operator|=
name|FieldUtil
operator|.
name|getSortedDocValues
argument_list|(
name|fcontext
operator|.
name|qcontext
argument_list|,
name|sf
argument_list|,
literal|null
argument_list|)
expr_stmt|;
if|if
condition|(
name|prefixRef
operator|!=
literal|null
condition|)
block|{
name|startTermIndex
operator|=
name|sortedDocValues
operator|.
name|lookupTerm
argument_list|(
name|prefixRef
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|startTermIndex
operator|<
literal|0
condition|)
name|startTermIndex
operator|=
operator|-
name|startTermIndex
operator|-
literal|1
expr_stmt|;
name|prefixRef
operator|.
name|append
argument_list|(
name|UnicodeUtil
operator|.
name|BIG_TERM
argument_list|)
expr_stmt|;
name|endTermIndex
operator|=
name|sortedDocValues
operator|.
name|lookupTerm
argument_list|(
name|prefixRef
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
assert|assert
name|endTermIndex
operator|<
literal|0
assert|;
name|endTermIndex
operator|=
operator|-
name|endTermIndex
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|startTermIndex
operator|=
literal|0
expr_stmt|;
name|endTermIndex
operator|=
name|sortedDocValues
operator|.
name|getValueCount
argument_list|()
expr_stmt|;
block|}
comment|// optimize collecting the "missing" bucket when startTermindex is 0 (since the "missing" ord is -1)
name|startTermIndex
operator|=
name|startTermIndex
operator|==
literal|0
operator|&&
name|freq
operator|.
name|missing
condition|?
operator|-
literal|1
else|:
name|startTermIndex
expr_stmt|;
name|nTerms
operator|=
name|endTermIndex
operator|-
name|startTermIndex
expr_stmt|;
block|}
DECL|method|collectDocs
specifier|protected
name|void
name|collectDocs
parameter_list|()
throws|throws
name|IOException
block|{
specifier|final
name|List
argument_list|<
name|LeafReaderContext
argument_list|>
name|leaves
init|=
name|fcontext
operator|.
name|searcher
operator|.
name|getIndexReader
argument_list|()
operator|.
name|leaves
argument_list|()
decl_stmt|;
specifier|final
name|Iterator
argument_list|<
name|LeafReaderContext
argument_list|>
name|ctxIt
init|=
name|leaves
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|LeafReaderContext
name|ctx
init|=
literal|null
decl_stmt|;
name|int
name|segBase
init|=
literal|0
decl_stmt|;
name|int
name|segMax
decl_stmt|;
name|int
name|adjustedMax
init|=
literal|0
decl_stmt|;
for|for
control|(
name|DocIterator
name|docsIt
init|=
name|fcontext
operator|.
name|base
operator|.
name|iterator
argument_list|()
init|;
name|docsIt
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
specifier|final
name|int
name|doc
init|=
name|docsIt
operator|.
name|nextDoc
argument_list|()
decl_stmt|;
if|if
condition|(
name|doc
operator|>=
name|adjustedMax
condition|)
block|{
do|do
block|{
name|ctx
operator|=
name|ctxIt
operator|.
name|next
argument_list|()
expr_stmt|;
name|segBase
operator|=
name|ctx
operator|.
name|docBase
expr_stmt|;
name|segMax
operator|=
name|ctx
operator|.
name|reader
argument_list|()
operator|.
name|maxDoc
argument_list|()
expr_stmt|;
name|adjustedMax
operator|=
name|segBase
operator|+
name|segMax
expr_stmt|;
block|}
do|while
condition|(
name|doc
operator|>=
name|adjustedMax
condition|)
do|;
assert|assert
name|doc
operator|>=
name|ctx
operator|.
name|docBase
assert|;
name|setNextReader
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
block|}
name|int
name|term
init|=
name|sortedDocValues
operator|.
name|getOrd
argument_list|(
name|doc
argument_list|)
decl_stmt|;
name|int
name|arrIdx
init|=
name|term
operator|-
name|startTermIndex
decl_stmt|;
if|if
condition|(
name|arrIdx
operator|>=
literal|0
operator|&&
name|arrIdx
operator|<
name|nTerms
condition|)
block|{
name|countAcc
operator|.
name|incrementCount
argument_list|(
name|arrIdx
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|collect
argument_list|(
name|doc
operator|-
name|segBase
argument_list|,
name|arrIdx
argument_list|)
expr_stmt|;
comment|// per-seg collectors
if|if
condition|(
name|allBucketsSlot
operator|>=
literal|0
operator|&&
name|term
operator|>=
literal|0
condition|)
block|{
name|countAcc
operator|.
name|incrementCount
argument_list|(
name|allBucketsSlot
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|collect
argument_list|(
name|doc
operator|-
name|segBase
argument_list|,
name|allBucketsSlot
argument_list|)
expr_stmt|;
comment|// per-seg collectors
block|}
block|}
block|}
block|}
block|}
end_class
begin_comment
comment|// UnInvertedField implementation of field faceting
end_comment
begin_class
DECL|class|FacetFieldProcessorUIF
class|class
name|FacetFieldProcessorUIF
extends|extends
name|FacetFieldProcessorFC
block|{
DECL|field|uif
name|UnInvertedField
name|uif
decl_stmt|;
DECL|field|te
name|TermsEnum
name|te
decl_stmt|;
DECL|method|FacetFieldProcessorUIF
name|FacetFieldProcessorUIF
parameter_list|(
name|FacetContext
name|fcontext
parameter_list|,
name|FacetField
name|freq
parameter_list|,
name|SchemaField
name|sf
parameter_list|)
block|{
name|super
argument_list|(
name|fcontext
argument_list|,
name|freq
argument_list|,
name|sf
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|findStartAndEndOrds
specifier|protected
name|void
name|findStartAndEndOrds
parameter_list|()
throws|throws
name|IOException
block|{
name|uif
operator|=
name|UnInvertedField
operator|.
name|getUnInvertedField
argument_list|(
name|freq
operator|.
name|field
argument_list|,
name|fcontext
operator|.
name|searcher
argument_list|)
expr_stmt|;
name|te
operator|=
name|uif
operator|.
name|getOrdTermsEnum
argument_list|(
name|fcontext
operator|.
name|searcher
operator|.
name|getLeafReader
argument_list|()
argument_list|)
expr_stmt|;
comment|// "te" can be null
name|startTermIndex
operator|=
literal|0
expr_stmt|;
name|endTermIndex
operator|=
name|uif
operator|.
name|numTerms
argument_list|()
expr_stmt|;
comment|// one past the end
if|if
condition|(
name|prefixRef
operator|!=
literal|null
operator|&&
name|te
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|te
operator|.
name|seekCeil
argument_list|(
name|prefixRef
operator|.
name|get
argument_list|()
argument_list|)
operator|==
name|TermsEnum
operator|.
name|SeekStatus
operator|.
name|END
condition|)
block|{
name|startTermIndex
operator|=
name|uif
operator|.
name|numTerms
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|startTermIndex
operator|=
operator|(
name|int
operator|)
name|te
operator|.
name|ord
argument_list|()
expr_stmt|;
block|}
name|prefixRef
operator|.
name|append
argument_list|(
name|UnicodeUtil
operator|.
name|BIG_TERM
argument_list|)
expr_stmt|;
if|if
condition|(
name|te
operator|.
name|seekCeil
argument_list|(
name|prefixRef
operator|.
name|get
argument_list|()
argument_list|)
operator|==
name|TermsEnum
operator|.
name|SeekStatus
operator|.
name|END
condition|)
block|{
name|endTermIndex
operator|=
name|uif
operator|.
name|numTerms
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|endTermIndex
operator|=
operator|(
name|int
operator|)
name|te
operator|.
name|ord
argument_list|()
expr_stmt|;
block|}
block|}
name|nTerms
operator|=
name|endTermIndex
operator|-
name|startTermIndex
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|lookupOrd
specifier|protected
name|BytesRef
name|lookupOrd
parameter_list|(
name|int
name|ord
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|uif
operator|.
name|getTermValue
argument_list|(
name|te
argument_list|,
name|ord
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|collectDocs
specifier|protected
name|void
name|collectDocs
parameter_list|()
throws|throws
name|IOException
block|{
name|uif
operator|.
name|collectDocs
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
block|}
end_class
begin_class
DECL|class|FacetFieldProcessorStream
class|class
name|FacetFieldProcessorStream
extends|extends
name|FacetFieldProcessor
implements|implements
name|Closeable
block|{
DECL|field|bucketsToSkip
name|long
name|bucketsToSkip
decl_stmt|;
DECL|field|bucketsReturned
name|long
name|bucketsReturned
decl_stmt|;
DECL|field|closed
name|boolean
name|closed
decl_stmt|;
DECL|field|countOnly
name|boolean
name|countOnly
decl_stmt|;
DECL|field|hasSubFacets
name|boolean
name|hasSubFacets
decl_stmt|;
comment|// true if there are subfacets
DECL|field|minDfFilterCache
name|int
name|minDfFilterCache
decl_stmt|;
DECL|field|docs
name|DocSet
name|docs
decl_stmt|;
DECL|field|fastForRandomSet
name|DocSet
name|fastForRandomSet
decl_stmt|;
DECL|field|termsEnum
name|TermsEnum
name|termsEnum
init|=
literal|null
decl_stmt|;
DECL|field|deState
name|SolrIndexSearcher
operator|.
name|DocsEnumState
name|deState
init|=
literal|null
decl_stmt|;
DECL|field|postingsEnum
name|PostingsEnum
name|postingsEnum
decl_stmt|;
DECL|field|startTermBytes
name|BytesRef
name|startTermBytes
decl_stmt|;
DECL|field|term
name|BytesRef
name|term
decl_stmt|;
DECL|field|leaves
name|LeafReaderContext
index|[]
name|leaves
decl_stmt|;
DECL|method|FacetFieldProcessorStream
name|FacetFieldProcessorStream
parameter_list|(
name|FacetContext
name|fcontext
parameter_list|,
name|FacetField
name|freq
parameter_list|,
name|SchemaField
name|sf
parameter_list|)
block|{
name|super
argument_list|(
name|fcontext
argument_list|,
name|freq
argument_list|,
name|sf
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|close
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|closed
condition|)
block|{
name|closed
operator|=
literal|true
expr_stmt|;
comment|// fcontext.base.decref();  // OFF-HEAP
block|}
block|}
annotation|@
name|Override
DECL|method|process
specifier|public
name|void
name|process
parameter_list|()
throws|throws
name|IOException
block|{
comment|// We need to keep the fcontext open after processing is done (since we will be streaming in the response writer).
comment|// But if the connection is broken, we want to clean up.
comment|// fcontext.base.incref();  // OFF-HEAP
name|fcontext
operator|.
name|qcontext
operator|.
name|addCloseHook
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|setup
argument_list|()
expr_stmt|;
name|response
operator|=
operator|new
name|SimpleOrderedMap
argument_list|<>
argument_list|()
expr_stmt|;
name|response
operator|.
name|add
argument_list|(
literal|"buckets"
argument_list|,
operator|new
name|Iterator
argument_list|()
block|{
name|boolean
name|retrieveNext
init|=
literal|true
decl_stmt|;
name|Object
name|val
decl_stmt|;
annotation|@
name|Override
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
if|if
condition|(
name|retrieveNext
condition|)
block|{
name|val
operator|=
name|nextBucket
argument_list|()
expr_stmt|;
block|}
name|retrieveNext
operator|=
literal|false
expr_stmt|;
return|return
name|val
operator|!=
literal|null
return|;
block|}
annotation|@
name|Override
specifier|public
name|Object
name|next
parameter_list|()
block|{
if|if
condition|(
name|retrieveNext
condition|)
block|{
name|val
operator|=
name|nextBucket
argument_list|()
expr_stmt|;
block|}
name|retrieveNext
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|val
operator|==
literal|null
condition|)
block|{
comment|// Last value, so clean up.  In the case that we are doing streaming facets within streaming facets,
comment|// the number of close hooks could grow very large, so we want to remove ourselves.
name|boolean
name|removed
init|=
name|fcontext
operator|.
name|qcontext
operator|.
name|removeCloseHook
argument_list|(
name|FacetFieldProcessorStream
operator|.
name|this
argument_list|)
decl_stmt|;
assert|assert
name|removed
assert|;
try|try
block|{
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|SolrException
operator|.
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
literal|"Error during facet streaming close"
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
return|return
name|val
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|remove
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
DECL|method|setup
specifier|public
name|void
name|setup
parameter_list|()
throws|throws
name|IOException
block|{
name|countOnly
operator|=
name|freq
operator|.
name|facetStats
operator|.
name|size
argument_list|()
operator|==
literal|0
operator|||
name|freq
operator|.
name|facetStats
operator|.
name|values
argument_list|()
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
operator|instanceof
name|CountAgg
expr_stmt|;
name|hasSubFacets
operator|=
name|freq
operator|.
name|subFacets
operator|.
name|size
argument_list|()
operator|>
literal|0
expr_stmt|;
name|bucketsToSkip
operator|=
name|freq
operator|.
name|offset
expr_stmt|;
name|createAccs
argument_list|(
operator|-
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|prepareForCollection
argument_list|()
expr_stmt|;
comment|// Minimum term docFreq in order to use the filterCache for that term.
name|int
name|defaultMinDf
init|=
name|Math
operator|.
name|max
argument_list|(
name|fcontext
operator|.
name|searcher
operator|.
name|maxDoc
argument_list|()
operator|>>
literal|4
argument_list|,
literal|3
argument_list|)
decl_stmt|;
comment|// (minimum of 3 is for test coverage purposes)
name|int
name|minDfFilterCache
init|=
name|freq
operator|.
name|cacheDf
operator|==
literal|0
condition|?
name|defaultMinDf
else|:
name|freq
operator|.
name|cacheDf
decl_stmt|;
if|if
condition|(
name|minDfFilterCache
operator|==
operator|-
literal|1
condition|)
name|minDfFilterCache
operator|=
name|Integer
operator|.
name|MAX_VALUE
expr_stmt|;
comment|// -1 means never cache
name|docs
operator|=
name|fcontext
operator|.
name|base
expr_stmt|;
name|fastForRandomSet
operator|=
literal|null
expr_stmt|;
if|if
condition|(
name|freq
operator|.
name|prefix
operator|!=
literal|null
condition|)
block|{
name|String
name|indexedPrefix
init|=
name|sf
operator|.
name|getType
argument_list|()
operator|.
name|toInternal
argument_list|(
name|freq
operator|.
name|prefix
argument_list|)
decl_stmt|;
name|startTermBytes
operator|=
operator|new
name|BytesRef
argument_list|(
name|indexedPrefix
argument_list|)
expr_stmt|;
block|}
name|Fields
name|fields
init|=
name|fcontext
operator|.
name|searcher
operator|.
name|getLeafReader
argument_list|()
operator|.
name|fields
argument_list|()
decl_stmt|;
name|Terms
name|terms
init|=
name|fields
operator|==
literal|null
condition|?
literal|null
else|:
name|fields
operator|.
name|terms
argument_list|(
name|sf
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
name|termsEnum
operator|=
literal|null
expr_stmt|;
name|deState
operator|=
literal|null
expr_stmt|;
name|term
operator|=
literal|null
expr_stmt|;
if|if
condition|(
name|terms
operator|!=
literal|null
condition|)
block|{
name|termsEnum
operator|=
name|terms
operator|.
name|iterator
argument_list|(
literal|null
argument_list|)
expr_stmt|;
comment|// TODO: OPT: if seek(ord) is supported for this termsEnum, then we could use it for
comment|// facet.offset when sorting by index order.
if|if
condition|(
name|startTermBytes
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|termsEnum
operator|.
name|seekCeil
argument_list|(
name|startTermBytes
argument_list|)
operator|==
name|TermsEnum
operator|.
name|SeekStatus
operator|.
name|END
condition|)
block|{
name|termsEnum
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
name|term
operator|=
name|termsEnum
operator|.
name|term
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// position termsEnum on first term
name|term
operator|=
name|termsEnum
operator|.
name|next
argument_list|()
expr_stmt|;
block|}
block|}
name|List
argument_list|<
name|LeafReaderContext
argument_list|>
name|leafList
init|=
name|fcontext
operator|.
name|searcher
operator|.
name|getTopReaderContext
argument_list|()
operator|.
name|leaves
argument_list|()
decl_stmt|;
name|leaves
operator|=
name|leafList
operator|.
name|toArray
argument_list|(
operator|new
name|LeafReaderContext
index|[
name|leafList
operator|.
name|size
argument_list|()
index|]
argument_list|)
expr_stmt|;
block|}
DECL|method|nextBucket
specifier|public
name|SimpleOrderedMap
argument_list|<
name|Object
argument_list|>
name|nextBucket
parameter_list|()
block|{
try|try
block|{
return|return
name|_nextBucket
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|SolrException
operator|.
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
literal|"Error during facet streaming"
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
DECL|method|_nextBucket
specifier|public
name|SimpleOrderedMap
argument_list|<
name|Object
argument_list|>
name|_nextBucket
parameter_list|()
throws|throws
name|IOException
block|{
name|int
name|effectiveMincount
init|=
call|(
name|int
call|)
argument_list|(
name|fcontext
operator|.
name|isShard
argument_list|()
condition|?
name|Math
operator|.
name|min
argument_list|(
literal|1
argument_list|,
name|freq
operator|.
name|mincount
argument_list|)
else|:
name|freq
operator|.
name|mincount
argument_list|)
decl_stmt|;
name|DocSet
name|termSet
init|=
literal|null
decl_stmt|;
try|try
block|{
while|while
condition|(
name|term
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|startTermBytes
operator|!=
literal|null
operator|&&
operator|!
name|StringHelper
operator|.
name|startsWith
argument_list|(
name|term
argument_list|,
name|startTermBytes
argument_list|)
condition|)
block|{
break|break;
block|}
name|int
name|df
init|=
name|termsEnum
operator|.
name|docFreq
argument_list|()
decl_stmt|;
if|if
condition|(
name|df
operator|<
name|effectiveMincount
condition|)
block|{
name|term
operator|=
name|termsEnum
operator|.
name|next
argument_list|()
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|termSet
operator|!=
literal|null
condition|)
block|{
comment|// termSet.decref(); // OFF-HEAP
name|termSet
operator|=
literal|null
expr_stmt|;
block|}
name|int
name|c
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|hasSubFacets
operator|||
name|df
operator|>=
name|minDfFilterCache
condition|)
block|{
comment|// use the filter cache
if|if
condition|(
name|deState
operator|==
literal|null
condition|)
block|{
name|deState
operator|=
operator|new
name|SolrIndexSearcher
operator|.
name|DocsEnumState
argument_list|()
expr_stmt|;
name|deState
operator|.
name|fieldName
operator|=
name|sf
operator|.
name|getName
argument_list|()
expr_stmt|;
name|deState
operator|.
name|liveDocs
operator|=
name|fcontext
operator|.
name|searcher
operator|.
name|getLeafReader
argument_list|()
operator|.
name|getLiveDocs
argument_list|()
expr_stmt|;
name|deState
operator|.
name|termsEnum
operator|=
name|termsEnum
expr_stmt|;
name|deState
operator|.
name|postingsEnum
operator|=
name|postingsEnum
expr_stmt|;
name|deState
operator|.
name|minSetSizeCached
operator|=
name|minDfFilterCache
expr_stmt|;
block|}
if|if
condition|(
name|hasSubFacets
operator|||
operator|!
name|countOnly
condition|)
block|{
name|DocSet
name|termsAll
init|=
name|fcontext
operator|.
name|searcher
operator|.
name|getDocSet
argument_list|(
name|deState
argument_list|)
decl_stmt|;
name|termSet
operator|=
name|docs
operator|.
name|intersection
argument_list|(
name|termsAll
argument_list|)
expr_stmt|;
comment|// termsAll.decref(); // OFF-HEAP
name|c
operator|=
name|termSet
operator|.
name|size
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|c
operator|=
name|fcontext
operator|.
name|searcher
operator|.
name|numDocs
argument_list|(
name|docs
argument_list|,
name|deState
argument_list|)
expr_stmt|;
block|}
name|postingsEnum
operator|=
name|deState
operator|.
name|postingsEnum
expr_stmt|;
name|resetStats
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|countOnly
condition|)
block|{
name|collect
argument_list|(
name|termSet
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// We don't need the docset here (meaning no sub-facets).
comment|// if countOnly, then we are calculating some other stats...
name|resetStats
argument_list|()
expr_stmt|;
comment|// lazy convert to fastForRandomSet
if|if
condition|(
name|fastForRandomSet
operator|==
literal|null
condition|)
block|{
name|fastForRandomSet
operator|=
name|docs
expr_stmt|;
if|if
condition|(
name|docs
operator|instanceof
name|SortedIntDocSet
condition|)
block|{
comment|// OFF-HEAP todo: also check for native version
name|SortedIntDocSet
name|sset
init|=
operator|(
name|SortedIntDocSet
operator|)
name|docs
decl_stmt|;
name|fastForRandomSet
operator|=
operator|new
name|HashDocSet
argument_list|(
name|sset
operator|.
name|getDocs
argument_list|()
argument_list|,
literal|0
argument_list|,
name|sset
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|// iterate over TermDocs to calculate the intersection
name|postingsEnum
operator|=
name|termsEnum
operator|.
name|postings
argument_list|(
literal|null
argument_list|,
name|postingsEnum
argument_list|,
name|PostingsEnum
operator|.
name|NONE
argument_list|)
expr_stmt|;
if|if
condition|(
name|postingsEnum
operator|instanceof
name|MultiPostingsEnum
condition|)
block|{
name|MultiPostingsEnum
operator|.
name|EnumWithSlice
index|[]
name|subs
init|=
operator|(
operator|(
name|MultiPostingsEnum
operator|)
name|postingsEnum
operator|)
operator|.
name|getSubs
argument_list|()
decl_stmt|;
name|int
name|numSubs
init|=
operator|(
operator|(
name|MultiPostingsEnum
operator|)
name|postingsEnum
operator|)
operator|.
name|getNumSubs
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|subindex
init|=
literal|0
init|;
name|subindex
operator|<
name|numSubs
condition|;
name|subindex
operator|++
control|)
block|{
name|MultiPostingsEnum
operator|.
name|EnumWithSlice
name|sub
init|=
name|subs
index|[
name|subindex
index|]
decl_stmt|;
if|if
condition|(
name|sub
operator|.
name|postingsEnum
operator|==
literal|null
condition|)
continue|continue;
name|int
name|base
init|=
name|sub
operator|.
name|slice
operator|.
name|start
decl_stmt|;
name|int
name|docid
decl_stmt|;
if|if
condition|(
name|countOnly
condition|)
block|{
while|while
condition|(
operator|(
name|docid
operator|=
name|sub
operator|.
name|postingsEnum
operator|.
name|nextDoc
argument_list|()
operator|)
operator|!=
name|DocIdSetIterator
operator|.
name|NO_MORE_DOCS
condition|)
block|{
if|if
condition|(
name|fastForRandomSet
operator|.
name|exists
argument_list|(
name|docid
operator|+
name|base
argument_list|)
condition|)
name|c
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
name|setNextReader
argument_list|(
name|leaves
index|[
name|sub
operator|.
name|slice
operator|.
name|readerIndex
index|]
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|docid
operator|=
name|sub
operator|.
name|postingsEnum
operator|.
name|nextDoc
argument_list|()
operator|)
operator|!=
name|DocIdSetIterator
operator|.
name|NO_MORE_DOCS
condition|)
block|{
if|if
condition|(
name|fastForRandomSet
operator|.
name|exists
argument_list|(
name|docid
operator|+
name|base
argument_list|)
condition|)
block|{
name|c
operator|++
expr_stmt|;
name|collect
argument_list|(
name|docid
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
else|else
block|{
name|int
name|docid
decl_stmt|;
if|if
condition|(
name|countOnly
condition|)
block|{
while|while
condition|(
operator|(
name|docid
operator|=
name|postingsEnum
operator|.
name|nextDoc
argument_list|()
operator|)
operator|!=
name|DocIdSetIterator
operator|.
name|NO_MORE_DOCS
condition|)
block|{
if|if
condition|(
name|fastForRandomSet
operator|.
name|exists
argument_list|(
name|docid
argument_list|)
condition|)
name|c
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
name|setNextReader
argument_list|(
name|leaves
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|docid
operator|=
name|postingsEnum
operator|.
name|nextDoc
argument_list|()
operator|)
operator|!=
name|DocIdSetIterator
operator|.
name|NO_MORE_DOCS
condition|)
block|{
if|if
condition|(
name|fastForRandomSet
operator|.
name|exists
argument_list|(
name|docid
argument_list|)
condition|)
block|{
name|c
operator|++
expr_stmt|;
name|collect
argument_list|(
name|docid
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
if|if
condition|(
name|c
operator|<
name|effectiveMincount
condition|)
block|{
name|term
operator|=
name|termsEnum
operator|.
name|next
argument_list|()
expr_stmt|;
continue|continue;
block|}
comment|// handle offset and limit
if|if
condition|(
name|bucketsToSkip
operator|>
literal|0
condition|)
block|{
name|bucketsToSkip
operator|--
expr_stmt|;
name|term
operator|=
name|termsEnum
operator|.
name|next
argument_list|()
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|freq
operator|.
name|limit
operator|>=
literal|0
operator|&&
operator|++
name|bucketsReturned
operator|>
name|freq
operator|.
name|limit
condition|)
block|{
return|return
literal|null
return|;
block|}
comment|// set count in case other stats depend on it
name|countAcc
operator|.
name|incrementCount
argument_list|(
literal|0
argument_list|,
name|c
argument_list|)
expr_stmt|;
comment|// OK, we have a good bucket to return... first get bucket value before moving to next term
name|Object
name|bucketVal
init|=
name|sf
operator|.
name|getType
argument_list|()
operator|.
name|toObject
argument_list|(
name|sf
argument_list|,
name|term
argument_list|)
decl_stmt|;
name|term
operator|=
name|termsEnum
operator|.
name|next
argument_list|()
expr_stmt|;
name|SimpleOrderedMap
argument_list|<
name|Object
argument_list|>
name|bucket
init|=
operator|new
name|SimpleOrderedMap
argument_list|<>
argument_list|()
decl_stmt|;
name|bucket
operator|.
name|add
argument_list|(
literal|"val"
argument_list|,
name|bucketVal
argument_list|)
expr_stmt|;
name|addStats
argument_list|(
name|bucket
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|hasSubFacets
condition|)
block|{
name|processSubs
argument_list|(
name|bucket
argument_list|,
name|termSet
argument_list|)
expr_stmt|;
block|}
comment|// TODO... termSet needs to stick around for streaming sub-facets?
return|return
name|bucket
return|;
block|}
block|}
finally|finally
block|{
if|if
condition|(
name|termSet
operator|!=
literal|null
condition|)
block|{
comment|// termSet.decref();  // OFF-HEAP
name|termSet
operator|=
literal|null
expr_stmt|;
block|}
block|}
comment|// end of the iteration
return|return
literal|null
return|;
block|}
block|}
end_class
end_unit
