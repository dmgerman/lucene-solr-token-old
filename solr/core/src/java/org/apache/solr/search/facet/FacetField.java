begin_unit
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_package
DECL|package|org.apache.solr.search.facet
package|package
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|search
operator|.
name|facet
package|;
end_package
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Closeable
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashMap
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|Fields
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|LeafReaderContext
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|MultiPostingsEnum
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|PostingsEnum
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|Term
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|Terms
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|TermsEnum
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|DocIdSetIterator
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|Query
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|TermQuery
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|BytesRef
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|BytesRefBuilder
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|PriorityQueue
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|StringHelper
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|UnicodeUtil
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|SolrException
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|util
operator|.
name|NamedList
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|util
operator|.
name|SimpleOrderedMap
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|schema
operator|.
name|FieldType
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|schema
operator|.
name|SchemaField
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|schema
operator|.
name|TrieField
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|search
operator|.
name|DocSet
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|search
operator|.
name|HashDocSet
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|search
operator|.
name|SolrIndexSearcher
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|search
operator|.
name|SortedIntDocSet
import|;
end_import
begin_class
DECL|class|FacetField
specifier|public
class|class
name|FacetField
extends|extends
name|FacetRequest
block|{
DECL|field|field
name|String
name|field
decl_stmt|;
DECL|field|offset
name|long
name|offset
decl_stmt|;
DECL|field|limit
name|long
name|limit
init|=
literal|10
decl_stmt|;
DECL|field|mincount
name|long
name|mincount
init|=
literal|1
decl_stmt|;
DECL|field|missing
name|boolean
name|missing
decl_stmt|;
DECL|field|allBuckets
name|boolean
name|allBuckets
decl_stmt|;
comment|// show cumulative stats across all buckets (this can be different than non-bucketed stats across all docs because of multi-valued docs)
DECL|field|numBuckets
name|boolean
name|numBuckets
decl_stmt|;
DECL|field|prefix
name|String
name|prefix
decl_stmt|;
DECL|field|sortVariable
name|String
name|sortVariable
decl_stmt|;
DECL|field|sortDirection
name|SortDirection
name|sortDirection
decl_stmt|;
DECL|field|method
name|FacetMethod
name|method
decl_stmt|;
DECL|field|cacheDf
name|int
name|cacheDf
decl_stmt|;
comment|// 0 means "default", -1 means "never cache"
comment|// experimental - force perSeg collection when using dv method, currently for testing purposes only.
DECL|field|perSeg
name|Boolean
name|perSeg
decl_stmt|;
comment|// TODO: put this somewhere more generic?
DECL|enum|SortDirection
specifier|public
specifier|static
enum|enum
name|SortDirection
block|{
DECL|enum constant|asc
name|asc
argument_list|(
operator|-
literal|1
argument_list|)
block|,
DECL|enum constant|desc
name|desc
argument_list|(
literal|1
argument_list|)
block|;
DECL|field|multiplier
specifier|private
specifier|final
name|int
name|multiplier
decl_stmt|;
DECL|method|SortDirection
specifier|private
name|SortDirection
parameter_list|(
name|int
name|multiplier
parameter_list|)
block|{
name|this
operator|.
name|multiplier
operator|=
name|multiplier
expr_stmt|;
block|}
comment|// asc==-1, desc==1
DECL|method|getMultiplier
specifier|public
name|int
name|getMultiplier
parameter_list|()
block|{
return|return
name|multiplier
return|;
block|}
block|}
DECL|enum|FacetMethod
specifier|public
specifier|static
enum|enum
name|FacetMethod
block|{
DECL|enum constant|DV
name|DV
block|,
comment|// DocValues
DECL|enum constant|UIF
name|UIF
block|,
comment|// UnInvertedField
DECL|enum constant|ENUM
name|ENUM
block|,
DECL|enum constant|STREAM
name|STREAM
block|,
DECL|enum constant|SMART
name|SMART
block|,     ;
DECL|method|fromString
specifier|public
specifier|static
name|FacetMethod
name|fromString
parameter_list|(
name|String
name|method
parameter_list|)
block|{
if|if
condition|(
name|method
operator|==
literal|null
operator|||
name|method
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
return|return
literal|null
return|;
if|if
condition|(
literal|"dv"
operator|.
name|equals
argument_list|(
name|method
argument_list|)
condition|)
block|{
return|return
name|DV
return|;
block|}
elseif|else
if|if
condition|(
literal|"uif"
operator|.
name|equals
argument_list|(
name|method
argument_list|)
condition|)
block|{
return|return
name|UIF
return|;
block|}
elseif|else
if|if
condition|(
literal|"enum"
operator|.
name|equals
argument_list|(
name|method
argument_list|)
condition|)
block|{
return|return
name|ENUM
return|;
block|}
elseif|else
if|if
condition|(
literal|"smart"
operator|.
name|equals
argument_list|(
name|method
argument_list|)
condition|)
block|{
return|return
name|SMART
return|;
block|}
elseif|else
if|if
condition|(
literal|"stream"
operator|.
name|equals
argument_list|(
name|method
argument_list|)
condition|)
block|{
return|return
name|STREAM
return|;
block|}
throw|throw
operator|new
name|SolrException
argument_list|(
name|SolrException
operator|.
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
literal|"Unknown FacetField method "
operator|+
name|method
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
DECL|method|createFacetProcessor
specifier|public
name|FacetProcessor
name|createFacetProcessor
parameter_list|(
name|FacetContext
name|fcontext
parameter_list|)
block|{
name|SchemaField
name|sf
init|=
name|fcontext
operator|.
name|searcher
operator|.
name|getSchema
argument_list|()
operator|.
name|getField
argument_list|(
name|field
argument_list|)
decl_stmt|;
name|FieldType
name|ft
init|=
name|sf
operator|.
name|getType
argument_list|()
decl_stmt|;
name|boolean
name|multiToken
init|=
name|sf
operator|.
name|multiValued
argument_list|()
operator|||
name|ft
operator|.
name|multiValuedFieldCache
argument_list|()
decl_stmt|;
if|if
condition|(
name|method
operator|==
name|FacetMethod
operator|.
name|ENUM
operator|&&
name|sf
operator|.
name|indexed
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
elseif|else
if|if
condition|(
name|method
operator|==
name|FacetMethod
operator|.
name|STREAM
operator|&&
name|sf
operator|.
name|indexed
argument_list|()
condition|)
block|{
return|return
operator|new
name|FacetFieldProcessorStream
argument_list|(
name|fcontext
argument_list|,
name|this
argument_list|,
name|sf
argument_list|)
return|;
block|}
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|document
operator|.
name|FieldType
operator|.
name|LegacyNumericType
name|ntype
init|=
name|ft
operator|.
name|getNumericType
argument_list|()
decl_stmt|;
if|if
condition|(
name|sf
operator|.
name|hasDocValues
argument_list|()
operator|&&
name|ntype
operator|==
literal|null
condition|)
block|{
comment|// single and multi-valued string docValues
return|return
operator|new
name|FacetFieldProcessorDV
argument_list|(
name|fcontext
argument_list|,
name|this
argument_list|,
name|sf
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|multiToken
condition|)
block|{
if|if
condition|(
name|sf
operator|.
name|getType
argument_list|()
operator|.
name|getNumericType
argument_list|()
operator|!=
literal|null
condition|)
block|{
comment|// single valued numeric (docvalues or fieldcache)
return|return
operator|new
name|FacetFieldProcessorNumeric
argument_list|(
name|fcontext
argument_list|,
name|this
argument_list|,
name|sf
argument_list|)
return|;
block|}
else|else
block|{
comment|// single valued string...
return|return
operator|new
name|FacetFieldProcessorDV
argument_list|(
name|fcontext
argument_list|,
name|this
argument_list|,
name|sf
argument_list|)
return|;
block|}
block|}
comment|// multivalued but field doesn't have docValues
if|if
condition|(
name|method
operator|==
name|FacetMethod
operator|.
name|DV
condition|)
block|{
return|return
operator|new
name|FacetFieldProcessorDV
argument_list|(
name|fcontext
argument_list|,
name|this
argument_list|,
name|sf
argument_list|)
return|;
block|}
comment|// Top-level multi-valued field cache (UIF)
return|return
operator|new
name|FacetFieldProcessorUIF
argument_list|(
name|fcontext
argument_list|,
name|this
argument_list|,
name|sf
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|createFacetMerger
specifier|public
name|FacetMerger
name|createFacetMerger
parameter_list|(
name|Object
name|prototype
parameter_list|)
block|{
return|return
operator|new
name|FacetFieldMerger
argument_list|(
name|this
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|getFacetDescription
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|getFacetDescription
parameter_list|()
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|descr
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
argument_list|()
decl_stmt|;
name|descr
operator|.
name|put
argument_list|(
literal|"field"
argument_list|,
name|field
argument_list|)
expr_stmt|;
name|descr
operator|.
name|put
argument_list|(
literal|"limit"
argument_list|,
operator|new
name|Long
argument_list|(
name|limit
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|descr
return|;
block|}
block|}
end_class
begin_class
DECL|class|FacetFieldProcessor
specifier|abstract
class|class
name|FacetFieldProcessor
extends|extends
name|FacetProcessor
argument_list|<
name|FacetField
argument_list|>
block|{
DECL|field|sf
name|SchemaField
name|sf
decl_stmt|;
DECL|field|indexOrderAcc
name|SlotAcc
name|indexOrderAcc
decl_stmt|;
DECL|field|effectiveMincount
name|int
name|effectiveMincount
decl_stmt|;
DECL|field|deferredAggs
name|Map
argument_list|<
name|String
argument_list|,
name|AggValueSource
argument_list|>
name|deferredAggs
decl_stmt|;
comment|// null if none
comment|// TODO: push any of this down to base class?
comment|//
comment|// For sort="x desc", collectAcc would point to "x", and sortAcc would also point to "x".
comment|// collectAcc would be used to accumulate all buckets, and sortAcc would be used to sort those buckets.
comment|//
DECL|field|collectAcc
name|SlotAcc
name|collectAcc
decl_stmt|;
comment|// Accumulator to collect across entire domain (in addition to the countAcc).  May be null.
DECL|field|sortAcc
name|SlotAcc
name|sortAcc
decl_stmt|;
comment|// Accumulator to use for sorting *only* (i.e. not used for collection). May be an alias of countAcc, collectAcc, or indexOrderAcc
DECL|field|otherAccs
name|SlotAcc
index|[]
name|otherAccs
decl_stmt|;
comment|// Accumulators that do not need to be calculated across all buckets.
DECL|field|allBucketsAcc
name|SpecialSlotAcc
name|allBucketsAcc
decl_stmt|;
comment|// this can internally refer to otherAccs and/or collectAcc. setNextReader should be called on otherAccs directly if they exist.
DECL|method|FacetFieldProcessor
name|FacetFieldProcessor
parameter_list|(
name|FacetContext
name|fcontext
parameter_list|,
name|FacetField
name|freq
parameter_list|,
name|SchemaField
name|sf
parameter_list|)
block|{
name|super
argument_list|(
name|fcontext
argument_list|,
name|freq
argument_list|)
expr_stmt|;
name|this
operator|.
name|sf
operator|=
name|sf
expr_stmt|;
name|this
operator|.
name|effectiveMincount
operator|=
call|(
name|int
call|)
argument_list|(
name|fcontext
operator|.
name|isShard
argument_list|()
condition|?
name|Math
operator|.
name|min
argument_list|(
literal|1
argument_list|,
name|freq
operator|.
name|mincount
argument_list|)
else|:
name|freq
operator|.
name|mincount
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|getResponse
specifier|public
name|Object
name|getResponse
parameter_list|()
block|{
return|return
name|response
return|;
block|}
comment|// This is used to create accs for second phase (or to create accs for all aggs)
annotation|@
name|Override
DECL|method|createAccs
specifier|protected
name|void
name|createAccs
parameter_list|(
name|int
name|docCount
parameter_list|,
name|int
name|slotCount
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|accMap
operator|==
literal|null
condition|)
block|{
name|accMap
operator|=
operator|new
name|LinkedHashMap
argument_list|<>
argument_list|()
expr_stmt|;
block|}
comment|// allow a custom count acc to be used
if|if
condition|(
name|countAcc
operator|==
literal|null
condition|)
block|{
name|countAcc
operator|=
operator|new
name|CountSlotArrAcc
argument_list|(
name|fcontext
argument_list|,
name|slotCount
argument_list|)
expr_stmt|;
name|countAcc
operator|.
name|key
operator|=
literal|"count"
expr_stmt|;
block|}
if|if
condition|(
name|accs
operator|!=
literal|null
condition|)
block|{
comment|// reuse these accs, but reset them first
for|for
control|(
name|SlotAcc
name|acc
range|:
name|accs
control|)
block|{
name|acc
operator|.
name|reset
argument_list|()
expr_stmt|;
block|}
return|return;
block|}
else|else
block|{
name|accs
operator|=
operator|new
name|SlotAcc
index|[
name|freq
operator|.
name|getFacetStats
argument_list|()
operator|.
name|size
argument_list|()
index|]
expr_stmt|;
block|}
name|int
name|accIdx
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|AggValueSource
argument_list|>
name|entry
range|:
name|freq
operator|.
name|getFacetStats
argument_list|()
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|SlotAcc
name|acc
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|slotCount
operator|==
literal|1
condition|)
block|{
name|acc
operator|=
name|accMap
operator|.
name|get
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|acc
operator|!=
literal|null
condition|)
block|{
name|acc
operator|.
name|reset
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|acc
operator|==
literal|null
condition|)
block|{
name|acc
operator|=
name|entry
operator|.
name|getValue
argument_list|()
operator|.
name|createSlotAcc
argument_list|(
name|fcontext
argument_list|,
name|docCount
argument_list|,
name|slotCount
argument_list|)
expr_stmt|;
name|acc
operator|.
name|key
operator|=
name|entry
operator|.
name|getKey
argument_list|()
expr_stmt|;
name|accMap
operator|.
name|put
argument_list|(
name|acc
operator|.
name|key
argument_list|,
name|acc
argument_list|)
expr_stmt|;
block|}
name|accs
index|[
name|accIdx
operator|++
index|]
operator|=
name|acc
expr_stmt|;
block|}
block|}
DECL|method|createCollectAcc
name|void
name|createCollectAcc
parameter_list|(
name|int
name|numDocs
parameter_list|,
name|int
name|numSlots
parameter_list|)
throws|throws
name|IOException
block|{
name|accMap
operator|=
operator|new
name|LinkedHashMap
argument_list|<>
argument_list|()
expr_stmt|;
comment|// we always count...
comment|// allow a subclass to set a custom counter.
if|if
condition|(
name|countAcc
operator|==
literal|null
condition|)
block|{
name|countAcc
operator|=
operator|new
name|CountSlotArrAcc
argument_list|(
name|fcontext
argument_list|,
name|numSlots
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
literal|"count"
operator|.
name|equals
argument_list|(
name|freq
operator|.
name|sortVariable
argument_list|)
condition|)
block|{
name|sortAcc
operator|=
name|countAcc
expr_stmt|;
name|deferredAggs
operator|=
name|freq
operator|.
name|getFacetStats
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|"index"
operator|.
name|equals
argument_list|(
name|freq
operator|.
name|sortVariable
argument_list|)
condition|)
block|{
comment|// allow subclass to set indexOrderAcc first
if|if
condition|(
name|indexOrderAcc
operator|==
literal|null
condition|)
block|{
comment|// This sorting accumulator just goes by the slot number, so does not need to be collected
comment|// and hence does not need to find it's way into the accMap or accs array.
name|indexOrderAcc
operator|=
operator|new
name|SortSlotAcc
argument_list|(
name|fcontext
argument_list|)
expr_stmt|;
block|}
name|sortAcc
operator|=
name|indexOrderAcc
expr_stmt|;
name|deferredAggs
operator|=
name|freq
operator|.
name|getFacetStats
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|AggValueSource
name|sortAgg
init|=
name|freq
operator|.
name|getFacetStats
argument_list|()
operator|.
name|get
argument_list|(
name|freq
operator|.
name|sortVariable
argument_list|)
decl_stmt|;
if|if
condition|(
name|sortAgg
operator|!=
literal|null
condition|)
block|{
name|collectAcc
operator|=
name|sortAgg
operator|.
name|createSlotAcc
argument_list|(
name|fcontext
argument_list|,
name|numDocs
argument_list|,
name|numSlots
argument_list|)
expr_stmt|;
name|collectAcc
operator|.
name|key
operator|=
name|freq
operator|.
name|sortVariable
expr_stmt|;
comment|// TODO: improve this
block|}
name|sortAcc
operator|=
name|collectAcc
expr_stmt|;
name|deferredAggs
operator|=
operator|new
name|HashMap
argument_list|<>
argument_list|(
name|freq
operator|.
name|getFacetStats
argument_list|()
argument_list|)
expr_stmt|;
name|deferredAggs
operator|.
name|remove
argument_list|(
name|freq
operator|.
name|sortVariable
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|deferredAggs
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
name|deferredAggs
operator|=
literal|null
expr_stmt|;
block|}
name|boolean
name|needOtherAccs
init|=
name|freq
operator|.
name|allBuckets
decl_stmt|;
comment|// TODO: use for missing too...
if|if
condition|(
operator|!
name|needOtherAccs
condition|)
block|{
comment|// we may need them later, but we don't want to create them now
comment|// otherwise we won't know if we need to call setNextReader on them.
return|return;
block|}
comment|// create the deferred aggs up front for use by allBuckets
name|createOtherAccs
argument_list|(
name|numDocs
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
DECL|method|createOtherAccs
name|void
name|createOtherAccs
parameter_list|(
name|int
name|numDocs
parameter_list|,
name|int
name|numSlots
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|otherAccs
operator|!=
literal|null
condition|)
block|{
comment|// reuse existing accumulators
for|for
control|(
name|SlotAcc
name|acc
range|:
name|otherAccs
control|)
block|{
name|acc
operator|.
name|reset
argument_list|()
expr_stmt|;
comment|// todo - make reset take numDocs and numSlots?
block|}
return|return;
block|}
name|int
name|numDeferred
init|=
name|deferredAggs
operator|==
literal|null
condition|?
literal|0
else|:
name|deferredAggs
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|numDeferred
operator|<=
literal|0
condition|)
return|return;
name|otherAccs
operator|=
operator|new
name|SlotAcc
index|[
name|numDeferred
index|]
expr_stmt|;
name|int
name|otherAccIdx
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|AggValueSource
argument_list|>
name|entry
range|:
name|deferredAggs
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|AggValueSource
name|agg
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|SlotAcc
name|acc
init|=
name|agg
operator|.
name|createSlotAcc
argument_list|(
name|fcontext
argument_list|,
name|numDocs
argument_list|,
name|numSlots
argument_list|)
decl_stmt|;
name|acc
operator|.
name|key
operator|=
name|entry
operator|.
name|getKey
argument_list|()
expr_stmt|;
name|accMap
operator|.
name|put
argument_list|(
name|acc
operator|.
name|key
argument_list|,
name|acc
argument_list|)
expr_stmt|;
name|otherAccs
index|[
name|otherAccIdx
operator|++
index|]
operator|=
name|acc
expr_stmt|;
block|}
if|if
condition|(
name|numDeferred
operator|==
name|freq
operator|.
name|getFacetStats
argument_list|()
operator|.
name|size
argument_list|()
condition|)
block|{
comment|// accs and otherAccs are the same...
name|accs
operator|=
name|otherAccs
expr_stmt|;
block|}
block|}
DECL|method|collectFirstPhase
name|int
name|collectFirstPhase
parameter_list|(
name|DocSet
name|docs
parameter_list|,
name|int
name|slot
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|num
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|collectAcc
operator|!=
literal|null
condition|)
block|{
name|num
operator|=
name|collectAcc
operator|.
name|collect
argument_list|(
name|docs
argument_list|,
name|slot
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|allBucketsAcc
operator|!=
literal|null
condition|)
block|{
name|num
operator|=
name|allBucketsAcc
operator|.
name|collect
argument_list|(
name|docs
argument_list|,
name|slot
argument_list|)
expr_stmt|;
block|}
return|return
name|num
operator|>=
literal|0
condition|?
name|num
else|:
name|docs
operator|.
name|size
argument_list|()
return|;
block|}
DECL|method|collectFirstPhase
name|void
name|collectFirstPhase
parameter_list|(
name|int
name|segDoc
parameter_list|,
name|int
name|slot
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|collectAcc
operator|!=
literal|null
condition|)
block|{
name|collectAcc
operator|.
name|collect
argument_list|(
name|segDoc
argument_list|,
name|slot
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|allBucketsAcc
operator|!=
literal|null
condition|)
block|{
name|allBucketsAcc
operator|.
name|collect
argument_list|(
name|segDoc
argument_list|,
name|slot
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|fillBucket
name|void
name|fillBucket
parameter_list|(
name|SimpleOrderedMap
argument_list|<
name|Object
argument_list|>
name|target
parameter_list|,
name|int
name|count
parameter_list|,
name|int
name|slotNum
parameter_list|,
name|DocSet
name|subDomain
parameter_list|,
name|Query
name|filter
parameter_list|)
throws|throws
name|IOException
block|{
name|target
operator|.
name|add
argument_list|(
literal|"count"
argument_list|,
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|<=
literal|0
operator|&&
operator|!
name|freq
operator|.
name|processEmpty
condition|)
return|return;
if|if
condition|(
name|collectAcc
operator|!=
literal|null
operator|&&
name|slotNum
operator|>=
literal|0
condition|)
block|{
name|collectAcc
operator|.
name|setValues
argument_list|(
name|target
argument_list|,
name|slotNum
argument_list|)
expr_stmt|;
block|}
name|createOtherAccs
argument_list|(
operator|-
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|otherAccs
operator|==
literal|null
operator|&&
name|freq
operator|.
name|subFacets
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
if|if
condition|(
name|subDomain
operator|==
literal|null
condition|)
block|{
name|subDomain
operator|=
name|fcontext
operator|.
name|searcher
operator|.
name|getDocSet
argument_list|(
name|filter
argument_list|,
name|fcontext
operator|.
name|base
argument_list|)
expr_stmt|;
block|}
comment|// if no subFacets, we only need a DocSet
comment|// otherwise we need more?
comment|// TODO: save something generic like "slotNum" in the context and use that to implement things like filter exclusion if necessary?
comment|// Hmmm, but we need to look up some stuff anyway (for the label?)
comment|// have a method like "DocSet applyConstraint(facet context, DocSet parent)"
comment|// that's needed for domain changing things like joins anyway???
if|if
condition|(
name|otherAccs
operator|!=
literal|null
condition|)
block|{
comment|// do acc at a time (traversing domain each time) or do all accs for each doc?
for|for
control|(
name|SlotAcc
name|acc
range|:
name|otherAccs
control|)
block|{
name|acc
operator|.
name|reset
argument_list|()
expr_stmt|;
comment|// TODO: only needed if we previously used for allBuckets or missing
name|acc
operator|.
name|collect
argument_list|(
name|subDomain
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|acc
operator|.
name|setValues
argument_list|(
name|target
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
name|processSubs
argument_list|(
name|target
argument_list|,
name|filter
argument_list|,
name|subDomain
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|processStats
specifier|protected
name|void
name|processStats
parameter_list|(
name|SimpleOrderedMap
argument_list|<
name|Object
argument_list|>
name|bucket
parameter_list|,
name|DocSet
name|docs
parameter_list|,
name|int
name|docCount
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|docCount
operator|==
literal|0
operator|&&
operator|!
name|freq
operator|.
name|processEmpty
operator|||
name|freq
operator|.
name|getFacetStats
argument_list|()
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
name|bucket
operator|.
name|add
argument_list|(
literal|"count"
argument_list|,
name|docCount
argument_list|)
expr_stmt|;
return|return;
block|}
name|createAccs
argument_list|(
name|docCount
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|int
name|collected
init|=
name|collect
argument_list|(
name|docs
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|// countAcc.incrementCount(0, collected);  // should we set the counton the acc instead of just passing it?
assert|assert
name|collected
operator|==
name|docCount
assert|;
name|addStats
argument_list|(
name|bucket
argument_list|,
name|collected
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|// overrides but with different signature!
DECL|method|addStats
name|void
name|addStats
parameter_list|(
name|SimpleOrderedMap
argument_list|<
name|Object
argument_list|>
name|target
parameter_list|,
name|int
name|count
parameter_list|,
name|int
name|slotNum
parameter_list|)
throws|throws
name|IOException
block|{
name|target
operator|.
name|add
argument_list|(
literal|"count"
argument_list|,
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|>
literal|0
operator|||
name|freq
operator|.
name|processEmpty
condition|)
block|{
for|for
control|(
name|SlotAcc
name|acc
range|:
name|accs
control|)
block|{
name|acc
operator|.
name|setValues
argument_list|(
name|target
argument_list|,
name|slotNum
argument_list|)
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|Override
DECL|method|setNextReader
name|void
name|setNextReader
parameter_list|(
name|LeafReaderContext
name|ctx
parameter_list|)
throws|throws
name|IOException
block|{
comment|// base class calls this (for missing bucket...) ...  go over accs[] in that case
name|super
operator|.
name|setNextReader
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
block|}
DECL|method|setNextReaderFirstPhase
name|void
name|setNextReaderFirstPhase
parameter_list|(
name|LeafReaderContext
name|ctx
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|collectAcc
operator|!=
literal|null
condition|)
block|{
name|collectAcc
operator|.
name|setNextReader
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|otherAccs
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|SlotAcc
name|acc
range|:
name|otherAccs
control|)
block|{
name|acc
operator|.
name|setNextReader
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|class|Slot
specifier|static
class|class
name|Slot
block|{
DECL|field|slot
name|int
name|slot
decl_stmt|;
DECL|method|tiebreakCompare
specifier|public
name|int
name|tiebreakCompare
parameter_list|(
name|int
name|slotA
parameter_list|,
name|int
name|slotB
parameter_list|)
block|{
return|return
name|slotB
operator|-
name|slotA
return|;
block|}
block|}
block|}
end_class
begin_class
DECL|class|SpecialSlotAcc
class|class
name|SpecialSlotAcc
extends|extends
name|SlotAcc
block|{
DECL|field|collectAcc
name|SlotAcc
name|collectAcc
decl_stmt|;
DECL|field|otherAccs
name|SlotAcc
index|[]
name|otherAccs
decl_stmt|;
DECL|field|collectAccSlot
name|int
name|collectAccSlot
decl_stmt|;
DECL|field|otherAccsSlot
name|int
name|otherAccsSlot
decl_stmt|;
DECL|field|count
name|long
name|count
decl_stmt|;
DECL|method|SpecialSlotAcc
specifier|public
name|SpecialSlotAcc
parameter_list|(
name|FacetContext
name|fcontext
parameter_list|,
name|SlotAcc
name|collectAcc
parameter_list|,
name|int
name|collectAccSlot
parameter_list|,
name|SlotAcc
index|[]
name|otherAccs
parameter_list|,
name|int
name|otherAccsSlot
parameter_list|)
block|{
name|super
argument_list|(
name|fcontext
argument_list|)
expr_stmt|;
name|this
operator|.
name|collectAcc
operator|=
name|collectAcc
expr_stmt|;
name|this
operator|.
name|collectAccSlot
operator|=
name|collectAccSlot
expr_stmt|;
name|this
operator|.
name|otherAccs
operator|=
name|otherAccs
expr_stmt|;
name|this
operator|.
name|otherAccsSlot
operator|=
name|otherAccsSlot
expr_stmt|;
block|}
DECL|method|getCollectAccSlot
specifier|public
name|int
name|getCollectAccSlot
parameter_list|()
block|{
return|return
name|collectAccSlot
return|;
block|}
DECL|method|getOtherAccSlot
specifier|public
name|int
name|getOtherAccSlot
parameter_list|()
block|{
return|return
name|otherAccsSlot
return|;
block|}
DECL|method|getSpecialCount
specifier|public
name|long
name|getSpecialCount
parameter_list|()
block|{
return|return
name|count
return|;
block|}
annotation|@
name|Override
DECL|method|collect
specifier|public
name|void
name|collect
parameter_list|(
name|int
name|doc
parameter_list|,
name|int
name|slot
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|slot
operator|!=
name|collectAccSlot
operator|||
name|slot
operator|<
literal|0
assert|;
name|count
operator|++
expr_stmt|;
if|if
condition|(
name|collectAcc
operator|!=
literal|null
condition|)
block|{
name|collectAcc
operator|.
name|collect
argument_list|(
name|doc
argument_list|,
name|collectAccSlot
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|otherAccs
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|SlotAcc
name|otherAcc
range|:
name|otherAccs
control|)
block|{
name|otherAcc
operator|.
name|collect
argument_list|(
name|doc
argument_list|,
name|otherAccsSlot
argument_list|)
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|Override
DECL|method|setNextReader
specifier|public
name|void
name|setNextReader
parameter_list|(
name|LeafReaderContext
name|readerContext
parameter_list|)
throws|throws
name|IOException
block|{
comment|// collectAcc and otherAccs will normally have setNextReader called directly on them.
comment|// This, however, will be used when collect(DocSet,slot) variant is used on this Acc.
if|if
condition|(
name|collectAcc
operator|!=
literal|null
condition|)
block|{
name|collectAcc
operator|.
name|setNextReader
argument_list|(
name|readerContext
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|otherAccs
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|SlotAcc
name|otherAcc
range|:
name|otherAccs
control|)
block|{
name|otherAcc
operator|.
name|setNextReader
argument_list|(
name|readerContext
argument_list|)
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|Override
DECL|method|compare
specifier|public
name|int
name|compare
parameter_list|(
name|int
name|slotA
parameter_list|,
name|int
name|slotB
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
DECL|method|getValue
specifier|public
name|Object
name|getValue
parameter_list|(
name|int
name|slotNum
parameter_list|)
throws|throws
name|IOException
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
DECL|method|setValues
specifier|public
name|void
name|setValues
parameter_list|(
name|SimpleOrderedMap
argument_list|<
name|Object
argument_list|>
name|bucket
parameter_list|,
name|int
name|slotNum
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|collectAcc
operator|!=
literal|null
condition|)
block|{
name|collectAcc
operator|.
name|setValues
argument_list|(
name|bucket
argument_list|,
name|collectAccSlot
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|otherAccs
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|SlotAcc
name|otherAcc
range|:
name|otherAccs
control|)
block|{
name|otherAcc
operator|.
name|setValues
argument_list|(
name|bucket
argument_list|,
name|otherAccsSlot
argument_list|)
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|Override
DECL|method|reset
specifier|public
name|void
name|reset
parameter_list|()
block|{
comment|// reset should be called on underlying accs
comment|// TODO: but in case something does need to be done here, should we require this method to be called but do nothing for now?
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
DECL|method|resize
specifier|public
name|void
name|resize
parameter_list|(
name|Resizer
name|resizer
parameter_list|)
block|{
comment|// someone else will call resize on collectAcc directly
if|if
condition|(
name|collectAccSlot
operator|>=
literal|0
condition|)
block|{
name|collectAccSlot
operator|=
name|resizer
operator|.
name|getNewSlot
argument_list|(
name|collectAccSlot
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_class
begin_comment
comment|// base class for FC style of facet counting (single and multi-valued strings)
end_comment
begin_class
DECL|class|FacetFieldProcessorFCBase
specifier|abstract
class|class
name|FacetFieldProcessorFCBase
extends|extends
name|FacetFieldProcessor
block|{
DECL|field|prefixRef
name|BytesRefBuilder
name|prefixRef
decl_stmt|;
DECL|field|startTermIndex
name|int
name|startTermIndex
decl_stmt|;
DECL|field|endTermIndex
name|int
name|endTermIndex
decl_stmt|;
DECL|field|nTerms
name|int
name|nTerms
decl_stmt|;
DECL|field|nDocs
name|int
name|nDocs
decl_stmt|;
DECL|field|maxSlots
name|int
name|maxSlots
decl_stmt|;
DECL|field|allBucketsSlot
name|int
name|allBucketsSlot
init|=
operator|-
literal|1
decl_stmt|;
comment|// slot for the primary Accs (countAcc, collectAcc)
DECL|method|FacetFieldProcessorFCBase
specifier|public
name|FacetFieldProcessorFCBase
parameter_list|(
name|FacetContext
name|fcontext
parameter_list|,
name|FacetField
name|freq
parameter_list|,
name|SchemaField
name|sf
parameter_list|)
block|{
name|super
argument_list|(
name|fcontext
argument_list|,
name|freq
argument_list|,
name|sf
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|process
specifier|public
name|void
name|process
parameter_list|()
throws|throws
name|IOException
block|{
name|super
operator|.
name|process
argument_list|()
expr_stmt|;
name|sf
operator|=
name|fcontext
operator|.
name|searcher
operator|.
name|getSchema
argument_list|()
operator|.
name|getField
argument_list|(
name|freq
operator|.
name|field
argument_list|)
expr_stmt|;
name|response
operator|=
name|getFieldCacheCounts
argument_list|()
expr_stmt|;
block|}
comment|/** this BytesRef may be shared across calls and should be deep-cloned if necessary */
DECL|method|lookupOrd
specifier|abstract
specifier|protected
name|BytesRef
name|lookupOrd
parameter_list|(
name|int
name|ord
parameter_list|)
throws|throws
name|IOException
function_decl|;
DECL|method|findStartAndEndOrds
specifier|abstract
specifier|protected
name|void
name|findStartAndEndOrds
parameter_list|()
throws|throws
name|IOException
function_decl|;
DECL|method|collectDocs
specifier|abstract
specifier|protected
name|void
name|collectDocs
parameter_list|()
throws|throws
name|IOException
function_decl|;
DECL|method|getFieldCacheCounts
specifier|public
name|SimpleOrderedMap
argument_list|<
name|Object
argument_list|>
name|getFieldCacheCounts
parameter_list|()
throws|throws
name|IOException
block|{
name|String
name|prefix
init|=
name|freq
operator|.
name|prefix
decl_stmt|;
if|if
condition|(
name|prefix
operator|==
literal|null
operator|||
name|prefix
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
block|{
name|prefixRef
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
name|prefixRef
operator|=
operator|new
name|BytesRefBuilder
argument_list|()
expr_stmt|;
name|prefixRef
operator|.
name|copyChars
argument_list|(
name|prefix
argument_list|)
expr_stmt|;
block|}
name|findStartAndEndOrds
argument_list|()
expr_stmt|;
name|maxSlots
operator|=
name|nTerms
expr_stmt|;
if|if
condition|(
name|freq
operator|.
name|allBuckets
condition|)
block|{
name|allBucketsSlot
operator|=
name|maxSlots
operator|++
expr_stmt|;
block|}
name|createCollectAcc
argument_list|(
name|nDocs
argument_list|,
name|maxSlots
argument_list|)
expr_stmt|;
if|if
condition|(
name|freq
operator|.
name|allBuckets
condition|)
block|{
name|allBucketsAcc
operator|=
operator|new
name|SpecialSlotAcc
argument_list|(
name|fcontext
argument_list|,
name|collectAcc
argument_list|,
name|allBucketsSlot
argument_list|,
name|otherAccs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|collectDocs
argument_list|()
expr_stmt|;
return|return
name|findTopSlots
argument_list|()
return|;
block|}
DECL|method|findTopSlots
specifier|protected
name|SimpleOrderedMap
argument_list|<
name|Object
argument_list|>
name|findTopSlots
parameter_list|()
throws|throws
name|IOException
block|{
name|SimpleOrderedMap
argument_list|<
name|Object
argument_list|>
name|res
init|=
operator|new
name|SimpleOrderedMap
argument_list|<>
argument_list|()
decl_stmt|;
name|int
name|numBuckets
init|=
literal|0
decl_stmt|;
name|List
argument_list|<
name|Object
argument_list|>
name|bucketVals
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|freq
operator|.
name|numBuckets
operator|&&
name|fcontext
operator|.
name|isShard
argument_list|()
condition|)
block|{
name|bucketVals
operator|=
operator|new
name|ArrayList
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
name|int
name|off
init|=
name|fcontext
operator|.
name|isShard
argument_list|()
condition|?
literal|0
else|:
operator|(
name|int
operator|)
name|freq
operator|.
name|offset
decl_stmt|;
comment|// add a modest amount of over-request if this is a shard request
name|int
name|lim
init|=
name|freq
operator|.
name|limit
operator|>=
literal|0
condition|?
operator|(
name|fcontext
operator|.
name|isShard
argument_list|()
condition|?
call|(
name|int
call|)
argument_list|(
name|freq
operator|.
name|limit
operator|*
literal|1.1
operator|+
literal|4
argument_list|)
else|:
operator|(
name|int
operator|)
name|freq
operator|.
name|limit
operator|)
else|:
name|Integer
operator|.
name|MAX_VALUE
decl_stmt|;
name|int
name|maxsize
init|=
call|(
name|int
call|)
argument_list|(
name|freq
operator|.
name|limit
operator|>=
literal|0
condition|?
name|freq
operator|.
name|offset
operator|+
name|lim
else|:
name|Integer
operator|.
name|MAX_VALUE
operator|-
literal|1
argument_list|)
decl_stmt|;
name|maxsize
operator|=
name|Math
operator|.
name|min
argument_list|(
name|maxsize
argument_list|,
name|nTerms
argument_list|)
expr_stmt|;
specifier|final
name|int
name|sortMul
init|=
name|freq
operator|.
name|sortDirection
operator|.
name|getMultiplier
argument_list|()
decl_stmt|;
specifier|final
name|SlotAcc
name|sortAcc
init|=
name|this
operator|.
name|sortAcc
decl_stmt|;
name|PriorityQueue
argument_list|<
name|Slot
argument_list|>
name|queue
init|=
operator|new
name|PriorityQueue
argument_list|<
name|Slot
argument_list|>
argument_list|(
name|maxsize
argument_list|)
block|{
annotation|@
name|Override
specifier|protected
name|boolean
name|lessThan
parameter_list|(
name|Slot
name|a
parameter_list|,
name|Slot
name|b
parameter_list|)
block|{
name|int
name|cmp
init|=
name|sortAcc
operator|.
name|compare
argument_list|(
name|a
operator|.
name|slot
argument_list|,
name|b
operator|.
name|slot
argument_list|)
operator|*
name|sortMul
decl_stmt|;
return|return
name|cmp
operator|==
literal|0
condition|?
name|b
operator|.
name|slot
operator|<
name|a
operator|.
name|slot
else|:
name|cmp
operator|<
literal|0
return|;
block|}
block|}
decl_stmt|;
name|Slot
name|bottom
init|=
literal|null
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nTerms
condition|;
name|i
operator|++
control|)
block|{
comment|// screen out buckets not matching mincount immediately (i.e. don't even increment numBuckets)
if|if
condition|(
name|effectiveMincount
operator|>
literal|0
operator|&&
name|countAcc
operator|.
name|getCount
argument_list|(
name|i
argument_list|)
operator|<
name|effectiveMincount
condition|)
block|{
continue|continue;
block|}
name|numBuckets
operator|++
expr_stmt|;
if|if
condition|(
name|bucketVals
operator|!=
literal|null
operator|&&
name|bucketVals
operator|.
name|size
argument_list|()
operator|<
literal|100
condition|)
block|{
name|int
name|ord
init|=
name|startTermIndex
operator|+
name|i
decl_stmt|;
name|BytesRef
name|br
init|=
name|lookupOrd
argument_list|(
name|ord
argument_list|)
decl_stmt|;
name|Object
name|val
init|=
name|sf
operator|.
name|getType
argument_list|()
operator|.
name|toObject
argument_list|(
name|sf
argument_list|,
name|br
argument_list|)
decl_stmt|;
name|bucketVals
operator|.
name|add
argument_list|(
name|val
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bottom
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|sortAcc
operator|.
name|compare
argument_list|(
name|bottom
operator|.
name|slot
argument_list|,
name|i
argument_list|)
operator|*
name|sortMul
operator|<
literal|0
condition|)
block|{
name|bottom
operator|.
name|slot
operator|=
name|i
expr_stmt|;
name|bottom
operator|=
name|queue
operator|.
name|updateTop
argument_list|()
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|lim
operator|>
literal|0
condition|)
block|{
comment|// queue not full
name|Slot
name|s
init|=
operator|new
name|Slot
argument_list|()
decl_stmt|;
name|s
operator|.
name|slot
operator|=
name|i
expr_stmt|;
name|queue
operator|.
name|add
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|queue
operator|.
name|size
argument_list|()
operator|>=
name|maxsize
condition|)
block|{
name|bottom
operator|=
name|queue
operator|.
name|top
argument_list|()
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|freq
operator|.
name|numBuckets
condition|)
block|{
if|if
condition|(
operator|!
name|fcontext
operator|.
name|isShard
argument_list|()
condition|)
block|{
name|res
operator|.
name|add
argument_list|(
literal|"numBuckets"
argument_list|,
name|numBuckets
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SimpleOrderedMap
name|map
init|=
operator|new
name|SimpleOrderedMap
argument_list|(
literal|2
argument_list|)
decl_stmt|;
name|map
operator|.
name|add
argument_list|(
literal|"numBuckets"
argument_list|,
name|numBuckets
argument_list|)
expr_stmt|;
name|map
operator|.
name|add
argument_list|(
literal|"vals"
argument_list|,
name|bucketVals
argument_list|)
expr_stmt|;
name|res
operator|.
name|add
argument_list|(
literal|"numBuckets"
argument_list|,
name|map
argument_list|)
expr_stmt|;
block|}
block|}
name|FacetDebugInfo
name|fdebug
init|=
name|fcontext
operator|.
name|getDebugInfo
argument_list|()
decl_stmt|;
if|if
condition|(
name|fdebug
operator|!=
literal|null
condition|)
name|fdebug
operator|.
name|putInfoItem
argument_list|(
literal|"numBuckets"
argument_list|,
operator|new
name|Long
argument_list|(
name|numBuckets
argument_list|)
argument_list|)
expr_stmt|;
comment|// if we are deep paging, we don't have to order the highest "offset" counts.
name|int
name|collectCount
init|=
name|Math
operator|.
name|max
argument_list|(
literal|0
argument_list|,
name|queue
operator|.
name|size
argument_list|()
operator|-
name|off
argument_list|)
decl_stmt|;
assert|assert
name|collectCount
operator|<=
name|lim
assert|;
name|int
index|[]
name|sortedSlots
init|=
operator|new
name|int
index|[
name|collectCount
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|collectCount
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|sortedSlots
index|[
name|i
index|]
operator|=
name|queue
operator|.
name|pop
argument_list|()
operator|.
name|slot
expr_stmt|;
block|}
if|if
condition|(
name|freq
operator|.
name|allBuckets
condition|)
block|{
name|SimpleOrderedMap
argument_list|<
name|Object
argument_list|>
name|allBuckets
init|=
operator|new
name|SimpleOrderedMap
argument_list|<>
argument_list|()
decl_stmt|;
name|allBuckets
operator|.
name|add
argument_list|(
literal|"count"
argument_list|,
name|allBucketsAcc
operator|.
name|getSpecialCount
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|allBucketsAcc
operator|!=
literal|null
condition|)
block|{
name|allBucketsAcc
operator|.
name|setValues
argument_list|(
name|allBuckets
argument_list|,
name|allBucketsSlot
argument_list|)
expr_stmt|;
block|}
name|res
operator|.
name|add
argument_list|(
literal|"allBuckets"
argument_list|,
name|allBuckets
argument_list|)
expr_stmt|;
block|}
name|ArrayList
name|bucketList
init|=
operator|new
name|ArrayList
argument_list|(
name|collectCount
argument_list|)
decl_stmt|;
name|res
operator|.
name|add
argument_list|(
literal|"buckets"
argument_list|,
name|bucketList
argument_list|)
expr_stmt|;
comment|// TODO: do this with a callback instead?
name|boolean
name|needFilter
init|=
name|deferredAggs
operator|!=
literal|null
operator|||
name|freq
operator|.
name|getSubFacets
argument_list|()
operator|.
name|size
argument_list|()
operator|>
literal|0
decl_stmt|;
for|for
control|(
name|int
name|slotNum
range|:
name|sortedSlots
control|)
block|{
name|SimpleOrderedMap
argument_list|<
name|Object
argument_list|>
name|bucket
init|=
operator|new
name|SimpleOrderedMap
argument_list|<>
argument_list|()
decl_stmt|;
comment|// get the ord of the slot...
name|int
name|ord
init|=
name|startTermIndex
operator|+
name|slotNum
decl_stmt|;
name|BytesRef
name|br
init|=
name|lookupOrd
argument_list|(
name|ord
argument_list|)
decl_stmt|;
name|Object
name|val
init|=
name|sf
operator|.
name|getType
argument_list|()
operator|.
name|toObject
argument_list|(
name|sf
argument_list|,
name|br
argument_list|)
decl_stmt|;
name|bucket
operator|.
name|add
argument_list|(
literal|"val"
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|TermQuery
name|filter
init|=
name|needFilter
condition|?
operator|new
name|TermQuery
argument_list|(
operator|new
name|Term
argument_list|(
name|sf
operator|.
name|getName
argument_list|()
argument_list|,
name|br
argument_list|)
argument_list|)
else|:
literal|null
decl_stmt|;
name|fillBucket
argument_list|(
name|bucket
argument_list|,
name|countAcc
operator|.
name|getCount
argument_list|(
name|slotNum
argument_list|)
argument_list|,
name|slotNum
argument_list|,
literal|null
argument_list|,
name|filter
argument_list|)
expr_stmt|;
name|bucketList
operator|.
name|add
argument_list|(
name|bucket
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|freq
operator|.
name|missing
condition|)
block|{
name|SimpleOrderedMap
argument_list|<
name|Object
argument_list|>
name|missingBucket
init|=
operator|new
name|SimpleOrderedMap
argument_list|<>
argument_list|()
decl_stmt|;
name|fillBucket
argument_list|(
name|missingBucket
argument_list|,
name|getFieldMissingQuery
argument_list|(
name|fcontext
operator|.
name|searcher
argument_list|,
name|freq
operator|.
name|field
argument_list|)
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|res
operator|.
name|add
argument_list|(
literal|"missing"
argument_list|,
name|missingBucket
argument_list|)
expr_stmt|;
block|}
return|return
name|res
return|;
block|}
block|}
end_class
begin_comment
comment|// UnInvertedField implementation of field faceting
end_comment
begin_class
DECL|class|FacetFieldProcessorUIF
class|class
name|FacetFieldProcessorUIF
extends|extends
name|FacetFieldProcessorFCBase
block|{
DECL|field|uif
name|UnInvertedField
name|uif
decl_stmt|;
DECL|field|te
name|TermsEnum
name|te
decl_stmt|;
DECL|method|FacetFieldProcessorUIF
name|FacetFieldProcessorUIF
parameter_list|(
name|FacetContext
name|fcontext
parameter_list|,
name|FacetField
name|freq
parameter_list|,
name|SchemaField
name|sf
parameter_list|)
block|{
name|super
argument_list|(
name|fcontext
argument_list|,
name|freq
argument_list|,
name|sf
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|findStartAndEndOrds
specifier|protected
name|void
name|findStartAndEndOrds
parameter_list|()
throws|throws
name|IOException
block|{
name|uif
operator|=
name|UnInvertedField
operator|.
name|getUnInvertedField
argument_list|(
name|freq
operator|.
name|field
argument_list|,
name|fcontext
operator|.
name|searcher
argument_list|)
expr_stmt|;
name|te
operator|=
name|uif
operator|.
name|getOrdTermsEnum
argument_list|(
name|fcontext
operator|.
name|searcher
operator|.
name|getLeafReader
argument_list|()
argument_list|)
expr_stmt|;
comment|// "te" can be null
name|startTermIndex
operator|=
literal|0
expr_stmt|;
name|endTermIndex
operator|=
name|uif
operator|.
name|numTerms
argument_list|()
expr_stmt|;
comment|// one past the end
if|if
condition|(
name|prefixRef
operator|!=
literal|null
operator|&&
name|te
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|te
operator|.
name|seekCeil
argument_list|(
name|prefixRef
operator|.
name|get
argument_list|()
argument_list|)
operator|==
name|TermsEnum
operator|.
name|SeekStatus
operator|.
name|END
condition|)
block|{
name|startTermIndex
operator|=
name|uif
operator|.
name|numTerms
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|startTermIndex
operator|=
operator|(
name|int
operator|)
name|te
operator|.
name|ord
argument_list|()
expr_stmt|;
block|}
name|prefixRef
operator|.
name|append
argument_list|(
name|UnicodeUtil
operator|.
name|BIG_TERM
argument_list|)
expr_stmt|;
if|if
condition|(
name|te
operator|.
name|seekCeil
argument_list|(
name|prefixRef
operator|.
name|get
argument_list|()
argument_list|)
operator|==
name|TermsEnum
operator|.
name|SeekStatus
operator|.
name|END
condition|)
block|{
name|endTermIndex
operator|=
name|uif
operator|.
name|numTerms
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|endTermIndex
operator|=
operator|(
name|int
operator|)
name|te
operator|.
name|ord
argument_list|()
expr_stmt|;
block|}
block|}
name|nTerms
operator|=
name|endTermIndex
operator|-
name|startTermIndex
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|lookupOrd
specifier|protected
name|BytesRef
name|lookupOrd
parameter_list|(
name|int
name|ord
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|uif
operator|.
name|getTermValue
argument_list|(
name|te
argument_list|,
name|ord
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|collectDocs
specifier|protected
name|void
name|collectDocs
parameter_list|()
throws|throws
name|IOException
block|{
name|uif
operator|.
name|collectDocs
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
block|}
end_class
begin_class
DECL|class|FacetFieldProcessorStream
class|class
name|FacetFieldProcessorStream
extends|extends
name|FacetFieldProcessor
implements|implements
name|Closeable
block|{
DECL|field|bucketsToSkip
name|long
name|bucketsToSkip
decl_stmt|;
DECL|field|bucketsReturned
name|long
name|bucketsReturned
decl_stmt|;
DECL|field|closed
name|boolean
name|closed
decl_stmt|;
DECL|field|countOnly
name|boolean
name|countOnly
decl_stmt|;
DECL|field|hasSubFacets
name|boolean
name|hasSubFacets
decl_stmt|;
comment|// true if there are subfacets
DECL|field|minDfFilterCache
name|int
name|minDfFilterCache
decl_stmt|;
DECL|field|docs
name|DocSet
name|docs
decl_stmt|;
DECL|field|fastForRandomSet
name|DocSet
name|fastForRandomSet
decl_stmt|;
DECL|field|termsEnum
name|TermsEnum
name|termsEnum
init|=
literal|null
decl_stmt|;
DECL|field|deState
name|SolrIndexSearcher
operator|.
name|DocsEnumState
name|deState
init|=
literal|null
decl_stmt|;
DECL|field|postingsEnum
name|PostingsEnum
name|postingsEnum
decl_stmt|;
DECL|field|startTermBytes
name|BytesRef
name|startTermBytes
decl_stmt|;
DECL|field|term
name|BytesRef
name|term
decl_stmt|;
DECL|field|leaves
name|LeafReaderContext
index|[]
name|leaves
decl_stmt|;
DECL|method|FacetFieldProcessorStream
name|FacetFieldProcessorStream
parameter_list|(
name|FacetContext
name|fcontext
parameter_list|,
name|FacetField
name|freq
parameter_list|,
name|SchemaField
name|sf
parameter_list|)
block|{
name|super
argument_list|(
name|fcontext
argument_list|,
name|freq
argument_list|,
name|sf
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|close
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|closed
condition|)
block|{
name|closed
operator|=
literal|true
expr_stmt|;
comment|// fcontext.base.decref();  // OFF-HEAP
block|}
block|}
annotation|@
name|Override
DECL|method|process
specifier|public
name|void
name|process
parameter_list|()
throws|throws
name|IOException
block|{
name|super
operator|.
name|process
argument_list|()
expr_stmt|;
comment|// We need to keep the fcontext open after processing is done (since we will be streaming in the response writer).
comment|// But if the connection is broken, we want to clean up.
comment|// fcontext.base.incref();  // OFF-HEAP
name|fcontext
operator|.
name|qcontext
operator|.
name|addCloseHook
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|setup
argument_list|()
expr_stmt|;
name|response
operator|=
operator|new
name|SimpleOrderedMap
argument_list|<>
argument_list|()
expr_stmt|;
name|response
operator|.
name|add
argument_list|(
literal|"buckets"
argument_list|,
operator|new
name|Iterator
argument_list|()
block|{
name|boolean
name|retrieveNext
init|=
literal|true
decl_stmt|;
name|Object
name|val
decl_stmt|;
annotation|@
name|Override
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
if|if
condition|(
name|retrieveNext
condition|)
block|{
name|val
operator|=
name|nextBucket
argument_list|()
expr_stmt|;
block|}
name|retrieveNext
operator|=
literal|false
expr_stmt|;
return|return
name|val
operator|!=
literal|null
return|;
block|}
annotation|@
name|Override
specifier|public
name|Object
name|next
parameter_list|()
block|{
if|if
condition|(
name|retrieveNext
condition|)
block|{
name|val
operator|=
name|nextBucket
argument_list|()
expr_stmt|;
block|}
name|retrieveNext
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|val
operator|==
literal|null
condition|)
block|{
comment|// Last value, so clean up.  In the case that we are doing streaming facets within streaming facets,
comment|// the number of close hooks could grow very large, so we want to remove ourselves.
name|boolean
name|removed
init|=
name|fcontext
operator|.
name|qcontext
operator|.
name|removeCloseHook
argument_list|(
name|FacetFieldProcessorStream
operator|.
name|this
argument_list|)
decl_stmt|;
assert|assert
name|removed
assert|;
try|try
block|{
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|SolrException
operator|.
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
literal|"Error during facet streaming close"
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
return|return
name|val
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|remove
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
DECL|method|setup
specifier|public
name|void
name|setup
parameter_list|()
throws|throws
name|IOException
block|{
name|countOnly
operator|=
name|freq
operator|.
name|facetStats
operator|.
name|size
argument_list|()
operator|==
literal|0
operator|||
name|freq
operator|.
name|facetStats
operator|.
name|values
argument_list|()
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
operator|instanceof
name|CountAgg
expr_stmt|;
name|hasSubFacets
operator|=
name|freq
operator|.
name|subFacets
operator|.
name|size
argument_list|()
operator|>
literal|0
expr_stmt|;
name|bucketsToSkip
operator|=
name|freq
operator|.
name|offset
expr_stmt|;
name|createAccs
argument_list|(
operator|-
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|// Minimum term docFreq in order to use the filterCache for that term.
name|int
name|defaultMinDf
init|=
name|Math
operator|.
name|max
argument_list|(
name|fcontext
operator|.
name|searcher
operator|.
name|maxDoc
argument_list|()
operator|>>
literal|4
argument_list|,
literal|3
argument_list|)
decl_stmt|;
comment|// (minimum of 3 is for test coverage purposes)
name|int
name|minDfFilterCache
init|=
name|freq
operator|.
name|cacheDf
operator|==
literal|0
condition|?
name|defaultMinDf
else|:
name|freq
operator|.
name|cacheDf
decl_stmt|;
if|if
condition|(
name|minDfFilterCache
operator|==
operator|-
literal|1
condition|)
name|minDfFilterCache
operator|=
name|Integer
operator|.
name|MAX_VALUE
expr_stmt|;
comment|// -1 means never cache
name|docs
operator|=
name|fcontext
operator|.
name|base
expr_stmt|;
name|fastForRandomSet
operator|=
literal|null
expr_stmt|;
if|if
condition|(
name|freq
operator|.
name|prefix
operator|!=
literal|null
condition|)
block|{
name|String
name|indexedPrefix
init|=
name|sf
operator|.
name|getType
argument_list|()
operator|.
name|toInternal
argument_list|(
name|freq
operator|.
name|prefix
argument_list|)
decl_stmt|;
name|startTermBytes
operator|=
operator|new
name|BytesRef
argument_list|(
name|indexedPrefix
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sf
operator|.
name|getType
argument_list|()
operator|.
name|getNumericType
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|String
name|triePrefix
init|=
name|TrieField
operator|.
name|getMainValuePrefix
argument_list|(
name|sf
operator|.
name|getType
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|triePrefix
operator|!=
literal|null
condition|)
block|{
name|startTermBytes
operator|=
operator|new
name|BytesRef
argument_list|(
name|triePrefix
argument_list|)
expr_stmt|;
block|}
block|}
name|Fields
name|fields
init|=
name|fcontext
operator|.
name|searcher
operator|.
name|getLeafReader
argument_list|()
operator|.
name|fields
argument_list|()
decl_stmt|;
name|Terms
name|terms
init|=
name|fields
operator|==
literal|null
condition|?
literal|null
else|:
name|fields
operator|.
name|terms
argument_list|(
name|sf
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
name|termsEnum
operator|=
literal|null
expr_stmt|;
name|deState
operator|=
literal|null
expr_stmt|;
name|term
operator|=
literal|null
expr_stmt|;
if|if
condition|(
name|terms
operator|!=
literal|null
condition|)
block|{
name|termsEnum
operator|=
name|terms
operator|.
name|iterator
argument_list|()
expr_stmt|;
comment|// TODO: OPT: if seek(ord) is supported for this termsEnum, then we could use it for
comment|// facet.offset when sorting by index order.
if|if
condition|(
name|startTermBytes
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|termsEnum
operator|.
name|seekCeil
argument_list|(
name|startTermBytes
argument_list|)
operator|==
name|TermsEnum
operator|.
name|SeekStatus
operator|.
name|END
condition|)
block|{
name|termsEnum
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
name|term
operator|=
name|termsEnum
operator|.
name|term
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// position termsEnum on first term
name|term
operator|=
name|termsEnum
operator|.
name|next
argument_list|()
expr_stmt|;
block|}
block|}
name|List
argument_list|<
name|LeafReaderContext
argument_list|>
name|leafList
init|=
name|fcontext
operator|.
name|searcher
operator|.
name|getTopReaderContext
argument_list|()
operator|.
name|leaves
argument_list|()
decl_stmt|;
name|leaves
operator|=
name|leafList
operator|.
name|toArray
argument_list|(
operator|new
name|LeafReaderContext
index|[
name|leafList
operator|.
name|size
argument_list|()
index|]
argument_list|)
expr_stmt|;
block|}
DECL|method|nextBucket
specifier|public
name|SimpleOrderedMap
argument_list|<
name|Object
argument_list|>
name|nextBucket
parameter_list|()
block|{
try|try
block|{
return|return
name|_nextBucket
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|SolrException
operator|.
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
literal|"Error during facet streaming"
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
DECL|method|_nextBucket
specifier|public
name|SimpleOrderedMap
argument_list|<
name|Object
argument_list|>
name|_nextBucket
parameter_list|()
throws|throws
name|IOException
block|{
name|DocSet
name|termSet
init|=
literal|null
decl_stmt|;
try|try
block|{
while|while
condition|(
name|term
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|startTermBytes
operator|!=
literal|null
operator|&&
operator|!
name|StringHelper
operator|.
name|startsWith
argument_list|(
name|term
argument_list|,
name|startTermBytes
argument_list|)
condition|)
block|{
break|break;
block|}
name|int
name|df
init|=
name|termsEnum
operator|.
name|docFreq
argument_list|()
decl_stmt|;
if|if
condition|(
name|df
operator|<
name|effectiveMincount
condition|)
block|{
name|term
operator|=
name|termsEnum
operator|.
name|next
argument_list|()
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|termSet
operator|!=
literal|null
condition|)
block|{
comment|// termSet.decref(); // OFF-HEAP
name|termSet
operator|=
literal|null
expr_stmt|;
block|}
name|int
name|c
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|hasSubFacets
operator|||
name|df
operator|>=
name|minDfFilterCache
condition|)
block|{
comment|// use the filter cache
if|if
condition|(
name|deState
operator|==
literal|null
condition|)
block|{
name|deState
operator|=
operator|new
name|SolrIndexSearcher
operator|.
name|DocsEnumState
argument_list|()
expr_stmt|;
name|deState
operator|.
name|fieldName
operator|=
name|sf
operator|.
name|getName
argument_list|()
expr_stmt|;
name|deState
operator|.
name|liveDocs
operator|=
name|fcontext
operator|.
name|searcher
operator|.
name|getLeafReader
argument_list|()
operator|.
name|getLiveDocs
argument_list|()
expr_stmt|;
name|deState
operator|.
name|termsEnum
operator|=
name|termsEnum
expr_stmt|;
name|deState
operator|.
name|postingsEnum
operator|=
name|postingsEnum
expr_stmt|;
name|deState
operator|.
name|minSetSizeCached
operator|=
name|minDfFilterCache
expr_stmt|;
block|}
if|if
condition|(
name|hasSubFacets
operator|||
operator|!
name|countOnly
condition|)
block|{
name|DocSet
name|termsAll
init|=
name|fcontext
operator|.
name|searcher
operator|.
name|getDocSet
argument_list|(
name|deState
argument_list|)
decl_stmt|;
name|termSet
operator|=
name|docs
operator|.
name|intersection
argument_list|(
name|termsAll
argument_list|)
expr_stmt|;
comment|// termsAll.decref(); // OFF-HEAP
name|c
operator|=
name|termSet
operator|.
name|size
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|c
operator|=
name|fcontext
operator|.
name|searcher
operator|.
name|numDocs
argument_list|(
name|docs
argument_list|,
name|deState
argument_list|)
expr_stmt|;
block|}
name|postingsEnum
operator|=
name|deState
operator|.
name|postingsEnum
expr_stmt|;
name|resetStats
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|countOnly
condition|)
block|{
name|collect
argument_list|(
name|termSet
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// We don't need the docset here (meaning no sub-facets).
comment|// if countOnly, then we are calculating some other stats...
name|resetStats
argument_list|()
expr_stmt|;
comment|// lazy convert to fastForRandomSet
if|if
condition|(
name|fastForRandomSet
operator|==
literal|null
condition|)
block|{
name|fastForRandomSet
operator|=
name|docs
expr_stmt|;
if|if
condition|(
name|docs
operator|instanceof
name|SortedIntDocSet
condition|)
block|{
comment|// OFF-HEAP todo: also check for native version
name|SortedIntDocSet
name|sset
init|=
operator|(
name|SortedIntDocSet
operator|)
name|docs
decl_stmt|;
name|fastForRandomSet
operator|=
operator|new
name|HashDocSet
argument_list|(
name|sset
operator|.
name|getDocs
argument_list|()
argument_list|,
literal|0
argument_list|,
name|sset
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|// iterate over TermDocs to calculate the intersection
name|postingsEnum
operator|=
name|termsEnum
operator|.
name|postings
argument_list|(
name|postingsEnum
argument_list|,
name|PostingsEnum
operator|.
name|NONE
argument_list|)
expr_stmt|;
if|if
condition|(
name|postingsEnum
operator|instanceof
name|MultiPostingsEnum
condition|)
block|{
name|MultiPostingsEnum
operator|.
name|EnumWithSlice
index|[]
name|subs
init|=
operator|(
operator|(
name|MultiPostingsEnum
operator|)
name|postingsEnum
operator|)
operator|.
name|getSubs
argument_list|()
decl_stmt|;
name|int
name|numSubs
init|=
operator|(
operator|(
name|MultiPostingsEnum
operator|)
name|postingsEnum
operator|)
operator|.
name|getNumSubs
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|subindex
init|=
literal|0
init|;
name|subindex
operator|<
name|numSubs
condition|;
name|subindex
operator|++
control|)
block|{
name|MultiPostingsEnum
operator|.
name|EnumWithSlice
name|sub
init|=
name|subs
index|[
name|subindex
index|]
decl_stmt|;
if|if
condition|(
name|sub
operator|.
name|postingsEnum
operator|==
literal|null
condition|)
continue|continue;
name|int
name|base
init|=
name|sub
operator|.
name|slice
operator|.
name|start
decl_stmt|;
name|int
name|docid
decl_stmt|;
if|if
condition|(
name|countOnly
condition|)
block|{
while|while
condition|(
operator|(
name|docid
operator|=
name|sub
operator|.
name|postingsEnum
operator|.
name|nextDoc
argument_list|()
operator|)
operator|!=
name|DocIdSetIterator
operator|.
name|NO_MORE_DOCS
condition|)
block|{
if|if
condition|(
name|fastForRandomSet
operator|.
name|exists
argument_list|(
name|docid
operator|+
name|base
argument_list|)
condition|)
name|c
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
name|setNextReader
argument_list|(
name|leaves
index|[
name|sub
operator|.
name|slice
operator|.
name|readerIndex
index|]
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|docid
operator|=
name|sub
operator|.
name|postingsEnum
operator|.
name|nextDoc
argument_list|()
operator|)
operator|!=
name|DocIdSetIterator
operator|.
name|NO_MORE_DOCS
condition|)
block|{
if|if
condition|(
name|fastForRandomSet
operator|.
name|exists
argument_list|(
name|docid
operator|+
name|base
argument_list|)
condition|)
block|{
name|c
operator|++
expr_stmt|;
name|collect
argument_list|(
name|docid
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
else|else
block|{
name|int
name|docid
decl_stmt|;
if|if
condition|(
name|countOnly
condition|)
block|{
while|while
condition|(
operator|(
name|docid
operator|=
name|postingsEnum
operator|.
name|nextDoc
argument_list|()
operator|)
operator|!=
name|DocIdSetIterator
operator|.
name|NO_MORE_DOCS
condition|)
block|{
if|if
condition|(
name|fastForRandomSet
operator|.
name|exists
argument_list|(
name|docid
argument_list|)
condition|)
name|c
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
name|setNextReader
argument_list|(
name|leaves
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|docid
operator|=
name|postingsEnum
operator|.
name|nextDoc
argument_list|()
operator|)
operator|!=
name|DocIdSetIterator
operator|.
name|NO_MORE_DOCS
condition|)
block|{
if|if
condition|(
name|fastForRandomSet
operator|.
name|exists
argument_list|(
name|docid
argument_list|)
condition|)
block|{
name|c
operator|++
expr_stmt|;
name|collect
argument_list|(
name|docid
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
if|if
condition|(
name|c
operator|<
name|effectiveMincount
condition|)
block|{
name|term
operator|=
name|termsEnum
operator|.
name|next
argument_list|()
expr_stmt|;
continue|continue;
block|}
comment|// handle offset and limit
if|if
condition|(
name|bucketsToSkip
operator|>
literal|0
condition|)
block|{
name|bucketsToSkip
operator|--
expr_stmt|;
name|term
operator|=
name|termsEnum
operator|.
name|next
argument_list|()
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|freq
operator|.
name|limit
operator|>=
literal|0
operator|&&
operator|++
name|bucketsReturned
operator|>
name|freq
operator|.
name|limit
condition|)
block|{
return|return
literal|null
return|;
block|}
comment|// set count in case other stats depend on it
name|countAcc
operator|.
name|incrementCount
argument_list|(
literal|0
argument_list|,
name|c
argument_list|)
expr_stmt|;
comment|// OK, we have a good bucket to return... first get bucket value before moving to next term
name|Object
name|bucketVal
init|=
name|sf
operator|.
name|getType
argument_list|()
operator|.
name|toObject
argument_list|(
name|sf
argument_list|,
name|term
argument_list|)
decl_stmt|;
name|TermQuery
name|bucketQuery
init|=
name|hasSubFacets
condition|?
operator|new
name|TermQuery
argument_list|(
operator|new
name|Term
argument_list|(
name|freq
operator|.
name|field
argument_list|,
name|term
argument_list|)
argument_list|)
else|:
literal|null
decl_stmt|;
name|term
operator|=
name|termsEnum
operator|.
name|next
argument_list|()
expr_stmt|;
name|SimpleOrderedMap
argument_list|<
name|Object
argument_list|>
name|bucket
init|=
operator|new
name|SimpleOrderedMap
argument_list|<>
argument_list|()
decl_stmt|;
name|bucket
operator|.
name|add
argument_list|(
literal|"val"
argument_list|,
name|bucketVal
argument_list|)
expr_stmt|;
name|addStats
argument_list|(
name|bucket
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|hasSubFacets
condition|)
block|{
name|processSubs
argument_list|(
name|bucket
argument_list|,
name|bucketQuery
argument_list|,
name|termSet
argument_list|)
expr_stmt|;
block|}
comment|// TODO... termSet needs to stick around for streaming sub-facets?
return|return
name|bucket
return|;
block|}
block|}
finally|finally
block|{
if|if
condition|(
name|termSet
operator|!=
literal|null
condition|)
block|{
comment|// termSet.decref();  // OFF-HEAP
name|termSet
operator|=
literal|null
expr_stmt|;
block|}
block|}
comment|// end of the iteration
return|return
literal|null
return|;
block|}
block|}
end_class
end_unit
