begin_unit
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_package
DECL|package|org.apache.solr.search
package|package
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|search
package|;
end_package
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Closeable
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URL
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|*
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicLong
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|document
operator|.
name|BinaryField
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|document
operator|.
name|Document
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|document
operator|.
name|Field
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|document
operator|.
name|FieldType
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|document
operator|.
name|LazyDocument
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|document
operator|.
name|NumericField
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|document
operator|.
name|TextField
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|*
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|IndexReader
operator|.
name|AtomicReaderContext
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|*
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|Directory
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|FSDirectory
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|Bits
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|BytesRef
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|OpenBitSet
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|ReaderUtil
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|params
operator|.
name|ModifiableSolrParams
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|util
operator|.
name|NamedList
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|util
operator|.
name|SimpleOrderedMap
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|core
operator|.
name|DirectoryFactory
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|core
operator|.
name|SolrConfig
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|core
operator|.
name|SolrCore
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|core
operator|.
name|SolrInfoMBean
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|request
operator|.
name|LocalSolrQueryRequest
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|request
operator|.
name|SolrQueryRequest
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|request
operator|.
name|SolrRequestInfo
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|request
operator|.
name|UnInvertedField
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|response
operator|.
name|SolrQueryResponse
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|schema
operator|.
name|IndexSchema
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|schema
operator|.
name|SchemaField
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|update
operator|.
name|SolrIndexConfig
import|;
end_import
begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import
begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import
begin_comment
comment|/**  * SolrIndexSearcher adds schema awareness and caching functionality  * over the lucene IndexSearcher.  *  *  * @since solr 0.9  */
end_comment
begin_class
DECL|class|SolrIndexSearcher
specifier|public
class|class
name|SolrIndexSearcher
extends|extends
name|IndexSearcher
implements|implements
name|Closeable
implements|,
name|SolrInfoMBean
block|{
comment|// These should *only* be used for debugging or monitoring purposes
DECL|field|numOpens
specifier|public
specifier|static
specifier|final
name|AtomicLong
name|numOpens
init|=
operator|new
name|AtomicLong
argument_list|()
decl_stmt|;
DECL|field|numCloses
specifier|public
specifier|static
specifier|final
name|AtomicLong
name|numCloses
init|=
operator|new
name|AtomicLong
argument_list|()
decl_stmt|;
DECL|field|log
specifier|private
specifier|static
name|Logger
name|log
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|SolrIndexSearcher
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|core
specifier|private
specifier|final
name|SolrCore
name|core
decl_stmt|;
DECL|field|schema
specifier|private
specifier|final
name|IndexSchema
name|schema
decl_stmt|;
DECL|field|indexDir
specifier|private
name|String
name|indexDir
decl_stmt|;
DECL|field|name
specifier|private
specifier|final
name|String
name|name
decl_stmt|;
DECL|field|openTime
specifier|private
name|long
name|openTime
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
DECL|field|registerTime
specifier|private
name|long
name|registerTime
init|=
literal|0
decl_stmt|;
DECL|field|warmupTime
specifier|private
name|long
name|warmupTime
init|=
literal|0
decl_stmt|;
DECL|field|reader
specifier|private
specifier|final
name|IndexReader
name|reader
decl_stmt|;
DECL|field|closeReader
specifier|private
specifier|final
name|boolean
name|closeReader
decl_stmt|;
DECL|field|queryResultWindowSize
specifier|private
specifier|final
name|int
name|queryResultWindowSize
decl_stmt|;
DECL|field|queryResultMaxDocsCached
specifier|private
specifier|final
name|int
name|queryResultMaxDocsCached
decl_stmt|;
DECL|field|useFilterForSortedQuery
specifier|private
specifier|final
name|boolean
name|useFilterForSortedQuery
decl_stmt|;
DECL|field|enableLazyFieldLoading
specifier|public
specifier|final
name|boolean
name|enableLazyFieldLoading
decl_stmt|;
DECL|field|cachingEnabled
specifier|private
specifier|final
name|boolean
name|cachingEnabled
decl_stmt|;
DECL|field|filterCache
specifier|private
specifier|final
name|SolrCache
argument_list|<
name|Query
argument_list|,
name|DocSet
argument_list|>
name|filterCache
decl_stmt|;
DECL|field|queryResultCache
specifier|private
specifier|final
name|SolrCache
argument_list|<
name|QueryResultKey
argument_list|,
name|DocList
argument_list|>
name|queryResultCache
decl_stmt|;
DECL|field|documentCache
specifier|private
specifier|final
name|SolrCache
argument_list|<
name|Integer
argument_list|,
name|Document
argument_list|>
name|documentCache
decl_stmt|;
DECL|field|fieldValueCache
specifier|private
specifier|final
name|SolrCache
argument_list|<
name|String
argument_list|,
name|UnInvertedField
argument_list|>
name|fieldValueCache
decl_stmt|;
DECL|field|optimizer
specifier|private
specifier|final
name|LuceneQueryOptimizer
name|optimizer
decl_stmt|;
comment|// map of generic caches - not synchronized since it's read-only after the constructor.
DECL|field|cacheMap
specifier|private
specifier|final
name|HashMap
argument_list|<
name|String
argument_list|,
name|SolrCache
argument_list|>
name|cacheMap
decl_stmt|;
DECL|field|noGenericCaches
specifier|private
specifier|static
specifier|final
name|HashMap
argument_list|<
name|String
argument_list|,
name|SolrCache
argument_list|>
name|noGenericCaches
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|SolrCache
argument_list|>
argument_list|(
literal|0
argument_list|)
decl_stmt|;
comment|// list of all caches associated with this searcher.
DECL|field|cacheList
specifier|private
specifier|final
name|SolrCache
index|[]
name|cacheList
decl_stmt|;
DECL|field|noCaches
specifier|private
specifier|static
specifier|final
name|SolrCache
index|[]
name|noCaches
init|=
operator|new
name|SolrCache
index|[
literal|0
index|]
decl_stmt|;
DECL|field|fieldNames
specifier|private
specifier|final
name|Collection
argument_list|<
name|String
argument_list|>
name|fieldNames
decl_stmt|;
DECL|field|storedHighlightFieldNames
specifier|private
name|Collection
argument_list|<
name|String
argument_list|>
name|storedHighlightFieldNames
decl_stmt|;
DECL|field|directoryFactory
specifier|private
name|DirectoryFactory
name|directoryFactory
decl_stmt|;
DECL|method|SolrIndexSearcher
specifier|public
name|SolrIndexSearcher
parameter_list|(
name|SolrCore
name|core
parameter_list|,
name|String
name|path
parameter_list|,
name|IndexSchema
name|schema
parameter_list|,
name|SolrIndexConfig
name|config
parameter_list|,
name|String
name|name
parameter_list|,
name|boolean
name|enableCache
parameter_list|,
name|DirectoryFactory
name|directoryFactory
parameter_list|)
throws|throws
name|IOException
block|{
comment|// we don't need to reserve the directory because we get it from the factory
name|this
argument_list|(
name|core
argument_list|,
name|schema
argument_list|,
name|name
argument_list|,
name|core
operator|.
name|getIndexReaderFactory
argument_list|()
operator|.
name|newReader
argument_list|(
name|directoryFactory
operator|.
name|get
argument_list|(
name|path
argument_list|,
name|config
operator|.
name|lockType
argument_list|)
argument_list|)
argument_list|,
literal|true
argument_list|,
name|enableCache
argument_list|,
literal|false
argument_list|,
name|directoryFactory
argument_list|)
expr_stmt|;
block|}
DECL|method|SolrIndexSearcher
specifier|public
name|SolrIndexSearcher
parameter_list|(
name|SolrCore
name|core
parameter_list|,
name|IndexSchema
name|schema
parameter_list|,
name|String
name|name
parameter_list|,
name|IndexReader
name|r
parameter_list|,
name|boolean
name|closeReader
parameter_list|,
name|boolean
name|enableCache
parameter_list|,
name|boolean
name|reserveDirectory
parameter_list|,
name|DirectoryFactory
name|directoryFactory
parameter_list|)
block|{
name|super
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|this
operator|.
name|directoryFactory
operator|=
name|directoryFactory
expr_stmt|;
name|this
operator|.
name|reader
operator|=
name|getIndexReader
argument_list|()
expr_stmt|;
name|this
operator|.
name|core
operator|=
name|core
expr_stmt|;
name|this
operator|.
name|schema
operator|=
name|schema
expr_stmt|;
name|this
operator|.
name|name
operator|=
literal|"Searcher@"
operator|+
name|Integer
operator|.
name|toHexString
argument_list|(
name|hashCode
argument_list|()
argument_list|)
operator|+
operator|(
name|name
operator|!=
literal|null
condition|?
literal|" "
operator|+
name|name
else|:
literal|""
operator|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Opening "
operator|+
name|this
operator|.
name|name
argument_list|)
expr_stmt|;
name|Directory
name|dir
init|=
name|r
operator|.
name|directory
argument_list|()
decl_stmt|;
if|if
condition|(
name|reserveDirectory
condition|)
block|{
comment|// keep the directory from being released while we use it
name|directoryFactory
operator|.
name|incRef
argument_list|(
name|dir
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dir
operator|instanceof
name|FSDirectory
condition|)
block|{
name|FSDirectory
name|fsDirectory
init|=
operator|(
name|FSDirectory
operator|)
name|dir
decl_stmt|;
name|indexDir
operator|=
name|fsDirectory
operator|.
name|getDirectory
argument_list|()
operator|.
name|getAbsolutePath
argument_list|()
expr_stmt|;
block|}
name|this
operator|.
name|closeReader
operator|=
name|closeReader
expr_stmt|;
name|setSimilarityProvider
argument_list|(
name|schema
operator|.
name|getSimilarityProvider
argument_list|()
argument_list|)
expr_stmt|;
name|SolrConfig
name|solrConfig
init|=
name|core
operator|.
name|getSolrConfig
argument_list|()
decl_stmt|;
name|queryResultWindowSize
operator|=
name|solrConfig
operator|.
name|queryResultWindowSize
expr_stmt|;
name|queryResultMaxDocsCached
operator|=
name|solrConfig
operator|.
name|queryResultMaxDocsCached
expr_stmt|;
name|useFilterForSortedQuery
operator|=
name|solrConfig
operator|.
name|useFilterForSortedQuery
expr_stmt|;
name|enableLazyFieldLoading
operator|=
name|solrConfig
operator|.
name|enableLazyFieldLoading
expr_stmt|;
name|cachingEnabled
operator|=
name|enableCache
expr_stmt|;
if|if
condition|(
name|cachingEnabled
condition|)
block|{
name|ArrayList
argument_list|<
name|SolrCache
argument_list|>
name|clist
init|=
operator|new
name|ArrayList
argument_list|<
name|SolrCache
argument_list|>
argument_list|()
decl_stmt|;
name|fieldValueCache
operator|=
name|solrConfig
operator|.
name|fieldValueCacheConfig
operator|==
literal|null
condition|?
literal|null
else|:
name|solrConfig
operator|.
name|fieldValueCacheConfig
operator|.
name|newInstance
argument_list|()
expr_stmt|;
if|if
condition|(
name|fieldValueCache
operator|!=
literal|null
condition|)
name|clist
operator|.
name|add
argument_list|(
name|fieldValueCache
argument_list|)
expr_stmt|;
name|filterCache
operator|=
name|solrConfig
operator|.
name|filterCacheConfig
operator|==
literal|null
condition|?
literal|null
else|:
name|solrConfig
operator|.
name|filterCacheConfig
operator|.
name|newInstance
argument_list|()
expr_stmt|;
if|if
condition|(
name|filterCache
operator|!=
literal|null
condition|)
name|clist
operator|.
name|add
argument_list|(
name|filterCache
argument_list|)
expr_stmt|;
name|queryResultCache
operator|=
name|solrConfig
operator|.
name|queryResultCacheConfig
operator|==
literal|null
condition|?
literal|null
else|:
name|solrConfig
operator|.
name|queryResultCacheConfig
operator|.
name|newInstance
argument_list|()
expr_stmt|;
if|if
condition|(
name|queryResultCache
operator|!=
literal|null
condition|)
name|clist
operator|.
name|add
argument_list|(
name|queryResultCache
argument_list|)
expr_stmt|;
name|documentCache
operator|=
name|solrConfig
operator|.
name|documentCacheConfig
operator|==
literal|null
condition|?
literal|null
else|:
name|solrConfig
operator|.
name|documentCacheConfig
operator|.
name|newInstance
argument_list|()
expr_stmt|;
if|if
condition|(
name|documentCache
operator|!=
literal|null
condition|)
name|clist
operator|.
name|add
argument_list|(
name|documentCache
argument_list|)
expr_stmt|;
if|if
condition|(
name|solrConfig
operator|.
name|userCacheConfigs
operator|==
literal|null
condition|)
block|{
name|cacheMap
operator|=
name|noGenericCaches
expr_stmt|;
block|}
else|else
block|{
name|cacheMap
operator|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|SolrCache
argument_list|>
argument_list|(
name|solrConfig
operator|.
name|userCacheConfigs
operator|.
name|length
argument_list|)
expr_stmt|;
for|for
control|(
name|CacheConfig
name|userCacheConfig
range|:
name|solrConfig
operator|.
name|userCacheConfigs
control|)
block|{
name|SolrCache
name|cache
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|userCacheConfig
operator|!=
literal|null
condition|)
name|cache
operator|=
name|userCacheConfig
operator|.
name|newInstance
argument_list|()
expr_stmt|;
if|if
condition|(
name|cache
operator|!=
literal|null
condition|)
block|{
name|cacheMap
operator|.
name|put
argument_list|(
name|cache
operator|.
name|name
argument_list|()
argument_list|,
name|cache
argument_list|)
expr_stmt|;
name|clist
operator|.
name|add
argument_list|(
name|cache
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|cacheList
operator|=
name|clist
operator|.
name|toArray
argument_list|(
operator|new
name|SolrCache
index|[
name|clist
operator|.
name|size
argument_list|()
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|filterCache
operator|=
literal|null
expr_stmt|;
name|queryResultCache
operator|=
literal|null
expr_stmt|;
name|documentCache
operator|=
literal|null
expr_stmt|;
name|fieldValueCache
operator|=
literal|null
expr_stmt|;
name|cacheMap
operator|=
name|noGenericCaches
expr_stmt|;
name|cacheList
operator|=
name|noCaches
expr_stmt|;
block|}
name|optimizer
operator|=
name|solrConfig
operator|.
name|filtOptEnabled
condition|?
operator|new
name|LuceneQueryOptimizer
argument_list|(
name|solrConfig
operator|.
name|filtOptCacheSize
argument_list|,
name|solrConfig
operator|.
name|filtOptThreshold
argument_list|)
else|:
literal|null
expr_stmt|;
name|fieldNames
operator|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
expr_stmt|;
for|for
control|(
name|FieldInfo
name|fieldInfo
range|:
name|ReaderUtil
operator|.
name|getMergedFieldInfos
argument_list|(
name|r
argument_list|)
control|)
block|{
name|fieldNames
operator|.
name|add
argument_list|(
name|fieldInfo
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
comment|// do this at the end since an exception in the constructor means we won't close
name|numOpens
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|name
operator|+
literal|"{"
operator|+
name|reader
operator|+
literal|"}"
return|;
block|}
DECL|method|getCore
specifier|public
name|SolrCore
name|getCore
parameter_list|()
block|{
return|return
name|core
return|;
block|}
DECL|method|maxDoc
specifier|public
specifier|final
name|int
name|maxDoc
parameter_list|()
block|{
return|return
name|reader
operator|.
name|maxDoc
argument_list|()
return|;
block|}
DECL|method|docFreq
specifier|public
specifier|final
name|int
name|docFreq
parameter_list|(
name|Term
name|term
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|reader
operator|.
name|docFreq
argument_list|(
name|term
argument_list|)
return|;
block|}
comment|/** Register sub-objects such as caches    */
DECL|method|register
specifier|public
name|void
name|register
parameter_list|()
block|{
comment|// register self
name|core
operator|.
name|getInfoRegistry
argument_list|()
operator|.
name|put
argument_list|(
literal|"searcher"
argument_list|,
name|this
argument_list|)
expr_stmt|;
name|core
operator|.
name|getInfoRegistry
argument_list|()
operator|.
name|put
argument_list|(
name|name
argument_list|,
name|this
argument_list|)
expr_stmt|;
for|for
control|(
name|SolrCache
name|cache
range|:
name|cacheList
control|)
block|{
name|cache
operator|.
name|setState
argument_list|(
name|SolrCache
operator|.
name|State
operator|.
name|LIVE
argument_list|)
expr_stmt|;
name|core
operator|.
name|getInfoRegistry
argument_list|()
operator|.
name|put
argument_list|(
name|cache
operator|.
name|name
argument_list|()
argument_list|,
name|cache
argument_list|)
expr_stmt|;
block|}
name|registerTime
operator|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
expr_stmt|;
block|}
comment|/**    * Free's resources associated with this searcher.    *    * In particular, the underlying reader and any cache's in use are closed.    */
DECL|method|close
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|cachingEnabled
condition|)
block|{
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"Closing "
argument_list|)
operator|.
name|append
argument_list|(
name|name
argument_list|)
expr_stmt|;
for|for
control|(
name|SolrCache
name|cache
range|:
name|cacheList
control|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|"\n\t"
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|cache
argument_list|)
expr_stmt|;
block|}
name|log
operator|.
name|info
argument_list|(
name|sb
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"Closing "
operator|+
name|name
argument_list|)
expr_stmt|;
block|}
name|core
operator|.
name|getInfoRegistry
argument_list|()
operator|.
name|remove
argument_list|(
name|name
argument_list|)
expr_stmt|;
comment|// super.close();
comment|// can't use super.close() since it just calls reader.close() and that may only be called once
comment|// per reader (even if incRef() was previously called).
if|if
condition|(
name|closeReader
condition|)
name|reader
operator|.
name|decRef
argument_list|()
expr_stmt|;
for|for
control|(
name|SolrCache
name|cache
range|:
name|cacheList
control|)
block|{
name|cache
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
name|directoryFactory
operator|.
name|release
argument_list|(
name|getIndexReader
argument_list|()
operator|.
name|directory
argument_list|()
argument_list|)
expr_stmt|;
comment|// do this at the end so it only gets done if there are no exceptions
name|numCloses
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
block|}
comment|/** Direct access to the IndexSchema for use with this searcher */
DECL|method|getSchema
specifier|public
name|IndexSchema
name|getSchema
parameter_list|()
block|{
return|return
name|schema
return|;
block|}
comment|/**    * Returns a collection of all field names the index reader knows about.    */
DECL|method|getFieldNames
specifier|public
name|Collection
argument_list|<
name|String
argument_list|>
name|getFieldNames
parameter_list|()
block|{
return|return
name|fieldNames
return|;
block|}
comment|/**    * Returns a collection of the names of all stored fields which can be    * highlighted the index reader knows about.    */
DECL|method|getStoredHighlightFieldNames
specifier|public
name|Collection
argument_list|<
name|String
argument_list|>
name|getStoredHighlightFieldNames
parameter_list|()
block|{
if|if
condition|(
name|storedHighlightFieldNames
operator|==
literal|null
condition|)
block|{
name|storedHighlightFieldNames
operator|=
operator|new
name|LinkedList
argument_list|<
name|String
argument_list|>
argument_list|()
expr_stmt|;
for|for
control|(
name|String
name|fieldName
range|:
name|fieldNames
control|)
block|{
try|try
block|{
name|SchemaField
name|field
init|=
name|schema
operator|.
name|getField
argument_list|(
name|fieldName
argument_list|)
decl_stmt|;
if|if
condition|(
name|field
operator|.
name|stored
argument_list|()
operator|&&
operator|(
operator|(
name|field
operator|.
name|getType
argument_list|()
operator|instanceof
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|schema
operator|.
name|TextField
operator|)
operator|||
operator|(
name|field
operator|.
name|getType
argument_list|()
operator|instanceof
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|schema
operator|.
name|StrField
operator|)
operator|)
condition|)
block|{
name|storedHighlightFieldNames
operator|.
name|add
argument_list|(
name|fieldName
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|RuntimeException
name|e
parameter_list|)
block|{
comment|// getField() throws a SolrException, but it arrives as a RuntimeException
name|log
operator|.
name|warn
argument_list|(
literal|"Field \""
operator|+
name|fieldName
operator|+
literal|"\" found in index, but not defined in schema."
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|storedHighlightFieldNames
return|;
block|}
comment|//
comment|// Set default regenerators on filter and query caches if they don't have any
comment|//
DECL|method|initRegenerators
specifier|public
specifier|static
name|void
name|initRegenerators
parameter_list|(
name|SolrConfig
name|solrConfig
parameter_list|)
block|{
if|if
condition|(
name|solrConfig
operator|.
name|fieldValueCacheConfig
operator|!=
literal|null
operator|&&
name|solrConfig
operator|.
name|fieldValueCacheConfig
operator|.
name|getRegenerator
argument_list|()
operator|==
literal|null
condition|)
block|{
name|solrConfig
operator|.
name|fieldValueCacheConfig
operator|.
name|setRegenerator
argument_list|(
operator|new
name|CacheRegenerator
argument_list|()
block|{
specifier|public
name|boolean
name|regenerateItem
parameter_list|(
name|SolrIndexSearcher
name|newSearcher
parameter_list|,
name|SolrCache
name|newCache
parameter_list|,
name|SolrCache
name|oldCache
parameter_list|,
name|Object
name|oldKey
parameter_list|,
name|Object
name|oldVal
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|oldVal
operator|instanceof
name|UnInvertedField
condition|)
block|{
name|UnInvertedField
operator|.
name|getUnInvertedField
argument_list|(
operator|(
name|String
operator|)
name|oldKey
argument_list|,
name|newSearcher
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|solrConfig
operator|.
name|filterCacheConfig
operator|!=
literal|null
operator|&&
name|solrConfig
operator|.
name|filterCacheConfig
operator|.
name|getRegenerator
argument_list|()
operator|==
literal|null
condition|)
block|{
name|solrConfig
operator|.
name|filterCacheConfig
operator|.
name|setRegenerator
argument_list|(
operator|new
name|CacheRegenerator
argument_list|()
block|{
specifier|public
name|boolean
name|regenerateItem
parameter_list|(
name|SolrIndexSearcher
name|newSearcher
parameter_list|,
name|SolrCache
name|newCache
parameter_list|,
name|SolrCache
name|oldCache
parameter_list|,
name|Object
name|oldKey
parameter_list|,
name|Object
name|oldVal
parameter_list|)
throws|throws
name|IOException
block|{
name|newSearcher
operator|.
name|cacheDocSet
argument_list|(
operator|(
name|Query
operator|)
name|oldKey
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|solrConfig
operator|.
name|queryResultCacheConfig
operator|!=
literal|null
operator|&&
name|solrConfig
operator|.
name|queryResultCacheConfig
operator|.
name|getRegenerator
argument_list|()
operator|==
literal|null
condition|)
block|{
specifier|final
name|int
name|queryResultWindowSize
init|=
name|solrConfig
operator|.
name|queryResultWindowSize
decl_stmt|;
name|solrConfig
operator|.
name|queryResultCacheConfig
operator|.
name|setRegenerator
argument_list|(
operator|new
name|CacheRegenerator
argument_list|()
block|{
specifier|public
name|boolean
name|regenerateItem
parameter_list|(
name|SolrIndexSearcher
name|newSearcher
parameter_list|,
name|SolrCache
name|newCache
parameter_list|,
name|SolrCache
name|oldCache
parameter_list|,
name|Object
name|oldKey
parameter_list|,
name|Object
name|oldVal
parameter_list|)
throws|throws
name|IOException
block|{
name|QueryResultKey
name|key
init|=
operator|(
name|QueryResultKey
operator|)
name|oldKey
decl_stmt|;
name|int
name|nDocs
init|=
literal|1
decl_stmt|;
comment|// request 1 doc and let caching round up to the next window size...
comment|// unless the window size is<=1, in which case we will pick
comment|// the minimum of the number of documents requested last time and
comment|// a reasonable number such as 40.
comment|// TODO: make more configurable later...
if|if
condition|(
name|queryResultWindowSize
operator|<=
literal|1
condition|)
block|{
name|DocList
name|oldList
init|=
operator|(
name|DocList
operator|)
name|oldVal
decl_stmt|;
name|int
name|oldnDocs
init|=
name|oldList
operator|.
name|offset
argument_list|()
operator|+
name|oldList
operator|.
name|size
argument_list|()
decl_stmt|;
comment|// 40 has factors of 2,4,5,10,20
name|nDocs
operator|=
name|Math
operator|.
name|min
argument_list|(
name|oldnDocs
argument_list|,
literal|40
argument_list|)
expr_stmt|;
block|}
name|int
name|flags
init|=
name|NO_CHECK_QCACHE
operator||
name|key
operator|.
name|nc_flags
decl_stmt|;
name|QueryCommand
name|qc
init|=
operator|new
name|QueryCommand
argument_list|()
decl_stmt|;
name|qc
operator|.
name|setQuery
argument_list|(
name|key
operator|.
name|query
argument_list|)
operator|.
name|setFilterList
argument_list|(
name|key
operator|.
name|filters
argument_list|)
operator|.
name|setSort
argument_list|(
name|key
operator|.
name|sort
argument_list|)
operator|.
name|setLen
argument_list|(
name|nDocs
argument_list|)
operator|.
name|setSupersetMaxDoc
argument_list|(
name|nDocs
argument_list|)
operator|.
name|setFlags
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|QueryResult
name|qr
init|=
operator|new
name|QueryResult
argument_list|()
decl_stmt|;
name|newSearcher
operator|.
name|getDocListC
argument_list|(
name|qr
argument_list|,
name|qc
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|search
specifier|public
name|QueryResult
name|search
parameter_list|(
name|QueryResult
name|qr
parameter_list|,
name|QueryCommand
name|cmd
parameter_list|)
throws|throws
name|IOException
block|{
name|getDocListC
argument_list|(
name|qr
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
return|return
name|qr
return|;
block|}
comment|//  public Hits search(Query query, Filter filter, Sort sort) throws IOException {
comment|//    // todo - when Solr starts accepting filters, need to
comment|//    // change this conditional check (filter!=null) and create a new filter
comment|//    // that ANDs them together if it already exists.
comment|//
comment|//    if (optimizer==null || filter!=null || !(query instanceof BooleanQuery)
comment|//    ) {
comment|//      return super.search(query,filter,sort);
comment|//    } else {
comment|//      Query[] newQuery = new Query[1];
comment|//      Filter[] newFilter = new Filter[1];
comment|//      optimizer.optimize((BooleanQuery)query, this, 0, newQuery, newFilter);
comment|//
comment|//      return super.search(newQuery[0], newFilter[0], sort);
comment|//    }
comment|//  }
comment|/**    * @return the indexDir on which this searcher is opened    */
DECL|method|getIndexDir
specifier|public
name|String
name|getIndexDir
parameter_list|()
block|{
return|return
name|indexDir
return|;
block|}
comment|/* ********************** Document retrieval *************************/
comment|/* Future optimizations (yonik)    *    * If no cache is present:    *   - use NO_LOAD instead of LAZY_LOAD    *   - use LOAD_AND_BREAK if a single field is begin retrieved    */
comment|/**    * FieldSelector which loads the specified fields, and load all other    * field lazily.    */
comment|// TODO: can we just subclass DocumentStoredFieldVisitor?
comment|// need to open up access to its Document...
DECL|class|SetNonLazyFieldSelector
specifier|static
class|class
name|SetNonLazyFieldSelector
extends|extends
name|StoredFieldVisitor
block|{
DECL|field|fieldsToLoad
specifier|private
name|Set
argument_list|<
name|String
argument_list|>
name|fieldsToLoad
decl_stmt|;
DECL|field|doc
specifier|final
name|Document
name|doc
init|=
operator|new
name|Document
argument_list|()
decl_stmt|;
DECL|field|lazyDoc
specifier|final
name|LazyDocument
name|lazyDoc
decl_stmt|;
DECL|method|SetNonLazyFieldSelector
name|SetNonLazyFieldSelector
parameter_list|(
name|Set
argument_list|<
name|String
argument_list|>
name|toLoad
parameter_list|,
name|IndexReader
name|reader
parameter_list|,
name|int
name|docID
parameter_list|)
block|{
name|fieldsToLoad
operator|=
name|toLoad
expr_stmt|;
name|lazyDoc
operator|=
operator|new
name|LazyDocument
argument_list|(
name|reader
argument_list|,
name|docID
argument_list|)
expr_stmt|;
block|}
DECL|method|needsField
specifier|public
name|Status
name|needsField
parameter_list|(
name|FieldInfo
name|fieldInfo
parameter_list|)
block|{
if|if
condition|(
name|fieldsToLoad
operator|.
name|contains
argument_list|(
name|fieldInfo
operator|.
name|name
argument_list|)
condition|)
block|{
return|return
name|Status
operator|.
name|YES
return|;
block|}
else|else
block|{
name|doc
operator|.
name|add
argument_list|(
name|lazyDoc
operator|.
name|getField
argument_list|(
name|fieldInfo
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|Status
operator|.
name|NO
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|binaryField
specifier|public
name|void
name|binaryField
parameter_list|(
name|FieldInfo
name|fieldInfo
parameter_list|,
name|byte
index|[]
name|value
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|)
throws|throws
name|IOException
block|{
name|doc
operator|.
name|add
argument_list|(
operator|new
name|BinaryField
argument_list|(
name|fieldInfo
operator|.
name|name
argument_list|,
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|stringField
specifier|public
name|void
name|stringField
parameter_list|(
name|FieldInfo
name|fieldInfo
parameter_list|,
name|String
name|value
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|FieldType
name|ft
init|=
operator|new
name|FieldType
argument_list|(
name|TextField
operator|.
name|TYPE_STORED
argument_list|)
decl_stmt|;
name|ft
operator|.
name|setStoreTermVectors
argument_list|(
name|fieldInfo
operator|.
name|storeTermVector
argument_list|)
expr_stmt|;
name|ft
operator|.
name|setStoreTermVectors
argument_list|(
name|fieldInfo
operator|.
name|storeTermVector
argument_list|)
expr_stmt|;
name|ft
operator|.
name|setIndexed
argument_list|(
name|fieldInfo
operator|.
name|isIndexed
argument_list|)
expr_stmt|;
name|ft
operator|.
name|setOmitNorms
argument_list|(
name|fieldInfo
operator|.
name|omitNorms
argument_list|)
expr_stmt|;
name|ft
operator|.
name|setIndexOptions
argument_list|(
name|fieldInfo
operator|.
name|indexOptions
argument_list|)
expr_stmt|;
name|doc
operator|.
name|add
argument_list|(
operator|new
name|Field
argument_list|(
name|fieldInfo
operator|.
name|name
argument_list|,
name|value
argument_list|,
name|ft
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|intField
specifier|public
name|void
name|intField
parameter_list|(
name|FieldInfo
name|fieldInfo
parameter_list|,
name|int
name|value
parameter_list|)
block|{
name|FieldType
name|ft
init|=
operator|new
name|FieldType
argument_list|(
name|NumericField
operator|.
name|TYPE_STORED
argument_list|)
decl_stmt|;
name|ft
operator|.
name|setIndexed
argument_list|(
name|fieldInfo
operator|.
name|isIndexed
argument_list|)
expr_stmt|;
name|doc
operator|.
name|add
argument_list|(
operator|new
name|NumericField
argument_list|(
name|fieldInfo
operator|.
name|name
argument_list|,
name|ft
argument_list|)
operator|.
name|setIntValue
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|longField
specifier|public
name|void
name|longField
parameter_list|(
name|FieldInfo
name|fieldInfo
parameter_list|,
name|long
name|value
parameter_list|)
block|{
name|FieldType
name|ft
init|=
operator|new
name|FieldType
argument_list|(
name|NumericField
operator|.
name|TYPE_STORED
argument_list|)
decl_stmt|;
name|ft
operator|.
name|setIndexed
argument_list|(
name|fieldInfo
operator|.
name|isIndexed
argument_list|)
expr_stmt|;
name|doc
operator|.
name|add
argument_list|(
operator|new
name|NumericField
argument_list|(
name|fieldInfo
operator|.
name|name
argument_list|,
name|ft
argument_list|)
operator|.
name|setLongValue
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|floatField
specifier|public
name|void
name|floatField
parameter_list|(
name|FieldInfo
name|fieldInfo
parameter_list|,
name|float
name|value
parameter_list|)
block|{
name|FieldType
name|ft
init|=
operator|new
name|FieldType
argument_list|(
name|NumericField
operator|.
name|TYPE_STORED
argument_list|)
decl_stmt|;
name|ft
operator|.
name|setIndexed
argument_list|(
name|fieldInfo
operator|.
name|isIndexed
argument_list|)
expr_stmt|;
name|doc
operator|.
name|add
argument_list|(
operator|new
name|NumericField
argument_list|(
name|fieldInfo
operator|.
name|name
argument_list|,
name|ft
argument_list|)
operator|.
name|setFloatValue
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|doubleField
specifier|public
name|void
name|doubleField
parameter_list|(
name|FieldInfo
name|fieldInfo
parameter_list|,
name|double
name|value
parameter_list|)
block|{
name|FieldType
name|ft
init|=
operator|new
name|FieldType
argument_list|(
name|NumericField
operator|.
name|TYPE_STORED
argument_list|)
decl_stmt|;
name|ft
operator|.
name|setIndexed
argument_list|(
name|fieldInfo
operator|.
name|isIndexed
argument_list|)
expr_stmt|;
name|doc
operator|.
name|add
argument_list|(
operator|new
name|NumericField
argument_list|(
name|fieldInfo
operator|.
name|name
argument_list|,
name|ft
argument_list|)
operator|.
name|setDoubleValue
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Retrieve the {@link Document} instance corresponding to the document id.    */
annotation|@
name|Override
DECL|method|doc
specifier|public
name|Document
name|doc
parameter_list|(
name|int
name|i
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|doc
argument_list|(
name|i
argument_list|,
operator|(
name|Set
argument_list|<
name|String
argument_list|>
operator|)
literal|null
argument_list|)
return|;
block|}
comment|/** Visit a document's fields using a {@link StoredFieldVisitor}    *  This method does not currently use the Solr document cache.    *     * @see IndexReader#document(int, StoredFieldVisitor) */
annotation|@
name|Override
DECL|method|doc
specifier|public
name|void
name|doc
parameter_list|(
name|int
name|n
parameter_list|,
name|StoredFieldVisitor
name|visitor
parameter_list|)
throws|throws
name|IOException
block|{
name|getIndexReader
argument_list|()
operator|.
name|document
argument_list|(
name|n
argument_list|,
name|visitor
argument_list|)
expr_stmt|;
block|}
comment|/**    * Retrieve the {@link Document} instance corresponding to the document id.    *    * Note: The document will have all fields accessable, but if a field    * filter is provided, only the provided fields will be loaded (the     * remainder will be available lazily).    */
DECL|method|doc
specifier|public
name|Document
name|doc
parameter_list|(
name|int
name|i
parameter_list|,
name|Set
argument_list|<
name|String
argument_list|>
name|fields
parameter_list|)
throws|throws
name|IOException
block|{
name|Document
name|d
decl_stmt|;
if|if
condition|(
name|documentCache
operator|!=
literal|null
condition|)
block|{
name|d
operator|=
name|documentCache
operator|.
name|get
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|!=
literal|null
condition|)
return|return
name|d
return|;
block|}
if|if
condition|(
operator|!
name|enableLazyFieldLoading
operator|||
name|fields
operator|==
literal|null
condition|)
block|{
name|d
operator|=
name|getIndexReader
argument_list|()
operator|.
name|document
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|final
name|SetNonLazyFieldSelector
name|visitor
init|=
operator|new
name|SetNonLazyFieldSelector
argument_list|(
name|fields
argument_list|,
name|getIndexReader
argument_list|()
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|getIndexReader
argument_list|()
operator|.
name|document
argument_list|(
name|i
argument_list|,
name|visitor
argument_list|)
expr_stmt|;
name|d
operator|=
name|visitor
operator|.
name|doc
expr_stmt|;
block|}
if|if
condition|(
name|documentCache
operator|!=
literal|null
condition|)
block|{
name|documentCache
operator|.
name|put
argument_list|(
name|i
argument_list|,
name|d
argument_list|)
expr_stmt|;
block|}
return|return
name|d
return|;
block|}
comment|/**    * Takes a list of docs (the doc ids actually), and reads them into an array     * of Documents.    */
DECL|method|readDocs
specifier|public
name|void
name|readDocs
parameter_list|(
name|Document
index|[]
name|docs
parameter_list|,
name|DocList
name|ids
parameter_list|)
throws|throws
name|IOException
block|{
name|readDocs
argument_list|(
name|docs
argument_list|,
name|ids
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/**    * Takes a list of docs (the doc ids actually) and a set of fields to load,    * and reads them into an array of Documents.    */
DECL|method|readDocs
specifier|public
name|void
name|readDocs
parameter_list|(
name|Document
index|[]
name|docs
parameter_list|,
name|DocList
name|ids
parameter_list|,
name|Set
argument_list|<
name|String
argument_list|>
name|fields
parameter_list|)
throws|throws
name|IOException
block|{
name|DocIterator
name|iter
init|=
name|ids
operator|.
name|iterator
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|docs
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|docs
index|[
name|i
index|]
operator|=
name|doc
argument_list|(
name|iter
operator|.
name|nextDoc
argument_list|()
argument_list|,
name|fields
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* ********************** end document retrieval *************************/
comment|////////////////////////////////////////////////////////////////////////////////
comment|////////////////////////////////////////////////////////////////////////////////
comment|////////////////////////////////////////////////////////////////////////////////
comment|/** expert: internal API, subject to change */
DECL|method|getFieldValueCache
specifier|public
name|SolrCache
argument_list|<
name|String
argument_list|,
name|UnInvertedField
argument_list|>
name|getFieldValueCache
parameter_list|()
block|{
return|return
name|fieldValueCache
return|;
block|}
comment|/** Returns a weighted sort according to this searcher */
DECL|method|weightSort
specifier|public
name|Sort
name|weightSort
parameter_list|(
name|Sort
name|sort
parameter_list|)
throws|throws
name|IOException
block|{
return|return
operator|(
name|sort
operator|!=
literal|null
operator|)
condition|?
name|sort
operator|.
name|rewrite
argument_list|(
name|this
argument_list|)
else|:
literal|null
return|;
block|}
comment|/**    * Returns the first document number containing the term<code>t</code>    * Returns -1 if no document was found.    * This method is primarily intended for clients that want to fetch    * documents using a unique identifier."    * @param t    * @return the first document number containing the term    */
DECL|method|getFirstMatch
specifier|public
name|int
name|getFirstMatch
parameter_list|(
name|Term
name|t
parameter_list|)
throws|throws
name|IOException
block|{
name|Fields
name|fields
init|=
name|MultiFields
operator|.
name|getFields
argument_list|(
name|reader
argument_list|)
decl_stmt|;
if|if
condition|(
name|fields
operator|==
literal|null
condition|)
return|return
operator|-
literal|1
return|;
name|Terms
name|terms
init|=
name|fields
operator|.
name|terms
argument_list|(
name|t
operator|.
name|field
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|terms
operator|==
literal|null
condition|)
return|return
operator|-
literal|1
return|;
name|BytesRef
name|termBytes
init|=
name|t
operator|.
name|bytes
argument_list|()
decl_stmt|;
specifier|final
name|TermsEnum
name|termsEnum
init|=
name|terms
operator|.
name|iterator
argument_list|(
literal|null
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|termsEnum
operator|.
name|seekExact
argument_list|(
name|termBytes
argument_list|,
literal|false
argument_list|)
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
name|DocsEnum
name|docs
init|=
name|termsEnum
operator|.
name|docs
argument_list|(
name|MultiFields
operator|.
name|getLiveDocs
argument_list|(
name|reader
argument_list|)
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|docs
operator|==
literal|null
condition|)
return|return
operator|-
literal|1
return|;
name|int
name|id
init|=
name|docs
operator|.
name|nextDoc
argument_list|()
decl_stmt|;
return|return
name|id
operator|==
name|DocIdSetIterator
operator|.
name|NO_MORE_DOCS
condition|?
operator|-
literal|1
else|:
name|id
return|;
block|}
comment|/**    * Compute and cache the DocSet that matches a query.    * The normal usage is expected to be cacheDocSet(myQuery, null,false)    * meaning that Solr will determine if the Query warrants caching, and    * if so, will compute the DocSet that matches the Query and cache it.    * If the answer to the query is already cached, nothing further will be done.    *<p>    * If the optionalAnswer DocSet is provided, it should *not* be modified    * after this call.    *    * @param query           the lucene query that will act as the key    * @param optionalAnswer   the DocSet to be cached - if null, it will be computed.    * @param mustCache        if true, a best effort will be made to cache this entry.    *                         if false, heuristics may be used to determine if it should be cached.    */
DECL|method|cacheDocSet
specifier|public
name|void
name|cacheDocSet
parameter_list|(
name|Query
name|query
parameter_list|,
name|DocSet
name|optionalAnswer
parameter_list|,
name|boolean
name|mustCache
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Even if the cache is null, still compute the DocSet as it may serve to warm the Lucene
comment|// or OS disk cache.
if|if
condition|(
name|optionalAnswer
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|filterCache
operator|!=
literal|null
condition|)
block|{
name|filterCache
operator|.
name|put
argument_list|(
name|query
argument_list|,
name|optionalAnswer
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
comment|// Throw away the result, relying on the fact that getDocSet
comment|// will currently always cache what it found.  If getDocSet() starts
comment|// using heuristics about what to cache, and mustCache==true, (or if we
comment|// want this method to start using heuristics too) then
comment|// this needs to change.
name|getDocSet
argument_list|(
name|query
argument_list|)
expr_stmt|;
block|}
comment|/**    * Returns the set of document ids matching a query.    * This method is cache-aware and attempts to retrieve the answer from the cache if possible.    * If the answer was not cached, it may have been inserted into the cache as a result of this call.    * This method can handle negative queries.    *<p>    * The DocSet returned should<b>not</b> be modified.    */
DECL|method|getDocSet
specifier|public
name|DocSet
name|getDocSet
parameter_list|(
name|Query
name|query
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|query
operator|instanceof
name|ExtendedQuery
condition|)
block|{
name|ExtendedQuery
name|eq
init|=
operator|(
name|ExtendedQuery
operator|)
name|query
decl_stmt|;
if|if
condition|(
operator|!
name|eq
operator|.
name|getCache
argument_list|()
condition|)
block|{
if|if
condition|(
name|query
operator|instanceof
name|WrappedQuery
condition|)
block|{
name|query
operator|=
operator|(
operator|(
name|WrappedQuery
operator|)
name|query
operator|)
operator|.
name|getWrappedQuery
argument_list|()
expr_stmt|;
block|}
name|query
operator|=
name|QueryUtils
operator|.
name|makeQueryable
argument_list|(
name|query
argument_list|)
expr_stmt|;
return|return
name|getDocSetNC
argument_list|(
name|query
argument_list|,
literal|null
argument_list|)
return|;
block|}
block|}
comment|// Get the absolute value (positive version) of this query.  If we
comment|// get back the same reference, we know it's positive.
name|Query
name|absQ
init|=
name|QueryUtils
operator|.
name|getAbs
argument_list|(
name|query
argument_list|)
decl_stmt|;
name|boolean
name|positive
init|=
name|query
operator|==
name|absQ
decl_stmt|;
if|if
condition|(
name|filterCache
operator|!=
literal|null
condition|)
block|{
name|DocSet
name|absAnswer
init|=
name|filterCache
operator|.
name|get
argument_list|(
name|absQ
argument_list|)
decl_stmt|;
if|if
condition|(
name|absAnswer
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|positive
condition|)
return|return
name|absAnswer
return|;
else|else
return|return
name|getPositiveDocSet
argument_list|(
name|matchAllDocsQuery
argument_list|)
operator|.
name|andNot
argument_list|(
name|absAnswer
argument_list|)
return|;
block|}
block|}
name|DocSet
name|absAnswer
init|=
name|getDocSetNC
argument_list|(
name|absQ
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|DocSet
name|answer
init|=
name|positive
condition|?
name|absAnswer
else|:
name|getPositiveDocSet
argument_list|(
name|matchAllDocsQuery
argument_list|)
operator|.
name|andNot
argument_list|(
name|absAnswer
argument_list|)
decl_stmt|;
if|if
condition|(
name|filterCache
operator|!=
literal|null
condition|)
block|{
comment|// cache negative queries as positive
name|filterCache
operator|.
name|put
argument_list|(
name|absQ
argument_list|,
name|absAnswer
argument_list|)
expr_stmt|;
block|}
return|return
name|answer
return|;
block|}
comment|// only handle positive (non negative) queries
DECL|method|getPositiveDocSet
name|DocSet
name|getPositiveDocSet
parameter_list|(
name|Query
name|q
parameter_list|)
throws|throws
name|IOException
block|{
name|DocSet
name|answer
decl_stmt|;
if|if
condition|(
name|filterCache
operator|!=
literal|null
condition|)
block|{
name|answer
operator|=
name|filterCache
operator|.
name|get
argument_list|(
name|q
argument_list|)
expr_stmt|;
if|if
condition|(
name|answer
operator|!=
literal|null
condition|)
return|return
name|answer
return|;
block|}
name|answer
operator|=
name|getDocSetNC
argument_list|(
name|q
argument_list|,
literal|null
argument_list|)
expr_stmt|;
if|if
condition|(
name|filterCache
operator|!=
literal|null
condition|)
name|filterCache
operator|.
name|put
argument_list|(
name|q
argument_list|,
name|answer
argument_list|)
expr_stmt|;
return|return
name|answer
return|;
block|}
DECL|field|matchAllDocsQuery
specifier|private
specifier|static
name|Query
name|matchAllDocsQuery
init|=
operator|new
name|MatchAllDocsQuery
argument_list|()
decl_stmt|;
DECL|class|ProcessedFilter
specifier|public
specifier|static
class|class
name|ProcessedFilter
block|{
DECL|field|answer
specifier|public
name|DocSet
name|answer
decl_stmt|;
comment|// the answer, if non-null
DECL|field|filter
specifier|public
name|Filter
name|filter
decl_stmt|;
DECL|field|postFilter
specifier|public
name|DelegatingCollector
name|postFilter
decl_stmt|;
block|}
DECL|field|sortByCost
specifier|private
specifier|static
name|Comparator
argument_list|<
name|Query
argument_list|>
name|sortByCost
init|=
operator|new
name|Comparator
argument_list|<
name|Query
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|int
name|compare
parameter_list|(
name|Query
name|q1
parameter_list|,
name|Query
name|q2
parameter_list|)
block|{
return|return
operator|(
operator|(
name|ExtendedQuery
operator|)
name|q1
operator|)
operator|.
name|getCost
argument_list|()
operator|-
operator|(
operator|(
name|ExtendedQuery
operator|)
name|q2
operator|)
operator|.
name|getCost
argument_list|()
return|;
block|}
block|}
decl_stmt|;
comment|/**    * Returns the set of document ids matching all queries.    * This method is cache-aware and attempts to retrieve the answer from the cache if possible.    * If the answer was not cached, it may have been inserted into the cache as a result of this call.    * This method can handle negative queries.    *<p>    * The DocSet returned should<b>not</b> be modified.    */
DECL|method|getDocSet
specifier|public
name|DocSet
name|getDocSet
parameter_list|(
name|List
argument_list|<
name|Query
argument_list|>
name|queries
parameter_list|)
throws|throws
name|IOException
block|{
name|ProcessedFilter
name|pf
init|=
name|getProcessedFilter
argument_list|(
literal|null
argument_list|,
name|queries
argument_list|)
decl_stmt|;
if|if
condition|(
name|pf
operator|.
name|answer
operator|!=
literal|null
condition|)
return|return
name|pf
operator|.
name|answer
return|;
name|DocSetCollector
name|setCollector
init|=
operator|new
name|DocSetCollector
argument_list|(
name|maxDoc
argument_list|()
operator|>>
literal|6
argument_list|,
name|maxDoc
argument_list|()
argument_list|)
decl_stmt|;
name|Collector
name|collector
init|=
name|setCollector
decl_stmt|;
if|if
condition|(
name|pf
operator|.
name|postFilter
operator|!=
literal|null
condition|)
block|{
name|pf
operator|.
name|postFilter
operator|.
name|setLastDelegate
argument_list|(
name|collector
argument_list|)
expr_stmt|;
name|collector
operator|=
name|pf
operator|.
name|postFilter
expr_stmt|;
block|}
specifier|final
name|AtomicReaderContext
index|[]
name|leaves
init|=
name|leafContexts
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|leaves
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|AtomicReaderContext
name|leaf
init|=
name|leaves
index|[
name|i
index|]
decl_stmt|;
specifier|final
name|IndexReader
name|reader
init|=
name|leaf
operator|.
name|reader
decl_stmt|;
specifier|final
name|Bits
name|liveDocs
init|=
name|reader
operator|.
name|getLiveDocs
argument_list|()
decl_stmt|;
comment|// TODO: the filter may already only have liveDocs...
name|DocIdSet
name|idSet
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|pf
operator|.
name|filter
operator|!=
literal|null
condition|)
block|{
name|idSet
operator|=
name|pf
operator|.
name|filter
operator|.
name|getDocIdSet
argument_list|(
name|leaf
argument_list|,
name|liveDocs
argument_list|)
expr_stmt|;
if|if
condition|(
name|idSet
operator|==
literal|null
condition|)
continue|continue;
block|}
name|DocIdSetIterator
name|idIter
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|idSet
operator|!=
literal|null
condition|)
block|{
name|idIter
operator|=
name|idSet
operator|.
name|iterator
argument_list|()
expr_stmt|;
if|if
condition|(
name|idIter
operator|==
literal|null
condition|)
continue|continue;
block|}
name|collector
operator|.
name|setNextReader
argument_list|(
name|leaf
argument_list|)
expr_stmt|;
name|int
name|max
init|=
name|reader
operator|.
name|maxDoc
argument_list|()
decl_stmt|;
if|if
condition|(
name|idIter
operator|==
literal|null
condition|)
block|{
for|for
control|(
name|int
name|docid
init|=
literal|0
init|;
name|docid
operator|<
name|max
condition|;
name|docid
operator|++
control|)
block|{
if|if
condition|(
name|liveDocs
operator|!=
literal|null
operator|&&
operator|!
name|liveDocs
operator|.
name|get
argument_list|(
name|docid
argument_list|)
condition|)
continue|continue;
name|collector
operator|.
name|collect
argument_list|(
name|docid
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|int
name|docid
init|=
operator|-
literal|1
init|;
operator|(
name|docid
operator|=
name|idIter
operator|.
name|advance
argument_list|(
name|docid
operator|+
literal|1
argument_list|)
operator|)
operator|<
name|max
condition|;
control|)
block|{
name|collector
operator|.
name|collect
argument_list|(
name|docid
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|setCollector
operator|.
name|getDocSet
argument_list|()
return|;
block|}
DECL|method|getProcessedFilter
specifier|public
name|ProcessedFilter
name|getProcessedFilter
parameter_list|(
name|DocSet
name|setFilter
parameter_list|,
name|List
argument_list|<
name|Query
argument_list|>
name|queries
parameter_list|)
throws|throws
name|IOException
block|{
name|ProcessedFilter
name|pf
init|=
operator|new
name|ProcessedFilter
argument_list|()
decl_stmt|;
if|if
condition|(
name|queries
operator|==
literal|null
operator|||
name|queries
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|setFilter
operator|!=
literal|null
condition|)
name|pf
operator|.
name|filter
operator|=
name|setFilter
operator|.
name|getTopFilter
argument_list|()
expr_stmt|;
return|return
name|pf
return|;
block|}
name|DocSet
name|answer
init|=
literal|null
decl_stmt|;
name|boolean
index|[]
name|neg
init|=
operator|new
name|boolean
index|[
name|queries
operator|.
name|size
argument_list|()
operator|+
literal|1
index|]
decl_stmt|;
name|DocSet
index|[]
name|sets
init|=
operator|new
name|DocSet
index|[
name|queries
operator|.
name|size
argument_list|()
operator|+
literal|1
index|]
decl_stmt|;
name|List
argument_list|<
name|Query
argument_list|>
name|notCached
init|=
literal|null
decl_stmt|;
name|List
argument_list|<
name|Query
argument_list|>
name|postFilters
init|=
literal|null
decl_stmt|;
name|int
name|end
init|=
literal|0
decl_stmt|;
name|int
name|smallestIndex
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|setFilter
operator|!=
literal|null
condition|)
block|{
name|answer
operator|=
name|sets
index|[
name|end
operator|++
index|]
operator|=
name|setFilter
expr_stmt|;
name|smallestIndex
operator|=
name|end
expr_stmt|;
block|}
name|int
name|smallestCount
init|=
name|Integer
operator|.
name|MAX_VALUE
decl_stmt|;
for|for
control|(
name|Query
name|q
range|:
name|queries
control|)
block|{
if|if
condition|(
name|q
operator|instanceof
name|ExtendedQuery
condition|)
block|{
name|ExtendedQuery
name|eq
init|=
operator|(
name|ExtendedQuery
operator|)
name|q
decl_stmt|;
if|if
condition|(
operator|!
name|eq
operator|.
name|getCache
argument_list|()
condition|)
block|{
if|if
condition|(
name|eq
operator|.
name|getCost
argument_list|()
operator|>=
literal|100
operator|&&
name|eq
operator|instanceof
name|PostFilter
condition|)
block|{
if|if
condition|(
name|postFilters
operator|==
literal|null
condition|)
name|postFilters
operator|=
operator|new
name|ArrayList
argument_list|<
name|Query
argument_list|>
argument_list|(
name|sets
operator|.
name|length
operator|-
name|end
argument_list|)
expr_stmt|;
name|postFilters
operator|.
name|add
argument_list|(
name|q
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|notCached
operator|==
literal|null
condition|)
name|notCached
operator|=
operator|new
name|ArrayList
argument_list|<
name|Query
argument_list|>
argument_list|(
name|sets
operator|.
name|length
operator|-
name|end
argument_list|)
expr_stmt|;
name|notCached
operator|.
name|add
argument_list|(
name|q
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
block|}
name|Query
name|posQuery
init|=
name|QueryUtils
operator|.
name|getAbs
argument_list|(
name|q
argument_list|)
decl_stmt|;
name|sets
index|[
name|end
index|]
operator|=
name|getPositiveDocSet
argument_list|(
name|posQuery
argument_list|)
expr_stmt|;
comment|// Negative query if absolute value different from original
if|if
condition|(
name|q
operator|==
name|posQuery
condition|)
block|{
name|neg
index|[
name|end
index|]
operator|=
literal|false
expr_stmt|;
comment|// keep track of the smallest positive set.
comment|// This optimization is only worth it if size() is cached, which it would
comment|// be if we don't do any set operations.
name|int
name|sz
init|=
name|sets
index|[
name|end
index|]
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|sz
operator|<
name|smallestCount
condition|)
block|{
name|smallestCount
operator|=
name|sz
expr_stmt|;
name|smallestIndex
operator|=
name|end
expr_stmt|;
name|answer
operator|=
name|sets
index|[
name|end
index|]
expr_stmt|;
block|}
block|}
else|else
block|{
name|neg
index|[
name|end
index|]
operator|=
literal|true
expr_stmt|;
block|}
name|end
operator|++
expr_stmt|;
block|}
comment|// Are all of our normal cached filters negative?
if|if
condition|(
name|end
operator|>
literal|0
operator|&&
name|answer
operator|==
literal|null
condition|)
block|{
name|answer
operator|=
name|getPositiveDocSet
argument_list|(
name|matchAllDocsQuery
argument_list|)
expr_stmt|;
block|}
comment|// do negative queries first to shrink set size
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|end
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|neg
index|[
name|i
index|]
condition|)
name|answer
operator|=
name|answer
operator|.
name|andNot
argument_list|(
name|sets
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|end
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|neg
index|[
name|i
index|]
operator|&&
name|i
operator|!=
name|smallestIndex
condition|)
name|answer
operator|=
name|answer
operator|.
name|intersection
argument_list|(
name|sets
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|notCached
operator|!=
literal|null
condition|)
block|{
name|Collections
operator|.
name|sort
argument_list|(
name|notCached
argument_list|,
name|sortByCost
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|Weight
argument_list|>
name|weights
init|=
operator|new
name|ArrayList
argument_list|<
name|Weight
argument_list|>
argument_list|(
name|notCached
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|Query
name|q
range|:
name|notCached
control|)
block|{
name|Query
name|qq
init|=
name|QueryUtils
operator|.
name|makeQueryable
argument_list|(
name|q
argument_list|)
decl_stmt|;
name|weights
operator|.
name|add
argument_list|(
name|createNormalizedWeight
argument_list|(
name|qq
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|pf
operator|.
name|filter
operator|=
operator|new
name|FilterImpl
argument_list|(
name|answer
argument_list|,
name|weights
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|postFilters
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|answer
operator|==
literal|null
condition|)
block|{
name|answer
operator|=
name|getPositiveDocSet
argument_list|(
name|matchAllDocsQuery
argument_list|)
expr_stmt|;
block|}
comment|// "answer" is the only part of the filter, so set it.
name|pf
operator|.
name|answer
operator|=
name|answer
expr_stmt|;
block|}
if|if
condition|(
name|answer
operator|!=
literal|null
condition|)
block|{
name|pf
operator|.
name|filter
operator|=
name|answer
operator|.
name|getTopFilter
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|postFilters
operator|!=
literal|null
condition|)
block|{
name|Collections
operator|.
name|sort
argument_list|(
name|postFilters
argument_list|,
name|sortByCost
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
name|postFilters
operator|.
name|size
argument_list|()
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|DelegatingCollector
name|prev
init|=
name|pf
operator|.
name|postFilter
decl_stmt|;
name|pf
operator|.
name|postFilter
operator|=
operator|(
operator|(
name|PostFilter
operator|)
name|postFilters
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|)
operator|.
name|getFilterCollector
argument_list|(
name|this
argument_list|)
expr_stmt|;
if|if
condition|(
name|prev
operator|!=
literal|null
condition|)
name|pf
operator|.
name|postFilter
operator|.
name|setDelegate
argument_list|(
name|prev
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|pf
return|;
block|}
comment|/** lucene.internal */
DECL|method|getDocSet
specifier|public
name|DocSet
name|getDocSet
parameter_list|(
name|DocsEnumState
name|deState
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|largestPossible
init|=
name|deState
operator|.
name|termsEnum
operator|.
name|docFreq
argument_list|()
decl_stmt|;
name|boolean
name|useCache
init|=
name|filterCache
operator|!=
literal|null
operator|&&
name|largestPossible
operator|>=
name|deState
operator|.
name|minSetSizeCached
decl_stmt|;
name|TermQuery
name|key
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|useCache
condition|)
block|{
name|key
operator|=
operator|new
name|TermQuery
argument_list|(
operator|new
name|Term
argument_list|(
name|deState
operator|.
name|fieldName
argument_list|,
name|BytesRef
operator|.
name|deepCopyOf
argument_list|(
name|deState
operator|.
name|termsEnum
operator|.
name|term
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|DocSet
name|result
init|=
name|filterCache
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|!=
literal|null
condition|)
return|return
name|result
return|;
block|}
name|int
name|smallSetSize
init|=
name|maxDoc
argument_list|()
operator|>>
literal|6
decl_stmt|;
name|int
name|scratchSize
init|=
name|Math
operator|.
name|min
argument_list|(
name|smallSetSize
argument_list|,
name|largestPossible
argument_list|)
decl_stmt|;
if|if
condition|(
name|deState
operator|.
name|scratch
operator|==
literal|null
operator|||
name|deState
operator|.
name|scratch
operator|.
name|length
operator|<
name|scratchSize
condition|)
name|deState
operator|.
name|scratch
operator|=
operator|new
name|int
index|[
name|scratchSize
index|]
expr_stmt|;
specifier|final
name|int
index|[]
name|docs
init|=
name|deState
operator|.
name|scratch
decl_stmt|;
name|int
name|upto
init|=
literal|0
decl_stmt|;
name|int
name|bitsSet
init|=
literal|0
decl_stmt|;
name|OpenBitSet
name|obs
init|=
literal|null
decl_stmt|;
name|DocsEnum
name|docsEnum
init|=
name|deState
operator|.
name|termsEnum
operator|.
name|docs
argument_list|(
name|deState
operator|.
name|liveDocs
argument_list|,
name|deState
operator|.
name|docsEnum
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|deState
operator|.
name|docsEnum
operator|==
literal|null
condition|)
block|{
name|deState
operator|.
name|docsEnum
operator|=
name|docsEnum
expr_stmt|;
block|}
if|if
condition|(
name|docsEnum
operator|instanceof
name|MultiDocsEnum
condition|)
block|{
name|MultiDocsEnum
operator|.
name|EnumWithSlice
index|[]
name|subs
init|=
operator|(
operator|(
name|MultiDocsEnum
operator|)
name|docsEnum
operator|)
operator|.
name|getSubs
argument_list|()
decl_stmt|;
name|int
name|numSubs
init|=
operator|(
operator|(
name|MultiDocsEnum
operator|)
name|docsEnum
operator|)
operator|.
name|getNumSubs
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|subindex
init|=
literal|0
init|;
name|subindex
operator|<
name|numSubs
condition|;
name|subindex
operator|++
control|)
block|{
name|MultiDocsEnum
operator|.
name|EnumWithSlice
name|sub
init|=
name|subs
index|[
name|subindex
index|]
decl_stmt|;
if|if
condition|(
name|sub
operator|.
name|docsEnum
operator|==
literal|null
condition|)
continue|continue;
name|int
name|base
init|=
name|sub
operator|.
name|slice
operator|.
name|start
decl_stmt|;
name|int
name|docid
decl_stmt|;
if|if
condition|(
name|largestPossible
operator|>
name|docs
operator|.
name|length
condition|)
block|{
if|if
condition|(
name|obs
operator|==
literal|null
condition|)
name|obs
operator|=
operator|new
name|OpenBitSet
argument_list|(
name|maxDoc
argument_list|()
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|docid
operator|=
name|sub
operator|.
name|docsEnum
operator|.
name|nextDoc
argument_list|()
operator|)
operator|!=
name|DocIdSetIterator
operator|.
name|NO_MORE_DOCS
condition|)
block|{
name|obs
operator|.
name|fastSet
argument_list|(
name|docid
operator|+
name|base
argument_list|)
expr_stmt|;
name|bitsSet
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
while|while
condition|(
operator|(
name|docid
operator|=
name|sub
operator|.
name|docsEnum
operator|.
name|nextDoc
argument_list|()
operator|)
operator|!=
name|DocIdSetIterator
operator|.
name|NO_MORE_DOCS
condition|)
block|{
name|docs
index|[
name|upto
operator|++
index|]
operator|=
name|docid
operator|+
name|base
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
block|{
name|int
name|docid
decl_stmt|;
if|if
condition|(
name|largestPossible
operator|>
name|docs
operator|.
name|length
condition|)
block|{
if|if
condition|(
name|obs
operator|==
literal|null
condition|)
name|obs
operator|=
operator|new
name|OpenBitSet
argument_list|(
name|maxDoc
argument_list|()
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|docid
operator|=
name|docsEnum
operator|.
name|nextDoc
argument_list|()
operator|)
operator|!=
name|DocIdSetIterator
operator|.
name|NO_MORE_DOCS
condition|)
block|{
name|obs
operator|.
name|fastSet
argument_list|(
name|docid
argument_list|)
expr_stmt|;
name|bitsSet
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
while|while
condition|(
operator|(
name|docid
operator|=
name|docsEnum
operator|.
name|nextDoc
argument_list|()
operator|)
operator|!=
name|DocIdSetIterator
operator|.
name|NO_MORE_DOCS
condition|)
block|{
name|docs
index|[
name|upto
operator|++
index|]
operator|=
name|docid
expr_stmt|;
block|}
block|}
block|}
name|DocSet
name|result
decl_stmt|;
if|if
condition|(
name|obs
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|upto
condition|;
name|i
operator|++
control|)
block|{
name|obs
operator|.
name|fastSet
argument_list|(
name|docs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|bitsSet
operator|+=
name|upto
expr_stmt|;
name|result
operator|=
operator|new
name|BitDocSet
argument_list|(
name|obs
argument_list|,
name|bitsSet
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|result
operator|=
name|upto
operator|==
literal|0
condition|?
name|DocSet
operator|.
name|EMPTY
else|:
operator|new
name|SortedIntDocSet
argument_list|(
name|Arrays
operator|.
name|copyOf
argument_list|(
name|docs
argument_list|,
name|upto
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|useCache
condition|)
block|{
name|filterCache
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
comment|// query must be positive
DECL|method|getDocSetNC
specifier|protected
name|DocSet
name|getDocSetNC
parameter_list|(
name|Query
name|query
parameter_list|,
name|DocSet
name|filter
parameter_list|)
throws|throws
name|IOException
block|{
name|DocSetCollector
name|collector
init|=
operator|new
name|DocSetCollector
argument_list|(
name|maxDoc
argument_list|()
operator|>>
literal|6
argument_list|,
name|maxDoc
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|filter
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|query
operator|instanceof
name|TermQuery
condition|)
block|{
name|Term
name|t
init|=
operator|(
operator|(
name|TermQuery
operator|)
name|query
operator|)
operator|.
name|getTerm
argument_list|()
decl_stmt|;
specifier|final
name|AtomicReaderContext
index|[]
name|leaves
init|=
name|leafContexts
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|leaves
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|AtomicReaderContext
name|leaf
init|=
name|leaves
index|[
name|i
index|]
decl_stmt|;
specifier|final
name|IndexReader
name|reader
init|=
name|leaf
operator|.
name|reader
decl_stmt|;
name|collector
operator|.
name|setNextReader
argument_list|(
name|leaf
argument_list|)
expr_stmt|;
name|Fields
name|fields
init|=
name|reader
operator|.
name|fields
argument_list|()
decl_stmt|;
name|Terms
name|terms
init|=
name|fields
operator|.
name|terms
argument_list|(
name|t
operator|.
name|field
argument_list|()
argument_list|)
decl_stmt|;
name|BytesRef
name|termBytes
init|=
name|t
operator|.
name|bytes
argument_list|()
decl_stmt|;
name|Bits
name|liveDocs
init|=
name|reader
operator|.
name|getLiveDocs
argument_list|()
decl_stmt|;
name|DocsEnum
name|docsEnum
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|terms
operator|!=
literal|null
condition|)
block|{
specifier|final
name|TermsEnum
name|termsEnum
init|=
name|terms
operator|.
name|iterator
argument_list|(
literal|null
argument_list|)
decl_stmt|;
if|if
condition|(
name|termsEnum
operator|.
name|seekExact
argument_list|(
name|termBytes
argument_list|,
literal|false
argument_list|)
condition|)
block|{
name|docsEnum
operator|=
name|termsEnum
operator|.
name|docs
argument_list|(
name|MultiFields
operator|.
name|getLiveDocs
argument_list|(
name|reader
argument_list|)
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|docsEnum
operator|!=
literal|null
condition|)
block|{
name|int
name|docid
decl_stmt|;
while|while
condition|(
operator|(
name|docid
operator|=
name|docsEnum
operator|.
name|nextDoc
argument_list|()
operator|)
operator|!=
name|DocIdSetIterator
operator|.
name|NO_MORE_DOCS
condition|)
block|{
name|collector
operator|.
name|collect
argument_list|(
name|docid
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
block|{
name|super
operator|.
name|search
argument_list|(
name|query
argument_list|,
literal|null
argument_list|,
name|collector
argument_list|)
expr_stmt|;
block|}
return|return
name|collector
operator|.
name|getDocSet
argument_list|()
return|;
block|}
else|else
block|{
name|Filter
name|luceneFilter
init|=
name|filter
operator|.
name|getTopFilter
argument_list|()
decl_stmt|;
name|super
operator|.
name|search
argument_list|(
name|query
argument_list|,
name|luceneFilter
argument_list|,
name|collector
argument_list|)
expr_stmt|;
return|return
name|collector
operator|.
name|getDocSet
argument_list|()
return|;
block|}
block|}
comment|/**    * Returns the set of document ids matching both the query and the filter.    * This method is cache-aware and attempts to retrieve the answer from the cache if possible.    * If the answer was not cached, it may have been inserted into the cache as a result of this call.    *<p>    *    * @param query    * @param filter may be null    * @return DocSet meeting the specified criteria, should<b>not</b> be modified by the caller.    */
DECL|method|getDocSet
specifier|public
name|DocSet
name|getDocSet
parameter_list|(
name|Query
name|query
parameter_list|,
name|DocSet
name|filter
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|filter
operator|==
literal|null
condition|)
return|return
name|getDocSet
argument_list|(
name|query
argument_list|)
return|;
if|if
condition|(
name|query
operator|instanceof
name|ExtendedQuery
condition|)
block|{
name|ExtendedQuery
name|eq
init|=
operator|(
name|ExtendedQuery
operator|)
name|query
decl_stmt|;
if|if
condition|(
operator|!
name|eq
operator|.
name|getCache
argument_list|()
condition|)
block|{
if|if
condition|(
name|query
operator|instanceof
name|WrappedQuery
condition|)
block|{
name|query
operator|=
operator|(
operator|(
name|WrappedQuery
operator|)
name|query
operator|)
operator|.
name|getWrappedQuery
argument_list|()
expr_stmt|;
block|}
name|query
operator|=
name|QueryUtils
operator|.
name|makeQueryable
argument_list|(
name|query
argument_list|)
expr_stmt|;
return|return
name|getDocSetNC
argument_list|(
name|query
argument_list|,
name|filter
argument_list|)
return|;
block|}
block|}
comment|// Negative query if absolute value different from original
name|Query
name|absQ
init|=
name|QueryUtils
operator|.
name|getAbs
argument_list|(
name|query
argument_list|)
decl_stmt|;
name|boolean
name|positive
init|=
name|absQ
operator|==
name|query
decl_stmt|;
name|DocSet
name|first
decl_stmt|;
if|if
condition|(
name|filterCache
operator|!=
literal|null
condition|)
block|{
name|first
operator|=
name|filterCache
operator|.
name|get
argument_list|(
name|absQ
argument_list|)
expr_stmt|;
if|if
condition|(
name|first
operator|==
literal|null
condition|)
block|{
name|first
operator|=
name|getDocSetNC
argument_list|(
name|absQ
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|filterCache
operator|.
name|put
argument_list|(
name|absQ
argument_list|,
name|first
argument_list|)
expr_stmt|;
block|}
return|return
name|positive
condition|?
name|first
operator|.
name|intersection
argument_list|(
name|filter
argument_list|)
else|:
name|filter
operator|.
name|andNot
argument_list|(
name|first
argument_list|)
return|;
block|}
comment|// If there isn't a cache, then do a single filtered query if positive.
return|return
name|positive
condition|?
name|getDocSetNC
argument_list|(
name|absQ
argument_list|,
name|filter
argument_list|)
else|:
name|filter
operator|.
name|andNot
argument_list|(
name|getPositiveDocSet
argument_list|(
name|absQ
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Returns documents matching both<code>query</code> and<code>filter</code>    * and sorted by<code>sort</code>.    *<p>    * This method is cache aware and may retrieve<code>filter</code> from    * the cache or make an insertion into the cache as a result of this call.    *<p>    * FUTURE: The returned DocList may be retrieved from a cache.    *    * @param query    * @param filter   may be null    * @param lsort    criteria by which to sort (if null, query relevance is used)    * @param offset   offset into the list of documents to return    * @param len      maximum number of documents to return    * @return DocList meeting the specified criteria, should<b>not</b> be modified by the caller.    * @throws IOException    */
DECL|method|getDocList
specifier|public
name|DocList
name|getDocList
parameter_list|(
name|Query
name|query
parameter_list|,
name|Query
name|filter
parameter_list|,
name|Sort
name|lsort
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|len
parameter_list|)
throws|throws
name|IOException
block|{
name|QueryCommand
name|qc
init|=
operator|new
name|QueryCommand
argument_list|()
decl_stmt|;
name|qc
operator|.
name|setQuery
argument_list|(
name|query
argument_list|)
operator|.
name|setFilterList
argument_list|(
name|filter
argument_list|)
operator|.
name|setSort
argument_list|(
name|lsort
argument_list|)
operator|.
name|setOffset
argument_list|(
name|offset
argument_list|)
operator|.
name|setLen
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|QueryResult
name|qr
init|=
operator|new
name|QueryResult
argument_list|()
decl_stmt|;
name|search
argument_list|(
name|qr
argument_list|,
name|qc
argument_list|)
expr_stmt|;
return|return
name|qr
operator|.
name|getDocList
argument_list|()
return|;
block|}
comment|/**    * Returns documents matching both<code>query</code> and the     * intersection of the<code>filterList</code>, sorted by<code>sort</code>.    *<p>    * This method is cache aware and may retrieve<code>filter</code> from    * the cache or make an insertion into the cache as a result of this call.    *<p>    * FUTURE: The returned DocList may be retrieved from a cache.    *    * @param query    * @param filterList may be null    * @param lsort    criteria by which to sort (if null, query relevance is used)    * @param offset   offset into the list of documents to return    * @param len      maximum number of documents to return    * @return DocList meeting the specified criteria, should<b>not</b> be modified by the caller.    * @throws IOException    */
DECL|method|getDocList
specifier|public
name|DocList
name|getDocList
parameter_list|(
name|Query
name|query
parameter_list|,
name|List
argument_list|<
name|Query
argument_list|>
name|filterList
parameter_list|,
name|Sort
name|lsort
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|flags
parameter_list|)
throws|throws
name|IOException
block|{
name|QueryCommand
name|qc
init|=
operator|new
name|QueryCommand
argument_list|()
decl_stmt|;
name|qc
operator|.
name|setQuery
argument_list|(
name|query
argument_list|)
operator|.
name|setFilterList
argument_list|(
name|filterList
argument_list|)
operator|.
name|setSort
argument_list|(
name|lsort
argument_list|)
operator|.
name|setOffset
argument_list|(
name|offset
argument_list|)
operator|.
name|setLen
argument_list|(
name|len
argument_list|)
operator|.
name|setFlags
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|QueryResult
name|qr
init|=
operator|new
name|QueryResult
argument_list|()
decl_stmt|;
name|search
argument_list|(
name|qr
argument_list|,
name|qc
argument_list|)
expr_stmt|;
return|return
name|qr
operator|.
name|getDocList
argument_list|()
return|;
block|}
DECL|field|NO_CHECK_QCACHE
specifier|static
specifier|final
name|int
name|NO_CHECK_QCACHE
init|=
literal|0x80000000
decl_stmt|;
DECL|field|GET_DOCSET
specifier|public
specifier|static
specifier|final
name|int
name|GET_DOCSET
init|=
literal|0x40000000
decl_stmt|;
DECL|field|NO_CHECK_FILTERCACHE
specifier|static
specifier|final
name|int
name|NO_CHECK_FILTERCACHE
init|=
literal|0x20000000
decl_stmt|;
DECL|field|NO_SET_QCACHE
specifier|static
specifier|final
name|int
name|NO_SET_QCACHE
init|=
literal|0x10000000
decl_stmt|;
DECL|field|GET_DOCLIST
specifier|public
specifier|static
specifier|final
name|int
name|GET_DOCLIST
init|=
literal|0x02
decl_stmt|;
comment|// get the documents actually returned in a response
DECL|field|GET_SCORES
specifier|public
specifier|static
specifier|final
name|int
name|GET_SCORES
init|=
literal|0x01
decl_stmt|;
comment|/**    * getDocList version that uses+populates query and filter caches.    * In the event of a timeout, the cache is not populated.    */
DECL|method|getDocListC
specifier|private
name|void
name|getDocListC
parameter_list|(
name|QueryResult
name|qr
parameter_list|,
name|QueryCommand
name|cmd
parameter_list|)
throws|throws
name|IOException
block|{
name|DocListAndSet
name|out
init|=
operator|new
name|DocListAndSet
argument_list|()
decl_stmt|;
name|qr
operator|.
name|setDocListAndSet
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|QueryResultKey
name|key
init|=
literal|null
decl_stmt|;
name|int
name|maxDocRequested
init|=
name|cmd
operator|.
name|getOffset
argument_list|()
operator|+
name|cmd
operator|.
name|getLen
argument_list|()
decl_stmt|;
comment|// check for overflow, and check for # docs in index
if|if
condition|(
name|maxDocRequested
argument_list|<
literal|0
operator|||
name|maxDocRequested
argument_list|>
name|maxDoc
argument_list|()
condition|)
name|maxDocRequested
operator|=
name|maxDoc
argument_list|()
expr_stmt|;
name|int
name|supersetMaxDoc
init|=
name|maxDocRequested
decl_stmt|;
name|DocList
name|superset
init|=
literal|null
decl_stmt|;
name|int
name|flags
init|=
name|cmd
operator|.
name|getFlags
argument_list|()
decl_stmt|;
name|Query
name|q
init|=
name|cmd
operator|.
name|getQuery
argument_list|()
decl_stmt|;
if|if
condition|(
name|q
operator|instanceof
name|ExtendedQuery
condition|)
block|{
name|ExtendedQuery
name|eq
init|=
operator|(
name|ExtendedQuery
operator|)
name|q
decl_stmt|;
if|if
condition|(
operator|!
name|eq
operator|.
name|getCache
argument_list|()
condition|)
block|{
name|flags
operator||=
operator|(
name|NO_CHECK_QCACHE
operator||
name|NO_SET_QCACHE
operator||
name|NO_CHECK_FILTERCACHE
operator|)
expr_stmt|;
block|}
block|}
comment|// we can try and look up the complete query in the cache.
comment|// we can't do that if filter!=null though (we don't want to
comment|// do hashCode() and equals() for a big DocSet).
if|if
condition|(
name|queryResultCache
operator|!=
literal|null
operator|&&
name|cmd
operator|.
name|getFilter
argument_list|()
operator|==
literal|null
operator|&&
operator|(
name|flags
operator|&
operator|(
name|NO_CHECK_QCACHE
operator||
name|NO_SET_QCACHE
operator|)
operator|)
operator|!=
operator|(
operator|(
name|NO_CHECK_QCACHE
operator||
name|NO_SET_QCACHE
operator|)
operator|)
condition|)
block|{
comment|// all of the current flags can be reused during warming,
comment|// so set all of them on the cache key.
name|key
operator|=
operator|new
name|QueryResultKey
argument_list|(
name|q
argument_list|,
name|cmd
operator|.
name|getFilterList
argument_list|()
argument_list|,
name|cmd
operator|.
name|getSort
argument_list|()
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|NO_CHECK_QCACHE
operator|)
operator|==
literal|0
condition|)
block|{
name|superset
operator|=
name|queryResultCache
operator|.
name|get
argument_list|(
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|superset
operator|!=
literal|null
condition|)
block|{
comment|// check that the cache entry has scores recorded if we need them
if|if
condition|(
operator|(
name|flags
operator|&
name|GET_SCORES
operator|)
operator|==
literal|0
operator|||
name|superset
operator|.
name|hasScores
argument_list|()
condition|)
block|{
comment|// NOTE: subset() returns null if the DocList has fewer docs than
comment|// requested
name|out
operator|.
name|docList
operator|=
name|superset
operator|.
name|subset
argument_list|(
name|cmd
operator|.
name|getOffset
argument_list|()
argument_list|,
name|cmd
operator|.
name|getLen
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|out
operator|.
name|docList
operator|!=
literal|null
condition|)
block|{
comment|// found the docList in the cache... now check if we need the docset too.
comment|// OPT: possible future optimization - if the doclist contains all the matches,
comment|// use it to make the docset instead of rerunning the query.
if|if
condition|(
name|out
operator|.
name|docSet
operator|==
literal|null
operator|&&
operator|(
operator|(
name|flags
operator|&
name|GET_DOCSET
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|cmd
operator|.
name|getFilterList
argument_list|()
operator|==
literal|null
condition|)
block|{
name|out
operator|.
name|docSet
operator|=
name|getDocSet
argument_list|(
name|cmd
operator|.
name|getQuery
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|List
argument_list|<
name|Query
argument_list|>
name|newList
init|=
operator|new
name|ArrayList
argument_list|<
name|Query
argument_list|>
argument_list|(
name|cmd
operator|.
name|getFilterList
argument_list|()
operator|.
name|size
argument_list|()
operator|+
literal|1
argument_list|)
decl_stmt|;
name|newList
operator|.
name|add
argument_list|(
name|cmd
operator|.
name|getQuery
argument_list|()
argument_list|)
expr_stmt|;
name|newList
operator|.
name|addAll
argument_list|(
name|cmd
operator|.
name|getFilterList
argument_list|()
argument_list|)
expr_stmt|;
name|out
operator|.
name|docSet
operator|=
name|getDocSet
argument_list|(
name|newList
argument_list|)
expr_stmt|;
block|}
block|}
return|return;
block|}
block|}
comment|// If we are going to generate the result, bump up to the
comment|// next resultWindowSize for better caching.
if|if
condition|(
operator|(
name|flags
operator|&
name|NO_SET_QCACHE
operator|)
operator|==
literal|0
condition|)
block|{
comment|// handle 0 special case as well as avoid idiv in the common case.
if|if
condition|(
name|maxDocRequested
operator|<
name|queryResultWindowSize
condition|)
block|{
name|supersetMaxDoc
operator|=
name|queryResultWindowSize
expr_stmt|;
block|}
else|else
block|{
name|supersetMaxDoc
operator|=
operator|(
operator|(
name|maxDocRequested
operator|-
literal|1
operator|)
operator|/
name|queryResultWindowSize
operator|+
literal|1
operator|)
operator|*
name|queryResultWindowSize
expr_stmt|;
if|if
condition|(
name|supersetMaxDoc
operator|<
literal|0
condition|)
name|supersetMaxDoc
operator|=
name|maxDocRequested
expr_stmt|;
block|}
block|}
else|else
block|{
name|key
operator|=
literal|null
expr_stmt|;
comment|// we won't be caching the result
block|}
block|}
comment|// OK, so now we need to generate an answer.
comment|// One way to do that would be to check if we have an unordered list
comment|// of results for the base query.  If so, we can apply the filters and then
comment|// sort by the resulting set.  This can only be used if:
comment|// - the sort doesn't contain score
comment|// - we don't want score returned.
comment|// check if we should try and use the filter cache
name|boolean
name|useFilterCache
init|=
literal|false
decl_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
operator|(
name|GET_SCORES
operator||
name|NO_CHECK_FILTERCACHE
operator|)
operator|)
operator|==
literal|0
operator|&&
name|useFilterForSortedQuery
operator|&&
name|cmd
operator|.
name|getSort
argument_list|()
operator|!=
literal|null
operator|&&
name|filterCache
operator|!=
literal|null
condition|)
block|{
name|useFilterCache
operator|=
literal|true
expr_stmt|;
name|SortField
index|[]
name|sfields
init|=
name|cmd
operator|.
name|getSort
argument_list|()
operator|.
name|getSort
argument_list|()
decl_stmt|;
for|for
control|(
name|SortField
name|sf
range|:
name|sfields
control|)
block|{
if|if
condition|(
name|sf
operator|.
name|getType
argument_list|()
operator|==
name|SortField
operator|.
name|Type
operator|.
name|SCORE
condition|)
block|{
name|useFilterCache
operator|=
literal|false
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|// disable useFilterCache optimization temporarily
if|if
condition|(
name|useFilterCache
condition|)
block|{
comment|// now actually use the filter cache.
comment|// for large filters that match few documents, this may be
comment|// slower than simply re-executing the query.
if|if
condition|(
name|out
operator|.
name|docSet
operator|==
literal|null
condition|)
block|{
name|out
operator|.
name|docSet
operator|=
name|getDocSet
argument_list|(
name|cmd
operator|.
name|getQuery
argument_list|()
argument_list|,
name|cmd
operator|.
name|getFilter
argument_list|()
argument_list|)
expr_stmt|;
name|DocSet
name|bigFilt
init|=
name|getDocSet
argument_list|(
name|cmd
operator|.
name|getFilterList
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|bigFilt
operator|!=
literal|null
condition|)
name|out
operator|.
name|docSet
operator|=
name|out
operator|.
name|docSet
operator|.
name|intersection
argument_list|(
name|bigFilt
argument_list|)
expr_stmt|;
block|}
comment|// todo: there could be a sortDocSet that could take a list of
comment|// the filters instead of anding them first...
comment|// perhaps there should be a multi-docset-iterator
name|superset
operator|=
name|sortDocSet
argument_list|(
name|out
operator|.
name|docSet
argument_list|,
name|cmd
operator|.
name|getSort
argument_list|()
argument_list|,
name|supersetMaxDoc
argument_list|)
expr_stmt|;
name|out
operator|.
name|docList
operator|=
name|superset
operator|.
name|subset
argument_list|(
name|cmd
operator|.
name|getOffset
argument_list|()
argument_list|,
name|cmd
operator|.
name|getLen
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// do it the normal way...
name|cmd
operator|.
name|setSupersetMaxDoc
argument_list|(
name|supersetMaxDoc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|GET_DOCSET
operator|)
operator|!=
literal|0
condition|)
block|{
comment|// this currently conflates returning the docset for the base query vs
comment|// the base query and all filters.
name|DocSet
name|qDocSet
init|=
name|getDocListAndSetNC
argument_list|(
name|qr
argument_list|,
name|cmd
argument_list|)
decl_stmt|;
comment|// cache the docSet matching the query w/o filtering
if|if
condition|(
name|qDocSet
operator|!=
literal|null
operator|&&
name|filterCache
operator|!=
literal|null
operator|&&
operator|!
name|qr
operator|.
name|isPartialResults
argument_list|()
condition|)
name|filterCache
operator|.
name|put
argument_list|(
name|cmd
operator|.
name|getQuery
argument_list|()
argument_list|,
name|qDocSet
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|getDocListNC
argument_list|(
name|qr
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
comment|//Parameters: cmd.getQuery(),theFilt,cmd.getSort(),0,supersetMaxDoc,cmd.getFlags(),cmd.getTimeAllowed(),responseHeader);
block|}
name|superset
operator|=
name|out
operator|.
name|docList
expr_stmt|;
name|out
operator|.
name|docList
operator|=
name|superset
operator|.
name|subset
argument_list|(
name|cmd
operator|.
name|getOffset
argument_list|()
argument_list|,
name|cmd
operator|.
name|getLen
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// lastly, put the superset in the cache if the size is less than or equal
comment|// to queryResultMaxDocsCached
if|if
condition|(
name|key
operator|!=
literal|null
operator|&&
name|superset
operator|.
name|size
argument_list|()
operator|<=
name|queryResultMaxDocsCached
operator|&&
operator|!
name|qr
operator|.
name|isPartialResults
argument_list|()
condition|)
block|{
name|queryResultCache
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|superset
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|getDocListNC
specifier|private
name|void
name|getDocListNC
parameter_list|(
name|QueryResult
name|qr
parameter_list|,
name|QueryCommand
name|cmd
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|long
name|timeAllowed
init|=
name|cmd
operator|.
name|getTimeAllowed
argument_list|()
decl_stmt|;
name|int
name|len
init|=
name|cmd
operator|.
name|getSupersetMaxDoc
argument_list|()
decl_stmt|;
name|int
name|last
init|=
name|len
decl_stmt|;
if|if
condition|(
name|last
argument_list|<
literal|0
operator|||
name|last
argument_list|>
name|maxDoc
argument_list|()
condition|)
name|last
operator|=
name|maxDoc
argument_list|()
expr_stmt|;
specifier|final
name|int
name|lastDocRequested
init|=
name|last
decl_stmt|;
name|int
name|nDocsReturned
decl_stmt|;
name|int
name|totalHits
decl_stmt|;
name|float
name|maxScore
decl_stmt|;
name|int
index|[]
name|ids
decl_stmt|;
name|float
index|[]
name|scores
decl_stmt|;
name|boolean
name|needScores
init|=
operator|(
name|cmd
operator|.
name|getFlags
argument_list|()
operator|&
name|GET_SCORES
operator|)
operator|!=
literal|0
decl_stmt|;
name|Query
name|query
init|=
name|QueryUtils
operator|.
name|makeQueryable
argument_list|(
name|cmd
operator|.
name|getQuery
argument_list|()
argument_list|)
decl_stmt|;
name|ProcessedFilter
name|pf
init|=
name|getProcessedFilter
argument_list|(
name|cmd
operator|.
name|getFilter
argument_list|()
argument_list|,
name|cmd
operator|.
name|getFilterList
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|Filter
name|luceneFilter
init|=
name|pf
operator|.
name|filter
decl_stmt|;
comment|// handle zero case...
if|if
condition|(
name|lastDocRequested
operator|<=
literal|0
condition|)
block|{
specifier|final
name|float
index|[]
name|topscore
init|=
operator|new
name|float
index|[]
block|{
name|Float
operator|.
name|NEGATIVE_INFINITY
block|}
decl_stmt|;
specifier|final
name|int
index|[]
name|numHits
init|=
operator|new
name|int
index|[
literal|1
index|]
decl_stmt|;
name|Collector
name|collector
decl_stmt|;
if|if
condition|(
operator|!
name|needScores
condition|)
block|{
name|collector
operator|=
operator|new
name|Collector
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|setScorer
parameter_list|(
name|Scorer
name|scorer
parameter_list|)
throws|throws
name|IOException
block|{           }
annotation|@
name|Override
specifier|public
name|void
name|collect
parameter_list|(
name|int
name|doc
parameter_list|)
throws|throws
name|IOException
block|{
name|numHits
index|[
literal|0
index|]
operator|++
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|setNextReader
parameter_list|(
name|AtomicReaderContext
name|context
parameter_list|)
throws|throws
name|IOException
block|{           }
annotation|@
name|Override
specifier|public
name|boolean
name|acceptsDocsOutOfOrder
parameter_list|()
block|{
return|return
literal|true
return|;
block|}
block|}
expr_stmt|;
block|}
else|else
block|{
name|collector
operator|=
operator|new
name|Collector
argument_list|()
block|{
name|Scorer
name|scorer
decl_stmt|;
annotation|@
name|Override
specifier|public
name|void
name|setScorer
parameter_list|(
name|Scorer
name|scorer
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|scorer
operator|=
name|scorer
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|collect
parameter_list|(
name|int
name|doc
parameter_list|)
throws|throws
name|IOException
block|{
name|numHits
index|[
literal|0
index|]
operator|++
expr_stmt|;
name|float
name|score
init|=
name|scorer
operator|.
name|score
argument_list|()
decl_stmt|;
if|if
condition|(
name|score
operator|>
name|topscore
index|[
literal|0
index|]
condition|)
name|topscore
index|[
literal|0
index|]
operator|=
name|score
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|setNextReader
parameter_list|(
name|AtomicReaderContext
name|context
parameter_list|)
throws|throws
name|IOException
block|{           }
annotation|@
name|Override
specifier|public
name|boolean
name|acceptsDocsOutOfOrder
parameter_list|()
block|{
return|return
literal|true
return|;
block|}
block|}
expr_stmt|;
block|}
if|if
condition|(
name|timeAllowed
operator|>
literal|0
condition|)
block|{
name|collector
operator|=
operator|new
name|TimeLimitingCollector
argument_list|(
name|collector
argument_list|,
name|TimeLimitingCollector
operator|.
name|getGlobalCounter
argument_list|()
argument_list|,
name|timeAllowed
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pf
operator|.
name|postFilter
operator|!=
literal|null
condition|)
block|{
name|pf
operator|.
name|postFilter
operator|.
name|setLastDelegate
argument_list|(
name|collector
argument_list|)
expr_stmt|;
name|collector
operator|=
name|pf
operator|.
name|postFilter
expr_stmt|;
block|}
try|try
block|{
name|super
operator|.
name|search
argument_list|(
name|query
argument_list|,
name|luceneFilter
argument_list|,
name|collector
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|TimeLimitingCollector
operator|.
name|TimeExceededException
name|x
parameter_list|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Query: "
operator|+
name|query
operator|+
literal|"; "
operator|+
name|x
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
name|qr
operator|.
name|setPartialResults
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
name|nDocsReturned
operator|=
literal|0
expr_stmt|;
name|ids
operator|=
operator|new
name|int
index|[
name|nDocsReturned
index|]
expr_stmt|;
name|scores
operator|=
operator|new
name|float
index|[
name|nDocsReturned
index|]
expr_stmt|;
name|totalHits
operator|=
name|numHits
index|[
literal|0
index|]
expr_stmt|;
name|maxScore
operator|=
name|totalHits
operator|>
literal|0
condition|?
name|topscore
index|[
literal|0
index|]
else|:
literal|0.0f
expr_stmt|;
block|}
else|else
block|{
name|TopDocsCollector
name|topCollector
decl_stmt|;
if|if
condition|(
name|cmd
operator|.
name|getSort
argument_list|()
operator|==
literal|null
condition|)
block|{
name|topCollector
operator|=
name|TopScoreDocCollector
operator|.
name|create
argument_list|(
name|len
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|topCollector
operator|=
name|TopFieldCollector
operator|.
name|create
argument_list|(
name|weightSort
argument_list|(
name|cmd
operator|.
name|getSort
argument_list|()
argument_list|)
argument_list|,
name|len
argument_list|,
literal|false
argument_list|,
name|needScores
argument_list|,
name|needScores
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
name|Collector
name|collector
init|=
name|topCollector
decl_stmt|;
if|if
condition|(
name|timeAllowed
operator|>
literal|0
condition|)
block|{
name|collector
operator|=
operator|new
name|TimeLimitingCollector
argument_list|(
name|collector
argument_list|,
name|TimeLimitingCollector
operator|.
name|getGlobalCounter
argument_list|()
argument_list|,
name|timeAllowed
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pf
operator|.
name|postFilter
operator|!=
literal|null
condition|)
block|{
name|pf
operator|.
name|postFilter
operator|.
name|setLastDelegate
argument_list|(
name|collector
argument_list|)
expr_stmt|;
name|collector
operator|=
name|pf
operator|.
name|postFilter
expr_stmt|;
block|}
try|try
block|{
name|super
operator|.
name|search
argument_list|(
name|query
argument_list|,
name|luceneFilter
argument_list|,
name|collector
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|TimeLimitingCollector
operator|.
name|TimeExceededException
name|x
parameter_list|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Query: "
operator|+
name|query
operator|+
literal|"; "
operator|+
name|x
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
name|qr
operator|.
name|setPartialResults
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
name|totalHits
operator|=
name|topCollector
operator|.
name|getTotalHits
argument_list|()
expr_stmt|;
name|TopDocs
name|topDocs
init|=
name|topCollector
operator|.
name|topDocs
argument_list|(
literal|0
argument_list|,
name|len
argument_list|)
decl_stmt|;
name|maxScore
operator|=
name|totalHits
operator|>
literal|0
condition|?
name|topDocs
operator|.
name|getMaxScore
argument_list|()
else|:
literal|0.0f
expr_stmt|;
name|nDocsReturned
operator|=
name|topDocs
operator|.
name|scoreDocs
operator|.
name|length
expr_stmt|;
name|ids
operator|=
operator|new
name|int
index|[
name|nDocsReturned
index|]
expr_stmt|;
name|scores
operator|=
operator|(
name|cmd
operator|.
name|getFlags
argument_list|()
operator|&
name|GET_SCORES
operator|)
operator|!=
literal|0
condition|?
operator|new
name|float
index|[
name|nDocsReturned
index|]
else|:
literal|null
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nDocsReturned
condition|;
name|i
operator|++
control|)
block|{
name|ScoreDoc
name|scoreDoc
init|=
name|topDocs
operator|.
name|scoreDocs
index|[
name|i
index|]
decl_stmt|;
name|ids
index|[
name|i
index|]
operator|=
name|scoreDoc
operator|.
name|doc
expr_stmt|;
if|if
condition|(
name|scores
operator|!=
literal|null
condition|)
name|scores
index|[
name|i
index|]
operator|=
name|scoreDoc
operator|.
name|score
expr_stmt|;
block|}
block|}
name|int
name|sliceLen
init|=
name|Math
operator|.
name|min
argument_list|(
name|lastDocRequested
argument_list|,
name|nDocsReturned
argument_list|)
decl_stmt|;
if|if
condition|(
name|sliceLen
operator|<
literal|0
condition|)
name|sliceLen
operator|=
literal|0
expr_stmt|;
name|qr
operator|.
name|setDocList
argument_list|(
operator|new
name|DocSlice
argument_list|(
literal|0
argument_list|,
name|sliceLen
argument_list|,
name|ids
argument_list|,
name|scores
argument_list|,
name|totalHits
argument_list|,
name|maxScore
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// any DocSet returned is for the query only, without any filtering... that way it may
comment|// be cached if desired.
DECL|method|getDocListAndSetNC
specifier|private
name|DocSet
name|getDocListAndSetNC
parameter_list|(
name|QueryResult
name|qr
parameter_list|,
name|QueryCommand
name|cmd
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|len
init|=
name|cmd
operator|.
name|getSupersetMaxDoc
argument_list|()
decl_stmt|;
name|int
name|last
init|=
name|len
decl_stmt|;
if|if
condition|(
name|last
argument_list|<
literal|0
operator|||
name|last
argument_list|>
name|maxDoc
argument_list|()
condition|)
name|last
operator|=
name|maxDoc
argument_list|()
expr_stmt|;
specifier|final
name|int
name|lastDocRequested
init|=
name|last
decl_stmt|;
name|int
name|nDocsReturned
decl_stmt|;
name|int
name|totalHits
decl_stmt|;
name|float
name|maxScore
decl_stmt|;
name|int
index|[]
name|ids
decl_stmt|;
name|float
index|[]
name|scores
decl_stmt|;
name|DocSet
name|set
decl_stmt|;
name|boolean
name|needScores
init|=
operator|(
name|cmd
operator|.
name|getFlags
argument_list|()
operator|&
name|GET_SCORES
operator|)
operator|!=
literal|0
decl_stmt|;
name|int
name|maxDoc
init|=
name|maxDoc
argument_list|()
decl_stmt|;
name|int
name|smallSetSize
init|=
name|maxDoc
operator|>>
literal|6
decl_stmt|;
name|ProcessedFilter
name|pf
init|=
name|getProcessedFilter
argument_list|(
name|cmd
operator|.
name|getFilter
argument_list|()
argument_list|,
name|cmd
operator|.
name|getFilterList
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|Filter
name|luceneFilter
init|=
name|pf
operator|.
name|filter
decl_stmt|;
name|Query
name|query
init|=
name|QueryUtils
operator|.
name|makeQueryable
argument_list|(
name|cmd
operator|.
name|getQuery
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|long
name|timeAllowed
init|=
name|cmd
operator|.
name|getTimeAllowed
argument_list|()
decl_stmt|;
comment|// handle zero case...
if|if
condition|(
name|lastDocRequested
operator|<=
literal|0
condition|)
block|{
specifier|final
name|float
index|[]
name|topscore
init|=
operator|new
name|float
index|[]
block|{
name|Float
operator|.
name|NEGATIVE_INFINITY
block|}
decl_stmt|;
name|Collector
name|collector
decl_stmt|;
name|DocSetCollector
name|setCollector
decl_stmt|;
if|if
condition|(
operator|!
name|needScores
condition|)
block|{
name|collector
operator|=
name|setCollector
operator|=
operator|new
name|DocSetCollector
argument_list|(
name|smallSetSize
argument_list|,
name|maxDoc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|collector
operator|=
name|setCollector
operator|=
operator|new
name|DocSetDelegateCollector
argument_list|(
name|smallSetSize
argument_list|,
name|maxDoc
argument_list|,
operator|new
name|Collector
argument_list|()
block|{
name|Scorer
name|scorer
decl_stmt|;
annotation|@
name|Override
specifier|public
name|void
name|setScorer
parameter_list|(
name|Scorer
name|scorer
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|scorer
operator|=
name|scorer
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|collect
parameter_list|(
name|int
name|doc
parameter_list|)
throws|throws
name|IOException
block|{
name|float
name|score
init|=
name|scorer
operator|.
name|score
argument_list|()
decl_stmt|;
if|if
condition|(
name|score
operator|>
name|topscore
index|[
literal|0
index|]
condition|)
name|topscore
index|[
literal|0
index|]
operator|=
name|score
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|setNextReader
parameter_list|(
name|AtomicReaderContext
name|context
parameter_list|)
throws|throws
name|IOException
block|{            }
annotation|@
name|Override
specifier|public
name|boolean
name|acceptsDocsOutOfOrder
parameter_list|()
block|{
return|return
literal|false
return|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|timeAllowed
operator|>
literal|0
condition|)
block|{
name|collector
operator|=
operator|new
name|TimeLimitingCollector
argument_list|(
name|collector
argument_list|,
name|TimeLimitingCollector
operator|.
name|getGlobalCounter
argument_list|()
argument_list|,
name|timeAllowed
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pf
operator|.
name|postFilter
operator|!=
literal|null
condition|)
block|{
name|pf
operator|.
name|postFilter
operator|.
name|setLastDelegate
argument_list|(
name|collector
argument_list|)
expr_stmt|;
name|collector
operator|=
name|pf
operator|.
name|postFilter
expr_stmt|;
block|}
try|try
block|{
name|super
operator|.
name|search
argument_list|(
name|query
argument_list|,
name|luceneFilter
argument_list|,
name|collector
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|TimeLimitingCollector
operator|.
name|TimeExceededException
name|x
parameter_list|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Query: "
operator|+
name|query
operator|+
literal|"; "
operator|+
name|x
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
name|qr
operator|.
name|setPartialResults
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
name|set
operator|=
name|setCollector
operator|.
name|getDocSet
argument_list|()
expr_stmt|;
name|nDocsReturned
operator|=
literal|0
expr_stmt|;
name|ids
operator|=
operator|new
name|int
index|[
name|nDocsReturned
index|]
expr_stmt|;
name|scores
operator|=
operator|new
name|float
index|[
name|nDocsReturned
index|]
expr_stmt|;
name|totalHits
operator|=
name|set
operator|.
name|size
argument_list|()
expr_stmt|;
name|maxScore
operator|=
name|totalHits
operator|>
literal|0
condition|?
name|topscore
index|[
literal|0
index|]
else|:
literal|0.0f
expr_stmt|;
block|}
else|else
block|{
name|TopDocsCollector
name|topCollector
decl_stmt|;
if|if
condition|(
name|cmd
operator|.
name|getSort
argument_list|()
operator|==
literal|null
condition|)
block|{
name|topCollector
operator|=
name|TopScoreDocCollector
operator|.
name|create
argument_list|(
name|len
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|topCollector
operator|=
name|TopFieldCollector
operator|.
name|create
argument_list|(
name|weightSort
argument_list|(
name|cmd
operator|.
name|getSort
argument_list|()
argument_list|)
argument_list|,
name|len
argument_list|,
literal|false
argument_list|,
name|needScores
argument_list|,
name|needScores
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
name|DocSetCollector
name|setCollector
init|=
operator|new
name|DocSetDelegateCollector
argument_list|(
name|maxDoc
operator|>>
literal|6
argument_list|,
name|maxDoc
argument_list|,
name|topCollector
argument_list|)
decl_stmt|;
name|Collector
name|collector
init|=
name|setCollector
decl_stmt|;
if|if
condition|(
name|timeAllowed
operator|>
literal|0
condition|)
block|{
name|collector
operator|=
operator|new
name|TimeLimitingCollector
argument_list|(
name|collector
argument_list|,
name|TimeLimitingCollector
operator|.
name|getGlobalCounter
argument_list|()
argument_list|,
name|timeAllowed
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pf
operator|.
name|postFilter
operator|!=
literal|null
condition|)
block|{
name|pf
operator|.
name|postFilter
operator|.
name|setLastDelegate
argument_list|(
name|collector
argument_list|)
expr_stmt|;
name|collector
operator|=
name|pf
operator|.
name|postFilter
expr_stmt|;
block|}
try|try
block|{
name|super
operator|.
name|search
argument_list|(
name|query
argument_list|,
name|luceneFilter
argument_list|,
name|collector
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|TimeLimitingCollector
operator|.
name|TimeExceededException
name|x
parameter_list|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Query: "
operator|+
name|query
operator|+
literal|"; "
operator|+
name|x
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
name|qr
operator|.
name|setPartialResults
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
name|set
operator|=
name|setCollector
operator|.
name|getDocSet
argument_list|()
expr_stmt|;
name|totalHits
operator|=
name|topCollector
operator|.
name|getTotalHits
argument_list|()
expr_stmt|;
assert|assert
operator|(
name|totalHits
operator|==
name|set
operator|.
name|size
argument_list|()
operator|)
assert|;
name|TopDocs
name|topDocs
init|=
name|topCollector
operator|.
name|topDocs
argument_list|(
literal|0
argument_list|,
name|len
argument_list|)
decl_stmt|;
name|maxScore
operator|=
name|totalHits
operator|>
literal|0
condition|?
name|topDocs
operator|.
name|getMaxScore
argument_list|()
else|:
literal|0.0f
expr_stmt|;
name|nDocsReturned
operator|=
name|topDocs
operator|.
name|scoreDocs
operator|.
name|length
expr_stmt|;
name|ids
operator|=
operator|new
name|int
index|[
name|nDocsReturned
index|]
expr_stmt|;
name|scores
operator|=
operator|(
name|cmd
operator|.
name|getFlags
argument_list|()
operator|&
name|GET_SCORES
operator|)
operator|!=
literal|0
condition|?
operator|new
name|float
index|[
name|nDocsReturned
index|]
else|:
literal|null
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nDocsReturned
condition|;
name|i
operator|++
control|)
block|{
name|ScoreDoc
name|scoreDoc
init|=
name|topDocs
operator|.
name|scoreDocs
index|[
name|i
index|]
decl_stmt|;
name|ids
index|[
name|i
index|]
operator|=
name|scoreDoc
operator|.
name|doc
expr_stmt|;
if|if
condition|(
name|scores
operator|!=
literal|null
condition|)
name|scores
index|[
name|i
index|]
operator|=
name|scoreDoc
operator|.
name|score
expr_stmt|;
block|}
block|}
name|int
name|sliceLen
init|=
name|Math
operator|.
name|min
argument_list|(
name|lastDocRequested
argument_list|,
name|nDocsReturned
argument_list|)
decl_stmt|;
if|if
condition|(
name|sliceLen
operator|<
literal|0
condition|)
name|sliceLen
operator|=
literal|0
expr_stmt|;
name|qr
operator|.
name|setDocList
argument_list|(
operator|new
name|DocSlice
argument_list|(
literal|0
argument_list|,
name|sliceLen
argument_list|,
name|ids
argument_list|,
name|scores
argument_list|,
name|totalHits
argument_list|,
name|maxScore
argument_list|)
argument_list|)
expr_stmt|;
comment|// TODO: if we collect results before the filter, we just need to intersect with
comment|// that filter to generate the DocSet for qr.setDocSet()
name|qr
operator|.
name|setDocSet
argument_list|(
name|set
argument_list|)
expr_stmt|;
comment|// TODO: currently we don't generate the DocSet for the base query,
comment|// but the QueryDocSet == CompleteDocSet if filter==null.
return|return
name|pf
operator|.
name|filter
operator|==
literal|null
operator|&&
name|pf
operator|.
name|postFilter
operator|==
literal|null
condition|?
name|qr
operator|.
name|getDocSet
argument_list|()
else|:
literal|null
return|;
block|}
comment|/**    * Returns documents matching both<code>query</code> and<code>filter</code>    * and sorted by<code>sort</code>.    * FUTURE: The returned DocList may be retrieved from a cache.    *    * @param query    * @param filter   may be null    * @param lsort    criteria by which to sort (if null, query relevance is used)    * @param offset   offset into the list of documents to return    * @param len      maximum number of documents to return    * @return DocList meeting the specified criteria, should<b>not</b> be modified by the caller.    * @throws IOException    */
DECL|method|getDocList
specifier|public
name|DocList
name|getDocList
parameter_list|(
name|Query
name|query
parameter_list|,
name|DocSet
name|filter
parameter_list|,
name|Sort
name|lsort
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|len
parameter_list|)
throws|throws
name|IOException
block|{
name|QueryCommand
name|qc
init|=
operator|new
name|QueryCommand
argument_list|()
decl_stmt|;
name|qc
operator|.
name|setQuery
argument_list|(
name|query
argument_list|)
operator|.
name|setFilter
argument_list|(
name|filter
argument_list|)
operator|.
name|setSort
argument_list|(
name|lsort
argument_list|)
operator|.
name|setOffset
argument_list|(
name|offset
argument_list|)
operator|.
name|setLen
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|QueryResult
name|qr
init|=
operator|new
name|QueryResult
argument_list|()
decl_stmt|;
name|search
argument_list|(
name|qr
argument_list|,
name|qc
argument_list|)
expr_stmt|;
return|return
name|qr
operator|.
name|getDocList
argument_list|()
return|;
block|}
comment|/**    * Returns documents matching both<code>query</code> and<code>filter</code>    * and sorted by<code>sort</code>.  Also returns the complete set of documents    * matching<code>query</code> and<code>filter</code> (regardless of<code>offset</code> and<code>len</code>).    *<p>    * This method is cache aware and may retrieve<code>filter</code> from    * the cache or make an insertion into the cache as a result of this call.    *<p>    * FUTURE: The returned DocList may be retrieved from a cache.    *<p>    * The DocList and DocSet returned should<b>not</b> be modified.    *    * @param query    * @param filter   may be null    * @param lsort    criteria by which to sort (if null, query relevance is used)    * @param offset   offset into the list of documents to return    * @param len      maximum number of documents to return    * @return DocListAndSet meeting the specified criteria, should<b>not</b> be modified by the caller.    * @throws IOException    */
DECL|method|getDocListAndSet
specifier|public
name|DocListAndSet
name|getDocListAndSet
parameter_list|(
name|Query
name|query
parameter_list|,
name|Query
name|filter
parameter_list|,
name|Sort
name|lsort
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|len
parameter_list|)
throws|throws
name|IOException
block|{
name|QueryCommand
name|qc
init|=
operator|new
name|QueryCommand
argument_list|()
decl_stmt|;
name|qc
operator|.
name|setQuery
argument_list|(
name|query
argument_list|)
operator|.
name|setFilterList
argument_list|(
name|filter
argument_list|)
operator|.
name|setSort
argument_list|(
name|lsort
argument_list|)
operator|.
name|setOffset
argument_list|(
name|offset
argument_list|)
operator|.
name|setLen
argument_list|(
name|len
argument_list|)
operator|.
name|setNeedDocSet
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|QueryResult
name|qr
init|=
operator|new
name|QueryResult
argument_list|()
decl_stmt|;
name|search
argument_list|(
name|qr
argument_list|,
name|qc
argument_list|)
expr_stmt|;
return|return
name|qr
operator|.
name|getDocListAndSet
argument_list|()
return|;
block|}
comment|/**    * Returns documents matching both<code>query</code> and<code>filter</code>    * and sorted by<code>sort</code>.  Also returns the compete set of documents    * matching<code>query</code> and<code>filter</code> (regardless of<code>offset</code> and<code>len</code>).    *<p>    * This method is cache aware and may retrieve<code>filter</code> from    * the cache or make an insertion into the cache as a result of this call.    *<p>    * FUTURE: The returned DocList may be retrieved from a cache.    *<p>    * The DocList and DocSet returned should<b>not</b> be modified.    *    * @param query    * @param filter   may be null    * @param lsort    criteria by which to sort (if null, query relevance is used)    * @param offset   offset into the list of documents to return    * @param len      maximum number of documents to return    * @param flags    user supplied flags for the result set    * @return DocListAndSet meeting the specified criteria, should<b>not</b> be modified by the caller.    * @throws IOException    */
DECL|method|getDocListAndSet
specifier|public
name|DocListAndSet
name|getDocListAndSet
parameter_list|(
name|Query
name|query
parameter_list|,
name|Query
name|filter
parameter_list|,
name|Sort
name|lsort
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|flags
parameter_list|)
throws|throws
name|IOException
block|{
name|QueryCommand
name|qc
init|=
operator|new
name|QueryCommand
argument_list|()
decl_stmt|;
name|qc
operator|.
name|setQuery
argument_list|(
name|query
argument_list|)
operator|.
name|setFilterList
argument_list|(
name|filter
argument_list|)
operator|.
name|setSort
argument_list|(
name|lsort
argument_list|)
operator|.
name|setOffset
argument_list|(
name|offset
argument_list|)
operator|.
name|setLen
argument_list|(
name|len
argument_list|)
operator|.
name|setFlags
argument_list|(
name|flags
argument_list|)
operator|.
name|setNeedDocSet
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|QueryResult
name|qr
init|=
operator|new
name|QueryResult
argument_list|()
decl_stmt|;
name|search
argument_list|(
name|qr
argument_list|,
name|qc
argument_list|)
expr_stmt|;
return|return
name|qr
operator|.
name|getDocListAndSet
argument_list|()
return|;
block|}
comment|/**    * Returns documents matching both<code>query</code> and the intersection     * of<code>filterList</code>, sorted by<code>sort</code>.      * Also returns the compete set of documents    * matching<code>query</code> and<code>filter</code>     * (regardless of<code>offset</code> and<code>len</code>).    *<p>    * This method is cache aware and may retrieve<code>filter</code> from    * the cache or make an insertion into the cache as a result of this call.    *<p>    * FUTURE: The returned DocList may be retrieved from a cache.    *<p>    * The DocList and DocSet returned should<b>not</b> be modified.    *    * @param query    * @param filterList   may be null    * @param lsort    criteria by which to sort (if null, query relevance is used)    * @param offset   offset into the list of documents to return    * @param len      maximum number of documents to return    * @return DocListAndSet meeting the specified criteria, should<b>not</b> be modified by the caller.    * @throws IOException    */
DECL|method|getDocListAndSet
specifier|public
name|DocListAndSet
name|getDocListAndSet
parameter_list|(
name|Query
name|query
parameter_list|,
name|List
argument_list|<
name|Query
argument_list|>
name|filterList
parameter_list|,
name|Sort
name|lsort
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|len
parameter_list|)
throws|throws
name|IOException
block|{
name|QueryCommand
name|qc
init|=
operator|new
name|QueryCommand
argument_list|()
decl_stmt|;
name|qc
operator|.
name|setQuery
argument_list|(
name|query
argument_list|)
operator|.
name|setFilterList
argument_list|(
name|filterList
argument_list|)
operator|.
name|setSort
argument_list|(
name|lsort
argument_list|)
operator|.
name|setOffset
argument_list|(
name|offset
argument_list|)
operator|.
name|setLen
argument_list|(
name|len
argument_list|)
operator|.
name|setNeedDocSet
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|QueryResult
name|qr
init|=
operator|new
name|QueryResult
argument_list|()
decl_stmt|;
name|search
argument_list|(
name|qr
argument_list|,
name|qc
argument_list|)
expr_stmt|;
return|return
name|qr
operator|.
name|getDocListAndSet
argument_list|()
return|;
block|}
comment|/**    * Returns documents matching both<code>query</code> and the intersection     * of<code>filterList</code>, sorted by<code>sort</code>.      * Also returns the compete set of documents    * matching<code>query</code> and<code>filter</code>     * (regardless of<code>offset</code> and<code>len</code>).    *<p>    * This method is cache aware and may retrieve<code>filter</code> from    * the cache or make an insertion into the cache as a result of this call.    *<p>    * FUTURE: The returned DocList may be retrieved from a cache.    *<p>    * The DocList and DocSet returned should<b>not</b> be modified.    *    * @param query    * @param filterList   may be null    * @param lsort    criteria by which to sort (if null, query relevance is used)    * @param offset   offset into the list of documents to return    * @param len      maximum number of documents to return    * @param flags    user supplied flags for the result set    * @return DocListAndSet meeting the specified criteria, should<b>not</b> be modified by the caller.    * @throws IOException    */
DECL|method|getDocListAndSet
specifier|public
name|DocListAndSet
name|getDocListAndSet
parameter_list|(
name|Query
name|query
parameter_list|,
name|List
argument_list|<
name|Query
argument_list|>
name|filterList
parameter_list|,
name|Sort
name|lsort
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|flags
parameter_list|)
throws|throws
name|IOException
block|{
name|QueryCommand
name|qc
init|=
operator|new
name|QueryCommand
argument_list|()
decl_stmt|;
name|qc
operator|.
name|setQuery
argument_list|(
name|query
argument_list|)
operator|.
name|setFilterList
argument_list|(
name|filterList
argument_list|)
operator|.
name|setSort
argument_list|(
name|lsort
argument_list|)
operator|.
name|setOffset
argument_list|(
name|offset
argument_list|)
operator|.
name|setLen
argument_list|(
name|len
argument_list|)
operator|.
name|setFlags
argument_list|(
name|flags
argument_list|)
operator|.
name|setNeedDocSet
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|QueryResult
name|qr
init|=
operator|new
name|QueryResult
argument_list|()
decl_stmt|;
name|search
argument_list|(
name|qr
argument_list|,
name|qc
argument_list|)
expr_stmt|;
return|return
name|qr
operator|.
name|getDocListAndSet
argument_list|()
return|;
block|}
comment|/**    * Returns documents matching both<code>query</code> and<code>filter</code>    * and sorted by<code>sort</code>. Also returns the compete set of documents    * matching<code>query</code> and<code>filter</code> (regardless of<code>offset</code> and<code>len</code>).    *<p>    * FUTURE: The returned DocList may be retrieved from a cache.    *    * @param query    * @param filter   may be null    * @param lsort    criteria by which to sort (if null, query relevance is used)    * @param offset   offset into the list of documents to return    * @param len      maximum number of documents to return    * @return DocListAndSet meeting the specified criteria, should<b>not</b> be modified by the caller.    * @throws IOException    */
DECL|method|getDocListAndSet
specifier|public
name|DocListAndSet
name|getDocListAndSet
parameter_list|(
name|Query
name|query
parameter_list|,
name|DocSet
name|filter
parameter_list|,
name|Sort
name|lsort
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|len
parameter_list|)
throws|throws
name|IOException
block|{
name|QueryCommand
name|qc
init|=
operator|new
name|QueryCommand
argument_list|()
decl_stmt|;
name|qc
operator|.
name|setQuery
argument_list|(
name|query
argument_list|)
operator|.
name|setFilter
argument_list|(
name|filter
argument_list|)
operator|.
name|setSort
argument_list|(
name|lsort
argument_list|)
operator|.
name|setOffset
argument_list|(
name|offset
argument_list|)
operator|.
name|setLen
argument_list|(
name|len
argument_list|)
operator|.
name|setNeedDocSet
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|QueryResult
name|qr
init|=
operator|new
name|QueryResult
argument_list|()
decl_stmt|;
name|search
argument_list|(
name|qr
argument_list|,
name|qc
argument_list|)
expr_stmt|;
return|return
name|qr
operator|.
name|getDocListAndSet
argument_list|()
return|;
block|}
comment|/**    * Returns documents matching both<code>query</code> and<code>filter</code>    * and sorted by<code>sort</code>.  Also returns the compete set of documents    * matching<code>query</code> and<code>filter</code> (regardless of<code>offset</code> and<code>len</code>).    *<p>    * This method is cache aware and may make an insertion into the cache     * as a result of this call.    *<p>    * FUTURE: The returned DocList may be retrieved from a cache.    *<p>    * The DocList and DocSet returned should<b>not</b> be modified.    *    * @param query    * @param filter   may be null    * @param lsort    criteria by which to sort (if null, query relevance is used)    * @param offset   offset into the list of documents to return    * @param len      maximum number of documents to return    * @param flags    user supplied flags for the result set    * @return DocListAndSet meeting the specified criteria, should<b>not</b> be modified by the caller.    * @throws IOException    */
DECL|method|getDocListAndSet
specifier|public
name|DocListAndSet
name|getDocListAndSet
parameter_list|(
name|Query
name|query
parameter_list|,
name|DocSet
name|filter
parameter_list|,
name|Sort
name|lsort
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|flags
parameter_list|)
throws|throws
name|IOException
block|{
name|QueryCommand
name|qc
init|=
operator|new
name|QueryCommand
argument_list|()
decl_stmt|;
name|qc
operator|.
name|setQuery
argument_list|(
name|query
argument_list|)
operator|.
name|setFilter
argument_list|(
name|filter
argument_list|)
operator|.
name|setSort
argument_list|(
name|lsort
argument_list|)
operator|.
name|setOffset
argument_list|(
name|offset
argument_list|)
operator|.
name|setLen
argument_list|(
name|len
argument_list|)
operator|.
name|setFlags
argument_list|(
name|flags
argument_list|)
operator|.
name|setNeedDocSet
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|QueryResult
name|qr
init|=
operator|new
name|QueryResult
argument_list|()
decl_stmt|;
name|search
argument_list|(
name|qr
argument_list|,
name|qc
argument_list|)
expr_stmt|;
return|return
name|qr
operator|.
name|getDocListAndSet
argument_list|()
return|;
block|}
DECL|method|sortDocSet
specifier|protected
name|DocList
name|sortDocSet
parameter_list|(
name|DocSet
name|set
parameter_list|,
name|Sort
name|sort
parameter_list|,
name|int
name|nDocs
parameter_list|)
throws|throws
name|IOException
block|{
comment|// bit of a hack to tell if a set is sorted - do it better in the futute.
name|boolean
name|inOrder
init|=
name|set
operator|instanceof
name|BitDocSet
operator|||
name|set
operator|instanceof
name|SortedIntDocSet
decl_stmt|;
name|TopDocsCollector
name|topCollector
init|=
name|TopFieldCollector
operator|.
name|create
argument_list|(
name|weightSort
argument_list|(
name|sort
argument_list|)
argument_list|,
name|nDocs
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|,
name|inOrder
argument_list|)
decl_stmt|;
name|DocIterator
name|iter
init|=
name|set
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|int
name|base
init|=
literal|0
decl_stmt|;
name|int
name|end
init|=
literal|0
decl_stmt|;
name|int
name|readerIndex
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|iter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|int
name|doc
init|=
name|iter
operator|.
name|nextDoc
argument_list|()
decl_stmt|;
while|while
condition|(
name|doc
operator|>=
name|end
condition|)
block|{
name|AtomicReaderContext
name|leaf
init|=
name|leafContexts
index|[
name|readerIndex
operator|++
index|]
decl_stmt|;
name|base
operator|=
name|leaf
operator|.
name|docBase
expr_stmt|;
name|end
operator|=
name|base
operator|+
name|leaf
operator|.
name|reader
operator|.
name|maxDoc
argument_list|()
expr_stmt|;
name|topCollector
operator|.
name|setNextReader
argument_list|(
name|leaf
argument_list|)
expr_stmt|;
comment|// we should never need to set the scorer given the settings for the collector
block|}
name|topCollector
operator|.
name|collect
argument_list|(
name|doc
operator|-
name|base
argument_list|)
expr_stmt|;
block|}
name|TopDocs
name|topDocs
init|=
name|topCollector
operator|.
name|topDocs
argument_list|(
literal|0
argument_list|,
name|nDocs
argument_list|)
decl_stmt|;
name|int
name|nDocsReturned
init|=
name|topDocs
operator|.
name|scoreDocs
operator|.
name|length
decl_stmt|;
name|int
index|[]
name|ids
init|=
operator|new
name|int
index|[
name|nDocsReturned
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nDocsReturned
condition|;
name|i
operator|++
control|)
block|{
name|ScoreDoc
name|scoreDoc
init|=
name|topDocs
operator|.
name|scoreDocs
index|[
name|i
index|]
decl_stmt|;
name|ids
index|[
name|i
index|]
operator|=
name|scoreDoc
operator|.
name|doc
expr_stmt|;
block|}
return|return
operator|new
name|DocSlice
argument_list|(
literal|0
argument_list|,
name|nDocsReturned
argument_list|,
name|ids
argument_list|,
literal|null
argument_list|,
name|topDocs
operator|.
name|totalHits
argument_list|,
literal|0.0f
argument_list|)
return|;
block|}
comment|/**    * Returns the number of documents that match both<code>a</code> and<code>b</code>.    *<p>    * This method is cache-aware and may check as well as modify the cache.    *    * @param a    * @param b    * @return the numer of documents in the intersection between<code>a</code> and<code>b</code>.    * @throws IOException    */
DECL|method|numDocs
specifier|public
name|int
name|numDocs
parameter_list|(
name|Query
name|a
parameter_list|,
name|DocSet
name|b
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Negative query if absolute value different from original
name|Query
name|absQ
init|=
name|QueryUtils
operator|.
name|getAbs
argument_list|(
name|a
argument_list|)
decl_stmt|;
name|DocSet
name|positiveA
init|=
name|getPositiveDocSet
argument_list|(
name|absQ
argument_list|)
decl_stmt|;
return|return
name|a
operator|==
name|absQ
condition|?
name|b
operator|.
name|intersectionSize
argument_list|(
name|positiveA
argument_list|)
else|:
name|b
operator|.
name|andNotSize
argument_list|(
name|positiveA
argument_list|)
return|;
block|}
comment|/** @lucene.internal */
DECL|method|numDocs
specifier|public
name|int
name|numDocs
parameter_list|(
name|DocSet
name|a
parameter_list|,
name|DocsEnumState
name|deState
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Negative query if absolute value different from original
return|return
name|a
operator|.
name|intersectionSize
argument_list|(
name|getDocSet
argument_list|(
name|deState
argument_list|)
argument_list|)
return|;
block|}
DECL|class|DocsEnumState
specifier|public
specifier|static
class|class
name|DocsEnumState
block|{
DECL|field|fieldName
specifier|public
name|String
name|fieldName
decl_stmt|;
comment|// currently interned for as long as lucene requires it
DECL|field|termsEnum
specifier|public
name|TermsEnum
name|termsEnum
decl_stmt|;
DECL|field|liveDocs
specifier|public
name|Bits
name|liveDocs
decl_stmt|;
DECL|field|docsEnum
specifier|public
name|DocsEnum
name|docsEnum
decl_stmt|;
DECL|field|minSetSizeCached
specifier|public
name|int
name|minSetSizeCached
decl_stmt|;
DECL|field|scratch
specifier|public
name|int
index|[]
name|scratch
decl_stmt|;
block|}
comment|/**    * Returns the number of documents that match both<code>a</code> and<code>b</code>.    *<p>    * This method is cache-aware and may check as well as modify the cache.    *    * @param a    * @param b    * @return the numer of documents in the intersection between<code>a</code> and<code>b</code>.    * @throws IOException    */
DECL|method|numDocs
specifier|public
name|int
name|numDocs
parameter_list|(
name|Query
name|a
parameter_list|,
name|Query
name|b
parameter_list|)
throws|throws
name|IOException
block|{
name|Query
name|absA
init|=
name|QueryUtils
operator|.
name|getAbs
argument_list|(
name|a
argument_list|)
decl_stmt|;
name|Query
name|absB
init|=
name|QueryUtils
operator|.
name|getAbs
argument_list|(
name|b
argument_list|)
decl_stmt|;
name|DocSet
name|positiveA
init|=
name|getPositiveDocSet
argument_list|(
name|absA
argument_list|)
decl_stmt|;
name|DocSet
name|positiveB
init|=
name|getPositiveDocSet
argument_list|(
name|absB
argument_list|)
decl_stmt|;
comment|// Negative query if absolute value different from original
if|if
condition|(
name|a
operator|==
name|absA
condition|)
block|{
if|if
condition|(
name|b
operator|==
name|absB
condition|)
return|return
name|positiveA
operator|.
name|intersectionSize
argument_list|(
name|positiveB
argument_list|)
return|;
return|return
name|positiveA
operator|.
name|andNotSize
argument_list|(
name|positiveB
argument_list|)
return|;
block|}
if|if
condition|(
name|b
operator|==
name|absB
condition|)
return|return
name|positiveB
operator|.
name|andNotSize
argument_list|(
name|positiveA
argument_list|)
return|;
comment|// if both negative, we need to create a temp DocSet since we
comment|// don't have a counting method that takes three.
name|DocSet
name|all
init|=
name|getPositiveDocSet
argument_list|(
name|matchAllDocsQuery
argument_list|)
decl_stmt|;
comment|// -a -b == *:*.andNot(a).andNotSize(b) == *.*.andNotSize(a.union(b))
comment|// we use the last form since the intermediate DocSet should normally be smaller.
return|return
name|all
operator|.
name|andNotSize
argument_list|(
name|positiveA
operator|.
name|union
argument_list|(
name|positiveB
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Takes a list of docs (the doc ids actually), and returns an array     * of Documents containing all of the stored fields.    */
DECL|method|readDocs
specifier|public
name|Document
index|[]
name|readDocs
parameter_list|(
name|DocList
name|ids
parameter_list|)
throws|throws
name|IOException
block|{
name|Document
index|[]
name|docs
init|=
operator|new
name|Document
index|[
name|ids
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
name|readDocs
argument_list|(
name|docs
argument_list|,
name|ids
argument_list|)
expr_stmt|;
return|return
name|docs
return|;
block|}
comment|/**    * Warm this searcher based on an old one (primarily for auto-cache warming).    */
DECL|method|warm
specifier|public
name|void
name|warm
parameter_list|(
name|SolrIndexSearcher
name|old
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Make sure this is first!  filters can help queryResults execute!
name|boolean
name|logme
init|=
name|log
operator|.
name|isInfoEnabled
argument_list|()
decl_stmt|;
name|long
name|warmingStartTime
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
comment|// warm the caches in order...
name|ModifiableSolrParams
name|params
init|=
operator|new
name|ModifiableSolrParams
argument_list|()
decl_stmt|;
name|params
operator|.
name|add
argument_list|(
literal|"warming"
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|cacheList
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|logme
condition|)
name|log
operator|.
name|info
argument_list|(
literal|"autowarming "
operator|+
name|this
operator|+
literal|" from "
operator|+
name|old
operator|+
literal|"\n\t"
operator|+
name|old
operator|.
name|cacheList
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|SolrQueryRequest
name|req
init|=
operator|new
name|LocalSolrQueryRequest
argument_list|(
name|core
argument_list|,
name|params
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|SolrIndexSearcher
name|getSearcher
parameter_list|()
block|{
return|return
name|SolrIndexSearcher
operator|.
name|this
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|close
parameter_list|()
block|{ }
block|}
decl_stmt|;
name|SolrQueryResponse
name|rsp
init|=
operator|new
name|SolrQueryResponse
argument_list|()
decl_stmt|;
name|SolrRequestInfo
operator|.
name|setRequestInfo
argument_list|(
operator|new
name|SolrRequestInfo
argument_list|(
name|req
argument_list|,
name|rsp
argument_list|)
argument_list|)
expr_stmt|;
try|try
block|{
name|this
operator|.
name|cacheList
index|[
name|i
index|]
operator|.
name|warm
argument_list|(
name|this
argument_list|,
name|old
operator|.
name|cacheList
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
try|try
block|{
name|req
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|SolrRequestInfo
operator|.
name|clearRequestInfo
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|logme
condition|)
name|log
operator|.
name|info
argument_list|(
literal|"autowarming result for "
operator|+
name|this
operator|+
literal|"\n\t"
operator|+
name|this
operator|.
name|cacheList
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|warmupTime
operator|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|-
name|warmingStartTime
expr_stmt|;
block|}
comment|/**    * return the named generic cache    */
DECL|method|getCache
specifier|public
name|SolrCache
name|getCache
parameter_list|(
name|String
name|cacheName
parameter_list|)
block|{
return|return
name|cacheMap
operator|.
name|get
argument_list|(
name|cacheName
argument_list|)
return|;
block|}
comment|/**    * lookup an entry in a generic cache    */
DECL|method|cacheLookup
specifier|public
name|Object
name|cacheLookup
parameter_list|(
name|String
name|cacheName
parameter_list|,
name|Object
name|key
parameter_list|)
block|{
name|SolrCache
name|cache
init|=
name|cacheMap
operator|.
name|get
argument_list|(
name|cacheName
argument_list|)
decl_stmt|;
return|return
name|cache
operator|==
literal|null
condition|?
literal|null
else|:
name|cache
operator|.
name|get
argument_list|(
name|key
argument_list|)
return|;
block|}
comment|/**    * insert an entry in a generic cache    */
DECL|method|cacheInsert
specifier|public
name|Object
name|cacheInsert
parameter_list|(
name|String
name|cacheName
parameter_list|,
name|Object
name|key
parameter_list|,
name|Object
name|val
parameter_list|)
block|{
name|SolrCache
name|cache
init|=
name|cacheMap
operator|.
name|get
argument_list|(
name|cacheName
argument_list|)
decl_stmt|;
return|return
name|cache
operator|==
literal|null
condition|?
literal|null
else|:
name|cache
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|val
argument_list|)
return|;
block|}
DECL|method|getOpenTime
specifier|public
name|long
name|getOpenTime
parameter_list|()
block|{
return|return
name|openTime
return|;
block|}
annotation|@
name|Override
DECL|method|explain
specifier|public
name|Explanation
name|explain
parameter_list|(
name|Query
name|query
parameter_list|,
name|int
name|doc
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|super
operator|.
name|explain
argument_list|(
name|QueryUtils
operator|.
name|makeQueryable
argument_list|(
name|query
argument_list|)
argument_list|,
name|doc
argument_list|)
return|;
block|}
comment|/////////////////////////////////////////////////////////////////////
comment|// SolrInfoMBean stuff: Statistics and Module Info
comment|/////////////////////////////////////////////////////////////////////
DECL|method|getName
specifier|public
name|String
name|getName
parameter_list|()
block|{
return|return
name|SolrIndexSearcher
operator|.
name|class
operator|.
name|getName
argument_list|()
return|;
block|}
DECL|method|getVersion
specifier|public
name|String
name|getVersion
parameter_list|()
block|{
return|return
name|SolrCore
operator|.
name|version
return|;
block|}
DECL|method|getDescription
specifier|public
name|String
name|getDescription
parameter_list|()
block|{
return|return
literal|"index searcher"
return|;
block|}
DECL|method|getCategory
specifier|public
name|Category
name|getCategory
parameter_list|()
block|{
return|return
name|Category
operator|.
name|CORE
return|;
block|}
DECL|method|getSourceId
specifier|public
name|String
name|getSourceId
parameter_list|()
block|{
return|return
literal|"$Id$"
return|;
block|}
DECL|method|getSource
specifier|public
name|String
name|getSource
parameter_list|()
block|{
return|return
literal|"$URL$"
return|;
block|}
DECL|method|getDocs
specifier|public
name|URL
index|[]
name|getDocs
parameter_list|()
block|{
return|return
literal|null
return|;
block|}
DECL|method|getStatistics
specifier|public
name|NamedList
argument_list|<
name|Object
argument_list|>
name|getStatistics
parameter_list|()
block|{
name|NamedList
argument_list|<
name|Object
argument_list|>
name|lst
init|=
operator|new
name|SimpleOrderedMap
argument_list|<
name|Object
argument_list|>
argument_list|()
decl_stmt|;
name|lst
operator|.
name|add
argument_list|(
literal|"searcherName"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|lst
operator|.
name|add
argument_list|(
literal|"caching"
argument_list|,
name|cachingEnabled
argument_list|)
expr_stmt|;
name|lst
operator|.
name|add
argument_list|(
literal|"numDocs"
argument_list|,
name|reader
operator|.
name|numDocs
argument_list|()
argument_list|)
expr_stmt|;
name|lst
operator|.
name|add
argument_list|(
literal|"maxDoc"
argument_list|,
name|reader
operator|.
name|maxDoc
argument_list|()
argument_list|)
expr_stmt|;
name|lst
operator|.
name|add
argument_list|(
literal|"reader"
argument_list|,
name|reader
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|lst
operator|.
name|add
argument_list|(
literal|"readerDir"
argument_list|,
name|reader
operator|.
name|directory
argument_list|()
argument_list|)
expr_stmt|;
name|lst
operator|.
name|add
argument_list|(
literal|"indexVersion"
argument_list|,
name|reader
operator|.
name|getVersion
argument_list|()
argument_list|)
expr_stmt|;
name|lst
operator|.
name|add
argument_list|(
literal|"openedAt"
argument_list|,
operator|new
name|Date
argument_list|(
name|openTime
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|registerTime
operator|!=
literal|0
condition|)
name|lst
operator|.
name|add
argument_list|(
literal|"registeredAt"
argument_list|,
operator|new
name|Date
argument_list|(
name|registerTime
argument_list|)
argument_list|)
expr_stmt|;
name|lst
operator|.
name|add
argument_list|(
literal|"warmupTime"
argument_list|,
name|warmupTime
argument_list|)
expr_stmt|;
return|return
name|lst
return|;
block|}
comment|/**    * A query request command to avoid having to change the method signatures    * if we want to pass additional information to the searcher.    */
DECL|class|QueryCommand
specifier|public
specifier|static
class|class
name|QueryCommand
block|{
DECL|field|query
specifier|private
name|Query
name|query
decl_stmt|;
DECL|field|filterList
specifier|private
name|List
argument_list|<
name|Query
argument_list|>
name|filterList
decl_stmt|;
DECL|field|filter
specifier|private
name|DocSet
name|filter
decl_stmt|;
DECL|field|sort
specifier|private
name|Sort
name|sort
decl_stmt|;
DECL|field|offset
specifier|private
name|int
name|offset
decl_stmt|;
DECL|field|len
specifier|private
name|int
name|len
decl_stmt|;
DECL|field|supersetMaxDoc
specifier|private
name|int
name|supersetMaxDoc
decl_stmt|;
DECL|field|flags
specifier|private
name|int
name|flags
decl_stmt|;
DECL|field|timeAllowed
specifier|private
name|long
name|timeAllowed
init|=
operator|-
literal|1
decl_stmt|;
comment|// public List<Grouping.Command> groupCommands;
DECL|method|getQuery
specifier|public
name|Query
name|getQuery
parameter_list|()
block|{
return|return
name|query
return|;
block|}
DECL|method|setQuery
specifier|public
name|QueryCommand
name|setQuery
parameter_list|(
name|Query
name|query
parameter_list|)
block|{
name|this
operator|.
name|query
operator|=
name|query
expr_stmt|;
return|return
name|this
return|;
block|}
DECL|method|getFilterList
specifier|public
name|List
argument_list|<
name|Query
argument_list|>
name|getFilterList
parameter_list|()
block|{
return|return
name|filterList
return|;
block|}
comment|/**      * @throws IllegalArgumentException if filter is not null.      */
DECL|method|setFilterList
specifier|public
name|QueryCommand
name|setFilterList
parameter_list|(
name|List
argument_list|<
name|Query
argument_list|>
name|filterList
parameter_list|)
block|{
if|if
condition|(
name|filter
operator|!=
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Either filter or filterList may be set in the QueryCommand, but not both."
argument_list|)
throw|;
block|}
name|this
operator|.
name|filterList
operator|=
name|filterList
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**      * A simple setter to build a filterList from a query      * @throws IllegalArgumentException if filter is not null.      */
DECL|method|setFilterList
specifier|public
name|QueryCommand
name|setFilterList
parameter_list|(
name|Query
name|f
parameter_list|)
block|{
if|if
condition|(
name|filter
operator|!=
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Either filter or filterList may be set in the QueryCommand, but not both."
argument_list|)
throw|;
block|}
name|filterList
operator|=
literal|null
expr_stmt|;
if|if
condition|(
name|f
operator|!=
literal|null
condition|)
block|{
name|filterList
operator|=
operator|new
name|ArrayList
argument_list|<
name|Query
argument_list|>
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|filterList
operator|.
name|add
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
return|return
name|this
return|;
block|}
DECL|method|getFilter
specifier|public
name|DocSet
name|getFilter
parameter_list|()
block|{
return|return
name|filter
return|;
block|}
comment|/**      * @throws IllegalArgumentException if filterList is not null.      */
DECL|method|setFilter
specifier|public
name|QueryCommand
name|setFilter
parameter_list|(
name|DocSet
name|filter
parameter_list|)
block|{
if|if
condition|(
name|filterList
operator|!=
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Either filter or filterList may be set in the QueryCommand, but not both."
argument_list|)
throw|;
block|}
name|this
operator|.
name|filter
operator|=
name|filter
expr_stmt|;
return|return
name|this
return|;
block|}
DECL|method|getSort
specifier|public
name|Sort
name|getSort
parameter_list|()
block|{
return|return
name|sort
return|;
block|}
DECL|method|setSort
specifier|public
name|QueryCommand
name|setSort
parameter_list|(
name|Sort
name|sort
parameter_list|)
block|{
name|this
operator|.
name|sort
operator|=
name|sort
expr_stmt|;
return|return
name|this
return|;
block|}
DECL|method|getOffset
specifier|public
name|int
name|getOffset
parameter_list|()
block|{
return|return
name|offset
return|;
block|}
DECL|method|setOffset
specifier|public
name|QueryCommand
name|setOffset
parameter_list|(
name|int
name|offset
parameter_list|)
block|{
name|this
operator|.
name|offset
operator|=
name|offset
expr_stmt|;
return|return
name|this
return|;
block|}
DECL|method|getLen
specifier|public
name|int
name|getLen
parameter_list|()
block|{
return|return
name|len
return|;
block|}
DECL|method|setLen
specifier|public
name|QueryCommand
name|setLen
parameter_list|(
name|int
name|len
parameter_list|)
block|{
name|this
operator|.
name|len
operator|=
name|len
expr_stmt|;
return|return
name|this
return|;
block|}
DECL|method|getSupersetMaxDoc
specifier|public
name|int
name|getSupersetMaxDoc
parameter_list|()
block|{
return|return
name|supersetMaxDoc
return|;
block|}
DECL|method|setSupersetMaxDoc
specifier|public
name|QueryCommand
name|setSupersetMaxDoc
parameter_list|(
name|int
name|supersetMaxDoc
parameter_list|)
block|{
name|this
operator|.
name|supersetMaxDoc
operator|=
name|supersetMaxDoc
expr_stmt|;
return|return
name|this
return|;
block|}
DECL|method|getFlags
specifier|public
name|int
name|getFlags
parameter_list|()
block|{
return|return
name|flags
return|;
block|}
DECL|method|replaceFlags
specifier|public
name|QueryCommand
name|replaceFlags
parameter_list|(
name|int
name|flags
parameter_list|)
block|{
name|this
operator|.
name|flags
operator|=
name|flags
expr_stmt|;
return|return
name|this
return|;
block|}
DECL|method|setFlags
specifier|public
name|QueryCommand
name|setFlags
parameter_list|(
name|int
name|flags
parameter_list|)
block|{
name|this
operator|.
name|flags
operator||=
name|flags
expr_stmt|;
return|return
name|this
return|;
block|}
DECL|method|clearFlags
specifier|public
name|QueryCommand
name|clearFlags
parameter_list|(
name|int
name|flags
parameter_list|)
block|{
name|this
operator|.
name|flags
operator|&=
operator|~
name|flags
expr_stmt|;
return|return
name|this
return|;
block|}
DECL|method|getTimeAllowed
specifier|public
name|long
name|getTimeAllowed
parameter_list|()
block|{
return|return
name|timeAllowed
return|;
block|}
DECL|method|setTimeAllowed
specifier|public
name|QueryCommand
name|setTimeAllowed
parameter_list|(
name|long
name|timeAllowed
parameter_list|)
block|{
name|this
operator|.
name|timeAllowed
operator|=
name|timeAllowed
expr_stmt|;
return|return
name|this
return|;
block|}
DECL|method|isNeedDocSet
specifier|public
name|boolean
name|isNeedDocSet
parameter_list|()
block|{
return|return
operator|(
name|flags
operator|&
name|GET_DOCSET
operator|)
operator|!=
literal|0
return|;
block|}
DECL|method|setNeedDocSet
specifier|public
name|QueryCommand
name|setNeedDocSet
parameter_list|(
name|boolean
name|needDocSet
parameter_list|)
block|{
return|return
name|needDocSet
condition|?
name|setFlags
argument_list|(
name|GET_DOCSET
argument_list|)
else|:
name|clearFlags
argument_list|(
name|GET_DOCSET
argument_list|)
return|;
block|}
block|}
comment|/**    * The result of a search.    */
DECL|class|QueryResult
specifier|public
specifier|static
class|class
name|QueryResult
block|{
DECL|field|partialResults
specifier|private
name|boolean
name|partialResults
decl_stmt|;
DECL|field|docListAndSet
specifier|private
name|DocListAndSet
name|docListAndSet
decl_stmt|;
DECL|field|groupedResults
specifier|public
name|Object
name|groupedResults
decl_stmt|;
comment|// TODO: currently for testing
DECL|method|getDocList
specifier|public
name|DocList
name|getDocList
parameter_list|()
block|{
return|return
name|docListAndSet
operator|.
name|docList
return|;
block|}
DECL|method|setDocList
specifier|public
name|void
name|setDocList
parameter_list|(
name|DocList
name|list
parameter_list|)
block|{
if|if
condition|(
name|docListAndSet
operator|==
literal|null
condition|)
block|{
name|docListAndSet
operator|=
operator|new
name|DocListAndSet
argument_list|()
expr_stmt|;
block|}
name|docListAndSet
operator|.
name|docList
operator|=
name|list
expr_stmt|;
block|}
DECL|method|getDocSet
specifier|public
name|DocSet
name|getDocSet
parameter_list|()
block|{
return|return
name|docListAndSet
operator|.
name|docSet
return|;
block|}
DECL|method|setDocSet
specifier|public
name|void
name|setDocSet
parameter_list|(
name|DocSet
name|set
parameter_list|)
block|{
if|if
condition|(
name|docListAndSet
operator|==
literal|null
condition|)
block|{
name|docListAndSet
operator|=
operator|new
name|DocListAndSet
argument_list|()
expr_stmt|;
block|}
name|docListAndSet
operator|.
name|docSet
operator|=
name|set
expr_stmt|;
block|}
DECL|method|isPartialResults
specifier|public
name|boolean
name|isPartialResults
parameter_list|()
block|{
return|return
name|partialResults
return|;
block|}
DECL|method|setPartialResults
specifier|public
name|void
name|setPartialResults
parameter_list|(
name|boolean
name|partialResults
parameter_list|)
block|{
name|this
operator|.
name|partialResults
operator|=
name|partialResults
expr_stmt|;
block|}
DECL|method|setDocListAndSet
specifier|public
name|void
name|setDocListAndSet
parameter_list|(
name|DocListAndSet
name|listSet
parameter_list|)
block|{
name|docListAndSet
operator|=
name|listSet
expr_stmt|;
block|}
DECL|method|getDocListAndSet
specifier|public
name|DocListAndSet
name|getDocListAndSet
parameter_list|()
block|{
return|return
name|docListAndSet
return|;
block|}
block|}
block|}
end_class
begin_class
DECL|class|FilterImpl
class|class
name|FilterImpl
extends|extends
name|Filter
block|{
DECL|field|filter
specifier|final
name|DocSet
name|filter
decl_stmt|;
DECL|field|topFilter
specifier|final
name|Filter
name|topFilter
decl_stmt|;
DECL|field|weights
specifier|final
name|List
argument_list|<
name|Weight
argument_list|>
name|weights
decl_stmt|;
DECL|method|FilterImpl
specifier|public
name|FilterImpl
parameter_list|(
name|DocSet
name|filter
parameter_list|,
name|List
argument_list|<
name|Weight
argument_list|>
name|weights
parameter_list|)
block|{
name|this
operator|.
name|filter
operator|=
name|filter
expr_stmt|;
name|this
operator|.
name|weights
operator|=
name|weights
expr_stmt|;
name|this
operator|.
name|topFilter
operator|=
name|filter
operator|==
literal|null
condition|?
literal|null
else|:
name|filter
operator|.
name|getTopFilter
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|getDocIdSet
specifier|public
name|DocIdSet
name|getDocIdSet
parameter_list|(
name|AtomicReaderContext
name|context
parameter_list|,
name|Bits
name|acceptDocs
parameter_list|)
throws|throws
name|IOException
block|{
name|DocIdSet
name|sub
init|=
name|topFilter
operator|==
literal|null
condition|?
literal|null
else|:
name|topFilter
operator|.
name|getDocIdSet
argument_list|(
name|context
argument_list|,
name|acceptDocs
argument_list|)
decl_stmt|;
if|if
condition|(
name|weights
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
return|return
name|sub
return|;
return|return
operator|new
name|FilterSet
argument_list|(
name|sub
argument_list|,
name|context
argument_list|)
return|;
block|}
DECL|class|FilterSet
specifier|private
class|class
name|FilterSet
extends|extends
name|DocIdSet
block|{
DECL|field|docIdSet
name|DocIdSet
name|docIdSet
decl_stmt|;
DECL|field|context
name|AtomicReaderContext
name|context
decl_stmt|;
DECL|method|FilterSet
specifier|public
name|FilterSet
parameter_list|(
name|DocIdSet
name|docIdSet
parameter_list|,
name|AtomicReaderContext
name|context
parameter_list|)
block|{
name|this
operator|.
name|docIdSet
operator|=
name|docIdSet
expr_stmt|;
name|this
operator|.
name|context
operator|=
name|context
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|iterator
specifier|public
name|DocIdSetIterator
name|iterator
parameter_list|()
throws|throws
name|IOException
block|{
name|List
argument_list|<
name|DocIdSetIterator
argument_list|>
name|iterators
init|=
operator|new
name|ArrayList
argument_list|<
name|DocIdSetIterator
argument_list|>
argument_list|(
name|weights
operator|.
name|size
argument_list|()
operator|+
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|docIdSet
operator|!=
literal|null
condition|)
block|{
name|DocIdSetIterator
name|iter
init|=
name|docIdSet
operator|.
name|iterator
argument_list|()
decl_stmt|;
if|if
condition|(
name|iter
operator|==
literal|null
condition|)
return|return
literal|null
return|;
name|iterators
operator|.
name|add
argument_list|(
name|iter
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|Weight
name|w
range|:
name|weights
control|)
block|{
name|Scorer
name|scorer
init|=
name|w
operator|.
name|scorer
argument_list|(
name|context
argument_list|,
literal|true
argument_list|,
literal|false
argument_list|,
name|context
operator|.
name|reader
operator|.
name|getLiveDocs
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|scorer
operator|==
literal|null
condition|)
return|return
literal|null
return|;
name|iterators
operator|.
name|add
argument_list|(
name|scorer
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|iterators
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
return|return
literal|null
return|;
if|if
condition|(
name|iterators
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
return|return
name|iterators
operator|.
name|get
argument_list|(
literal|0
argument_list|)
return|;
if|if
condition|(
name|iterators
operator|.
name|size
argument_list|()
operator|==
literal|2
condition|)
return|return
operator|new
name|DualFilterIterator
argument_list|(
name|iterators
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
name|iterators
operator|.
name|get
argument_list|(
literal|1
argument_list|)
argument_list|)
return|;
return|return
operator|new
name|FilterIterator
argument_list|(
name|iterators
operator|.
name|toArray
argument_list|(
operator|new
name|DocIdSetIterator
index|[
name|iterators
operator|.
name|size
argument_list|()
index|]
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|bits
specifier|public
name|Bits
name|bits
parameter_list|()
throws|throws
name|IOException
block|{
return|return
literal|null
return|;
comment|// don't use random access
block|}
block|}
DECL|class|FilterIterator
specifier|private
specifier|static
class|class
name|FilterIterator
extends|extends
name|DocIdSetIterator
block|{
DECL|field|iterators
specifier|final
name|DocIdSetIterator
index|[]
name|iterators
decl_stmt|;
DECL|field|first
specifier|final
name|DocIdSetIterator
name|first
decl_stmt|;
DECL|method|FilterIterator
specifier|public
name|FilterIterator
parameter_list|(
name|DocIdSetIterator
index|[]
name|iterators
parameter_list|)
block|{
name|this
operator|.
name|iterators
operator|=
name|iterators
expr_stmt|;
name|this
operator|.
name|first
operator|=
name|iterators
index|[
literal|0
index|]
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|docID
specifier|public
name|int
name|docID
parameter_list|()
block|{
return|return
name|first
operator|.
name|docID
argument_list|()
return|;
block|}
DECL|method|doNext
specifier|private
name|int
name|doNext
parameter_list|(
name|int
name|doc
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|which
init|=
literal|0
decl_stmt|;
comment|// index of the iterator with the highest id
name|int
name|i
init|=
literal|1
decl_stmt|;
name|outer
label|:
for|for
control|(
init|;
condition|;
control|)
block|{
for|for
control|(
init|;
name|i
operator|<
name|iterators
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|==
name|which
condition|)
continue|continue;
name|DocIdSetIterator
name|iter
init|=
name|iterators
index|[
name|i
index|]
decl_stmt|;
name|int
name|next
init|=
name|iter
operator|.
name|advance
argument_list|(
name|doc
argument_list|)
decl_stmt|;
if|if
condition|(
name|next
operator|!=
name|doc
condition|)
block|{
name|doc
operator|=
name|next
expr_stmt|;
name|which
operator|=
name|i
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
continue|continue
name|outer
continue|;
block|}
block|}
return|return
name|doc
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|nextDoc
specifier|public
name|int
name|nextDoc
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|doNext
argument_list|(
name|first
operator|.
name|nextDoc
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|advance
specifier|public
name|int
name|advance
parameter_list|(
name|int
name|target
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|doNext
argument_list|(
name|first
operator|.
name|advance
argument_list|(
name|target
argument_list|)
argument_list|)
return|;
block|}
block|}
DECL|class|DualFilterIterator
specifier|private
specifier|static
class|class
name|DualFilterIterator
extends|extends
name|DocIdSetIterator
block|{
DECL|field|a
specifier|final
name|DocIdSetIterator
name|a
decl_stmt|;
DECL|field|b
specifier|final
name|DocIdSetIterator
name|b
decl_stmt|;
DECL|method|DualFilterIterator
specifier|public
name|DualFilterIterator
parameter_list|(
name|DocIdSetIterator
name|a
parameter_list|,
name|DocIdSetIterator
name|b
parameter_list|)
block|{
name|this
operator|.
name|a
operator|=
name|a
expr_stmt|;
name|this
operator|.
name|b
operator|=
name|b
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|docID
specifier|public
name|int
name|docID
parameter_list|()
block|{
return|return
name|a
operator|.
name|docID
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|nextDoc
specifier|public
name|int
name|nextDoc
parameter_list|()
throws|throws
name|IOException
block|{
name|int
name|doc
init|=
name|a
operator|.
name|nextDoc
argument_list|()
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|other
init|=
name|b
operator|.
name|advance
argument_list|(
name|doc
argument_list|)
decl_stmt|;
if|if
condition|(
name|other
operator|==
name|doc
condition|)
return|return
name|doc
return|;
name|doc
operator|=
name|a
operator|.
name|advance
argument_list|(
name|other
argument_list|)
expr_stmt|;
if|if
condition|(
name|other
operator|==
name|doc
condition|)
return|return
name|doc
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|advance
specifier|public
name|int
name|advance
parameter_list|(
name|int
name|target
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|doc
init|=
name|a
operator|.
name|advance
argument_list|(
name|target
argument_list|)
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|other
init|=
name|b
operator|.
name|advance
argument_list|(
name|doc
argument_list|)
decl_stmt|;
if|if
condition|(
name|other
operator|==
name|doc
condition|)
return|return
name|doc
return|;
name|doc
operator|=
name|a
operator|.
name|advance
argument_list|(
name|other
argument_list|)
expr_stmt|;
if|if
condition|(
name|other
operator|==
name|doc
condition|)
return|return
name|doc
return|;
block|}
block|}
block|}
block|}
end_class
end_unit
