begin_unit
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_package
DECL|package|org.apache.solr.search
package|package
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|search
package|;
end_package
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Closeable
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|invoke
operator|.
name|MethodHandles
import|;
end_import
begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URL
import|;
end_import
begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|charset
operator|.
name|StandardCharsets
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Date
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedList
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicLong
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|document
operator|.
name|Document
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|document
operator|.
name|DocumentStoredFieldVisitor
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|document
operator|.
name|LazyDocument
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|BinaryDocValues
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|DirectoryReader
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|DocValues
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|DocValuesType
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|ExitableDirectoryReader
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|FieldInfo
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|FieldInfos
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|IndexReader
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|IndexableField
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|LeafReader
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|LeafReaderContext
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|MultiPostingsEnum
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|NumericDocValues
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|PostingsEnum
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|SlowCompositeReaderWrapper
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|SortedDocValues
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|SortedSetDocValues
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|StoredFieldVisitor
operator|.
name|Status
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|StoredFieldVisitor
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|Term
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|TermContext
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|Terms
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|TermsEnum
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|BooleanClause
operator|.
name|Occur
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|BooleanClause
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|BooleanQuery
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|CollectionStatistics
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|Collector
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|ConstantScoreQuery
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|DocIdSet
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|DocIdSetIterator
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|EarlyTerminatingSortingCollector
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|Explanation
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|FieldDoc
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|IndexSearcher
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|LeafCollector
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|MatchAllDocsQuery
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|MultiCollector
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|Query
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|ScoreDoc
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|Scorer
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|SimpleCollector
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|Sort
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|SortField
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|TermQuery
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|TermStatistics
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|TimeLimitingCollector
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|TopDocs
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|TopDocsCollector
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|TopFieldCollector
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|TopFieldDocs
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|TopScoreDocCollector
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|TotalHitCountCollector
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|Weight
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|Directory
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|uninverting
operator|.
name|UninvertingReader
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|Bits
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|BytesRef
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|FixedBitSet
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|NumericUtils
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|SolrDocumentBase
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|SolrException
operator|.
name|ErrorCode
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|SolrException
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|params
operator|.
name|ModifiableSolrParams
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|util
operator|.
name|NamedList
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|util
operator|.
name|SimpleOrderedMap
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|core
operator|.
name|DirectoryFactory
operator|.
name|DirContext
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|core
operator|.
name|DirectoryFactory
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|core
operator|.
name|SolrConfig
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|core
operator|.
name|SolrCore
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|core
operator|.
name|SolrInfoMBean
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|request
operator|.
name|LocalSolrQueryRequest
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|request
operator|.
name|SolrQueryRequest
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|request
operator|.
name|SolrRequestInfo
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|response
operator|.
name|SolrQueryResponse
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|schema
operator|.
name|EnumField
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|schema
operator|.
name|IndexSchema
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|schema
operator|.
name|SchemaField
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|schema
operator|.
name|TrieDateField
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|schema
operator|.
name|TrieDoubleField
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|schema
operator|.
name|TrieFloatField
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|schema
operator|.
name|TrieIntField
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|search
operator|.
name|facet
operator|.
name|UnInvertedField
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|search
operator|.
name|stats
operator|.
name|StatsSource
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|update
operator|.
name|IndexFingerprint
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|update
operator|.
name|SolrIndexConfig
import|;
end_import
begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import
begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import
begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Function
import|;
end_import
begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Iterables
import|;
end_import
begin_comment
comment|/**  * SolrIndexSearcher adds schema awareness and caching functionality over {@link IndexSearcher}.  *  * @since solr 0.9  */
end_comment
begin_class
DECL|class|SolrIndexSearcher
specifier|public
class|class
name|SolrIndexSearcher
extends|extends
name|IndexSearcher
implements|implements
name|Closeable
implements|,
name|SolrInfoMBean
block|{
DECL|field|log
specifier|private
specifier|static
specifier|final
name|Logger
name|log
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|MethodHandles
operator|.
name|lookup
argument_list|()
operator|.
name|lookupClass
argument_list|()
argument_list|)
decl_stmt|;
DECL|field|STATS_SOURCE
specifier|public
specifier|static
specifier|final
name|String
name|STATS_SOURCE
init|=
literal|"org.apache.solr.stats_source"
decl_stmt|;
comment|// These should *only* be used for debugging or monitoring purposes
DECL|field|numOpens
specifier|public
specifier|static
specifier|final
name|AtomicLong
name|numOpens
init|=
operator|new
name|AtomicLong
argument_list|()
decl_stmt|;
DECL|field|numCloses
specifier|public
specifier|static
specifier|final
name|AtomicLong
name|numCloses
init|=
operator|new
name|AtomicLong
argument_list|()
decl_stmt|;
DECL|field|NO_GENERIC_CACHES
specifier|private
specifier|static
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|SolrCache
argument_list|>
name|NO_GENERIC_CACHES
init|=
name|Collections
operator|.
name|emptyMap
argument_list|()
decl_stmt|;
DECL|field|NO_CACHES
specifier|private
specifier|static
specifier|final
name|SolrCache
index|[]
name|NO_CACHES
init|=
operator|new
name|SolrCache
index|[
literal|0
index|]
decl_stmt|;
DECL|field|core
specifier|private
specifier|final
name|SolrCore
name|core
decl_stmt|;
DECL|field|schema
specifier|private
specifier|final
name|IndexSchema
name|schema
decl_stmt|;
DECL|field|name
specifier|private
specifier|final
name|String
name|name
decl_stmt|;
DECL|field|openTime
specifier|private
specifier|final
name|Date
name|openTime
init|=
operator|new
name|Date
argument_list|()
decl_stmt|;
DECL|field|openNanoTime
specifier|private
specifier|final
name|long
name|openNanoTime
init|=
name|System
operator|.
name|nanoTime
argument_list|()
decl_stmt|;
DECL|field|registerTime
specifier|private
name|Date
name|registerTime
decl_stmt|;
DECL|field|warmupTime
specifier|private
name|long
name|warmupTime
init|=
literal|0
decl_stmt|;
DECL|field|reader
specifier|private
specifier|final
name|DirectoryReader
name|reader
decl_stmt|;
DECL|field|closeReader
specifier|private
specifier|final
name|boolean
name|closeReader
decl_stmt|;
DECL|field|queryResultWindowSize
specifier|private
specifier|final
name|int
name|queryResultWindowSize
decl_stmt|;
DECL|field|queryResultMaxDocsCached
specifier|private
specifier|final
name|int
name|queryResultMaxDocsCached
decl_stmt|;
DECL|field|useFilterForSortedQuery
specifier|private
specifier|final
name|boolean
name|useFilterForSortedQuery
decl_stmt|;
DECL|field|enableLazyFieldLoading
specifier|public
specifier|final
name|boolean
name|enableLazyFieldLoading
decl_stmt|;
DECL|field|cachingEnabled
specifier|private
specifier|final
name|boolean
name|cachingEnabled
decl_stmt|;
DECL|field|filterCache
specifier|private
specifier|final
name|SolrCache
argument_list|<
name|Query
argument_list|,
name|DocSet
argument_list|>
name|filterCache
decl_stmt|;
DECL|field|queryResultCache
specifier|private
specifier|final
name|SolrCache
argument_list|<
name|QueryResultKey
argument_list|,
name|DocList
argument_list|>
name|queryResultCache
decl_stmt|;
DECL|field|documentCache
specifier|private
specifier|final
name|SolrCache
argument_list|<
name|Integer
argument_list|,
name|Document
argument_list|>
name|documentCache
decl_stmt|;
DECL|field|fieldValueCache
specifier|private
specifier|final
name|SolrCache
argument_list|<
name|String
argument_list|,
name|UnInvertedField
argument_list|>
name|fieldValueCache
decl_stmt|;
comment|// map of generic caches - not synchronized since it's read-only after the constructor.
DECL|field|cacheMap
specifier|private
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|SolrCache
argument_list|>
name|cacheMap
decl_stmt|;
comment|// list of all caches associated with this searcher.
DECL|field|cacheList
specifier|private
specifier|final
name|SolrCache
index|[]
name|cacheList
decl_stmt|;
DECL|field|fieldInfos
specifier|private
specifier|final
name|FieldInfos
name|fieldInfos
decl_stmt|;
comment|/** Contains the names/patterns of all docValues=true,stored=false fields in the schema. */
DECL|field|allNonStoredDVs
specifier|private
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|allNonStoredDVs
decl_stmt|;
comment|/** Contains the names/patterns of all docValues=true,stored=false,useDocValuesAsStored=true fields in the schema. */
DECL|field|nonStoredDVsUsedAsStored
specifier|private
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|nonStoredDVsUsedAsStored
decl_stmt|;
DECL|field|storedHighlightFieldNames
specifier|private
name|Collection
argument_list|<
name|String
argument_list|>
name|storedHighlightFieldNames
decl_stmt|;
DECL|field|directoryFactory
specifier|private
name|DirectoryFactory
name|directoryFactory
decl_stmt|;
DECL|field|leafReader
specifier|private
specifier|final
name|LeafReader
name|leafReader
decl_stmt|;
comment|// only for addIndexes etc (no fieldcache)
DECL|field|rawReader
specifier|private
specifier|final
name|DirectoryReader
name|rawReader
decl_stmt|;
DECL|field|path
specifier|private
specifier|final
name|String
name|path
decl_stmt|;
DECL|field|releaseDirectory
specifier|private
name|boolean
name|releaseDirectory
decl_stmt|;
DECL|field|fingerprint
specifier|private
specifier|volatile
name|IndexFingerprint
name|fingerprint
decl_stmt|;
DECL|field|fingerprintLock
specifier|private
specifier|final
name|Object
name|fingerprintLock
init|=
operator|new
name|Object
argument_list|()
decl_stmt|;
DECL|method|getReader
specifier|private
specifier|static
name|DirectoryReader
name|getReader
parameter_list|(
name|SolrCore
name|core
parameter_list|,
name|SolrIndexConfig
name|config
parameter_list|,
name|DirectoryFactory
name|directoryFactory
parameter_list|,
name|String
name|path
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|Directory
name|dir
init|=
name|directoryFactory
operator|.
name|get
argument_list|(
name|path
argument_list|,
name|DirContext
operator|.
name|DEFAULT
argument_list|,
name|config
operator|.
name|lockType
argument_list|)
decl_stmt|;
try|try
block|{
return|return
name|core
operator|.
name|getIndexReaderFactory
argument_list|()
operator|.
name|newReader
argument_list|(
name|dir
argument_list|,
name|core
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|directoryFactory
operator|.
name|release
argument_list|(
name|dir
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|SERVER_ERROR
argument_list|,
literal|"Error opening Reader"
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
comment|// TODO: wrap elsewhere and return a "map" from the schema that overrides get() ?
comment|// this reader supports reopen
DECL|method|wrapReader
specifier|private
specifier|static
name|DirectoryReader
name|wrapReader
parameter_list|(
name|SolrCore
name|core
parameter_list|,
name|DirectoryReader
name|reader
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|reader
operator|!=
literal|null
assert|;
return|return
name|ExitableDirectoryReader
operator|.
name|wrap
argument_list|(
name|UninvertingReader
operator|.
name|wrap
argument_list|(
name|reader
argument_list|,
name|core
operator|.
name|getLatestSchema
argument_list|()
operator|.
name|getUninversionMap
argument_list|(
name|reader
argument_list|)
argument_list|)
argument_list|,
name|SolrQueryTimeoutImpl
operator|.
name|getInstance
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Builds the necessary collector chain (via delegate wrapping) and executes the query against it. This method takes    * into consideration both the explicitly provided collector and postFilter as well as any needed collector wrappers    * for dealing with options specified in the QueryCOmmand.    */
DECL|method|buildAndRunCollectorChain
specifier|private
name|void
name|buildAndRunCollectorChain
parameter_list|(
name|QueryResult
name|qr
parameter_list|,
name|Query
name|query
parameter_list|,
name|Collector
name|collector
parameter_list|,
name|QueryCommand
name|cmd
parameter_list|,
name|DelegatingCollector
name|postFilter
parameter_list|)
throws|throws
name|IOException
block|{
name|EarlyTerminatingSortingCollector
name|earlyTerminatingSortingCollector
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|cmd
operator|.
name|getSegmentTerminateEarly
argument_list|()
condition|)
block|{
specifier|final
name|Sort
name|cmdSort
init|=
name|cmd
operator|.
name|getSort
argument_list|()
decl_stmt|;
specifier|final
name|int
name|cmdLen
init|=
name|cmd
operator|.
name|getLen
argument_list|()
decl_stmt|;
specifier|final
name|Sort
name|mergeSort
init|=
name|core
operator|.
name|getSolrCoreState
argument_list|()
operator|.
name|getMergePolicySort
argument_list|()
decl_stmt|;
if|if
condition|(
name|cmdSort
operator|==
literal|null
operator|||
name|cmdLen
operator|<=
literal|0
operator|||
name|mergeSort
operator|==
literal|null
operator|||
operator|!
name|EarlyTerminatingSortingCollector
operator|.
name|canEarlyTerminate
argument_list|(
name|cmdSort
argument_list|,
name|mergeSort
argument_list|)
condition|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"unsupported combination: segmentTerminateEarly=true cmdSort={} cmdLen={} mergeSort={}"
argument_list|,
name|cmdSort
argument_list|,
name|cmdLen
argument_list|,
name|mergeSort
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|collector
operator|=
name|earlyTerminatingSortingCollector
operator|=
operator|new
name|EarlyTerminatingSortingCollector
argument_list|(
name|collector
argument_list|,
name|cmdSort
argument_list|,
name|cmd
operator|.
name|getLen
argument_list|()
argument_list|,
name|mergeSort
argument_list|)
expr_stmt|;
block|}
block|}
specifier|final
name|boolean
name|terminateEarly
init|=
name|cmd
operator|.
name|getTerminateEarly
argument_list|()
decl_stmt|;
if|if
condition|(
name|terminateEarly
condition|)
block|{
name|collector
operator|=
operator|new
name|EarlyTerminatingCollector
argument_list|(
name|collector
argument_list|,
name|cmd
operator|.
name|getLen
argument_list|()
argument_list|)
expr_stmt|;
block|}
specifier|final
name|long
name|timeAllowed
init|=
name|cmd
operator|.
name|getTimeAllowed
argument_list|()
decl_stmt|;
if|if
condition|(
name|timeAllowed
operator|>
literal|0
condition|)
block|{
name|collector
operator|=
operator|new
name|TimeLimitingCollector
argument_list|(
name|collector
argument_list|,
name|TimeLimitingCollector
operator|.
name|getGlobalCounter
argument_list|()
argument_list|,
name|timeAllowed
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|postFilter
operator|!=
literal|null
condition|)
block|{
name|postFilter
operator|.
name|setLastDelegate
argument_list|(
name|collector
argument_list|)
expr_stmt|;
name|collector
operator|=
name|postFilter
expr_stmt|;
block|}
try|try
block|{
name|super
operator|.
name|search
argument_list|(
name|query
argument_list|,
name|collector
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|TimeLimitingCollector
operator|.
name|TimeExceededException
decl||
name|ExitableDirectoryReader
operator|.
name|ExitingReaderException
name|x
parameter_list|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Query: [{}]; {}"
argument_list|,
name|query
argument_list|,
name|x
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
name|qr
operator|.
name|setPartialResults
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|EarlyTerminatingCollectorException
name|etce
parameter_list|)
block|{
if|if
condition|(
name|collector
operator|instanceof
name|DelegatingCollector
condition|)
block|{
operator|(
operator|(
name|DelegatingCollector
operator|)
name|collector
operator|)
operator|.
name|finish
argument_list|()
expr_stmt|;
block|}
throw|throw
name|etce
throw|;
block|}
finally|finally
block|{
if|if
condition|(
name|earlyTerminatingSortingCollector
operator|!=
literal|null
condition|)
block|{
name|qr
operator|.
name|setSegmentTerminatedEarly
argument_list|(
name|earlyTerminatingSortingCollector
operator|.
name|terminatedEarly
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|collector
operator|instanceof
name|DelegatingCollector
condition|)
block|{
operator|(
operator|(
name|DelegatingCollector
operator|)
name|collector
operator|)
operator|.
name|finish
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|SolrIndexSearcher
specifier|public
name|SolrIndexSearcher
parameter_list|(
name|SolrCore
name|core
parameter_list|,
name|String
name|path
parameter_list|,
name|IndexSchema
name|schema
parameter_list|,
name|SolrIndexConfig
name|config
parameter_list|,
name|String
name|name
parameter_list|,
name|boolean
name|enableCache
parameter_list|,
name|DirectoryFactory
name|directoryFactory
parameter_list|)
throws|throws
name|IOException
block|{
comment|// We don't need to reserve the directory because we get it from the factory
name|this
argument_list|(
name|core
argument_list|,
name|path
argument_list|,
name|schema
argument_list|,
name|name
argument_list|,
name|getReader
argument_list|(
name|core
argument_list|,
name|config
argument_list|,
name|directoryFactory
argument_list|,
name|path
argument_list|)
argument_list|,
literal|true
argument_list|,
name|enableCache
argument_list|,
literal|false
argument_list|,
name|directoryFactory
argument_list|)
expr_stmt|;
comment|// Release the directory at close.
name|this
operator|.
name|releaseDirectory
operator|=
literal|true
expr_stmt|;
block|}
DECL|method|SolrIndexSearcher
specifier|public
name|SolrIndexSearcher
parameter_list|(
name|SolrCore
name|core
parameter_list|,
name|String
name|path
parameter_list|,
name|IndexSchema
name|schema
parameter_list|,
name|String
name|name
parameter_list|,
name|DirectoryReader
name|r
parameter_list|,
name|boolean
name|closeReader
parameter_list|,
name|boolean
name|enableCache
parameter_list|,
name|boolean
name|reserveDirectory
parameter_list|,
name|DirectoryFactory
name|directoryFactory
parameter_list|)
throws|throws
name|IOException
block|{
name|super
argument_list|(
name|wrapReader
argument_list|(
name|core
argument_list|,
name|r
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|path
operator|=
name|path
expr_stmt|;
name|this
operator|.
name|directoryFactory
operator|=
name|directoryFactory
expr_stmt|;
name|this
operator|.
name|reader
operator|=
operator|(
name|DirectoryReader
operator|)
name|super
operator|.
name|readerContext
operator|.
name|reader
argument_list|()
expr_stmt|;
name|this
operator|.
name|rawReader
operator|=
name|r
expr_stmt|;
name|this
operator|.
name|leafReader
operator|=
name|SlowCompositeReaderWrapper
operator|.
name|wrap
argument_list|(
name|this
operator|.
name|reader
argument_list|)
expr_stmt|;
name|this
operator|.
name|core
operator|=
name|core
expr_stmt|;
name|this
operator|.
name|schema
operator|=
name|schema
expr_stmt|;
name|this
operator|.
name|name
operator|=
literal|"Searcher@"
operator|+
name|Integer
operator|.
name|toHexString
argument_list|(
name|hashCode
argument_list|()
argument_list|)
operator|+
literal|"["
operator|+
name|core
operator|.
name|getName
argument_list|()
operator|+
literal|"]"
operator|+
operator|(
name|name
operator|!=
literal|null
condition|?
literal|" "
operator|+
name|name
else|:
literal|""
operator|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Opening [{}]"
argument_list|,
name|this
operator|.
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|directoryFactory
operator|.
name|searchersReserveCommitPoints
argument_list|()
condition|)
block|{
comment|// reserve commit point for life of searcher
name|core
operator|.
name|getDeletionPolicy
argument_list|()
operator|.
name|saveCommitPoint
argument_list|(
name|reader
operator|.
name|getIndexCommit
argument_list|()
operator|.
name|getGeneration
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|reserveDirectory
condition|)
block|{
comment|// Keep the directory from being released while we use it.
name|directoryFactory
operator|.
name|incRef
argument_list|(
name|getIndexReader
argument_list|()
operator|.
name|directory
argument_list|()
argument_list|)
expr_stmt|;
comment|// Make sure to release it when closing.
name|this
operator|.
name|releaseDirectory
operator|=
literal|true
expr_stmt|;
block|}
name|this
operator|.
name|closeReader
operator|=
name|closeReader
expr_stmt|;
name|setSimilarity
argument_list|(
name|schema
operator|.
name|getSimilarity
argument_list|()
argument_list|)
expr_stmt|;
specifier|final
name|SolrConfig
name|solrConfig
init|=
name|core
operator|.
name|getSolrConfig
argument_list|()
decl_stmt|;
name|this
operator|.
name|queryResultWindowSize
operator|=
name|solrConfig
operator|.
name|queryResultWindowSize
expr_stmt|;
name|this
operator|.
name|queryResultMaxDocsCached
operator|=
name|solrConfig
operator|.
name|queryResultMaxDocsCached
expr_stmt|;
name|this
operator|.
name|useFilterForSortedQuery
operator|=
name|solrConfig
operator|.
name|useFilterForSortedQuery
expr_stmt|;
name|this
operator|.
name|enableLazyFieldLoading
operator|=
name|solrConfig
operator|.
name|enableLazyFieldLoading
expr_stmt|;
name|this
operator|.
name|cachingEnabled
operator|=
name|enableCache
expr_stmt|;
if|if
condition|(
name|cachingEnabled
condition|)
block|{
specifier|final
name|ArrayList
argument_list|<
name|SolrCache
argument_list|>
name|clist
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|fieldValueCache
operator|=
name|solrConfig
operator|.
name|fieldValueCacheConfig
operator|==
literal|null
condition|?
literal|null
else|:
name|solrConfig
operator|.
name|fieldValueCacheConfig
operator|.
name|newInstance
argument_list|()
expr_stmt|;
if|if
condition|(
name|fieldValueCache
operator|!=
literal|null
condition|)
name|clist
operator|.
name|add
argument_list|(
name|fieldValueCache
argument_list|)
expr_stmt|;
name|filterCache
operator|=
name|solrConfig
operator|.
name|filterCacheConfig
operator|==
literal|null
condition|?
literal|null
else|:
name|solrConfig
operator|.
name|filterCacheConfig
operator|.
name|newInstance
argument_list|()
expr_stmt|;
if|if
condition|(
name|filterCache
operator|!=
literal|null
condition|)
name|clist
operator|.
name|add
argument_list|(
name|filterCache
argument_list|)
expr_stmt|;
name|queryResultCache
operator|=
name|solrConfig
operator|.
name|queryResultCacheConfig
operator|==
literal|null
condition|?
literal|null
else|:
name|solrConfig
operator|.
name|queryResultCacheConfig
operator|.
name|newInstance
argument_list|()
expr_stmt|;
if|if
condition|(
name|queryResultCache
operator|!=
literal|null
condition|)
name|clist
operator|.
name|add
argument_list|(
name|queryResultCache
argument_list|)
expr_stmt|;
name|documentCache
operator|=
name|solrConfig
operator|.
name|documentCacheConfig
operator|==
literal|null
condition|?
literal|null
else|:
name|solrConfig
operator|.
name|documentCacheConfig
operator|.
name|newInstance
argument_list|()
expr_stmt|;
if|if
condition|(
name|documentCache
operator|!=
literal|null
condition|)
name|clist
operator|.
name|add
argument_list|(
name|documentCache
argument_list|)
expr_stmt|;
if|if
condition|(
name|solrConfig
operator|.
name|userCacheConfigs
operator|==
literal|null
condition|)
block|{
name|cacheMap
operator|=
name|NO_GENERIC_CACHES
expr_stmt|;
block|}
else|else
block|{
name|cacheMap
operator|=
operator|new
name|HashMap
argument_list|<>
argument_list|(
name|solrConfig
operator|.
name|userCacheConfigs
operator|.
name|length
argument_list|)
expr_stmt|;
for|for
control|(
name|CacheConfig
name|userCacheConfig
range|:
name|solrConfig
operator|.
name|userCacheConfigs
control|)
block|{
name|SolrCache
name|cache
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|userCacheConfig
operator|!=
literal|null
condition|)
name|cache
operator|=
name|userCacheConfig
operator|.
name|newInstance
argument_list|()
expr_stmt|;
if|if
condition|(
name|cache
operator|!=
literal|null
condition|)
block|{
name|cacheMap
operator|.
name|put
argument_list|(
name|cache
operator|.
name|name
argument_list|()
argument_list|,
name|cache
argument_list|)
expr_stmt|;
name|clist
operator|.
name|add
argument_list|(
name|cache
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|cacheList
operator|=
name|clist
operator|.
name|toArray
argument_list|(
operator|new
name|SolrCache
index|[
name|clist
operator|.
name|size
argument_list|()
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|this
operator|.
name|filterCache
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|queryResultCache
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|documentCache
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|fieldValueCache
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|cacheMap
operator|=
name|NO_GENERIC_CACHES
expr_stmt|;
name|this
operator|.
name|cacheList
operator|=
name|NO_CACHES
expr_stmt|;
block|}
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|nonStoredDVsUsedAsStored
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|allNonStoredDVs
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
name|this
operator|.
name|fieldInfos
operator|=
name|leafReader
operator|.
name|getFieldInfos
argument_list|()
expr_stmt|;
for|for
control|(
name|FieldInfo
name|fieldInfo
range|:
name|fieldInfos
control|)
block|{
specifier|final
name|SchemaField
name|schemaField
init|=
name|schema
operator|.
name|getFieldOrNull
argument_list|(
name|fieldInfo
operator|.
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|schemaField
operator|!=
literal|null
operator|&&
operator|!
name|schemaField
operator|.
name|stored
argument_list|()
operator|&&
name|schemaField
operator|.
name|hasDocValues
argument_list|()
condition|)
block|{
if|if
condition|(
name|schemaField
operator|.
name|useDocValuesAsStored
argument_list|()
condition|)
block|{
name|nonStoredDVsUsedAsStored
operator|.
name|add
argument_list|(
name|fieldInfo
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
name|allNonStoredDVs
operator|.
name|add
argument_list|(
name|fieldInfo
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
block|}
name|this
operator|.
name|nonStoredDVsUsedAsStored
operator|=
name|Collections
operator|.
name|unmodifiableSet
argument_list|(
name|nonStoredDVsUsedAsStored
argument_list|)
expr_stmt|;
name|this
operator|.
name|allNonStoredDVs
operator|=
name|Collections
operator|.
name|unmodifiableSet
argument_list|(
name|allNonStoredDVs
argument_list|)
expr_stmt|;
comment|// We already have our own filter cache
name|setQueryCache
argument_list|(
literal|null
argument_list|)
expr_stmt|;
comment|// do this at the end since an exception in the constructor means we won't close
name|numOpens
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
block|}
comment|/*    * Override these two methods to provide a way to use global collection stats.    */
annotation|@
name|Override
DECL|method|termStatistics
specifier|public
name|TermStatistics
name|termStatistics
parameter_list|(
name|Term
name|term
parameter_list|,
name|TermContext
name|context
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|SolrRequestInfo
name|reqInfo
init|=
name|SolrRequestInfo
operator|.
name|getRequestInfo
argument_list|()
decl_stmt|;
if|if
condition|(
name|reqInfo
operator|!=
literal|null
condition|)
block|{
specifier|final
name|StatsSource
name|statsSrc
init|=
operator|(
name|StatsSource
operator|)
name|reqInfo
operator|.
name|getReq
argument_list|()
operator|.
name|getContext
argument_list|()
operator|.
name|get
argument_list|(
name|STATS_SOURCE
argument_list|)
decl_stmt|;
if|if
condition|(
name|statsSrc
operator|!=
literal|null
condition|)
block|{
return|return
name|statsSrc
operator|.
name|termStatistics
argument_list|(
name|this
argument_list|,
name|term
argument_list|,
name|context
argument_list|)
return|;
block|}
block|}
return|return
name|localTermStatistics
argument_list|(
name|term
argument_list|,
name|context
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|collectionStatistics
specifier|public
name|CollectionStatistics
name|collectionStatistics
parameter_list|(
name|String
name|field
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|SolrRequestInfo
name|reqInfo
init|=
name|SolrRequestInfo
operator|.
name|getRequestInfo
argument_list|()
decl_stmt|;
if|if
condition|(
name|reqInfo
operator|!=
literal|null
condition|)
block|{
specifier|final
name|StatsSource
name|statsSrc
init|=
operator|(
name|StatsSource
operator|)
name|reqInfo
operator|.
name|getReq
argument_list|()
operator|.
name|getContext
argument_list|()
operator|.
name|get
argument_list|(
name|STATS_SOURCE
argument_list|)
decl_stmt|;
if|if
condition|(
name|statsSrc
operator|!=
literal|null
condition|)
block|{
return|return
name|statsSrc
operator|.
name|collectionStatistics
argument_list|(
name|this
argument_list|,
name|field
argument_list|)
return|;
block|}
block|}
return|return
name|localCollectionStatistics
argument_list|(
name|field
argument_list|)
return|;
block|}
DECL|method|localTermStatistics
specifier|public
name|TermStatistics
name|localTermStatistics
parameter_list|(
name|Term
name|term
parameter_list|,
name|TermContext
name|context
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|super
operator|.
name|termStatistics
argument_list|(
name|term
argument_list|,
name|context
argument_list|)
return|;
block|}
DECL|method|localCollectionStatistics
specifier|public
name|CollectionStatistics
name|localCollectionStatistics
parameter_list|(
name|String
name|field
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|super
operator|.
name|collectionStatistics
argument_list|(
name|field
argument_list|)
return|;
block|}
DECL|method|isCachingEnabled
specifier|public
name|boolean
name|isCachingEnabled
parameter_list|()
block|{
return|return
name|cachingEnabled
return|;
block|}
DECL|method|getPath
specifier|public
name|String
name|getPath
parameter_list|()
block|{
return|return
name|path
return|;
block|}
annotation|@
name|Override
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|name
operator|+
literal|"{"
operator|+
name|reader
operator|+
literal|"}"
return|;
block|}
DECL|method|getCore
specifier|public
name|SolrCore
name|getCore
parameter_list|()
block|{
return|return
name|core
return|;
block|}
DECL|method|maxDoc
specifier|public
specifier|final
name|int
name|maxDoc
parameter_list|()
block|{
return|return
name|reader
operator|.
name|maxDoc
argument_list|()
return|;
block|}
DECL|method|docFreq
specifier|public
specifier|final
name|int
name|docFreq
parameter_list|(
name|Term
name|term
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|reader
operator|.
name|docFreq
argument_list|(
name|term
argument_list|)
return|;
block|}
DECL|method|getLeafReader
specifier|public
specifier|final
name|LeafReader
name|getLeafReader
parameter_list|()
block|{
return|return
name|leafReader
return|;
block|}
comment|/** Raw reader (no fieldcaches etc). Useful for operations like addIndexes */
DECL|method|getRawReader
specifier|public
specifier|final
name|DirectoryReader
name|getRawReader
parameter_list|()
block|{
return|return
name|rawReader
return|;
block|}
annotation|@
name|Override
DECL|method|getIndexReader
specifier|public
specifier|final
name|DirectoryReader
name|getIndexReader
parameter_list|()
block|{
assert|assert
name|reader
operator|==
name|super
operator|.
name|getIndexReader
argument_list|()
assert|;
return|return
name|reader
return|;
block|}
comment|/**    * Register sub-objects such as caches    */
DECL|method|register
specifier|public
name|void
name|register
parameter_list|()
block|{
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|SolrInfoMBean
argument_list|>
name|infoRegistry
init|=
name|core
operator|.
name|getInfoRegistry
argument_list|()
decl_stmt|;
comment|// register self
name|infoRegistry
operator|.
name|put
argument_list|(
literal|"searcher"
argument_list|,
name|this
argument_list|)
expr_stmt|;
name|infoRegistry
operator|.
name|put
argument_list|(
name|name
argument_list|,
name|this
argument_list|)
expr_stmt|;
for|for
control|(
name|SolrCache
name|cache
range|:
name|cacheList
control|)
block|{
name|cache
operator|.
name|setState
argument_list|(
name|SolrCache
operator|.
name|State
operator|.
name|LIVE
argument_list|)
expr_stmt|;
name|infoRegistry
operator|.
name|put
argument_list|(
name|cache
operator|.
name|name
argument_list|()
argument_list|,
name|cache
argument_list|)
expr_stmt|;
block|}
name|registerTime
operator|=
operator|new
name|Date
argument_list|()
expr_stmt|;
block|}
comment|/**    * Free's resources associated with this searcher.    *    * In particular, the underlying reader and any cache's in use are closed.    */
annotation|@
name|Override
DECL|method|close
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|log
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
if|if
condition|(
name|cachingEnabled
condition|)
block|{
specifier|final
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"Closing "
argument_list|)
operator|.
name|append
argument_list|(
name|name
argument_list|)
expr_stmt|;
for|for
control|(
name|SolrCache
name|cache
range|:
name|cacheList
control|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|"\n\t"
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|cache
argument_list|)
expr_stmt|;
block|}
name|log
operator|.
name|debug
argument_list|(
name|sb
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"Closing [{}]"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
block|}
name|core
operator|.
name|getInfoRegistry
argument_list|()
operator|.
name|remove
argument_list|(
name|name
argument_list|)
expr_stmt|;
comment|// super.close();
comment|// can't use super.close() since it just calls reader.close() and that may only be called once
comment|// per reader (even if incRef() was previously called).
name|long
name|cpg
init|=
name|reader
operator|.
name|getIndexCommit
argument_list|()
operator|.
name|getGeneration
argument_list|()
decl_stmt|;
try|try
block|{
if|if
condition|(
name|closeReader
condition|)
name|rawReader
operator|.
name|decRef
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|SolrException
operator|.
name|log
argument_list|(
name|log
argument_list|,
literal|"Problem dec ref'ing reader"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|directoryFactory
operator|.
name|searchersReserveCommitPoints
argument_list|()
condition|)
block|{
name|core
operator|.
name|getDeletionPolicy
argument_list|()
operator|.
name|releaseCommitPoint
argument_list|(
name|cpg
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|SolrCache
name|cache
range|:
name|cacheList
control|)
block|{
name|cache
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|releaseDirectory
condition|)
block|{
name|directoryFactory
operator|.
name|release
argument_list|(
name|getIndexReader
argument_list|()
operator|.
name|directory
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// do this at the end so it only gets done if there are no exceptions
name|numCloses
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
block|}
comment|/** Direct access to the IndexSchema for use with this searcher */
DECL|method|getSchema
specifier|public
name|IndexSchema
name|getSchema
parameter_list|()
block|{
return|return
name|schema
return|;
block|}
comment|/**    * Returns a collection of all field names the index reader knows about.    */
DECL|method|getFieldNames
specifier|public
name|Iterable
argument_list|<
name|String
argument_list|>
name|getFieldNames
parameter_list|()
block|{
return|return
name|Iterables
operator|.
name|transform
argument_list|(
name|fieldInfos
argument_list|,
operator|new
name|Function
argument_list|<
name|FieldInfo
argument_list|,
name|String
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|String
name|apply
parameter_list|(
name|FieldInfo
name|fieldInfo
parameter_list|)
block|{
return|return
name|fieldInfo
operator|.
name|name
return|;
block|}
block|}
argument_list|)
return|;
block|}
DECL|method|getFilterCache
specifier|public
name|SolrCache
argument_list|<
name|Query
argument_list|,
name|DocSet
argument_list|>
name|getFilterCache
parameter_list|()
block|{
return|return
name|filterCache
return|;
block|}
comment|/**    * Returns a collection of the names of all stored fields which can be highlighted the index reader knows about.    */
DECL|method|getStoredHighlightFieldNames
specifier|public
name|Collection
argument_list|<
name|String
argument_list|>
name|getStoredHighlightFieldNames
parameter_list|()
block|{
synchronized|synchronized
init|(
name|this
init|)
block|{
if|if
condition|(
name|storedHighlightFieldNames
operator|==
literal|null
condition|)
block|{
name|storedHighlightFieldNames
operator|=
operator|new
name|LinkedList
argument_list|<>
argument_list|()
expr_stmt|;
for|for
control|(
name|FieldInfo
name|fieldInfo
range|:
name|fieldInfos
control|)
block|{
specifier|final
name|String
name|fieldName
init|=
name|fieldInfo
operator|.
name|name
decl_stmt|;
try|try
block|{
name|SchemaField
name|field
init|=
name|schema
operator|.
name|getField
argument_list|(
name|fieldName
argument_list|)
decl_stmt|;
if|if
condition|(
name|field
operator|.
name|stored
argument_list|()
operator|&&
operator|(
operator|(
name|field
operator|.
name|getType
argument_list|()
operator|instanceof
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|schema
operator|.
name|TextField
operator|)
operator|||
operator|(
name|field
operator|.
name|getType
argument_list|()
operator|instanceof
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|schema
operator|.
name|StrField
operator|)
operator|)
condition|)
block|{
name|storedHighlightFieldNames
operator|.
name|add
argument_list|(
name|fieldName
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|RuntimeException
name|e
parameter_list|)
block|{
comment|// getField() throws a SolrException, but it arrives as a RuntimeException
name|log
operator|.
name|warn
argument_list|(
literal|"Field [{}] found in index, but not defined in schema."
argument_list|,
name|fieldName
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|storedHighlightFieldNames
return|;
block|}
block|}
comment|//
comment|// Set default regenerators on filter and query caches if they don't have any
comment|//
DECL|method|initRegenerators
specifier|public
specifier|static
name|void
name|initRegenerators
parameter_list|(
name|SolrConfig
name|solrConfig
parameter_list|)
block|{
if|if
condition|(
name|solrConfig
operator|.
name|fieldValueCacheConfig
operator|!=
literal|null
operator|&&
name|solrConfig
operator|.
name|fieldValueCacheConfig
operator|.
name|getRegenerator
argument_list|()
operator|==
literal|null
condition|)
block|{
name|solrConfig
operator|.
name|fieldValueCacheConfig
operator|.
name|setRegenerator
argument_list|(
operator|new
name|CacheRegenerator
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|boolean
name|regenerateItem
parameter_list|(
name|SolrIndexSearcher
name|newSearcher
parameter_list|,
name|SolrCache
name|newCache
parameter_list|,
name|SolrCache
name|oldCache
parameter_list|,
name|Object
name|oldKey
parameter_list|,
name|Object
name|oldVal
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|oldVal
operator|instanceof
name|UnInvertedField
condition|)
block|{
name|UnInvertedField
operator|.
name|getUnInvertedField
argument_list|(
operator|(
name|String
operator|)
name|oldKey
argument_list|,
name|newSearcher
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|solrConfig
operator|.
name|filterCacheConfig
operator|!=
literal|null
operator|&&
name|solrConfig
operator|.
name|filterCacheConfig
operator|.
name|getRegenerator
argument_list|()
operator|==
literal|null
condition|)
block|{
name|solrConfig
operator|.
name|filterCacheConfig
operator|.
name|setRegenerator
argument_list|(
operator|new
name|CacheRegenerator
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|boolean
name|regenerateItem
parameter_list|(
name|SolrIndexSearcher
name|newSearcher
parameter_list|,
name|SolrCache
name|newCache
parameter_list|,
name|SolrCache
name|oldCache
parameter_list|,
name|Object
name|oldKey
parameter_list|,
name|Object
name|oldVal
parameter_list|)
throws|throws
name|IOException
block|{
name|newSearcher
operator|.
name|cacheDocSet
argument_list|(
operator|(
name|Query
operator|)
name|oldKey
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|solrConfig
operator|.
name|queryResultCacheConfig
operator|!=
literal|null
operator|&&
name|solrConfig
operator|.
name|queryResultCacheConfig
operator|.
name|getRegenerator
argument_list|()
operator|==
literal|null
condition|)
block|{
specifier|final
name|int
name|queryResultWindowSize
init|=
name|solrConfig
operator|.
name|queryResultWindowSize
decl_stmt|;
name|solrConfig
operator|.
name|queryResultCacheConfig
operator|.
name|setRegenerator
argument_list|(
operator|new
name|CacheRegenerator
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|boolean
name|regenerateItem
parameter_list|(
name|SolrIndexSearcher
name|newSearcher
parameter_list|,
name|SolrCache
name|newCache
parameter_list|,
name|SolrCache
name|oldCache
parameter_list|,
name|Object
name|oldKey
parameter_list|,
name|Object
name|oldVal
parameter_list|)
throws|throws
name|IOException
block|{
name|QueryResultKey
name|key
init|=
operator|(
name|QueryResultKey
operator|)
name|oldKey
decl_stmt|;
name|int
name|nDocs
init|=
literal|1
decl_stmt|;
comment|// request 1 doc and let caching round up to the next window size...
comment|// unless the window size is<=1, in which case we will pick
comment|// the minimum of the number of documents requested last time and
comment|// a reasonable number such as 40.
comment|// TODO: make more configurable later...
if|if
condition|(
name|queryResultWindowSize
operator|<=
literal|1
condition|)
block|{
name|DocList
name|oldList
init|=
operator|(
name|DocList
operator|)
name|oldVal
decl_stmt|;
name|int
name|oldnDocs
init|=
name|oldList
operator|.
name|offset
argument_list|()
operator|+
name|oldList
operator|.
name|size
argument_list|()
decl_stmt|;
comment|// 40 has factors of 2,4,5,10,20
name|nDocs
operator|=
name|Math
operator|.
name|min
argument_list|(
name|oldnDocs
argument_list|,
literal|40
argument_list|)
expr_stmt|;
block|}
name|int
name|flags
init|=
name|NO_CHECK_QCACHE
operator||
name|key
operator|.
name|nc_flags
decl_stmt|;
name|QueryCommand
name|qc
init|=
operator|new
name|QueryCommand
argument_list|()
decl_stmt|;
name|qc
operator|.
name|setQuery
argument_list|(
name|key
operator|.
name|query
argument_list|)
operator|.
name|setFilterList
argument_list|(
name|key
operator|.
name|filters
argument_list|)
operator|.
name|setSort
argument_list|(
name|key
operator|.
name|sort
argument_list|)
operator|.
name|setLen
argument_list|(
name|nDocs
argument_list|)
operator|.
name|setSupersetMaxDoc
argument_list|(
name|nDocs
argument_list|)
operator|.
name|setFlags
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|QueryResult
name|qr
init|=
operator|new
name|QueryResult
argument_list|()
decl_stmt|;
name|newSearcher
operator|.
name|getDocListC
argument_list|(
name|qr
argument_list|,
name|qc
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|search
specifier|public
name|QueryResult
name|search
parameter_list|(
name|QueryResult
name|qr
parameter_list|,
name|QueryCommand
name|cmd
parameter_list|)
throws|throws
name|IOException
block|{
name|getDocListC
argument_list|(
name|qr
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
return|return
name|qr
return|;
block|}
comment|// FIXME: This option has been dead/noop since 3.1, should we re-enable or remove it?
comment|// public Hits search(Query query, Filter filter, Sort sort) throws IOException {
comment|// // todo - when Solr starts accepting filters, need to
comment|// // change this conditional check (filter!=null) and create a new filter
comment|// // that ANDs them together if it already exists.
comment|//
comment|// if (optimizer==null || filter!=null || !(query instanceof BooleanQuery)
comment|// ) {
comment|// return super.search(query,filter,sort);
comment|// } else {
comment|// Query[] newQuery = new Query[1];
comment|// Filter[] newFilter = new Filter[1];
comment|// optimizer.optimize((BooleanQuery)query, this, 0, newQuery, newFilter);
comment|//
comment|// return super.search(newQuery[0], newFilter[0], sort);
comment|// }
comment|// }
comment|/* ********************** Document retrieval *************************/
comment|/*    * Future optimizations (yonik)    *    * If no cache is present: - use NO_LOAD instead of LAZY_LOAD - use LOAD_AND_BREAK if a single field is begin    * retrieved    */
comment|/** FieldSelector which loads the specified fields, and loads all other field lazily. */
DECL|class|SetNonLazyFieldSelector
specifier|private
specifier|static
class|class
name|SetNonLazyFieldSelector
extends|extends
name|DocumentStoredFieldVisitor
block|{
DECL|field|doc
specifier|private
specifier|final
name|Document
name|doc
decl_stmt|;
DECL|field|lazyDoc
specifier|private
specifier|final
name|LazyDocument
name|lazyDoc
decl_stmt|;
DECL|method|SetNonLazyFieldSelector
name|SetNonLazyFieldSelector
parameter_list|(
name|Set
argument_list|<
name|String
argument_list|>
name|toLoad
parameter_list|,
name|IndexReader
name|reader
parameter_list|,
name|int
name|docID
parameter_list|)
block|{
name|super
argument_list|(
name|toLoad
argument_list|)
expr_stmt|;
name|lazyDoc
operator|=
operator|new
name|LazyDocument
argument_list|(
name|reader
argument_list|,
name|docID
argument_list|)
expr_stmt|;
name|doc
operator|=
name|getDocument
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|needsField
specifier|public
name|Status
name|needsField
parameter_list|(
name|FieldInfo
name|fieldInfo
parameter_list|)
throws|throws
name|IOException
block|{
name|Status
name|status
init|=
name|super
operator|.
name|needsField
argument_list|(
name|fieldInfo
argument_list|)
decl_stmt|;
if|if
condition|(
name|status
operator|==
name|Status
operator|.
name|NO
condition|)
block|{
name|doc
operator|.
name|add
argument_list|(
name|lazyDoc
operator|.
name|getField
argument_list|(
name|fieldInfo
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|status
return|;
block|}
block|}
comment|/**    * Retrieve the {@link Document} instance corresponding to the document id.    */
annotation|@
name|Override
DECL|method|doc
specifier|public
name|Document
name|doc
parameter_list|(
name|int
name|i
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|doc
argument_list|(
name|i
argument_list|,
operator|(
name|Set
argument_list|<
name|String
argument_list|>
operator|)
literal|null
argument_list|)
return|;
block|}
comment|/**    * Visit a document's fields using a {@link StoredFieldVisitor} This method does not currently add to the Solr    * document cache.    *     * @see IndexReader#document(int, StoredFieldVisitor)    */
annotation|@
name|Override
DECL|method|doc
specifier|public
name|void
name|doc
parameter_list|(
name|int
name|n
parameter_list|,
name|StoredFieldVisitor
name|visitor
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|documentCache
operator|!=
literal|null
condition|)
block|{
name|Document
name|cached
init|=
name|documentCache
operator|.
name|get
argument_list|(
name|n
argument_list|)
decl_stmt|;
if|if
condition|(
name|cached
operator|!=
literal|null
condition|)
block|{
name|visitFromCached
argument_list|(
name|cached
argument_list|,
name|visitor
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|getIndexReader
argument_list|()
operator|.
name|document
argument_list|(
name|n
argument_list|,
name|visitor
argument_list|)
expr_stmt|;
block|}
comment|/** Executes a stored field visitor against a hit from the document cache */
DECL|method|visitFromCached
specifier|private
name|void
name|visitFromCached
parameter_list|(
name|Document
name|document
parameter_list|,
name|StoredFieldVisitor
name|visitor
parameter_list|)
throws|throws
name|IOException
block|{
for|for
control|(
name|IndexableField
name|f
range|:
name|document
control|)
block|{
specifier|final
name|FieldInfo
name|info
init|=
name|fieldInfos
operator|.
name|fieldInfo
argument_list|(
name|f
operator|.
name|name
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|Status
name|needsField
init|=
name|visitor
operator|.
name|needsField
argument_list|(
name|info
argument_list|)
decl_stmt|;
if|if
condition|(
name|needsField
operator|==
name|Status
operator|.
name|STOP
condition|)
return|return;
if|if
condition|(
name|needsField
operator|==
name|Status
operator|.
name|NO
condition|)
continue|continue;
if|if
condition|(
name|f
operator|.
name|binaryValue
argument_list|()
operator|!=
literal|null
condition|)
block|{
specifier|final
name|BytesRef
name|binaryValue
init|=
name|f
operator|.
name|binaryValue
argument_list|()
decl_stmt|;
specifier|final
name|byte
name|copy
index|[]
init|=
operator|new
name|byte
index|[
name|binaryValue
operator|.
name|length
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|binaryValue
operator|.
name|bytes
argument_list|,
name|binaryValue
operator|.
name|offset
argument_list|,
name|copy
argument_list|,
literal|0
argument_list|,
name|copy
operator|.
name|length
argument_list|)
expr_stmt|;
name|visitor
operator|.
name|binaryField
argument_list|(
name|info
argument_list|,
name|copy
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|f
operator|.
name|numericValue
argument_list|()
operator|!=
literal|null
condition|)
block|{
specifier|final
name|Number
name|numericValue
init|=
name|f
operator|.
name|numericValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|numericValue
operator|instanceof
name|Double
condition|)
block|{
name|visitor
operator|.
name|doubleField
argument_list|(
name|info
argument_list|,
name|numericValue
operator|.
name|doubleValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|numericValue
operator|instanceof
name|Integer
condition|)
block|{
name|visitor
operator|.
name|intField
argument_list|(
name|info
argument_list|,
name|numericValue
operator|.
name|intValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|numericValue
operator|instanceof
name|Float
condition|)
block|{
name|visitor
operator|.
name|floatField
argument_list|(
name|info
argument_list|,
name|numericValue
operator|.
name|floatValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|numericValue
operator|instanceof
name|Long
condition|)
block|{
name|visitor
operator|.
name|longField
argument_list|(
name|info
argument_list|,
name|numericValue
operator|.
name|longValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|AssertionError
argument_list|()
throw|;
block|}
block|}
else|else
block|{
name|visitor
operator|.
name|stringField
argument_list|(
name|info
argument_list|,
name|f
operator|.
name|stringValue
argument_list|()
operator|.
name|getBytes
argument_list|(
name|StandardCharsets
operator|.
name|UTF_8
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Retrieve the {@link Document} instance corresponding to the document id.    *<p>    *<b>NOTE</b>: the document will have all fields accessible, but if a field filter is provided, only the provided    * fields will be loaded (the remainder will be available lazily).    */
annotation|@
name|Override
DECL|method|doc
specifier|public
name|Document
name|doc
parameter_list|(
name|int
name|i
parameter_list|,
name|Set
argument_list|<
name|String
argument_list|>
name|fields
parameter_list|)
throws|throws
name|IOException
block|{
name|Document
name|d
decl_stmt|;
if|if
condition|(
name|documentCache
operator|!=
literal|null
condition|)
block|{
name|d
operator|=
name|documentCache
operator|.
name|get
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|!=
literal|null
condition|)
return|return
name|d
return|;
block|}
specifier|final
name|DirectoryReader
name|reader
init|=
name|getIndexReader
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|enableLazyFieldLoading
operator|||
name|fields
operator|==
literal|null
condition|)
block|{
name|d
operator|=
name|reader
operator|.
name|document
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|final
name|SetNonLazyFieldSelector
name|visitor
init|=
operator|new
name|SetNonLazyFieldSelector
argument_list|(
name|fields
argument_list|,
name|reader
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|reader
operator|.
name|document
argument_list|(
name|i
argument_list|,
name|visitor
argument_list|)
expr_stmt|;
name|d
operator|=
name|visitor
operator|.
name|doc
expr_stmt|;
block|}
if|if
condition|(
name|documentCache
operator|!=
literal|null
condition|)
block|{
name|documentCache
operator|.
name|put
argument_list|(
name|i
argument_list|,
name|d
argument_list|)
expr_stmt|;
block|}
return|return
name|d
return|;
block|}
comment|/**    * This will fetch and add the docValues fields to a given SolrDocument/SolrInputDocument    *    * @param doc    *          A SolrDocument or SolrInputDocument instance where docValues will be added    * @param docid    *          The lucene docid of the document to be populated    * @param fields    *          The list of docValues fields to be decorated    */
DECL|method|decorateDocValueFields
specifier|public
name|void
name|decorateDocValueFields
parameter_list|(
annotation|@
name|SuppressWarnings
argument_list|(
literal|"rawtypes"
argument_list|)
name|SolrDocumentBase
name|doc
parameter_list|,
name|int
name|docid
parameter_list|,
name|Set
argument_list|<
name|String
argument_list|>
name|fields
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|LeafReader
name|reader
init|=
name|getLeafReader
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|fieldName
range|:
name|fields
control|)
block|{
specifier|final
name|SchemaField
name|schemaField
init|=
name|schema
operator|.
name|getFieldOrNull
argument_list|(
name|fieldName
argument_list|)
decl_stmt|;
if|if
condition|(
name|schemaField
operator|==
literal|null
operator|||
operator|!
name|schemaField
operator|.
name|hasDocValues
argument_list|()
operator|||
name|doc
operator|.
name|containsKey
argument_list|(
name|fieldName
argument_list|)
condition|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Couldn't decorate docValues for field: [{}], schemaField: [{}]"
argument_list|,
name|fieldName
argument_list|,
name|schemaField
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|DocValues
operator|.
name|getDocsWithField
argument_list|(
name|leafReader
argument_list|,
name|fieldName
argument_list|)
operator|.
name|get
argument_list|(
name|docid
argument_list|)
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|schemaField
operator|.
name|multiValued
argument_list|()
condition|)
block|{
specifier|final
name|SortedSetDocValues
name|values
init|=
name|reader
operator|.
name|getSortedSetDocValues
argument_list|(
name|fieldName
argument_list|)
decl_stmt|;
if|if
condition|(
name|values
operator|!=
literal|null
operator|&&
name|values
operator|.
name|getValueCount
argument_list|()
operator|>
literal|0
condition|)
block|{
name|values
operator|.
name|setDocument
argument_list|(
name|docid
argument_list|)
expr_stmt|;
specifier|final
name|List
argument_list|<
name|Object
argument_list|>
name|outValues
init|=
operator|new
name|LinkedList
argument_list|<
name|Object
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|long
name|ord
init|=
name|values
operator|.
name|nextOrd
argument_list|()
init|;
name|ord
operator|!=
name|SortedSetDocValues
operator|.
name|NO_MORE_ORDS
condition|;
name|ord
operator|=
name|values
operator|.
name|nextOrd
argument_list|()
control|)
block|{
specifier|final
name|BytesRef
name|value
init|=
name|values
operator|.
name|lookupOrd
argument_list|(
name|ord
argument_list|)
decl_stmt|;
name|outValues
operator|.
name|add
argument_list|(
name|schemaField
operator|.
name|getType
argument_list|()
operator|.
name|toObject
argument_list|(
name|schemaField
argument_list|,
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|outValues
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
name|doc
operator|.
name|addField
argument_list|(
name|fieldName
argument_list|,
name|outValues
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
specifier|final
name|DocValuesType
name|dvType
init|=
name|fieldInfos
operator|.
name|fieldInfo
argument_list|(
name|fieldName
argument_list|)
operator|.
name|getDocValuesType
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|dvType
condition|)
block|{
case|case
name|NUMERIC
case|:
specifier|final
name|NumericDocValues
name|ndv
init|=
name|leafReader
operator|.
name|getNumericDocValues
argument_list|(
name|fieldName
argument_list|)
decl_stmt|;
name|Long
name|val
init|=
name|ndv
operator|.
name|get
argument_list|(
name|docid
argument_list|)
decl_stmt|;
name|Object
name|newVal
init|=
name|val
decl_stmt|;
if|if
condition|(
name|schemaField
operator|.
name|getType
argument_list|()
operator|instanceof
name|TrieIntField
condition|)
block|{
name|newVal
operator|=
name|val
operator|.
name|intValue
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|schemaField
operator|.
name|getType
argument_list|()
operator|instanceof
name|TrieFloatField
condition|)
block|{
name|newVal
operator|=
name|Float
operator|.
name|intBitsToFloat
argument_list|(
name|val
operator|.
name|intValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|schemaField
operator|.
name|getType
argument_list|()
operator|instanceof
name|TrieDoubleField
condition|)
block|{
name|newVal
operator|=
name|Double
operator|.
name|longBitsToDouble
argument_list|(
name|val
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|schemaField
operator|.
name|getType
argument_list|()
operator|instanceof
name|TrieDateField
condition|)
block|{
name|newVal
operator|=
operator|new
name|Date
argument_list|(
name|val
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|schemaField
operator|.
name|getType
argument_list|()
operator|instanceof
name|EnumField
condition|)
block|{
name|newVal
operator|=
operator|(
operator|(
name|EnumField
operator|)
name|schemaField
operator|.
name|getType
argument_list|()
operator|)
operator|.
name|intValueToStringValue
argument_list|(
name|val
operator|.
name|intValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|doc
operator|.
name|addField
argument_list|(
name|fieldName
argument_list|,
name|newVal
argument_list|)
expr_stmt|;
break|break;
case|case
name|BINARY
case|:
name|BinaryDocValues
name|bdv
init|=
name|leafReader
operator|.
name|getBinaryDocValues
argument_list|(
name|fieldName
argument_list|)
decl_stmt|;
name|doc
operator|.
name|addField
argument_list|(
name|fieldName
argument_list|,
name|bdv
operator|.
name|get
argument_list|(
name|docid
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SORTED
case|:
name|SortedDocValues
name|sdv
init|=
name|leafReader
operator|.
name|getSortedDocValues
argument_list|(
name|fieldName
argument_list|)
decl_stmt|;
if|if
condition|(
name|sdv
operator|.
name|getOrd
argument_list|(
name|docid
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|doc
operator|.
name|addField
argument_list|(
name|fieldName
argument_list|,
name|sdv
operator|.
name|get
argument_list|(
name|docid
argument_list|)
operator|.
name|utf8ToString
argument_list|()
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SORTED_NUMERIC
case|:
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"SORTED_NUMERIC not supported yet!"
argument_list|)
throw|;
case|case
name|SORTED_SET
case|:
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"SORTED_SET fields should be multi-valued!"
argument_list|)
throw|;
case|case
name|NONE
case|:
comment|// Shouldn't happen since we check that the document has a DocValues field.
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"Document does not have a DocValues field with the name '"
operator|+
name|fieldName
operator|+
literal|"'!"
argument_list|)
throw|;
block|}
block|}
block|}
block|}
comment|/**    * Takes a list of docs (the doc ids actually), and reads them into an array of Documents.    */
DECL|method|readDocs
specifier|public
name|void
name|readDocs
parameter_list|(
name|Document
index|[]
name|docs
parameter_list|,
name|DocList
name|ids
parameter_list|)
throws|throws
name|IOException
block|{
name|readDocs
argument_list|(
name|docs
argument_list|,
name|ids
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/**    * Takes a list of docs (the doc ids actually) and a set of fields to load, and reads them into an array of Documents.    */
DECL|method|readDocs
specifier|public
name|void
name|readDocs
parameter_list|(
name|Document
index|[]
name|docs
parameter_list|,
name|DocList
name|ids
parameter_list|,
name|Set
argument_list|<
name|String
argument_list|>
name|fields
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|DocIterator
name|iter
init|=
name|ids
operator|.
name|iterator
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|docs
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|docs
index|[
name|i
index|]
operator|=
name|doc
argument_list|(
name|iter
operator|.
name|nextDoc
argument_list|()
argument_list|,
name|fields
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Returns an unmodifiable set of non-stored docValues field names.    *    * @param onlyUseDocValuesAsStored    *          If false, returns all non-stored docValues. If true, returns only those non-stored docValues which have    *          the {@link SchemaField#useDocValuesAsStored()} flag true.    */
DECL|method|getNonStoredDVs
specifier|public
name|Set
argument_list|<
name|String
argument_list|>
name|getNonStoredDVs
parameter_list|(
name|boolean
name|onlyUseDocValuesAsStored
parameter_list|)
block|{
return|return
name|onlyUseDocValuesAsStored
condition|?
name|nonStoredDVsUsedAsStored
else|:
name|allNonStoredDVs
return|;
block|}
comment|/* ********************** end document retrieval *************************/
comment|////////////////////////////////////////////////////////////////////////////////
comment|////////////////////////////////////////////////////////////////////////////////
comment|////////////////////////////////////////////////////////////////////////////////
comment|/** expert: internal API, subject to change */
DECL|method|getFieldValueCache
specifier|public
name|SolrCache
argument_list|<
name|String
argument_list|,
name|UnInvertedField
argument_list|>
name|getFieldValueCache
parameter_list|()
block|{
return|return
name|fieldValueCache
return|;
block|}
comment|/** Returns a weighted sort according to this searcher */
DECL|method|weightSort
specifier|public
name|Sort
name|weightSort
parameter_list|(
name|Sort
name|sort
parameter_list|)
throws|throws
name|IOException
block|{
return|return
operator|(
name|sort
operator|!=
literal|null
operator|)
condition|?
name|sort
operator|.
name|rewrite
argument_list|(
name|this
argument_list|)
else|:
literal|null
return|;
block|}
comment|/**    * Returns the first document number containing the term<code>t</code> Returns -1 if no document was found. This    * method is primarily intended for clients that want to fetch documents using a unique identifier."    *     * @return the first document number containing the term    */
DECL|method|getFirstMatch
specifier|public
name|int
name|getFirstMatch
parameter_list|(
name|Term
name|t
parameter_list|)
throws|throws
name|IOException
block|{
name|Terms
name|terms
init|=
name|leafReader
operator|.
name|terms
argument_list|(
name|t
operator|.
name|field
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|terms
operator|==
literal|null
condition|)
return|return
operator|-
literal|1
return|;
name|BytesRef
name|termBytes
init|=
name|t
operator|.
name|bytes
argument_list|()
decl_stmt|;
specifier|final
name|TermsEnum
name|termsEnum
init|=
name|terms
operator|.
name|iterator
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|termsEnum
operator|.
name|seekExact
argument_list|(
name|termBytes
argument_list|)
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
name|PostingsEnum
name|docs
init|=
name|termsEnum
operator|.
name|postings
argument_list|(
literal|null
argument_list|,
name|PostingsEnum
operator|.
name|NONE
argument_list|)
decl_stmt|;
name|docs
operator|=
name|BitsFilteredPostingsEnum
operator|.
name|wrap
argument_list|(
name|docs
argument_list|,
name|leafReader
operator|.
name|getLiveDocs
argument_list|()
argument_list|)
expr_stmt|;
name|int
name|id
init|=
name|docs
operator|.
name|nextDoc
argument_list|()
decl_stmt|;
return|return
name|id
operator|==
name|DocIdSetIterator
operator|.
name|NO_MORE_DOCS
condition|?
operator|-
literal|1
else|:
name|id
return|;
block|}
comment|/**    * lookup the docid by the unique key field, and return the id *within* the leaf reader in the low 32 bits, and the    * index of the leaf reader in the high 32 bits. -1 is returned if not found.    *     * @lucene.internal    */
DECL|method|lookupId
specifier|public
name|long
name|lookupId
parameter_list|(
name|BytesRef
name|idBytes
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|field
init|=
name|schema
operator|.
name|getUniqueKeyField
argument_list|()
operator|.
name|getName
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|,
name|c
init|=
name|leafContexts
operator|.
name|size
argument_list|()
init|;
name|i
operator|<
name|c
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|LeafReaderContext
name|leaf
init|=
name|leafContexts
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
specifier|final
name|LeafReader
name|reader
init|=
name|leaf
operator|.
name|reader
argument_list|()
decl_stmt|;
specifier|final
name|Terms
name|terms
init|=
name|reader
operator|.
name|terms
argument_list|(
name|field
argument_list|)
decl_stmt|;
if|if
condition|(
name|terms
operator|==
literal|null
condition|)
continue|continue;
name|TermsEnum
name|te
init|=
name|terms
operator|.
name|iterator
argument_list|()
decl_stmt|;
if|if
condition|(
name|te
operator|.
name|seekExact
argument_list|(
name|idBytes
argument_list|)
condition|)
block|{
name|PostingsEnum
name|docs
init|=
name|te
operator|.
name|postings
argument_list|(
literal|null
argument_list|,
name|PostingsEnum
operator|.
name|NONE
argument_list|)
decl_stmt|;
name|docs
operator|=
name|BitsFilteredPostingsEnum
operator|.
name|wrap
argument_list|(
name|docs
argument_list|,
name|reader
operator|.
name|getLiveDocs
argument_list|()
argument_list|)
expr_stmt|;
name|int
name|id
init|=
name|docs
operator|.
name|nextDoc
argument_list|()
decl_stmt|;
if|if
condition|(
name|id
operator|==
name|DocIdSetIterator
operator|.
name|NO_MORE_DOCS
condition|)
continue|continue;
assert|assert
name|docs
operator|.
name|nextDoc
argument_list|()
operator|==
name|DocIdSetIterator
operator|.
name|NO_MORE_DOCS
assert|;
return|return
operator|(
operator|(
operator|(
name|long
operator|)
name|i
operator|)
operator|<<
literal|32
operator|)
operator||
name|id
return|;
block|}
block|}
return|return
operator|-
literal|1
return|;
block|}
comment|/**    * Compute and cache the DocSet that matches a query. The normal usage is expected to be cacheDocSet(myQuery,    * null,false) meaning that Solr will determine if the Query warrants caching, and if so, will compute the DocSet that    * matches the Query and cache it. If the answer to the query is already cached, nothing further will be done.    *<p>    * If the optionalAnswer DocSet is provided, it should *not* be modified after this call.    *    * @param query    *          the lucene query that will act as the key    * @param optionalAnswer    *          the DocSet to be cached - if null, it will be computed.    * @param mustCache    *          if true, a best effort will be made to cache this entry. if false, heuristics may be used to determine if    *          it should be cached.    */
DECL|method|cacheDocSet
specifier|public
name|void
name|cacheDocSet
parameter_list|(
name|Query
name|query
parameter_list|,
name|DocSet
name|optionalAnswer
parameter_list|,
name|boolean
name|mustCache
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Even if the cache is null, still compute the DocSet as it may serve to warm the Lucene
comment|// or OS disk cache.
if|if
condition|(
name|optionalAnswer
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|filterCache
operator|!=
literal|null
condition|)
block|{
name|filterCache
operator|.
name|put
argument_list|(
name|query
argument_list|,
name|optionalAnswer
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
comment|// Throw away the result, relying on the fact that getDocSet
comment|// will currently always cache what it found. If getDocSet() starts
comment|// using heuristics about what to cache, and mustCache==true, (or if we
comment|// want this method to start using heuristics too) then
comment|// this needs to change.
name|getDocSet
argument_list|(
name|query
argument_list|)
expr_stmt|;
block|}
DECL|method|getDocSetBits
specifier|public
name|BitDocSet
name|getDocSetBits
parameter_list|(
name|Query
name|q
parameter_list|)
throws|throws
name|IOException
block|{
name|DocSet
name|answer
init|=
name|getDocSet
argument_list|(
name|q
argument_list|)
decl_stmt|;
if|if
condition|(
name|answer
operator|instanceof
name|BitDocSet
condition|)
block|{
return|return
operator|(
name|BitDocSet
operator|)
name|answer
return|;
block|}
name|FixedBitSet
name|bs
init|=
operator|new
name|FixedBitSet
argument_list|(
name|maxDoc
argument_list|()
argument_list|)
decl_stmt|;
name|DocIterator
name|iter
init|=
name|answer
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|iter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|bs
operator|.
name|set
argument_list|(
name|iter
operator|.
name|nextDoc
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|BitDocSet
name|answerBits
init|=
operator|new
name|BitDocSet
argument_list|(
name|bs
argument_list|,
name|answer
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|filterCache
operator|!=
literal|null
condition|)
block|{
name|filterCache
operator|.
name|put
argument_list|(
name|q
argument_list|,
name|answerBits
argument_list|)
expr_stmt|;
block|}
return|return
name|answerBits
return|;
block|}
comment|/**    * Returns the set of document ids matching a query. This method is cache-aware and attempts to retrieve the answer    * from the cache if possible. If the answer was not cached, it may have been inserted into the cache as a result of    * this call. This method can handle negative queries.    *<p>    * The DocSet returned should<b>not</b> be modified.    */
DECL|method|getDocSet
specifier|public
name|DocSet
name|getDocSet
parameter_list|(
name|Query
name|query
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|query
operator|instanceof
name|ExtendedQuery
condition|)
block|{
name|ExtendedQuery
name|eq
init|=
operator|(
name|ExtendedQuery
operator|)
name|query
decl_stmt|;
if|if
condition|(
operator|!
name|eq
operator|.
name|getCache
argument_list|()
condition|)
block|{
if|if
condition|(
name|query
operator|instanceof
name|WrappedQuery
condition|)
block|{
name|query
operator|=
operator|(
operator|(
name|WrappedQuery
operator|)
name|query
operator|)
operator|.
name|getWrappedQuery
argument_list|()
expr_stmt|;
block|}
name|query
operator|=
name|QueryUtils
operator|.
name|makeQueryable
argument_list|(
name|query
argument_list|)
expr_stmt|;
return|return
name|getDocSetNC
argument_list|(
name|query
argument_list|,
literal|null
argument_list|)
return|;
block|}
block|}
comment|// Get the absolute value (positive version) of this query. If we
comment|// get back the same reference, we know it's positive.
name|Query
name|absQ
init|=
name|QueryUtils
operator|.
name|getAbs
argument_list|(
name|query
argument_list|)
decl_stmt|;
name|boolean
name|positive
init|=
name|query
operator|==
name|absQ
decl_stmt|;
if|if
condition|(
name|filterCache
operator|!=
literal|null
condition|)
block|{
name|DocSet
name|absAnswer
init|=
name|filterCache
operator|.
name|get
argument_list|(
name|absQ
argument_list|)
decl_stmt|;
if|if
condition|(
name|absAnswer
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|positive
condition|)
return|return
name|absAnswer
return|;
else|else
return|return
name|getLiveDocs
argument_list|()
operator|.
name|andNot
argument_list|(
name|absAnswer
argument_list|)
return|;
block|}
block|}
name|DocSet
name|absAnswer
init|=
name|getDocSetNC
argument_list|(
name|absQ
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|DocSet
name|answer
init|=
name|positive
condition|?
name|absAnswer
else|:
name|getLiveDocs
argument_list|()
operator|.
name|andNot
argument_list|(
name|absAnswer
argument_list|)
decl_stmt|;
if|if
condition|(
name|filterCache
operator|!=
literal|null
condition|)
block|{
comment|// cache negative queries as positive
name|filterCache
operator|.
name|put
argument_list|(
name|absQ
argument_list|,
name|absAnswer
argument_list|)
expr_stmt|;
block|}
return|return
name|answer
return|;
block|}
comment|// only handle positive (non negative) queries
DECL|method|getPositiveDocSet
name|DocSet
name|getPositiveDocSet
parameter_list|(
name|Query
name|q
parameter_list|)
throws|throws
name|IOException
block|{
name|DocSet
name|answer
decl_stmt|;
if|if
condition|(
name|filterCache
operator|!=
literal|null
condition|)
block|{
name|answer
operator|=
name|filterCache
operator|.
name|get
argument_list|(
name|q
argument_list|)
expr_stmt|;
if|if
condition|(
name|answer
operator|!=
literal|null
condition|)
return|return
name|answer
return|;
block|}
name|answer
operator|=
name|getDocSetNC
argument_list|(
name|q
argument_list|,
literal|null
argument_list|)
expr_stmt|;
if|if
condition|(
name|filterCache
operator|!=
literal|null
condition|)
name|filterCache
operator|.
name|put
argument_list|(
name|q
argument_list|,
name|answer
argument_list|)
expr_stmt|;
return|return
name|answer
return|;
block|}
DECL|field|matchAllDocsQuery
specifier|private
specifier|static
name|Query
name|matchAllDocsQuery
init|=
operator|new
name|MatchAllDocsQuery
argument_list|()
decl_stmt|;
DECL|field|liveDocs
specifier|private
name|BitDocSet
name|liveDocs
decl_stmt|;
DECL|method|getLiveDocs
specifier|public
name|BitDocSet
name|getLiveDocs
parameter_list|()
throws|throws
name|IOException
block|{
comment|// going through the filter cache will provide thread safety here
if|if
condition|(
name|liveDocs
operator|==
literal|null
condition|)
block|{
name|liveDocs
operator|=
name|getDocSetBits
argument_list|(
name|matchAllDocsQuery
argument_list|)
expr_stmt|;
block|}
return|return
name|liveDocs
return|;
block|}
DECL|class|ProcessedFilter
specifier|public
specifier|static
class|class
name|ProcessedFilter
block|{
DECL|field|answer
specifier|public
name|DocSet
name|answer
decl_stmt|;
comment|// the answer, if non-null
DECL|field|filter
specifier|public
name|Filter
name|filter
decl_stmt|;
DECL|field|postFilter
specifier|public
name|DelegatingCollector
name|postFilter
decl_stmt|;
DECL|field|hasDeletedDocs
specifier|public
name|boolean
name|hasDeletedDocs
decl_stmt|;
comment|// true if it's possible that filter may match deleted docs
block|}
DECL|field|sortByCost
specifier|private
specifier|static
name|Comparator
argument_list|<
name|Query
argument_list|>
name|sortByCost
init|=
parameter_list|(
name|q1
parameter_list|,
name|q2
parameter_list|)
lambda|->
operator|(
operator|(
name|ExtendedQuery
operator|)
name|q1
operator|)
operator|.
name|getCost
argument_list|()
operator|-
operator|(
operator|(
name|ExtendedQuery
operator|)
name|q2
operator|)
operator|.
name|getCost
argument_list|()
decl_stmt|;
DECL|method|getDocSetScore
specifier|private
name|DocSet
name|getDocSetScore
parameter_list|(
name|List
argument_list|<
name|Query
argument_list|>
name|queries
parameter_list|)
throws|throws
name|IOException
block|{
name|Query
name|main
init|=
name|queries
operator|.
name|remove
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|ProcessedFilter
name|pf
init|=
name|getProcessedFilter
argument_list|(
literal|null
argument_list|,
name|queries
argument_list|)
decl_stmt|;
name|DocSetCollector
name|setCollector
init|=
operator|new
name|DocSetCollector
argument_list|(
name|maxDoc
argument_list|()
argument_list|)
decl_stmt|;
name|Collector
name|collector
init|=
name|setCollector
decl_stmt|;
if|if
condition|(
name|pf
operator|.
name|postFilter
operator|!=
literal|null
condition|)
block|{
name|pf
operator|.
name|postFilter
operator|.
name|setLastDelegate
argument_list|(
name|collector
argument_list|)
expr_stmt|;
name|collector
operator|=
name|pf
operator|.
name|postFilter
expr_stmt|;
block|}
if|if
condition|(
name|pf
operator|.
name|filter
operator|!=
literal|null
condition|)
block|{
name|Query
name|query
init|=
operator|new
name|BooleanQuery
operator|.
name|Builder
argument_list|()
operator|.
name|add
argument_list|(
name|main
argument_list|,
name|Occur
operator|.
name|MUST
argument_list|)
operator|.
name|add
argument_list|(
name|pf
operator|.
name|filter
argument_list|,
name|Occur
operator|.
name|FILTER
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|search
argument_list|(
name|query
argument_list|,
name|collector
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|search
argument_list|(
name|main
argument_list|,
name|collector
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|collector
operator|instanceof
name|DelegatingCollector
condition|)
block|{
operator|(
operator|(
name|DelegatingCollector
operator|)
name|collector
operator|)
operator|.
name|finish
argument_list|()
expr_stmt|;
block|}
name|DocSet
name|docSet
init|=
name|setCollector
operator|.
name|getDocSet
argument_list|()
decl_stmt|;
return|return
name|docSet
return|;
block|}
comment|/**    * Returns the set of document ids matching all queries. This method is cache-aware and attempts to retrieve the    * answer from the cache if possible. If the answer was not cached, it may have been inserted into the cache as a    * result of this call. This method can handle negative queries.    *<p>    * The DocSet returned should<b>not</b> be modified.    */
DECL|method|getDocSet
specifier|public
name|DocSet
name|getDocSet
parameter_list|(
name|List
argument_list|<
name|Query
argument_list|>
name|queries
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|queries
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|Query
name|q
range|:
name|queries
control|)
block|{
if|if
condition|(
name|q
operator|instanceof
name|ScoreFilter
condition|)
block|{
return|return
name|getDocSetScore
argument_list|(
name|queries
argument_list|)
return|;
block|}
block|}
block|}
name|ProcessedFilter
name|pf
init|=
name|getProcessedFilter
argument_list|(
literal|null
argument_list|,
name|queries
argument_list|)
decl_stmt|;
if|if
condition|(
name|pf
operator|.
name|answer
operator|!=
literal|null
condition|)
return|return
name|pf
operator|.
name|answer
return|;
name|DocSetCollector
name|setCollector
init|=
operator|new
name|DocSetCollector
argument_list|(
name|maxDoc
argument_list|()
argument_list|)
decl_stmt|;
name|Collector
name|collector
init|=
name|setCollector
decl_stmt|;
if|if
condition|(
name|pf
operator|.
name|postFilter
operator|!=
literal|null
condition|)
block|{
name|pf
operator|.
name|postFilter
operator|.
name|setLastDelegate
argument_list|(
name|collector
argument_list|)
expr_stmt|;
name|collector
operator|=
name|pf
operator|.
name|postFilter
expr_stmt|;
block|}
for|for
control|(
specifier|final
name|LeafReaderContext
name|leaf
range|:
name|leafContexts
control|)
block|{
specifier|final
name|LeafReader
name|reader
init|=
name|leaf
operator|.
name|reader
argument_list|()
decl_stmt|;
name|Bits
name|liveDocs
init|=
name|reader
operator|.
name|getLiveDocs
argument_list|()
decl_stmt|;
name|DocIdSet
name|idSet
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|pf
operator|.
name|filter
operator|!=
literal|null
condition|)
block|{
name|idSet
operator|=
name|pf
operator|.
name|filter
operator|.
name|getDocIdSet
argument_list|(
name|leaf
argument_list|,
name|liveDocs
argument_list|)
expr_stmt|;
if|if
condition|(
name|idSet
operator|==
literal|null
condition|)
continue|continue;
block|}
name|DocIdSetIterator
name|idIter
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|idSet
operator|!=
literal|null
condition|)
block|{
name|idIter
operator|=
name|idSet
operator|.
name|iterator
argument_list|()
expr_stmt|;
if|if
condition|(
name|idIter
operator|==
literal|null
condition|)
continue|continue;
if|if
condition|(
operator|!
name|pf
operator|.
name|hasDeletedDocs
condition|)
name|liveDocs
operator|=
literal|null
expr_stmt|;
comment|// no need to check liveDocs
block|}
specifier|final
name|LeafCollector
name|leafCollector
init|=
name|collector
operator|.
name|getLeafCollector
argument_list|(
name|leaf
argument_list|)
decl_stmt|;
name|int
name|max
init|=
name|reader
operator|.
name|maxDoc
argument_list|()
decl_stmt|;
if|if
condition|(
name|idIter
operator|==
literal|null
condition|)
block|{
for|for
control|(
name|int
name|docid
init|=
literal|0
init|;
name|docid
operator|<
name|max
condition|;
name|docid
operator|++
control|)
block|{
if|if
condition|(
name|liveDocs
operator|!=
literal|null
operator|&&
operator|!
name|liveDocs
operator|.
name|get
argument_list|(
name|docid
argument_list|)
condition|)
continue|continue;
name|leafCollector
operator|.
name|collect
argument_list|(
name|docid
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|liveDocs
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|int
name|docid
init|=
operator|-
literal|1
init|;
operator|(
name|docid
operator|=
name|idIter
operator|.
name|advance
argument_list|(
name|docid
operator|+
literal|1
argument_list|)
operator|)
operator|<
name|max
condition|;
control|)
block|{
if|if
condition|(
name|liveDocs
operator|.
name|get
argument_list|(
name|docid
argument_list|)
condition|)
name|leafCollector
operator|.
name|collect
argument_list|(
name|docid
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|int
name|docid
init|=
operator|-
literal|1
init|;
operator|(
name|docid
operator|=
name|idIter
operator|.
name|advance
argument_list|(
name|docid
operator|+
literal|1
argument_list|)
operator|)
operator|<
name|max
condition|;
control|)
block|{
name|leafCollector
operator|.
name|collect
argument_list|(
name|docid
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|collector
operator|instanceof
name|DelegatingCollector
condition|)
block|{
operator|(
operator|(
name|DelegatingCollector
operator|)
name|collector
operator|)
operator|.
name|finish
argument_list|()
expr_stmt|;
block|}
return|return
name|setCollector
operator|.
name|getDocSet
argument_list|()
return|;
block|}
DECL|method|getProcessedFilter
specifier|public
name|ProcessedFilter
name|getProcessedFilter
parameter_list|(
name|DocSet
name|setFilter
parameter_list|,
name|List
argument_list|<
name|Query
argument_list|>
name|queries
parameter_list|)
throws|throws
name|IOException
block|{
name|ProcessedFilter
name|pf
init|=
operator|new
name|ProcessedFilter
argument_list|()
decl_stmt|;
if|if
condition|(
name|queries
operator|==
literal|null
operator|||
name|queries
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|setFilter
operator|!=
literal|null
condition|)
name|pf
operator|.
name|filter
operator|=
name|setFilter
operator|.
name|getTopFilter
argument_list|()
expr_stmt|;
return|return
name|pf
return|;
block|}
name|DocSet
name|answer
init|=
literal|null
decl_stmt|;
name|boolean
index|[]
name|neg
init|=
operator|new
name|boolean
index|[
name|queries
operator|.
name|size
argument_list|()
operator|+
literal|1
index|]
decl_stmt|;
name|DocSet
index|[]
name|sets
init|=
operator|new
name|DocSet
index|[
name|queries
operator|.
name|size
argument_list|()
operator|+
literal|1
index|]
decl_stmt|;
name|List
argument_list|<
name|Query
argument_list|>
name|notCached
init|=
literal|null
decl_stmt|;
name|List
argument_list|<
name|Query
argument_list|>
name|postFilters
init|=
literal|null
decl_stmt|;
name|int
name|end
init|=
literal|0
decl_stmt|;
name|int
name|smallestIndex
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|setFilter
operator|!=
literal|null
condition|)
block|{
name|answer
operator|=
name|sets
index|[
name|end
operator|++
index|]
operator|=
name|setFilter
expr_stmt|;
name|smallestIndex
operator|=
name|end
expr_stmt|;
block|}
name|int
name|smallestCount
init|=
name|Integer
operator|.
name|MAX_VALUE
decl_stmt|;
for|for
control|(
name|Query
name|q
range|:
name|queries
control|)
block|{
if|if
condition|(
name|q
operator|instanceof
name|ExtendedQuery
condition|)
block|{
name|ExtendedQuery
name|eq
init|=
operator|(
name|ExtendedQuery
operator|)
name|q
decl_stmt|;
if|if
condition|(
operator|!
name|eq
operator|.
name|getCache
argument_list|()
condition|)
block|{
if|if
condition|(
name|eq
operator|.
name|getCost
argument_list|()
operator|>=
literal|100
operator|&&
name|eq
operator|instanceof
name|PostFilter
condition|)
block|{
if|if
condition|(
name|postFilters
operator|==
literal|null
condition|)
name|postFilters
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|sets
operator|.
name|length
operator|-
name|end
argument_list|)
expr_stmt|;
name|postFilters
operator|.
name|add
argument_list|(
name|q
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|notCached
operator|==
literal|null
condition|)
name|notCached
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|sets
operator|.
name|length
operator|-
name|end
argument_list|)
expr_stmt|;
name|notCached
operator|.
name|add
argument_list|(
name|q
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
block|}
if|if
condition|(
name|filterCache
operator|==
literal|null
condition|)
block|{
comment|// there is no cache: don't pull bitsets
if|if
condition|(
name|notCached
operator|==
literal|null
condition|)
name|notCached
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|sets
operator|.
name|length
operator|-
name|end
argument_list|)
expr_stmt|;
name|WrappedQuery
name|uncached
init|=
operator|new
name|WrappedQuery
argument_list|(
name|q
argument_list|)
decl_stmt|;
name|uncached
operator|.
name|setCache
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|notCached
operator|.
name|add
argument_list|(
name|uncached
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|Query
name|posQuery
init|=
name|QueryUtils
operator|.
name|getAbs
argument_list|(
name|q
argument_list|)
decl_stmt|;
name|sets
index|[
name|end
index|]
operator|=
name|getPositiveDocSet
argument_list|(
name|posQuery
argument_list|)
expr_stmt|;
comment|// Negative query if absolute value different from original
if|if
condition|(
name|q
operator|==
name|posQuery
condition|)
block|{
name|neg
index|[
name|end
index|]
operator|=
literal|false
expr_stmt|;
comment|// keep track of the smallest positive set.
comment|// This optimization is only worth it if size() is cached, which it would
comment|// be if we don't do any set operations.
name|int
name|sz
init|=
name|sets
index|[
name|end
index|]
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|sz
operator|<
name|smallestCount
condition|)
block|{
name|smallestCount
operator|=
name|sz
expr_stmt|;
name|smallestIndex
operator|=
name|end
expr_stmt|;
name|answer
operator|=
name|sets
index|[
name|end
index|]
expr_stmt|;
block|}
block|}
else|else
block|{
name|neg
index|[
name|end
index|]
operator|=
literal|true
expr_stmt|;
block|}
name|end
operator|++
expr_stmt|;
block|}
comment|// Are all of our normal cached filters negative?
if|if
condition|(
name|end
operator|>
literal|0
operator|&&
name|answer
operator|==
literal|null
condition|)
block|{
name|answer
operator|=
name|getLiveDocs
argument_list|()
expr_stmt|;
block|}
comment|// do negative queries first to shrink set size
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|end
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|neg
index|[
name|i
index|]
condition|)
name|answer
operator|=
name|answer
operator|.
name|andNot
argument_list|(
name|sets
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|end
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|neg
index|[
name|i
index|]
operator|&&
name|i
operator|!=
name|smallestIndex
condition|)
name|answer
operator|=
name|answer
operator|.
name|intersection
argument_list|(
name|sets
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|notCached
operator|!=
literal|null
condition|)
block|{
name|Collections
operator|.
name|sort
argument_list|(
name|notCached
argument_list|,
name|sortByCost
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|Weight
argument_list|>
name|weights
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|notCached
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|Query
name|q
range|:
name|notCached
control|)
block|{
name|Query
name|qq
init|=
name|QueryUtils
operator|.
name|makeQueryable
argument_list|(
name|q
argument_list|)
decl_stmt|;
name|weights
operator|.
name|add
argument_list|(
name|createNormalizedWeight
argument_list|(
name|qq
argument_list|,
literal|true
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|pf
operator|.
name|filter
operator|=
operator|new
name|FilterImpl
argument_list|(
name|answer
argument_list|,
name|weights
argument_list|)
expr_stmt|;
name|pf
operator|.
name|hasDeletedDocs
operator|=
operator|(
name|answer
operator|==
literal|null
operator|)
expr_stmt|;
comment|// if all clauses were uncached, the resulting filter may match deleted docs
block|}
else|else
block|{
if|if
condition|(
name|postFilters
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|answer
operator|==
literal|null
condition|)
block|{
name|answer
operator|=
name|getLiveDocs
argument_list|()
expr_stmt|;
block|}
comment|// "answer" is the only part of the filter, so set it.
name|pf
operator|.
name|answer
operator|=
name|answer
expr_stmt|;
block|}
if|if
condition|(
name|answer
operator|!=
literal|null
condition|)
block|{
name|pf
operator|.
name|filter
operator|=
name|answer
operator|.
name|getTopFilter
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|postFilters
operator|!=
literal|null
condition|)
block|{
name|Collections
operator|.
name|sort
argument_list|(
name|postFilters
argument_list|,
name|sortByCost
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
name|postFilters
operator|.
name|size
argument_list|()
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|DelegatingCollector
name|prev
init|=
name|pf
operator|.
name|postFilter
decl_stmt|;
name|pf
operator|.
name|postFilter
operator|=
operator|(
operator|(
name|PostFilter
operator|)
name|postFilters
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|)
operator|.
name|getFilterCollector
argument_list|(
name|this
argument_list|)
expr_stmt|;
if|if
condition|(
name|prev
operator|!=
literal|null
condition|)
name|pf
operator|.
name|postFilter
operator|.
name|setDelegate
argument_list|(
name|prev
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|pf
return|;
block|}
comment|/** @lucene.internal */
DECL|method|getDocSet
specifier|public
name|DocSet
name|getDocSet
parameter_list|(
name|DocsEnumState
name|deState
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|largestPossible
init|=
name|deState
operator|.
name|termsEnum
operator|.
name|docFreq
argument_list|()
decl_stmt|;
name|boolean
name|useCache
init|=
name|filterCache
operator|!=
literal|null
operator|&&
name|largestPossible
operator|>=
name|deState
operator|.
name|minSetSizeCached
decl_stmt|;
name|TermQuery
name|key
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|useCache
condition|)
block|{
name|key
operator|=
operator|new
name|TermQuery
argument_list|(
operator|new
name|Term
argument_list|(
name|deState
operator|.
name|fieldName
argument_list|,
name|deState
operator|.
name|termsEnum
operator|.
name|term
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|DocSet
name|result
init|=
name|filterCache
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|!=
literal|null
condition|)
return|return
name|result
return|;
block|}
name|int
name|smallSetSize
init|=
name|DocSetUtil
operator|.
name|smallSetSize
argument_list|(
name|maxDoc
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|scratchSize
init|=
name|Math
operator|.
name|min
argument_list|(
name|smallSetSize
argument_list|,
name|largestPossible
argument_list|)
decl_stmt|;
if|if
condition|(
name|deState
operator|.
name|scratch
operator|==
literal|null
operator|||
name|deState
operator|.
name|scratch
operator|.
name|length
operator|<
name|scratchSize
condition|)
name|deState
operator|.
name|scratch
operator|=
operator|new
name|int
index|[
name|scratchSize
index|]
expr_stmt|;
specifier|final
name|int
index|[]
name|docs
init|=
name|deState
operator|.
name|scratch
decl_stmt|;
name|int
name|upto
init|=
literal|0
decl_stmt|;
name|int
name|bitsSet
init|=
literal|0
decl_stmt|;
name|FixedBitSet
name|fbs
init|=
literal|null
decl_stmt|;
name|PostingsEnum
name|postingsEnum
init|=
name|deState
operator|.
name|termsEnum
operator|.
name|postings
argument_list|(
name|deState
operator|.
name|postingsEnum
argument_list|,
name|PostingsEnum
operator|.
name|NONE
argument_list|)
decl_stmt|;
name|postingsEnum
operator|=
name|BitsFilteredPostingsEnum
operator|.
name|wrap
argument_list|(
name|postingsEnum
argument_list|,
name|deState
operator|.
name|liveDocs
argument_list|)
expr_stmt|;
if|if
condition|(
name|deState
operator|.
name|postingsEnum
operator|==
literal|null
condition|)
block|{
name|deState
operator|.
name|postingsEnum
operator|=
name|postingsEnum
expr_stmt|;
block|}
if|if
condition|(
name|postingsEnum
operator|instanceof
name|MultiPostingsEnum
condition|)
block|{
name|MultiPostingsEnum
operator|.
name|EnumWithSlice
index|[]
name|subs
init|=
operator|(
operator|(
name|MultiPostingsEnum
operator|)
name|postingsEnum
operator|)
operator|.
name|getSubs
argument_list|()
decl_stmt|;
name|int
name|numSubs
init|=
operator|(
operator|(
name|MultiPostingsEnum
operator|)
name|postingsEnum
operator|)
operator|.
name|getNumSubs
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|subindex
init|=
literal|0
init|;
name|subindex
operator|<
name|numSubs
condition|;
name|subindex
operator|++
control|)
block|{
name|MultiPostingsEnum
operator|.
name|EnumWithSlice
name|sub
init|=
name|subs
index|[
name|subindex
index|]
decl_stmt|;
if|if
condition|(
name|sub
operator|.
name|postingsEnum
operator|==
literal|null
condition|)
continue|continue;
name|int
name|base
init|=
name|sub
operator|.
name|slice
operator|.
name|start
decl_stmt|;
name|int
name|docid
decl_stmt|;
if|if
condition|(
name|largestPossible
operator|>
name|docs
operator|.
name|length
condition|)
block|{
if|if
condition|(
name|fbs
operator|==
literal|null
condition|)
name|fbs
operator|=
operator|new
name|FixedBitSet
argument_list|(
name|maxDoc
argument_list|()
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|docid
operator|=
name|sub
operator|.
name|postingsEnum
operator|.
name|nextDoc
argument_list|()
operator|)
operator|!=
name|DocIdSetIterator
operator|.
name|NO_MORE_DOCS
condition|)
block|{
name|fbs
operator|.
name|set
argument_list|(
name|docid
operator|+
name|base
argument_list|)
expr_stmt|;
name|bitsSet
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
while|while
condition|(
operator|(
name|docid
operator|=
name|sub
operator|.
name|postingsEnum
operator|.
name|nextDoc
argument_list|()
operator|)
operator|!=
name|DocIdSetIterator
operator|.
name|NO_MORE_DOCS
condition|)
block|{
name|docs
index|[
name|upto
operator|++
index|]
operator|=
name|docid
operator|+
name|base
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
block|{
name|int
name|docid
decl_stmt|;
if|if
condition|(
name|largestPossible
operator|>
name|docs
operator|.
name|length
condition|)
block|{
name|fbs
operator|=
operator|new
name|FixedBitSet
argument_list|(
name|maxDoc
argument_list|()
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|docid
operator|=
name|postingsEnum
operator|.
name|nextDoc
argument_list|()
operator|)
operator|!=
name|DocIdSetIterator
operator|.
name|NO_MORE_DOCS
condition|)
block|{
name|fbs
operator|.
name|set
argument_list|(
name|docid
argument_list|)
expr_stmt|;
name|bitsSet
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
while|while
condition|(
operator|(
name|docid
operator|=
name|postingsEnum
operator|.
name|nextDoc
argument_list|()
operator|)
operator|!=
name|DocIdSetIterator
operator|.
name|NO_MORE_DOCS
condition|)
block|{
name|docs
index|[
name|upto
operator|++
index|]
operator|=
name|docid
expr_stmt|;
block|}
block|}
block|}
name|DocSet
name|result
decl_stmt|;
if|if
condition|(
name|fbs
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|upto
condition|;
name|i
operator|++
control|)
block|{
name|fbs
operator|.
name|set
argument_list|(
name|docs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|bitsSet
operator|+=
name|upto
expr_stmt|;
name|result
operator|=
operator|new
name|BitDocSet
argument_list|(
name|fbs
argument_list|,
name|bitsSet
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|result
operator|=
name|upto
operator|==
literal|0
condition|?
name|DocSet
operator|.
name|EMPTY
else|:
operator|new
name|SortedIntDocSet
argument_list|(
name|Arrays
operator|.
name|copyOf
argument_list|(
name|docs
argument_list|,
name|upto
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|useCache
condition|)
block|{
name|filterCache
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
comment|// query must be positive
DECL|method|getDocSetNC
specifier|protected
name|DocSet
name|getDocSetNC
parameter_list|(
name|Query
name|query
parameter_list|,
name|DocSet
name|filter
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|DocSetUtil
operator|.
name|createDocSet
argument_list|(
name|this
argument_list|,
name|query
argument_list|,
name|filter
argument_list|)
return|;
block|}
comment|/**    * Returns the set of document ids matching both the query and the filter. This method is cache-aware and attempts to    * retrieve the answer from the cache if possible. If the answer was not cached, it may have been inserted into the    * cache as a result of this call.    *<p>    *    * @param filter    *          may be null    * @return DocSet meeting the specified criteria, should<b>not</b> be modified by the caller.    */
DECL|method|getDocSet
specifier|public
name|DocSet
name|getDocSet
parameter_list|(
name|Query
name|query
parameter_list|,
name|DocSet
name|filter
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|filter
operator|==
literal|null
condition|)
return|return
name|getDocSet
argument_list|(
name|query
argument_list|)
return|;
if|if
condition|(
name|query
operator|instanceof
name|ExtendedQuery
condition|)
block|{
name|ExtendedQuery
name|eq
init|=
operator|(
name|ExtendedQuery
operator|)
name|query
decl_stmt|;
if|if
condition|(
operator|!
name|eq
operator|.
name|getCache
argument_list|()
condition|)
block|{
if|if
condition|(
name|query
operator|instanceof
name|WrappedQuery
condition|)
block|{
name|query
operator|=
operator|(
operator|(
name|WrappedQuery
operator|)
name|query
operator|)
operator|.
name|getWrappedQuery
argument_list|()
expr_stmt|;
block|}
name|query
operator|=
name|QueryUtils
operator|.
name|makeQueryable
argument_list|(
name|query
argument_list|)
expr_stmt|;
return|return
name|getDocSetNC
argument_list|(
name|query
argument_list|,
name|filter
argument_list|)
return|;
block|}
block|}
comment|// Negative query if absolute value different from original
name|Query
name|absQ
init|=
name|QueryUtils
operator|.
name|getAbs
argument_list|(
name|query
argument_list|)
decl_stmt|;
name|boolean
name|positive
init|=
name|absQ
operator|==
name|query
decl_stmt|;
name|DocSet
name|first
decl_stmt|;
if|if
condition|(
name|filterCache
operator|!=
literal|null
condition|)
block|{
name|first
operator|=
name|filterCache
operator|.
name|get
argument_list|(
name|absQ
argument_list|)
expr_stmt|;
if|if
condition|(
name|first
operator|==
literal|null
condition|)
block|{
name|first
operator|=
name|getDocSetNC
argument_list|(
name|absQ
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|filterCache
operator|.
name|put
argument_list|(
name|absQ
argument_list|,
name|first
argument_list|)
expr_stmt|;
block|}
return|return
name|positive
condition|?
name|first
operator|.
name|intersection
argument_list|(
name|filter
argument_list|)
else|:
name|filter
operator|.
name|andNot
argument_list|(
name|first
argument_list|)
return|;
block|}
comment|// If there isn't a cache, then do a single filtered query if positive.
return|return
name|positive
condition|?
name|getDocSetNC
argument_list|(
name|absQ
argument_list|,
name|filter
argument_list|)
else|:
name|filter
operator|.
name|andNot
argument_list|(
name|getPositiveDocSet
argument_list|(
name|absQ
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Returns documents matching both<code>query</code> and<code>filter</code> and sorted by<code>sort</code>.    *<p>    * This method is cache aware and may retrieve<code>filter</code> from the cache or make an insertion into the cache    * as a result of this call.    *<p>    * FUTURE: The returned DocList may be retrieved from a cache.    *    * @param filter    *          may be null    * @param lsort    *          criteria by which to sort (if null, query relevance is used)    * @param offset    *          offset into the list of documents to return    * @param len    *          maximum number of documents to return    * @return DocList meeting the specified criteria, should<b>not</b> be modified by the caller.    * @throws IOException    *           If there is a low-level I/O error.    */
DECL|method|getDocList
specifier|public
name|DocList
name|getDocList
parameter_list|(
name|Query
name|query
parameter_list|,
name|Query
name|filter
parameter_list|,
name|Sort
name|lsort
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|len
parameter_list|)
throws|throws
name|IOException
block|{
name|QueryCommand
name|qc
init|=
operator|new
name|QueryCommand
argument_list|()
decl_stmt|;
name|qc
operator|.
name|setQuery
argument_list|(
name|query
argument_list|)
operator|.
name|setFilterList
argument_list|(
name|filter
argument_list|)
operator|.
name|setSort
argument_list|(
name|lsort
argument_list|)
operator|.
name|setOffset
argument_list|(
name|offset
argument_list|)
operator|.
name|setLen
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|QueryResult
name|qr
init|=
operator|new
name|QueryResult
argument_list|()
decl_stmt|;
name|search
argument_list|(
name|qr
argument_list|,
name|qc
argument_list|)
expr_stmt|;
return|return
name|qr
operator|.
name|getDocList
argument_list|()
return|;
block|}
comment|/**    * Returns documents matching both<code>query</code> and the intersection of the<code>filterList</code>, sorted by    *<code>sort</code>.    *<p>    * This method is cache aware and may retrieve<code>filter</code> from the cache or make an insertion into the cache    * as a result of this call.    *<p>    * FUTURE: The returned DocList may be retrieved from a cache.    *    * @param filterList    *          may be null    * @param lsort    *          criteria by which to sort (if null, query relevance is used)    * @param offset    *          offset into the list of documents to return    * @param len    *          maximum number of documents to return    * @return DocList meeting the specified criteria, should<b>not</b> be modified by the caller.    * @throws IOException    *           If there is a low-level I/O error.    */
DECL|method|getDocList
specifier|public
name|DocList
name|getDocList
parameter_list|(
name|Query
name|query
parameter_list|,
name|List
argument_list|<
name|Query
argument_list|>
name|filterList
parameter_list|,
name|Sort
name|lsort
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|flags
parameter_list|)
throws|throws
name|IOException
block|{
name|QueryCommand
name|qc
init|=
operator|new
name|QueryCommand
argument_list|()
decl_stmt|;
name|qc
operator|.
name|setQuery
argument_list|(
name|query
argument_list|)
operator|.
name|setFilterList
argument_list|(
name|filterList
argument_list|)
operator|.
name|setSort
argument_list|(
name|lsort
argument_list|)
operator|.
name|setOffset
argument_list|(
name|offset
argument_list|)
operator|.
name|setLen
argument_list|(
name|len
argument_list|)
operator|.
name|setFlags
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|QueryResult
name|qr
init|=
operator|new
name|QueryResult
argument_list|()
decl_stmt|;
name|search
argument_list|(
name|qr
argument_list|,
name|qc
argument_list|)
expr_stmt|;
return|return
name|qr
operator|.
name|getDocList
argument_list|()
return|;
block|}
DECL|field|NO_CHECK_QCACHE
specifier|public
specifier|static
specifier|final
name|int
name|NO_CHECK_QCACHE
init|=
literal|0x80000000
decl_stmt|;
DECL|field|GET_DOCSET
specifier|public
specifier|static
specifier|final
name|int
name|GET_DOCSET
init|=
literal|0x40000000
decl_stmt|;
DECL|field|NO_CHECK_FILTERCACHE
specifier|static
specifier|final
name|int
name|NO_CHECK_FILTERCACHE
init|=
literal|0x20000000
decl_stmt|;
DECL|field|NO_SET_QCACHE
specifier|static
specifier|final
name|int
name|NO_SET_QCACHE
init|=
literal|0x10000000
decl_stmt|;
DECL|field|SEGMENT_TERMINATE_EARLY
specifier|static
specifier|final
name|int
name|SEGMENT_TERMINATE_EARLY
init|=
literal|0x08
decl_stmt|;
DECL|field|TERMINATE_EARLY
specifier|public
specifier|static
specifier|final
name|int
name|TERMINATE_EARLY
init|=
literal|0x04
decl_stmt|;
DECL|field|GET_DOCLIST
specifier|public
specifier|static
specifier|final
name|int
name|GET_DOCLIST
init|=
literal|0x02
decl_stmt|;
comment|// get the documents actually returned in a response
DECL|field|GET_SCORES
specifier|public
specifier|static
specifier|final
name|int
name|GET_SCORES
init|=
literal|0x01
decl_stmt|;
comment|/**    * getDocList version that uses+populates query and filter caches. In the event of a timeout, the cache is not    * populated.    */
DECL|method|getDocListC
specifier|private
name|void
name|getDocListC
parameter_list|(
name|QueryResult
name|qr
parameter_list|,
name|QueryCommand
name|cmd
parameter_list|)
throws|throws
name|IOException
block|{
name|DocListAndSet
name|out
init|=
operator|new
name|DocListAndSet
argument_list|()
decl_stmt|;
name|qr
operator|.
name|setDocListAndSet
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|QueryResultKey
name|key
init|=
literal|null
decl_stmt|;
name|int
name|maxDocRequested
init|=
name|cmd
operator|.
name|getOffset
argument_list|()
operator|+
name|cmd
operator|.
name|getLen
argument_list|()
decl_stmt|;
comment|// check for overflow, and check for # docs in index
if|if
condition|(
name|maxDocRequested
argument_list|<
literal|0
operator|||
name|maxDocRequested
argument_list|>
name|maxDoc
argument_list|()
condition|)
name|maxDocRequested
operator|=
name|maxDoc
argument_list|()
expr_stmt|;
name|int
name|supersetMaxDoc
init|=
name|maxDocRequested
decl_stmt|;
name|DocList
name|superset
init|=
literal|null
decl_stmt|;
name|int
name|flags
init|=
name|cmd
operator|.
name|getFlags
argument_list|()
decl_stmt|;
name|Query
name|q
init|=
name|cmd
operator|.
name|getQuery
argument_list|()
decl_stmt|;
if|if
condition|(
name|q
operator|instanceof
name|ExtendedQuery
condition|)
block|{
name|ExtendedQuery
name|eq
init|=
operator|(
name|ExtendedQuery
operator|)
name|q
decl_stmt|;
if|if
condition|(
operator|!
name|eq
operator|.
name|getCache
argument_list|()
condition|)
block|{
name|flags
operator||=
operator|(
name|NO_CHECK_QCACHE
operator||
name|NO_SET_QCACHE
operator||
name|NO_CHECK_FILTERCACHE
operator|)
expr_stmt|;
block|}
block|}
comment|// we can try and look up the complete query in the cache.
comment|// we can't do that if filter!=null though (we don't want to
comment|// do hashCode() and equals() for a big DocSet).
if|if
condition|(
name|queryResultCache
operator|!=
literal|null
operator|&&
name|cmd
operator|.
name|getFilter
argument_list|()
operator|==
literal|null
operator|&&
operator|(
name|flags
operator|&
operator|(
name|NO_CHECK_QCACHE
operator||
name|NO_SET_QCACHE
operator|)
operator|)
operator|!=
operator|(
operator|(
name|NO_CHECK_QCACHE
operator||
name|NO_SET_QCACHE
operator|)
operator|)
condition|)
block|{
comment|// all of the current flags can be reused during warming,
comment|// so set all of them on the cache key.
name|key
operator|=
operator|new
name|QueryResultKey
argument_list|(
name|q
argument_list|,
name|cmd
operator|.
name|getFilterList
argument_list|()
argument_list|,
name|cmd
operator|.
name|getSort
argument_list|()
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|NO_CHECK_QCACHE
operator|)
operator|==
literal|0
condition|)
block|{
name|superset
operator|=
name|queryResultCache
operator|.
name|get
argument_list|(
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|superset
operator|!=
literal|null
condition|)
block|{
comment|// check that the cache entry has scores recorded if we need them
if|if
condition|(
operator|(
name|flags
operator|&
name|GET_SCORES
operator|)
operator|==
literal|0
operator|||
name|superset
operator|.
name|hasScores
argument_list|()
condition|)
block|{
comment|// NOTE: subset() returns null if the DocList has fewer docs than
comment|// requested
name|out
operator|.
name|docList
operator|=
name|superset
operator|.
name|subset
argument_list|(
name|cmd
operator|.
name|getOffset
argument_list|()
argument_list|,
name|cmd
operator|.
name|getLen
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|out
operator|.
name|docList
operator|!=
literal|null
condition|)
block|{
comment|// found the docList in the cache... now check if we need the docset too.
comment|// OPT: possible future optimization - if the doclist contains all the matches,
comment|// use it to make the docset instead of rerunning the query.
if|if
condition|(
name|out
operator|.
name|docSet
operator|==
literal|null
operator|&&
operator|(
operator|(
name|flags
operator|&
name|GET_DOCSET
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|cmd
operator|.
name|getFilterList
argument_list|()
operator|==
literal|null
condition|)
block|{
name|out
operator|.
name|docSet
operator|=
name|getDocSet
argument_list|(
name|cmd
operator|.
name|getQuery
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|List
argument_list|<
name|Query
argument_list|>
name|newList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|cmd
operator|.
name|getFilterList
argument_list|()
operator|.
name|size
argument_list|()
operator|+
literal|1
argument_list|)
decl_stmt|;
name|newList
operator|.
name|add
argument_list|(
name|cmd
operator|.
name|getQuery
argument_list|()
argument_list|)
expr_stmt|;
name|newList
operator|.
name|addAll
argument_list|(
name|cmd
operator|.
name|getFilterList
argument_list|()
argument_list|)
expr_stmt|;
name|out
operator|.
name|docSet
operator|=
name|getDocSet
argument_list|(
name|newList
argument_list|)
expr_stmt|;
block|}
block|}
return|return;
block|}
block|}
comment|// If we are going to generate the result, bump up to the
comment|// next resultWindowSize for better caching.
if|if
condition|(
operator|(
name|flags
operator|&
name|NO_SET_QCACHE
operator|)
operator|==
literal|0
condition|)
block|{
comment|// handle 0 special case as well as avoid idiv in the common case.
if|if
condition|(
name|maxDocRequested
operator|<
name|queryResultWindowSize
condition|)
block|{
name|supersetMaxDoc
operator|=
name|queryResultWindowSize
expr_stmt|;
block|}
else|else
block|{
name|supersetMaxDoc
operator|=
operator|(
operator|(
name|maxDocRequested
operator|-
literal|1
operator|)
operator|/
name|queryResultWindowSize
operator|+
literal|1
operator|)
operator|*
name|queryResultWindowSize
expr_stmt|;
if|if
condition|(
name|supersetMaxDoc
operator|<
literal|0
condition|)
name|supersetMaxDoc
operator|=
name|maxDocRequested
expr_stmt|;
block|}
block|}
else|else
block|{
name|key
operator|=
literal|null
expr_stmt|;
comment|// we won't be caching the result
block|}
block|}
name|cmd
operator|.
name|setSupersetMaxDoc
argument_list|(
name|supersetMaxDoc
argument_list|)
expr_stmt|;
comment|// OK, so now we need to generate an answer.
comment|// One way to do that would be to check if we have an unordered list
comment|// of results for the base query. If so, we can apply the filters and then
comment|// sort by the resulting set. This can only be used if:
comment|// - the sort doesn't contain score
comment|// - we don't want score returned.
comment|// check if we should try and use the filter cache
name|boolean
name|useFilterCache
init|=
literal|false
decl_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
operator|(
name|GET_SCORES
operator||
name|NO_CHECK_FILTERCACHE
operator|)
operator|)
operator|==
literal|0
operator|&&
name|useFilterForSortedQuery
operator|&&
name|cmd
operator|.
name|getSort
argument_list|()
operator|!=
literal|null
operator|&&
name|filterCache
operator|!=
literal|null
condition|)
block|{
name|useFilterCache
operator|=
literal|true
expr_stmt|;
name|SortField
index|[]
name|sfields
init|=
name|cmd
operator|.
name|getSort
argument_list|()
operator|.
name|getSort
argument_list|()
decl_stmt|;
for|for
control|(
name|SortField
name|sf
range|:
name|sfields
control|)
block|{
if|if
condition|(
name|sf
operator|.
name|getType
argument_list|()
operator|==
name|SortField
operator|.
name|Type
operator|.
name|SCORE
condition|)
block|{
name|useFilterCache
operator|=
literal|false
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|useFilterCache
condition|)
block|{
comment|// now actually use the filter cache.
comment|// for large filters that match few documents, this may be
comment|// slower than simply re-executing the query.
if|if
condition|(
name|out
operator|.
name|docSet
operator|==
literal|null
condition|)
block|{
name|out
operator|.
name|docSet
operator|=
name|getDocSet
argument_list|(
name|cmd
operator|.
name|getQuery
argument_list|()
argument_list|,
name|cmd
operator|.
name|getFilter
argument_list|()
argument_list|)
expr_stmt|;
name|DocSet
name|bigFilt
init|=
name|getDocSet
argument_list|(
name|cmd
operator|.
name|getFilterList
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|bigFilt
operator|!=
literal|null
condition|)
name|out
operator|.
name|docSet
operator|=
name|out
operator|.
name|docSet
operator|.
name|intersection
argument_list|(
name|bigFilt
argument_list|)
expr_stmt|;
block|}
comment|// todo: there could be a sortDocSet that could take a list of
comment|// the filters instead of anding them first...
comment|// perhaps there should be a multi-docset-iterator
name|sortDocSet
argument_list|(
name|qr
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// do it the normal way...
if|if
condition|(
operator|(
name|flags
operator|&
name|GET_DOCSET
operator|)
operator|!=
literal|0
condition|)
block|{
comment|// this currently conflates returning the docset for the base query vs
comment|// the base query and all filters.
name|DocSet
name|qDocSet
init|=
name|getDocListAndSetNC
argument_list|(
name|qr
argument_list|,
name|cmd
argument_list|)
decl_stmt|;
comment|// cache the docSet matching the query w/o filtering
if|if
condition|(
name|qDocSet
operator|!=
literal|null
operator|&&
name|filterCache
operator|!=
literal|null
operator|&&
operator|!
name|qr
operator|.
name|isPartialResults
argument_list|()
condition|)
name|filterCache
operator|.
name|put
argument_list|(
name|cmd
operator|.
name|getQuery
argument_list|()
argument_list|,
name|qDocSet
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|getDocListNC
argument_list|(
name|qr
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
block|}
assert|assert
literal|null
operator|!=
name|out
operator|.
name|docList
operator|:
literal|"docList is null"
assert|;
block|}
if|if
condition|(
literal|null
operator|==
name|cmd
operator|.
name|getCursorMark
argument_list|()
condition|)
block|{
comment|// Kludge...
comment|// we can't use DocSlice.subset, even though it should be an identity op
comment|// because it gets confused by situations where there are lots of matches, but
comment|// less docs in the slice then were requested, (due to the cursor)
comment|// so we have to short circuit the call.
comment|// None of which is really a problem since we can't use caching with
comment|// cursors anyway, but it still looks weird to have to special case this
comment|// behavior based on this condition - hence the long explanation.
name|superset
operator|=
name|out
operator|.
name|docList
expr_stmt|;
name|out
operator|.
name|docList
operator|=
name|superset
operator|.
name|subset
argument_list|(
name|cmd
operator|.
name|getOffset
argument_list|()
argument_list|,
name|cmd
operator|.
name|getLen
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// sanity check our cursor assumptions
assert|assert
literal|null
operator|==
name|superset
operator|:
literal|"cursor: superset isn't null"
assert|;
assert|assert
literal|0
operator|==
name|cmd
operator|.
name|getOffset
argument_list|()
operator|:
literal|"cursor: command offset mismatch"
assert|;
assert|assert
literal|0
operator|==
name|out
operator|.
name|docList
operator|.
name|offset
argument_list|()
operator|:
literal|"cursor: docList offset mismatch"
assert|;
assert|assert
name|cmd
operator|.
name|getLen
argument_list|()
operator|>=
name|supersetMaxDoc
operator|:
literal|"cursor: superset len mismatch: "
operator|+
name|cmd
operator|.
name|getLen
argument_list|()
operator|+
literal|" vs "
operator|+
name|supersetMaxDoc
assert|;
block|}
comment|// lastly, put the superset in the cache if the size is less than or equal
comment|// to queryResultMaxDocsCached
if|if
condition|(
name|key
operator|!=
literal|null
operator|&&
name|superset
operator|.
name|size
argument_list|()
operator|<=
name|queryResultMaxDocsCached
operator|&&
operator|!
name|qr
operator|.
name|isPartialResults
argument_list|()
condition|)
block|{
name|queryResultCache
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|superset
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Helper method for extracting the {@link FieldDoc} sort values from a {@link TopFieldDocs} when available and making    * the appropriate call to {@link QueryResult#setNextCursorMark} when applicable.    *    * @param qr    *<code>QueryResult</code> to modify    * @param qc    *<code>QueryCommand</code> for context of method    * @param topDocs    *          May or may not be a<code>TopFieldDocs</code>    */
DECL|method|populateNextCursorMarkFromTopDocs
specifier|private
name|void
name|populateNextCursorMarkFromTopDocs
parameter_list|(
name|QueryResult
name|qr
parameter_list|,
name|QueryCommand
name|qc
parameter_list|,
name|TopDocs
name|topDocs
parameter_list|)
block|{
comment|// TODO: would be nice to rename& generalize this method for non-cursor cases...
comment|// ...would be handy to reuse the ScoreDoc/FieldDoc sort vals directly in distrib sort
comment|// ...but that has non-trivial queryResultCache implications
comment|// See: SOLR-5595
if|if
condition|(
literal|null
operator|==
name|qc
operator|.
name|getCursorMark
argument_list|()
condition|)
block|{
comment|// nothing to do, short circuit out
return|return;
block|}
specifier|final
name|CursorMark
name|lastCursorMark
init|=
name|qc
operator|.
name|getCursorMark
argument_list|()
decl_stmt|;
comment|// if we have a cursor, then we have a sort that at minimum involves uniqueKey..
comment|// so we must have a TopFieldDocs containing FieldDoc[]
assert|assert
name|topDocs
operator|instanceof
name|TopFieldDocs
operator|:
literal|"TopFieldDocs cursor constraint violated"
assert|;
specifier|final
name|TopFieldDocs
name|topFieldDocs
init|=
operator|(
name|TopFieldDocs
operator|)
name|topDocs
decl_stmt|;
specifier|final
name|ScoreDoc
index|[]
name|scoreDocs
init|=
name|topFieldDocs
operator|.
name|scoreDocs
decl_stmt|;
if|if
condition|(
literal|0
operator|==
name|scoreDocs
operator|.
name|length
condition|)
block|{
comment|// no docs on this page, re-use existing cursor mark
name|qr
operator|.
name|setNextCursorMark
argument_list|(
name|lastCursorMark
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ScoreDoc
name|lastDoc
init|=
name|scoreDocs
index|[
name|scoreDocs
operator|.
name|length
operator|-
literal|1
index|]
decl_stmt|;
assert|assert
name|lastDoc
operator|instanceof
name|FieldDoc
operator|:
literal|"FieldDoc cursor constraint violated"
assert|;
name|List
argument_list|<
name|Object
argument_list|>
name|lastFields
init|=
name|Arrays
operator|.
expr|<
name|Object
operator|>
name|asList
argument_list|(
operator|(
operator|(
name|FieldDoc
operator|)
name|lastDoc
operator|)
operator|.
name|fields
argument_list|)
decl_stmt|;
name|CursorMark
name|nextCursorMark
init|=
name|lastCursorMark
operator|.
name|createNext
argument_list|(
name|lastFields
argument_list|)
decl_stmt|;
assert|assert
literal|null
operator|!=
name|nextCursorMark
operator|:
literal|"null nextCursorMark"
assert|;
name|qr
operator|.
name|setNextCursorMark
argument_list|(
name|nextCursorMark
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Helper method for inspecting QueryCommand and creating the appropriate {@link TopDocsCollector}    *    * @param len    *          the number of docs to return    * @param cmd    *          The Command whose properties should determine the type of TopDocsCollector to use.    */
DECL|method|buildTopDocsCollector
specifier|private
name|TopDocsCollector
name|buildTopDocsCollector
parameter_list|(
name|int
name|len
parameter_list|,
name|QueryCommand
name|cmd
parameter_list|)
throws|throws
name|IOException
block|{
name|Query
name|q
init|=
name|cmd
operator|.
name|getQuery
argument_list|()
decl_stmt|;
if|if
condition|(
name|q
operator|instanceof
name|RankQuery
condition|)
block|{
name|RankQuery
name|rq
init|=
operator|(
name|RankQuery
operator|)
name|q
decl_stmt|;
return|return
name|rq
operator|.
name|getTopDocsCollector
argument_list|(
name|len
argument_list|,
name|cmd
argument_list|,
name|this
argument_list|)
return|;
block|}
if|if
condition|(
literal|null
operator|==
name|cmd
operator|.
name|getSort
argument_list|()
condition|)
block|{
assert|assert
literal|null
operator|==
name|cmd
operator|.
name|getCursorMark
argument_list|()
operator|:
literal|"have cursor but no sort"
assert|;
return|return
name|TopScoreDocCollector
operator|.
name|create
argument_list|(
name|len
argument_list|)
return|;
block|}
else|else
block|{
comment|// we have a sort
specifier|final
name|boolean
name|needScores
init|=
operator|(
name|cmd
operator|.
name|getFlags
argument_list|()
operator|&
name|GET_SCORES
operator|)
operator|!=
literal|0
decl_stmt|;
specifier|final
name|Sort
name|weightedSort
init|=
name|weightSort
argument_list|(
name|cmd
operator|.
name|getSort
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|CursorMark
name|cursor
init|=
name|cmd
operator|.
name|getCursorMark
argument_list|()
decl_stmt|;
comment|// :TODO: make fillFields its own QueryCommand flag? ...
comment|// ... see comments in populateNextCursorMarkFromTopDocs for cache issues (SOLR-5595)
specifier|final
name|boolean
name|fillFields
init|=
operator|(
literal|null
operator|!=
name|cursor
operator|)
decl_stmt|;
specifier|final
name|FieldDoc
name|searchAfter
init|=
operator|(
literal|null
operator|!=
name|cursor
condition|?
name|cursor
operator|.
name|getSearchAfterFieldDoc
argument_list|()
else|:
literal|null
operator|)
decl_stmt|;
return|return
name|TopFieldCollector
operator|.
name|create
argument_list|(
name|weightedSort
argument_list|,
name|len
argument_list|,
name|searchAfter
argument_list|,
name|fillFields
argument_list|,
name|needScores
argument_list|,
name|needScores
argument_list|)
return|;
block|}
block|}
DECL|method|getDocListNC
specifier|private
name|void
name|getDocListNC
parameter_list|(
name|QueryResult
name|qr
parameter_list|,
name|QueryCommand
name|cmd
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|len
init|=
name|cmd
operator|.
name|getSupersetMaxDoc
argument_list|()
decl_stmt|;
name|int
name|last
init|=
name|len
decl_stmt|;
if|if
condition|(
name|last
argument_list|<
literal|0
operator|||
name|last
argument_list|>
name|maxDoc
argument_list|()
condition|)
name|last
operator|=
name|maxDoc
argument_list|()
expr_stmt|;
specifier|final
name|int
name|lastDocRequested
init|=
name|last
decl_stmt|;
name|int
name|nDocsReturned
decl_stmt|;
name|int
name|totalHits
decl_stmt|;
name|float
name|maxScore
decl_stmt|;
name|int
index|[]
name|ids
decl_stmt|;
name|float
index|[]
name|scores
decl_stmt|;
name|boolean
name|needScores
init|=
operator|(
name|cmd
operator|.
name|getFlags
argument_list|()
operator|&
name|GET_SCORES
operator|)
operator|!=
literal|0
decl_stmt|;
name|Query
name|query
init|=
name|QueryUtils
operator|.
name|makeQueryable
argument_list|(
name|cmd
operator|.
name|getQuery
argument_list|()
argument_list|)
decl_stmt|;
name|ProcessedFilter
name|pf
init|=
name|getProcessedFilter
argument_list|(
name|cmd
operator|.
name|getFilter
argument_list|()
argument_list|,
name|cmd
operator|.
name|getFilterList
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|pf
operator|.
name|filter
operator|!=
literal|null
condition|)
block|{
name|query
operator|=
operator|new
name|BooleanQuery
operator|.
name|Builder
argument_list|()
operator|.
name|add
argument_list|(
name|query
argument_list|,
name|Occur
operator|.
name|MUST
argument_list|)
operator|.
name|add
argument_list|(
name|pf
operator|.
name|filter
argument_list|,
name|Occur
operator|.
name|FILTER
argument_list|)
operator|.
name|build
argument_list|()
expr_stmt|;
block|}
comment|// handle zero case...
if|if
condition|(
name|lastDocRequested
operator|<=
literal|0
condition|)
block|{
specifier|final
name|float
index|[]
name|topscore
init|=
operator|new
name|float
index|[]
block|{
name|Float
operator|.
name|NEGATIVE_INFINITY
block|}
decl_stmt|;
specifier|final
name|int
index|[]
name|numHits
init|=
operator|new
name|int
index|[
literal|1
index|]
decl_stmt|;
name|Collector
name|collector
decl_stmt|;
if|if
condition|(
operator|!
name|needScores
condition|)
block|{
name|collector
operator|=
operator|new
name|SimpleCollector
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|collect
parameter_list|(
name|int
name|doc
parameter_list|)
block|{
name|numHits
index|[
literal|0
index|]
operator|++
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|needsScores
parameter_list|()
block|{
return|return
literal|false
return|;
block|}
block|}
expr_stmt|;
block|}
else|else
block|{
name|collector
operator|=
operator|new
name|SimpleCollector
argument_list|()
block|{
name|Scorer
name|scorer
decl_stmt|;
annotation|@
name|Override
specifier|public
name|void
name|setScorer
parameter_list|(
name|Scorer
name|scorer
parameter_list|)
block|{
name|this
operator|.
name|scorer
operator|=
name|scorer
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|collect
parameter_list|(
name|int
name|doc
parameter_list|)
throws|throws
name|IOException
block|{
name|numHits
index|[
literal|0
index|]
operator|++
expr_stmt|;
name|float
name|score
init|=
name|scorer
operator|.
name|score
argument_list|()
decl_stmt|;
if|if
condition|(
name|score
operator|>
name|topscore
index|[
literal|0
index|]
condition|)
name|topscore
index|[
literal|0
index|]
operator|=
name|score
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|needsScores
parameter_list|()
block|{
return|return
literal|true
return|;
block|}
block|}
expr_stmt|;
block|}
name|buildAndRunCollectorChain
argument_list|(
name|qr
argument_list|,
name|query
argument_list|,
name|collector
argument_list|,
name|cmd
argument_list|,
name|pf
operator|.
name|postFilter
argument_list|)
expr_stmt|;
name|nDocsReturned
operator|=
literal|0
expr_stmt|;
name|ids
operator|=
operator|new
name|int
index|[
name|nDocsReturned
index|]
expr_stmt|;
name|scores
operator|=
operator|new
name|float
index|[
name|nDocsReturned
index|]
expr_stmt|;
name|totalHits
operator|=
name|numHits
index|[
literal|0
index|]
expr_stmt|;
name|maxScore
operator|=
name|totalHits
operator|>
literal|0
condition|?
name|topscore
index|[
literal|0
index|]
else|:
literal|0.0f
expr_stmt|;
comment|// no docs on this page, so cursor doesn't change
name|qr
operator|.
name|setNextCursorMark
argument_list|(
name|cmd
operator|.
name|getCursorMark
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|final
name|TopDocsCollector
name|topCollector
init|=
name|buildTopDocsCollector
argument_list|(
name|len
argument_list|,
name|cmd
argument_list|)
decl_stmt|;
name|Collector
name|collector
init|=
name|topCollector
decl_stmt|;
name|buildAndRunCollectorChain
argument_list|(
name|qr
argument_list|,
name|query
argument_list|,
name|collector
argument_list|,
name|cmd
argument_list|,
name|pf
operator|.
name|postFilter
argument_list|)
expr_stmt|;
name|totalHits
operator|=
name|topCollector
operator|.
name|getTotalHits
argument_list|()
expr_stmt|;
name|TopDocs
name|topDocs
init|=
name|topCollector
operator|.
name|topDocs
argument_list|(
literal|0
argument_list|,
name|len
argument_list|)
decl_stmt|;
name|populateNextCursorMarkFromTopDocs
argument_list|(
name|qr
argument_list|,
name|cmd
argument_list|,
name|topDocs
argument_list|)
expr_stmt|;
name|maxScore
operator|=
name|totalHits
operator|>
literal|0
condition|?
name|topDocs
operator|.
name|getMaxScore
argument_list|()
else|:
literal|0.0f
expr_stmt|;
name|nDocsReturned
operator|=
name|topDocs
operator|.
name|scoreDocs
operator|.
name|length
expr_stmt|;
name|ids
operator|=
operator|new
name|int
index|[
name|nDocsReturned
index|]
expr_stmt|;
name|scores
operator|=
operator|(
name|cmd
operator|.
name|getFlags
argument_list|()
operator|&
name|GET_SCORES
operator|)
operator|!=
literal|0
condition|?
operator|new
name|float
index|[
name|nDocsReturned
index|]
else|:
literal|null
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nDocsReturned
condition|;
name|i
operator|++
control|)
block|{
name|ScoreDoc
name|scoreDoc
init|=
name|topDocs
operator|.
name|scoreDocs
index|[
name|i
index|]
decl_stmt|;
name|ids
index|[
name|i
index|]
operator|=
name|scoreDoc
operator|.
name|doc
expr_stmt|;
if|if
condition|(
name|scores
operator|!=
literal|null
condition|)
name|scores
index|[
name|i
index|]
operator|=
name|scoreDoc
operator|.
name|score
expr_stmt|;
block|}
block|}
name|int
name|sliceLen
init|=
name|Math
operator|.
name|min
argument_list|(
name|lastDocRequested
argument_list|,
name|nDocsReturned
argument_list|)
decl_stmt|;
if|if
condition|(
name|sliceLen
operator|<
literal|0
condition|)
name|sliceLen
operator|=
literal|0
expr_stmt|;
name|qr
operator|.
name|setDocList
argument_list|(
operator|new
name|DocSlice
argument_list|(
literal|0
argument_list|,
name|sliceLen
argument_list|,
name|ids
argument_list|,
name|scores
argument_list|,
name|totalHits
argument_list|,
name|maxScore
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// any DocSet returned is for the query only, without any filtering... that way it may
comment|// be cached if desired.
DECL|method|getDocListAndSetNC
specifier|private
name|DocSet
name|getDocListAndSetNC
parameter_list|(
name|QueryResult
name|qr
parameter_list|,
name|QueryCommand
name|cmd
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|len
init|=
name|cmd
operator|.
name|getSupersetMaxDoc
argument_list|()
decl_stmt|;
name|int
name|last
init|=
name|len
decl_stmt|;
if|if
condition|(
name|last
argument_list|<
literal|0
operator|||
name|last
argument_list|>
name|maxDoc
argument_list|()
condition|)
name|last
operator|=
name|maxDoc
argument_list|()
expr_stmt|;
specifier|final
name|int
name|lastDocRequested
init|=
name|last
decl_stmt|;
name|int
name|nDocsReturned
decl_stmt|;
name|int
name|totalHits
decl_stmt|;
name|float
name|maxScore
decl_stmt|;
name|int
index|[]
name|ids
decl_stmt|;
name|float
index|[]
name|scores
decl_stmt|;
name|DocSet
name|set
decl_stmt|;
name|boolean
name|needScores
init|=
operator|(
name|cmd
operator|.
name|getFlags
argument_list|()
operator|&
name|GET_SCORES
operator|)
operator|!=
literal|0
decl_stmt|;
name|int
name|maxDoc
init|=
name|maxDoc
argument_list|()
decl_stmt|;
name|ProcessedFilter
name|pf
init|=
name|getProcessedFilter
argument_list|(
name|cmd
operator|.
name|getFilter
argument_list|()
argument_list|,
name|cmd
operator|.
name|getFilterList
argument_list|()
argument_list|)
decl_stmt|;
name|Query
name|query
init|=
name|QueryUtils
operator|.
name|makeQueryable
argument_list|(
name|cmd
operator|.
name|getQuery
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|pf
operator|.
name|filter
operator|!=
literal|null
condition|)
block|{
name|query
operator|=
operator|new
name|BooleanQuery
operator|.
name|Builder
argument_list|()
operator|.
name|add
argument_list|(
name|query
argument_list|,
name|Occur
operator|.
name|MUST
argument_list|)
operator|.
name|add
argument_list|(
name|pf
operator|.
name|filter
argument_list|,
name|Occur
operator|.
name|FILTER
argument_list|)
operator|.
name|build
argument_list|()
expr_stmt|;
block|}
comment|// handle zero case...
if|if
condition|(
name|lastDocRequested
operator|<=
literal|0
condition|)
block|{
specifier|final
name|float
index|[]
name|topscore
init|=
operator|new
name|float
index|[]
block|{
name|Float
operator|.
name|NEGATIVE_INFINITY
block|}
decl_stmt|;
name|Collector
name|collector
decl_stmt|;
specifier|final
name|DocSetCollector
name|setCollector
init|=
operator|new
name|DocSetCollector
argument_list|(
name|maxDoc
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|needScores
condition|)
block|{
name|collector
operator|=
name|setCollector
expr_stmt|;
block|}
else|else
block|{
specifier|final
name|Collector
name|topScoreCollector
init|=
operator|new
name|SimpleCollector
argument_list|()
block|{
name|Scorer
name|scorer
decl_stmt|;
annotation|@
name|Override
specifier|public
name|void
name|setScorer
parameter_list|(
name|Scorer
name|scorer
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|scorer
operator|=
name|scorer
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|collect
parameter_list|(
name|int
name|doc
parameter_list|)
throws|throws
name|IOException
block|{
name|float
name|score
init|=
name|scorer
operator|.
name|score
argument_list|()
decl_stmt|;
if|if
condition|(
name|score
operator|>
name|topscore
index|[
literal|0
index|]
condition|)
name|topscore
index|[
literal|0
index|]
operator|=
name|score
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|needsScores
parameter_list|()
block|{
return|return
literal|true
return|;
block|}
block|}
decl_stmt|;
name|collector
operator|=
name|MultiCollector
operator|.
name|wrap
argument_list|(
name|setCollector
argument_list|,
name|topScoreCollector
argument_list|)
expr_stmt|;
block|}
name|buildAndRunCollectorChain
argument_list|(
name|qr
argument_list|,
name|query
argument_list|,
name|collector
argument_list|,
name|cmd
argument_list|,
name|pf
operator|.
name|postFilter
argument_list|)
expr_stmt|;
name|set
operator|=
name|setCollector
operator|.
name|getDocSet
argument_list|()
expr_stmt|;
name|nDocsReturned
operator|=
literal|0
expr_stmt|;
name|ids
operator|=
operator|new
name|int
index|[
name|nDocsReturned
index|]
expr_stmt|;
name|scores
operator|=
operator|new
name|float
index|[
name|nDocsReturned
index|]
expr_stmt|;
name|totalHits
operator|=
name|set
operator|.
name|size
argument_list|()
expr_stmt|;
name|maxScore
operator|=
name|totalHits
operator|>
literal|0
condition|?
name|topscore
index|[
literal|0
index|]
else|:
literal|0.0f
expr_stmt|;
comment|// no docs on this page, so cursor doesn't change
name|qr
operator|.
name|setNextCursorMark
argument_list|(
name|cmd
operator|.
name|getCursorMark
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|final
name|TopDocsCollector
name|topCollector
init|=
name|buildTopDocsCollector
argument_list|(
name|len
argument_list|,
name|cmd
argument_list|)
decl_stmt|;
name|DocSetCollector
name|setCollector
init|=
operator|new
name|DocSetCollector
argument_list|(
name|maxDoc
argument_list|)
decl_stmt|;
name|Collector
name|collector
init|=
name|MultiCollector
operator|.
name|wrap
argument_list|(
name|topCollector
argument_list|,
name|setCollector
argument_list|)
decl_stmt|;
name|buildAndRunCollectorChain
argument_list|(
name|qr
argument_list|,
name|query
argument_list|,
name|collector
argument_list|,
name|cmd
argument_list|,
name|pf
operator|.
name|postFilter
argument_list|)
expr_stmt|;
name|set
operator|=
name|setCollector
operator|.
name|getDocSet
argument_list|()
expr_stmt|;
name|totalHits
operator|=
name|topCollector
operator|.
name|getTotalHits
argument_list|()
expr_stmt|;
assert|assert
operator|(
name|totalHits
operator|==
name|set
operator|.
name|size
argument_list|()
operator|)
assert|;
name|TopDocs
name|topDocs
init|=
name|topCollector
operator|.
name|topDocs
argument_list|(
literal|0
argument_list|,
name|len
argument_list|)
decl_stmt|;
name|populateNextCursorMarkFromTopDocs
argument_list|(
name|qr
argument_list|,
name|cmd
argument_list|,
name|topDocs
argument_list|)
expr_stmt|;
name|maxScore
operator|=
name|totalHits
operator|>
literal|0
condition|?
name|topDocs
operator|.
name|getMaxScore
argument_list|()
else|:
literal|0.0f
expr_stmt|;
name|nDocsReturned
operator|=
name|topDocs
operator|.
name|scoreDocs
operator|.
name|length
expr_stmt|;
name|ids
operator|=
operator|new
name|int
index|[
name|nDocsReturned
index|]
expr_stmt|;
name|scores
operator|=
operator|(
name|cmd
operator|.
name|getFlags
argument_list|()
operator|&
name|GET_SCORES
operator|)
operator|!=
literal|0
condition|?
operator|new
name|float
index|[
name|nDocsReturned
index|]
else|:
literal|null
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nDocsReturned
condition|;
name|i
operator|++
control|)
block|{
name|ScoreDoc
name|scoreDoc
init|=
name|topDocs
operator|.
name|scoreDocs
index|[
name|i
index|]
decl_stmt|;
name|ids
index|[
name|i
index|]
operator|=
name|scoreDoc
operator|.
name|doc
expr_stmt|;
if|if
condition|(
name|scores
operator|!=
literal|null
condition|)
name|scores
index|[
name|i
index|]
operator|=
name|scoreDoc
operator|.
name|score
expr_stmt|;
block|}
block|}
name|int
name|sliceLen
init|=
name|Math
operator|.
name|min
argument_list|(
name|lastDocRequested
argument_list|,
name|nDocsReturned
argument_list|)
decl_stmt|;
if|if
condition|(
name|sliceLen
operator|<
literal|0
condition|)
name|sliceLen
operator|=
literal|0
expr_stmt|;
name|qr
operator|.
name|setDocList
argument_list|(
operator|new
name|DocSlice
argument_list|(
literal|0
argument_list|,
name|sliceLen
argument_list|,
name|ids
argument_list|,
name|scores
argument_list|,
name|totalHits
argument_list|,
name|maxScore
argument_list|)
argument_list|)
expr_stmt|;
comment|// TODO: if we collect results before the filter, we just need to intersect with
comment|// that filter to generate the DocSet for qr.setDocSet()
name|qr
operator|.
name|setDocSet
argument_list|(
name|set
argument_list|)
expr_stmt|;
comment|// TODO: currently we don't generate the DocSet for the base query,
comment|// but the QueryDocSet == CompleteDocSet if filter==null.
return|return
name|pf
operator|.
name|filter
operator|==
literal|null
operator|&&
name|pf
operator|.
name|postFilter
operator|==
literal|null
condition|?
name|qr
operator|.
name|getDocSet
argument_list|()
else|:
literal|null
return|;
block|}
comment|/**    * Returns documents matching both<code>query</code> and<code>filter</code> and sorted by<code>sort</code>. FUTURE:    * The returned DocList may be retrieved from a cache.    *    * @param filter    *          may be null    * @param lsort    *          criteria by which to sort (if null, query relevance is used)    * @param offset    *          offset into the list of documents to return    * @param len    *          maximum number of documents to return    * @return DocList meeting the specified criteria, should<b>not</b> be modified by the caller.    * @throws IOException    *           If there is a low-level I/O error.    */
DECL|method|getDocList
specifier|public
name|DocList
name|getDocList
parameter_list|(
name|Query
name|query
parameter_list|,
name|DocSet
name|filter
parameter_list|,
name|Sort
name|lsort
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|len
parameter_list|)
throws|throws
name|IOException
block|{
name|QueryCommand
name|qc
init|=
operator|new
name|QueryCommand
argument_list|()
decl_stmt|;
name|qc
operator|.
name|setQuery
argument_list|(
name|query
argument_list|)
operator|.
name|setFilter
argument_list|(
name|filter
argument_list|)
operator|.
name|setSort
argument_list|(
name|lsort
argument_list|)
operator|.
name|setOffset
argument_list|(
name|offset
argument_list|)
operator|.
name|setLen
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|QueryResult
name|qr
init|=
operator|new
name|QueryResult
argument_list|()
decl_stmt|;
name|search
argument_list|(
name|qr
argument_list|,
name|qc
argument_list|)
expr_stmt|;
return|return
name|qr
operator|.
name|getDocList
argument_list|()
return|;
block|}
comment|/**    * Returns documents matching both<code>query</code> and<code>filter</code> and sorted by<code>sort</code>. Also    * returns the complete set of documents matching<code>query</code> and<code>filter</code> (regardless of    *<code>offset</code> and<code>len</code>).    *<p>    * This method is cache aware and may retrieve<code>filter</code> from the cache or make an insertion into the cache    * as a result of this call.    *<p>    * FUTURE: The returned DocList may be retrieved from a cache.    *<p>    * The DocList and DocSet returned should<b>not</b> be modified.    *    * @param filter    *          may be null    * @param lsort    *          criteria by which to sort (if null, query relevance is used)    * @param offset    *          offset into the list of documents to return    * @param len    *          maximum number of documents to return    * @return DocListAndSet meeting the specified criteria, should<b>not</b> be modified by the caller.    * @throws IOException    *           If there is a low-level I/O error.    */
DECL|method|getDocListAndSet
specifier|public
name|DocListAndSet
name|getDocListAndSet
parameter_list|(
name|Query
name|query
parameter_list|,
name|Query
name|filter
parameter_list|,
name|Sort
name|lsort
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|len
parameter_list|)
throws|throws
name|IOException
block|{
name|QueryCommand
name|qc
init|=
operator|new
name|QueryCommand
argument_list|()
decl_stmt|;
name|qc
operator|.
name|setQuery
argument_list|(
name|query
argument_list|)
operator|.
name|setFilterList
argument_list|(
name|filter
argument_list|)
operator|.
name|setSort
argument_list|(
name|lsort
argument_list|)
operator|.
name|setOffset
argument_list|(
name|offset
argument_list|)
operator|.
name|setLen
argument_list|(
name|len
argument_list|)
operator|.
name|setNeedDocSet
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|QueryResult
name|qr
init|=
operator|new
name|QueryResult
argument_list|()
decl_stmt|;
name|search
argument_list|(
name|qr
argument_list|,
name|qc
argument_list|)
expr_stmt|;
return|return
name|qr
operator|.
name|getDocListAndSet
argument_list|()
return|;
block|}
comment|/**    * Returns documents matching both<code>query</code> and<code>filter</code> and sorted by<code>sort</code>. Also    * returns the compete set of documents matching<code>query</code> and<code>filter</code> (regardless of    *<code>offset</code> and<code>len</code>).    *<p>    * This method is cache aware and may retrieve<code>filter</code> from the cache or make an insertion into the cache    * as a result of this call.    *<p>    * FUTURE: The returned DocList may be retrieved from a cache.    *<p>    * The DocList and DocSet returned should<b>not</b> be modified.    *    * @param filter    *          may be null    * @param lsort    *          criteria by which to sort (if null, query relevance is used)    * @param offset    *          offset into the list of documents to return    * @param len    *          maximum number of documents to return    * @param flags    *          user supplied flags for the result set    * @return DocListAndSet meeting the specified criteria, should<b>not</b> be modified by the caller.    * @throws IOException    *           If there is a low-level I/O error.    */
DECL|method|getDocListAndSet
specifier|public
name|DocListAndSet
name|getDocListAndSet
parameter_list|(
name|Query
name|query
parameter_list|,
name|Query
name|filter
parameter_list|,
name|Sort
name|lsort
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|flags
parameter_list|)
throws|throws
name|IOException
block|{
name|QueryCommand
name|qc
init|=
operator|new
name|QueryCommand
argument_list|()
decl_stmt|;
name|qc
operator|.
name|setQuery
argument_list|(
name|query
argument_list|)
operator|.
name|setFilterList
argument_list|(
name|filter
argument_list|)
operator|.
name|setSort
argument_list|(
name|lsort
argument_list|)
operator|.
name|setOffset
argument_list|(
name|offset
argument_list|)
operator|.
name|setLen
argument_list|(
name|len
argument_list|)
operator|.
name|setFlags
argument_list|(
name|flags
argument_list|)
operator|.
name|setNeedDocSet
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|QueryResult
name|qr
init|=
operator|new
name|QueryResult
argument_list|()
decl_stmt|;
name|search
argument_list|(
name|qr
argument_list|,
name|qc
argument_list|)
expr_stmt|;
return|return
name|qr
operator|.
name|getDocListAndSet
argument_list|()
return|;
block|}
comment|/**    * Returns documents matching both<code>query</code> and the intersection of<code>filterList</code>, sorted by    *<code>sort</code>. Also returns the compete set of documents matching<code>query</code> and<code>filter</code>    * (regardless of<code>offset</code> and<code>len</code>).    *<p>    * This method is cache aware and may retrieve<code>filter</code> from the cache or make an insertion into the cache    * as a result of this call.    *<p>    * FUTURE: The returned DocList may be retrieved from a cache.    *<p>    * The DocList and DocSet returned should<b>not</b> be modified.    *    * @param filterList    *          may be null    * @param lsort    *          criteria by which to sort (if null, query relevance is used)    * @param offset    *          offset into the list of documents to return    * @param len    *          maximum number of documents to return    * @return DocListAndSet meeting the specified criteria, should<b>not</b> be modified by the caller.    * @throws IOException    *           If there is a low-level I/O error.    */
DECL|method|getDocListAndSet
specifier|public
name|DocListAndSet
name|getDocListAndSet
parameter_list|(
name|Query
name|query
parameter_list|,
name|List
argument_list|<
name|Query
argument_list|>
name|filterList
parameter_list|,
name|Sort
name|lsort
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|len
parameter_list|)
throws|throws
name|IOException
block|{
name|QueryCommand
name|qc
init|=
operator|new
name|QueryCommand
argument_list|()
decl_stmt|;
name|qc
operator|.
name|setQuery
argument_list|(
name|query
argument_list|)
operator|.
name|setFilterList
argument_list|(
name|filterList
argument_list|)
operator|.
name|setSort
argument_list|(
name|lsort
argument_list|)
operator|.
name|setOffset
argument_list|(
name|offset
argument_list|)
operator|.
name|setLen
argument_list|(
name|len
argument_list|)
operator|.
name|setNeedDocSet
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|QueryResult
name|qr
init|=
operator|new
name|QueryResult
argument_list|()
decl_stmt|;
name|search
argument_list|(
name|qr
argument_list|,
name|qc
argument_list|)
expr_stmt|;
return|return
name|qr
operator|.
name|getDocListAndSet
argument_list|()
return|;
block|}
comment|/**    * Returns documents matching both<code>query</code> and the intersection of<code>filterList</code>, sorted by    *<code>sort</code>. Also returns the compete set of documents matching<code>query</code> and<code>filter</code>    * (regardless of<code>offset</code> and<code>len</code>).    *<p>    * This method is cache aware and may retrieve<code>filter</code> from the cache or make an insertion into the cache    * as a result of this call.    *<p>    * FUTURE: The returned DocList may be retrieved from a cache.    *<p>    * The DocList and DocSet returned should<b>not</b> be modified.    *    * @param filterList    *          may be null    * @param lsort    *          criteria by which to sort (if null, query relevance is used)    * @param offset    *          offset into the list of documents to return    * @param len    *          maximum number of documents to return    * @param flags    *          user supplied flags for the result set    * @return DocListAndSet meeting the specified criteria, should<b>not</b> be modified by the caller.    * @throws IOException    *           If there is a low-level I/O error.    */
DECL|method|getDocListAndSet
specifier|public
name|DocListAndSet
name|getDocListAndSet
parameter_list|(
name|Query
name|query
parameter_list|,
name|List
argument_list|<
name|Query
argument_list|>
name|filterList
parameter_list|,
name|Sort
name|lsort
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|flags
parameter_list|)
throws|throws
name|IOException
block|{
name|QueryCommand
name|qc
init|=
operator|new
name|QueryCommand
argument_list|()
decl_stmt|;
name|qc
operator|.
name|setQuery
argument_list|(
name|query
argument_list|)
operator|.
name|setFilterList
argument_list|(
name|filterList
argument_list|)
operator|.
name|setSort
argument_list|(
name|lsort
argument_list|)
operator|.
name|setOffset
argument_list|(
name|offset
argument_list|)
operator|.
name|setLen
argument_list|(
name|len
argument_list|)
operator|.
name|setFlags
argument_list|(
name|flags
argument_list|)
operator|.
name|setNeedDocSet
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|QueryResult
name|qr
init|=
operator|new
name|QueryResult
argument_list|()
decl_stmt|;
name|search
argument_list|(
name|qr
argument_list|,
name|qc
argument_list|)
expr_stmt|;
return|return
name|qr
operator|.
name|getDocListAndSet
argument_list|()
return|;
block|}
comment|/**    * Returns documents matching both<code>query</code> and<code>filter</code> and sorted by<code>sort</code>. Also    * returns the compete set of documents matching<code>query</code> and<code>filter</code> (regardless of    *<code>offset</code> and<code>len</code>).    *<p>    * FUTURE: The returned DocList may be retrieved from a cache.    *    * @param filter    *          may be null    * @param lsort    *          criteria by which to sort (if null, query relevance is used)    * @param offset    *          offset into the list of documents to return    * @param len    *          maximum number of documents to return    * @return DocListAndSet meeting the specified criteria, should<b>not</b> be modified by the caller.    * @throws IOException    *           If there is a low-level I/O error.    */
DECL|method|getDocListAndSet
specifier|public
name|DocListAndSet
name|getDocListAndSet
parameter_list|(
name|Query
name|query
parameter_list|,
name|DocSet
name|filter
parameter_list|,
name|Sort
name|lsort
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|len
parameter_list|)
throws|throws
name|IOException
block|{
name|QueryCommand
name|qc
init|=
operator|new
name|QueryCommand
argument_list|()
decl_stmt|;
name|qc
operator|.
name|setQuery
argument_list|(
name|query
argument_list|)
operator|.
name|setFilter
argument_list|(
name|filter
argument_list|)
operator|.
name|setSort
argument_list|(
name|lsort
argument_list|)
operator|.
name|setOffset
argument_list|(
name|offset
argument_list|)
operator|.
name|setLen
argument_list|(
name|len
argument_list|)
operator|.
name|setNeedDocSet
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|QueryResult
name|qr
init|=
operator|new
name|QueryResult
argument_list|()
decl_stmt|;
name|search
argument_list|(
name|qr
argument_list|,
name|qc
argument_list|)
expr_stmt|;
return|return
name|qr
operator|.
name|getDocListAndSet
argument_list|()
return|;
block|}
comment|/**    * Returns documents matching both<code>query</code> and<code>filter</code> and sorted by<code>sort</code>. Also    * returns the compete set of documents matching<code>query</code> and<code>filter</code> (regardless of    *<code>offset</code> and<code>len</code>).    *<p>    * This method is cache aware and may make an insertion into the cache as a result of this call.    *<p>    * FUTURE: The returned DocList may be retrieved from a cache.    *<p>    * The DocList and DocSet returned should<b>not</b> be modified.    *    * @param filter    *          may be null    * @param lsort    *          criteria by which to sort (if null, query relevance is used)    * @param offset    *          offset into the list of documents to return    * @param len    *          maximum number of documents to return    * @param flags    *          user supplied flags for the result set    * @return DocListAndSet meeting the specified criteria, should<b>not</b> be modified by the caller.    * @throws IOException    *           If there is a low-level I/O error.    */
DECL|method|getDocListAndSet
specifier|public
name|DocListAndSet
name|getDocListAndSet
parameter_list|(
name|Query
name|query
parameter_list|,
name|DocSet
name|filter
parameter_list|,
name|Sort
name|lsort
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|flags
parameter_list|)
throws|throws
name|IOException
block|{
name|QueryCommand
name|qc
init|=
operator|new
name|QueryCommand
argument_list|()
decl_stmt|;
name|qc
operator|.
name|setQuery
argument_list|(
name|query
argument_list|)
operator|.
name|setFilter
argument_list|(
name|filter
argument_list|)
operator|.
name|setSort
argument_list|(
name|lsort
argument_list|)
operator|.
name|setOffset
argument_list|(
name|offset
argument_list|)
operator|.
name|setLen
argument_list|(
name|len
argument_list|)
operator|.
name|setFlags
argument_list|(
name|flags
argument_list|)
operator|.
name|setNeedDocSet
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|QueryResult
name|qr
init|=
operator|new
name|QueryResult
argument_list|()
decl_stmt|;
name|search
argument_list|(
name|qr
argument_list|,
name|qc
argument_list|)
expr_stmt|;
return|return
name|qr
operator|.
name|getDocListAndSet
argument_list|()
return|;
block|}
DECL|method|sortDocSet
specifier|protected
name|void
name|sortDocSet
parameter_list|(
name|QueryResult
name|qr
parameter_list|,
name|QueryCommand
name|cmd
parameter_list|)
throws|throws
name|IOException
block|{
name|DocSet
name|set
init|=
name|qr
operator|.
name|getDocListAndSet
argument_list|()
operator|.
name|docSet
decl_stmt|;
name|int
name|nDocs
init|=
name|cmd
operator|.
name|getSupersetMaxDoc
argument_list|()
decl_stmt|;
if|if
condition|(
name|nDocs
operator|==
literal|0
condition|)
block|{
comment|// SOLR-2923
name|qr
operator|.
name|getDocListAndSet
argument_list|()
operator|.
name|docList
operator|=
operator|new
name|DocSlice
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
operator|new
name|int
index|[
literal|0
index|]
argument_list|,
literal|null
argument_list|,
name|set
operator|.
name|size
argument_list|()
argument_list|,
literal|0f
argument_list|)
expr_stmt|;
name|qr
operator|.
name|setNextCursorMark
argument_list|(
name|cmd
operator|.
name|getCursorMark
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// bit of a hack to tell if a set is sorted - do it better in the future.
name|boolean
name|inOrder
init|=
name|set
operator|instanceof
name|BitDocSet
operator|||
name|set
operator|instanceof
name|SortedIntDocSet
decl_stmt|;
name|TopDocsCollector
name|topCollector
init|=
name|buildTopDocsCollector
argument_list|(
name|nDocs
argument_list|,
name|cmd
argument_list|)
decl_stmt|;
name|DocIterator
name|iter
init|=
name|set
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|int
name|base
init|=
literal|0
decl_stmt|;
name|int
name|end
init|=
literal|0
decl_stmt|;
name|int
name|readerIndex
init|=
literal|0
decl_stmt|;
name|LeafCollector
name|leafCollector
init|=
literal|null
decl_stmt|;
while|while
condition|(
name|iter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|int
name|doc
init|=
name|iter
operator|.
name|nextDoc
argument_list|()
decl_stmt|;
while|while
condition|(
name|doc
operator|>=
name|end
condition|)
block|{
name|LeafReaderContext
name|leaf
init|=
name|leafContexts
operator|.
name|get
argument_list|(
name|readerIndex
operator|++
argument_list|)
decl_stmt|;
name|base
operator|=
name|leaf
operator|.
name|docBase
expr_stmt|;
name|end
operator|=
name|base
operator|+
name|leaf
operator|.
name|reader
argument_list|()
operator|.
name|maxDoc
argument_list|()
expr_stmt|;
name|leafCollector
operator|=
name|topCollector
operator|.
name|getLeafCollector
argument_list|(
name|leaf
argument_list|)
expr_stmt|;
comment|// we should never need to set the scorer given the settings for the collector
block|}
name|leafCollector
operator|.
name|collect
argument_list|(
name|doc
operator|-
name|base
argument_list|)
expr_stmt|;
block|}
name|TopDocs
name|topDocs
init|=
name|topCollector
operator|.
name|topDocs
argument_list|(
literal|0
argument_list|,
name|nDocs
argument_list|)
decl_stmt|;
name|int
name|nDocsReturned
init|=
name|topDocs
operator|.
name|scoreDocs
operator|.
name|length
decl_stmt|;
name|int
index|[]
name|ids
init|=
operator|new
name|int
index|[
name|nDocsReturned
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nDocsReturned
condition|;
name|i
operator|++
control|)
block|{
name|ScoreDoc
name|scoreDoc
init|=
name|topDocs
operator|.
name|scoreDocs
index|[
name|i
index|]
decl_stmt|;
name|ids
index|[
name|i
index|]
operator|=
name|scoreDoc
operator|.
name|doc
expr_stmt|;
block|}
name|qr
operator|.
name|getDocListAndSet
argument_list|()
operator|.
name|docList
operator|=
operator|new
name|DocSlice
argument_list|(
literal|0
argument_list|,
name|nDocsReturned
argument_list|,
name|ids
argument_list|,
literal|null
argument_list|,
name|topDocs
operator|.
name|totalHits
argument_list|,
literal|0.0f
argument_list|)
expr_stmt|;
name|populateNextCursorMarkFromTopDocs
argument_list|(
name|qr
argument_list|,
name|cmd
argument_list|,
name|topDocs
argument_list|)
expr_stmt|;
block|}
comment|/**    * Returns the number of documents that match both<code>a</code> and<code>b</code>.    *<p>    * This method is cache-aware and may check as well as modify the cache.    *    * @return the number of documents in the intersection between<code>a</code> and<code>b</code>.    * @throws IOException    *           If there is a low-level I/O error.    */
DECL|method|numDocs
specifier|public
name|int
name|numDocs
parameter_list|(
name|Query
name|a
parameter_list|,
name|DocSet
name|b
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|filterCache
operator|!=
literal|null
condition|)
block|{
comment|// Negative query if absolute value different from original
name|Query
name|absQ
init|=
name|QueryUtils
operator|.
name|getAbs
argument_list|(
name|a
argument_list|)
decl_stmt|;
name|DocSet
name|positiveA
init|=
name|getPositiveDocSet
argument_list|(
name|absQ
argument_list|)
decl_stmt|;
return|return
name|a
operator|==
name|absQ
condition|?
name|b
operator|.
name|intersectionSize
argument_list|(
name|positiveA
argument_list|)
else|:
name|b
operator|.
name|andNotSize
argument_list|(
name|positiveA
argument_list|)
return|;
block|}
else|else
block|{
comment|// If there isn't a cache, then do a single filtered query
comment|// NOTE: we cannot use FilteredQuery, because BitDocSet assumes it will never
comment|// have deleted documents, but UninvertedField's doNegative has sets with deleted docs
name|TotalHitCountCollector
name|collector
init|=
operator|new
name|TotalHitCountCollector
argument_list|()
decl_stmt|;
name|BooleanQuery
operator|.
name|Builder
name|bq
init|=
operator|new
name|BooleanQuery
operator|.
name|Builder
argument_list|()
decl_stmt|;
name|bq
operator|.
name|add
argument_list|(
name|QueryUtils
operator|.
name|makeQueryable
argument_list|(
name|a
argument_list|)
argument_list|,
name|BooleanClause
operator|.
name|Occur
operator|.
name|MUST
argument_list|)
expr_stmt|;
name|bq
operator|.
name|add
argument_list|(
operator|new
name|ConstantScoreQuery
argument_list|(
name|b
operator|.
name|getTopFilter
argument_list|()
argument_list|)
argument_list|,
name|BooleanClause
operator|.
name|Occur
operator|.
name|MUST
argument_list|)
expr_stmt|;
name|super
operator|.
name|search
argument_list|(
name|bq
operator|.
name|build
argument_list|()
argument_list|,
name|collector
argument_list|)
expr_stmt|;
return|return
name|collector
operator|.
name|getTotalHits
argument_list|()
return|;
block|}
block|}
comment|/** @lucene.internal */
DECL|method|numDocs
specifier|public
name|int
name|numDocs
parameter_list|(
name|DocSet
name|a
parameter_list|,
name|DocsEnumState
name|deState
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Negative query if absolute value different from original
return|return
name|a
operator|.
name|intersectionSize
argument_list|(
name|getDocSet
argument_list|(
name|deState
argument_list|)
argument_list|)
return|;
block|}
DECL|class|DocsEnumState
specifier|public
specifier|static
class|class
name|DocsEnumState
block|{
DECL|field|fieldName
specifier|public
name|String
name|fieldName
decl_stmt|;
comment|// currently interned for as long as lucene requires it
DECL|field|termsEnum
specifier|public
name|TermsEnum
name|termsEnum
decl_stmt|;
DECL|field|liveDocs
specifier|public
name|Bits
name|liveDocs
decl_stmt|;
DECL|field|postingsEnum
specifier|public
name|PostingsEnum
name|postingsEnum
decl_stmt|;
DECL|field|minSetSizeCached
specifier|public
name|int
name|minSetSizeCached
decl_stmt|;
DECL|field|scratch
specifier|public
name|int
index|[]
name|scratch
decl_stmt|;
block|}
comment|/**    * Returns the number of documents that match both<code>a</code> and<code>b</code>.    *<p>    * This method is cache-aware and may check as well as modify the cache.    *    * @return the number of documents in the intersection between<code>a</code> and<code>b</code>.    * @throws IOException    *           If there is a low-level I/O error.    */
DECL|method|numDocs
specifier|public
name|int
name|numDocs
parameter_list|(
name|Query
name|a
parameter_list|,
name|Query
name|b
parameter_list|)
throws|throws
name|IOException
block|{
name|Query
name|absA
init|=
name|QueryUtils
operator|.
name|getAbs
argument_list|(
name|a
argument_list|)
decl_stmt|;
name|Query
name|absB
init|=
name|QueryUtils
operator|.
name|getAbs
argument_list|(
name|b
argument_list|)
decl_stmt|;
name|DocSet
name|positiveA
init|=
name|getPositiveDocSet
argument_list|(
name|absA
argument_list|)
decl_stmt|;
name|DocSet
name|positiveB
init|=
name|getPositiveDocSet
argument_list|(
name|absB
argument_list|)
decl_stmt|;
comment|// Negative query if absolute value different from original
if|if
condition|(
name|a
operator|==
name|absA
condition|)
block|{
if|if
condition|(
name|b
operator|==
name|absB
condition|)
return|return
name|positiveA
operator|.
name|intersectionSize
argument_list|(
name|positiveB
argument_list|)
return|;
return|return
name|positiveA
operator|.
name|andNotSize
argument_list|(
name|positiveB
argument_list|)
return|;
block|}
if|if
condition|(
name|b
operator|==
name|absB
condition|)
return|return
name|positiveB
operator|.
name|andNotSize
argument_list|(
name|positiveA
argument_list|)
return|;
comment|// if both negative, we need to create a temp DocSet since we
comment|// don't have a counting method that takes three.
name|DocSet
name|all
init|=
name|getLiveDocs
argument_list|()
decl_stmt|;
comment|// -a -b == *:*.andNot(a).andNotSize(b) == *.*.andNotSize(a.union(b))
comment|// we use the last form since the intermediate DocSet should normally be smaller.
return|return
name|all
operator|.
name|andNotSize
argument_list|(
name|positiveA
operator|.
name|union
argument_list|(
name|positiveB
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Takes a list of document IDs, and returns an array of Documents containing all of the stored fields.    */
DECL|method|readDocs
specifier|public
name|Document
index|[]
name|readDocs
parameter_list|(
name|DocList
name|ids
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|Document
index|[]
name|docs
init|=
operator|new
name|Document
index|[
name|ids
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
name|readDocs
argument_list|(
name|docs
argument_list|,
name|ids
argument_list|)
expr_stmt|;
return|return
name|docs
return|;
block|}
comment|/**    * Warm this searcher based on an old one (primarily for auto-cache warming).    */
DECL|method|warm
specifier|public
name|void
name|warm
parameter_list|(
name|SolrIndexSearcher
name|old
parameter_list|)
block|{
comment|// Make sure this is first! filters can help queryResults execute!
name|long
name|warmingStartTime
init|=
name|System
operator|.
name|nanoTime
argument_list|()
decl_stmt|;
comment|// warm the caches in order...
name|ModifiableSolrParams
name|params
init|=
operator|new
name|ModifiableSolrParams
argument_list|()
decl_stmt|;
name|params
operator|.
name|add
argument_list|(
literal|"warming"
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|cacheList
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|log
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"autowarming [{}] from [{}]\n\t{}"
argument_list|,
name|this
argument_list|,
name|old
argument_list|,
name|old
operator|.
name|cacheList
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
specifier|final
name|SolrQueryRequest
name|req
init|=
operator|new
name|LocalSolrQueryRequest
argument_list|(
name|core
argument_list|,
name|params
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|SolrIndexSearcher
name|getSearcher
parameter_list|()
block|{
return|return
name|SolrIndexSearcher
operator|.
name|this
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|close
parameter_list|()
block|{}
block|}
decl_stmt|;
specifier|final
name|SolrQueryResponse
name|rsp
init|=
operator|new
name|SolrQueryResponse
argument_list|()
decl_stmt|;
name|SolrRequestInfo
operator|.
name|clearRequestInfo
argument_list|()
expr_stmt|;
name|SolrRequestInfo
operator|.
name|setRequestInfo
argument_list|(
operator|new
name|SolrRequestInfo
argument_list|(
name|req
argument_list|,
name|rsp
argument_list|)
argument_list|)
expr_stmt|;
try|try
block|{
name|cacheList
index|[
name|i
index|]
operator|.
name|warm
argument_list|(
name|this
argument_list|,
name|old
operator|.
name|cacheList
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
try|try
block|{
name|req
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|SolrRequestInfo
operator|.
name|clearRequestInfo
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|log
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"autowarming result for [{}]\n\t{}"
argument_list|,
name|this
argument_list|,
name|cacheList
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|warmupTime
operator|=
name|TimeUnit
operator|.
name|MILLISECONDS
operator|.
name|convert
argument_list|(
name|System
operator|.
name|nanoTime
argument_list|()
operator|-
name|warmingStartTime
argument_list|,
name|TimeUnit
operator|.
name|NANOSECONDS
argument_list|)
expr_stmt|;
block|}
comment|/**    * return the named generic cache    */
DECL|method|getCache
specifier|public
name|SolrCache
name|getCache
parameter_list|(
name|String
name|cacheName
parameter_list|)
block|{
return|return
name|cacheMap
operator|.
name|get
argument_list|(
name|cacheName
argument_list|)
return|;
block|}
comment|/**    * lookup an entry in a generic cache    */
DECL|method|cacheLookup
specifier|public
name|Object
name|cacheLookup
parameter_list|(
name|String
name|cacheName
parameter_list|,
name|Object
name|key
parameter_list|)
block|{
name|SolrCache
name|cache
init|=
name|cacheMap
operator|.
name|get
argument_list|(
name|cacheName
argument_list|)
decl_stmt|;
return|return
name|cache
operator|==
literal|null
condition|?
literal|null
else|:
name|cache
operator|.
name|get
argument_list|(
name|key
argument_list|)
return|;
block|}
comment|/**    * insert an entry in a generic cache    */
DECL|method|cacheInsert
specifier|public
name|Object
name|cacheInsert
parameter_list|(
name|String
name|cacheName
parameter_list|,
name|Object
name|key
parameter_list|,
name|Object
name|val
parameter_list|)
block|{
name|SolrCache
name|cache
init|=
name|cacheMap
operator|.
name|get
argument_list|(
name|cacheName
argument_list|)
decl_stmt|;
return|return
name|cache
operator|==
literal|null
condition|?
literal|null
else|:
name|cache
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|val
argument_list|)
return|;
block|}
DECL|method|getOpenTimeStamp
specifier|public
name|Date
name|getOpenTimeStamp
parameter_list|()
block|{
return|return
name|openTime
return|;
block|}
comment|// public but primarily for test case usage
DECL|method|getOpenNanoTime
specifier|public
name|long
name|getOpenNanoTime
parameter_list|()
block|{
return|return
name|openNanoTime
return|;
block|}
annotation|@
name|Override
DECL|method|explain
specifier|public
name|Explanation
name|explain
parameter_list|(
name|Query
name|query
parameter_list|,
name|int
name|doc
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|super
operator|.
name|explain
argument_list|(
name|QueryUtils
operator|.
name|makeQueryable
argument_list|(
name|query
argument_list|)
argument_list|,
name|doc
argument_list|)
return|;
block|}
comment|/** @lucene.internal    * gets a cached version of the IndexFingerprint for this searcher    **/
DECL|method|getIndexFingerprint
specifier|public
name|IndexFingerprint
name|getIndexFingerprint
parameter_list|(
name|long
name|maxVersion
parameter_list|)
throws|throws
name|IOException
block|{
comment|// possibly expensive, so prevent more than one thread from calculating it for this searcher
synchronized|synchronized
init|(
name|fingerprintLock
init|)
block|{
if|if
condition|(
name|fingerprint
operator|==
literal|null
condition|)
block|{
name|fingerprint
operator|=
name|IndexFingerprint
operator|.
name|getFingerprint
argument_list|(
name|this
argument_list|,
name|maxVersion
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|fingerprint
return|;
block|}
comment|/////////////////////////////////////////////////////////////////////
comment|// SolrInfoMBean stuff: Statistics and Module Info
comment|/////////////////////////////////////////////////////////////////////
annotation|@
name|Override
DECL|method|getName
specifier|public
name|String
name|getName
parameter_list|()
block|{
return|return
name|SolrIndexSearcher
operator|.
name|class
operator|.
name|getName
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|getVersion
specifier|public
name|String
name|getVersion
parameter_list|()
block|{
return|return
name|SolrCore
operator|.
name|version
return|;
block|}
annotation|@
name|Override
DECL|method|getDescription
specifier|public
name|String
name|getDescription
parameter_list|()
block|{
return|return
literal|"index searcher"
return|;
block|}
annotation|@
name|Override
DECL|method|getCategory
specifier|public
name|Category
name|getCategory
parameter_list|()
block|{
return|return
name|Category
operator|.
name|CORE
return|;
block|}
annotation|@
name|Override
DECL|method|getSource
specifier|public
name|String
name|getSource
parameter_list|()
block|{
return|return
literal|null
return|;
block|}
annotation|@
name|Override
DECL|method|getDocs
specifier|public
name|URL
index|[]
name|getDocs
parameter_list|()
block|{
return|return
literal|null
return|;
block|}
annotation|@
name|Override
DECL|method|getStatistics
specifier|public
name|NamedList
argument_list|<
name|Object
argument_list|>
name|getStatistics
parameter_list|()
block|{
specifier|final
name|NamedList
argument_list|<
name|Object
argument_list|>
name|lst
init|=
operator|new
name|SimpleOrderedMap
argument_list|<>
argument_list|()
decl_stmt|;
name|lst
operator|.
name|add
argument_list|(
literal|"searcherName"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|lst
operator|.
name|add
argument_list|(
literal|"caching"
argument_list|,
name|cachingEnabled
argument_list|)
expr_stmt|;
name|lst
operator|.
name|add
argument_list|(
literal|"numDocs"
argument_list|,
name|reader
operator|.
name|numDocs
argument_list|()
argument_list|)
expr_stmt|;
name|lst
operator|.
name|add
argument_list|(
literal|"maxDoc"
argument_list|,
name|reader
operator|.
name|maxDoc
argument_list|()
argument_list|)
expr_stmt|;
name|lst
operator|.
name|add
argument_list|(
literal|"deletedDocs"
argument_list|,
name|reader
operator|.
name|maxDoc
argument_list|()
operator|-
name|reader
operator|.
name|numDocs
argument_list|()
argument_list|)
expr_stmt|;
name|lst
operator|.
name|add
argument_list|(
literal|"reader"
argument_list|,
name|reader
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|lst
operator|.
name|add
argument_list|(
literal|"readerDir"
argument_list|,
name|reader
operator|.
name|directory
argument_list|()
argument_list|)
expr_stmt|;
name|lst
operator|.
name|add
argument_list|(
literal|"indexVersion"
argument_list|,
name|reader
operator|.
name|getVersion
argument_list|()
argument_list|)
expr_stmt|;
name|lst
operator|.
name|add
argument_list|(
literal|"openedAt"
argument_list|,
name|openTime
argument_list|)
expr_stmt|;
if|if
condition|(
name|registerTime
operator|!=
literal|null
condition|)
name|lst
operator|.
name|add
argument_list|(
literal|"registeredAt"
argument_list|,
name|registerTime
argument_list|)
expr_stmt|;
name|lst
operator|.
name|add
argument_list|(
literal|"warmupTime"
argument_list|,
name|warmupTime
argument_list|)
expr_stmt|;
return|return
name|lst
return|;
block|}
DECL|class|FilterImpl
specifier|private
specifier|static
class|class
name|FilterImpl
extends|extends
name|Filter
block|{
DECL|field|topFilter
specifier|private
specifier|final
name|Filter
name|topFilter
decl_stmt|;
DECL|field|weights
specifier|private
specifier|final
name|List
argument_list|<
name|Weight
argument_list|>
name|weights
decl_stmt|;
DECL|method|FilterImpl
specifier|public
name|FilterImpl
parameter_list|(
name|DocSet
name|filter
parameter_list|,
name|List
argument_list|<
name|Weight
argument_list|>
name|weights
parameter_list|)
block|{
name|this
operator|.
name|weights
operator|=
name|weights
expr_stmt|;
name|this
operator|.
name|topFilter
operator|=
name|filter
operator|==
literal|null
condition|?
literal|null
else|:
name|filter
operator|.
name|getTopFilter
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|getDocIdSet
specifier|public
name|DocIdSet
name|getDocIdSet
parameter_list|(
name|LeafReaderContext
name|context
parameter_list|,
name|Bits
name|acceptDocs
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|DocIdSet
name|sub
init|=
name|topFilter
operator|==
literal|null
condition|?
literal|null
else|:
name|topFilter
operator|.
name|getDocIdSet
argument_list|(
name|context
argument_list|,
name|acceptDocs
argument_list|)
decl_stmt|;
if|if
condition|(
name|weights
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
return|return
name|sub
return|;
return|return
operator|new
name|FilterSet
argument_list|(
name|sub
argument_list|,
name|context
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|(
name|String
name|field
parameter_list|)
block|{
return|return
literal|"SolrFilter"
return|;
block|}
DECL|class|FilterSet
specifier|private
class|class
name|FilterSet
extends|extends
name|DocIdSet
block|{
DECL|field|docIdSet
specifier|private
specifier|final
name|DocIdSet
name|docIdSet
decl_stmt|;
DECL|field|context
specifier|private
specifier|final
name|LeafReaderContext
name|context
decl_stmt|;
DECL|method|FilterSet
specifier|public
name|FilterSet
parameter_list|(
name|DocIdSet
name|docIdSet
parameter_list|,
name|LeafReaderContext
name|context
parameter_list|)
block|{
name|this
operator|.
name|docIdSet
operator|=
name|docIdSet
expr_stmt|;
name|this
operator|.
name|context
operator|=
name|context
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|iterator
specifier|public
name|DocIdSetIterator
name|iterator
parameter_list|()
throws|throws
name|IOException
block|{
name|List
argument_list|<
name|DocIdSetIterator
argument_list|>
name|iterators
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|weights
operator|.
name|size
argument_list|()
operator|+
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|docIdSet
operator|!=
literal|null
condition|)
block|{
specifier|final
name|DocIdSetIterator
name|iter
init|=
name|docIdSet
operator|.
name|iterator
argument_list|()
decl_stmt|;
if|if
condition|(
name|iter
operator|==
literal|null
condition|)
return|return
literal|null
return|;
name|iterators
operator|.
name|add
argument_list|(
name|iter
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|Weight
name|w
range|:
name|weights
control|)
block|{
specifier|final
name|Scorer
name|scorer
init|=
name|w
operator|.
name|scorer
argument_list|(
name|context
argument_list|)
decl_stmt|;
if|if
condition|(
name|scorer
operator|==
literal|null
condition|)
return|return
literal|null
return|;
name|iterators
operator|.
name|add
argument_list|(
name|scorer
operator|.
name|iterator
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|iterators
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
literal|null
return|;
if|if
condition|(
name|iterators
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
return|return
name|iterators
operator|.
name|get
argument_list|(
literal|0
argument_list|)
return|;
if|if
condition|(
name|iterators
operator|.
name|size
argument_list|()
operator|==
literal|2
condition|)
return|return
operator|new
name|DualFilterIterator
argument_list|(
name|iterators
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
name|iterators
operator|.
name|get
argument_list|(
literal|1
argument_list|)
argument_list|)
return|;
return|return
operator|new
name|FilterIterator
argument_list|(
name|iterators
operator|.
name|toArray
argument_list|(
operator|new
name|DocIdSetIterator
index|[
name|iterators
operator|.
name|size
argument_list|()
index|]
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|bits
specifier|public
name|Bits
name|bits
parameter_list|()
throws|throws
name|IOException
block|{
return|return
literal|null
return|;
comment|// don't use random access
block|}
annotation|@
name|Override
DECL|method|ramBytesUsed
specifier|public
name|long
name|ramBytesUsed
parameter_list|()
block|{
return|return
name|docIdSet
operator|!=
literal|null
condition|?
name|docIdSet
operator|.
name|ramBytesUsed
argument_list|()
else|:
literal|0L
return|;
block|}
block|}
DECL|class|FilterIterator
specifier|private
specifier|static
class|class
name|FilterIterator
extends|extends
name|DocIdSetIterator
block|{
DECL|field|iterators
specifier|private
specifier|final
name|DocIdSetIterator
index|[]
name|iterators
decl_stmt|;
DECL|field|first
specifier|private
specifier|final
name|DocIdSetIterator
name|first
decl_stmt|;
DECL|method|FilterIterator
specifier|public
name|FilterIterator
parameter_list|(
name|DocIdSetIterator
index|[]
name|iterators
parameter_list|)
block|{
name|this
operator|.
name|iterators
operator|=
name|iterators
expr_stmt|;
name|this
operator|.
name|first
operator|=
name|iterators
index|[
literal|0
index|]
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|docID
specifier|public
name|int
name|docID
parameter_list|()
block|{
return|return
name|first
operator|.
name|docID
argument_list|()
return|;
block|}
DECL|method|advanceAllTo
specifier|private
name|int
name|advanceAllTo
parameter_list|(
name|int
name|doc
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|highestDocIter
init|=
literal|0
decl_stmt|;
comment|// index of the iterator with the highest id
name|int
name|i
init|=
literal|1
decl_stmt|;
comment|// We already advanced the first iterator before calling this method
while|while
condition|(
name|i
operator|<
name|iterators
operator|.
name|length
condition|)
block|{
if|if
condition|(
name|i
operator|!=
name|highestDocIter
condition|)
block|{
specifier|final
name|int
name|next
init|=
name|iterators
index|[
name|i
index|]
operator|.
name|advance
argument_list|(
name|doc
argument_list|)
decl_stmt|;
if|if
condition|(
name|next
operator|!=
name|doc
condition|)
block|{
comment|// We need to advance all iterators to a new target
name|doc
operator|=
name|next
expr_stmt|;
name|highestDocIter
operator|=
name|i
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
block|}
operator|++
name|i
expr_stmt|;
block|}
return|return
name|doc
return|;
block|}
annotation|@
name|Override
DECL|method|nextDoc
specifier|public
name|int
name|nextDoc
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|advanceAllTo
argument_list|(
name|first
operator|.
name|nextDoc
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|advance
specifier|public
name|int
name|advance
parameter_list|(
name|int
name|target
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|advanceAllTo
argument_list|(
name|first
operator|.
name|advance
argument_list|(
name|target
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|cost
specifier|public
name|long
name|cost
parameter_list|()
block|{
return|return
name|first
operator|.
name|cost
argument_list|()
return|;
block|}
block|}
DECL|class|DualFilterIterator
specifier|private
specifier|static
class|class
name|DualFilterIterator
extends|extends
name|DocIdSetIterator
block|{
DECL|field|a
specifier|private
specifier|final
name|DocIdSetIterator
name|a
decl_stmt|;
DECL|field|b
specifier|private
specifier|final
name|DocIdSetIterator
name|b
decl_stmt|;
DECL|method|DualFilterIterator
specifier|public
name|DualFilterIterator
parameter_list|(
name|DocIdSetIterator
name|a
parameter_list|,
name|DocIdSetIterator
name|b
parameter_list|)
block|{
name|this
operator|.
name|a
operator|=
name|a
expr_stmt|;
name|this
operator|.
name|b
operator|=
name|b
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|docID
specifier|public
name|int
name|docID
parameter_list|()
block|{
return|return
name|a
operator|.
name|docID
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|nextDoc
specifier|public
name|int
name|nextDoc
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|doNext
argument_list|(
name|a
operator|.
name|nextDoc
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|advance
specifier|public
name|int
name|advance
parameter_list|(
name|int
name|target
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|doNext
argument_list|(
name|a
operator|.
name|advance
argument_list|(
name|target
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|cost
specifier|public
name|long
name|cost
parameter_list|()
block|{
return|return
name|Math
operator|.
name|min
argument_list|(
name|a
operator|.
name|cost
argument_list|()
argument_list|,
name|b
operator|.
name|cost
argument_list|()
argument_list|)
return|;
block|}
DECL|method|doNext
specifier|private
name|int
name|doNext
parameter_list|(
name|int
name|doc
parameter_list|)
throws|throws
name|IOException
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|other
init|=
name|b
operator|.
name|advance
argument_list|(
name|doc
argument_list|)
decl_stmt|;
if|if
condition|(
name|other
operator|==
name|doc
condition|)
return|return
name|doc
return|;
name|doc
operator|=
name|a
operator|.
name|advance
argument_list|(
name|other
argument_list|)
expr_stmt|;
if|if
condition|(
name|other
operator|==
name|doc
condition|)
return|return
name|doc
return|;
block|}
block|}
block|}
block|}
block|}
end_class
end_unit
