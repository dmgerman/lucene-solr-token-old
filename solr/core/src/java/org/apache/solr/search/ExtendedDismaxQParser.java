begin_unit
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_package
DECL|package|org.apache.solr.search
package|package
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|search
package|;
end_package
begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Function
import|;
end_import
begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Multimap
import|;
end_import
begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Multimaps
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|Analyzer
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|core
operator|.
name|StopFilterFactory
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|util
operator|.
name|TokenFilterFactory
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|queries
operator|.
name|function
operator|.
name|BoostedQuery
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|queries
operator|.
name|function
operator|.
name|FunctionQuery
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|queries
operator|.
name|function
operator|.
name|ValueSource
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|queries
operator|.
name|function
operator|.
name|valuesource
operator|.
name|ProductFloatFunction
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|queries
operator|.
name|function
operator|.
name|valuesource
operator|.
name|QueryValueSource
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|BooleanClause
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|BooleanQuery
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|DisjunctionMaxQuery
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|MatchAllDocsQuery
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|MultiPhraseQuery
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|PhraseQuery
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|Query
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|analysis
operator|.
name|TokenizerChain
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|params
operator|.
name|DisMaxParams
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|params
operator|.
name|SolrParams
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|util
operator|.
name|NamedList
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|parser
operator|.
name|QueryParser
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|parser
operator|.
name|SolrQueryParserBase
operator|.
name|MagicFieldName
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|request
operator|.
name|SolrQueryRequest
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|schema
operator|.
name|FieldType
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|util
operator|.
name|SolrPluginUtils
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashMap
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedList
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import
begin_comment
comment|/**  * Query parser that generates DisjunctionMaxQueries based on user configuration.  * See Wiki page http://wiki.apache.org/solr/ExtendedDisMax  */
end_comment
begin_class
DECL|class|ExtendedDismaxQParser
specifier|public
class|class
name|ExtendedDismaxQParser
extends|extends
name|QParser
block|{
comment|/**    * A field we can't ever find in any schema, so we can safely tell    * DisjunctionMaxQueryParser to use it as our defaultField, and    * map aliases from it to any field in our schema.    */
DECL|field|IMPOSSIBLE_FIELD_NAME
specifier|private
specifier|static
name|String
name|IMPOSSIBLE_FIELD_NAME
init|=
literal|"\uFFFC\uFFFC\uFFFC"
decl_stmt|;
comment|/**    * Helper function which returns the specified {@link FieldParams}' {@link FieldParams#getWordGrams()} value.    */
DECL|field|WORD_GRAM_EXTRACTOR
specifier|private
specifier|static
specifier|final
name|Function
argument_list|<
name|FieldParams
argument_list|,
name|Integer
argument_list|>
name|WORD_GRAM_EXTRACTOR
init|=
operator|new
name|Function
argument_list|<
name|FieldParams
argument_list|,
name|Integer
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Integer
name|apply
parameter_list|(
name|FieldParams
name|input
parameter_list|)
block|{
return|return
name|input
operator|.
name|getWordGrams
argument_list|()
return|;
block|}
block|}
decl_stmt|;
comment|/**    * Helper function which returns the specified {@link FieldParams}' {@link FieldParams#getSlop()} value.    */
DECL|field|PHRASE_SLOP_EXTRACTOR
specifier|private
specifier|static
specifier|final
name|Function
argument_list|<
name|FieldParams
argument_list|,
name|Integer
argument_list|>
name|PHRASE_SLOP_EXTRACTOR
init|=
operator|new
name|Function
argument_list|<
name|FieldParams
argument_list|,
name|Integer
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Integer
name|apply
parameter_list|(
name|FieldParams
name|input
parameter_list|)
block|{
return|return
name|input
operator|.
name|getSlop
argument_list|()
return|;
block|}
block|}
decl_stmt|;
comment|/** shorten the class references for utilities */
DECL|class|U
specifier|private
specifier|static
class|class
name|U
extends|extends
name|SolrPluginUtils
block|{
comment|/* :NOOP */
block|}
comment|/** shorten the class references for utilities */
DECL|interface|DMP
specifier|private
specifier|static
interface|interface
name|DMP
extends|extends
name|DisMaxParams
block|{
comment|/**      * User fields. The fields that can be used by the end user to create field-specific queries.      */
DECL|field|UF
specifier|public
specifier|static
name|String
name|UF
init|=
literal|"uf"
decl_stmt|;
comment|/**      * Lowercase Operators. If set to true, 'or' and 'and' will be considered OR and AND, otherwise      * lowercase operators will be considered terms to search for.      */
DECL|field|LOWERCASE_OPS
specifier|public
specifier|static
name|String
name|LOWERCASE_OPS
init|=
literal|"lowercaseOperators"
decl_stmt|;
comment|/**      * Multiplicative boost. Boost functions which scores are going to be multiplied to the score      * of the main query (instead of just added, like with bf)      */
DECL|field|MULT_BOOST
specifier|public
specifier|static
name|String
name|MULT_BOOST
init|=
literal|"boost"
decl_stmt|;
comment|/**      * If set to true, stopwords are removed from the query.      */
DECL|field|STOPWORDS
specifier|public
specifier|static
name|String
name|STOPWORDS
init|=
literal|"stopwords"
decl_stmt|;
block|}
DECL|field|config
specifier|private
name|ExtendedDismaxConfiguration
name|config
decl_stmt|;
DECL|field|parsedUserQuery
specifier|private
name|Query
name|parsedUserQuery
decl_stmt|;
DECL|field|altUserQuery
specifier|private
name|Query
name|altUserQuery
decl_stmt|;
DECL|field|boostQueries
specifier|private
name|List
argument_list|<
name|Query
argument_list|>
name|boostQueries
decl_stmt|;
DECL|field|parsed
specifier|private
name|boolean
name|parsed
init|=
literal|false
decl_stmt|;
DECL|method|ExtendedDismaxQParser
specifier|public
name|ExtendedDismaxQParser
parameter_list|(
name|String
name|qstr
parameter_list|,
name|SolrParams
name|localParams
parameter_list|,
name|SolrParams
name|params
parameter_list|,
name|SolrQueryRequest
name|req
parameter_list|)
block|{
name|super
argument_list|(
name|qstr
argument_list|,
name|localParams
argument_list|,
name|params
argument_list|,
name|req
argument_list|)
expr_stmt|;
name|config
operator|=
name|this
operator|.
name|createConfiguration
argument_list|(
name|qstr
argument_list|,
name|localParams
argument_list|,
name|params
argument_list|,
name|req
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|parse
specifier|public
name|Query
name|parse
parameter_list|()
throws|throws
name|SyntaxError
block|{
name|parsed
operator|=
literal|true
expr_stmt|;
comment|/* the main query we will execute.  we disable the coord because      * this query is an artificial construct      */
name|BooleanQuery
name|query
init|=
operator|new
name|BooleanQuery
argument_list|(
literal|true
argument_list|)
decl_stmt|;
comment|/* * * Main User Query * * */
name|parsedUserQuery
operator|=
literal|null
expr_stmt|;
name|String
name|userQuery
init|=
name|getString
argument_list|()
decl_stmt|;
name|altUserQuery
operator|=
literal|null
expr_stmt|;
if|if
condition|(
name|userQuery
operator|==
literal|null
operator|||
name|userQuery
operator|.
name|trim
argument_list|()
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
block|{
comment|// If no query is specified, we may have an alternate
if|if
condition|(
name|config
operator|.
name|altQ
operator|!=
literal|null
condition|)
block|{
name|QParser
name|altQParser
init|=
name|subQuery
argument_list|(
name|config
operator|.
name|altQ
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|altUserQuery
operator|=
name|altQParser
operator|.
name|getQuery
argument_list|()
expr_stmt|;
name|query
operator|.
name|add
argument_list|(
name|altUserQuery
argument_list|,
name|BooleanClause
operator|.
name|Occur
operator|.
name|MUST
argument_list|)
expr_stmt|;
block|}
else|else
block|{
return|return
literal|null
return|;
comment|// throw new SyntaxError("missing query string" );
block|}
block|}
else|else
block|{
comment|// There is a valid query string
name|ExtendedSolrQueryParser
name|up
init|=
name|createEdismaxQueryParser
argument_list|(
name|this
argument_list|,
name|IMPOSSIBLE_FIELD_NAME
argument_list|)
decl_stmt|;
name|up
operator|.
name|addAlias
argument_list|(
name|IMPOSSIBLE_FIELD_NAME
argument_list|,
name|config
operator|.
name|tiebreaker
argument_list|,
name|config
operator|.
name|queryFields
argument_list|)
expr_stmt|;
name|addAliasesFromRequest
argument_list|(
name|up
argument_list|,
name|config
operator|.
name|tiebreaker
argument_list|)
expr_stmt|;
name|up
operator|.
name|setPhraseSlop
argument_list|(
name|config
operator|.
name|qslop
argument_list|)
expr_stmt|;
comment|// slop for explicit user phrase queries
name|up
operator|.
name|setAllowLeadingWildcard
argument_list|(
literal|true
argument_list|)
expr_stmt|;
comment|// defer escaping and only do if lucene parsing fails, or we need phrases
comment|// parsing fails.  Need to sloppy phrase queries anyway though.
name|List
argument_list|<
name|Clause
argument_list|>
name|clauses
init|=
name|splitIntoClauses
argument_list|(
name|userQuery
argument_list|,
literal|false
argument_list|)
decl_stmt|;
comment|// Always rebuild mainUserQuery from clauses to catch modifications from splitIntoClauses
comment|// This was necessary for userFields modifications to get propagated into the query.
comment|// Convert lower or mixed case operators to uppercase if we saw them.
comment|// only do this for the lucene query part and not for phrase query boosting
comment|// since some fields might not be case insensitive.
comment|// We don't use a regex for this because it might change and AND or OR in
comment|// a phrase query in a case sensitive field.
name|String
name|mainUserQuery
init|=
name|rebuildUserQuery
argument_list|(
name|clauses
argument_list|,
name|config
operator|.
name|lowercaseOperators
argument_list|)
decl_stmt|;
comment|// but always for unstructured implicit bqs created by getFieldQuery
name|up
operator|.
name|minShouldMatch
operator|=
name|config
operator|.
name|minShouldMatch
expr_stmt|;
name|parsedUserQuery
operator|=
name|parseOriginalQuery
argument_list|(
name|up
argument_list|,
name|mainUserQuery
argument_list|,
name|clauses
argument_list|,
name|config
argument_list|)
expr_stmt|;
if|if
condition|(
name|parsedUserQuery
operator|==
literal|null
condition|)
block|{
name|parsedUserQuery
operator|=
name|parseEscapedQuery
argument_list|(
name|up
argument_list|,
name|escapeUserQuery
argument_list|(
name|clauses
argument_list|)
argument_list|,
name|config
argument_list|)
expr_stmt|;
block|}
name|query
operator|.
name|add
argument_list|(
name|parsedUserQuery
argument_list|,
name|BooleanClause
operator|.
name|Occur
operator|.
name|MUST
argument_list|)
expr_stmt|;
name|addPhraseFieldQueries
argument_list|(
name|query
argument_list|,
name|clauses
argument_list|,
name|config
argument_list|)
expr_stmt|;
block|}
comment|/* * * Boosting Query * * */
name|boostQueries
operator|=
name|getBoostQueries
argument_list|()
expr_stmt|;
for|for
control|(
name|Query
name|f
range|:
name|boostQueries
control|)
block|{
name|query
operator|.
name|add
argument_list|(
name|f
argument_list|,
name|BooleanClause
operator|.
name|Occur
operator|.
name|SHOULD
argument_list|)
expr_stmt|;
block|}
comment|/* * * Boosting Functions * * */
name|List
argument_list|<
name|Query
argument_list|>
name|boostFunctions
init|=
name|getBoostFunctions
argument_list|()
decl_stmt|;
for|for
control|(
name|Query
name|f
range|:
name|boostFunctions
control|)
block|{
name|query
operator|.
name|add
argument_list|(
name|f
argument_list|,
name|BooleanClause
operator|.
name|Occur
operator|.
name|SHOULD
argument_list|)
expr_stmt|;
block|}
comment|//
comment|// create a boosted query (scores multiplied by boosts)
comment|//
name|Query
name|topQuery
init|=
name|query
decl_stmt|;
name|List
argument_list|<
name|ValueSource
argument_list|>
name|boosts
init|=
name|getMultiplicativeBoosts
argument_list|()
decl_stmt|;
if|if
condition|(
name|boosts
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
name|ValueSource
name|prod
init|=
operator|new
name|ProductFloatFunction
argument_list|(
name|boosts
operator|.
name|toArray
argument_list|(
operator|new
name|ValueSource
index|[
name|boosts
operator|.
name|size
argument_list|()
index|]
argument_list|)
argument_list|)
decl_stmt|;
name|topQuery
operator|=
operator|new
name|BoostedQuery
argument_list|(
name|query
argument_list|,
name|prod
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|boosts
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
name|topQuery
operator|=
operator|new
name|BoostedQuery
argument_list|(
name|query
argument_list|,
name|boosts
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|topQuery
return|;
block|}
comment|/**    * Adds shingled phrase queries to all the fields specified in the pf, pf2 anf pf3 parameters    *     */
DECL|method|addPhraseFieldQueries
specifier|protected
name|void
name|addPhraseFieldQueries
parameter_list|(
name|BooleanQuery
name|query
parameter_list|,
name|List
argument_list|<
name|Clause
argument_list|>
name|clauses
parameter_list|,
name|ExtendedDismaxConfiguration
name|config
parameter_list|)
throws|throws
name|SyntaxError
block|{
comment|// sloppy phrase queries for proximity
name|List
argument_list|<
name|FieldParams
argument_list|>
name|allPhraseFields
init|=
name|config
operator|.
name|getAllPhraseFields
argument_list|()
decl_stmt|;
if|if
condition|(
name|allPhraseFields
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
comment|// find non-field clauses
name|List
argument_list|<
name|Clause
argument_list|>
name|normalClauses
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|clauses
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|Clause
name|clause
range|:
name|clauses
control|)
block|{
if|if
condition|(
name|clause
operator|.
name|field
operator|!=
literal|null
operator|||
name|clause
operator|.
name|isPhrase
condition|)
continue|continue;
comment|// check for keywords "AND,OR,TO"
if|if
condition|(
name|clause
operator|.
name|isBareWord
argument_list|()
condition|)
block|{
name|String
name|s
init|=
name|clause
operator|.
name|val
decl_stmt|;
comment|// avoid putting explicit operators in the phrase query
if|if
condition|(
literal|"OR"
operator|.
name|equals
argument_list|(
name|s
argument_list|)
operator|||
literal|"AND"
operator|.
name|equals
argument_list|(
name|s
argument_list|)
operator|||
literal|"NOT"
operator|.
name|equals
argument_list|(
name|s
argument_list|)
operator|||
literal|"TO"
operator|.
name|equals
argument_list|(
name|s
argument_list|)
condition|)
continue|continue;
block|}
name|normalClauses
operator|.
name|add
argument_list|(
name|clause
argument_list|)
expr_stmt|;
block|}
comment|// create a map of {wordGram, [phraseField]}
name|Multimap
argument_list|<
name|Integer
argument_list|,
name|FieldParams
argument_list|>
name|phraseFieldsByWordGram
init|=
name|Multimaps
operator|.
name|index
argument_list|(
name|allPhraseFields
argument_list|,
name|WORD_GRAM_EXTRACTOR
argument_list|)
decl_stmt|;
comment|// for each {wordGram, [phraseField]} entry, create and add shingled field queries to the main user query
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|Integer
argument_list|,
name|Collection
argument_list|<
name|FieldParams
argument_list|>
argument_list|>
name|phraseFieldsByWordGramEntry
range|:
name|phraseFieldsByWordGram
operator|.
name|asMap
argument_list|()
operator|.
name|entrySet
argument_list|()
control|)
block|{
comment|// group the fields within this wordGram collection by their associated slop (it's possible that the same
comment|// field appears multiple times for the same wordGram count but with different slop values. In this case, we
comment|// should take the *sum* of those phrase queries, rather than the max across them).
name|Multimap
argument_list|<
name|Integer
argument_list|,
name|FieldParams
argument_list|>
name|phraseFieldsBySlop
init|=
name|Multimaps
operator|.
name|index
argument_list|(
name|phraseFieldsByWordGramEntry
operator|.
name|getValue
argument_list|()
argument_list|,
name|PHRASE_SLOP_EXTRACTOR
argument_list|)
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|Integer
argument_list|,
name|Collection
argument_list|<
name|FieldParams
argument_list|>
argument_list|>
name|phraseFieldsBySlopEntry
range|:
name|phraseFieldsBySlop
operator|.
name|asMap
argument_list|()
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|addShingledPhraseQueries
argument_list|(
name|query
argument_list|,
name|normalClauses
argument_list|,
name|phraseFieldsBySlopEntry
operator|.
name|getValue
argument_list|()
argument_list|,
name|phraseFieldsByWordGramEntry
operator|.
name|getKey
argument_list|()
argument_list|,
name|config
operator|.
name|tiebreaker
argument_list|,
name|phraseFieldsBySlopEntry
operator|.
name|getKey
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**    * Creates an instance of ExtendedDismaxConfiguration. It will contain all    * the necessary parameters to parse the query    */
DECL|method|createConfiguration
specifier|protected
name|ExtendedDismaxConfiguration
name|createConfiguration
parameter_list|(
name|String
name|qstr
parameter_list|,
name|SolrParams
name|localParams
parameter_list|,
name|SolrParams
name|params
parameter_list|,
name|SolrQueryRequest
name|req
parameter_list|)
block|{
return|return
operator|new
name|ExtendedDismaxConfiguration
argument_list|(
name|localParams
argument_list|,
name|params
argument_list|,
name|req
argument_list|)
return|;
block|}
comment|/**    * Creates an instance of ExtendedSolrQueryParser, the query parser that's going to be used    * to parse the query.    */
DECL|method|createEdismaxQueryParser
specifier|protected
name|ExtendedSolrQueryParser
name|createEdismaxQueryParser
parameter_list|(
name|QParser
name|qParser
parameter_list|,
name|String
name|field
parameter_list|)
block|{
return|return
operator|new
name|ExtendedSolrQueryParser
argument_list|(
name|qParser
argument_list|,
name|field
argument_list|)
return|;
block|}
comment|/**    * Parses an escaped version of the user's query.  This method is called     * in the event that the original query encounters exceptions during parsing.    *    * @param up parser used    * @param escapedUserQuery query that is parsed, should already be escaped so that no trivial parse errors are encountered    * @param config Configuration options for this parse request    * @return the resulting query (flattened if needed) with "min should match" rules applied as specified in the config.    * @see #parseOriginalQuery    * @see SolrPluginUtils#flattenBooleanQuery    */
DECL|method|parseEscapedQuery
specifier|protected
name|Query
name|parseEscapedQuery
parameter_list|(
name|ExtendedSolrQueryParser
name|up
parameter_list|,
name|String
name|escapedUserQuery
parameter_list|,
name|ExtendedDismaxConfiguration
name|config
parameter_list|)
throws|throws
name|SyntaxError
block|{
name|Query
name|query
init|=
name|up
operator|.
name|parse
argument_list|(
name|escapedUserQuery
argument_list|)
decl_stmt|;
if|if
condition|(
name|query
operator|instanceof
name|BooleanQuery
condition|)
block|{
name|BooleanQuery
name|t
init|=
operator|new
name|BooleanQuery
argument_list|()
decl_stmt|;
name|SolrPluginUtils
operator|.
name|flattenBooleanQuery
argument_list|(
name|t
argument_list|,
operator|(
name|BooleanQuery
operator|)
name|query
argument_list|)
expr_stmt|;
name|SolrPluginUtils
operator|.
name|setMinShouldMatch
argument_list|(
name|t
argument_list|,
name|config
operator|.
name|minShouldMatch
argument_list|)
expr_stmt|;
name|query
operator|=
name|t
expr_stmt|;
block|}
return|return
name|query
return|;
block|}
comment|/**    * Parses the user's original query.  This method attempts to cleanly parse the specified query string using the specified parser, any Exceptions are ignored resulting in null being returned.    *    * @param up parser used    * @param mainUserQuery query string that is parsed    * @param clauses used to dictate "min should match" logic    * @param config Configuration options for this parse request    * @return the resulting query with "min should match" rules applied as specified in the config.    * @see #parseEscapedQuery    */
DECL|method|parseOriginalQuery
specifier|protected
name|Query
name|parseOriginalQuery
parameter_list|(
name|ExtendedSolrQueryParser
name|up
parameter_list|,
name|String
name|mainUserQuery
parameter_list|,
name|List
argument_list|<
name|Clause
argument_list|>
name|clauses
parameter_list|,
name|ExtendedDismaxConfiguration
name|config
parameter_list|)
block|{
name|Query
name|query
init|=
literal|null
decl_stmt|;
try|try
block|{
name|up
operator|.
name|setRemoveStopFilter
argument_list|(
operator|!
name|config
operator|.
name|stopwords
argument_list|)
expr_stmt|;
name|up
operator|.
name|exceptions
operator|=
literal|true
expr_stmt|;
name|query
operator|=
name|up
operator|.
name|parse
argument_list|(
name|mainUserQuery
argument_list|)
expr_stmt|;
if|if
condition|(
name|shouldRemoveStopFilter
argument_list|(
name|config
argument_list|,
name|query
argument_list|)
condition|)
block|{
comment|// if the query was all stop words, remove none of them
name|up
operator|.
name|setRemoveStopFilter
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|query
operator|=
name|up
operator|.
name|parse
argument_list|(
name|mainUserQuery
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
comment|// ignore failure and reparse later after escaping reserved chars
name|up
operator|.
name|exceptions
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
name|query
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
comment|// For correct lucene queries, turn off mm processing if there
comment|// were explicit operators (except for AND).
name|boolean
name|doMinMatched
init|=
name|doMinMatched
argument_list|(
name|clauses
argument_list|,
name|config
operator|.
name|lowercaseOperators
argument_list|)
decl_stmt|;
if|if
condition|(
name|doMinMatched
operator|&&
name|query
operator|instanceof
name|BooleanQuery
condition|)
block|{
name|SolrPluginUtils
operator|.
name|setMinShouldMatch
argument_list|(
operator|(
name|BooleanQuery
operator|)
name|query
argument_list|,
name|config
operator|.
name|minShouldMatch
argument_list|)
expr_stmt|;
block|}
return|return
name|query
return|;
block|}
comment|/**    * Determines if query should be re-parsed removing the stop filter.    * @return true if there are stopwords configured and the parsed query was empty    *         false in any other case.    */
DECL|method|shouldRemoveStopFilter
specifier|protected
name|boolean
name|shouldRemoveStopFilter
parameter_list|(
name|ExtendedDismaxConfiguration
name|config
parameter_list|,
name|Query
name|query
parameter_list|)
block|{
return|return
name|config
operator|.
name|stopwords
operator|&&
name|isEmpty
argument_list|(
name|query
argument_list|)
return|;
block|}
DECL|method|escapeUserQuery
specifier|private
name|String
name|escapeUserQuery
parameter_list|(
name|List
argument_list|<
name|Clause
argument_list|>
name|clauses
parameter_list|)
block|{
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|Clause
name|clause
range|:
name|clauses
control|)
block|{
name|boolean
name|doQuote
init|=
name|clause
operator|.
name|isPhrase
decl_stmt|;
name|String
name|s
init|=
name|clause
operator|.
name|val
decl_stmt|;
if|if
condition|(
operator|!
name|clause
operator|.
name|isPhrase
operator|&&
operator|(
literal|"OR"
operator|.
name|equals
argument_list|(
name|s
argument_list|)
operator|||
literal|"AND"
operator|.
name|equals
argument_list|(
name|s
argument_list|)
operator|||
literal|"NOT"
operator|.
name|equals
argument_list|(
name|s
argument_list|)
operator|)
condition|)
block|{
name|doQuote
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|clause
operator|.
name|must
operator|!=
literal|0
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|clause
operator|.
name|must
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|clause
operator|.
name|field
operator|!=
literal|null
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|clause
operator|.
name|field
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|':'
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|doQuote
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|'"'
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
name|clause
operator|.
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|doQuote
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|'"'
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|clause
operator|.
name|field
operator|!=
literal|null
condition|)
block|{
comment|// Add the default user field boost, if any
name|Float
name|boost
init|=
name|config
operator|.
name|userFields
operator|.
name|getBoost
argument_list|(
name|clause
operator|.
name|field
argument_list|)
decl_stmt|;
if|if
condition|(
name|boost
operator|!=
literal|null
condition|)
name|sb
operator|.
name|append
argument_list|(
literal|"^"
argument_list|)
operator|.
name|append
argument_list|(
name|boost
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**    * Returns false if at least one of the clauses is an explicit operator (except for AND)    */
DECL|method|doMinMatched
specifier|private
name|boolean
name|doMinMatched
parameter_list|(
name|List
argument_list|<
name|Clause
argument_list|>
name|clauses
parameter_list|,
name|boolean
name|lowercaseOperators
parameter_list|)
block|{
for|for
control|(
name|Clause
name|clause
range|:
name|clauses
control|)
block|{
if|if
condition|(
name|clause
operator|.
name|must
operator|==
literal|'+'
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|clause
operator|.
name|must
operator|==
literal|'-'
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|clause
operator|.
name|isBareWord
argument_list|()
condition|)
block|{
name|String
name|s
init|=
name|clause
operator|.
name|val
decl_stmt|;
if|if
condition|(
literal|"OR"
operator|.
name|equals
argument_list|(
name|s
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
elseif|else
if|if
condition|(
literal|"NOT"
operator|.
name|equals
argument_list|(
name|s
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
elseif|else
if|if
condition|(
name|lowercaseOperators
operator|&&
literal|"or"
operator|.
name|equals
argument_list|(
name|s
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
block|}
return|return
literal|true
return|;
block|}
comment|/**    * Generates a query string from the raw clauses, uppercasing     * 'and' and 'or' as needed.    * @param clauses the clauses of the query string to be rebuilt    * @param lowercaseOperators if true, lowercase 'and' and 'or' clauses will     *        be recognized as operators and uppercased in the final query string.    * @return the generated query string.    */
DECL|method|rebuildUserQuery
specifier|protected
name|String
name|rebuildUserQuery
parameter_list|(
name|List
argument_list|<
name|Clause
argument_list|>
name|clauses
parameter_list|,
name|boolean
name|lowercaseOperators
parameter_list|)
block|{
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|clauses
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|Clause
name|clause
init|=
name|clauses
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|String
name|s
init|=
name|clause
operator|.
name|raw
decl_stmt|;
comment|// and and or won't be operators at the start or end
if|if
condition|(
name|lowercaseOperators
operator|&&
name|i
operator|>
literal|0
operator|&&
name|i
operator|+
literal|1
operator|<
name|clauses
operator|.
name|size
argument_list|()
condition|)
block|{
if|if
condition|(
literal|"AND"
operator|.
name|equalsIgnoreCase
argument_list|(
name|s
argument_list|)
condition|)
block|{
name|s
operator|=
literal|"AND"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|"OR"
operator|.
name|equalsIgnoreCase
argument_list|(
name|s
argument_list|)
condition|)
block|{
name|s
operator|=
literal|"OR"
expr_stmt|;
block|}
block|}
name|sb
operator|.
name|append
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**    * Parses all multiplicative boosts    */
DECL|method|getMultiplicativeBoosts
specifier|protected
name|List
argument_list|<
name|ValueSource
argument_list|>
name|getMultiplicativeBoosts
parameter_list|()
throws|throws
name|SyntaxError
block|{
name|List
argument_list|<
name|ValueSource
argument_list|>
name|boosts
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
if|if
condition|(
name|config
operator|.
name|hasMultiplicativeBoosts
argument_list|()
condition|)
block|{
for|for
control|(
name|String
name|boostStr
range|:
name|config
operator|.
name|multBoosts
control|)
block|{
if|if
condition|(
name|boostStr
operator|==
literal|null
operator|||
name|boostStr
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
continue|continue;
name|Query
name|boost
init|=
name|subQuery
argument_list|(
name|boostStr
argument_list|,
name|FunctionQParserPlugin
operator|.
name|NAME
argument_list|)
operator|.
name|getQuery
argument_list|()
decl_stmt|;
name|ValueSource
name|vs
decl_stmt|;
if|if
condition|(
name|boost
operator|instanceof
name|FunctionQuery
condition|)
block|{
name|vs
operator|=
operator|(
operator|(
name|FunctionQuery
operator|)
name|boost
operator|)
operator|.
name|getValueSource
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|vs
operator|=
operator|new
name|QueryValueSource
argument_list|(
name|boost
argument_list|,
literal|1.0f
argument_list|)
expr_stmt|;
block|}
name|boosts
operator|.
name|add
argument_list|(
name|vs
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|boosts
return|;
block|}
comment|/**    * Parses all function queries    */
DECL|method|getBoostFunctions
specifier|protected
name|List
argument_list|<
name|Query
argument_list|>
name|getBoostFunctions
parameter_list|()
throws|throws
name|SyntaxError
block|{
name|List
argument_list|<
name|Query
argument_list|>
name|boostFunctions
init|=
operator|new
name|LinkedList
argument_list|<>
argument_list|()
decl_stmt|;
if|if
condition|(
name|config
operator|.
name|hasBoostFunctions
argument_list|()
condition|)
block|{
for|for
control|(
name|String
name|boostFunc
range|:
name|config
operator|.
name|boostFuncs
control|)
block|{
if|if
condition|(
literal|null
operator|==
name|boostFunc
operator|||
literal|""
operator|.
name|equals
argument_list|(
name|boostFunc
argument_list|)
condition|)
continue|continue;
name|Map
argument_list|<
name|String
argument_list|,
name|Float
argument_list|>
name|ff
init|=
name|SolrPluginUtils
operator|.
name|parseFieldBoosts
argument_list|(
name|boostFunc
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|f
range|:
name|ff
operator|.
name|keySet
argument_list|()
control|)
block|{
name|Query
name|fq
init|=
name|subQuery
argument_list|(
name|f
argument_list|,
name|FunctionQParserPlugin
operator|.
name|NAME
argument_list|)
operator|.
name|getQuery
argument_list|()
decl_stmt|;
name|Float
name|b
init|=
name|ff
operator|.
name|get
argument_list|(
name|f
argument_list|)
decl_stmt|;
if|if
condition|(
literal|null
operator|!=
name|b
condition|)
block|{
name|fq
operator|.
name|setBoost
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
name|boostFunctions
operator|.
name|add
argument_list|(
name|fq
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|boostFunctions
return|;
block|}
comment|/**    * Parses all boost queries    */
DECL|method|getBoostQueries
specifier|protected
name|List
argument_list|<
name|Query
argument_list|>
name|getBoostQueries
parameter_list|()
throws|throws
name|SyntaxError
block|{
name|List
argument_list|<
name|Query
argument_list|>
name|boostQueries
init|=
operator|new
name|LinkedList
argument_list|<>
argument_list|()
decl_stmt|;
if|if
condition|(
name|config
operator|.
name|hasBoostParams
argument_list|()
condition|)
block|{
for|for
control|(
name|String
name|qs
range|:
name|config
operator|.
name|boostParams
control|)
block|{
if|if
condition|(
name|qs
operator|.
name|trim
argument_list|()
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
continue|continue;
name|Query
name|q
init|=
name|subQuery
argument_list|(
name|qs
argument_list|,
literal|null
argument_list|)
operator|.
name|getQuery
argument_list|()
decl_stmt|;
name|boostQueries
operator|.
name|add
argument_list|(
name|q
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|boostQueries
return|;
block|}
comment|/**    * Extracts all the aliased fields from the requests and adds them to up    */
DECL|method|addAliasesFromRequest
specifier|private
name|void
name|addAliasesFromRequest
parameter_list|(
name|ExtendedSolrQueryParser
name|up
parameter_list|,
name|float
name|tiebreaker
parameter_list|)
block|{
name|Iterator
argument_list|<
name|String
argument_list|>
name|it
init|=
name|config
operator|.
name|solrParams
operator|.
name|getParameterNamesIterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|String
name|param
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|param
operator|.
name|startsWith
argument_list|(
literal|"f."
argument_list|)
operator|&&
name|param
operator|.
name|endsWith
argument_list|(
literal|".qf"
argument_list|)
condition|)
block|{
comment|// Add the alias
name|String
name|fname
init|=
name|param
operator|.
name|substring
argument_list|(
literal|2
argument_list|,
name|param
operator|.
name|length
argument_list|()
operator|-
literal|3
argument_list|)
decl_stmt|;
name|String
name|qfReplacement
init|=
name|config
operator|.
name|solrParams
operator|.
name|get
argument_list|(
name|param
argument_list|)
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|Float
argument_list|>
name|parsedQf
init|=
name|SolrPluginUtils
operator|.
name|parseFieldBoosts
argument_list|(
name|qfReplacement
argument_list|)
decl_stmt|;
if|if
condition|(
name|parsedQf
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
return|return;
name|up
operator|.
name|addAlias
argument_list|(
name|fname
argument_list|,
name|tiebreaker
argument_list|,
name|parsedQf
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Modifies the main query by adding a new optional Query consisting    * of shingled phrase queries across the specified clauses using the     * specified field =&gt; boost mappings.    *    * @param mainQuery Where the phrase boosting queries will be added    * @param clauses Clauses that will be used to construct the phrases    * @param fields Field =&gt; boost mappings for the phrase queries    * @param shingleSize how big the phrases should be, 0 means a single phrase    * @param tiebreaker tie breaker value for the DisjunctionMaxQueries    */
DECL|method|addShingledPhraseQueries
specifier|protected
name|void
name|addShingledPhraseQueries
parameter_list|(
specifier|final
name|BooleanQuery
name|mainQuery
parameter_list|,
specifier|final
name|List
argument_list|<
name|Clause
argument_list|>
name|clauses
parameter_list|,
specifier|final
name|Collection
argument_list|<
name|FieldParams
argument_list|>
name|fields
parameter_list|,
name|int
name|shingleSize
parameter_list|,
specifier|final
name|float
name|tiebreaker
parameter_list|,
specifier|final
name|int
name|slop
parameter_list|)
throws|throws
name|SyntaxError
block|{
if|if
condition|(
literal|null
operator|==
name|fields
operator|||
name|fields
operator|.
name|isEmpty
argument_list|()
operator|||
literal|null
operator|==
name|clauses
operator|||
name|clauses
operator|.
name|size
argument_list|()
operator|<
name|shingleSize
condition|)
return|return;
if|if
condition|(
literal|0
operator|==
name|shingleSize
condition|)
name|shingleSize
operator|=
name|clauses
operator|.
name|size
argument_list|()
expr_stmt|;
specifier|final
name|int
name|lastClauseIndex
init|=
name|shingleSize
operator|-
literal|1
decl_stmt|;
name|StringBuilder
name|userPhraseQuery
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|clauses
operator|.
name|size
argument_list|()
operator|-
name|lastClauseIndex
condition|;
name|i
operator|++
control|)
block|{
name|userPhraseQuery
operator|.
name|append
argument_list|(
literal|'"'
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<=
name|lastClauseIndex
condition|;
name|j
operator|++
control|)
block|{
name|userPhraseQuery
operator|.
name|append
argument_list|(
name|clauses
operator|.
name|get
argument_list|(
name|i
operator|+
name|j
argument_list|)
operator|.
name|val
argument_list|)
expr_stmt|;
name|userPhraseQuery
operator|.
name|append
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
name|userPhraseQuery
operator|.
name|append
argument_list|(
literal|'"'
argument_list|)
expr_stmt|;
name|userPhraseQuery
operator|.
name|append
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
comment|/* for parsing sloppy phrases using DisjunctionMaxQueries */
name|ExtendedSolrQueryParser
name|pp
init|=
name|createEdismaxQueryParser
argument_list|(
name|this
argument_list|,
name|IMPOSSIBLE_FIELD_NAME
argument_list|)
decl_stmt|;
name|pp
operator|.
name|addAlias
argument_list|(
name|IMPOSSIBLE_FIELD_NAME
argument_list|,
name|tiebreaker
argument_list|,
name|getFieldBoosts
argument_list|(
name|fields
argument_list|)
argument_list|)
expr_stmt|;
name|pp
operator|.
name|setPhraseSlop
argument_list|(
name|slop
argument_list|)
expr_stmt|;
name|pp
operator|.
name|setRemoveStopFilter
argument_list|(
literal|true
argument_list|)
expr_stmt|;
comment|// remove stop filter and keep stopwords
comment|/* :TODO: reevaluate using makeDismax=true vs false...      *       * The DismaxQueryParser always used DisjunctionMaxQueries for the       * pf boost, for the same reasons it used them for the qf fields.      * When Yonik first wrote the ExtendedDismaxQParserPlugin, he added      * the "makeDismax=false" property to use BooleanQueries instead, but       * when asked why his response was "I honestly don't recall" ...      *      * https://issues.apache.org/jira/browse/SOLR-1553?focusedCommentId=12793813#action_12793813      *      * so for now, we continue to use dismax style queries because it       * seems the most logical and is back compatible, but we should       * try to figure out what Yonik was thinking at the time (because he       * rarely does things for no reason)      */
name|pp
operator|.
name|makeDismax
operator|=
literal|true
expr_stmt|;
comment|// minClauseSize is independent of the shingleSize because of stop words
comment|// (if they are removed from the middle, so be it, but we need at least
comment|// two or there shouldn't be a boost)
name|pp
operator|.
name|minClauseSize
operator|=
literal|2
expr_stmt|;
comment|// TODO: perhaps we shouldn't use synonyms either...
name|Query
name|phrase
init|=
name|pp
operator|.
name|parse
argument_list|(
name|userPhraseQuery
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|phrase
operator|!=
literal|null
condition|)
block|{
name|mainQuery
operator|.
name|add
argument_list|(
name|phrase
argument_list|,
name|BooleanClause
operator|.
name|Occur
operator|.
name|SHOULD
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * @return a {fieldName, fieldBoost} map for the given fields.    */
DECL|method|getFieldBoosts
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|Float
argument_list|>
name|getFieldBoosts
parameter_list|(
name|Collection
argument_list|<
name|FieldParams
argument_list|>
name|fields
parameter_list|)
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|Float
argument_list|>
name|fieldBoostMap
init|=
operator|new
name|LinkedHashMap
argument_list|<>
argument_list|(
name|fields
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|FieldParams
name|field
range|:
name|fields
control|)
block|{
name|fieldBoostMap
operator|.
name|put
argument_list|(
name|field
operator|.
name|getField
argument_list|()
argument_list|,
name|field
operator|.
name|getBoost
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|fieldBoostMap
return|;
block|}
annotation|@
name|Override
DECL|method|getDefaultHighlightFields
specifier|public
name|String
index|[]
name|getDefaultHighlightFields
parameter_list|()
block|{
return|return
name|config
operator|.
name|queryFields
operator|.
name|keySet
argument_list|()
operator|.
name|toArray
argument_list|(
operator|new
name|String
index|[
literal|0
index|]
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|getHighlightQuery
specifier|public
name|Query
name|getHighlightQuery
parameter_list|()
throws|throws
name|SyntaxError
block|{
if|if
condition|(
operator|!
name|parsed
condition|)
name|parse
argument_list|()
expr_stmt|;
return|return
name|parsedUserQuery
operator|==
literal|null
condition|?
name|altUserQuery
else|:
name|parsedUserQuery
return|;
block|}
annotation|@
name|Override
DECL|method|addDebugInfo
specifier|public
name|void
name|addDebugInfo
parameter_list|(
name|NamedList
argument_list|<
name|Object
argument_list|>
name|debugInfo
parameter_list|)
block|{
name|super
operator|.
name|addDebugInfo
argument_list|(
name|debugInfo
argument_list|)
expr_stmt|;
name|debugInfo
operator|.
name|add
argument_list|(
literal|"altquerystring"
argument_list|,
name|altUserQuery
argument_list|)
expr_stmt|;
if|if
condition|(
literal|null
operator|!=
name|boostQueries
condition|)
block|{
name|debugInfo
operator|.
name|add
argument_list|(
literal|"boost_queries"
argument_list|,
name|config
operator|.
name|boostParams
argument_list|)
expr_stmt|;
name|debugInfo
operator|.
name|add
argument_list|(
literal|"parsed_boost_queries"
argument_list|,
name|QueryParsing
operator|.
name|toString
argument_list|(
name|boostQueries
argument_list|,
name|getReq
argument_list|()
operator|.
name|getSchema
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|debugInfo
operator|.
name|add
argument_list|(
literal|"boostfuncs"
argument_list|,
name|getReq
argument_list|()
operator|.
name|getParams
argument_list|()
operator|.
name|getParams
argument_list|(
name|DisMaxParams
operator|.
name|BF
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// FIXME: Not in use
comment|//  public static CharSequence partialEscape(CharSequence s) {
comment|//    StringBuilder sb = new StringBuilder();
comment|//
comment|//    int len = s.length();
comment|//    for (int i = 0; i< len; i++) {
comment|//      char c = s.charAt(i);
comment|//      if (c == ':') {
comment|//        // look forward to make sure it's something that won't
comment|//        // cause a parse exception (something that won't be escaped... like
comment|//        // +,-,:, whitespace
comment|//        if (i+1<len&& i>0) {
comment|//          char ch = s.charAt(i+1);
comment|//          if (!(Character.isWhitespace(ch) || ch=='+' || ch=='-' || ch==':')) {
comment|//            // OK, at this point the chars after the ':' will be fine.
comment|//            // now look back and try to determine if this is a fieldname
comment|//            // [+,-]? [letter,_] [letter digit,_,-,.]*
comment|//            // This won't cover *all* possible lucene fieldnames, but we should
comment|//            // only pick nice names to begin with
comment|//            int start, pos;
comment|//            for (start=i-1; start>=0; start--) {
comment|//              ch = s.charAt(start);
comment|//              if (Character.isWhitespace(ch)) break;
comment|//            }
comment|//
comment|//            // skip whitespace
comment|//            pos = start+1;
comment|//
comment|//            // skip leading + or -
comment|//            ch = s.charAt(pos);
comment|//            if (ch=='+' || ch=='-') {
comment|//              pos++;
comment|//            }
comment|//
comment|//            // we don't need to explicitly check for end of string
comment|//            // since ':' will act as our sentinal
comment|//
comment|//              // first char can't be '-' or '.'
comment|//              ch = s.charAt(pos++);
comment|//              if (Character.isJavaIdentifierPart(ch)) {
comment|//
comment|//                for(;;) {
comment|//                  ch = s.charAt(pos++);
comment|//                  if (!(Character.isJavaIdentifierPart(ch) || ch=='-' || ch=='.')) {
comment|//                    break;
comment|//                  }
comment|//                }
comment|//
comment|//                if (pos<=i) {
comment|//                  // OK, we got to the ':' and everything looked like a valid fieldname, so
comment|//                  // don't escape the ':'
comment|//                  sb.append(':');
comment|//                  continue;  // jump back to start of outer-most loop
comment|//                }
comment|//
comment|//              }
comment|//
comment|//
comment|//          }
comment|//        }
comment|//
comment|//        // we fell through to here, so we should escape this like other reserved chars.
comment|//        sb.append('\\');
comment|//      }
comment|//      else if (c == '\\' || c == '!' || c == '(' || c == ')' ||
comment|//          c == '^' || c == '[' || c == ']' ||
comment|//          c == '{'  || c == '}' || c == '~' || c == '*' || c == '?'
comment|//          )
comment|//      {
comment|//        sb.append('\\');
comment|//      }
comment|//      sb.append(c);
comment|//    }
comment|//    return sb;
comment|//  }
DECL|class|Clause
specifier|protected
specifier|static
class|class
name|Clause
block|{
DECL|method|isBareWord
name|boolean
name|isBareWord
parameter_list|()
block|{
return|return
name|must
operator|==
literal|0
operator|&&
operator|!
name|isPhrase
return|;
block|}
DECL|field|field
specifier|protected
name|String
name|field
decl_stmt|;
DECL|field|rawField
specifier|protected
name|String
name|rawField
decl_stmt|;
comment|// if the clause is +(foo:bar) then rawField=(foo
DECL|field|isPhrase
specifier|protected
name|boolean
name|isPhrase
decl_stmt|;
DECL|field|hasWhitespace
specifier|protected
name|boolean
name|hasWhitespace
decl_stmt|;
DECL|field|hasSpecialSyntax
specifier|protected
name|boolean
name|hasSpecialSyntax
decl_stmt|;
DECL|field|syntaxError
specifier|protected
name|boolean
name|syntaxError
decl_stmt|;
DECL|field|must
specifier|protected
name|char
name|must
decl_stmt|;
comment|// + or -
DECL|field|val
specifier|protected
name|String
name|val
decl_stmt|;
comment|// the field value (minus the field name, +/-, quotes)
DECL|field|raw
specifier|protected
name|String
name|raw
decl_stmt|;
comment|// the raw clause w/o leading/trailing whitespace
block|}
DECL|method|splitIntoClauses
specifier|public
name|List
argument_list|<
name|Clause
argument_list|>
name|splitIntoClauses
parameter_list|(
name|String
name|s
parameter_list|,
name|boolean
name|ignoreQuote
parameter_list|)
block|{
name|ArrayList
argument_list|<
name|Clause
argument_list|>
name|lst
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
literal|4
argument_list|)
decl_stmt|;
name|Clause
name|clause
decl_stmt|;
name|int
name|pos
init|=
literal|0
decl_stmt|;
name|int
name|end
init|=
name|s
operator|.
name|length
argument_list|()
decl_stmt|;
name|char
name|ch
init|=
literal|0
decl_stmt|;
name|int
name|start
decl_stmt|;
name|boolean
name|disallowUserField
decl_stmt|;
while|while
condition|(
name|pos
operator|<
name|end
condition|)
block|{
name|clause
operator|=
operator|new
name|Clause
argument_list|()
expr_stmt|;
name|disallowUserField
operator|=
literal|true
expr_stmt|;
name|ch
operator|=
name|s
operator|.
name|charAt
argument_list|(
name|pos
argument_list|)
expr_stmt|;
while|while
condition|(
name|Character
operator|.
name|isWhitespace
argument_list|(
name|ch
argument_list|)
condition|)
block|{
if|if
condition|(
operator|++
name|pos
operator|>=
name|end
condition|)
break|break;
name|ch
operator|=
name|s
operator|.
name|charAt
argument_list|(
name|pos
argument_list|)
expr_stmt|;
block|}
name|start
operator|=
name|pos
expr_stmt|;
if|if
condition|(
operator|(
name|ch
operator|==
literal|'+'
operator|||
name|ch
operator|==
literal|'-'
operator|)
operator|&&
operator|(
name|pos
operator|+
literal|1
operator|)
operator|<
name|end
condition|)
block|{
name|clause
operator|.
name|must
operator|=
name|ch
expr_stmt|;
name|pos
operator|++
expr_stmt|;
block|}
name|clause
operator|.
name|field
operator|=
name|getFieldName
argument_list|(
name|s
argument_list|,
name|pos
argument_list|,
name|end
argument_list|)
expr_stmt|;
if|if
condition|(
name|clause
operator|.
name|field
operator|!=
literal|null
operator|&&
operator|!
name|config
operator|.
name|userFields
operator|.
name|isAllowed
argument_list|(
name|clause
operator|.
name|field
argument_list|)
condition|)
block|{
name|clause
operator|.
name|field
operator|=
literal|null
expr_stmt|;
block|}
if|if
condition|(
name|clause
operator|.
name|field
operator|!=
literal|null
condition|)
block|{
name|disallowUserField
operator|=
literal|false
expr_stmt|;
name|int
name|colon
init|=
name|s
operator|.
name|indexOf
argument_list|(
literal|':'
argument_list|,
name|pos
argument_list|)
decl_stmt|;
name|clause
operator|.
name|rawField
operator|=
name|s
operator|.
name|substring
argument_list|(
name|pos
argument_list|,
name|colon
argument_list|)
expr_stmt|;
name|pos
operator|+=
name|colon
operator|-
name|pos
expr_stmt|;
comment|// skip the field name
name|pos
operator|++
expr_stmt|;
comment|// skip the ':'
block|}
if|if
condition|(
name|pos
operator|>=
name|end
condition|)
break|break;
name|char
name|inString
init|=
literal|0
decl_stmt|;
name|ch
operator|=
name|s
operator|.
name|charAt
argument_list|(
name|pos
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ignoreQuote
operator|&&
name|ch
operator|==
literal|'"'
condition|)
block|{
name|clause
operator|.
name|isPhrase
operator|=
literal|true
expr_stmt|;
name|inString
operator|=
literal|'"'
expr_stmt|;
name|pos
operator|++
expr_stmt|;
block|}
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
while|while
condition|(
name|pos
operator|<
name|end
condition|)
block|{
name|ch
operator|=
name|s
operator|.
name|charAt
argument_list|(
name|pos
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'\\'
condition|)
block|{
comment|// skip escaped chars, but leave escaped
name|sb
operator|.
name|append
argument_list|(
name|ch
argument_list|)
expr_stmt|;
if|if
condition|(
name|pos
operator|>=
name|end
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|ch
argument_list|)
expr_stmt|;
comment|// double backslash if we are at the end of the string
break|break;
block|}
name|ch
operator|=
name|s
operator|.
name|charAt
argument_list|(
name|pos
operator|++
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|ch
argument_list|)
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|inString
operator|!=
literal|0
operator|&&
name|ch
operator|==
name|inString
condition|)
block|{
name|inString
operator|=
literal|0
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|Character
operator|.
name|isWhitespace
argument_list|(
name|ch
argument_list|)
condition|)
block|{
name|clause
operator|.
name|hasWhitespace
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|inString
operator|==
literal|0
condition|)
block|{
comment|// end of the token if we aren't in a string, backing
comment|// up the position.
name|pos
operator|--
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|inString
operator|==
literal|0
condition|)
block|{
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'!'
case|:
case|case
literal|'('
case|:
case|case
literal|')'
case|:
case|case
literal|':'
case|:
case|case
literal|'^'
case|:
case|case
literal|'['
case|:
case|case
literal|']'
case|:
case|case
literal|'{'
case|:
case|case
literal|'}'
case|:
case|case
literal|'~'
case|:
case|case
literal|'*'
case|:
case|case
literal|'?'
case|:
case|case
literal|'"'
case|:
case|case
literal|'+'
case|:
case|case
literal|'-'
case|:
case|case
literal|'\\'
case|:
case|case
literal|'|'
case|:
case|case
literal|'&'
case|:
case|case
literal|'/'
case|:
name|clause
operator|.
name|hasSpecialSyntax
operator|=
literal|true
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|'\\'
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
literal|'"'
condition|)
block|{
comment|// only char we need to escape in a string is double quote
name|sb
operator|.
name|append
argument_list|(
literal|'\\'
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
name|ch
argument_list|)
expr_stmt|;
block|}
name|clause
operator|.
name|val
operator|=
name|sb
operator|.
name|toString
argument_list|()
expr_stmt|;
if|if
condition|(
name|clause
operator|.
name|isPhrase
condition|)
block|{
if|if
condition|(
name|inString
operator|!=
literal|0
condition|)
block|{
comment|// detected bad quote balancing... retry
comment|// parsing with quotes like any other char
return|return
name|splitIntoClauses
argument_list|(
name|s
argument_list|,
literal|true
argument_list|)
return|;
block|}
comment|// special syntax in a string isn't special
name|clause
operator|.
name|hasSpecialSyntax
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
comment|// an empty clause... must be just a + or - on its own
if|if
condition|(
name|clause
operator|.
name|val
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
block|{
name|clause
operator|.
name|syntaxError
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|clause
operator|.
name|must
operator|!=
literal|0
condition|)
block|{
name|clause
operator|.
name|val
operator|=
literal|"\\"
operator|+
name|clause
operator|.
name|must
expr_stmt|;
name|clause
operator|.
name|must
operator|=
literal|0
expr_stmt|;
name|clause
operator|.
name|hasSpecialSyntax
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
comment|// uh.. this shouldn't happen.
name|clause
operator|=
literal|null
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|clause
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|disallowUserField
condition|)
block|{
name|clause
operator|.
name|raw
operator|=
name|s
operator|.
name|substring
argument_list|(
name|start
argument_list|,
name|pos
argument_list|)
expr_stmt|;
comment|// escape colons, except for "match all" query
if|if
condition|(
operator|!
literal|"*:*"
operator|.
name|equals
argument_list|(
name|clause
operator|.
name|raw
argument_list|)
condition|)
block|{
name|clause
operator|.
name|raw
operator|=
name|clause
operator|.
name|raw
operator|.
name|replaceAll
argument_list|(
literal|"([^\\\\]):"
argument_list|,
literal|"$1\\\\:"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|clause
operator|.
name|raw
operator|=
name|s
operator|.
name|substring
argument_list|(
name|start
argument_list|,
name|pos
argument_list|)
expr_stmt|;
comment|// Add default userField boost if no explicit boost exists
if|if
condition|(
name|config
operator|.
name|userFields
operator|.
name|isAllowed
argument_list|(
name|clause
operator|.
name|field
argument_list|)
operator|&&
operator|!
name|clause
operator|.
name|raw
operator|.
name|contains
argument_list|(
literal|"^"
argument_list|)
condition|)
block|{
name|Float
name|boost
init|=
name|config
operator|.
name|userFields
operator|.
name|getBoost
argument_list|(
name|clause
operator|.
name|field
argument_list|)
decl_stmt|;
if|if
condition|(
name|boost
operator|!=
literal|null
condition|)
name|clause
operator|.
name|raw
operator|+=
literal|"^"
operator|+
name|boost
expr_stmt|;
block|}
block|}
name|lst
operator|.
name|add
argument_list|(
name|clause
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|lst
return|;
block|}
comment|/**     * returns a field name or legal field alias from the current     * position of the string     */
DECL|method|getFieldName
specifier|public
name|String
name|getFieldName
parameter_list|(
name|String
name|s
parameter_list|,
name|int
name|pos
parameter_list|,
name|int
name|end
parameter_list|)
block|{
if|if
condition|(
name|pos
operator|>=
name|end
condition|)
return|return
literal|null
return|;
name|int
name|p
init|=
name|pos
decl_stmt|;
name|int
name|colon
init|=
name|s
operator|.
name|indexOf
argument_list|(
literal|':'
argument_list|,
name|pos
argument_list|)
decl_stmt|;
comment|// make sure there is space after the colon, but not whitespace
if|if
condition|(
name|colon
operator|<=
name|pos
operator|||
name|colon
operator|+
literal|1
operator|>=
name|end
operator|||
name|Character
operator|.
name|isWhitespace
argument_list|(
name|s
operator|.
name|charAt
argument_list|(
name|colon
operator|+
literal|1
argument_list|)
argument_list|)
condition|)
return|return
literal|null
return|;
name|char
name|ch
init|=
name|s
operator|.
name|charAt
argument_list|(
name|p
operator|++
argument_list|)
decl_stmt|;
while|while
condition|(
operator|(
name|ch
operator|==
literal|'('
operator|||
name|ch
operator|==
literal|'+'
operator|||
name|ch
operator|==
literal|'-'
operator|)
operator|&&
operator|(
name|pos
operator|<
name|end
operator|)
condition|)
block|{
name|ch
operator|=
name|s
operator|.
name|charAt
argument_list|(
name|p
operator|++
argument_list|)
expr_stmt|;
name|pos
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|Character
operator|.
name|isJavaIdentifierPart
argument_list|(
name|ch
argument_list|)
condition|)
return|return
literal|null
return|;
while|while
condition|(
name|p
operator|<
name|colon
condition|)
block|{
name|ch
operator|=
name|s
operator|.
name|charAt
argument_list|(
name|p
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|Character
operator|.
name|isJavaIdentifierPart
argument_list|(
name|ch
argument_list|)
operator|||
name|ch
operator|==
literal|'-'
operator|||
name|ch
operator|==
literal|'.'
operator|)
condition|)
return|return
literal|null
return|;
block|}
name|String
name|fname
init|=
name|s
operator|.
name|substring
argument_list|(
name|pos
argument_list|,
name|p
argument_list|)
decl_stmt|;
name|boolean
name|isInSchema
init|=
name|getReq
argument_list|()
operator|.
name|getSchema
argument_list|()
operator|.
name|getFieldTypeNoEx
argument_list|(
name|fname
argument_list|)
operator|!=
literal|null
decl_stmt|;
name|boolean
name|isAlias
init|=
name|config
operator|.
name|solrParams
operator|.
name|get
argument_list|(
literal|"f."
operator|+
name|fname
operator|+
literal|".qf"
argument_list|)
operator|!=
literal|null
decl_stmt|;
name|boolean
name|isMagic
init|=
operator|(
literal|null
operator|!=
name|MagicFieldName
operator|.
name|get
argument_list|(
name|fname
argument_list|)
operator|)
decl_stmt|;
return|return
operator|(
name|isInSchema
operator|||
name|isAlias
operator|||
name|isMagic
operator|)
condition|?
name|fname
else|:
literal|null
return|;
block|}
DECL|method|split
specifier|public
specifier|static
name|List
argument_list|<
name|String
argument_list|>
name|split
parameter_list|(
name|String
name|s
parameter_list|,
name|boolean
name|ignoreQuote
parameter_list|)
block|{
name|ArrayList
argument_list|<
name|String
argument_list|>
name|lst
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
literal|4
argument_list|)
decl_stmt|;
name|int
name|pos
init|=
literal|0
decl_stmt|,
name|start
init|=
literal|0
decl_stmt|,
name|end
init|=
name|s
operator|.
name|length
argument_list|()
decl_stmt|;
name|char
name|inString
init|=
literal|0
decl_stmt|;
name|char
name|ch
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|pos
operator|<
name|end
condition|)
block|{
name|char
name|prevChar
init|=
name|ch
decl_stmt|;
name|ch
operator|=
name|s
operator|.
name|charAt
argument_list|(
name|pos
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'\\'
condition|)
block|{
comment|// skip escaped chars
name|pos
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|inString
operator|!=
literal|0
operator|&&
name|ch
operator|==
name|inString
condition|)
block|{
name|inString
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|ignoreQuote
operator|&&
name|ch
operator|==
literal|'"'
condition|)
block|{
comment|// If char is directly preceeded by a number or letter
comment|// then don't treat it as the start of a string.
if|if
condition|(
operator|!
name|Character
operator|.
name|isLetterOrDigit
argument_list|(
name|prevChar
argument_list|)
condition|)
block|{
name|inString
operator|=
name|ch
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|Character
operator|.
name|isWhitespace
argument_list|(
name|ch
argument_list|)
operator|&&
name|inString
operator|==
literal|0
condition|)
block|{
name|lst
operator|.
name|add
argument_list|(
name|s
operator|.
name|substring
argument_list|(
name|start
argument_list|,
name|pos
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|start
operator|=
name|pos
expr_stmt|;
block|}
block|}
if|if
condition|(
name|start
operator|<
name|end
condition|)
block|{
name|lst
operator|.
name|add
argument_list|(
name|s
operator|.
name|substring
argument_list|(
name|start
argument_list|,
name|end
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|inString
operator|!=
literal|0
condition|)
block|{
comment|// unbalanced quote... ignore them
return|return
name|split
argument_list|(
name|s
argument_list|,
literal|true
argument_list|)
return|;
block|}
return|return
name|lst
return|;
block|}
DECL|enum|QType
enum|enum
name|QType
block|{
DECL|enum constant|FIELD
name|FIELD
block|,
DECL|enum constant|PHRASE
name|PHRASE
block|,
DECL|enum constant|PREFIX
name|PREFIX
block|,
DECL|enum constant|WILDCARD
name|WILDCARD
block|,
DECL|enum constant|FUZZY
name|FUZZY
block|,
DECL|enum constant|RANGE
name|RANGE
block|}
DECL|field|unknownField
specifier|static
specifier|final
name|RuntimeException
name|unknownField
init|=
operator|new
name|RuntimeException
argument_list|(
literal|"UnknownField"
argument_list|)
decl_stmt|;
static|static
block|{
name|unknownField
operator|.
name|fillInStackTrace
argument_list|()
expr_stmt|;
block|}
comment|/**    * A subclass of SolrQueryParser that supports aliasing fields for    * constructing DisjunctionMaxQueries.    */
DECL|class|ExtendedSolrQueryParser
specifier|public
specifier|static
class|class
name|ExtendedSolrQueryParser
extends|extends
name|SolrQueryParser
block|{
comment|/** A simple container for storing alias info      */
DECL|class|Alias
specifier|protected
class|class
name|Alias
block|{
DECL|field|tie
specifier|public
name|float
name|tie
decl_stmt|;
DECL|field|fields
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|Float
argument_list|>
name|fields
decl_stmt|;
block|}
DECL|field|makeDismax
name|boolean
name|makeDismax
init|=
literal|true
decl_stmt|;
DECL|field|disableCoord
name|boolean
name|disableCoord
init|=
literal|true
decl_stmt|;
DECL|field|allowWildcard
name|boolean
name|allowWildcard
init|=
literal|true
decl_stmt|;
DECL|field|minClauseSize
name|int
name|minClauseSize
init|=
literal|0
decl_stmt|;
comment|// minimum number of clauses per phrase query...
comment|// used when constructing boosting part of query via sloppy phrases
DECL|field|exceptions
name|boolean
name|exceptions
decl_stmt|;
comment|//  allow exceptions to be thrown (for example on a missing field)
DECL|field|nonStopFilterAnalyzerPerField
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|Analyzer
argument_list|>
name|nonStopFilterAnalyzerPerField
decl_stmt|;
DECL|field|removeStopFilter
specifier|private
name|boolean
name|removeStopFilter
decl_stmt|;
DECL|field|minShouldMatch
name|String
name|minShouldMatch
decl_stmt|;
comment|// for inner boolean queries produced from a single fieldQuery
comment|/**      * Where we store a map from field name we expect to see in our query      * string, to Alias object containing the fields to use in our      * DisjunctionMaxQuery and the tiebreaker to use.      */
DECL|field|aliases
specifier|protected
name|Map
argument_list|<
name|String
argument_list|,
name|Alias
argument_list|>
name|aliases
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|(
literal|3
argument_list|)
decl_stmt|;
DECL|field|type
specifier|private
name|QType
name|type
decl_stmt|;
DECL|field|field
specifier|private
name|String
name|field
decl_stmt|;
DECL|field|val
specifier|private
name|String
name|val
decl_stmt|;
DECL|field|val2
specifier|private
name|String
name|val2
decl_stmt|;
DECL|field|bool
specifier|private
name|boolean
name|bool
decl_stmt|;
DECL|field|bool2
specifier|private
name|boolean
name|bool2
decl_stmt|;
DECL|field|flt
specifier|private
name|float
name|flt
decl_stmt|;
DECL|field|slop
specifier|private
name|int
name|slop
decl_stmt|;
DECL|method|ExtendedSolrQueryParser
specifier|public
name|ExtendedSolrQueryParser
parameter_list|(
name|QParser
name|parser
parameter_list|,
name|String
name|defaultField
parameter_list|)
block|{
name|super
argument_list|(
name|parser
argument_list|,
name|defaultField
argument_list|)
expr_stmt|;
comment|// don't trust that our parent class won't ever change its default
name|setDefaultOperator
argument_list|(
name|QueryParser
operator|.
name|Operator
operator|.
name|OR
argument_list|)
expr_stmt|;
block|}
DECL|method|setRemoveStopFilter
specifier|public
name|void
name|setRemoveStopFilter
parameter_list|(
name|boolean
name|remove
parameter_list|)
block|{
name|removeStopFilter
operator|=
name|remove
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|getBooleanQuery
specifier|protected
name|Query
name|getBooleanQuery
parameter_list|(
name|List
argument_list|<
name|BooleanClause
argument_list|>
name|clauses
parameter_list|,
name|boolean
name|disableCoord
parameter_list|)
throws|throws
name|SyntaxError
block|{
name|Query
name|q
init|=
name|super
operator|.
name|getBooleanQuery
argument_list|(
name|clauses
argument_list|,
name|disableCoord
argument_list|)
decl_stmt|;
if|if
condition|(
name|q
operator|!=
literal|null
condition|)
block|{
name|q
operator|=
name|QueryUtils
operator|.
name|makeQueryable
argument_list|(
name|q
argument_list|)
expr_stmt|;
block|}
return|return
name|q
return|;
block|}
comment|/**      * Add an alias to this query parser.      *      * @param field the field name that should trigger alias mapping      * @param fieldBoosts the mapping from fieldname to boost value that      *                    should be used to build up the clauses of the      *                    DisjunctionMaxQuery.      * @param tiebreaker to the tiebreaker to be used in the      *                   DisjunctionMaxQuery      * @see SolrPluginUtils#parseFieldBoosts      */
DECL|method|addAlias
specifier|public
name|void
name|addAlias
parameter_list|(
name|String
name|field
parameter_list|,
name|float
name|tiebreaker
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|Float
argument_list|>
name|fieldBoosts
parameter_list|)
block|{
name|Alias
name|a
init|=
operator|new
name|Alias
argument_list|()
decl_stmt|;
name|a
operator|.
name|tie
operator|=
name|tiebreaker
expr_stmt|;
name|a
operator|.
name|fields
operator|=
name|fieldBoosts
expr_stmt|;
name|aliases
operator|.
name|put
argument_list|(
name|field
argument_list|,
name|a
argument_list|)
expr_stmt|;
block|}
comment|/**      * Returns the aliases found for a field.      * Returns null if there are no aliases for the field      * @return Alias      */
DECL|method|getAlias
specifier|protected
name|Alias
name|getAlias
parameter_list|(
name|String
name|field
parameter_list|)
block|{
return|return
name|aliases
operator|.
name|get
argument_list|(
name|field
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|getFieldQuery
specifier|protected
name|Query
name|getFieldQuery
parameter_list|(
name|String
name|field
parameter_list|,
name|String
name|val
parameter_list|,
name|boolean
name|quoted
parameter_list|)
throws|throws
name|SyntaxError
block|{
name|this
operator|.
name|type
operator|=
name|QType
operator|.
name|FIELD
expr_stmt|;
name|this
operator|.
name|field
operator|=
name|field
expr_stmt|;
name|this
operator|.
name|val
operator|=
name|val
expr_stmt|;
name|this
operator|.
name|slop
operator|=
name|getPhraseSlop
argument_list|()
expr_stmt|;
comment|// unspecified
return|return
name|getAliasedQuery
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|getFieldQuery
specifier|protected
name|Query
name|getFieldQuery
parameter_list|(
name|String
name|field
parameter_list|,
name|String
name|val
parameter_list|,
name|int
name|slop
parameter_list|)
throws|throws
name|SyntaxError
block|{
name|this
operator|.
name|type
operator|=
name|QType
operator|.
name|PHRASE
expr_stmt|;
name|this
operator|.
name|field
operator|=
name|field
expr_stmt|;
name|this
operator|.
name|val
operator|=
name|val
expr_stmt|;
name|this
operator|.
name|slop
operator|=
name|slop
expr_stmt|;
return|return
name|getAliasedQuery
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|getPrefixQuery
specifier|protected
name|Query
name|getPrefixQuery
parameter_list|(
name|String
name|field
parameter_list|,
name|String
name|val
parameter_list|)
throws|throws
name|SyntaxError
block|{
if|if
condition|(
name|val
operator|.
name|equals
argument_list|(
literal|""
argument_list|)
operator|&&
name|field
operator|.
name|equals
argument_list|(
literal|"*"
argument_list|)
condition|)
block|{
return|return
operator|new
name|MatchAllDocsQuery
argument_list|()
return|;
block|}
name|this
operator|.
name|type
operator|=
name|QType
operator|.
name|PREFIX
expr_stmt|;
name|this
operator|.
name|field
operator|=
name|field
expr_stmt|;
name|this
operator|.
name|val
operator|=
name|val
expr_stmt|;
return|return
name|getAliasedQuery
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|newFieldQuery
specifier|protected
name|Query
name|newFieldQuery
parameter_list|(
name|Analyzer
name|analyzer
parameter_list|,
name|String
name|field
parameter_list|,
name|String
name|queryText
parameter_list|,
name|boolean
name|quoted
parameter_list|)
throws|throws
name|SyntaxError
block|{
name|Analyzer
name|actualAnalyzer
decl_stmt|;
if|if
condition|(
name|removeStopFilter
condition|)
block|{
if|if
condition|(
name|nonStopFilterAnalyzerPerField
operator|==
literal|null
condition|)
block|{
name|nonStopFilterAnalyzerPerField
operator|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
expr_stmt|;
block|}
name|actualAnalyzer
operator|=
name|nonStopFilterAnalyzerPerField
operator|.
name|get
argument_list|(
name|field
argument_list|)
expr_stmt|;
if|if
condition|(
name|actualAnalyzer
operator|==
literal|null
condition|)
block|{
name|actualAnalyzer
operator|=
name|noStopwordFilterAnalyzer
argument_list|(
name|field
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|actualAnalyzer
operator|=
name|parser
operator|.
name|getReq
argument_list|()
operator|.
name|getSchema
argument_list|()
operator|.
name|getFieldType
argument_list|(
name|field
argument_list|)
operator|.
name|getQueryAnalyzer
argument_list|()
expr_stmt|;
block|}
return|return
name|super
operator|.
name|newFieldQuery
argument_list|(
name|actualAnalyzer
argument_list|,
name|field
argument_list|,
name|queryText
argument_list|,
name|quoted
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|getRangeQuery
specifier|protected
name|Query
name|getRangeQuery
parameter_list|(
name|String
name|field
parameter_list|,
name|String
name|a
parameter_list|,
name|String
name|b
parameter_list|,
name|boolean
name|startInclusive
parameter_list|,
name|boolean
name|endInclusive
parameter_list|)
throws|throws
name|SyntaxError
block|{
name|this
operator|.
name|type
operator|=
name|QType
operator|.
name|RANGE
expr_stmt|;
name|this
operator|.
name|field
operator|=
name|field
expr_stmt|;
name|this
operator|.
name|val
operator|=
name|a
expr_stmt|;
name|this
operator|.
name|val2
operator|=
name|b
expr_stmt|;
name|this
operator|.
name|bool
operator|=
name|startInclusive
expr_stmt|;
name|this
operator|.
name|bool2
operator|=
name|endInclusive
expr_stmt|;
return|return
name|getAliasedQuery
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|getWildcardQuery
specifier|protected
name|Query
name|getWildcardQuery
parameter_list|(
name|String
name|field
parameter_list|,
name|String
name|val
parameter_list|)
throws|throws
name|SyntaxError
block|{
if|if
condition|(
name|val
operator|.
name|equals
argument_list|(
literal|"*"
argument_list|)
condition|)
block|{
if|if
condition|(
name|field
operator|.
name|equals
argument_list|(
literal|"*"
argument_list|)
operator|||
name|getExplicitField
argument_list|()
operator|==
literal|null
condition|)
block|{
return|return
operator|new
name|MatchAllDocsQuery
argument_list|()
return|;
block|}
else|else
block|{
return|return
name|getPrefixQuery
argument_list|(
name|field
argument_list|,
literal|""
argument_list|)
return|;
block|}
block|}
name|this
operator|.
name|type
operator|=
name|QType
operator|.
name|WILDCARD
expr_stmt|;
name|this
operator|.
name|field
operator|=
name|field
expr_stmt|;
name|this
operator|.
name|val
operator|=
name|val
expr_stmt|;
return|return
name|getAliasedQuery
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|getFuzzyQuery
specifier|protected
name|Query
name|getFuzzyQuery
parameter_list|(
name|String
name|field
parameter_list|,
name|String
name|val
parameter_list|,
name|float
name|minSimilarity
parameter_list|)
throws|throws
name|SyntaxError
block|{
name|this
operator|.
name|type
operator|=
name|QType
operator|.
name|FUZZY
expr_stmt|;
name|this
operator|.
name|field
operator|=
name|field
expr_stmt|;
name|this
operator|.
name|val
operator|=
name|val
expr_stmt|;
name|this
operator|.
name|flt
operator|=
name|minSimilarity
expr_stmt|;
return|return
name|getAliasedQuery
argument_list|()
return|;
block|}
comment|/**      * Delegates to the super class unless the field has been specified      * as an alias -- in which case we recurse on each of      * the aliased fields, and the results are composed into a      * DisjunctionMaxQuery.  (so yes: aliases which point at other      * aliases should work)      */
DECL|method|getAliasedQuery
specifier|protected
name|Query
name|getAliasedQuery
parameter_list|()
throws|throws
name|SyntaxError
block|{
name|Alias
name|a
init|=
name|aliases
operator|.
name|get
argument_list|(
name|field
argument_list|)
decl_stmt|;
name|this
operator|.
name|validateCyclicAliasing
argument_list|(
name|field
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
operator|!=
literal|null
condition|)
block|{
name|List
argument_list|<
name|Query
argument_list|>
name|lst
init|=
name|getQueries
argument_list|(
name|a
argument_list|)
decl_stmt|;
if|if
condition|(
name|lst
operator|==
literal|null
operator|||
name|lst
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
return|return
name|getQuery
argument_list|()
return|;
comment|// make a DisjunctionMaxQuery in this case too... it will stop
comment|// the "mm" processing from making everything required in the case
comment|// that the query expanded to multiple clauses.
comment|// DisMaxQuery.rewrite() removes itself if there is just a single clause anyway.
comment|// if (lst.size()==1) return lst.get(0);
if|if
condition|(
name|makeDismax
condition|)
block|{
name|DisjunctionMaxQuery
name|q
init|=
operator|new
name|DisjunctionMaxQuery
argument_list|(
name|lst
argument_list|,
name|a
operator|.
name|tie
argument_list|)
decl_stmt|;
return|return
name|q
return|;
block|}
else|else
block|{
comment|// should we disable coord?
name|BooleanQuery
name|q
init|=
operator|new
name|BooleanQuery
argument_list|(
name|disableCoord
argument_list|)
decl_stmt|;
for|for
control|(
name|Query
name|sub
range|:
name|lst
control|)
block|{
name|q
operator|.
name|add
argument_list|(
name|sub
argument_list|,
name|BooleanClause
operator|.
name|Occur
operator|.
name|SHOULD
argument_list|)
expr_stmt|;
block|}
return|return
name|q
return|;
block|}
block|}
else|else
block|{
comment|// verify that a fielded query is actually on a field that exists... if not,
comment|// then throw an exception to get us out of here, and we'll treat it like a
comment|// literal when we try the escape+re-parse.
if|if
condition|(
name|exceptions
condition|)
block|{
name|FieldType
name|ft
init|=
name|schema
operator|.
name|getFieldTypeNoEx
argument_list|(
name|field
argument_list|)
decl_stmt|;
if|if
condition|(
name|ft
operator|==
literal|null
operator|&&
literal|null
operator|==
name|MagicFieldName
operator|.
name|get
argument_list|(
name|field
argument_list|)
condition|)
block|{
throw|throw
name|unknownField
throw|;
block|}
block|}
return|return
name|getQuery
argument_list|()
return|;
block|}
block|}
comment|/**      * Validate there is no cyclic referencing in the aliasing      */
DECL|method|validateCyclicAliasing
specifier|private
name|void
name|validateCyclicAliasing
parameter_list|(
name|String
name|field
parameter_list|)
throws|throws
name|SyntaxError
block|{
name|Set
argument_list|<
name|String
argument_list|>
name|set
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
name|set
operator|.
name|add
argument_list|(
name|field
argument_list|)
expr_stmt|;
if|if
condition|(
name|validateField
argument_list|(
name|field
argument_list|,
name|set
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|SyntaxError
argument_list|(
literal|"Field aliases lead to a cycle"
argument_list|)
throw|;
block|}
block|}
DECL|method|validateField
specifier|private
name|boolean
name|validateField
parameter_list|(
name|String
name|field
parameter_list|,
name|Set
argument_list|<
name|String
argument_list|>
name|set
parameter_list|)
block|{
if|if
condition|(
name|this
operator|.
name|getAlias
argument_list|(
name|field
argument_list|)
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
name|boolean
name|hascycle
init|=
literal|false
decl_stmt|;
for|for
control|(
name|String
name|referencedField
range|:
name|this
operator|.
name|getAlias
argument_list|(
name|field
argument_list|)
operator|.
name|fields
operator|.
name|keySet
argument_list|()
control|)
block|{
if|if
condition|(
operator|!
name|set
operator|.
name|add
argument_list|(
name|referencedField
argument_list|)
condition|)
block|{
name|hascycle
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|validateField
argument_list|(
name|referencedField
argument_list|,
name|set
argument_list|)
condition|)
block|{
name|hascycle
operator|=
literal|true
expr_stmt|;
block|}
name|set
operator|.
name|remove
argument_list|(
name|referencedField
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|hascycle
return|;
block|}
DECL|method|getQueries
specifier|protected
name|List
argument_list|<
name|Query
argument_list|>
name|getQueries
parameter_list|(
name|Alias
name|a
parameter_list|)
throws|throws
name|SyntaxError
block|{
if|if
condition|(
name|a
operator|==
literal|null
condition|)
return|return
literal|null
return|;
if|if
condition|(
name|a
operator|.
name|fields
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
return|return
literal|null
return|;
name|List
argument_list|<
name|Query
argument_list|>
name|lst
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
literal|4
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|f
range|:
name|a
operator|.
name|fields
operator|.
name|keySet
argument_list|()
control|)
block|{
name|this
operator|.
name|field
operator|=
name|f
expr_stmt|;
name|Query
name|sub
init|=
name|getAliasedQuery
argument_list|()
decl_stmt|;
if|if
condition|(
name|sub
operator|!=
literal|null
condition|)
block|{
name|Float
name|boost
init|=
name|a
operator|.
name|fields
operator|.
name|get
argument_list|(
name|f
argument_list|)
decl_stmt|;
if|if
condition|(
name|boost
operator|!=
literal|null
condition|)
block|{
name|sub
operator|.
name|setBoost
argument_list|(
name|boost
argument_list|)
expr_stmt|;
block|}
name|lst
operator|.
name|add
argument_list|(
name|sub
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|lst
return|;
block|}
DECL|method|getQuery
specifier|private
name|Query
name|getQuery
parameter_list|()
block|{
try|try
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|FIELD
case|:
comment|// fallthrough
case|case
name|PHRASE
case|:
name|Query
name|query
init|=
name|super
operator|.
name|getFieldQuery
argument_list|(
name|field
argument_list|,
name|val
argument_list|,
name|type
operator|==
name|QType
operator|.
name|PHRASE
argument_list|)
decl_stmt|;
comment|// A BooleanQuery is only possible from getFieldQuery if it came from
comment|// a single whitespace separated term. In this case, check the coordination
comment|// factor on the query: if it's enabled, that means we aren't a set of synonyms
comment|// but instead multiple terms from one whitespace-separated term, we must
comment|// apply minShouldMatch here so that it works correctly with other things
comment|// like aliasing.
if|if
condition|(
name|query
operator|instanceof
name|BooleanQuery
condition|)
block|{
name|BooleanQuery
name|bq
init|=
operator|(
name|BooleanQuery
operator|)
name|query
decl_stmt|;
if|if
condition|(
operator|!
name|bq
operator|.
name|isCoordDisabled
argument_list|()
condition|)
block|{
name|SolrPluginUtils
operator|.
name|setMinShouldMatch
argument_list|(
name|bq
argument_list|,
name|minShouldMatch
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|query
operator|instanceof
name|PhraseQuery
condition|)
block|{
name|PhraseQuery
name|pq
init|=
operator|(
name|PhraseQuery
operator|)
name|query
decl_stmt|;
if|if
condition|(
name|minClauseSize
operator|>
literal|1
operator|&&
name|pq
operator|.
name|getTerms
argument_list|()
operator|.
name|length
operator|<
name|minClauseSize
condition|)
return|return
literal|null
return|;
operator|(
operator|(
name|PhraseQuery
operator|)
name|query
operator|)
operator|.
name|setSlop
argument_list|(
name|slop
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|query
operator|instanceof
name|MultiPhraseQuery
condition|)
block|{
name|MultiPhraseQuery
name|pq
init|=
operator|(
name|MultiPhraseQuery
operator|)
name|query
decl_stmt|;
if|if
condition|(
name|minClauseSize
operator|>
literal|1
operator|&&
name|pq
operator|.
name|getTermArrays
argument_list|()
operator|.
name|size
argument_list|()
operator|<
name|minClauseSize
condition|)
return|return
literal|null
return|;
operator|(
operator|(
name|MultiPhraseQuery
operator|)
name|query
operator|)
operator|.
name|setSlop
argument_list|(
name|slop
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|minClauseSize
operator|>
literal|1
condition|)
block|{
comment|// if it's not a type of phrase query, it doesn't meet the minClauseSize requirements
return|return
literal|null
return|;
block|}
return|return
name|query
return|;
case|case
name|PREFIX
case|:
return|return
name|super
operator|.
name|getPrefixQuery
argument_list|(
name|field
argument_list|,
name|val
argument_list|)
return|;
case|case
name|WILDCARD
case|:
return|return
name|super
operator|.
name|getWildcardQuery
argument_list|(
name|field
argument_list|,
name|val
argument_list|)
return|;
case|case
name|FUZZY
case|:
return|return
name|super
operator|.
name|getFuzzyQuery
argument_list|(
name|field
argument_list|,
name|val
argument_list|,
name|flt
argument_list|)
return|;
case|case
name|RANGE
case|:
return|return
name|super
operator|.
name|getRangeQuery
argument_list|(
name|field
argument_list|,
name|val
argument_list|,
name|val2
argument_list|,
name|bool
argument_list|,
name|bool2
argument_list|)
return|;
block|}
return|return
literal|null
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
comment|// an exception here is due to the field query not being compatible with the input text
comment|// for example, passing a string to a numeric field.
return|return
literal|null
return|;
block|}
block|}
DECL|method|noStopwordFilterAnalyzer
specifier|private
name|Analyzer
name|noStopwordFilterAnalyzer
parameter_list|(
name|String
name|fieldName
parameter_list|)
block|{
name|FieldType
name|ft
init|=
name|parser
operator|.
name|getReq
argument_list|()
operator|.
name|getSchema
argument_list|()
operator|.
name|getFieldType
argument_list|(
name|fieldName
argument_list|)
decl_stmt|;
name|Analyzer
name|qa
init|=
name|ft
operator|.
name|getQueryAnalyzer
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|qa
operator|instanceof
name|TokenizerChain
operator|)
condition|)
block|{
return|return
name|qa
return|;
block|}
name|TokenizerChain
name|tcq
init|=
operator|(
name|TokenizerChain
operator|)
name|qa
decl_stmt|;
name|Analyzer
name|ia
init|=
name|ft
operator|.
name|getIndexAnalyzer
argument_list|()
decl_stmt|;
if|if
condition|(
name|ia
operator|==
name|qa
operator|||
operator|!
operator|(
name|ia
operator|instanceof
name|TokenizerChain
operator|)
condition|)
block|{
return|return
name|qa
return|;
block|}
name|TokenizerChain
name|tci
init|=
operator|(
name|TokenizerChain
operator|)
name|ia
decl_stmt|;
comment|// make sure that there isn't a stop filter in the indexer
for|for
control|(
name|TokenFilterFactory
name|tf
range|:
name|tci
operator|.
name|getTokenFilterFactories
argument_list|()
control|)
block|{
if|if
condition|(
name|tf
operator|instanceof
name|StopFilterFactory
condition|)
block|{
return|return
name|qa
return|;
block|}
block|}
comment|// now if there is a stop filter in the query analyzer, remove it
name|int
name|stopIdx
init|=
operator|-
literal|1
decl_stmt|;
name|TokenFilterFactory
index|[]
name|facs
init|=
name|tcq
operator|.
name|getTokenFilterFactories
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|facs
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|TokenFilterFactory
name|tf
init|=
name|facs
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|tf
operator|instanceof
name|StopFilterFactory
condition|)
block|{
name|stopIdx
operator|=
name|i
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|stopIdx
operator|==
operator|-
literal|1
condition|)
block|{
comment|// no stop filter exists
return|return
name|qa
return|;
block|}
name|TokenFilterFactory
index|[]
name|newtf
init|=
operator|new
name|TokenFilterFactory
index|[
name|facs
operator|.
name|length
operator|-
literal|1
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|,
name|j
init|=
literal|0
init|;
name|i
operator|<
name|facs
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|==
name|stopIdx
condition|)
continue|continue;
name|newtf
index|[
name|j
operator|++
index|]
operator|=
name|facs
index|[
name|i
index|]
expr_stmt|;
block|}
name|TokenizerChain
name|newa
init|=
operator|new
name|TokenizerChain
argument_list|(
name|tcq
operator|.
name|getTokenizerFactory
argument_list|()
argument_list|,
name|newtf
argument_list|)
decl_stmt|;
name|newa
operator|.
name|setPositionIncrementGap
argument_list|(
name|tcq
operator|.
name|getPositionIncrementGap
argument_list|(
name|fieldName
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|newa
return|;
block|}
block|}
DECL|method|isEmpty
specifier|static
name|boolean
name|isEmpty
parameter_list|(
name|Query
name|q
parameter_list|)
block|{
if|if
condition|(
name|q
operator|==
literal|null
condition|)
return|return
literal|true
return|;
if|if
condition|(
name|q
operator|instanceof
name|BooleanQuery
operator|&&
operator|(
operator|(
name|BooleanQuery
operator|)
name|q
operator|)
operator|.
name|clauses
argument_list|()
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
return|return
literal|true
return|;
return|return
literal|false
return|;
block|}
comment|/**    * Class that encapsulates the input from userFields parameter and can answer whether    * a field allowed or disallowed as fielded query in the query string    */
DECL|class|UserFields
specifier|static
class|class
name|UserFields
block|{
DECL|field|userFieldsMap
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|Float
argument_list|>
name|userFieldsMap
decl_stmt|;
DECL|field|dynamicUserFields
specifier|private
name|DynamicField
index|[]
name|dynamicUserFields
decl_stmt|;
DECL|field|negativeDynamicUserFields
specifier|private
name|DynamicField
index|[]
name|negativeDynamicUserFields
decl_stmt|;
DECL|method|UserFields
name|UserFields
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|Float
argument_list|>
name|ufm
parameter_list|)
block|{
name|userFieldsMap
operator|=
name|ufm
expr_stmt|;
if|if
condition|(
literal|0
operator|==
name|userFieldsMap
operator|.
name|size
argument_list|()
condition|)
block|{
name|userFieldsMap
operator|.
name|put
argument_list|(
literal|"*"
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|// Process dynamic patterns in userFields
name|ArrayList
argument_list|<
name|DynamicField
argument_list|>
name|dynUserFields
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|DynamicField
argument_list|>
name|negDynUserFields
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|f
range|:
name|userFieldsMap
operator|.
name|keySet
argument_list|()
control|)
block|{
if|if
condition|(
name|f
operator|.
name|contains
argument_list|(
literal|"*"
argument_list|)
condition|)
block|{
if|if
condition|(
name|f
operator|.
name|startsWith
argument_list|(
literal|"-"
argument_list|)
condition|)
name|negDynUserFields
operator|.
name|add
argument_list|(
operator|new
name|DynamicField
argument_list|(
name|f
operator|.
name|substring
argument_list|(
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|dynUserFields
operator|.
name|add
argument_list|(
operator|new
name|DynamicField
argument_list|(
name|f
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|Collections
operator|.
name|sort
argument_list|(
name|dynUserFields
argument_list|)
expr_stmt|;
name|dynamicUserFields
operator|=
name|dynUserFields
operator|.
name|toArray
argument_list|(
operator|new
name|DynamicField
index|[
name|dynUserFields
operator|.
name|size
argument_list|()
index|]
argument_list|)
expr_stmt|;
name|Collections
operator|.
name|sort
argument_list|(
name|negDynUserFields
argument_list|)
expr_stmt|;
name|negativeDynamicUserFields
operator|=
name|negDynUserFields
operator|.
name|toArray
argument_list|(
operator|new
name|DynamicField
index|[
name|negDynUserFields
operator|.
name|size
argument_list|()
index|]
argument_list|)
expr_stmt|;
block|}
comment|/**      * Is the given field name allowed according to UserFields spec given in the uf parameter?      * @param fname the field name to examine      * @return true if the fielded queries are allowed on this field      */
DECL|method|isAllowed
specifier|public
name|boolean
name|isAllowed
parameter_list|(
name|String
name|fname
parameter_list|)
block|{
name|boolean
name|res
init|=
operator|(
operator|(
name|userFieldsMap
operator|.
name|containsKey
argument_list|(
name|fname
argument_list|)
operator|||
name|isDynField
argument_list|(
name|fname
argument_list|,
literal|false
argument_list|)
operator|)
operator|&&
operator|!
name|userFieldsMap
operator|.
name|containsKey
argument_list|(
literal|"-"
operator|+
name|fname
argument_list|)
operator|&&
operator|!
name|isDynField
argument_list|(
name|fname
argument_list|,
literal|true
argument_list|)
operator|)
decl_stmt|;
return|return
name|res
return|;
block|}
DECL|method|isDynField
specifier|private
name|boolean
name|isDynField
parameter_list|(
name|String
name|field
parameter_list|,
name|boolean
name|neg
parameter_list|)
block|{
return|return
name|getDynFieldForName
argument_list|(
name|field
argument_list|,
name|neg
argument_list|)
operator|==
literal|null
condition|?
literal|false
else|:
literal|true
return|;
block|}
DECL|method|getDynFieldForName
specifier|private
name|String
name|getDynFieldForName
parameter_list|(
name|String
name|f
parameter_list|,
name|boolean
name|neg
parameter_list|)
block|{
for|for
control|(
name|DynamicField
name|df
range|:
name|neg
condition|?
name|negativeDynamicUserFields
else|:
name|dynamicUserFields
control|)
block|{
if|if
condition|(
name|df
operator|.
name|matches
argument_list|(
name|f
argument_list|)
condition|)
return|return
name|df
operator|.
name|wildcard
return|;
block|}
return|return
literal|null
return|;
block|}
comment|/**      * Finds the default user field boost associated with the given field.      * This is parsed from the uf parameter, and may be specified as wildcards, e.g. *name^2.0 or *^3.0      * @param field the field to find boost for      * @return the float boost value associated with the given field or a wildcard matching the field      */
DECL|method|getBoost
specifier|public
name|Float
name|getBoost
parameter_list|(
name|String
name|field
parameter_list|)
block|{
return|return
operator|(
name|userFieldsMap
operator|.
name|containsKey
argument_list|(
name|field
argument_list|)
operator|)
condition|?
name|userFieldsMap
operator|.
name|get
argument_list|(
name|field
argument_list|)
else|:
comment|// Exact field
name|userFieldsMap
operator|.
name|get
argument_list|(
name|getDynFieldForName
argument_list|(
name|field
argument_list|,
literal|false
argument_list|)
argument_list|)
return|;
comment|// Dynamic field
block|}
block|}
comment|/* Represents a dynamic field, for easier matching, inspired by same class in IndexSchema */
DECL|class|DynamicField
specifier|static
class|class
name|DynamicField
implements|implements
name|Comparable
argument_list|<
name|DynamicField
argument_list|>
block|{
DECL|field|STARTS_WITH
specifier|final
specifier|static
name|int
name|STARTS_WITH
init|=
literal|1
decl_stmt|;
DECL|field|ENDS_WITH
specifier|final
specifier|static
name|int
name|ENDS_WITH
init|=
literal|2
decl_stmt|;
DECL|field|CATCHALL
specifier|final
specifier|static
name|int
name|CATCHALL
init|=
literal|3
decl_stmt|;
DECL|field|wildcard
specifier|final
name|String
name|wildcard
decl_stmt|;
DECL|field|type
specifier|final
name|int
name|type
decl_stmt|;
DECL|field|str
specifier|final
name|String
name|str
decl_stmt|;
DECL|method|DynamicField
specifier|protected
name|DynamicField
parameter_list|(
name|String
name|wildcard
parameter_list|)
block|{
name|this
operator|.
name|wildcard
operator|=
name|wildcard
expr_stmt|;
if|if
condition|(
name|wildcard
operator|.
name|equals
argument_list|(
literal|"*"
argument_list|)
condition|)
block|{
name|type
operator|=
name|CATCHALL
expr_stmt|;
name|str
operator|=
literal|null
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|wildcard
operator|.
name|startsWith
argument_list|(
literal|"*"
argument_list|)
condition|)
block|{
name|type
operator|=
name|ENDS_WITH
expr_stmt|;
name|str
operator|=
name|wildcard
operator|.
name|substring
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|wildcard
operator|.
name|endsWith
argument_list|(
literal|"*"
argument_list|)
condition|)
block|{
name|type
operator|=
name|STARTS_WITH
expr_stmt|;
name|str
operator|=
name|wildcard
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|wildcard
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"dynamic field name must start or end with *"
argument_list|)
throw|;
block|}
block|}
comment|/*      * Returns true if the regex wildcard for this DynamicField would match the input field name      */
DECL|method|matches
specifier|public
name|boolean
name|matches
parameter_list|(
name|String
name|name
parameter_list|)
block|{
if|if
condition|(
name|type
operator|==
name|CATCHALL
condition|)
return|return
literal|true
return|;
elseif|else
if|if
condition|(
name|type
operator|==
name|STARTS_WITH
operator|&&
name|name
operator|.
name|startsWith
argument_list|(
name|str
argument_list|)
condition|)
return|return
literal|true
return|;
elseif|else
if|if
condition|(
name|type
operator|==
name|ENDS_WITH
operator|&&
name|name
operator|.
name|endsWith
argument_list|(
name|str
argument_list|)
condition|)
return|return
literal|true
return|;
else|else
return|return
literal|false
return|;
block|}
comment|/**      * Sort order is based on length of regex.  Longest comes first.      * @param other The object to compare to.      * @return a negative integer, zero, or a positive integer      * as this object is less than, equal to, or greater than      * the specified object.      */
annotation|@
name|Override
DECL|method|compareTo
specifier|public
name|int
name|compareTo
parameter_list|(
name|DynamicField
name|other
parameter_list|)
block|{
return|return
name|other
operator|.
name|wildcard
operator|.
name|length
argument_list|()
operator|-
name|wildcard
operator|.
name|length
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|this
operator|.
name|wildcard
return|;
block|}
block|}
comment|/**    * Simple container for configuration information used when parsing queries    */
DECL|class|ExtendedDismaxConfiguration
specifier|public
class|class
name|ExtendedDismaxConfiguration
block|{
comment|/**       * The field names specified by 'qf' that (most) clauses will       * be queried against       */
DECL|field|queryFields
specifier|protected
name|Map
argument_list|<
name|String
argument_list|,
name|Float
argument_list|>
name|queryFields
decl_stmt|;
comment|/**       * The field names specified by 'uf' that users are       * allowed to include literally in their query string.  The Float      * boost values will be applied automatically to any clause using that       * field name. '*' will be treated as an alias for any       * field that exists in the schema. Wildcards are allowed to      * express dynamicFields.      */
DECL|field|userFields
specifier|protected
name|UserFields
name|userFields
decl_stmt|;
DECL|field|boostParams
specifier|protected
name|String
index|[]
name|boostParams
decl_stmt|;
DECL|field|multBoosts
specifier|protected
name|String
index|[]
name|multBoosts
decl_stmt|;
DECL|field|solrParams
specifier|protected
name|SolrParams
name|solrParams
decl_stmt|;
DECL|field|minShouldMatch
specifier|protected
name|String
name|minShouldMatch
decl_stmt|;
DECL|field|allPhraseFields
specifier|protected
name|List
argument_list|<
name|FieldParams
argument_list|>
name|allPhraseFields
decl_stmt|;
DECL|field|tiebreaker
specifier|protected
name|float
name|tiebreaker
decl_stmt|;
DECL|field|qslop
specifier|protected
name|int
name|qslop
decl_stmt|;
DECL|field|stopwords
specifier|protected
name|boolean
name|stopwords
decl_stmt|;
DECL|field|altQ
specifier|protected
name|String
name|altQ
decl_stmt|;
DECL|field|lowercaseOperators
specifier|protected
name|boolean
name|lowercaseOperators
decl_stmt|;
DECL|field|boostFuncs
specifier|protected
name|String
index|[]
name|boostFuncs
decl_stmt|;
DECL|method|ExtendedDismaxConfiguration
specifier|public
name|ExtendedDismaxConfiguration
parameter_list|(
name|SolrParams
name|localParams
parameter_list|,
name|SolrParams
name|params
parameter_list|,
name|SolrQueryRequest
name|req
parameter_list|)
block|{
name|solrParams
operator|=
name|SolrParams
operator|.
name|wrapDefaults
argument_list|(
name|localParams
argument_list|,
name|params
argument_list|)
expr_stmt|;
name|minShouldMatch
operator|=
name|DisMaxQParser
operator|.
name|parseMinShouldMatch
argument_list|(
name|req
operator|.
name|getSchema
argument_list|()
argument_list|,
name|solrParams
argument_list|)
expr_stmt|;
comment|// req.getSearcher() here causes searcher refcount imbalance
name|userFields
operator|=
operator|new
name|UserFields
argument_list|(
name|U
operator|.
name|parseFieldBoosts
argument_list|(
name|solrParams
operator|.
name|getParams
argument_list|(
name|DMP
operator|.
name|UF
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
try|try
block|{
name|queryFields
operator|=
name|DisMaxQParser
operator|.
name|parseQueryFields
argument_list|(
name|req
operator|.
name|getSchema
argument_list|()
argument_list|,
name|solrParams
argument_list|)
expr_stmt|;
comment|// req.getSearcher() here causes searcher refcount imbalance
block|}
catch|catch
parameter_list|(
name|SyntaxError
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
comment|// Phrase slop array
name|int
name|pslop
index|[]
init|=
operator|new
name|int
index|[
literal|4
index|]
decl_stmt|;
name|pslop
index|[
literal|0
index|]
operator|=
name|solrParams
operator|.
name|getInt
argument_list|(
name|DisMaxParams
operator|.
name|PS
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pslop
index|[
literal|2
index|]
operator|=
name|solrParams
operator|.
name|getInt
argument_list|(
name|DisMaxParams
operator|.
name|PS2
argument_list|,
name|pslop
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|pslop
index|[
literal|3
index|]
operator|=
name|solrParams
operator|.
name|getInt
argument_list|(
name|DisMaxParams
operator|.
name|PS3
argument_list|,
name|pslop
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|FieldParams
argument_list|>
name|phraseFields
init|=
name|U
operator|.
name|parseFieldBoostsAndSlop
argument_list|(
name|solrParams
operator|.
name|getParams
argument_list|(
name|DMP
operator|.
name|PF
argument_list|)
argument_list|,
literal|0
argument_list|,
name|pslop
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|FieldParams
argument_list|>
name|phraseFields2
init|=
name|U
operator|.
name|parseFieldBoostsAndSlop
argument_list|(
name|solrParams
operator|.
name|getParams
argument_list|(
name|DMP
operator|.
name|PF2
argument_list|)
argument_list|,
literal|2
argument_list|,
name|pslop
index|[
literal|2
index|]
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|FieldParams
argument_list|>
name|phraseFields3
init|=
name|U
operator|.
name|parseFieldBoostsAndSlop
argument_list|(
name|solrParams
operator|.
name|getParams
argument_list|(
name|DMP
operator|.
name|PF3
argument_list|)
argument_list|,
literal|3
argument_list|,
name|pslop
index|[
literal|3
index|]
argument_list|)
decl_stmt|;
name|allPhraseFields
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|phraseFields
operator|.
name|size
argument_list|()
operator|+
name|phraseFields2
operator|.
name|size
argument_list|()
operator|+
name|phraseFields3
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|allPhraseFields
operator|.
name|addAll
argument_list|(
name|phraseFields
argument_list|)
expr_stmt|;
name|allPhraseFields
operator|.
name|addAll
argument_list|(
name|phraseFields2
argument_list|)
expr_stmt|;
name|allPhraseFields
operator|.
name|addAll
argument_list|(
name|phraseFields3
argument_list|)
expr_stmt|;
name|tiebreaker
operator|=
name|solrParams
operator|.
name|getFloat
argument_list|(
name|DisMaxParams
operator|.
name|TIE
argument_list|,
literal|0.0f
argument_list|)
expr_stmt|;
name|qslop
operator|=
name|solrParams
operator|.
name|getInt
argument_list|(
name|DisMaxParams
operator|.
name|QS
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|stopwords
operator|=
name|solrParams
operator|.
name|getBool
argument_list|(
name|DMP
operator|.
name|STOPWORDS
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|altQ
operator|=
name|solrParams
operator|.
name|get
argument_list|(
name|DisMaxParams
operator|.
name|ALTQ
argument_list|)
expr_stmt|;
name|lowercaseOperators
operator|=
name|solrParams
operator|.
name|getBool
argument_list|(
name|DMP
operator|.
name|LOWERCASE_OPS
argument_list|,
literal|true
argument_list|)
expr_stmt|;
comment|/* * * Boosting Query * * */
name|boostParams
operator|=
name|solrParams
operator|.
name|getParams
argument_list|(
name|DisMaxParams
operator|.
name|BQ
argument_list|)
expr_stmt|;
name|boostFuncs
operator|=
name|solrParams
operator|.
name|getParams
argument_list|(
name|DisMaxParams
operator|.
name|BF
argument_list|)
expr_stmt|;
name|multBoosts
operator|=
name|solrParams
operator|.
name|getParams
argument_list|(
name|DMP
operator|.
name|MULT_BOOST
argument_list|)
expr_stmt|;
block|}
comment|/**      *       * @return true if there are valid multiplicative boost queries      */
DECL|method|hasMultiplicativeBoosts
specifier|public
name|boolean
name|hasMultiplicativeBoosts
parameter_list|()
block|{
return|return
name|multBoosts
operator|!=
literal|null
operator|&&
name|multBoosts
operator|.
name|length
operator|>
literal|0
return|;
block|}
comment|/**      *       * @return true if there are valid boost functions      */
DECL|method|hasBoostFunctions
specifier|public
name|boolean
name|hasBoostFunctions
parameter_list|()
block|{
return|return
literal|null
operator|!=
name|boostFuncs
operator|&&
literal|0
operator|!=
name|boostFuncs
operator|.
name|length
return|;
block|}
comment|/**      *       * @return true if there are valid boost params      */
DECL|method|hasBoostParams
specifier|public
name|boolean
name|hasBoostParams
parameter_list|()
block|{
return|return
name|boostParams
operator|!=
literal|null
operator|&&
name|boostParams
operator|.
name|length
operator|>
literal|0
return|;
block|}
DECL|method|getAllPhraseFields
specifier|public
name|List
argument_list|<
name|FieldParams
argument_list|>
name|getAllPhraseFields
parameter_list|()
block|{
return|return
name|allPhraseFields
return|;
block|}
block|}
block|}
end_class
end_unit
