begin_unit
begin_package
DECL|package|org.apache.solr.search.facet
package|package
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|search
operator|.
name|facet
package|;
end_package
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|DocValues
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|LeafReaderContext
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|NumericDocValues
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|Query
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|BitUtil
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|Bits
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|PriorityQueue
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|util
operator|.
name|SimpleOrderedMap
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|schema
operator|.
name|SchemaField
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|search
operator|.
name|DocIterator
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|search
operator|.
name|DocSetCollector
import|;
end_import
begin_class
DECL|class|FacetFieldProcessorNumeric
class|class
name|FacetFieldProcessorNumeric
extends|extends
name|FacetFieldProcessor
block|{
DECL|field|MAXIMUM_STARTING_TABLE_SIZE
specifier|static
name|int
name|MAXIMUM_STARTING_TABLE_SIZE
init|=
literal|1024
decl_stmt|;
comment|// must be a power of two, non-final to support setting by tests
DECL|class|LongCounts
specifier|static
class|class
name|LongCounts
block|{
DECL|field|LOAD_FACTOR
specifier|static
specifier|final
name|float
name|LOAD_FACTOR
init|=
literal|0.7f
decl_stmt|;
DECL|field|numAdds
name|long
name|numAdds
decl_stmt|;
DECL|field|vals
name|long
index|[]
name|vals
decl_stmt|;
DECL|field|counts
name|int
index|[]
name|counts
decl_stmt|;
comment|// maintain the counts here since we need them to tell if there was actually a value anyway
DECL|field|oldToNewMapping
name|int
index|[]
name|oldToNewMapping
decl_stmt|;
DECL|field|cardinality
name|int
name|cardinality
decl_stmt|;
DECL|field|threshold
name|int
name|threshold
decl_stmt|;
comment|/** sz must be a power of two */
DECL|method|LongCounts
name|LongCounts
parameter_list|(
name|int
name|sz
parameter_list|)
block|{
name|vals
operator|=
operator|new
name|long
index|[
name|sz
index|]
expr_stmt|;
name|counts
operator|=
operator|new
name|int
index|[
name|sz
index|]
expr_stmt|;
name|threshold
operator|=
call|(
name|int
call|)
argument_list|(
name|sz
operator|*
name|LOAD_FACTOR
argument_list|)
expr_stmt|;
block|}
comment|/** Current number of slots in the hash table */
DECL|method|numSlots
specifier|public
name|int
name|numSlots
parameter_list|()
block|{
return|return
name|vals
operator|.
name|length
return|;
block|}
DECL|method|hash
specifier|private
name|int
name|hash
parameter_list|(
name|long
name|val
parameter_list|)
block|{
comment|// For floats: exponent bits start at bit 23 for single precision,
comment|// and bit 52 for double precision.
comment|// Many values will only have significant bits just to the right of that,
comment|// and the leftmost bits will all be zero.
comment|// For now, lets just settle to get first 8 significant mantissa bits of double or float in the lowest bits of our hash
comment|// The upper bits of our hash will be irrelevant.
name|int
name|h
init|=
call|(
name|int
call|)
argument_list|(
name|val
operator|+
operator|(
name|val
operator|>>>
literal|44
operator|)
operator|+
operator|(
name|val
operator|>>>
literal|15
operator|)
argument_list|)
decl_stmt|;
return|return
name|h
return|;
block|}
comment|/** returns the slot */
DECL|method|add
name|int
name|add
parameter_list|(
name|long
name|val
parameter_list|)
block|{
if|if
condition|(
name|cardinality
operator|>=
name|threshold
condition|)
block|{
name|rehash
argument_list|()
expr_stmt|;
block|}
name|numAdds
operator|++
expr_stmt|;
name|int
name|h
init|=
name|hash
argument_list|(
name|val
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|slot
init|=
name|h
operator|&
operator|(
name|vals
operator|.
name|length
operator|-
literal|1
operator|)
init|;
condition|;
name|slot
operator|=
operator|(
name|slot
operator|+
operator|(
operator|(
name|h
operator|>>
literal|7
operator|)
operator||
literal|1
operator|)
operator|)
operator|&
operator|(
name|vals
operator|.
name|length
operator|-
literal|1
operator|)
control|)
block|{
name|int
name|count
init|=
name|counts
index|[
name|slot
index|]
decl_stmt|;
if|if
condition|(
name|count
operator|==
literal|0
condition|)
block|{
name|counts
index|[
name|slot
index|]
operator|=
literal|1
expr_stmt|;
name|vals
index|[
name|slot
index|]
operator|=
name|val
expr_stmt|;
name|cardinality
operator|++
expr_stmt|;
return|return
name|slot
return|;
block|}
elseif|else
if|if
condition|(
name|vals
index|[
name|slot
index|]
operator|==
name|val
condition|)
block|{
comment|// val is already in the set
name|counts
index|[
name|slot
index|]
operator|=
name|count
operator|+
literal|1
expr_stmt|;
return|return
name|slot
return|;
block|}
block|}
block|}
DECL|method|rehash
specifier|protected
name|void
name|rehash
parameter_list|()
block|{
name|long
index|[]
name|oldVals
init|=
name|vals
decl_stmt|;
name|int
index|[]
name|oldCounts
init|=
name|counts
decl_stmt|;
comment|// after retrieving the count, this array is reused as a mapping to new array
name|int
name|newCapacity
init|=
name|vals
operator|.
name|length
operator|<<
literal|1
decl_stmt|;
name|vals
operator|=
operator|new
name|long
index|[
name|newCapacity
index|]
expr_stmt|;
name|counts
operator|=
operator|new
name|int
index|[
name|newCapacity
index|]
expr_stmt|;
name|threshold
operator|=
call|(
name|int
call|)
argument_list|(
name|newCapacity
operator|*
name|LOAD_FACTOR
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|oldVals
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|int
name|count
init|=
name|oldCounts
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|count
operator|==
literal|0
condition|)
block|{
name|oldCounts
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
continue|continue;
block|}
name|long
name|val
init|=
name|oldVals
index|[
name|i
index|]
decl_stmt|;
name|int
name|h
init|=
name|hash
argument_list|(
name|val
argument_list|)
decl_stmt|;
name|int
name|slot
init|=
name|h
operator|&
operator|(
name|vals
operator|.
name|length
operator|-
literal|1
operator|)
decl_stmt|;
while|while
condition|(
name|counts
index|[
name|slot
index|]
operator|!=
literal|0
condition|)
block|{
name|slot
operator|=
operator|(
name|slot
operator|+
operator|(
operator|(
name|h
operator|>>
literal|7
operator|)
operator||
literal|1
operator|)
operator|)
operator|&
operator|(
name|vals
operator|.
name|length
operator|-
literal|1
operator|)
expr_stmt|;
block|}
name|counts
index|[
name|slot
index|]
operator|=
name|count
expr_stmt|;
name|vals
index|[
name|slot
index|]
operator|=
name|val
expr_stmt|;
name|oldCounts
index|[
name|i
index|]
operator|=
name|slot
expr_stmt|;
block|}
name|oldToNewMapping
operator|=
name|oldCounts
expr_stmt|;
block|}
DECL|method|cardinality
name|int
name|cardinality
parameter_list|()
block|{
return|return
name|cardinality
return|;
block|}
block|}
DECL|method|FacetFieldProcessorNumeric
name|FacetFieldProcessorNumeric
parameter_list|(
name|FacetContext
name|fcontext
parameter_list|,
name|FacetField
name|freq
parameter_list|,
name|SchemaField
name|sf
parameter_list|)
block|{
name|super
argument_list|(
name|fcontext
argument_list|,
name|freq
argument_list|,
name|sf
argument_list|)
expr_stmt|;
block|}
DECL|field|allBucketsSlot
name|int
name|allBucketsSlot
init|=
operator|-
literal|1
decl_stmt|;
annotation|@
name|Override
DECL|method|process
specifier|public
name|void
name|process
parameter_list|()
throws|throws
name|IOException
block|{
name|super
operator|.
name|process
argument_list|()
expr_stmt|;
name|response
operator|=
name|calcFacets
argument_list|()
expr_stmt|;
block|}
DECL|method|doRehash
specifier|private
name|void
name|doRehash
parameter_list|(
name|LongCounts
name|table
parameter_list|)
block|{
if|if
condition|(
name|collectAcc
operator|==
literal|null
operator|&&
name|allBucketsAcc
operator|==
literal|null
condition|)
return|return;
comment|// Our "count" acc is backed by the hash table and will already be rehashed
comment|// otherAccs don't need to be rehashed
name|int
name|newTableSize
init|=
name|table
operator|.
name|numSlots
argument_list|()
decl_stmt|;
name|int
name|numSlots
init|=
name|newTableSize
decl_stmt|;
specifier|final
name|int
name|oldAllBucketsSlot
init|=
name|allBucketsSlot
decl_stmt|;
if|if
condition|(
name|oldAllBucketsSlot
operator|>=
literal|0
condition|)
block|{
name|allBucketsSlot
operator|=
name|numSlots
operator|++
expr_stmt|;
block|}
specifier|final
name|int
name|finalNumSlots
init|=
name|numSlots
decl_stmt|;
specifier|final
name|int
index|[]
name|mapping
init|=
name|table
operator|.
name|oldToNewMapping
decl_stmt|;
name|SlotAcc
operator|.
name|Resizer
name|resizer
init|=
operator|new
name|SlotAcc
operator|.
name|Resizer
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|int
name|getNewSize
parameter_list|()
block|{
return|return
name|finalNumSlots
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|getNewSlot
parameter_list|(
name|int
name|oldSlot
parameter_list|)
block|{
if|if
condition|(
name|oldSlot
operator|<
name|mapping
operator|.
name|length
condition|)
block|{
return|return
name|mapping
index|[
name|oldSlot
index|]
return|;
block|}
if|if
condition|(
name|oldSlot
operator|==
name|oldAllBucketsSlot
condition|)
block|{
return|return
name|allBucketsSlot
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
block|}
decl_stmt|;
comment|// NOTE: resizing isn't strictly necessary for missing/allBuckets... we could just set the new slot directly
if|if
condition|(
name|collectAcc
operator|!=
literal|null
condition|)
block|{
name|collectAcc
operator|.
name|resize
argument_list|(
name|resizer
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|allBucketsAcc
operator|!=
literal|null
condition|)
block|{
name|allBucketsAcc
operator|.
name|resize
argument_list|(
name|resizer
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|calcFacets
specifier|public
name|SimpleOrderedMap
argument_list|<
name|Object
argument_list|>
name|calcFacets
parameter_list|()
throws|throws
name|IOException
block|{
specifier|final
name|FacetRangeProcessor
operator|.
name|Calc
name|calc
init|=
name|FacetRangeProcessor
operator|.
name|getNumericCalc
argument_list|(
name|sf
argument_list|)
decl_stmt|;
comment|// TODO: it would be really nice to know the number of unique values!!!!
name|int
name|possibleValues
init|=
name|fcontext
operator|.
name|base
operator|.
name|size
argument_list|()
decl_stmt|;
comment|// size smaller tables so that no resize will be necessary
name|int
name|currHashSize
init|=
name|BitUtil
operator|.
name|nextHighestPowerOfTwo
argument_list|(
call|(
name|int
call|)
argument_list|(
name|possibleValues
operator|*
operator|(
literal|1
operator|/
name|LongCounts
operator|.
name|LOAD_FACTOR
operator|)
operator|+
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|currHashSize
operator|=
name|Math
operator|.
name|min
argument_list|(
name|currHashSize
argument_list|,
name|MAXIMUM_STARTING_TABLE_SIZE
argument_list|)
expr_stmt|;
specifier|final
name|LongCounts
name|table
init|=
operator|new
name|LongCounts
argument_list|(
name|currHashSize
argument_list|)
block|{
annotation|@
name|Override
specifier|protected
name|void
name|rehash
parameter_list|()
block|{
name|super
operator|.
name|rehash
argument_list|()
expr_stmt|;
name|doRehash
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|oldToNewMapping
operator|=
literal|null
expr_stmt|;
comment|// allow for gc
block|}
block|}
decl_stmt|;
name|int
name|numSlots
init|=
name|currHashSize
decl_stmt|;
name|int
name|numMissing
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|freq
operator|.
name|allBuckets
condition|)
block|{
name|allBucketsSlot
operator|=
name|numSlots
operator|++
expr_stmt|;
block|}
name|indexOrderAcc
operator|=
operator|new
name|SlotAcc
argument_list|(
name|fcontext
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|void
name|collect
parameter_list|(
name|int
name|doc
parameter_list|,
name|int
name|slot
parameter_list|)
throws|throws
name|IOException
block|{       }
annotation|@
name|Override
specifier|public
name|int
name|compare
parameter_list|(
name|int
name|slotA
parameter_list|,
name|int
name|slotB
parameter_list|)
block|{
name|long
name|s1
init|=
name|calc
operator|.
name|bitsToSortableBits
argument_list|(
name|table
operator|.
name|vals
index|[
name|slotA
index|]
argument_list|)
decl_stmt|;
name|long
name|s2
init|=
name|calc
operator|.
name|bitsToSortableBits
argument_list|(
name|table
operator|.
name|vals
index|[
name|slotB
index|]
argument_list|)
decl_stmt|;
return|return
name|Long
operator|.
name|compare
argument_list|(
name|s1
argument_list|,
name|s2
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|Object
name|getValue
parameter_list|(
name|int
name|slotNum
parameter_list|)
throws|throws
name|IOException
block|{
return|return
literal|null
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|reset
parameter_list|()
block|{       }
annotation|@
name|Override
specifier|public
name|void
name|resize
parameter_list|(
name|Resizer
name|resizer
parameter_list|)
block|{       }
block|}
expr_stmt|;
name|countAcc
operator|=
operator|new
name|CountSlotAcc
argument_list|(
name|fcontext
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|void
name|incrementCount
parameter_list|(
name|int
name|slot
parameter_list|,
name|int
name|count
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|getCount
parameter_list|(
name|int
name|slot
parameter_list|)
block|{
return|return
name|table
operator|.
name|counts
index|[
name|slot
index|]
return|;
block|}
annotation|@
name|Override
specifier|public
name|Object
name|getValue
parameter_list|(
name|int
name|slotNum
parameter_list|)
block|{
return|return
name|getCount
argument_list|(
name|slotNum
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|reset
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|collect
parameter_list|(
name|int
name|doc
parameter_list|,
name|int
name|slot
parameter_list|)
throws|throws
name|IOException
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|compare
parameter_list|(
name|int
name|slotA
parameter_list|,
name|int
name|slotB
parameter_list|)
block|{
return|return
name|Integer
operator|.
name|compare
argument_list|(
name|table
operator|.
name|counts
index|[
name|slotA
index|]
argument_list|,
name|table
operator|.
name|counts
index|[
name|slotB
index|]
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|resize
parameter_list|(
name|Resizer
name|resizer
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
block|}
expr_stmt|;
comment|// we set the countAcc& indexAcc first so generic ones won't be created for us.
name|createCollectAcc
argument_list|(
name|fcontext
operator|.
name|base
operator|.
name|size
argument_list|()
argument_list|,
name|numSlots
argument_list|)
expr_stmt|;
if|if
condition|(
name|freq
operator|.
name|allBuckets
condition|)
block|{
name|allBucketsAcc
operator|=
operator|new
name|SpecialSlotAcc
argument_list|(
name|fcontext
argument_list|,
name|collectAcc
argument_list|,
name|allBucketsSlot
argument_list|,
name|otherAccs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|NumericDocValues
name|values
init|=
literal|null
decl_stmt|;
name|Bits
name|docsWithField
init|=
literal|null
decl_stmt|;
comment|// TODO: factor this code out so it can be shared...
specifier|final
name|List
argument_list|<
name|LeafReaderContext
argument_list|>
name|leaves
init|=
name|fcontext
operator|.
name|searcher
operator|.
name|getIndexReader
argument_list|()
operator|.
name|leaves
argument_list|()
decl_stmt|;
specifier|final
name|Iterator
argument_list|<
name|LeafReaderContext
argument_list|>
name|ctxIt
init|=
name|leaves
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|LeafReaderContext
name|ctx
init|=
literal|null
decl_stmt|;
name|int
name|segBase
init|=
literal|0
decl_stmt|;
name|int
name|segMax
decl_stmt|;
name|int
name|adjustedMax
init|=
literal|0
decl_stmt|;
for|for
control|(
name|DocIterator
name|docsIt
init|=
name|fcontext
operator|.
name|base
operator|.
name|iterator
argument_list|()
init|;
name|docsIt
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
specifier|final
name|int
name|doc
init|=
name|docsIt
operator|.
name|nextDoc
argument_list|()
decl_stmt|;
if|if
condition|(
name|doc
operator|>=
name|adjustedMax
condition|)
block|{
do|do
block|{
name|ctx
operator|=
name|ctxIt
operator|.
name|next
argument_list|()
expr_stmt|;
name|segBase
operator|=
name|ctx
operator|.
name|docBase
expr_stmt|;
name|segMax
operator|=
name|ctx
operator|.
name|reader
argument_list|()
operator|.
name|maxDoc
argument_list|()
expr_stmt|;
name|adjustedMax
operator|=
name|segBase
operator|+
name|segMax
expr_stmt|;
block|}
do|while
condition|(
name|doc
operator|>=
name|adjustedMax
condition|)
do|;
assert|assert
name|doc
operator|>=
name|ctx
operator|.
name|docBase
assert|;
name|setNextReaderFirstPhase
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|values
operator|=
name|DocValues
operator|.
name|getNumeric
argument_list|(
name|ctx
operator|.
name|reader
argument_list|()
argument_list|,
name|sf
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|docsWithField
operator|=
name|DocValues
operator|.
name|getDocsWithField
argument_list|(
name|ctx
operator|.
name|reader
argument_list|()
argument_list|,
name|sf
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|int
name|segDoc
init|=
name|doc
operator|-
name|segBase
decl_stmt|;
name|long
name|val
init|=
name|values
operator|.
name|get
argument_list|(
name|segDoc
argument_list|)
decl_stmt|;
if|if
condition|(
name|val
operator|!=
literal|0
operator|||
name|docsWithField
operator|.
name|get
argument_list|(
name|segDoc
argument_list|)
condition|)
block|{
name|int
name|slot
init|=
name|table
operator|.
name|add
argument_list|(
name|val
argument_list|)
decl_stmt|;
comment|// this can trigger a rehash rehash
comment|// countAcc.incrementCount(slot, 1);
comment|// our countAcc is virtual, so this is not needed
name|collectFirstPhase
argument_list|(
name|segDoc
argument_list|,
name|slot
argument_list|)
expr_stmt|;
block|}
block|}
comment|//
comment|// collection done, time to find the top slots
comment|//
name|int
name|numBuckets
init|=
literal|0
decl_stmt|;
name|List
argument_list|<
name|Object
argument_list|>
name|bucketVals
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|freq
operator|.
name|numBuckets
operator|&&
name|fcontext
operator|.
name|isShard
argument_list|()
condition|)
block|{
name|bucketVals
operator|=
operator|new
name|ArrayList
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
name|int
name|off
init|=
name|fcontext
operator|.
name|isShard
argument_list|()
condition|?
literal|0
else|:
operator|(
name|int
operator|)
name|freq
operator|.
name|offset
decl_stmt|;
comment|// add a modest amount of over-request if this is a shard request
name|int
name|lim
init|=
name|freq
operator|.
name|limit
operator|>=
literal|0
condition|?
operator|(
name|fcontext
operator|.
name|isShard
argument_list|()
condition|?
call|(
name|int
call|)
argument_list|(
name|freq
operator|.
name|limit
operator|*
literal|1.1
operator|+
literal|4
argument_list|)
else|:
operator|(
name|int
operator|)
name|freq
operator|.
name|limit
operator|)
else|:
name|Integer
operator|.
name|MAX_VALUE
decl_stmt|;
name|int
name|maxsize
init|=
call|(
name|int
call|)
argument_list|(
name|freq
operator|.
name|limit
operator|>=
literal|0
condition|?
name|freq
operator|.
name|offset
operator|+
name|lim
else|:
name|Integer
operator|.
name|MAX_VALUE
operator|-
literal|1
argument_list|)
decl_stmt|;
name|maxsize
operator|=
name|Math
operator|.
name|min
argument_list|(
name|maxsize
argument_list|,
name|table
operator|.
name|cardinality
argument_list|)
expr_stmt|;
specifier|final
name|int
name|sortMul
init|=
name|freq
operator|.
name|sortDirection
operator|.
name|getMultiplier
argument_list|()
decl_stmt|;
name|PriorityQueue
argument_list|<
name|Slot
argument_list|>
name|queue
init|=
operator|new
name|PriorityQueue
argument_list|<
name|Slot
argument_list|>
argument_list|(
name|maxsize
argument_list|)
block|{
annotation|@
name|Override
specifier|protected
name|boolean
name|lessThan
parameter_list|(
name|Slot
name|a
parameter_list|,
name|Slot
name|b
parameter_list|)
block|{
comment|// TODO: sort-by-index-order
name|int
name|cmp
init|=
name|sortAcc
operator|.
name|compare
argument_list|(
name|a
operator|.
name|slot
argument_list|,
name|b
operator|.
name|slot
argument_list|)
operator|*
name|sortMul
decl_stmt|;
return|return
name|cmp
operator|==
literal|0
condition|?
operator|(
name|indexOrderAcc
operator|.
name|compare
argument_list|(
name|a
operator|.
name|slot
argument_list|,
name|b
operator|.
name|slot
argument_list|)
operator|>
literal|0
operator|)
else|:
name|cmp
operator|<
literal|0
return|;
block|}
block|}
decl_stmt|;
comment|// TODO: create a countAcc that wrapps the table so we can reuse more code?
name|Slot
name|bottom
init|=
literal|null
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|table
operator|.
name|counts
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|int
name|count
init|=
name|table
operator|.
name|counts
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|count
operator|<
name|effectiveMincount
condition|)
block|{
comment|// either not a valid slot, or count not high enough
continue|continue;
block|}
name|numBuckets
operator|++
expr_stmt|;
comment|// can be different from the table cardinality if mincount> 1
name|long
name|val
init|=
name|table
operator|.
name|vals
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|bucketVals
operator|!=
literal|null
operator|&&
name|bucketVals
operator|.
name|size
argument_list|()
operator|<
literal|100
condition|)
block|{
name|bucketVals
operator|.
name|add
argument_list|(
name|calc
operator|.
name|bitsToValue
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bottom
operator|==
literal|null
condition|)
block|{
name|bottom
operator|=
operator|new
name|Slot
argument_list|()
expr_stmt|;
block|}
name|bottom
operator|.
name|slot
operator|=
name|i
expr_stmt|;
name|bottom
operator|=
name|queue
operator|.
name|insertWithOverflow
argument_list|(
name|bottom
argument_list|)
expr_stmt|;
block|}
name|SimpleOrderedMap
name|res
init|=
operator|new
name|SimpleOrderedMap
argument_list|()
decl_stmt|;
if|if
condition|(
name|freq
operator|.
name|numBuckets
condition|)
block|{
if|if
condition|(
operator|!
name|fcontext
operator|.
name|isShard
argument_list|()
condition|)
block|{
name|res
operator|.
name|add
argument_list|(
literal|"numBuckets"
argument_list|,
name|numBuckets
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SimpleOrderedMap
name|map
init|=
operator|new
name|SimpleOrderedMap
argument_list|(
literal|2
argument_list|)
decl_stmt|;
name|map
operator|.
name|add
argument_list|(
literal|"numBuckets"
argument_list|,
name|numBuckets
argument_list|)
expr_stmt|;
name|map
operator|.
name|add
argument_list|(
literal|"vals"
argument_list|,
name|bucketVals
argument_list|)
expr_stmt|;
name|res
operator|.
name|add
argument_list|(
literal|"numBuckets"
argument_list|,
name|map
argument_list|)
expr_stmt|;
block|}
block|}
name|FacetDebugInfo
name|fdebug
init|=
name|fcontext
operator|.
name|getDebugInfo
argument_list|()
decl_stmt|;
if|if
condition|(
name|fdebug
operator|!=
literal|null
condition|)
name|fdebug
operator|.
name|putInfoItem
argument_list|(
literal|"numBuckets"
argument_list|,
operator|new
name|Long
argument_list|(
name|numBuckets
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|freq
operator|.
name|allBuckets
condition|)
block|{
name|SimpleOrderedMap
argument_list|<
name|Object
argument_list|>
name|allBuckets
init|=
operator|new
name|SimpleOrderedMap
argument_list|<>
argument_list|()
decl_stmt|;
comment|// countAcc.setValues(allBuckets, allBucketsSlot);
name|allBuckets
operator|.
name|add
argument_list|(
literal|"count"
argument_list|,
name|table
operator|.
name|numAdds
argument_list|)
expr_stmt|;
name|allBucketsAcc
operator|.
name|setValues
argument_list|(
name|allBuckets
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|// allBuckets currently doesn't execute sub-facets (because it doesn't change the domain?)
name|res
operator|.
name|add
argument_list|(
literal|"allBuckets"
argument_list|,
name|allBuckets
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|freq
operator|.
name|missing
condition|)
block|{
comment|// TODO: it would be more efficient to buid up a missing DocSet if we need it here anyway.
name|SimpleOrderedMap
argument_list|<
name|Object
argument_list|>
name|missingBucket
init|=
operator|new
name|SimpleOrderedMap
argument_list|<>
argument_list|()
decl_stmt|;
name|fillBucket
argument_list|(
name|missingBucket
argument_list|,
name|getFieldMissingQuery
argument_list|(
name|fcontext
operator|.
name|searcher
argument_list|,
name|freq
operator|.
name|field
argument_list|)
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|res
operator|.
name|add
argument_list|(
literal|"missing"
argument_list|,
name|missingBucket
argument_list|)
expr_stmt|;
block|}
comment|// if we are deep paging, we don't have to order the highest "offset" counts.
name|int
name|collectCount
init|=
name|Math
operator|.
name|max
argument_list|(
literal|0
argument_list|,
name|queue
operator|.
name|size
argument_list|()
operator|-
name|off
argument_list|)
decl_stmt|;
assert|assert
name|collectCount
operator|<=
name|lim
assert|;
name|int
index|[]
name|sortedSlots
init|=
operator|new
name|int
index|[
name|collectCount
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|collectCount
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|sortedSlots
index|[
name|i
index|]
operator|=
name|queue
operator|.
name|pop
argument_list|()
operator|.
name|slot
expr_stmt|;
block|}
name|ArrayList
name|bucketList
init|=
operator|new
name|ArrayList
argument_list|(
name|collectCount
argument_list|)
decl_stmt|;
name|res
operator|.
name|add
argument_list|(
literal|"buckets"
argument_list|,
name|bucketList
argument_list|)
expr_stmt|;
name|boolean
name|needFilter
init|=
name|deferredAggs
operator|!=
literal|null
operator|||
name|freq
operator|.
name|getSubFacets
argument_list|()
operator|.
name|size
argument_list|()
operator|>
literal|0
decl_stmt|;
for|for
control|(
name|int
name|slotNum
range|:
name|sortedSlots
control|)
block|{
name|SimpleOrderedMap
argument_list|<
name|Object
argument_list|>
name|bucket
init|=
operator|new
name|SimpleOrderedMap
argument_list|<>
argument_list|()
decl_stmt|;
name|Comparable
name|val
init|=
name|calc
operator|.
name|bitsToValue
argument_list|(
name|table
operator|.
name|vals
index|[
name|slotNum
index|]
argument_list|)
decl_stmt|;
name|bucket
operator|.
name|add
argument_list|(
literal|"val"
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|Query
name|filter
init|=
name|needFilter
condition|?
name|sf
operator|.
name|getType
argument_list|()
operator|.
name|getFieldQuery
argument_list|(
literal|null
argument_list|,
name|sf
argument_list|,
name|calc
operator|.
name|formatValue
argument_list|(
name|val
argument_list|)
argument_list|)
else|:
literal|null
decl_stmt|;
name|fillBucket
argument_list|(
name|bucket
argument_list|,
name|table
operator|.
name|counts
index|[
name|slotNum
index|]
argument_list|,
name|slotNum
argument_list|,
literal|null
argument_list|,
name|filter
argument_list|)
expr_stmt|;
name|bucketList
operator|.
name|add
argument_list|(
name|bucket
argument_list|)
expr_stmt|;
block|}
return|return
name|res
return|;
block|}
block|}
end_class
end_unit
