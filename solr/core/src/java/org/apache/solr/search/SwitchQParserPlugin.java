begin_unit
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_package
DECL|package|org.apache.solr.search
package|package
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|search
package|;
end_package
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|Query
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|params
operator|.
name|SolrParams
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|util
operator|.
name|NamedList
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|request
operator|.
name|SolrQueryRequest
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|handler
operator|.
name|component
operator|.
name|SearchHandler
import|;
end_import
begin_comment
comment|// jdoc
end_comment
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|lang
operator|.
name|StringUtils
import|;
end_import
begin_comment
comment|/**  *<p>A QParserPlugin that acts like a "switch/case" statement.</p>  *   *<p>  * QParser's produced by this plugin will take their primary input string,   * trimmed and prefixed with "<code>case.</code>", to use as a key to lookup a   * "switch case" in the parser's local params.  If a matching local param is   * found the resulting param value will then be parsed as a subquery, and   * returned as the parse result.  *</p>  *<p>  * The "<code>case</code>" local param can be optionally be specified as a   * switch case to match missing (or blank) input strings.    * The "<code>default</code>" local param can optionally be specified   * as a default case to use if the input string does not match any other   * switch case local params.  If<code>default</code> is not specified,   * then any input which does not match a switch case local param will result   * in a syntax error.  *</p>  *  *<p>  * In the examples below, the result of each query would be<code>XXX</code>....  *</p>  *<pre>  *  q={!switch case.foo=XXX case.bar=zzz case.yak=qqq}foo  *  q={!switch case.foo=qqq case.bar=XXX case.yak=zzz} bar  // extra whitespace  *  q={!switch case.foo=qqq case.bar=zzz default=XXX}asdf   // fallback on default  *  q={!switch case=XXX case.bar=zzz case.yak=qqq}          // blank input  *</pre>  *  *<p>  * A practical usage of this QParsePlugin, is in specifying "appends"   *<code>fq</code> params in the configuration of a {@link SearchHandler}, to   * provide a fixed set of filter options for clients using custom parameter   * names.   * Using the example configuration below, clients can optionally specify the   * custom parameters<code>in_stock</code> and<code>shipping</code> to   * override the default filtering behavior, but are limited to the specific   * set of legal values (<code>shipping=any|free</code>,   *<code>in_stock=yes|no|all</code>).    *</p>  *  *<pre class="prettyprint">  *&lt;requestHandler name="/select" class="solr.SearchHandler"&gt;  *&lt;lst name="defaults"&gt;  *&lt;str name="in_stock"&gt;yes&lt;/str&gt;  *&lt;str name="shipping"&gt;any&lt;/str&gt;  *&lt;/lst&gt;  *&lt;lst name="appends"&gt;  *&lt;str name="fq"&gt;{!switch case.all='*:*'  *                             case.yes='inStock:true'  *                             case.no='inStock:false'  *                             v=$in_stock}&lt;/str&gt;  *&lt;str name="fq"&gt;{!switch case.any='*:*'  *                             case.free='shipping_cost:0.0'  *                             v=$shipping}&lt;/str&gt;  *&lt;/lst&gt;  *&lt;/requestHandler&gt;</pre>  *  *<p>  * A slightly more interesting variant of the<code>shipping</code> example above, would be  * to combine the switch parser with the frange parser, to allow the client to specify an   * arbitrary "max shipping" amount that will be used to build a filter if and only if a   * value is specified.  Example:  *</p>  *<pre class="prettyprint">  *&lt;requestHandler name="/select" class="solr.SearchHandler"&gt;  *&lt;lst name="invariants"&gt;  *&lt;str name="shipping_fq"&gt;{!frange u=$shipping}shipping_cost&lt;/str&gt;  *&lt;/lst&gt;  *&lt;lst name="defaults"&gt;  *&lt;str name="shipping"&gt;any&lt;/str&gt;  *&lt;/lst&gt;  *&lt;lst name="appends"&gt;  *&lt;str name="fq"&gt;{!switch case='*:*'  *                             case.any='*:*'  *                             default=$shipping_fq  *                             v=$shipping}&lt;/str&gt;  *&lt;/lst&gt;  *&lt;/requestHandler&gt;</pre>  *  *<p>  * With the above configuration a client that specifies<code>shipping=any</code>, or   * does not specify a<code>shipping</code> param at all, will not have the results   * filtered.  But if a client specifies a numeric value (ie:<code>shipping=10</code>,   *<code>shipping=5</code>, etc..) then the results will be limited to documents whose   *<code>shipping_cost</code> field has a value less then that number.  *</p>  *  *<p>  * A similar use case would be to combine the switch parser with the bbox parser to   * support an optional geographic filter that is applied if and only if the client   * specifies a<code>location</code> param containing a lat,lon pair to be used as   * the center of the bounding box:  *</p>  *<pre class="prettyprint">  *&lt;requestHandler name="/select" class="solr.SearchHandler"&gt;  *&lt;lst name="invariants"&gt;  *&lt;str name="bbox_fq"&gt;{!bbox pt=$location sfield=geo d=$dist}&lt;/str&gt;  *&lt;/lst&gt;  *&lt;lst name="defaults"&gt;  *&lt;str name="dist"&gt;100&lt;/str&gt;  *&lt;/lst&gt;  *&lt;lst name="appends"&gt;  *&lt;str name="fq"&gt;{!switch case='*:*'   *                             default=$bbox_fq   *                             v=$location}&lt;/str&gt;  *&lt;/lst&gt;  *&lt;/requestHandler&gt;</pre>  */
end_comment
begin_class
DECL|class|SwitchQParserPlugin
specifier|public
class|class
name|SwitchQParserPlugin
extends|extends
name|QParserPlugin
block|{
DECL|field|NAME
specifier|public
specifier|static
specifier|final
name|String
name|NAME
init|=
literal|"switch"
decl_stmt|;
comment|/**     * Used as both a local params key to find the "default" if no    * blank input is provided to the parser, as well as a prefix (followed by     * '.' for looking up the switch input.    */
DECL|field|SWITCH_CASE
specifier|public
specifier|static
name|String
name|SWITCH_CASE
init|=
literal|"case"
decl_stmt|;
comment|/**    * A local param whose value, if specified, is used if no switch case    * matches the parser input.  If this param is not specified, and no     * switch case matches the parser input, an error is returned.    */
DECL|field|SWITCH_DEFAULT
specifier|public
specifier|static
name|String
name|SWITCH_DEFAULT
init|=
literal|"default"
decl_stmt|;
annotation|@
name|Override
DECL|method|createParser
specifier|public
name|QParser
name|createParser
parameter_list|(
name|String
name|qstr
parameter_list|,
name|SolrParams
name|localParams
parameter_list|,
name|SolrParams
name|params
parameter_list|,
name|SolrQueryRequest
name|req
parameter_list|)
block|{
return|return
operator|new
name|QParser
argument_list|(
name|qstr
argument_list|,
name|localParams
argument_list|,
name|params
argument_list|,
name|req
argument_list|)
block|{
name|QParser
name|subParser
decl_stmt|;
annotation|@
name|Override
specifier|public
name|Query
name|parse
parameter_list|()
throws|throws
name|SyntaxError
block|{
name|String
name|val
init|=
name|localParams
operator|.
name|get
argument_list|(
name|QueryParsing
operator|.
name|V
argument_list|)
decl_stmt|;
comment|// we don't want to wrapDefaults arround params, because then
comment|// clients could add their own switch options
name|String
name|subQ
init|=
name|localParams
operator|.
name|get
argument_list|(
name|SWITCH_DEFAULT
argument_list|)
decl_stmt|;
name|subQ
operator|=
name|StringUtils
operator|.
name|isBlank
argument_list|(
name|val
argument_list|)
condition|?
name|localParams
operator|.
name|get
argument_list|(
name|SWITCH_CASE
argument_list|,
name|subQ
argument_list|)
else|:
name|localParams
operator|.
name|get
argument_list|(
name|SWITCH_CASE
operator|+
literal|"."
operator|+
name|val
operator|.
name|trim
argument_list|()
argument_list|,
name|subQ
argument_list|)
expr_stmt|;
if|if
condition|(
literal|null
operator|==
name|subQ
condition|)
block|{
throw|throw
operator|new
name|SyntaxError
argument_list|(
literal|"No "
operator|+
name|SWITCH_DEFAULT
operator|+
literal|", and no switch case matching specified query string: \""
operator|+
name|val
operator|+
literal|"\""
argument_list|)
throw|;
block|}
name|subParser
operator|=
name|subQuery
argument_list|(
name|subQ
argument_list|,
literal|null
argument_list|)
expr_stmt|;
return|return
name|subParser
operator|.
name|getQuery
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
index|[]
name|getDefaultHighlightFields
parameter_list|()
block|{
return|return
name|subParser
operator|.
name|getDefaultHighlightFields
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|Query
name|getHighlightQuery
parameter_list|()
throws|throws
name|SyntaxError
block|{
return|return
name|subParser
operator|.
name|getHighlightQuery
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|addDebugInfo
parameter_list|(
name|NamedList
argument_list|<
name|Object
argument_list|>
name|debugInfo
parameter_list|)
block|{
name|subParser
operator|.
name|addDebugInfo
argument_list|(
name|debugInfo
argument_list|)
expr_stmt|;
block|}
block|}
return|;
block|}
block|}
end_class
end_unit
