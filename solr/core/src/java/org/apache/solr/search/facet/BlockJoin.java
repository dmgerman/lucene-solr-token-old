begin_unit
begin_package
DECL|package|org.apache.solr.search.facet
package|package
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|search
operator|.
name|facet
package|;
end_package
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|DocIdSetIterator
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|FixedBitSet
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|search
operator|.
name|BitDocSet
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|search
operator|.
name|DocIterator
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|search
operator|.
name|DocSet
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|search
operator|.
name|DocSetCollector
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|search
operator|.
name|DocSetUtil
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|search
operator|.
name|QueryContext
import|;
end_import
begin_comment
comment|/** @lucene.experimental */
end_comment
begin_class
DECL|class|BlockJoin
specifier|public
class|class
name|BlockJoin
block|{
comment|/** acceptDocs will normally be used to avoid deleted documents from being generated as part of the answer DocSet (just use *:*)    *  although it can be used to further constrain the generated documents.    */
DECL|method|toChildren
specifier|public
specifier|static
name|DocSet
name|toChildren
parameter_list|(
name|DocSet
name|parentInput
parameter_list|,
name|BitDocSet
name|parentList
parameter_list|,
name|DocSet
name|acceptDocs
parameter_list|,
name|QueryContext
name|qcontext
parameter_list|)
throws|throws
name|IOException
block|{
name|FixedBitSet
name|parentBits
init|=
name|parentList
operator|.
name|getBits
argument_list|()
decl_stmt|;
name|DocSetCollector
name|collector
init|=
operator|new
name|DocSetCollector
argument_list|(
name|qcontext
operator|.
name|searcher
argument_list|()
operator|.
name|maxDoc
argument_list|()
argument_list|)
decl_stmt|;
name|DocIterator
name|iter
init|=
name|parentInput
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|iter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|int
name|parentDoc
init|=
name|iter
operator|.
name|nextDoc
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|parentList
operator|.
name|exists
argument_list|(
name|parentDoc
argument_list|)
operator|||
name|parentDoc
operator|==
literal|0
condition|)
block|{
comment|// test for parentDoc==0 here to avoid passing -1 to prevSetBit later on
comment|// not a parent, or parent has no children
continue|continue;
block|}
name|int
name|prevParent
init|=
name|parentBits
operator|.
name|prevSetBit
argument_list|(
name|parentDoc
operator|-
literal|1
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|childDoc
init|=
name|prevParent
operator|+
literal|1
init|;
name|childDoc
operator|<
name|parentDoc
condition|;
name|childDoc
operator|++
control|)
block|{
if|if
condition|(
name|acceptDocs
operator|!=
literal|null
operator|&&
operator|!
name|acceptDocs
operator|.
name|exists
argument_list|(
name|childDoc
argument_list|)
condition|)
continue|continue;
comment|// only select live docs
name|collector
operator|.
name|collect
argument_list|(
name|childDoc
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|collector
operator|.
name|getDocSet
argument_list|()
return|;
block|}
comment|/** childInput may also contain parents (i.e. a parent or below will all roll up to that parent) */
DECL|method|toParents
specifier|public
specifier|static
name|DocSet
name|toParents
parameter_list|(
name|DocSet
name|childInput
parameter_list|,
name|BitDocSet
name|parentList
parameter_list|,
name|QueryContext
name|qcontext
parameter_list|)
throws|throws
name|IOException
block|{
name|FixedBitSet
name|parentBits
init|=
name|parentList
operator|.
name|getBits
argument_list|()
decl_stmt|;
name|DocSetCollector
name|collector
init|=
operator|new
name|DocSetCollector
argument_list|(
name|qcontext
operator|.
name|searcher
argument_list|()
operator|.
name|maxDoc
argument_list|()
argument_list|)
decl_stmt|;
name|DocIterator
name|iter
init|=
name|childInput
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|int
name|currentParent
init|=
operator|-
literal|1
decl_stmt|;
while|while
condition|(
name|iter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|int
name|childDoc
init|=
name|iter
operator|.
name|nextDoc
argument_list|()
decl_stmt|;
comment|// TODO: skipping
if|if
condition|(
name|childDoc
operator|<=
name|currentParent
condition|)
block|{
comment|// use<= since we also allow parents in the input
comment|// we already visited this parent
continue|continue;
block|}
name|currentParent
operator|=
name|parentBits
operator|.
name|nextSetBit
argument_list|(
name|childDoc
argument_list|)
expr_stmt|;
if|if
condition|(
name|currentParent
operator|!=
name|DocIdSetIterator
operator|.
name|NO_MORE_DOCS
condition|)
block|{
comment|// only collect the parent the first time we skip to it
name|collector
operator|.
name|collect
argument_list|(
name|currentParent
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|collector
operator|.
name|getDocSet
argument_list|()
return|;
block|}
block|}
end_class
end_unit
