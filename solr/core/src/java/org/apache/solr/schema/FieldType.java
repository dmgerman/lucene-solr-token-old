begin_unit
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_package
DECL|package|org.apache.solr.schema
package|package
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|schema
package|;
end_package
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|invoke
operator|.
name|MethodHandles
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Locale
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|Analyzer
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|Tokenizer
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|tokenattributes
operator|.
name|CharTermAttribute
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|tokenattributes
operator|.
name|OffsetAttribute
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|util
operator|.
name|CharFilterFactory
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|util
operator|.
name|TokenFilterFactory
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|util
operator|.
name|TokenizerFactory
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|document
operator|.
name|Field
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|IndexOptions
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|StorableField
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|Term
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|queries
operator|.
name|function
operator|.
name|ValueSource
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|DocValuesRangeQuery
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|DocValuesRewriteMethod
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|MultiTermQuery
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|PrefixQuery
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|Query
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|SortField
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|SortedNumericSelector
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|SortedSetSelector
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|TermQuery
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|similarities
operator|.
name|Similarity
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|uninverting
operator|.
name|UninvertingReader
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|BytesRef
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|BytesRefBuilder
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|CharsRef
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|CharsRefBuilder
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|Version
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|analysis
operator|.
name|SolrAnalyzer
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|analysis
operator|.
name|TokenizerChain
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|SolrException
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|SolrException
operator|.
name|ErrorCode
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|util
operator|.
name|Base64
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|util
operator|.
name|SimpleOrderedMap
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|util
operator|.
name|StrUtils
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|query
operator|.
name|SolrRangeQuery
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|response
operator|.
name|TextResponseWriter
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|search
operator|.
name|QParser
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|search
operator|.
name|Sorting
import|;
end_import
begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import
begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import
begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|util
operator|.
name|AbstractAnalysisFactory
operator|.
name|LUCENE_MATCH_VERSION_PARAM
import|;
end_import
begin_comment
comment|/**  * Base class for all field types used by an index schema.  *  *  */
end_comment
begin_class
DECL|class|FieldType
specifier|public
specifier|abstract
class|class
name|FieldType
extends|extends
name|FieldProperties
block|{
DECL|field|log
specifier|private
specifier|static
specifier|final
name|Logger
name|log
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|MethodHandles
operator|.
name|lookup
argument_list|()
operator|.
name|lookupClass
argument_list|()
argument_list|)
decl_stmt|;
comment|/**    * The default poly field separator.    *    * @see #createFields(SchemaField, Object, float)    * @see #isPolyField()    */
DECL|field|POLY_FIELD_SEPARATOR
specifier|public
specifier|static
specifier|final
name|String
name|POLY_FIELD_SEPARATOR
init|=
literal|"___"
decl_stmt|;
comment|/** The name of the type (not the name of the field) */
DECL|field|typeName
specifier|protected
name|String
name|typeName
decl_stmt|;
comment|/** additional arguments specified in the field type declaration */
DECL|field|args
specifier|protected
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|args
decl_stmt|;
comment|/** properties explicitly set to true */
DECL|field|trueProperties
specifier|protected
name|int
name|trueProperties
decl_stmt|;
comment|/** properties explicitly set to false */
DECL|field|falseProperties
specifier|protected
name|int
name|falseProperties
decl_stmt|;
DECL|field|properties
specifier|protected
name|int
name|properties
decl_stmt|;
DECL|field|isExplicitQueryAnalyzer
specifier|private
name|boolean
name|isExplicitQueryAnalyzer
decl_stmt|;
DECL|field|isExplicitAnalyzer
specifier|private
name|boolean
name|isExplicitAnalyzer
decl_stmt|;
comment|/** Returns true if fields of this type should be tokenized */
DECL|method|isTokenized
specifier|public
name|boolean
name|isTokenized
parameter_list|()
block|{
return|return
operator|(
name|properties
operator|&
name|TOKENIZED
operator|)
operator|!=
literal|0
return|;
block|}
comment|/** Returns true if fields can have multiple values */
DECL|method|isMultiValued
specifier|public
name|boolean
name|isMultiValued
parameter_list|()
block|{
return|return
operator|(
name|properties
operator|&
name|MULTIVALUED
operator|)
operator|!=
literal|0
return|;
block|}
comment|/** Check if a property is set */
DECL|method|hasProperty
specifier|protected
name|boolean
name|hasProperty
parameter_list|(
name|int
name|p
parameter_list|)
block|{
return|return
operator|(
name|properties
operator|&
name|p
operator|)
operator|!=
literal|0
return|;
block|}
comment|/**    * A "polyField" is a FieldType that can produce more than one IndexableField instance for a single value, via the {@link #createFields(org.apache.solr.schema.SchemaField, Object, float)} method.  This is useful    * when hiding the implementation details of a field from the Solr end user.  For instance, a spatial point may be represented by multiple different fields.    * @return true if the {@link #createFields(org.apache.solr.schema.SchemaField, Object, float)} method may return more than one field    */
DECL|method|isPolyField
specifier|public
name|boolean
name|isPolyField
parameter_list|()
block|{
return|return
literal|false
return|;
block|}
comment|/**    * Returns true if the fields' docValues should be used for obtaining stored value    */
DECL|method|useDocValuesAsStored
specifier|public
name|boolean
name|useDocValuesAsStored
parameter_list|()
block|{
return|return
operator|(
name|properties
operator|&
name|USE_DOCVALUES_AS_STORED
operator|)
operator|!=
literal|0
return|;
block|}
comment|/** Returns true if a single field value of this type has multiple logical values    *  for the purposes of faceting, sorting, etc.  Text fields normally return    *  true since each token/word is a logical value.    */
DECL|method|multiValuedFieldCache
specifier|public
name|boolean
name|multiValuedFieldCache
parameter_list|()
block|{
return|return
name|isTokenized
argument_list|()
return|;
block|}
comment|/** subclasses should initialize themselves with the args provided    * and remove valid arguments.  leftover arguments will cause an exception.    * Common boolean properties have already been handled.    *    */
DECL|method|init
specifier|protected
name|void
name|init
parameter_list|(
name|IndexSchema
name|schema
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|args
parameter_list|)
block|{    }
comment|// Handle additional arguments...
DECL|method|setArgs
specifier|protected
name|void
name|setArgs
parameter_list|(
name|IndexSchema
name|schema
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|args
parameter_list|)
block|{
comment|// default to STORED, INDEXED, OMIT_TF_POSITIONS and MULTIVALUED depending on schema version
name|properties
operator|=
operator|(
name|STORED
operator||
name|INDEXED
operator|)
expr_stmt|;
name|float
name|schemaVersion
init|=
name|schema
operator|.
name|getVersion
argument_list|()
decl_stmt|;
if|if
condition|(
name|schemaVersion
operator|<
literal|1.1f
condition|)
name|properties
operator||=
name|MULTIVALUED
expr_stmt|;
if|if
condition|(
name|schemaVersion
operator|>
literal|1.1f
condition|)
name|properties
operator||=
name|OMIT_TF_POSITIONS
expr_stmt|;
if|if
condition|(
name|schemaVersion
operator|<
literal|1.3
condition|)
block|{
name|args
operator|.
name|remove
argument_list|(
literal|"compressThreshold"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|schemaVersion
operator|>=
literal|1.6f
condition|)
name|properties
operator||=
name|USE_DOCVALUES_AS_STORED
expr_stmt|;
name|this
operator|.
name|args
operator|=
name|Collections
operator|.
name|unmodifiableMap
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|initArgs
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|(
name|args
argument_list|)
decl_stmt|;
name|initArgs
operator|.
name|remove
argument_list|(
name|CLASS_NAME
argument_list|)
expr_stmt|;
comment|// consume the class arg
name|trueProperties
operator|=
name|FieldProperties
operator|.
name|parseProperties
argument_list|(
name|initArgs
argument_list|,
literal|true
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|falseProperties
operator|=
name|FieldProperties
operator|.
name|parseProperties
argument_list|(
name|initArgs
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|properties
operator|&=
operator|~
name|falseProperties
expr_stmt|;
name|properties
operator||=
name|trueProperties
expr_stmt|;
for|for
control|(
name|String
name|prop
range|:
name|FieldProperties
operator|.
name|propertyNames
control|)
name|initArgs
operator|.
name|remove
argument_list|(
name|prop
argument_list|)
expr_stmt|;
name|init
argument_list|(
name|schema
argument_list|,
name|initArgs
argument_list|)
expr_stmt|;
name|String
name|positionInc
init|=
name|initArgs
operator|.
name|get
argument_list|(
name|POSITION_INCREMENT_GAP
argument_list|)
decl_stmt|;
if|if
condition|(
name|positionInc
operator|!=
literal|null
condition|)
block|{
name|Analyzer
name|analyzer
init|=
name|getIndexAnalyzer
argument_list|()
decl_stmt|;
if|if
condition|(
name|analyzer
operator|instanceof
name|SolrAnalyzer
condition|)
block|{
operator|(
operator|(
name|SolrAnalyzer
operator|)
name|analyzer
operator|)
operator|.
name|setPositionIncrementGap
argument_list|(
name|Integer
operator|.
name|parseInt
argument_list|(
name|positionInc
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Can't set "
operator|+
name|POSITION_INCREMENT_GAP
operator|+
literal|" on custom analyzer "
operator|+
name|analyzer
operator|.
name|getClass
argument_list|()
argument_list|)
throw|;
block|}
name|analyzer
operator|=
name|getQueryAnalyzer
argument_list|()
expr_stmt|;
if|if
condition|(
name|analyzer
operator|instanceof
name|SolrAnalyzer
condition|)
block|{
operator|(
operator|(
name|SolrAnalyzer
operator|)
name|analyzer
operator|)
operator|.
name|setPositionIncrementGap
argument_list|(
name|Integer
operator|.
name|parseInt
argument_list|(
name|positionInc
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Can't set "
operator|+
name|POSITION_INCREMENT_GAP
operator|+
literal|" on custom analyzer "
operator|+
name|analyzer
operator|.
name|getClass
argument_list|()
argument_list|)
throw|;
block|}
name|initArgs
operator|.
name|remove
argument_list|(
name|POSITION_INCREMENT_GAP
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|postingsFormat
operator|=
name|initArgs
operator|.
name|remove
argument_list|(
name|POSTINGS_FORMAT
argument_list|)
expr_stmt|;
name|this
operator|.
name|docValuesFormat
operator|=
name|initArgs
operator|.
name|remove
argument_list|(
name|DOC_VALUES_FORMAT
argument_list|)
expr_stmt|;
if|if
condition|(
name|initArgs
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"schema fieldtype "
operator|+
name|typeName
operator|+
literal|"("
operator|+
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|")"
operator|+
literal|" invalid arguments:"
operator|+
name|initArgs
argument_list|)
throw|;
block|}
block|}
comment|/** :TODO: document this method */
DECL|method|restrictProps
specifier|protected
name|void
name|restrictProps
parameter_list|(
name|int
name|props
parameter_list|)
block|{
if|if
condition|(
operator|(
name|properties
operator|&
name|props
operator|)
operator|!=
literal|0
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"schema fieldtype "
operator|+
name|typeName
operator|+
literal|"("
operator|+
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|")"
operator|+
literal|" invalid properties:"
operator|+
name|propertiesToString
argument_list|(
name|properties
operator|&
name|props
argument_list|)
argument_list|)
throw|;
block|}
block|}
comment|/** The Name of this FieldType as specified in the schema file */
DECL|method|getTypeName
specifier|public
name|String
name|getTypeName
parameter_list|()
block|{
return|return
name|typeName
return|;
block|}
DECL|method|setTypeName
name|void
name|setTypeName
parameter_list|(
name|String
name|typeName
parameter_list|)
block|{
name|this
operator|.
name|typeName
operator|=
name|typeName
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|typeName
operator|+
literal|"{class="
operator|+
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
comment|//            + propertiesToString(properties)
operator|+
operator|(
name|indexAnalyzer
operator|!=
literal|null
condition|?
literal|",analyzer="
operator|+
name|indexAnalyzer
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
else|:
literal|""
operator|)
operator|+
literal|",args="
operator|+
name|args
operator|+
literal|"}"
return|;
block|}
comment|/**    * Used for adding a document when a field needs to be created from a    * type and a string.    *    *<p>    * By default, the indexed value is the same as the stored value    * (taken from toInternal()).   Having a different representation for    * external, internal, and indexed would present quite a few problems    * given the current Lucene architecture.  An analyzer for adding docs    * would need to translate internal-&gt;indexed while an analyzer for    * querying would need to translate external-&gt;indexed.    *</p>    *<p>    * The only other alternative to having internal==indexed would be to have    * internal==external.   In this case, toInternal should convert to    * the indexed representation, toExternal() should do nothing, and    * createField() should *not* call toInternal, but use the external    * value and set tokenized=true to get Lucene to convert to the    * internal(indexed) form.    *</p>    *    * :TODO: clean up and clarify this explanation.    *    * @see #toInternal    *    *    */
DECL|method|createField
specifier|public
name|StorableField
name|createField
parameter_list|(
name|SchemaField
name|field
parameter_list|,
name|Object
name|value
parameter_list|,
name|float
name|boost
parameter_list|)
block|{
if|if
condition|(
operator|!
name|field
operator|.
name|indexed
argument_list|()
operator|&&
operator|!
name|field
operator|.
name|stored
argument_list|()
condition|)
block|{
if|if
condition|(
name|log
operator|.
name|isTraceEnabled
argument_list|()
condition|)
name|log
operator|.
name|trace
argument_list|(
literal|"Ignoring unindexed/unstored field: "
operator|+
name|field
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
name|String
name|val
decl_stmt|;
try|try
block|{
name|val
operator|=
name|toInternal
argument_list|(
name|value
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|RuntimeException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|SolrException
operator|.
name|ErrorCode
operator|.
name|SERVER_ERROR
argument_list|,
literal|"Error while creating field '"
operator|+
name|field
operator|+
literal|"' from value '"
operator|+
name|value
operator|+
literal|"'"
argument_list|,
name|e
argument_list|)
throw|;
block|}
if|if
condition|(
name|val
operator|==
literal|null
condition|)
return|return
literal|null
return|;
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|document
operator|.
name|FieldType
name|newType
init|=
operator|new
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|document
operator|.
name|FieldType
argument_list|()
decl_stmt|;
name|newType
operator|.
name|setTokenized
argument_list|(
name|field
operator|.
name|isTokenized
argument_list|()
argument_list|)
expr_stmt|;
name|newType
operator|.
name|setStored
argument_list|(
name|field
operator|.
name|stored
argument_list|()
argument_list|)
expr_stmt|;
name|newType
operator|.
name|setOmitNorms
argument_list|(
name|field
operator|.
name|omitNorms
argument_list|()
argument_list|)
expr_stmt|;
name|newType
operator|.
name|setIndexOptions
argument_list|(
name|field
operator|.
name|indexed
argument_list|()
condition|?
name|getIndexOptions
argument_list|(
name|field
argument_list|,
name|val
argument_list|)
else|:
name|IndexOptions
operator|.
name|NONE
argument_list|)
expr_stmt|;
name|newType
operator|.
name|setStoreTermVectors
argument_list|(
name|field
operator|.
name|storeTermVector
argument_list|()
argument_list|)
expr_stmt|;
name|newType
operator|.
name|setStoreTermVectorOffsets
argument_list|(
name|field
operator|.
name|storeTermOffsets
argument_list|()
argument_list|)
expr_stmt|;
name|newType
operator|.
name|setStoreTermVectorPositions
argument_list|(
name|field
operator|.
name|storeTermPositions
argument_list|()
argument_list|)
expr_stmt|;
name|newType
operator|.
name|setStoreTermVectorPayloads
argument_list|(
name|field
operator|.
name|storeTermPayloads
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|createField
argument_list|(
name|field
operator|.
name|getName
argument_list|()
argument_list|,
name|val
argument_list|,
name|newType
argument_list|,
name|boost
argument_list|)
return|;
block|}
comment|/**    * Create the field from native Lucene parts.  Mostly intended for use by FieldTypes outputing multiple    * Fields per SchemaField    * @param name The name of the field    * @param val The _internal_ value to index    * @param type {@link org.apache.lucene.document.FieldType}    * @param boost The boost value    * @return the {@link org.apache.lucene.index.IndexableField}.    */
DECL|method|createField
specifier|protected
name|StorableField
name|createField
parameter_list|(
name|String
name|name
parameter_list|,
name|String
name|val
parameter_list|,
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|document
operator|.
name|FieldType
name|type
parameter_list|,
name|float
name|boost
parameter_list|)
block|{
name|Field
name|f
init|=
operator|new
name|Field
argument_list|(
name|name
argument_list|,
name|val
argument_list|,
name|type
argument_list|)
decl_stmt|;
name|f
operator|.
name|setBoost
argument_list|(
name|boost
argument_list|)
expr_stmt|;
return|return
name|f
return|;
block|}
comment|/**    * Given a {@link org.apache.solr.schema.SchemaField}, create one or more {@link org.apache.lucene.index.IndexableField} instances    * @param field the {@link org.apache.solr.schema.SchemaField}    * @param value The value to add to the field    * @param boost The boost to apply    * @return An array of {@link org.apache.lucene.index.IndexableField}    *    * @see #createField(SchemaField, Object, float)    * @see #isPolyField()    */
DECL|method|createFields
specifier|public
name|List
argument_list|<
name|StorableField
argument_list|>
name|createFields
parameter_list|(
name|SchemaField
name|field
parameter_list|,
name|Object
name|value
parameter_list|,
name|float
name|boost
parameter_list|)
block|{
name|StorableField
name|f
init|=
name|createField
argument_list|(
name|field
argument_list|,
name|value
argument_list|,
name|boost
argument_list|)
decl_stmt|;
if|if
condition|(
name|field
operator|.
name|hasDocValues
argument_list|()
operator|&&
name|f
operator|.
name|fieldType
argument_list|()
operator|.
name|docValuesType
argument_list|()
operator|==
literal|null
condition|)
block|{
comment|// field types that support doc values should either override createField
comment|// to return a field with doc values or extend createFields if this can't
comment|// be done in a single field instance (see StrField for example)
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"This field type does not support doc values: "
operator|+
name|this
argument_list|)
throw|;
block|}
return|return
name|f
operator|==
literal|null
condition|?
name|Collections
operator|.
expr|<
name|StorableField
operator|>
name|emptyList
argument_list|()
else|:
name|Collections
operator|.
name|singletonList
argument_list|(
name|f
argument_list|)
return|;
block|}
DECL|method|getIndexOptions
specifier|protected
name|IndexOptions
name|getIndexOptions
parameter_list|(
name|SchemaField
name|field
parameter_list|,
name|String
name|internalVal
parameter_list|)
block|{
name|IndexOptions
name|options
init|=
name|IndexOptions
operator|.
name|DOCS_AND_FREQS_AND_POSITIONS
decl_stmt|;
if|if
condition|(
name|field
operator|.
name|omitTermFreqAndPositions
argument_list|()
condition|)
block|{
name|options
operator|=
name|IndexOptions
operator|.
name|DOCS
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|field
operator|.
name|omitPositions
argument_list|()
condition|)
block|{
name|options
operator|=
name|IndexOptions
operator|.
name|DOCS_AND_FREQS
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|field
operator|.
name|storeOffsetsWithPositions
argument_list|()
condition|)
block|{
name|options
operator|=
name|IndexOptions
operator|.
name|DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS
expr_stmt|;
block|}
return|return
name|options
return|;
block|}
comment|/**    * Convert an external value (from XML update command or from query string)    * into the internal format for both storing and indexing (which can be modified by any analyzers).    * @see #toExternal    */
DECL|method|toInternal
specifier|public
name|String
name|toInternal
parameter_list|(
name|String
name|val
parameter_list|)
block|{
comment|// - used in delete when a Term needs to be created.
comment|// - used by the default getTokenizer() and createField()
return|return
name|val
return|;
block|}
comment|/**    * Convert the stored-field format to an external (string, human readable)    * value    * @see #toInternal    */
DECL|method|toExternal
specifier|public
name|String
name|toExternal
parameter_list|(
name|StorableField
name|f
parameter_list|)
block|{
comment|// currently used in writing XML of the search result (but perhaps
comment|// a more efficient toXML(IndexableField f, Writer w) should be used
comment|// in the future.
return|return
name|f
operator|.
name|stringValue
argument_list|()
return|;
block|}
comment|/**    * Convert the stored-field format to an external object.    * @see #toInternal    * @since solr 1.3    */
DECL|method|toObject
specifier|public
name|Object
name|toObject
parameter_list|(
name|StorableField
name|f
parameter_list|)
block|{
return|return
name|toExternal
argument_list|(
name|f
argument_list|)
return|;
comment|// by default use the string
block|}
DECL|method|toObject
specifier|public
name|Object
name|toObject
parameter_list|(
name|SchemaField
name|sf
parameter_list|,
name|BytesRef
name|term
parameter_list|)
block|{
specifier|final
name|CharsRefBuilder
name|ref
init|=
operator|new
name|CharsRefBuilder
argument_list|()
decl_stmt|;
name|indexedToReadable
argument_list|(
name|term
argument_list|,
name|ref
argument_list|)
expr_stmt|;
specifier|final
name|StorableField
name|f
init|=
name|createField
argument_list|(
name|sf
argument_list|,
name|ref
operator|.
name|toString
argument_list|()
argument_list|,
literal|1.0f
argument_list|)
decl_stmt|;
return|return
name|toObject
argument_list|(
name|f
argument_list|)
return|;
block|}
comment|/** Given an indexed term, return the human readable representation */
DECL|method|indexedToReadable
specifier|public
name|String
name|indexedToReadable
parameter_list|(
name|String
name|indexedForm
parameter_list|)
block|{
return|return
name|indexedForm
return|;
block|}
comment|/** Given an indexed term, append the human readable representation*/
DECL|method|indexedToReadable
specifier|public
name|CharsRef
name|indexedToReadable
parameter_list|(
name|BytesRef
name|input
parameter_list|,
name|CharsRefBuilder
name|output
parameter_list|)
block|{
name|output
operator|.
name|copyUTF8Bytes
argument_list|(
name|input
argument_list|)
expr_stmt|;
return|return
name|output
operator|.
name|get
argument_list|()
return|;
block|}
comment|/** Given the stored field, return the human readable representation */
DECL|method|storedToReadable
specifier|public
name|String
name|storedToReadable
parameter_list|(
name|StorableField
name|f
parameter_list|)
block|{
return|return
name|toExternal
argument_list|(
name|f
argument_list|)
return|;
block|}
comment|/** Given the stored field, return the indexed form */
DECL|method|storedToIndexed
specifier|public
name|String
name|storedToIndexed
parameter_list|(
name|StorableField
name|f
parameter_list|)
block|{
comment|// right now, the transformation of single valued fields like SortableInt
comment|// is done when the Field is created, not at analysis time... this means
comment|// that the indexed form is the same as the stored field form.
return|return
name|f
operator|.
name|stringValue
argument_list|()
return|;
block|}
comment|/** Given the readable value, return the term value that will match it. */
DECL|method|readableToIndexed
specifier|public
name|String
name|readableToIndexed
parameter_list|(
name|String
name|val
parameter_list|)
block|{
return|return
name|toInternal
argument_list|(
name|val
argument_list|)
return|;
block|}
comment|/** Given the readable value, return the term value that will match it. */
DECL|method|readableToIndexed
specifier|public
name|void
name|readableToIndexed
parameter_list|(
name|CharSequence
name|val
parameter_list|,
name|BytesRefBuilder
name|result
parameter_list|)
block|{
specifier|final
name|String
name|internal
init|=
name|readableToIndexed
argument_list|(
name|val
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
name|result
operator|.
name|copyChars
argument_list|(
name|internal
argument_list|)
expr_stmt|;
block|}
DECL|method|setIsExplicitQueryAnalyzer
specifier|public
name|void
name|setIsExplicitQueryAnalyzer
parameter_list|(
name|boolean
name|isExplicitQueryAnalyzer
parameter_list|)
block|{
name|this
operator|.
name|isExplicitQueryAnalyzer
operator|=
name|isExplicitQueryAnalyzer
expr_stmt|;
block|}
DECL|method|isExplicitQueryAnalyzer
specifier|public
name|boolean
name|isExplicitQueryAnalyzer
parameter_list|()
block|{
return|return
name|isExplicitQueryAnalyzer
return|;
block|}
DECL|method|setIsExplicitAnalyzer
specifier|public
name|void
name|setIsExplicitAnalyzer
parameter_list|(
name|boolean
name|explicitAnalyzer
parameter_list|)
block|{
name|isExplicitAnalyzer
operator|=
name|explicitAnalyzer
expr_stmt|;
block|}
DECL|method|isExplicitAnalyzer
specifier|public
name|boolean
name|isExplicitAnalyzer
parameter_list|()
block|{
return|return
name|isExplicitAnalyzer
return|;
block|}
comment|/**    * @return the string used to specify the concrete class name in a serialized representation: the class arg.      *         If the concrete class name was not specified via a class arg, returns {@code getClass().getName()}.    */
DECL|method|getClassArg
specifier|public
name|String
name|getClassArg
parameter_list|()
block|{
if|if
condition|(
literal|null
operator|!=
name|args
condition|)
block|{
name|String
name|className
init|=
name|args
operator|.
name|get
argument_list|(
name|CLASS_NAME
argument_list|)
decl_stmt|;
if|if
condition|(
literal|null
operator|!=
name|className
condition|)
block|{
return|return
name|className
return|;
block|}
block|}
return|return
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
return|;
block|}
comment|/**    * Returns a Query instance for doing prefix searches on this field type.    * Also, other QueryParser implementations may have different semantics.    *<p>    * Sub-classes should override this method to provide their own range query implementation.    *    * @param parser       the {@link org.apache.solr.search.QParser} calling the method    * @param sf           the schema field    * @param termStr      the term string for prefix query    * @return a Query instance to perform prefix search    *    */
DECL|method|getPrefixQuery
specifier|public
name|Query
name|getPrefixQuery
parameter_list|(
name|QParser
name|parser
parameter_list|,
name|SchemaField
name|sf
parameter_list|,
name|String
name|termStr
parameter_list|)
block|{
name|PrefixQuery
name|query
init|=
operator|new
name|PrefixQuery
argument_list|(
operator|new
name|Term
argument_list|(
name|sf
operator|.
name|getName
argument_list|()
argument_list|,
name|termStr
argument_list|)
argument_list|)
decl_stmt|;
name|query
operator|.
name|setRewriteMethod
argument_list|(
name|sf
operator|.
name|getType
argument_list|()
operator|.
name|getRewriteMethod
argument_list|(
name|parser
argument_list|,
name|sf
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|query
return|;
block|}
comment|/**    * DocValues is not enabled for a field, but it's indexed, docvalues can be constructed     * on the fly (uninverted, aka fieldcache) on the first request to sort, facet, etc.     * This specifies the structure to use.    *     * @param sf field instance    * @return type to uninvert, or {@code null} (to disallow uninversion for the field)    */
DECL|method|getUninversionType
specifier|public
specifier|abstract
name|UninvertingReader
operator|.
name|Type
name|getUninversionType
parameter_list|(
name|SchemaField
name|sf
parameter_list|)
function_decl|;
comment|/**    * Default analyzer for types that only produce 1 verbatim token...    * A maximum size of chars to be read must be specified    */
DECL|class|DefaultAnalyzer
specifier|protected
specifier|final
class|class
name|DefaultAnalyzer
extends|extends
name|SolrAnalyzer
block|{
DECL|field|maxChars
specifier|final
name|int
name|maxChars
decl_stmt|;
DECL|method|DefaultAnalyzer
name|DefaultAnalyzer
parameter_list|(
name|int
name|maxChars
parameter_list|)
block|{
name|this
operator|.
name|maxChars
operator|=
name|maxChars
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|createComponents
specifier|public
name|TokenStreamComponents
name|createComponents
parameter_list|(
name|String
name|fieldName
parameter_list|)
block|{
name|Tokenizer
name|ts
init|=
operator|new
name|Tokenizer
argument_list|()
block|{
specifier|final
name|char
index|[]
name|cbuf
init|=
operator|new
name|char
index|[
name|maxChars
index|]
decl_stmt|;
specifier|final
name|CharTermAttribute
name|termAtt
init|=
name|addAttribute
argument_list|(
name|CharTermAttribute
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|final
name|OffsetAttribute
name|offsetAtt
init|=
name|addAttribute
argument_list|(
name|OffsetAttribute
operator|.
name|class
argument_list|)
decl_stmt|;
annotation|@
name|Override
specifier|public
name|boolean
name|incrementToken
parameter_list|()
throws|throws
name|IOException
block|{
name|clearAttributes
argument_list|()
expr_stmt|;
name|int
name|n
init|=
name|input
operator|.
name|read
argument_list|(
name|cbuf
argument_list|,
literal|0
argument_list|,
name|maxChars
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
operator|<=
literal|0
condition|)
return|return
literal|false
return|;
name|String
name|s
init|=
name|toInternal
argument_list|(
operator|new
name|String
argument_list|(
name|cbuf
argument_list|,
literal|0
argument_list|,
name|n
argument_list|)
argument_list|)
decl_stmt|;
name|termAtt
operator|.
name|setEmpty
argument_list|()
operator|.
name|append
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|offsetAtt
operator|.
name|setOffset
argument_list|(
name|correctOffset
argument_list|(
literal|0
argument_list|)
argument_list|,
name|correctOffset
argument_list|(
name|n
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
decl_stmt|;
return|return
operator|new
name|TokenStreamComponents
argument_list|(
name|ts
argument_list|)
return|;
block|}
block|}
DECL|field|indexAnalyzer
specifier|private
name|Analyzer
name|indexAnalyzer
init|=
operator|new
name|DefaultAnalyzer
argument_list|(
literal|256
argument_list|)
decl_stmt|;
DECL|field|queryAnalyzer
specifier|private
name|Analyzer
name|queryAnalyzer
init|=
name|indexAnalyzer
decl_stmt|;
comment|/**    * Returns the Analyzer to be used when indexing fields of this type.    *<p>    * This method may be called many times, at any time.    *</p>    * @see #getQueryAnalyzer    */
DECL|method|getIndexAnalyzer
specifier|public
name|Analyzer
name|getIndexAnalyzer
parameter_list|()
block|{
return|return
name|indexAnalyzer
return|;
block|}
comment|/**    * Returns the Analyzer to be used when searching fields of this type.    *<p>    * This method may be called many times, at any time.    *</p>    * @see #getIndexAnalyzer    */
DECL|method|getQueryAnalyzer
specifier|public
name|Analyzer
name|getQueryAnalyzer
parameter_list|()
block|{
return|return
name|queryAnalyzer
return|;
block|}
comment|/**    * Returns true if this type supports index and query analyzers, false otherwise.    */
DECL|method|supportsAnalyzers
specifier|protected
name|boolean
name|supportsAnalyzers
parameter_list|()
block|{
return|return
literal|false
return|;
block|}
comment|/**    * Sets the Analyzer to be used when indexing fields of this type.    *    *<p>    * Subclasses should override {@link #supportsAnalyzers()} to    * enable this function.    *</p>    *    * @see #supportsAnalyzers()    * @see #setQueryAnalyzer    * @see #getIndexAnalyzer    */
DECL|method|setIndexAnalyzer
specifier|public
specifier|final
name|void
name|setIndexAnalyzer
parameter_list|(
name|Analyzer
name|analyzer
parameter_list|)
block|{
if|if
condition|(
name|supportsAnalyzers
argument_list|()
condition|)
block|{
name|indexAnalyzer
operator|=
name|analyzer
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|SERVER_ERROR
argument_list|,
literal|"FieldType: "
operator|+
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|" ("
operator|+
name|typeName
operator|+
literal|") does not support specifying an analyzer"
argument_list|)
throw|;
block|}
block|}
comment|/**    * Sets the Analyzer to be used when querying fields of this type.    *    *<p>    * Subclasses should override {@link #supportsAnalyzers()} to    * enable this function.    *</p>    *    * @see #supportsAnalyzers()    * @see #setIndexAnalyzer    * @see #getQueryAnalyzer    */
DECL|method|setQueryAnalyzer
specifier|public
specifier|final
name|void
name|setQueryAnalyzer
parameter_list|(
name|Analyzer
name|analyzer
parameter_list|)
block|{
if|if
condition|(
name|supportsAnalyzers
argument_list|()
condition|)
block|{
name|queryAnalyzer
operator|=
name|analyzer
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|SERVER_ERROR
argument_list|,
literal|"FieldType: "
operator|+
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|" ("
operator|+
name|typeName
operator|+
literal|") does not support specifying an analyzer"
argument_list|)
throw|;
block|}
block|}
comment|/** @lucene.internal */
DECL|field|similarityFactory
specifier|protected
name|SimilarityFactory
name|similarityFactory
decl_stmt|;
comment|/** @lucene.internal */
DECL|field|similarity
specifier|protected
name|Similarity
name|similarity
decl_stmt|;
comment|/**    * Gets the Similarity used when scoring fields of this type    *     *<p>    * The default implementation returns null, which means this type    * has no custom similarity associated with it.    *</p>    *     * @lucene.internal    */
DECL|method|getSimilarity
specifier|public
name|Similarity
name|getSimilarity
parameter_list|()
block|{
return|return
name|similarity
return|;
block|}
comment|/**    * Gets the factory for the Similarity used when scoring fields of this type    *    *<p>    * The default implementation returns null, which means this type    * has no custom similarity factory associated with it.    *</p>    *    * @lucene.internal    */
DECL|method|getSimilarityFactory
specifier|public
name|SimilarityFactory
name|getSimilarityFactory
parameter_list|()
block|{
return|return
name|similarityFactory
return|;
block|}
comment|/** Return the numeric type of this field, or null if this field is not a    *  numeric field. */
DECL|method|getNumericType
specifier|public
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|document
operator|.
name|FieldType
operator|.
name|LegacyNumericType
name|getNumericType
parameter_list|()
block|{
return|return
literal|null
return|;
block|}
comment|/**    * Sets the Similarity used when scoring fields of this type    * @lucene.internal    */
DECL|method|setSimilarity
specifier|public
name|void
name|setSimilarity
parameter_list|(
name|SimilarityFactory
name|similarityFactory
parameter_list|)
block|{
name|this
operator|.
name|similarityFactory
operator|=
name|similarityFactory
expr_stmt|;
name|this
operator|.
name|similarity
operator|=
name|similarityFactory
operator|.
name|getSimilarity
argument_list|()
expr_stmt|;
block|}
comment|/**    * The postings format used for this field type    */
DECL|field|postingsFormat
specifier|protected
name|String
name|postingsFormat
decl_stmt|;
DECL|method|getPostingsFormat
specifier|public
name|String
name|getPostingsFormat
parameter_list|()
block|{
return|return
name|postingsFormat
return|;
block|}
comment|/**    * The docvalues format used for this field type    */
DECL|field|docValuesFormat
specifier|protected
name|String
name|docValuesFormat
decl_stmt|;
DECL|method|getDocValuesFormat
specifier|public
specifier|final
name|String
name|getDocValuesFormat
parameter_list|()
block|{
return|return
name|docValuesFormat
return|;
block|}
comment|/**    * calls back to TextResponseWriter to write the field value    */
DECL|method|write
specifier|public
specifier|abstract
name|void
name|write
parameter_list|(
name|TextResponseWriter
name|writer
parameter_list|,
name|String
name|name
parameter_list|,
name|StorableField
name|f
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|/**    * Returns the SortField instance that should be used to sort fields    * of this type.    * @see SchemaField#checkSortability    */
DECL|method|getSortField
specifier|public
specifier|abstract
name|SortField
name|getSortField
parameter_list|(
name|SchemaField
name|field
parameter_list|,
name|boolean
name|top
parameter_list|)
function_decl|;
comment|/**    * Utility usable by subclasses when they want to get basic String sorting    * using common checks.    * @see SchemaField#checkSortability    */
DECL|method|getStringSort
specifier|protected
name|SortField
name|getStringSort
parameter_list|(
name|SchemaField
name|field
parameter_list|,
name|boolean
name|reverse
parameter_list|)
block|{
name|field
operator|.
name|checkSortability
argument_list|()
expr_stmt|;
return|return
name|Sorting
operator|.
name|getStringSortField
argument_list|(
name|field
operator|.
name|name
argument_list|,
name|reverse
argument_list|,
name|field
operator|.
name|sortMissingLast
argument_list|()
argument_list|,
name|field
operator|.
name|sortMissingFirst
argument_list|()
argument_list|)
return|;
block|}
comment|/** called to get the default value source (normally, from the    *  Lucene FieldCache.)    */
DECL|method|getValueSource
specifier|public
name|ValueSource
name|getValueSource
parameter_list|(
name|SchemaField
name|field
parameter_list|,
name|QParser
name|parser
parameter_list|)
block|{
name|field
operator|.
name|checkFieldCacheSource
argument_list|()
expr_stmt|;
return|return
operator|new
name|StrFieldSource
argument_list|(
name|field
operator|.
name|name
argument_list|)
return|;
block|}
comment|/**    * Method for dynamically building a ValueSource based on a single value of a multivalued field.    *    * The default implementation throws an error except in the trivial case where this method is used on     * a {@link SchemaField} that is in fact not-multivalued, in which case it delegates to     * {@link #getValueSource}    *    * @see MultiValueSelector    */
DECL|method|getSingleValueSource
specifier|public
name|ValueSource
name|getSingleValueSource
parameter_list|(
name|MultiValueSelector
name|choice
parameter_list|,
name|SchemaField
name|field
parameter_list|,
name|QParser
name|parser
parameter_list|)
block|{
comment|// trivial base case
if|if
condition|(
operator|!
name|field
operator|.
name|multiValued
argument_list|()
condition|)
block|{
comment|// single value matches any selector
return|return
name|getValueSource
argument_list|(
name|field
argument_list|,
name|parser
argument_list|)
return|;
block|}
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
literal|"Selecting a single value from a multivalued field is not supported for this field: "
operator|+
name|field
operator|.
name|getName
argument_list|()
operator|+
literal|" (type: "
operator|+
name|this
operator|.
name|getTypeName
argument_list|()
operator|+
literal|")"
argument_list|)
throw|;
block|}
comment|/**    * Returns a Query instance for doing range searches on this field type. {@link org.apache.solr.search.SolrQueryParser}    * currently passes part1 and part2 as null if they are '*' respectively. minInclusive and maxInclusive are both true    * currently by SolrQueryParser but that may change in the future. Also, other QueryParser implementations may have    * different semantics.    *<p>    * Sub-classes should override this method to provide their own range query implementation. They should strive to    * handle nulls in part1 and/or part2 as well as unequal minInclusive and maxInclusive parameters gracefully.    *    * @param parser       the {@link org.apache.solr.search.QParser} calling the method    * @param field        the schema field    * @param part1        the lower boundary of the range, nulls are allowed.    * @param part2        the upper boundary of the range, nulls are allowed    * @param minInclusive whether the minimum of the range is inclusive or not    * @param maxInclusive whether the maximum of the range is inclusive or not    *  @return a Query instance to perform range search according to given parameters    *    */
DECL|method|getRangeQuery
specifier|public
name|Query
name|getRangeQuery
parameter_list|(
name|QParser
name|parser
parameter_list|,
name|SchemaField
name|field
parameter_list|,
name|String
name|part1
parameter_list|,
name|String
name|part2
parameter_list|,
name|boolean
name|minInclusive
parameter_list|,
name|boolean
name|maxInclusive
parameter_list|)
block|{
comment|// TODO: change these all to use readableToIndexed/bytes instead (e.g. for unicode collation)
if|if
condition|(
name|field
operator|.
name|hasDocValues
argument_list|()
operator|&&
operator|!
name|field
operator|.
name|indexed
argument_list|()
condition|)
block|{
return|return
name|DocValuesRangeQuery
operator|.
name|newBytesRefRange
argument_list|(
name|field
operator|.
name|getName
argument_list|()
argument_list|,
name|part1
operator|==
literal|null
condition|?
literal|null
else|:
operator|new
name|BytesRef
argument_list|(
name|toInternal
argument_list|(
name|part1
argument_list|)
argument_list|)
argument_list|,
name|part2
operator|==
literal|null
condition|?
literal|null
else|:
operator|new
name|BytesRef
argument_list|(
name|toInternal
argument_list|(
name|part2
argument_list|)
argument_list|)
argument_list|,
name|minInclusive
argument_list|,
name|maxInclusive
argument_list|)
return|;
block|}
else|else
block|{
name|SolrRangeQuery
name|rangeQuery
init|=
operator|new
name|SolrRangeQuery
argument_list|(
name|field
operator|.
name|getName
argument_list|()
argument_list|,
name|part1
operator|==
literal|null
condition|?
literal|null
else|:
operator|new
name|BytesRef
argument_list|(
name|toInternal
argument_list|(
name|part1
argument_list|)
argument_list|)
argument_list|,
name|part2
operator|==
literal|null
condition|?
literal|null
else|:
operator|new
name|BytesRef
argument_list|(
name|toInternal
argument_list|(
name|part2
argument_list|)
argument_list|)
argument_list|,
name|minInclusive
argument_list|,
name|maxInclusive
argument_list|)
decl_stmt|;
return|return
name|rangeQuery
return|;
block|}
block|}
comment|/**    * Returns a Query instance for doing searches against a field.    * @param parser The {@link org.apache.solr.search.QParser} calling the method    * @param field The {@link org.apache.solr.schema.SchemaField} of the field to search    * @param externalVal The String representation of the value to search    * @return The {@link org.apache.lucene.search.Query} instance.  This implementation returns a {@link org.apache.lucene.search.TermQuery} but overriding queries may not    *     */
DECL|method|getFieldQuery
specifier|public
name|Query
name|getFieldQuery
parameter_list|(
name|QParser
name|parser
parameter_list|,
name|SchemaField
name|field
parameter_list|,
name|String
name|externalVal
parameter_list|)
block|{
name|BytesRefBuilder
name|br
init|=
operator|new
name|BytesRefBuilder
argument_list|()
decl_stmt|;
name|readableToIndexed
argument_list|(
name|externalVal
argument_list|,
name|br
argument_list|)
expr_stmt|;
if|if
condition|(
name|field
operator|.
name|hasDocValues
argument_list|()
operator|&&
operator|!
name|field
operator|.
name|indexed
argument_list|()
condition|)
block|{
comment|// match-only
return|return
name|getRangeQuery
argument_list|(
name|parser
argument_list|,
name|field
argument_list|,
name|externalVal
argument_list|,
name|externalVal
argument_list|,
literal|true
argument_list|,
literal|true
argument_list|)
return|;
block|}
else|else
block|{
return|return
operator|new
name|TermQuery
argument_list|(
operator|new
name|Term
argument_list|(
name|field
operator|.
name|getName
argument_list|()
argument_list|,
name|br
argument_list|)
argument_list|)
return|;
block|}
block|}
comment|/**    * Expert: Returns the rewrite method for multiterm queries such as wildcards.    * @param parser The {@link org.apache.solr.search.QParser} calling the method    * @param field The {@link org.apache.solr.schema.SchemaField} of the field to search    * @return A suitable rewrite method for rewriting multi-term queries to primitive queries.    */
DECL|method|getRewriteMethod
specifier|public
name|MultiTermQuery
operator|.
name|RewriteMethod
name|getRewriteMethod
parameter_list|(
name|QParser
name|parser
parameter_list|,
name|SchemaField
name|field
parameter_list|)
block|{
if|if
condition|(
operator|!
name|field
operator|.
name|indexed
argument_list|()
operator|&&
name|field
operator|.
name|hasDocValues
argument_list|()
condition|)
block|{
return|return
operator|new
name|DocValuesRewriteMethod
argument_list|()
return|;
block|}
else|else
block|{
return|return
name|MultiTermQuery
operator|.
name|CONSTANT_SCORE_REWRITE
return|;
block|}
block|}
comment|/**    * Check's {@link org.apache.solr.schema.SchemaField} instances constructed     * using this field type to ensure that they are valid.    *    *<p>    * This method is called by the<code>SchemaField</code> constructor to     * check that its initialization does not violate any fundemental     * requirements of the<code>FieldType</code>.  The default implementation     * does nothing, but subclasses may chose to throw a {@link SolrException}      * if invariants are violated by the<code>SchemaField.</code>    *</p>    */
DECL|method|checkSchemaField
specifier|public
name|void
name|checkSchemaField
parameter_list|(
specifier|final
name|SchemaField
name|field
parameter_list|)
block|{
comment|// override if your field type supports doc values
if|if
condition|(
name|field
operator|.
name|hasDocValues
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|SERVER_ERROR
argument_list|,
literal|"Field type "
operator|+
name|this
operator|+
literal|" does not support doc values"
argument_list|)
throw|;
block|}
block|}
DECL|field|TYPE
specifier|public
specifier|static
specifier|final
name|String
name|TYPE
init|=
literal|"type"
decl_stmt|;
DECL|field|TYPE_NAME
specifier|public
specifier|static
specifier|final
name|String
name|TYPE_NAME
init|=
literal|"name"
decl_stmt|;
DECL|field|CLASS_NAME
specifier|public
specifier|static
specifier|final
name|String
name|CLASS_NAME
init|=
literal|"class"
decl_stmt|;
DECL|field|ANALYZER
specifier|public
specifier|static
specifier|final
name|String
name|ANALYZER
init|=
literal|"analyzer"
decl_stmt|;
DECL|field|INDEX
specifier|public
specifier|static
specifier|final
name|String
name|INDEX
init|=
literal|"index"
decl_stmt|;
DECL|field|INDEX_ANALYZER
specifier|public
specifier|static
specifier|final
name|String
name|INDEX_ANALYZER
init|=
literal|"indexAnalyzer"
decl_stmt|;
DECL|field|QUERY
specifier|public
specifier|static
specifier|final
name|String
name|QUERY
init|=
literal|"query"
decl_stmt|;
DECL|field|QUERY_ANALYZER
specifier|public
specifier|static
specifier|final
name|String
name|QUERY_ANALYZER
init|=
literal|"queryAnalyzer"
decl_stmt|;
DECL|field|MULTI_TERM
specifier|public
specifier|static
specifier|final
name|String
name|MULTI_TERM
init|=
literal|"multiterm"
decl_stmt|;
DECL|field|MULTI_TERM_ANALYZER
specifier|public
specifier|static
specifier|final
name|String
name|MULTI_TERM_ANALYZER
init|=
literal|"multiTermAnalyzer"
decl_stmt|;
DECL|field|SIMILARITY
specifier|public
specifier|static
specifier|final
name|String
name|SIMILARITY
init|=
literal|"similarity"
decl_stmt|;
DECL|field|CHAR_FILTER
specifier|public
specifier|static
specifier|final
name|String
name|CHAR_FILTER
init|=
literal|"charFilter"
decl_stmt|;
DECL|field|CHAR_FILTERS
specifier|public
specifier|static
specifier|final
name|String
name|CHAR_FILTERS
init|=
literal|"charFilters"
decl_stmt|;
DECL|field|TOKENIZER
specifier|public
specifier|static
specifier|final
name|String
name|TOKENIZER
init|=
literal|"tokenizer"
decl_stmt|;
DECL|field|FILTER
specifier|public
specifier|static
specifier|final
name|String
name|FILTER
init|=
literal|"filter"
decl_stmt|;
DECL|field|FILTERS
specifier|public
specifier|static
specifier|final
name|String
name|FILTERS
init|=
literal|"filters"
decl_stmt|;
DECL|field|POSTINGS_FORMAT
specifier|private
specifier|static
specifier|final
name|String
name|POSTINGS_FORMAT
init|=
literal|"postingsFormat"
decl_stmt|;
DECL|field|DOC_VALUES_FORMAT
specifier|private
specifier|static
specifier|final
name|String
name|DOC_VALUES_FORMAT
init|=
literal|"docValuesFormat"
decl_stmt|;
DECL|field|AUTO_GENERATE_PHRASE_QUERIES
specifier|private
specifier|static
specifier|final
name|String
name|AUTO_GENERATE_PHRASE_QUERIES
init|=
literal|"autoGeneratePhraseQueries"
decl_stmt|;
DECL|field|ARGS
specifier|private
specifier|static
specifier|final
name|String
name|ARGS
init|=
literal|"args"
decl_stmt|;
DECL|field|POSITION_INCREMENT_GAP
specifier|private
specifier|static
specifier|final
name|String
name|POSITION_INCREMENT_GAP
init|=
literal|"positionIncrementGap"
decl_stmt|;
comment|/**    * Get a map of property name -&gt; value for this field type.     * @param showDefaults if true, include default properties.    */
DECL|method|getNamedPropertyValues
specifier|public
name|SimpleOrderedMap
argument_list|<
name|Object
argument_list|>
name|getNamedPropertyValues
parameter_list|(
name|boolean
name|showDefaults
parameter_list|)
block|{
name|SimpleOrderedMap
argument_list|<
name|Object
argument_list|>
name|namedPropertyValues
init|=
operator|new
name|SimpleOrderedMap
argument_list|<>
argument_list|()
decl_stmt|;
name|namedPropertyValues
operator|.
name|add
argument_list|(
name|TYPE_NAME
argument_list|,
name|getTypeName
argument_list|()
argument_list|)
expr_stmt|;
name|namedPropertyValues
operator|.
name|add
argument_list|(
name|CLASS_NAME
argument_list|,
name|getClassArg
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|showDefaults
condition|)
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|fieldTypeArgs
init|=
name|getNonFieldPropertyArgs
argument_list|()
decl_stmt|;
if|if
condition|(
literal|null
operator|!=
name|fieldTypeArgs
condition|)
block|{
for|for
control|(
name|String
name|key
range|:
name|fieldTypeArgs
operator|.
name|keySet
argument_list|()
control|)
block|{
if|if
condition|(
operator|!
name|CLASS_NAME
operator|.
name|equals
argument_list|(
name|key
argument_list|)
operator|&&
operator|!
name|TYPE_NAME
operator|.
name|equals
argument_list|(
name|key
argument_list|)
condition|)
block|{
name|namedPropertyValues
operator|.
name|add
argument_list|(
name|key
argument_list|,
name|fieldTypeArgs
operator|.
name|get
argument_list|(
name|key
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|this
operator|instanceof
name|TextField
condition|)
block|{
name|namedPropertyValues
operator|.
name|add
argument_list|(
name|AUTO_GENERATE_PHRASE_QUERIES
argument_list|,
operator|(
operator|(
name|TextField
operator|)
name|this
operator|)
operator|.
name|getAutoGeneratePhraseQueries
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|namedPropertyValues
operator|.
name|add
argument_list|(
name|getPropertyName
argument_list|(
name|INDEXED
argument_list|)
argument_list|,
name|hasProperty
argument_list|(
name|INDEXED
argument_list|)
argument_list|)
expr_stmt|;
name|namedPropertyValues
operator|.
name|add
argument_list|(
name|getPropertyName
argument_list|(
name|STORED
argument_list|)
argument_list|,
name|hasProperty
argument_list|(
name|STORED
argument_list|)
argument_list|)
expr_stmt|;
name|namedPropertyValues
operator|.
name|add
argument_list|(
name|getPropertyName
argument_list|(
name|DOC_VALUES
argument_list|)
argument_list|,
name|hasProperty
argument_list|(
name|DOC_VALUES
argument_list|)
argument_list|)
expr_stmt|;
name|namedPropertyValues
operator|.
name|add
argument_list|(
name|getPropertyName
argument_list|(
name|STORE_TERMVECTORS
argument_list|)
argument_list|,
name|hasProperty
argument_list|(
name|STORE_TERMVECTORS
argument_list|)
argument_list|)
expr_stmt|;
name|namedPropertyValues
operator|.
name|add
argument_list|(
name|getPropertyName
argument_list|(
name|STORE_TERMPOSITIONS
argument_list|)
argument_list|,
name|hasProperty
argument_list|(
name|STORE_TERMPOSITIONS
argument_list|)
argument_list|)
expr_stmt|;
name|namedPropertyValues
operator|.
name|add
argument_list|(
name|getPropertyName
argument_list|(
name|STORE_TERMOFFSETS
argument_list|)
argument_list|,
name|hasProperty
argument_list|(
name|STORE_TERMOFFSETS
argument_list|)
argument_list|)
expr_stmt|;
name|namedPropertyValues
operator|.
name|add
argument_list|(
name|getPropertyName
argument_list|(
name|OMIT_NORMS
argument_list|)
argument_list|,
name|hasProperty
argument_list|(
name|OMIT_NORMS
argument_list|)
argument_list|)
expr_stmt|;
name|namedPropertyValues
operator|.
name|add
argument_list|(
name|getPropertyName
argument_list|(
name|OMIT_TF_POSITIONS
argument_list|)
argument_list|,
name|hasProperty
argument_list|(
name|OMIT_TF_POSITIONS
argument_list|)
argument_list|)
expr_stmt|;
name|namedPropertyValues
operator|.
name|add
argument_list|(
name|getPropertyName
argument_list|(
name|OMIT_POSITIONS
argument_list|)
argument_list|,
name|hasProperty
argument_list|(
name|OMIT_POSITIONS
argument_list|)
argument_list|)
expr_stmt|;
name|namedPropertyValues
operator|.
name|add
argument_list|(
name|getPropertyName
argument_list|(
name|STORE_OFFSETS
argument_list|)
argument_list|,
name|hasProperty
argument_list|(
name|STORE_OFFSETS
argument_list|)
argument_list|)
expr_stmt|;
name|namedPropertyValues
operator|.
name|add
argument_list|(
name|getPropertyName
argument_list|(
name|MULTIVALUED
argument_list|)
argument_list|,
name|hasProperty
argument_list|(
name|MULTIVALUED
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|hasProperty
argument_list|(
name|SORT_MISSING_FIRST
argument_list|)
condition|)
block|{
name|namedPropertyValues
operator|.
name|add
argument_list|(
name|getPropertyName
argument_list|(
name|SORT_MISSING_FIRST
argument_list|)
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|hasProperty
argument_list|(
name|SORT_MISSING_LAST
argument_list|)
condition|)
block|{
name|namedPropertyValues
operator|.
name|add
argument_list|(
name|getPropertyName
argument_list|(
name|SORT_MISSING_LAST
argument_list|)
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
name|namedPropertyValues
operator|.
name|add
argument_list|(
name|getPropertyName
argument_list|(
name|TOKENIZED
argument_list|)
argument_list|,
name|isTokenized
argument_list|()
argument_list|)
expr_stmt|;
comment|// The BINARY property is always false
comment|// namedPropertyValues.add(getPropertyName(BINARY), hasProperty(BINARY));
if|if
condition|(
literal|null
operator|!=
name|getPostingsFormat
argument_list|()
condition|)
block|{
name|namedPropertyValues
operator|.
name|add
argument_list|(
name|POSTINGS_FORMAT
argument_list|,
name|getPostingsFormat
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
literal|null
operator|!=
name|getDocValuesFormat
argument_list|()
condition|)
block|{
name|namedPropertyValues
operator|.
name|add
argument_list|(
name|DOC_VALUES_FORMAT
argument_list|,
name|getDocValuesFormat
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// Don't show defaults
name|Set
argument_list|<
name|String
argument_list|>
name|fieldProperties
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|propertyName
range|:
name|FieldProperties
operator|.
name|propertyNames
control|)
block|{
name|fieldProperties
operator|.
name|add
argument_list|(
name|propertyName
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|String
name|key
range|:
name|args
operator|.
name|keySet
argument_list|()
control|)
block|{
if|if
condition|(
name|fieldProperties
operator|.
name|contains
argument_list|(
name|key
argument_list|)
condition|)
block|{
name|namedPropertyValues
operator|.
name|add
argument_list|(
name|key
argument_list|,
name|StrUtils
operator|.
name|parseBool
argument_list|(
name|args
operator|.
name|get
argument_list|(
name|key
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|CLASS_NAME
operator|.
name|equals
argument_list|(
name|key
argument_list|)
operator|&&
operator|!
name|TYPE_NAME
operator|.
name|equals
argument_list|(
name|key
argument_list|)
condition|)
block|{
name|namedPropertyValues
operator|.
name|add
argument_list|(
name|key
argument_list|,
name|args
operator|.
name|get
argument_list|(
name|key
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
literal|null
operator|!=
name|getSimilarityFactory
argument_list|()
condition|)
block|{
name|namedPropertyValues
operator|.
name|add
argument_list|(
name|SIMILARITY
argument_list|,
name|getSimilarityFactory
argument_list|()
operator|.
name|getNamedPropertyValues
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|isExplicitAnalyzer
argument_list|()
condition|)
block|{
name|String
name|analyzerProperty
init|=
name|isExplicitQueryAnalyzer
argument_list|()
condition|?
name|INDEX_ANALYZER
else|:
name|ANALYZER
decl_stmt|;
name|namedPropertyValues
operator|.
name|add
argument_list|(
name|analyzerProperty
argument_list|,
name|getAnalyzerProperties
argument_list|(
name|getIndexAnalyzer
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|isExplicitQueryAnalyzer
argument_list|()
condition|)
block|{
name|String
name|analyzerProperty
init|=
name|isExplicitAnalyzer
argument_list|()
condition|?
name|QUERY_ANALYZER
else|:
name|ANALYZER
decl_stmt|;
name|namedPropertyValues
operator|.
name|add
argument_list|(
name|analyzerProperty
argument_list|,
name|getAnalyzerProperties
argument_list|(
name|getQueryAnalyzer
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|this
operator|instanceof
name|TextField
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|TextField
operator|)
name|this
operator|)
operator|.
name|isExplicitMultiTermAnalyzer
argument_list|()
condition|)
block|{
name|namedPropertyValues
operator|.
name|add
argument_list|(
name|MULTI_TERM_ANALYZER
argument_list|,
name|getAnalyzerProperties
argument_list|(
operator|(
operator|(
name|TextField
operator|)
name|this
operator|)
operator|.
name|getMultiTermAnalyzer
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|namedPropertyValues
return|;
block|}
comment|/** Returns args to this field type that aren't standard field properties */
DECL|method|getNonFieldPropertyArgs
specifier|protected
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|getNonFieldPropertyArgs
parameter_list|()
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|initArgs
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|(
name|args
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|prop
range|:
name|FieldProperties
operator|.
name|propertyNames
control|)
block|{
name|initArgs
operator|.
name|remove
argument_list|(
name|prop
argument_list|)
expr_stmt|;
block|}
return|return
name|initArgs
return|;
block|}
comment|/**     * Returns a description of the given analyzer, by either reporting the Analyzer class    * name (and optionally luceneMatchVersion) if it's not a TokenizerChain, or if it is,    * querying each analysis factory for its name and args.    */
DECL|method|getAnalyzerProperties
specifier|protected
specifier|static
name|SimpleOrderedMap
argument_list|<
name|Object
argument_list|>
name|getAnalyzerProperties
parameter_list|(
name|Analyzer
name|analyzer
parameter_list|)
block|{
name|SimpleOrderedMap
argument_list|<
name|Object
argument_list|>
name|analyzerProps
init|=
operator|new
name|SimpleOrderedMap
argument_list|<>
argument_list|()
decl_stmt|;
if|if
condition|(
name|analyzer
operator|instanceof
name|TokenizerChain
condition|)
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|factoryArgs
decl_stmt|;
name|TokenizerChain
name|tokenizerChain
init|=
operator|(
name|TokenizerChain
operator|)
name|analyzer
decl_stmt|;
name|CharFilterFactory
index|[]
name|charFilterFactories
init|=
name|tokenizerChain
operator|.
name|getCharFilterFactories
argument_list|()
decl_stmt|;
if|if
condition|(
literal|0
operator|<
name|charFilterFactories
operator|.
name|length
condition|)
block|{
name|List
argument_list|<
name|SimpleOrderedMap
argument_list|<
name|Object
argument_list|>
argument_list|>
name|charFilterProps
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|CharFilterFactory
name|charFilterFactory
range|:
name|charFilterFactories
control|)
block|{
name|SimpleOrderedMap
argument_list|<
name|Object
argument_list|>
name|props
init|=
operator|new
name|SimpleOrderedMap
argument_list|<>
argument_list|()
decl_stmt|;
name|props
operator|.
name|add
argument_list|(
name|CLASS_NAME
argument_list|,
name|charFilterFactory
operator|.
name|getClassArg
argument_list|()
argument_list|)
expr_stmt|;
name|factoryArgs
operator|=
name|charFilterFactory
operator|.
name|getOriginalArgs
argument_list|()
expr_stmt|;
if|if
condition|(
literal|null
operator|!=
name|factoryArgs
condition|)
block|{
for|for
control|(
name|String
name|key
range|:
name|factoryArgs
operator|.
name|keySet
argument_list|()
control|)
block|{
if|if
condition|(
operator|!
name|CLASS_NAME
operator|.
name|equals
argument_list|(
name|key
argument_list|)
condition|)
block|{
if|if
condition|(
name|LUCENE_MATCH_VERSION_PARAM
operator|.
name|equals
argument_list|(
name|key
argument_list|)
condition|)
block|{
if|if
condition|(
name|charFilterFactory
operator|.
name|isExplicitLuceneMatchVersion
argument_list|()
condition|)
block|{
name|props
operator|.
name|add
argument_list|(
name|key
argument_list|,
name|factoryArgs
operator|.
name|get
argument_list|(
name|key
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|props
operator|.
name|add
argument_list|(
name|key
argument_list|,
name|factoryArgs
operator|.
name|get
argument_list|(
name|key
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
name|charFilterProps
operator|.
name|add
argument_list|(
name|props
argument_list|)
expr_stmt|;
block|}
name|analyzerProps
operator|.
name|add
argument_list|(
name|CHAR_FILTERS
argument_list|,
name|charFilterProps
argument_list|)
expr_stmt|;
block|}
name|SimpleOrderedMap
argument_list|<
name|Object
argument_list|>
name|tokenizerProps
init|=
operator|new
name|SimpleOrderedMap
argument_list|<>
argument_list|()
decl_stmt|;
name|TokenizerFactory
name|tokenizerFactory
init|=
name|tokenizerChain
operator|.
name|getTokenizerFactory
argument_list|()
decl_stmt|;
name|tokenizerProps
operator|.
name|add
argument_list|(
name|CLASS_NAME
argument_list|,
name|tokenizerFactory
operator|.
name|getClassArg
argument_list|()
argument_list|)
expr_stmt|;
name|factoryArgs
operator|=
name|tokenizerFactory
operator|.
name|getOriginalArgs
argument_list|()
expr_stmt|;
if|if
condition|(
literal|null
operator|!=
name|factoryArgs
condition|)
block|{
for|for
control|(
name|String
name|key
range|:
name|factoryArgs
operator|.
name|keySet
argument_list|()
control|)
block|{
if|if
condition|(
operator|!
name|CLASS_NAME
operator|.
name|equals
argument_list|(
name|key
argument_list|)
condition|)
block|{
if|if
condition|(
name|LUCENE_MATCH_VERSION_PARAM
operator|.
name|equals
argument_list|(
name|key
argument_list|)
condition|)
block|{
if|if
condition|(
name|tokenizerFactory
operator|.
name|isExplicitLuceneMatchVersion
argument_list|()
condition|)
block|{
name|tokenizerProps
operator|.
name|add
argument_list|(
name|key
argument_list|,
name|factoryArgs
operator|.
name|get
argument_list|(
name|key
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|tokenizerProps
operator|.
name|add
argument_list|(
name|key
argument_list|,
name|factoryArgs
operator|.
name|get
argument_list|(
name|key
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
name|analyzerProps
operator|.
name|add
argument_list|(
name|TOKENIZER
argument_list|,
name|tokenizerProps
argument_list|)
expr_stmt|;
name|TokenFilterFactory
index|[]
name|filterFactories
init|=
name|tokenizerChain
operator|.
name|getTokenFilterFactories
argument_list|()
decl_stmt|;
if|if
condition|(
literal|0
operator|<
name|filterFactories
operator|.
name|length
condition|)
block|{
name|List
argument_list|<
name|SimpleOrderedMap
argument_list|<
name|Object
argument_list|>
argument_list|>
name|filterProps
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|TokenFilterFactory
name|filterFactory
range|:
name|filterFactories
control|)
block|{
name|SimpleOrderedMap
argument_list|<
name|Object
argument_list|>
name|props
init|=
operator|new
name|SimpleOrderedMap
argument_list|<>
argument_list|()
decl_stmt|;
name|props
operator|.
name|add
argument_list|(
name|CLASS_NAME
argument_list|,
name|filterFactory
operator|.
name|getClassArg
argument_list|()
argument_list|)
expr_stmt|;
name|factoryArgs
operator|=
name|filterFactory
operator|.
name|getOriginalArgs
argument_list|()
expr_stmt|;
if|if
condition|(
literal|null
operator|!=
name|factoryArgs
condition|)
block|{
for|for
control|(
name|String
name|key
range|:
name|factoryArgs
operator|.
name|keySet
argument_list|()
control|)
block|{
if|if
condition|(
operator|!
name|CLASS_NAME
operator|.
name|equals
argument_list|(
name|key
argument_list|)
condition|)
block|{
if|if
condition|(
name|LUCENE_MATCH_VERSION_PARAM
operator|.
name|equals
argument_list|(
name|key
argument_list|)
condition|)
block|{
if|if
condition|(
name|filterFactory
operator|.
name|isExplicitLuceneMatchVersion
argument_list|()
condition|)
block|{
name|props
operator|.
name|add
argument_list|(
name|key
argument_list|,
name|factoryArgs
operator|.
name|get
argument_list|(
name|key
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|props
operator|.
name|add
argument_list|(
name|key
argument_list|,
name|factoryArgs
operator|.
name|get
argument_list|(
name|key
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
name|filterProps
operator|.
name|add
argument_list|(
name|props
argument_list|)
expr_stmt|;
block|}
name|analyzerProps
operator|.
name|add
argument_list|(
name|FILTERS
argument_list|,
name|filterProps
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// analyzer is not instanceof TokenizerChain
name|analyzerProps
operator|.
name|add
argument_list|(
name|CLASS_NAME
argument_list|,
name|analyzer
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|analyzer
operator|.
name|getVersion
argument_list|()
operator|!=
name|Version
operator|.
name|LATEST
condition|)
block|{
name|analyzerProps
operator|.
name|add
argument_list|(
name|LUCENE_MATCH_VERSION_PARAM
argument_list|,
name|analyzer
operator|.
name|getVersion
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|analyzerProps
return|;
block|}
comment|/**Converts any Object to a java Object native to this field type    */
DECL|method|toNativeType
specifier|public
name|Object
name|toNativeType
parameter_list|(
name|Object
name|val
parameter_list|)
block|{
return|return
name|val
return|;
block|}
comment|/**     * Convert a value used by the FieldComparator for this FieldType's SortField    * into a marshalable value for distributed sorting.    */
DECL|method|marshalSortValue
specifier|public
name|Object
name|marshalSortValue
parameter_list|(
name|Object
name|value
parameter_list|)
block|{
return|return
name|value
return|;
block|}
comment|/**    * Convert a value marshaled via {@link #marshalSortValue} back     * into a value usable by the FieldComparator for this FieldType's SortField    */
DECL|method|unmarshalSortValue
specifier|public
name|Object
name|unmarshalSortValue
parameter_list|(
name|Object
name|value
parameter_list|)
block|{
return|return
name|value
return|;
block|}
comment|/**    * Marshals a string-based field value.    */
DECL|method|marshalStringSortValue
specifier|protected
specifier|static
name|Object
name|marshalStringSortValue
parameter_list|(
name|Object
name|value
parameter_list|)
block|{
if|if
condition|(
literal|null
operator|==
name|value
condition|)
block|{
return|return
literal|null
return|;
block|}
name|CharsRefBuilder
name|spare
init|=
operator|new
name|CharsRefBuilder
argument_list|()
decl_stmt|;
name|spare
operator|.
name|copyUTF8Bytes
argument_list|(
operator|(
name|BytesRef
operator|)
name|value
argument_list|)
expr_stmt|;
return|return
name|spare
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**    * Unmarshals a string-based field value.    */
DECL|method|unmarshalStringSortValue
specifier|protected
specifier|static
name|Object
name|unmarshalStringSortValue
parameter_list|(
name|Object
name|value
parameter_list|)
block|{
if|if
condition|(
literal|null
operator|==
name|value
condition|)
block|{
return|return
literal|null
return|;
block|}
name|BytesRefBuilder
name|spare
init|=
operator|new
name|BytesRefBuilder
argument_list|()
decl_stmt|;
name|String
name|stringVal
init|=
operator|(
name|String
operator|)
name|value
decl_stmt|;
name|spare
operator|.
name|copyChars
argument_list|(
name|stringVal
argument_list|)
expr_stmt|;
return|return
name|spare
operator|.
name|get
argument_list|()
return|;
block|}
comment|/**    * Marshals a binary field value.    */
DECL|method|marshalBase64SortValue
specifier|protected
specifier|static
name|Object
name|marshalBase64SortValue
parameter_list|(
name|Object
name|value
parameter_list|)
block|{
if|if
condition|(
literal|null
operator|==
name|value
condition|)
block|{
return|return
literal|null
return|;
block|}
specifier|final
name|BytesRef
name|val
init|=
operator|(
name|BytesRef
operator|)
name|value
decl_stmt|;
return|return
name|Base64
operator|.
name|byteArrayToBase64
argument_list|(
name|val
operator|.
name|bytes
argument_list|,
name|val
operator|.
name|offset
argument_list|,
name|val
operator|.
name|length
argument_list|)
return|;
block|}
comment|/**    * Unmarshals a binary field value.    */
DECL|method|unmarshalBase64SortValue
specifier|protected
specifier|static
name|Object
name|unmarshalBase64SortValue
parameter_list|(
name|Object
name|value
parameter_list|)
block|{
if|if
condition|(
literal|null
operator|==
name|value
condition|)
block|{
return|return
literal|null
return|;
block|}
specifier|final
name|String
name|val
init|=
operator|(
name|String
operator|)
name|value
decl_stmt|;
specifier|final
name|byte
index|[]
name|bytes
init|=
name|Base64
operator|.
name|base64ToByteArray
argument_list|(
name|val
argument_list|)
decl_stmt|;
return|return
operator|new
name|BytesRef
argument_list|(
name|bytes
argument_list|)
return|;
block|}
comment|/**    * An enumeration representing various options that may exist for selecting a single value from a     * multivalued field.  This class is designed to be an abstract representation, agnostic of some of     * the underlying specifics.  Not all enum value are garunteeded work in all contexts -- null checks     * must be dont by the caller for the specific methods needed.    *    * @see FieldType#getSingleValueSource    */
DECL|enum|MultiValueSelector
specifier|public
enum|enum
name|MultiValueSelector
block|{
comment|// trying to be agnostic about SortedSetSelector.Type vs SortedNumericSelector.Type
DECL|enum constant|MIN
name|MIN
parameter_list|(
name|SortedSetSelector
operator|.
name|Type
operator|.
name|MIN
parameter_list|,
name|SortedNumericSelector
operator|.
name|Type
operator|.
name|MIN
parameter_list|)
operator|,
constructor|MAX(SortedSetSelector.Type.MAX
DECL|enum constant|MAX
operator|,
constructor|SortedNumericSelector.Type.MAX
block|)
enum|;
annotation|@
name|Override
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|super
operator|.
name|toString
argument_list|()
operator|.
name|toLowerCase
argument_list|(
name|Locale
operator|.
name|ROOT
argument_list|)
return|;
block|}
comment|/**       * The appropriate<code>SortedSetSelector.Type</code> option for this<code>MultiValueSelector</code>,      * may be null if there is no equivilent      */
DECL|method|getSortedSetSelectorType
specifier|public
name|SortedSetSelector
operator|.
name|Type
name|getSortedSetSelectorType
parameter_list|()
block|{
return|return
name|sType
return|;
block|}
comment|/**       * The appropriate<code>SortedNumericSelector.Type</code> option for this<code>MultiValueSelector</code>,      * may be null if there is no equivilent      */
DECL|method|getSortedNumericSelectorType
specifier|public
name|SortedNumericSelector
operator|.
name|Type
name|getSortedNumericSelectorType
parameter_list|()
block|{
return|return
name|nType
return|;
block|}
DECL|field|sType
specifier|private
specifier|final
name|SortedSetSelector
operator|.
name|Type
name|sType
decl_stmt|;
DECL|field|nType
specifier|private
specifier|final
name|SortedNumericSelector
operator|.
name|Type
name|nType
decl_stmt|;
DECL|method|MultiValueSelector
specifier|private
name|MultiValueSelector
parameter_list|(
name|SortedSetSelector
operator|.
name|Type
name|sType
parameter_list|,
name|SortedNumericSelector
operator|.
name|Type
name|nType
parameter_list|)
block|{
name|this
operator|.
name|sType
operator|=
name|sType
expr_stmt|;
name|this
operator|.
name|nType
operator|=
name|nType
expr_stmt|;
block|}
comment|/**      * Returns a MultiValueSelector matching the specified (case insensitive) label, or null if       * no corrisponding MultiValueSelector exists.      *       * @param label a non null label to be checked for a corrisponding MultiValueSelector      * @return a MultiValueSelector or null if no MultiValueSelector matches the specified label      */
DECL|method|lookup
specifier|public
specifier|static
name|MultiValueSelector
name|lookup
parameter_list|(
name|String
name|label
parameter_list|)
block|{
if|if
condition|(
literal|null
operator|==
name|label
condition|)
block|{
throw|throw
operator|new
name|NullPointerException
argument_list|(
literal|"label must not be null when calling MultiValueSelector.lookup"
argument_list|)
throw|;
block|}
try|try
block|{
return|return
name|valueOf
argument_list|(
name|label
operator|.
name|toUpperCase
argument_list|(
name|Locale
operator|.
name|ROOT
argument_list|)
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|e
parameter_list|)
block|{
return|return
literal|null
return|;
block|}
block|}
block|}
end_class
unit|}
end_unit
