begin_unit
begin_package
DECL|package|org.apache.solr.schema
package|package
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|schema
package|;
end_package
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileOutputStream
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStreamWriter
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|StringWriter
import|;
end_import
begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|invoke
operator|.
name|MethodHandles
import|;
end_import
begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|charset
operator|.
name|StandardCharsets
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Callable
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ExecutionException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ExecutorService
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Future
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|io
operator|.
name|IOUtils
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|Analyzer
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|util
operator|.
name|CharFilterFactory
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|util
operator|.
name|ResourceLoaderAware
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|util
operator|.
name|TokenFilterFactory
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|util
operator|.
name|TokenizerFactory
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|analysis
operator|.
name|TokenizerChain
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|client
operator|.
name|solrj
operator|.
name|SolrClient
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|client
operator|.
name|solrj
operator|.
name|SolrRequest
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|client
operator|.
name|solrj
operator|.
name|SolrResponse
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|client
operator|.
name|solrj
operator|.
name|impl
operator|.
name|HttpSolrClient
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|cloud
operator|.
name|ZkController
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|cloud
operator|.
name|ZkSolrResourceLoader
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|SolrException
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|SolrException
operator|.
name|ErrorCode
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|cloud
operator|.
name|ClusterState
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|cloud
operator|.
name|Replica
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|cloud
operator|.
name|Slice
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|cloud
operator|.
name|SolrZkClient
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|cloud
operator|.
name|ZkCoreNodeProps
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|cloud
operator|.
name|ZkStateReader
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|params
operator|.
name|ModifiableSolrParams
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|params
operator|.
name|SolrParams
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|util
operator|.
name|ContentStream
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|util
operator|.
name|ExecutorUtil
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|util
operator|.
name|NamedList
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|core
operator|.
name|SolrConfig
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|core
operator|.
name|SolrResourceLoader
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|rest
operator|.
name|schema
operator|.
name|FieldTypeXmlAdapter
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|util
operator|.
name|DefaultSolrThreadFactory
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|util
operator|.
name|FileUtils
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|util
operator|.
name|RTimer
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|CreateMode
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|KeeperException
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|data
operator|.
name|Stat
import|;
end_import
begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import
begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import
begin_import
import|import
name|org
operator|.
name|xml
operator|.
name|sax
operator|.
name|InputSource
import|;
end_import
begin_comment
comment|/** Solr-managed schema - non-user-editable, but can be mutable via internal and external REST API requests. */
end_comment
begin_class
DECL|class|ManagedIndexSchema
specifier|public
specifier|final
class|class
name|ManagedIndexSchema
extends|extends
name|IndexSchema
block|{
DECL|field|isMutable
specifier|private
name|boolean
name|isMutable
init|=
literal|false
decl_stmt|;
DECL|method|isMutable
annotation|@
name|Override
specifier|public
name|boolean
name|isMutable
parameter_list|()
block|{
return|return
name|isMutable
return|;
block|}
DECL|field|managedSchemaResourceName
specifier|final
name|String
name|managedSchemaResourceName
decl_stmt|;
DECL|field|schemaZkVersion
name|int
name|schemaZkVersion
decl_stmt|;
DECL|field|schemaUpdateLock
specifier|final
name|Object
name|schemaUpdateLock
decl_stmt|;
DECL|field|log
specifier|private
specifier|static
specifier|final
name|Logger
name|log
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|MethodHandles
operator|.
name|lookup
argument_list|()
operator|.
name|lookupClass
argument_list|()
argument_list|)
decl_stmt|;
comment|/**    * Constructs a schema using the specified resource name and stream.    *    * @see org.apache.solr.core.SolrResourceLoader#openSchema    *      By default, this follows the normal config path directory searching rules.    * @see org.apache.solr.core.SolrResourceLoader#openResource    */
DECL|method|ManagedIndexSchema
name|ManagedIndexSchema
parameter_list|(
name|SolrConfig
name|solrConfig
parameter_list|,
name|String
name|name
parameter_list|,
name|InputSource
name|is
parameter_list|,
name|boolean
name|isMutable
parameter_list|,
name|String
name|managedSchemaResourceName
parameter_list|,
name|int
name|schemaZkVersion
parameter_list|,
name|Object
name|schemaUpdateLock
parameter_list|)
throws|throws
name|KeeperException
throws|,
name|InterruptedException
block|{
name|super
argument_list|(
name|solrConfig
argument_list|,
name|name
argument_list|,
name|is
argument_list|)
expr_stmt|;
name|this
operator|.
name|isMutable
operator|=
name|isMutable
expr_stmt|;
name|this
operator|.
name|managedSchemaResourceName
operator|=
name|managedSchemaResourceName
expr_stmt|;
name|this
operator|.
name|schemaZkVersion
operator|=
name|schemaZkVersion
expr_stmt|;
name|this
operator|.
name|schemaUpdateLock
operator|=
name|schemaUpdateLock
expr_stmt|;
block|}
comment|/** Persist the schema to local storage or to ZooKeeper */
DECL|method|persistManagedSchema
name|boolean
name|persistManagedSchema
parameter_list|(
name|boolean
name|createOnly
parameter_list|)
block|{
if|if
condition|(
name|loader
operator|instanceof
name|ZkSolrResourceLoader
condition|)
block|{
return|return
name|persistManagedSchemaToZooKeeper
argument_list|(
name|createOnly
argument_list|)
return|;
block|}
comment|// Persist locally
name|File
name|managedSchemaFile
init|=
operator|new
name|File
argument_list|(
name|loader
operator|.
name|getConfigDir
argument_list|()
argument_list|,
name|managedSchemaResourceName
argument_list|)
decl_stmt|;
name|OutputStreamWriter
name|writer
init|=
literal|null
decl_stmt|;
try|try
block|{
name|File
name|parentDir
init|=
name|managedSchemaFile
operator|.
name|getParentFile
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|parentDir
operator|.
name|isDirectory
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|parentDir
operator|.
name|mkdirs
argument_list|()
condition|)
block|{
specifier|final
name|String
name|msg
init|=
literal|"Can't create managed schema directory "
operator|+
name|parentDir
operator|.
name|getAbsolutePath
argument_list|()
decl_stmt|;
name|log
operator|.
name|error
argument_list|(
name|msg
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|SERVER_ERROR
argument_list|,
name|msg
argument_list|)
throw|;
block|}
block|}
specifier|final
name|FileOutputStream
name|out
init|=
operator|new
name|FileOutputStream
argument_list|(
name|managedSchemaFile
argument_list|)
decl_stmt|;
name|writer
operator|=
operator|new
name|OutputStreamWriter
argument_list|(
name|out
argument_list|,
name|StandardCharsets
operator|.
name|UTF_8
argument_list|)
expr_stmt|;
name|persist
argument_list|(
name|writer
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Upgraded to managed schema at "
operator|+
name|managedSchemaFile
operator|.
name|getPath
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
specifier|final
name|String
name|msg
init|=
literal|"Error persisting managed schema "
operator|+
name|managedSchemaFile
decl_stmt|;
name|log
operator|.
name|error
argument_list|(
name|msg
argument_list|,
name|e
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|SERVER_ERROR
argument_list|,
name|msg
argument_list|,
name|e
argument_list|)
throw|;
block|}
finally|finally
block|{
name|IOUtils
operator|.
name|closeQuietly
argument_list|(
name|writer
argument_list|)
expr_stmt|;
try|try
block|{
name|FileUtils
operator|.
name|sync
argument_list|(
name|managedSchemaFile
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
specifier|final
name|String
name|msg
init|=
literal|"Error syncing the managed schema file "
operator|+
name|managedSchemaFile
decl_stmt|;
name|log
operator|.
name|error
argument_list|(
name|msg
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|true
return|;
block|}
comment|/**    * Persists the managed schema to ZooKeeper using optimistic concurrency.    *<p/>    * If createOnly is true, success is when the schema is created or if it previously existed.    *<p/>    * If createOnly is false, success is when the schema is persisted - this will only happen    * if schemaZkVersion matches the version in ZooKeeper.    *     * @return true on success     */
DECL|method|persistManagedSchemaToZooKeeper
name|boolean
name|persistManagedSchemaToZooKeeper
parameter_list|(
name|boolean
name|createOnly
parameter_list|)
block|{
specifier|final
name|ZkSolrResourceLoader
name|zkLoader
init|=
operator|(
name|ZkSolrResourceLoader
operator|)
name|loader
decl_stmt|;
specifier|final
name|ZkController
name|zkController
init|=
name|zkLoader
operator|.
name|getZkController
argument_list|()
decl_stmt|;
specifier|final
name|SolrZkClient
name|zkClient
init|=
name|zkController
operator|.
name|getZkClient
argument_list|()
decl_stmt|;
specifier|final
name|String
name|managedSchemaPath
init|=
name|zkLoader
operator|.
name|getConfigSetZkPath
argument_list|()
operator|+
literal|"/"
operator|+
name|managedSchemaResourceName
decl_stmt|;
name|boolean
name|success
init|=
literal|true
decl_stmt|;
name|boolean
name|schemaChangedInZk
init|=
literal|false
decl_stmt|;
try|try
block|{
comment|// Persist the managed schema
name|StringWriter
name|writer
init|=
operator|new
name|StringWriter
argument_list|()
decl_stmt|;
name|persist
argument_list|(
name|writer
argument_list|)
expr_stmt|;
specifier|final
name|byte
index|[]
name|data
init|=
name|writer
operator|.
name|toString
argument_list|()
operator|.
name|getBytes
argument_list|(
name|StandardCharsets
operator|.
name|UTF_8
argument_list|)
decl_stmt|;
if|if
condition|(
name|createOnly
condition|)
block|{
try|try
block|{
name|zkClient
operator|.
name|create
argument_list|(
name|managedSchemaPath
argument_list|,
name|data
argument_list|,
name|CreateMode
operator|.
name|PERSISTENT
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|schemaZkVersion
operator|=
literal|0
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Created and persisted managed schema znode at "
operator|+
name|managedSchemaPath
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|KeeperException
operator|.
name|NodeExistsException
name|e
parameter_list|)
block|{
comment|// This is okay - do nothing and fall through
name|log
operator|.
name|info
argument_list|(
literal|"Managed schema znode at "
operator|+
name|managedSchemaPath
operator|+
literal|" already exists - no need to create it"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
try|try
block|{
comment|// Assumption: the path exists
name|Stat
name|stat
init|=
name|zkClient
operator|.
name|setData
argument_list|(
name|managedSchemaPath
argument_list|,
name|data
argument_list|,
name|schemaZkVersion
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|schemaZkVersion
operator|=
name|stat
operator|.
name|getVersion
argument_list|()
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Persisted managed schema version "
operator|+
name|schemaZkVersion
operator|+
literal|" at "
operator|+
name|managedSchemaPath
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|KeeperException
operator|.
name|BadVersionException
name|e
parameter_list|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"Bad version when trying to persist schema using "
operator|+
name|schemaZkVersion
operator|+
literal|" due to: "
operator|+
name|e
argument_list|)
expr_stmt|;
name|success
operator|=
literal|false
expr_stmt|;
name|schemaChangedInZk
operator|=
literal|true
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
if|if
condition|(
name|e
operator|instanceof
name|InterruptedException
condition|)
block|{
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
comment|// Restore the interrupted status
block|}
specifier|final
name|String
name|msg
init|=
literal|"Error persisting managed schema at "
operator|+
name|managedSchemaPath
decl_stmt|;
name|log
operator|.
name|error
argument_list|(
name|msg
argument_list|,
name|e
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|SERVER_ERROR
argument_list|,
name|msg
argument_list|,
name|e
argument_list|)
throw|;
block|}
if|if
condition|(
name|schemaChangedInZk
condition|)
block|{
name|String
name|msg
init|=
literal|"Failed to persist managed schema at "
operator|+
name|managedSchemaPath
operator|+
literal|" - version mismatch"
decl_stmt|;
name|log
operator|.
name|info
argument_list|(
name|msg
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|SchemaChangedInZkException
argument_list|(
name|ErrorCode
operator|.
name|CONFLICT
argument_list|,
name|msg
operator|+
literal|", retry."
argument_list|)
throw|;
block|}
return|return
name|success
return|;
block|}
comment|/**    * Block up to a specified maximum time until we see agreement on the schema    * version in ZooKeeper across all replicas for a collection.    */
DECL|method|waitForSchemaZkVersionAgreement
specifier|public
specifier|static
name|void
name|waitForSchemaZkVersionAgreement
parameter_list|(
name|String
name|collection
parameter_list|,
name|String
name|localCoreNodeName
parameter_list|,
name|int
name|schemaZkVersion
parameter_list|,
name|ZkController
name|zkController
parameter_list|,
name|int
name|maxWaitSecs
parameter_list|)
block|{
name|RTimer
name|timer
init|=
operator|new
name|RTimer
argument_list|()
decl_stmt|;
comment|// get a list of active replica cores to query for the schema zk version (skipping this core of course)
name|List
argument_list|<
name|GetZkSchemaVersionCallable
argument_list|>
name|concurrentTasks
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|coreUrl
range|:
name|getActiveReplicaCoreUrls
argument_list|(
name|zkController
argument_list|,
name|collection
argument_list|,
name|localCoreNodeName
argument_list|)
control|)
name|concurrentTasks
operator|.
name|add
argument_list|(
operator|new
name|GetZkSchemaVersionCallable
argument_list|(
name|coreUrl
argument_list|,
name|schemaZkVersion
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|concurrentTasks
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
comment|// nothing to wait for ...
name|log
operator|.
name|info
argument_list|(
literal|"Waiting up to "
operator|+
name|maxWaitSecs
operator|+
literal|" secs for "
operator|+
name|concurrentTasks
operator|.
name|size
argument_list|()
operator|+
literal|" replicas to apply schema update version "
operator|+
name|schemaZkVersion
operator|+
literal|" for collection "
operator|+
name|collection
argument_list|)
expr_stmt|;
comment|// use an executor service to invoke schema zk version requests in parallel with a max wait time
name|int
name|poolSize
init|=
name|Math
operator|.
name|min
argument_list|(
name|concurrentTasks
operator|.
name|size
argument_list|()
argument_list|,
literal|10
argument_list|)
decl_stmt|;
name|ExecutorService
name|parallelExecutor
init|=
name|ExecutorUtil
operator|.
name|newMDCAwareFixedThreadPool
argument_list|(
name|poolSize
argument_list|,
operator|new
name|DefaultSolrThreadFactory
argument_list|(
literal|"managedSchemaExecutor"
argument_list|)
argument_list|)
decl_stmt|;
try|try
block|{
name|List
argument_list|<
name|Future
argument_list|<
name|Integer
argument_list|>
argument_list|>
name|results
init|=
name|parallelExecutor
operator|.
name|invokeAll
argument_list|(
name|concurrentTasks
argument_list|,
name|maxWaitSecs
argument_list|,
name|TimeUnit
operator|.
name|SECONDS
argument_list|)
decl_stmt|;
comment|// determine whether all replicas have the update
name|List
argument_list|<
name|String
argument_list|>
name|failedList
init|=
literal|null
decl_stmt|;
comment|// lazily init'd
for|for
control|(
name|int
name|f
init|=
literal|0
init|;
name|f
operator|<
name|results
operator|.
name|size
argument_list|()
condition|;
name|f
operator|++
control|)
block|{
name|int
name|vers
init|=
operator|-
literal|1
decl_stmt|;
name|Future
argument_list|<
name|Integer
argument_list|>
name|next
init|=
name|results
operator|.
name|get
argument_list|(
name|f
argument_list|)
decl_stmt|;
if|if
condition|(
name|next
operator|.
name|isDone
argument_list|()
operator|&&
operator|!
name|next
operator|.
name|isCancelled
argument_list|()
condition|)
block|{
comment|// looks to have finished, but need to check the version value too
try|try
block|{
name|vers
operator|=
name|next
operator|.
name|get
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ExecutionException
name|e
parameter_list|)
block|{
comment|// shouldn't happen since we checked isCancelled
block|}
block|}
if|if
condition|(
name|vers
operator|==
operator|-
literal|1
condition|)
block|{
name|String
name|coreUrl
init|=
name|concurrentTasks
operator|.
name|get
argument_list|(
name|f
argument_list|)
operator|.
name|coreUrl
decl_stmt|;
name|log
operator|.
name|warn
argument_list|(
literal|"Core "
operator|+
name|coreUrl
operator|+
literal|" version mismatch! Expected "
operator|+
name|schemaZkVersion
operator|+
literal|" but got "
operator|+
name|vers
argument_list|)
expr_stmt|;
if|if
condition|(
name|failedList
operator|==
literal|null
condition|)
name|failedList
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
expr_stmt|;
name|failedList
operator|.
name|add
argument_list|(
name|coreUrl
argument_list|)
expr_stmt|;
block|}
block|}
comment|// if any tasks haven't completed within the specified timeout, it's an error
if|if
condition|(
name|failedList
operator|!=
literal|null
condition|)
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|SERVER_ERROR
argument_list|,
name|failedList
operator|.
name|size
argument_list|()
operator|+
literal|" out of "
operator|+
operator|(
name|concurrentTasks
operator|.
name|size
argument_list|()
operator|+
literal|1
operator|)
operator|+
literal|" replicas failed to update their schema to version "
operator|+
name|schemaZkVersion
operator|+
literal|" within "
operator|+
name|maxWaitSecs
operator|+
literal|" seconds! Failed cores: "
operator|+
name|failedList
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Core "
operator|+
name|localCoreNodeName
operator|+
literal|" was interrupted waiting for schema version "
operator|+
name|schemaZkVersion
operator|+
literal|" to propagate to "
operator|+
name|concurrentTasks
operator|.
name|size
argument_list|()
operator|+
literal|" replicas for collection "
operator|+
name|collection
argument_list|)
expr_stmt|;
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
operator|!
name|parallelExecutor
operator|.
name|isShutdown
argument_list|()
condition|)
name|parallelExecutor
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
name|log
operator|.
name|info
argument_list|(
literal|"Took {}ms for {} replicas to apply schema update version {} for collection {}"
argument_list|,
name|timer
operator|.
name|getTime
argument_list|()
argument_list|,
name|concurrentTasks
operator|.
name|size
argument_list|()
argument_list|,
name|schemaZkVersion
argument_list|,
name|collection
argument_list|)
expr_stmt|;
block|}
DECL|method|getActiveReplicaCoreUrls
specifier|protected
specifier|static
name|List
argument_list|<
name|String
argument_list|>
name|getActiveReplicaCoreUrls
parameter_list|(
name|ZkController
name|zkController
parameter_list|,
name|String
name|collection
parameter_list|,
name|String
name|localCoreNodeName
parameter_list|)
block|{
name|List
argument_list|<
name|String
argument_list|>
name|activeReplicaCoreUrls
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|ZkStateReader
name|zkStateReader
init|=
name|zkController
operator|.
name|getZkStateReader
argument_list|()
decl_stmt|;
name|ClusterState
name|clusterState
init|=
name|zkStateReader
operator|.
name|getClusterState
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|String
argument_list|>
name|liveNodes
init|=
name|clusterState
operator|.
name|getLiveNodes
argument_list|()
decl_stmt|;
name|Collection
argument_list|<
name|Slice
argument_list|>
name|activeSlices
init|=
name|clusterState
operator|.
name|getActiveSlices
argument_list|(
name|collection
argument_list|)
decl_stmt|;
if|if
condition|(
name|activeSlices
operator|!=
literal|null
operator|&&
name|activeSlices
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|Slice
name|next
range|:
name|activeSlices
control|)
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|Replica
argument_list|>
name|replicasMap
init|=
name|next
operator|.
name|getReplicasMap
argument_list|()
decl_stmt|;
if|if
condition|(
name|replicasMap
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|Replica
argument_list|>
name|entry
range|:
name|replicasMap
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|Replica
name|replica
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|localCoreNodeName
operator|.
name|equals
argument_list|(
name|replica
operator|.
name|getName
argument_list|()
argument_list|)
operator|&&
name|replica
operator|.
name|getState
argument_list|()
operator|==
name|Replica
operator|.
name|State
operator|.
name|ACTIVE
operator|&&
name|liveNodes
operator|.
name|contains
argument_list|(
name|replica
operator|.
name|getNodeName
argument_list|()
argument_list|)
condition|)
block|{
name|ZkCoreNodeProps
name|replicaCoreProps
init|=
operator|new
name|ZkCoreNodeProps
argument_list|(
name|replica
argument_list|)
decl_stmt|;
name|activeReplicaCoreUrls
operator|.
name|add
argument_list|(
name|replicaCoreProps
operator|.
name|getCoreUrl
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
return|return
name|activeReplicaCoreUrls
return|;
block|}
DECL|class|GetZkSchemaVersionCallable
specifier|private
specifier|static
class|class
name|GetZkSchemaVersionCallable
extends|extends
name|SolrRequest
implements|implements
name|Callable
argument_list|<
name|Integer
argument_list|>
block|{
DECL|field|coreUrl
specifier|private
name|String
name|coreUrl
decl_stmt|;
DECL|field|expectedZkVersion
specifier|private
name|int
name|expectedZkVersion
decl_stmt|;
DECL|method|GetZkSchemaVersionCallable
name|GetZkSchemaVersionCallable
parameter_list|(
name|String
name|coreUrl
parameter_list|,
name|int
name|expectedZkVersion
parameter_list|)
block|{
name|super
argument_list|(
name|METHOD
operator|.
name|GET
argument_list|,
literal|"/schema/zkversion"
argument_list|)
expr_stmt|;
name|this
operator|.
name|coreUrl
operator|=
name|coreUrl
expr_stmt|;
name|this
operator|.
name|expectedZkVersion
operator|=
name|expectedZkVersion
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|getParams
specifier|public
name|SolrParams
name|getParams
parameter_list|()
block|{
name|ModifiableSolrParams
name|wparams
init|=
operator|new
name|ModifiableSolrParams
argument_list|()
decl_stmt|;
name|wparams
operator|.
name|set
argument_list|(
literal|"refreshIfBelowVersion"
argument_list|,
name|expectedZkVersion
argument_list|)
expr_stmt|;
return|return
name|wparams
return|;
block|}
annotation|@
name|Override
DECL|method|call
specifier|public
name|Integer
name|call
parameter_list|()
throws|throws
name|Exception
block|{
name|int
name|remoteVersion
init|=
operator|-
literal|1
decl_stmt|;
try|try
init|(
name|HttpSolrClient
name|solr
init|=
operator|new
name|HttpSolrClient
argument_list|(
name|coreUrl
argument_list|)
init|)
block|{
comment|// eventually, this loop will get killed by the ExecutorService's timeout
while|while
condition|(
name|remoteVersion
operator|==
operator|-
literal|1
operator|||
name|remoteVersion
operator|<
name|expectedZkVersion
condition|)
block|{
try|try
block|{
name|HttpSolrClient
operator|.
name|HttpUriRequestResponse
name|mrr
init|=
name|solr
operator|.
name|httpUriRequest
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|NamedList
argument_list|<
name|Object
argument_list|>
name|zkversionResp
init|=
name|mrr
operator|.
name|future
operator|.
name|get
argument_list|()
decl_stmt|;
if|if
condition|(
name|zkversionResp
operator|!=
literal|null
condition|)
name|remoteVersion
operator|=
operator|(
name|Integer
operator|)
name|zkversionResp
operator|.
name|get
argument_list|(
literal|"zkversion"
argument_list|)
expr_stmt|;
if|if
condition|(
name|remoteVersion
operator|<
name|expectedZkVersion
condition|)
block|{
comment|// rather than waiting and re-polling, let's be proactive and tell the replica
comment|// to refresh its schema from ZooKeeper, if that fails, then the
comment|//Thread.sleep(1000); // slight delay before requesting version again
name|log
operator|.
name|error
argument_list|(
literal|"Replica "
operator|+
name|coreUrl
operator|+
literal|" returned schema version "
operator|+
name|remoteVersion
operator|+
literal|" and has not applied schema version "
operator|+
name|expectedZkVersion
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
if|if
condition|(
name|e
operator|instanceof
name|InterruptedException
condition|)
block|{
break|break;
comment|// stop looping
block|}
else|else
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Failed to get /schema/zkversion from "
operator|+
name|coreUrl
operator|+
literal|" due to: "
operator|+
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
name|remoteVersion
return|;
block|}
annotation|@
name|Override
DECL|method|getContentStreams
specifier|public
name|Collection
argument_list|<
name|ContentStream
argument_list|>
name|getContentStreams
parameter_list|()
throws|throws
name|IOException
block|{
return|return
literal|null
return|;
block|}
annotation|@
name|Override
DECL|method|createResponse
specifier|protected
name|SolrResponse
name|createResponse
parameter_list|(
name|SolrClient
name|client
parameter_list|)
block|{
return|return
literal|null
return|;
block|}
block|}
DECL|class|FieldExistsException
specifier|public
class|class
name|FieldExistsException
extends|extends
name|SolrException
block|{
DECL|method|FieldExistsException
specifier|public
name|FieldExistsException
parameter_list|(
name|ErrorCode
name|code
parameter_list|,
name|String
name|msg
parameter_list|)
block|{
name|super
argument_list|(
name|code
argument_list|,
name|msg
argument_list|)
expr_stmt|;
block|}
block|}
DECL|class|SchemaChangedInZkException
specifier|public
class|class
name|SchemaChangedInZkException
extends|extends
name|SolrException
block|{
DECL|method|SchemaChangedInZkException
specifier|public
name|SchemaChangedInZkException
parameter_list|(
name|ErrorCode
name|code
parameter_list|,
name|String
name|msg
parameter_list|)
block|{
name|super
argument_list|(
name|code
argument_list|,
name|msg
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|addFields
specifier|public
name|ManagedIndexSchema
name|addFields
parameter_list|(
name|Collection
argument_list|<
name|SchemaField
argument_list|>
name|newFields
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|Collection
argument_list|<
name|String
argument_list|>
argument_list|>
name|copyFieldNames
parameter_list|,
name|boolean
name|persist
parameter_list|)
block|{
name|ManagedIndexSchema
name|newSchema
decl_stmt|;
if|if
condition|(
name|isMutable
condition|)
block|{
name|boolean
name|success
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|copyFieldNames
operator|==
literal|null
condition|)
block|{
name|copyFieldNames
operator|=
name|Collections
operator|.
name|emptyMap
argument_list|()
expr_stmt|;
block|}
name|newSchema
operator|=
name|shallowCopy
argument_list|(
literal|true
argument_list|)
expr_stmt|;
for|for
control|(
name|SchemaField
name|newField
range|:
name|newFields
control|)
block|{
if|if
condition|(
literal|null
operator|!=
name|newSchema
operator|.
name|fields
operator|.
name|get
argument_list|(
name|newField
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
block|{
name|String
name|msg
init|=
literal|"Field '"
operator|+
name|newField
operator|.
name|getName
argument_list|()
operator|+
literal|"' already exists."
decl_stmt|;
throw|throw
operator|new
name|FieldExistsException
argument_list|(
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
name|msg
argument_list|)
throw|;
block|}
name|newSchema
operator|.
name|fields
operator|.
name|put
argument_list|(
name|newField
operator|.
name|getName
argument_list|()
argument_list|,
name|newField
argument_list|)
expr_stmt|;
if|if
condition|(
literal|null
operator|!=
name|newField
operator|.
name|getDefaultValue
argument_list|()
condition|)
block|{
name|log
operator|.
name|debug
argument_list|(
name|newField
operator|.
name|getName
argument_list|()
operator|+
literal|" contains default value: "
operator|+
name|newField
operator|.
name|getDefaultValue
argument_list|()
argument_list|)
expr_stmt|;
name|newSchema
operator|.
name|fieldsWithDefaultValue
operator|.
name|add
argument_list|(
name|newField
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|newField
operator|.
name|isRequired
argument_list|()
condition|)
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"{} is required in this schema"
argument_list|,
name|newField
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|newSchema
operator|.
name|requiredFields
operator|.
name|add
argument_list|(
name|newField
argument_list|)
expr_stmt|;
block|}
name|Collection
argument_list|<
name|String
argument_list|>
name|copyFields
init|=
name|copyFieldNames
operator|.
name|get
argument_list|(
name|newField
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|copyFields
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|String
name|copyField
range|:
name|copyFields
control|)
block|{
name|newSchema
operator|.
name|registerCopyField
argument_list|(
name|newField
operator|.
name|getName
argument_list|()
argument_list|,
name|copyField
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|newSchema
operator|.
name|postReadInform
argument_list|()
expr_stmt|;
name|newSchema
operator|.
name|refreshAnalyzers
argument_list|()
expr_stmt|;
if|if
condition|(
name|persist
condition|)
block|{
name|success
operator|=
name|newSchema
operator|.
name|persistManagedSchema
argument_list|(
literal|false
argument_list|)
expr_stmt|;
comment|// don't just create - update it if it already exists
if|if
condition|(
name|success
condition|)
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"Added field(s): {}"
argument_list|,
name|newFields
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|log
operator|.
name|error
argument_list|(
literal|"Failed to add field(s): {}"
argument_list|,
name|newFields
argument_list|)
expr_stmt|;
name|newSchema
operator|=
literal|null
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|String
name|msg
init|=
literal|"This ManagedIndexSchema is not mutable."
decl_stmt|;
name|log
operator|.
name|error
argument_list|(
name|msg
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|SERVER_ERROR
argument_list|,
name|msg
argument_list|)
throw|;
block|}
return|return
name|newSchema
return|;
block|}
annotation|@
name|Override
DECL|method|deleteFields
specifier|public
name|ManagedIndexSchema
name|deleteFields
parameter_list|(
name|Collection
argument_list|<
name|String
argument_list|>
name|names
parameter_list|)
block|{
name|ManagedIndexSchema
name|newSchema
decl_stmt|;
if|if
condition|(
name|isMutable
condition|)
block|{
name|newSchema
operator|=
name|shallowCopy
argument_list|(
literal|true
argument_list|)
expr_stmt|;
for|for
control|(
name|String
name|name
range|:
name|names
control|)
block|{
name|SchemaField
name|field
init|=
name|getFieldOrNull
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
literal|null
operator|!=
name|field
condition|)
block|{
name|String
name|message
init|=
literal|"Can't delete field '"
operator|+
name|name
operator|+
literal|"' because it's referred to by at least one copy field directive."
decl_stmt|;
if|if
condition|(
name|newSchema
operator|.
name|copyFieldsMap
operator|.
name|containsKey
argument_list|(
name|name
argument_list|)
operator|||
name|newSchema
operator|.
name|isCopyFieldTarget
argument_list|(
name|field
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
name|message
argument_list|)
throw|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|newSchema
operator|.
name|dynamicCopyFields
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
name|DynamicCopy
name|dynamicCopy
init|=
name|newSchema
operator|.
name|dynamicCopyFields
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|name
operator|.
name|equals
argument_list|(
name|dynamicCopy
operator|.
name|getRegex
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
name|message
argument_list|)
throw|;
block|}
block|}
name|newSchema
operator|.
name|fields
operator|.
name|remove
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|newSchema
operator|.
name|fieldsWithDefaultValue
operator|.
name|remove
argument_list|(
name|field
argument_list|)
expr_stmt|;
name|newSchema
operator|.
name|requiredFields
operator|.
name|remove
argument_list|(
name|field
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|String
name|msg
init|=
literal|"The field '"
operator|+
name|name
operator|+
literal|"' is not present in this schema, and so cannot be deleted."
decl_stmt|;
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
name|msg
argument_list|)
throw|;
block|}
block|}
name|newSchema
operator|.
name|postReadInform
argument_list|()
expr_stmt|;
name|newSchema
operator|.
name|refreshAnalyzers
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|String
name|msg
init|=
literal|"This ManagedIndexSchema is not mutable."
decl_stmt|;
name|log
operator|.
name|error
argument_list|(
name|msg
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|SERVER_ERROR
argument_list|,
name|msg
argument_list|)
throw|;
block|}
return|return
name|newSchema
return|;
block|}
annotation|@
name|Override
DECL|method|replaceField
specifier|public
name|ManagedIndexSchema
name|replaceField
parameter_list|(
name|String
name|fieldName
parameter_list|,
name|FieldType
name|replacementFieldType
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|?
argument_list|>
name|replacementArgs
parameter_list|)
block|{
name|ManagedIndexSchema
name|newSchema
decl_stmt|;
if|if
condition|(
name|isMutable
condition|)
block|{
name|SchemaField
name|oldField
init|=
name|fields
operator|.
name|get
argument_list|(
name|fieldName
argument_list|)
decl_stmt|;
if|if
condition|(
literal|null
operator|==
name|oldField
condition|)
block|{
name|String
name|msg
init|=
literal|"The field '"
operator|+
name|fieldName
operator|+
literal|"' is not present in this schema, and so cannot be replaced."
decl_stmt|;
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
name|msg
argument_list|)
throw|;
block|}
name|newSchema
operator|=
name|shallowCopy
argument_list|(
literal|true
argument_list|)
expr_stmt|;
comment|// clone data structures before modifying them
name|newSchema
operator|.
name|copyFieldsMap
operator|=
name|cloneCopyFieldsMap
argument_list|(
name|copyFieldsMap
argument_list|)
expr_stmt|;
name|newSchema
operator|.
name|copyFieldTargetCounts
operator|=
call|(
name|Map
argument_list|<
name|SchemaField
argument_list|,
name|Integer
argument_list|>
call|)
argument_list|(
operator|(
name|HashMap
argument_list|<
name|SchemaField
argument_list|,
name|Integer
argument_list|>
operator|)
name|copyFieldTargetCounts
argument_list|)
operator|.
name|clone
argument_list|()
expr_stmt|;
name|newSchema
operator|.
name|dynamicCopyFields
operator|=
operator|new
name|DynamicCopy
index|[
name|dynamicCopyFields
operator|.
name|length
index|]
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|dynamicCopyFields
argument_list|,
literal|0
argument_list|,
name|newSchema
operator|.
name|dynamicCopyFields
argument_list|,
literal|0
argument_list|,
name|dynamicCopyFields
operator|.
name|length
argument_list|)
expr_stmt|;
comment|// Drop the old field
name|newSchema
operator|.
name|fields
operator|.
name|remove
argument_list|(
name|fieldName
argument_list|)
expr_stmt|;
name|newSchema
operator|.
name|fieldsWithDefaultValue
operator|.
name|remove
argument_list|(
name|oldField
argument_list|)
expr_stmt|;
name|newSchema
operator|.
name|requiredFields
operator|.
name|remove
argument_list|(
name|oldField
argument_list|)
expr_stmt|;
comment|// Add the replacement field
name|SchemaField
name|replacementField
init|=
name|SchemaField
operator|.
name|create
argument_list|(
name|fieldName
argument_list|,
name|replacementFieldType
argument_list|,
name|replacementArgs
argument_list|)
decl_stmt|;
name|newSchema
operator|.
name|fields
operator|.
name|put
argument_list|(
name|fieldName
argument_list|,
name|replacementField
argument_list|)
expr_stmt|;
if|if
condition|(
literal|null
operator|!=
name|replacementField
operator|.
name|getDefaultValue
argument_list|()
condition|)
block|{
name|log
operator|.
name|debug
argument_list|(
name|replacementField
operator|.
name|getName
argument_list|()
operator|+
literal|" contains default value: "
operator|+
name|replacementField
operator|.
name|getDefaultValue
argument_list|()
argument_list|)
expr_stmt|;
name|newSchema
operator|.
name|fieldsWithDefaultValue
operator|.
name|add
argument_list|(
name|replacementField
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|replacementField
operator|.
name|isRequired
argument_list|()
condition|)
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"{} is required in this schema"
argument_list|,
name|replacementField
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|newSchema
operator|.
name|requiredFields
operator|.
name|add
argument_list|(
name|replacementField
argument_list|)
expr_stmt|;
block|}
name|List
argument_list|<
name|CopyField
argument_list|>
name|copyFieldsToRebuild
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|newSchema
operator|.
name|removeCopyFieldSource
argument_list|(
name|fieldName
argument_list|,
name|copyFieldsToRebuild
argument_list|)
expr_stmt|;
name|newSchema
operator|.
name|copyFieldTargetCounts
operator|.
name|remove
argument_list|(
name|oldField
argument_list|)
expr_stmt|;
comment|// zero out target count for this field
comment|// Remove copy fields where the target is this field; remember them to rebuild
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|CopyField
argument_list|>
argument_list|>
name|entry
range|:
name|newSchema
operator|.
name|copyFieldsMap
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|List
argument_list|<
name|CopyField
argument_list|>
name|perSourceCopyFields
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|Iterator
argument_list|<
name|CopyField
argument_list|>
name|checkDestCopyFieldsIter
init|=
name|perSourceCopyFields
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|checkDestCopyFieldsIter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|CopyField
name|checkDestCopyField
init|=
name|checkDestCopyFieldsIter
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|fieldName
operator|.
name|equals
argument_list|(
name|checkDestCopyField
operator|.
name|getDestination
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
block|{
name|checkDestCopyFieldsIter
operator|.
name|remove
argument_list|()
expr_stmt|;
name|copyFieldsToRebuild
operator|.
name|add
argument_list|(
name|checkDestCopyField
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|newSchema
operator|.
name|rebuildCopyFields
argument_list|(
name|copyFieldsToRebuild
argument_list|)
expr_stmt|;
comment|// Find dynamic copy fields where the source or destination is this field; remember them to rebuild
name|List
argument_list|<
name|DynamicCopy
argument_list|>
name|dynamicCopyFieldsToRebuild
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|DynamicCopy
argument_list|>
name|newDynamicCopyFields
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|newSchema
operator|.
name|dynamicCopyFields
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
name|DynamicCopy
name|dynamicCopy
init|=
name|newSchema
operator|.
name|dynamicCopyFields
index|[
name|i
index|]
decl_stmt|;
name|SchemaField
name|destinationPrototype
init|=
name|dynamicCopy
operator|.
name|getDestination
argument_list|()
operator|.
name|getPrototype
argument_list|()
decl_stmt|;
if|if
condition|(
name|fieldName
operator|.
name|equals
argument_list|(
name|dynamicCopy
operator|.
name|getRegex
argument_list|()
argument_list|)
operator|||
name|fieldName
operator|.
name|equals
argument_list|(
name|destinationPrototype
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
block|{
name|dynamicCopyFieldsToRebuild
operator|.
name|add
argument_list|(
name|dynamicCopy
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|newDynamicCopyFields
operator|.
name|add
argument_list|(
name|dynamicCopy
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Rebuild affected dynamic copy fields
if|if
condition|(
name|dynamicCopyFieldsToRebuild
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|newSchema
operator|.
name|dynamicCopyFields
operator|=
name|newDynamicCopyFields
operator|.
name|toArray
argument_list|(
operator|new
name|DynamicCopy
index|[
name|newDynamicCopyFields
operator|.
name|size
argument_list|()
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|DynamicCopy
name|dynamicCopy
range|:
name|dynamicCopyFieldsToRebuild
control|)
block|{
name|newSchema
operator|.
name|registerCopyField
argument_list|(
name|dynamicCopy
operator|.
name|getRegex
argument_list|()
argument_list|,
name|dynamicCopy
operator|.
name|getDestFieldName
argument_list|()
argument_list|,
name|dynamicCopy
operator|.
name|getMaxChars
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|newSchema
operator|.
name|postReadInform
argument_list|()
expr_stmt|;
name|newSchema
operator|.
name|refreshAnalyzers
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|String
name|msg
init|=
literal|"This ManagedIndexSchema is not mutable."
decl_stmt|;
name|log
operator|.
name|error
argument_list|(
name|msg
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|SERVER_ERROR
argument_list|,
name|msg
argument_list|)
throw|;
block|}
return|return
name|newSchema
return|;
block|}
annotation|@
name|Override
DECL|method|addDynamicFields
specifier|public
name|ManagedIndexSchema
name|addDynamicFields
parameter_list|(
name|Collection
argument_list|<
name|SchemaField
argument_list|>
name|newDynamicFields
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|Collection
argument_list|<
name|String
argument_list|>
argument_list|>
name|copyFieldNames
parameter_list|,
name|boolean
name|persist
parameter_list|)
block|{
name|ManagedIndexSchema
name|newSchema
decl_stmt|;
if|if
condition|(
name|isMutable
condition|)
block|{
name|boolean
name|success
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|copyFieldNames
operator|==
literal|null
condition|)
block|{
name|copyFieldNames
operator|=
name|Collections
operator|.
name|emptyMap
argument_list|()
expr_stmt|;
block|}
name|newSchema
operator|=
name|shallowCopy
argument_list|(
literal|true
argument_list|)
expr_stmt|;
for|for
control|(
name|SchemaField
name|newDynamicField
range|:
name|newDynamicFields
control|)
block|{
name|List
argument_list|<
name|DynamicField
argument_list|>
name|dFields
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|newSchema
operator|.
name|dynamicFields
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|isDuplicateDynField
argument_list|(
name|dFields
argument_list|,
name|newDynamicField
argument_list|)
condition|)
block|{
name|String
name|msg
init|=
literal|"Dynamic field '"
operator|+
name|newDynamicField
operator|.
name|getName
argument_list|()
operator|+
literal|"' already exists."
decl_stmt|;
throw|throw
operator|new
name|FieldExistsException
argument_list|(
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
name|msg
argument_list|)
throw|;
block|}
name|dFields
operator|.
name|add
argument_list|(
operator|new
name|DynamicField
argument_list|(
name|newDynamicField
argument_list|)
argument_list|)
expr_stmt|;
name|newSchema
operator|.
name|dynamicFields
operator|=
name|dynamicFieldListToSortedArray
argument_list|(
name|dFields
argument_list|)
expr_stmt|;
name|Collection
argument_list|<
name|String
argument_list|>
name|copyFields
init|=
name|copyFieldNames
operator|.
name|get
argument_list|(
name|newDynamicField
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|copyFields
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|String
name|copyField
range|:
name|copyFields
control|)
block|{
name|newSchema
operator|.
name|registerCopyField
argument_list|(
name|newDynamicField
operator|.
name|getName
argument_list|()
argument_list|,
name|copyField
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|newSchema
operator|.
name|postReadInform
argument_list|()
expr_stmt|;
name|newSchema
operator|.
name|refreshAnalyzers
argument_list|()
expr_stmt|;
if|if
condition|(
name|persist
condition|)
block|{
name|success
operator|=
name|newSchema
operator|.
name|persistManagedSchema
argument_list|(
literal|false
argument_list|)
expr_stmt|;
comment|// don't just create - update it if it already exists
if|if
condition|(
name|success
condition|)
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"Added dynamic field(s): {}"
argument_list|,
name|newDynamicFields
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|log
operator|.
name|error
argument_list|(
literal|"Failed to add dynamic field(s): {}"
argument_list|,
name|newDynamicFields
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|String
name|msg
init|=
literal|"This ManagedIndexSchema is not mutable."
decl_stmt|;
name|log
operator|.
name|error
argument_list|(
name|msg
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|SERVER_ERROR
argument_list|,
name|msg
argument_list|)
throw|;
block|}
return|return
name|newSchema
return|;
block|}
annotation|@
name|Override
DECL|method|deleteDynamicFields
specifier|public
name|ManagedIndexSchema
name|deleteDynamicFields
parameter_list|(
name|Collection
argument_list|<
name|String
argument_list|>
name|fieldNamePatterns
parameter_list|)
block|{
name|ManagedIndexSchema
name|newSchema
decl_stmt|;
if|if
condition|(
name|isMutable
condition|)
block|{
name|newSchema
operator|=
name|shallowCopy
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|newSchema
operator|.
name|dynamicCopyFields
operator|=
operator|new
name|DynamicCopy
index|[
name|dynamicCopyFields
operator|.
name|length
index|]
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|dynamicCopyFields
argument_list|,
literal|0
argument_list|,
name|newSchema
operator|.
name|dynamicCopyFields
argument_list|,
literal|0
argument_list|,
name|dynamicCopyFields
operator|.
name|length
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|DynamicCopy
argument_list|>
name|dynamicCopyFieldsToRebuild
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|DynamicCopy
argument_list|>
name|newDynamicCopyFields
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|fieldNamePattern
range|:
name|fieldNamePatterns
control|)
block|{
name|DynamicField
name|dynamicField
init|=
literal|null
decl_stmt|;
name|int
name|dfPos
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
name|dfPos
operator|<
name|newSchema
operator|.
name|dynamicFields
operator|.
name|length
condition|;
operator|++
name|dfPos
control|)
block|{
name|DynamicField
name|df
init|=
name|newSchema
operator|.
name|dynamicFields
index|[
name|dfPos
index|]
decl_stmt|;
if|if
condition|(
name|df
operator|.
name|getRegex
argument_list|()
operator|.
name|equals
argument_list|(
name|fieldNamePattern
argument_list|)
condition|)
block|{
name|dynamicField
operator|=
name|df
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
literal|null
operator|==
name|dynamicField
condition|)
block|{
name|String
name|msg
init|=
literal|"The dynamic field '"
operator|+
name|fieldNamePattern
operator|+
literal|"' is not present in this schema, and so cannot be deleted."
decl_stmt|;
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
name|msg
argument_list|)
throw|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|newSchema
operator|.
name|dynamicCopyFields
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
name|DynamicCopy
name|dynamicCopy
init|=
name|newSchema
operator|.
name|dynamicCopyFields
index|[
name|i
index|]
decl_stmt|;
name|DynamicField
name|destDynamicBase
init|=
name|dynamicCopy
operator|.
name|getDestDynamicBase
argument_list|()
decl_stmt|;
name|DynamicField
name|sourceDynamicBase
init|=
name|dynamicCopy
operator|.
name|getSourceDynamicBase
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
literal|null
operator|!=
name|destDynamicBase
operator|&&
name|fieldNamePattern
operator|.
name|equals
argument_list|(
name|destDynamicBase
operator|.
name|getRegex
argument_list|()
argument_list|)
operator|)
operator|||
operator|(
literal|null
operator|!=
name|sourceDynamicBase
operator|&&
name|fieldNamePattern
operator|.
name|equals
argument_list|(
name|sourceDynamicBase
operator|.
name|getRegex
argument_list|()
argument_list|)
operator|)
operator|||
name|dynamicField
operator|.
name|matches
argument_list|(
name|dynamicCopy
operator|.
name|getRegex
argument_list|()
argument_list|)
operator|||
name|dynamicField
operator|.
name|matches
argument_list|(
name|dynamicCopy
operator|.
name|getDestFieldName
argument_list|()
argument_list|)
condition|)
block|{
name|dynamicCopyFieldsToRebuild
operator|.
name|add
argument_list|(
name|dynamicCopy
argument_list|)
expr_stmt|;
name|newSchema
operator|.
name|decrementCopyFieldTargetCount
argument_list|(
name|dynamicCopy
operator|.
name|getDestination
argument_list|()
operator|.
name|getPrototype
argument_list|()
argument_list|)
expr_stmt|;
comment|// don't add this dynamic copy field to newDynamicCopyFields - effectively removing it
block|}
else|else
block|{
name|newDynamicCopyFields
operator|.
name|add
argument_list|(
name|dynamicCopy
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|newSchema
operator|.
name|dynamicFields
operator|.
name|length
operator|>
literal|1
condition|)
block|{
name|DynamicField
index|[]
name|temp
init|=
operator|new
name|DynamicField
index|[
name|newSchema
operator|.
name|dynamicFields
operator|.
name|length
operator|-
literal|1
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|newSchema
operator|.
name|dynamicFields
argument_list|,
literal|0
argument_list|,
name|temp
argument_list|,
literal|0
argument_list|,
name|dfPos
argument_list|)
expr_stmt|;
comment|// skip over the dynamic field to be deleted
name|System
operator|.
name|arraycopy
argument_list|(
name|newSchema
operator|.
name|dynamicFields
argument_list|,
name|dfPos
operator|+
literal|1
argument_list|,
name|temp
argument_list|,
name|dfPos
argument_list|,
name|newSchema
operator|.
name|dynamicFields
operator|.
name|length
operator|-
name|dfPos
operator|-
literal|1
argument_list|)
expr_stmt|;
name|newSchema
operator|.
name|dynamicFields
operator|=
name|temp
expr_stmt|;
block|}
else|else
block|{
name|newSchema
operator|.
name|dynamicFields
operator|=
operator|new
name|DynamicField
index|[
literal|0
index|]
expr_stmt|;
block|}
block|}
comment|// After removing all dynamic fields, rebuild affected dynamic copy fields.
comment|// This may trigger an exception, if one of the deleted dynamic fields was the only matching source or target.
if|if
condition|(
name|dynamicCopyFieldsToRebuild
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|newSchema
operator|.
name|dynamicCopyFields
operator|=
name|newDynamicCopyFields
operator|.
name|toArray
argument_list|(
operator|new
name|DynamicCopy
index|[
name|newDynamicCopyFields
operator|.
name|size
argument_list|()
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|DynamicCopy
name|dynamicCopy
range|:
name|dynamicCopyFieldsToRebuild
control|)
block|{
name|newSchema
operator|.
name|registerCopyField
argument_list|(
name|dynamicCopy
operator|.
name|getRegex
argument_list|()
argument_list|,
name|dynamicCopy
operator|.
name|getDestFieldName
argument_list|()
argument_list|,
name|dynamicCopy
operator|.
name|getMaxChars
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|newSchema
operator|.
name|postReadInform
argument_list|()
expr_stmt|;
name|newSchema
operator|.
name|refreshAnalyzers
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|String
name|msg
init|=
literal|"This ManagedIndexSchema is not mutable."
decl_stmt|;
name|log
operator|.
name|error
argument_list|(
name|msg
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|SERVER_ERROR
argument_list|,
name|msg
argument_list|)
throw|;
block|}
return|return
name|newSchema
return|;
block|}
annotation|@
name|Override
DECL|method|replaceDynamicField
specifier|public
name|ManagedIndexSchema
name|replaceDynamicField
parameter_list|(
name|String
name|fieldNamePattern
parameter_list|,
name|FieldType
name|replacementFieldType
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|?
argument_list|>
name|replacementArgs
parameter_list|)
block|{
name|ManagedIndexSchema
name|newSchema
decl_stmt|;
if|if
condition|(
name|isMutable
condition|)
block|{
name|DynamicField
name|oldDynamicField
init|=
literal|null
decl_stmt|;
name|int
name|dfPos
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
name|dfPos
operator|<
name|dynamicFields
operator|.
name|length
condition|;
operator|++
name|dfPos
control|)
block|{
name|DynamicField
name|dynamicField
init|=
name|dynamicFields
index|[
name|dfPos
index|]
decl_stmt|;
if|if
condition|(
name|dynamicField
operator|.
name|getRegex
argument_list|()
operator|.
name|equals
argument_list|(
name|fieldNamePattern
argument_list|)
condition|)
block|{
name|oldDynamicField
operator|=
name|dynamicField
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
literal|null
operator|==
name|oldDynamicField
condition|)
block|{
name|String
name|msg
init|=
literal|"The dynamic field '"
operator|+
name|fieldNamePattern
operator|+
literal|"' is not present in this schema, and so cannot be replaced."
decl_stmt|;
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
name|msg
argument_list|)
throw|;
block|}
name|newSchema
operator|=
name|shallowCopy
argument_list|(
literal|true
argument_list|)
expr_stmt|;
comment|// clone data structures before modifying them
name|newSchema
operator|.
name|copyFieldTargetCounts
operator|=
call|(
name|Map
argument_list|<
name|SchemaField
argument_list|,
name|Integer
argument_list|>
call|)
argument_list|(
operator|(
name|HashMap
argument_list|<
name|SchemaField
argument_list|,
name|Integer
argument_list|>
operator|)
name|copyFieldTargetCounts
argument_list|)
operator|.
name|clone
argument_list|()
expr_stmt|;
name|newSchema
operator|.
name|dynamicCopyFields
operator|=
operator|new
name|DynamicCopy
index|[
name|dynamicCopyFields
operator|.
name|length
index|]
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|dynamicCopyFields
argument_list|,
literal|0
argument_list|,
name|newSchema
operator|.
name|dynamicCopyFields
argument_list|,
literal|0
argument_list|,
name|dynamicCopyFields
operator|.
name|length
argument_list|)
expr_stmt|;
comment|// Put the replacement dynamic field in place
name|SchemaField
name|prototype
init|=
name|SchemaField
operator|.
name|create
argument_list|(
name|fieldNamePattern
argument_list|,
name|replacementFieldType
argument_list|,
name|replacementArgs
argument_list|)
decl_stmt|;
name|newSchema
operator|.
name|dynamicFields
index|[
name|dfPos
index|]
operator|=
operator|new
name|DynamicField
argument_list|(
name|prototype
argument_list|)
expr_stmt|;
comment|// Find dynamic copy fields where this dynamic field is the source or target base; remember them to rebuild
name|List
argument_list|<
name|DynamicCopy
argument_list|>
name|dynamicCopyFieldsToRebuild
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|DynamicCopy
argument_list|>
name|newDynamicCopyFields
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|newSchema
operator|.
name|dynamicCopyFields
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
name|DynamicCopy
name|dynamicCopy
init|=
name|newSchema
operator|.
name|dynamicCopyFields
index|[
name|i
index|]
decl_stmt|;
name|DynamicField
name|destDynamicBase
init|=
name|dynamicCopy
operator|.
name|getDestDynamicBase
argument_list|()
decl_stmt|;
name|DynamicField
name|sourceDynamicBase
init|=
name|dynamicCopy
operator|.
name|getSourceDynamicBase
argument_list|()
decl_stmt|;
if|if
condition|(
name|fieldNamePattern
operator|.
name|equals
argument_list|(
name|dynamicCopy
operator|.
name|getRegex
argument_list|()
argument_list|)
operator|||
name|fieldNamePattern
operator|.
name|equals
argument_list|(
name|dynamicCopy
operator|.
name|getDestFieldName
argument_list|()
argument_list|)
operator|||
operator|(
literal|null
operator|!=
name|destDynamicBase
operator|&&
name|fieldNamePattern
operator|.
name|equals
argument_list|(
name|destDynamicBase
operator|.
name|getRegex
argument_list|()
argument_list|)
operator|)
operator|||
operator|(
literal|null
operator|!=
name|sourceDynamicBase
operator|&&
name|fieldNamePattern
operator|.
name|equals
argument_list|(
name|sourceDynamicBase
operator|.
name|getRegex
argument_list|()
argument_list|)
operator|)
condition|)
block|{
name|dynamicCopyFieldsToRebuild
operator|.
name|add
argument_list|(
name|dynamicCopy
argument_list|)
expr_stmt|;
name|newSchema
operator|.
name|decrementCopyFieldTargetCount
argument_list|(
name|dynamicCopy
operator|.
name|getDestination
argument_list|()
operator|.
name|getPrototype
argument_list|()
argument_list|)
expr_stmt|;
comment|// don't add this dynamic copy field to newDynamicCopyFields - effectively removing it
block|}
else|else
block|{
name|newDynamicCopyFields
operator|.
name|add
argument_list|(
name|dynamicCopy
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Rebuild affected dynamic copy fields
if|if
condition|(
name|dynamicCopyFieldsToRebuild
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|newSchema
operator|.
name|dynamicCopyFields
operator|=
name|newDynamicCopyFields
operator|.
name|toArray
argument_list|(
operator|new
name|DynamicCopy
index|[
name|newDynamicCopyFields
operator|.
name|size
argument_list|()
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|DynamicCopy
name|dynamicCopy
range|:
name|dynamicCopyFieldsToRebuild
control|)
block|{
name|newSchema
operator|.
name|registerCopyField
argument_list|(
name|dynamicCopy
operator|.
name|getRegex
argument_list|()
argument_list|,
name|dynamicCopy
operator|.
name|getDestFieldName
argument_list|()
argument_list|,
name|dynamicCopy
operator|.
name|getMaxChars
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|newSchema
operator|.
name|postReadInform
argument_list|()
expr_stmt|;
name|newSchema
operator|.
name|refreshAnalyzers
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|String
name|msg
init|=
literal|"This ManagedIndexSchema is not mutable."
decl_stmt|;
name|log
operator|.
name|error
argument_list|(
name|msg
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|SERVER_ERROR
argument_list|,
name|msg
argument_list|)
throw|;
block|}
return|return
name|newSchema
return|;
block|}
annotation|@
name|Override
DECL|method|addCopyFields
specifier|public
name|ManagedIndexSchema
name|addCopyFields
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|Collection
argument_list|<
name|String
argument_list|>
argument_list|>
name|copyFields
parameter_list|,
name|boolean
name|persist
parameter_list|)
block|{
name|ManagedIndexSchema
name|newSchema
decl_stmt|;
if|if
condition|(
name|isMutable
condition|)
block|{
name|boolean
name|success
init|=
literal|false
decl_stmt|;
name|newSchema
operator|=
name|shallowCopy
argument_list|(
literal|true
argument_list|)
expr_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|Collection
argument_list|<
name|String
argument_list|>
argument_list|>
name|entry
range|:
name|copyFields
operator|.
name|entrySet
argument_list|()
control|)
block|{
comment|//Key is the name of the field, values are the destinations
for|for
control|(
name|String
name|destination
range|:
name|entry
operator|.
name|getValue
argument_list|()
control|)
block|{
name|newSchema
operator|.
name|registerCopyField
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|destination
argument_list|)
expr_stmt|;
block|}
block|}
name|newSchema
operator|.
name|postReadInform
argument_list|()
expr_stmt|;
name|newSchema
operator|.
name|refreshAnalyzers
argument_list|()
expr_stmt|;
if|if
condition|(
name|persist
condition|)
block|{
name|success
operator|=
name|newSchema
operator|.
name|persistManagedSchema
argument_list|(
literal|false
argument_list|)
expr_stmt|;
comment|// don't just create - update it if it already exists
if|if
condition|(
name|success
condition|)
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"Added copy fields for {} sources"
argument_list|,
name|copyFields
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|log
operator|.
name|error
argument_list|(
literal|"Failed to add copy fields for {} sources"
argument_list|,
name|copyFields
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|String
name|msg
init|=
literal|"This ManagedIndexSchema is not mutable."
decl_stmt|;
name|log
operator|.
name|error
argument_list|(
name|msg
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|SERVER_ERROR
argument_list|,
name|msg
argument_list|)
throw|;
block|}
return|return
name|newSchema
return|;
block|}
annotation|@
name|Override
DECL|method|addCopyFields
specifier|public
name|ManagedIndexSchema
name|addCopyFields
parameter_list|(
name|String
name|source
parameter_list|,
name|Collection
argument_list|<
name|String
argument_list|>
name|destinations
parameter_list|,
name|int
name|maxChars
parameter_list|)
block|{
name|ManagedIndexSchema
name|newSchema
decl_stmt|;
if|if
condition|(
name|isMutable
condition|)
block|{
name|newSchema
operator|=
name|shallowCopy
argument_list|(
literal|true
argument_list|)
expr_stmt|;
for|for
control|(
name|String
name|destination
range|:
name|destinations
control|)
block|{
name|newSchema
operator|.
name|registerCopyField
argument_list|(
name|source
argument_list|,
name|destination
argument_list|,
name|maxChars
argument_list|)
expr_stmt|;
block|}
name|newSchema
operator|.
name|postReadInform
argument_list|()
expr_stmt|;
name|newSchema
operator|.
name|refreshAnalyzers
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|String
name|msg
init|=
literal|"This ManagedIndexSchema is not mutable."
decl_stmt|;
name|log
operator|.
name|error
argument_list|(
name|msg
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|SERVER_ERROR
argument_list|,
name|msg
argument_list|)
throw|;
block|}
return|return
name|newSchema
return|;
block|}
annotation|@
name|Override
DECL|method|deleteCopyFields
specifier|public
name|ManagedIndexSchema
name|deleteCopyFields
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|Collection
argument_list|<
name|String
argument_list|>
argument_list|>
name|copyFields
parameter_list|)
block|{
name|ManagedIndexSchema
name|newSchema
decl_stmt|;
if|if
condition|(
name|isMutable
condition|)
block|{
name|newSchema
operator|=
name|shallowCopy
argument_list|(
literal|true
argument_list|)
expr_stmt|;
comment|// clone data structures before modifying them
name|newSchema
operator|.
name|copyFieldsMap
operator|=
name|cloneCopyFieldsMap
argument_list|(
name|copyFieldsMap
argument_list|)
expr_stmt|;
name|newSchema
operator|.
name|copyFieldTargetCounts
operator|=
call|(
name|Map
argument_list|<
name|SchemaField
argument_list|,
name|Integer
argument_list|>
call|)
argument_list|(
operator|(
name|HashMap
argument_list|<
name|SchemaField
argument_list|,
name|Integer
argument_list|>
operator|)
name|copyFieldTargetCounts
argument_list|)
operator|.
name|clone
argument_list|()
expr_stmt|;
name|newSchema
operator|.
name|dynamicCopyFields
operator|=
operator|new
name|DynamicCopy
index|[
name|dynamicCopyFields
operator|.
name|length
index|]
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|dynamicCopyFields
argument_list|,
literal|0
argument_list|,
name|newSchema
operator|.
name|dynamicCopyFields
argument_list|,
literal|0
argument_list|,
name|dynamicCopyFields
operator|.
name|length
argument_list|)
expr_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|Collection
argument_list|<
name|String
argument_list|>
argument_list|>
name|entry
range|:
name|copyFields
operator|.
name|entrySet
argument_list|()
control|)
block|{
comment|// Key is the source, values are the destinations
for|for
control|(
name|String
name|destination
range|:
name|entry
operator|.
name|getValue
argument_list|()
control|)
block|{
name|newSchema
operator|.
name|deleteCopyField
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|destination
argument_list|)
expr_stmt|;
block|}
block|}
name|newSchema
operator|.
name|postReadInform
argument_list|()
expr_stmt|;
name|newSchema
operator|.
name|refreshAnalyzers
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|String
name|msg
init|=
literal|"This ManagedIndexSchema is not mutable."
decl_stmt|;
name|log
operator|.
name|error
argument_list|(
name|msg
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|SERVER_ERROR
argument_list|,
name|msg
argument_list|)
throw|;
block|}
return|return
name|newSchema
return|;
block|}
DECL|method|deleteCopyField
specifier|private
name|void
name|deleteCopyField
parameter_list|(
name|String
name|source
parameter_list|,
name|String
name|dest
parameter_list|)
block|{
comment|// Assumption: a copy field directive will exist only if the source& destination (dynamic) fields exist
name|SchemaField
name|destSchemaField
init|=
name|fields
operator|.
name|get
argument_list|(
name|dest
argument_list|)
decl_stmt|;
name|SchemaField
name|sourceSchemaField
init|=
name|fields
operator|.
name|get
argument_list|(
name|source
argument_list|)
decl_stmt|;
specifier|final
name|String
name|invalidGlobMessage
init|=
literal|"is an invalid glob: either it contains more than one asterisk,"
operator|+
literal|" or the asterisk occurs neither at the start nor at the end."
decl_stmt|;
if|if
condition|(
name|source
operator|.
name|contains
argument_list|(
literal|"*"
argument_list|)
operator|&&
operator|!
name|isValidFieldGlob
argument_list|(
name|source
argument_list|)
condition|)
block|{
name|String
name|msg
init|=
literal|"copyField source '"
operator|+
name|source
operator|+
literal|"' "
operator|+
name|invalidGlobMessage
decl_stmt|;
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
name|msg
argument_list|)
throw|;
block|}
if|if
condition|(
name|dest
operator|.
name|contains
argument_list|(
literal|"*"
argument_list|)
operator|&&
operator|!
name|isValidFieldGlob
argument_list|(
name|dest
argument_list|)
condition|)
block|{
name|String
name|msg
init|=
literal|"copyField dest '"
operator|+
name|dest
operator|+
literal|"' "
operator|+
name|invalidGlobMessage
decl_stmt|;
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
name|msg
argument_list|)
throw|;
block|}
name|boolean
name|found
init|=
literal|false
decl_stmt|;
if|if
condition|(
literal|null
operator|==
name|destSchemaField
operator|||
literal|null
operator|==
name|sourceSchemaField
condition|)
block|{
comment|// Must be dynamic copy field
if|if
condition|(
name|dynamicCopyFields
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|dynamicCopyFields
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
name|DynamicCopy
name|dynamicCopy
init|=
name|dynamicCopyFields
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|source
operator|.
name|equals
argument_list|(
name|dynamicCopy
operator|.
name|getRegex
argument_list|()
argument_list|)
operator|&&
name|dest
operator|.
name|equals
argument_list|(
name|dynamicCopy
operator|.
name|getDestFieldName
argument_list|()
argument_list|)
condition|)
block|{
name|found
operator|=
literal|true
expr_stmt|;
name|SchemaField
name|destinationPrototype
init|=
name|dynamicCopy
operator|.
name|getDestination
argument_list|()
operator|.
name|getPrototype
argument_list|()
decl_stmt|;
if|if
condition|(
name|copyFieldTargetCounts
operator|.
name|containsKey
argument_list|(
name|destinationPrototype
argument_list|)
condition|)
block|{
name|decrementCopyFieldTargetCount
argument_list|(
name|destinationPrototype
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dynamicCopyFields
operator|.
name|length
operator|>
literal|1
condition|)
block|{
name|DynamicCopy
index|[]
name|temp
init|=
operator|new
name|DynamicCopy
index|[
name|dynamicCopyFields
operator|.
name|length
operator|-
literal|1
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|dynamicCopyFields
argument_list|,
literal|0
argument_list|,
name|temp
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|// skip over the dynamic copy field to be deleted
name|System
operator|.
name|arraycopy
argument_list|(
name|dynamicCopyFields
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|temp
argument_list|,
name|i
argument_list|,
name|dynamicCopyFields
operator|.
name|length
operator|-
name|i
operator|-
literal|1
argument_list|)
expr_stmt|;
name|dynamicCopyFields
operator|=
name|temp
expr_stmt|;
block|}
else|else
block|{
name|dynamicCopyFields
operator|=
literal|null
expr_stmt|;
block|}
break|break;
block|}
block|}
block|}
block|}
else|else
block|{
comment|// non-dynamic copy field directive
name|List
argument_list|<
name|CopyField
argument_list|>
name|copyFieldList
init|=
name|copyFieldsMap
operator|.
name|get
argument_list|(
name|source
argument_list|)
decl_stmt|;
if|if
condition|(
name|copyFieldList
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|Iterator
argument_list|<
name|CopyField
argument_list|>
name|iter
init|=
name|copyFieldList
operator|.
name|iterator
argument_list|()
init|;
name|iter
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|CopyField
name|copyField
init|=
name|iter
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|dest
operator|.
name|equals
argument_list|(
name|copyField
operator|.
name|getDestination
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
block|{
name|found
operator|=
literal|true
expr_stmt|;
name|decrementCopyFieldTargetCount
argument_list|(
name|copyField
operator|.
name|getDestination
argument_list|()
argument_list|)
expr_stmt|;
name|iter
operator|.
name|remove
argument_list|()
expr_stmt|;
if|if
condition|(
name|copyFieldList
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|copyFieldsMap
operator|.
name|remove
argument_list|(
name|source
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
block|}
block|}
if|if
condition|(
operator|!
name|found
condition|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
literal|"Copy field directive not found: '"
operator|+
name|source
operator|+
literal|"' -> '"
operator|+
name|dest
operator|+
literal|"'"
argument_list|)
throw|;
block|}
block|}
comment|/**    * Removes all copy fields with the given source field name, decrements the count for the copy field target,    * and adds the removed copy fields to removedCopyFields.    */
DECL|method|removeCopyFieldSource
specifier|private
name|void
name|removeCopyFieldSource
parameter_list|(
name|String
name|sourceFieldName
parameter_list|,
name|List
argument_list|<
name|CopyField
argument_list|>
name|removedCopyFields
parameter_list|)
block|{
name|List
argument_list|<
name|CopyField
argument_list|>
name|sourceCopyFields
init|=
name|copyFieldsMap
operator|.
name|remove
argument_list|(
name|sourceFieldName
argument_list|)
decl_stmt|;
if|if
condition|(
literal|null
operator|!=
name|sourceCopyFields
condition|)
block|{
for|for
control|(
name|CopyField
name|sourceCopyField
range|:
name|sourceCopyFields
control|)
block|{
name|decrementCopyFieldTargetCount
argument_list|(
name|sourceCopyField
operator|.
name|getDestination
argument_list|()
argument_list|)
expr_stmt|;
name|removedCopyFields
operator|.
name|add
argument_list|(
name|sourceCopyField
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Registers new copy fields with the source, destination and maxChars taken from each of the oldCopyFields.    *     * Assumption: the fields in oldCopyFields still exist in the schema.     */
DECL|method|rebuildCopyFields
specifier|private
name|void
name|rebuildCopyFields
parameter_list|(
name|List
argument_list|<
name|CopyField
argument_list|>
name|oldCopyFields
parameter_list|)
block|{
if|if
condition|(
name|oldCopyFields
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|CopyField
name|copyField
range|:
name|oldCopyFields
control|)
block|{
name|SchemaField
name|source
init|=
name|fields
operator|.
name|get
argument_list|(
name|copyField
operator|.
name|getSource
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
name|SchemaField
name|destination
init|=
name|fields
operator|.
name|get
argument_list|(
name|copyField
operator|.
name|getDestination
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
name|registerExplicitSrcAndDestFields
argument_list|(
name|copyField
operator|.
name|getSource
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|copyField
operator|.
name|getMaxChars
argument_list|()
argument_list|,
name|destination
argument_list|,
name|source
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Decrements the count for the given destination field in copyFieldTargetCounts.    */
DECL|method|decrementCopyFieldTargetCount
specifier|private
name|void
name|decrementCopyFieldTargetCount
parameter_list|(
name|SchemaField
name|dest
parameter_list|)
block|{
name|Integer
name|count
init|=
name|copyFieldTargetCounts
operator|.
name|get
argument_list|(
name|dest
argument_list|)
decl_stmt|;
assert|assert
name|count
operator|!=
literal|null
assert|;
if|if
condition|(
name|count
operator|<=
literal|1
condition|)
block|{
name|copyFieldTargetCounts
operator|.
name|remove
argument_list|(
name|dest
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|copyFieldTargetCounts
operator|.
name|put
argument_list|(
name|dest
argument_list|,
name|count
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|addFieldTypes
specifier|public
name|ManagedIndexSchema
name|addFieldTypes
parameter_list|(
name|List
argument_list|<
name|FieldType
argument_list|>
name|fieldTypeList
parameter_list|,
name|boolean
name|persist
parameter_list|)
block|{
if|if
condition|(
operator|!
name|isMutable
condition|)
block|{
name|String
name|msg
init|=
literal|"This ManagedIndexSchema is not mutable."
decl_stmt|;
name|log
operator|.
name|error
argument_list|(
name|msg
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|SERVER_ERROR
argument_list|,
name|msg
argument_list|)
throw|;
block|}
name|ManagedIndexSchema
name|newSchema
init|=
name|shallowCopy
argument_list|(
literal|true
argument_list|)
decl_stmt|;
comment|// we shallow copied fieldTypes, but since we're changing them, we need to do a true
comment|// deep copy before adding the new field types
name|HashMap
argument_list|<
name|String
argument_list|,
name|FieldType
argument_list|>
name|clone
init|=
call|(
name|HashMap
argument_list|<
name|String
argument_list|,
name|FieldType
argument_list|>
call|)
argument_list|(
operator|(
name|HashMap
argument_list|<
name|String
argument_list|,
name|FieldType
argument_list|>
operator|)
name|newSchema
operator|.
name|fieldTypes
argument_list|)
operator|.
name|clone
argument_list|()
decl_stmt|;
name|newSchema
operator|.
name|fieldTypes
operator|=
name|clone
expr_stmt|;
comment|// do a first pass to validate the field types don't exist already
for|for
control|(
name|FieldType
name|fieldType
range|:
name|fieldTypeList
control|)
block|{
name|String
name|typeName
init|=
name|fieldType
operator|.
name|getTypeName
argument_list|()
decl_stmt|;
if|if
condition|(
name|newSchema
operator|.
name|getFieldTypeByName
argument_list|(
name|typeName
argument_list|)
operator|!=
literal|null
condition|)
block|{
throw|throw
operator|new
name|FieldExistsException
argument_list|(
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
literal|"Field type '"
operator|+
name|typeName
operator|+
literal|"' already exists!"
argument_list|)
throw|;
block|}
name|newSchema
operator|.
name|fieldTypes
operator|.
name|put
argument_list|(
name|typeName
argument_list|,
name|fieldType
argument_list|)
expr_stmt|;
block|}
name|newSchema
operator|.
name|postReadInform
argument_list|()
expr_stmt|;
name|newSchema
operator|.
name|refreshAnalyzers
argument_list|()
expr_stmt|;
if|if
condition|(
name|persist
condition|)
block|{
name|boolean
name|success
init|=
name|newSchema
operator|.
name|persistManagedSchema
argument_list|(
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|success
condition|)
block|{
if|if
condition|(
name|log
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|StringBuilder
name|fieldTypeNames
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fieldTypeList
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|>
literal|0
condition|)
name|fieldTypeNames
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
name|fieldTypeNames
operator|.
name|append
argument_list|(
name|fieldTypeList
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|typeName
argument_list|)
expr_stmt|;
block|}
name|log
operator|.
name|debug
argument_list|(
literal|"Added field types: {}"
argument_list|,
name|fieldTypeNames
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// this is unlikely to happen as most errors are handled as exceptions in the persist code
name|log
operator|.
name|error
argument_list|(
literal|"Failed to add field types: {}"
argument_list|,
name|fieldTypeList
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|SERVER_ERROR
argument_list|,
literal|"Failed to persist updated schema due to underlying storage issue; check log for more details!"
argument_list|)
throw|;
block|}
block|}
return|return
name|newSchema
return|;
block|}
annotation|@
name|Override
DECL|method|deleteFieldTypes
specifier|public
name|ManagedIndexSchema
name|deleteFieldTypes
parameter_list|(
name|Collection
argument_list|<
name|String
argument_list|>
name|names
parameter_list|)
block|{
name|ManagedIndexSchema
name|newSchema
decl_stmt|;
if|if
condition|(
name|isMutable
condition|)
block|{
for|for
control|(
name|String
name|name
range|:
name|names
control|)
block|{
if|if
condition|(
operator|!
name|fieldTypes
operator|.
name|containsKey
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|String
name|msg
init|=
literal|"The field type '"
operator|+
name|name
operator|+
literal|"' is not present in this schema, and so cannot be deleted."
decl_stmt|;
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
name|msg
argument_list|)
throw|;
block|}
for|for
control|(
name|SchemaField
name|field
range|:
name|fields
operator|.
name|values
argument_list|()
control|)
block|{
if|if
condition|(
name|field
operator|.
name|getType
argument_list|()
operator|.
name|getTypeName
argument_list|()
operator|.
name|equals
argument_list|(
name|name
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
literal|"Can't delete '"
operator|+
name|name
operator|+
literal|"' because it's the field type of field '"
operator|+
name|field
operator|.
name|getName
argument_list|()
operator|+
literal|"'."
argument_list|)
throw|;
block|}
block|}
for|for
control|(
name|DynamicField
name|dynamicField
range|:
name|dynamicFields
control|)
block|{
if|if
condition|(
name|dynamicField
operator|.
name|getPrototype
argument_list|()
operator|.
name|getType
argument_list|()
operator|.
name|getTypeName
argument_list|()
operator|.
name|equals
argument_list|(
name|name
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
literal|"Can't delete '"
operator|+
name|name
operator|+
literal|"' because it's the field type of dynamic field '"
operator|+
name|dynamicField
operator|.
name|getRegex
argument_list|()
operator|+
literal|"'."
argument_list|)
throw|;
block|}
block|}
block|}
name|newSchema
operator|=
name|shallowCopy
argument_list|(
literal|true
argument_list|)
expr_stmt|;
for|for
control|(
name|String
name|name
range|:
name|names
control|)
block|{
name|newSchema
operator|.
name|fieldTypes
operator|.
name|remove
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
name|newSchema
operator|.
name|postReadInform
argument_list|()
expr_stmt|;
name|newSchema
operator|.
name|refreshAnalyzers
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|String
name|msg
init|=
literal|"This ManagedIndexSchema is not mutable."
decl_stmt|;
name|log
operator|.
name|error
argument_list|(
name|msg
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|SERVER_ERROR
argument_list|,
name|msg
argument_list|)
throw|;
block|}
return|return
name|newSchema
return|;
block|}
DECL|method|cloneCopyFieldsMap
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|CopyField
argument_list|>
argument_list|>
name|cloneCopyFieldsMap
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|CopyField
argument_list|>
argument_list|>
name|original
parameter_list|)
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|CopyField
argument_list|>
argument_list|>
name|clone
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|(
name|original
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
name|Iterator
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|CopyField
argument_list|>
argument_list|>
argument_list|>
name|iterator
init|=
name|original
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|iterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|CopyField
argument_list|>
argument_list|>
name|entry
init|=
name|iterator
operator|.
name|next
argument_list|()
decl_stmt|;
name|clone
operator|.
name|put
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|clone
return|;
block|}
annotation|@
name|Override
DECL|method|replaceFieldType
specifier|public
name|ManagedIndexSchema
name|replaceFieldType
parameter_list|(
name|String
name|typeName
parameter_list|,
name|String
name|replacementClassName
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|replacementArgs
parameter_list|)
block|{
name|ManagedIndexSchema
name|newSchema
decl_stmt|;
if|if
condition|(
name|isMutable
condition|)
block|{
if|if
condition|(
operator|!
name|fieldTypes
operator|.
name|containsKey
argument_list|(
name|typeName
argument_list|)
condition|)
block|{
name|String
name|msg
init|=
literal|"The field type '"
operator|+
name|typeName
operator|+
literal|"' is not present in this schema, and so cannot be replaced."
decl_stmt|;
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
name|msg
argument_list|)
throw|;
block|}
name|newSchema
operator|=
name|shallowCopy
argument_list|(
literal|true
argument_list|)
expr_stmt|;
comment|// clone data structures before modifying them
name|newSchema
operator|.
name|fieldTypes
operator|=
call|(
name|Map
argument_list|<
name|String
argument_list|,
name|FieldType
argument_list|>
call|)
argument_list|(
operator|(
name|HashMap
argument_list|<
name|String
argument_list|,
name|FieldType
argument_list|>
operator|)
name|fieldTypes
argument_list|)
operator|.
name|clone
argument_list|()
expr_stmt|;
name|newSchema
operator|.
name|copyFieldsMap
operator|=
name|cloneCopyFieldsMap
argument_list|(
name|copyFieldsMap
argument_list|)
expr_stmt|;
name|newSchema
operator|.
name|copyFieldTargetCounts
operator|=
call|(
name|Map
argument_list|<
name|SchemaField
argument_list|,
name|Integer
argument_list|>
call|)
argument_list|(
operator|(
name|HashMap
argument_list|<
name|SchemaField
argument_list|,
name|Integer
argument_list|>
operator|)
name|copyFieldTargetCounts
argument_list|)
operator|.
name|clone
argument_list|()
expr_stmt|;
name|newSchema
operator|.
name|dynamicCopyFields
operator|=
operator|new
name|DynamicCopy
index|[
name|dynamicCopyFields
operator|.
name|length
index|]
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|dynamicCopyFields
argument_list|,
literal|0
argument_list|,
name|newSchema
operator|.
name|dynamicCopyFields
argument_list|,
literal|0
argument_list|,
name|dynamicCopyFields
operator|.
name|length
argument_list|)
expr_stmt|;
name|newSchema
operator|.
name|dynamicFields
operator|=
operator|new
name|DynamicField
index|[
name|dynamicFields
operator|.
name|length
index|]
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|dynamicFields
argument_list|,
literal|0
argument_list|,
name|newSchema
operator|.
name|dynamicFields
argument_list|,
literal|0
argument_list|,
name|dynamicFields
operator|.
name|length
argument_list|)
expr_stmt|;
name|newSchema
operator|.
name|fieldTypes
operator|.
name|remove
argument_list|(
name|typeName
argument_list|)
expr_stmt|;
name|FieldType
name|replacementFieldType
init|=
name|newSchema
operator|.
name|newFieldType
argument_list|(
name|typeName
argument_list|,
name|replacementClassName
argument_list|,
name|replacementArgs
argument_list|)
decl_stmt|;
name|newSchema
operator|.
name|fieldTypes
operator|.
name|put
argument_list|(
name|typeName
argument_list|,
name|replacementFieldType
argument_list|)
expr_stmt|;
comment|// Rebuild fields of the type being replaced
name|List
argument_list|<
name|CopyField
argument_list|>
name|copyFieldsToRebuild
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|SchemaField
argument_list|>
name|replacementFields
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|Iterator
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|SchemaField
argument_list|>
argument_list|>
name|fieldsIter
init|=
name|newSchema
operator|.
name|fields
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|fieldsIter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|SchemaField
argument_list|>
name|entry
init|=
name|fieldsIter
operator|.
name|next
argument_list|()
decl_stmt|;
name|SchemaField
name|oldField
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|oldField
operator|.
name|getType
argument_list|()
operator|.
name|getTypeName
argument_list|()
operator|.
name|equals
argument_list|(
name|typeName
argument_list|)
condition|)
block|{
name|String
name|fieldName
init|=
name|oldField
operator|.
name|getName
argument_list|()
decl_stmt|;
comment|// Drop the old field
name|fieldsIter
operator|.
name|remove
argument_list|()
expr_stmt|;
name|newSchema
operator|.
name|fieldsWithDefaultValue
operator|.
name|remove
argument_list|(
name|oldField
argument_list|)
expr_stmt|;
name|newSchema
operator|.
name|requiredFields
operator|.
name|remove
argument_list|(
name|oldField
argument_list|)
expr_stmt|;
comment|// Add the replacement field
name|SchemaField
name|replacementField
init|=
name|SchemaField
operator|.
name|create
argument_list|(
name|fieldName
argument_list|,
name|replacementFieldType
argument_list|,
name|oldField
operator|.
name|getArgs
argument_list|()
argument_list|)
decl_stmt|;
name|replacementFields
operator|.
name|add
argument_list|(
name|replacementField
argument_list|)
expr_stmt|;
comment|// Save the new field to be added after iteration is finished
if|if
condition|(
literal|null
operator|!=
name|replacementField
operator|.
name|getDefaultValue
argument_list|()
condition|)
block|{
name|log
operator|.
name|debug
argument_list|(
name|replacementField
operator|.
name|getName
argument_list|()
operator|+
literal|" contains default value: "
operator|+
name|replacementField
operator|.
name|getDefaultValue
argument_list|()
argument_list|)
expr_stmt|;
name|newSchema
operator|.
name|fieldsWithDefaultValue
operator|.
name|add
argument_list|(
name|replacementField
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|replacementField
operator|.
name|isRequired
argument_list|()
condition|)
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"{} is required in this schema"
argument_list|,
name|replacementField
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|newSchema
operator|.
name|requiredFields
operator|.
name|add
argument_list|(
name|replacementField
argument_list|)
expr_stmt|;
block|}
name|newSchema
operator|.
name|removeCopyFieldSource
argument_list|(
name|fieldName
argument_list|,
name|copyFieldsToRebuild
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|SchemaField
name|replacementField
range|:
name|replacementFields
control|)
block|{
name|newSchema
operator|.
name|fields
operator|.
name|put
argument_list|(
name|replacementField
operator|.
name|getName
argument_list|()
argument_list|,
name|replacementField
argument_list|)
expr_stmt|;
block|}
comment|// Remove copy fields where the target is of the type being replaced; remember them to rebuild
name|Iterator
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|CopyField
argument_list|>
argument_list|>
argument_list|>
name|copyFieldsMapIter
init|=
name|newSchema
operator|.
name|copyFieldsMap
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|copyFieldsMapIter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|CopyField
argument_list|>
argument_list|>
name|entry
init|=
name|copyFieldsMapIter
operator|.
name|next
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|CopyField
argument_list|>
name|perSourceCopyFields
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|Iterator
argument_list|<
name|CopyField
argument_list|>
name|checkDestCopyFieldsIter
init|=
name|perSourceCopyFields
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|checkDestCopyFieldsIter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|CopyField
name|checkDestCopyField
init|=
name|checkDestCopyFieldsIter
operator|.
name|next
argument_list|()
decl_stmt|;
name|SchemaField
name|destination
init|=
name|checkDestCopyField
operator|.
name|getDestination
argument_list|()
decl_stmt|;
if|if
condition|(
name|typeName
operator|.
name|equals
argument_list|(
name|destination
operator|.
name|getType
argument_list|()
operator|.
name|getTypeName
argument_list|()
argument_list|)
condition|)
block|{
name|checkDestCopyFieldsIter
operator|.
name|remove
argument_list|()
expr_stmt|;
name|copyFieldsToRebuild
operator|.
name|add
argument_list|(
name|checkDestCopyField
argument_list|)
expr_stmt|;
name|newSchema
operator|.
name|copyFieldTargetCounts
operator|.
name|remove
argument_list|(
name|destination
argument_list|)
expr_stmt|;
comment|// zero out target count
block|}
block|}
if|if
condition|(
name|perSourceCopyFields
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|copyFieldsMapIter
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
block|}
comment|// Rebuild dynamic fields of the type being replaced
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|newSchema
operator|.
name|dynamicFields
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
name|SchemaField
name|prototype
init|=
name|newSchema
operator|.
name|dynamicFields
index|[
name|i
index|]
operator|.
name|getPrototype
argument_list|()
decl_stmt|;
if|if
condition|(
name|typeName
operator|.
name|equals
argument_list|(
name|prototype
operator|.
name|getType
argument_list|()
operator|.
name|getTypeName
argument_list|()
argument_list|)
condition|)
block|{
name|newSchema
operator|.
name|dynamicFields
index|[
name|i
index|]
operator|=
operator|new
name|DynamicField
argument_list|(
name|SchemaField
operator|.
name|create
argument_list|(
name|prototype
operator|.
name|getName
argument_list|()
argument_list|,
name|replacementFieldType
argument_list|,
name|prototype
operator|.
name|getArgs
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Find dynamic copy fields where the destination field's type is being replaced
comment|// or the source dynamic base's type is being replaced; remember them to rebuild
name|List
argument_list|<
name|DynamicCopy
argument_list|>
name|dynamicCopyFieldsToRebuild
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|DynamicCopy
argument_list|>
name|newDynamicCopyFields
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|newSchema
operator|.
name|dynamicCopyFields
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
name|DynamicCopy
name|dynamicCopy
init|=
name|newSchema
operator|.
name|dynamicCopyFields
index|[
name|i
index|]
decl_stmt|;
name|DynamicField
name|sourceDynamicBase
init|=
name|dynamicCopy
operator|.
name|getSourceDynamicBase
argument_list|()
decl_stmt|;
name|SchemaField
name|destinationPrototype
init|=
name|dynamicCopy
operator|.
name|getDestination
argument_list|()
operator|.
name|getPrototype
argument_list|()
decl_stmt|;
if|if
condition|(
name|typeName
operator|.
name|equals
argument_list|(
name|destinationPrototype
operator|.
name|getType
argument_list|()
operator|.
name|getTypeName
argument_list|()
argument_list|)
operator|||
operator|(
literal|null
operator|!=
name|sourceDynamicBase
operator|&&
name|typeName
operator|.
name|equals
argument_list|(
name|sourceDynamicBase
operator|.
name|getPrototype
argument_list|()
operator|.
name|getType
argument_list|()
operator|.
name|getTypeName
argument_list|()
argument_list|)
operator|)
condition|)
block|{
name|dynamicCopyFieldsToRebuild
operator|.
name|add
argument_list|(
name|dynamicCopy
argument_list|)
expr_stmt|;
if|if
condition|(
name|newSchema
operator|.
name|copyFieldTargetCounts
operator|.
name|containsKey
argument_list|(
name|destinationPrototype
argument_list|)
condition|)
block|{
name|newSchema
operator|.
name|decrementCopyFieldTargetCount
argument_list|(
name|destinationPrototype
argument_list|)
expr_stmt|;
block|}
comment|// don't add this dynamic copy field to newDynamicCopyFields - effectively removing it
block|}
else|else
block|{
name|newDynamicCopyFields
operator|.
name|add
argument_list|(
name|dynamicCopy
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Rebuild affected dynamic copy fields
if|if
condition|(
name|dynamicCopyFieldsToRebuild
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|newSchema
operator|.
name|dynamicCopyFields
operator|=
name|newDynamicCopyFields
operator|.
name|toArray
argument_list|(
operator|new
name|DynamicCopy
index|[
name|newDynamicCopyFields
operator|.
name|size
argument_list|()
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|DynamicCopy
name|dynamicCopy
range|:
name|dynamicCopyFieldsToRebuild
control|)
block|{
name|newSchema
operator|.
name|registerCopyField
argument_list|(
name|dynamicCopy
operator|.
name|getRegex
argument_list|()
argument_list|,
name|dynamicCopy
operator|.
name|getDestFieldName
argument_list|()
argument_list|,
name|dynamicCopy
operator|.
name|getMaxChars
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|newSchema
operator|.
name|rebuildCopyFields
argument_list|(
name|copyFieldsToRebuild
argument_list|)
expr_stmt|;
name|newSchema
operator|.
name|postReadInform
argument_list|()
expr_stmt|;
name|newSchema
operator|.
name|refreshAnalyzers
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|String
name|msg
init|=
literal|"This ManagedIndexSchema is not mutable."
decl_stmt|;
name|log
operator|.
name|error
argument_list|(
name|msg
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|SERVER_ERROR
argument_list|,
name|msg
argument_list|)
throw|;
block|}
return|return
name|newSchema
return|;
block|}
annotation|@
name|Override
DECL|method|postReadInform
specifier|protected
name|void
name|postReadInform
parameter_list|()
block|{
name|super
operator|.
name|postReadInform
argument_list|()
expr_stmt|;
for|for
control|(
name|FieldType
name|fieldType
range|:
name|fieldTypes
operator|.
name|values
argument_list|()
control|)
block|{
name|informResourceLoaderAwareObjectsForFieldType
argument_list|(
name|fieldType
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Informs analyzers used by a fieldType.    */
DECL|method|informResourceLoaderAwareObjectsForFieldType
specifier|protected
name|void
name|informResourceLoaderAwareObjectsForFieldType
parameter_list|(
name|FieldType
name|fieldType
parameter_list|)
block|{
comment|// must inform any sub-components used in the
comment|// tokenizer chain if they are ResourceLoaderAware
if|if
condition|(
operator|!
name|fieldType
operator|.
name|supportsAnalyzers
argument_list|()
condition|)
return|return;
name|Analyzer
name|indexAnalyzer
init|=
name|fieldType
operator|.
name|getIndexAnalyzer
argument_list|()
decl_stmt|;
if|if
condition|(
name|indexAnalyzer
operator|!=
literal|null
operator|&&
name|indexAnalyzer
operator|instanceof
name|TokenizerChain
condition|)
name|informResourceLoaderAwareObjectsInChain
argument_list|(
operator|(
name|TokenizerChain
operator|)
name|indexAnalyzer
argument_list|)
expr_stmt|;
name|Analyzer
name|queryAnalyzer
init|=
name|fieldType
operator|.
name|getQueryAnalyzer
argument_list|()
decl_stmt|;
comment|// ref comparison is correct here (vs. equals) as they may be the same
comment|// object in which case, we don't need to inform twice ... however, it's
comment|// actually safe to call inform multiple times on an object anyway
if|if
condition|(
name|queryAnalyzer
operator|!=
literal|null
operator|&&
name|queryAnalyzer
operator|!=
name|indexAnalyzer
operator|&&
name|queryAnalyzer
operator|instanceof
name|TokenizerChain
condition|)
name|informResourceLoaderAwareObjectsInChain
argument_list|(
operator|(
name|TokenizerChain
operator|)
name|queryAnalyzer
argument_list|)
expr_stmt|;
comment|// if fieldType is a TextField, it might have a multi-term analyzer
if|if
condition|(
name|fieldType
operator|instanceof
name|TextField
condition|)
block|{
name|TextField
name|textFieldType
init|=
operator|(
name|TextField
operator|)
name|fieldType
decl_stmt|;
name|Analyzer
name|multiTermAnalyzer
init|=
name|textFieldType
operator|.
name|getMultiTermAnalyzer
argument_list|()
decl_stmt|;
if|if
condition|(
name|multiTermAnalyzer
operator|!=
literal|null
operator|&&
name|multiTermAnalyzer
operator|!=
name|indexAnalyzer
operator|&&
name|multiTermAnalyzer
operator|!=
name|queryAnalyzer
operator|&&
name|multiTermAnalyzer
operator|instanceof
name|TokenizerChain
condition|)
name|informResourceLoaderAwareObjectsInChain
argument_list|(
operator|(
name|TokenizerChain
operator|)
name|multiTermAnalyzer
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|newField
specifier|public
name|SchemaField
name|newField
parameter_list|(
name|String
name|fieldName
parameter_list|,
name|String
name|fieldType
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|?
argument_list|>
name|options
parameter_list|)
block|{
name|SchemaField
name|sf
decl_stmt|;
if|if
condition|(
name|isMutable
condition|)
block|{
try|try
block|{
if|if
condition|(
operator|-
literal|1
operator|!=
name|fieldName
operator|.
name|indexOf
argument_list|(
literal|'*'
argument_list|)
condition|)
block|{
name|String
name|msg
init|=
literal|"Can't add dynamic field '"
operator|+
name|fieldName
operator|+
literal|"'."
decl_stmt|;
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
name|msg
argument_list|)
throw|;
block|}
name|SchemaField
name|existingFieldWithTheSameName
init|=
name|fields
operator|.
name|get
argument_list|(
name|fieldName
argument_list|)
decl_stmt|;
if|if
condition|(
literal|null
operator|!=
name|existingFieldWithTheSameName
condition|)
block|{
name|String
name|msg
init|=
literal|"Field '"
operator|+
name|fieldName
operator|+
literal|"' already exists."
decl_stmt|;
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
name|msg
argument_list|)
throw|;
block|}
name|FieldType
name|type
init|=
name|getFieldTypeByName
argument_list|(
name|fieldType
argument_list|)
decl_stmt|;
if|if
condition|(
literal|null
operator|==
name|type
condition|)
block|{
name|String
name|msg
init|=
literal|"Field '"
operator|+
name|fieldName
operator|+
literal|"': Field type '"
operator|+
name|fieldType
operator|+
literal|"' not found."
decl_stmt|;
name|log
operator|.
name|error
argument_list|(
name|msg
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
name|msg
argument_list|)
throw|;
block|}
name|sf
operator|=
name|SchemaField
operator|.
name|create
argument_list|(
name|fieldName
argument_list|,
name|type
argument_list|,
name|options
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SolrException
name|e
parameter_list|)
block|{
throw|throw
name|e
throw|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
else|else
block|{
name|String
name|msg
init|=
literal|"This ManagedIndexSchema is not mutable."
decl_stmt|;
name|log
operator|.
name|error
argument_list|(
name|msg
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|SERVER_ERROR
argument_list|,
name|msg
argument_list|)
throw|;
block|}
return|return
name|sf
return|;
block|}
DECL|method|getSchemaZkVersion
specifier|public
name|int
name|getSchemaZkVersion
parameter_list|()
block|{
return|return
name|schemaZkVersion
return|;
block|}
annotation|@
name|Override
DECL|method|newDynamicField
specifier|public
name|SchemaField
name|newDynamicField
parameter_list|(
name|String
name|fieldNamePattern
parameter_list|,
name|String
name|fieldType
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|?
argument_list|>
name|options
parameter_list|)
block|{
name|SchemaField
name|sf
decl_stmt|;
if|if
condition|(
name|isMutable
condition|)
block|{
try|try
block|{
name|FieldType
name|type
init|=
name|getFieldTypeByName
argument_list|(
name|fieldType
argument_list|)
decl_stmt|;
if|if
condition|(
literal|null
operator|==
name|type
condition|)
block|{
name|String
name|msg
init|=
literal|"Dynamic field '"
operator|+
name|fieldNamePattern
operator|+
literal|"': Field type '"
operator|+
name|fieldType
operator|+
literal|"' not found."
decl_stmt|;
name|log
operator|.
name|error
argument_list|(
name|msg
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
name|msg
argument_list|)
throw|;
block|}
name|sf
operator|=
name|SchemaField
operator|.
name|create
argument_list|(
name|fieldNamePattern
argument_list|,
name|type
argument_list|,
name|options
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isValidDynamicField
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|dynamicFields
argument_list|)
argument_list|,
name|sf
argument_list|)
condition|)
block|{
name|String
name|msg
init|=
literal|"Invalid dynamic field '"
operator|+
name|fieldNamePattern
operator|+
literal|"'"
decl_stmt|;
name|log
operator|.
name|error
argument_list|(
name|msg
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
name|msg
argument_list|)
throw|;
block|}
block|}
catch|catch
parameter_list|(
name|SolrException
name|e
parameter_list|)
block|{
throw|throw
name|e
throw|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
else|else
block|{
name|String
name|msg
init|=
literal|"This ManagedIndexSchema is not mutable."
decl_stmt|;
name|log
operator|.
name|error
argument_list|(
name|msg
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|SERVER_ERROR
argument_list|,
name|msg
argument_list|)
throw|;
block|}
return|return
name|sf
return|;
block|}
annotation|@
name|Override
DECL|method|newFieldType
specifier|public
name|FieldType
name|newFieldType
parameter_list|(
name|String
name|typeName
parameter_list|,
name|String
name|className
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|?
argument_list|>
name|options
parameter_list|)
block|{
if|if
condition|(
operator|!
name|isMutable
condition|)
block|{
name|String
name|msg
init|=
literal|"This ManagedIndexSchema is not mutable."
decl_stmt|;
name|log
operator|.
name|error
argument_list|(
name|msg
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|SERVER_ERROR
argument_list|,
name|msg
argument_list|)
throw|;
block|}
if|if
condition|(
name|getFieldTypeByName
argument_list|(
name|typeName
argument_list|)
operator|!=
literal|null
condition|)
block|{
name|String
name|msg
init|=
literal|"Field type '"
operator|+
name|typeName
operator|+
literal|"' already exists."
decl_stmt|;
name|log
operator|.
name|error
argument_list|(
name|msg
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
name|msg
argument_list|)
throw|;
block|}
comment|// build the new FieldType using the existing FieldTypePluginLoader framework
comment|// which expects XML, so we use a JSON to XML adapter to transform the JSON object
comment|// provided in the request into the XML format supported by the plugin loader
name|Map
argument_list|<
name|String
argument_list|,
name|FieldType
argument_list|>
name|newFieldTypes
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|SchemaAware
argument_list|>
name|schemaAwareList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|FieldTypePluginLoader
name|typeLoader
init|=
operator|new
name|FieldTypePluginLoader
argument_list|(
name|this
argument_list|,
name|newFieldTypes
argument_list|,
name|schemaAwareList
argument_list|)
decl_stmt|;
name|typeLoader
operator|.
name|loadSingle
argument_list|(
name|loader
argument_list|,
name|FieldTypeXmlAdapter
operator|.
name|toNode
argument_list|(
name|options
argument_list|)
argument_list|)
expr_stmt|;
name|FieldType
name|ft
init|=
name|newFieldTypes
operator|.
name|get
argument_list|(
name|typeName
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|schemaAwareList
operator|.
name|isEmpty
argument_list|()
condition|)
name|schemaAware
operator|.
name|addAll
argument_list|(
name|schemaAwareList
argument_list|)
expr_stmt|;
return|return
name|ft
return|;
block|}
comment|/**    * After creating a new FieldType, it may contain components that implement    * the ResourceLoaderAware interface, which need to be informed after they    * are loaded (as they depend on this callback to complete initialization work)    */
DECL|method|informResourceLoaderAwareObjectsInChain
specifier|protected
name|void
name|informResourceLoaderAwareObjectsInChain
parameter_list|(
name|TokenizerChain
name|chain
parameter_list|)
block|{
name|CharFilterFactory
index|[]
name|charFilters
init|=
name|chain
operator|.
name|getCharFilterFactories
argument_list|()
decl_stmt|;
for|for
control|(
name|CharFilterFactory
name|next
range|:
name|charFilters
control|)
block|{
if|if
condition|(
name|next
operator|instanceof
name|ResourceLoaderAware
condition|)
block|{
try|try
block|{
operator|(
operator|(
name|ResourceLoaderAware
operator|)
name|next
operator|)
operator|.
name|inform
argument_list|(
name|loader
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|SERVER_ERROR
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
block|}
name|TokenizerFactory
name|tokenizerFactory
init|=
name|chain
operator|.
name|getTokenizerFactory
argument_list|()
decl_stmt|;
if|if
condition|(
name|tokenizerFactory
operator|instanceof
name|ResourceLoaderAware
condition|)
block|{
try|try
block|{
operator|(
operator|(
name|ResourceLoaderAware
operator|)
name|tokenizerFactory
operator|)
operator|.
name|inform
argument_list|(
name|loader
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|SERVER_ERROR
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
name|TokenFilterFactory
index|[]
name|filters
init|=
name|chain
operator|.
name|getTokenFilterFactories
argument_list|()
decl_stmt|;
for|for
control|(
name|TokenFilterFactory
name|next
range|:
name|filters
control|)
block|{
if|if
condition|(
name|next
operator|instanceof
name|ResourceLoaderAware
condition|)
block|{
try|try
block|{
operator|(
operator|(
name|ResourceLoaderAware
operator|)
name|next
operator|)
operator|.
name|inform
argument_list|(
name|loader
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|SERVER_ERROR
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
block|}
block|}
DECL|method|ManagedIndexSchema
specifier|private
name|ManagedIndexSchema
parameter_list|(
specifier|final
name|SolrConfig
name|solrConfig
parameter_list|,
specifier|final
name|SolrResourceLoader
name|loader
parameter_list|,
name|boolean
name|isMutable
parameter_list|,
name|String
name|managedSchemaResourceName
parameter_list|,
name|int
name|schemaZkVersion
parameter_list|,
name|Object
name|schemaUpdateLock
parameter_list|)
throws|throws
name|KeeperException
throws|,
name|InterruptedException
block|{
name|super
argument_list|(
name|solrConfig
argument_list|,
name|loader
argument_list|)
expr_stmt|;
name|this
operator|.
name|isMutable
operator|=
name|isMutable
expr_stmt|;
name|this
operator|.
name|managedSchemaResourceName
operator|=
name|managedSchemaResourceName
expr_stmt|;
name|this
operator|.
name|schemaZkVersion
operator|=
name|schemaZkVersion
expr_stmt|;
name|this
operator|.
name|schemaUpdateLock
operator|=
name|schemaUpdateLock
expr_stmt|;
block|}
comment|/**    * Makes a shallow copy of this schema.    *     * Not copied: analyzers     *     * @param includeFieldDataStructures if true, fields, fieldsWithDefaultValue, and requiredFields    *                                   are copied; otherwise, they are not.    * @return A shallow copy of this schema    */
DECL|method|shallowCopy
name|ManagedIndexSchema
name|shallowCopy
parameter_list|(
name|boolean
name|includeFieldDataStructures
parameter_list|)
block|{
name|ManagedIndexSchema
name|newSchema
init|=
literal|null
decl_stmt|;
try|try
block|{
name|newSchema
operator|=
operator|new
name|ManagedIndexSchema
argument_list|(
name|solrConfig
argument_list|,
name|loader
argument_list|,
name|isMutable
argument_list|,
name|managedSchemaResourceName
argument_list|,
name|schemaZkVersion
argument_list|,
name|getSchemaUpdateLock
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|KeeperException
name|e
parameter_list|)
block|{
specifier|final
name|String
name|msg
init|=
literal|"Error instantiating ManagedIndexSchema"
decl_stmt|;
name|log
operator|.
name|error
argument_list|(
name|msg
argument_list|,
name|e
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|SolrException
argument_list|(
name|SolrException
operator|.
name|ErrorCode
operator|.
name|SERVER_ERROR
argument_list|,
name|msg
argument_list|,
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
comment|// Restore the interrupted status
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
name|log
operator|.
name|warn
argument_list|(
literal|""
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
assert|assert
name|newSchema
operator|!=
literal|null
assert|;
name|newSchema
operator|.
name|name
operator|=
name|name
expr_stmt|;
name|newSchema
operator|.
name|version
operator|=
name|version
expr_stmt|;
name|newSchema
operator|.
name|defaultSearchFieldName
operator|=
name|defaultSearchFieldName
expr_stmt|;
name|newSchema
operator|.
name|queryParserDefaultOperator
operator|=
name|queryParserDefaultOperator
expr_stmt|;
name|newSchema
operator|.
name|isExplicitQueryParserDefaultOperator
operator|=
name|isExplicitQueryParserDefaultOperator
expr_stmt|;
name|newSchema
operator|.
name|similarity
operator|=
name|similarity
expr_stmt|;
name|newSchema
operator|.
name|similarityFactory
operator|=
name|similarityFactory
expr_stmt|;
name|newSchema
operator|.
name|isExplicitSimilarity
operator|=
name|isExplicitSimilarity
expr_stmt|;
name|newSchema
operator|.
name|uniqueKeyField
operator|=
name|uniqueKeyField
expr_stmt|;
name|newSchema
operator|.
name|uniqueKeyFieldName
operator|=
name|uniqueKeyFieldName
expr_stmt|;
name|newSchema
operator|.
name|uniqueKeyFieldType
operator|=
name|uniqueKeyFieldType
expr_stmt|;
comment|// After the schema is persisted, resourceName is the same as managedSchemaResourceName
name|newSchema
operator|.
name|resourceName
operator|=
name|managedSchemaResourceName
expr_stmt|;
if|if
condition|(
name|includeFieldDataStructures
condition|)
block|{
comment|// These need new collections, since addFields() can add members to them
name|newSchema
operator|.
name|fields
operator|.
name|putAll
argument_list|(
name|fields
argument_list|)
expr_stmt|;
name|newSchema
operator|.
name|fieldsWithDefaultValue
operator|.
name|addAll
argument_list|(
name|fieldsWithDefaultValue
argument_list|)
expr_stmt|;
name|newSchema
operator|.
name|requiredFields
operator|.
name|addAll
argument_list|(
name|requiredFields
argument_list|)
expr_stmt|;
block|}
comment|// These don't need new collections - addFields() won't add members to them
name|newSchema
operator|.
name|fieldTypes
operator|=
name|fieldTypes
expr_stmt|;
name|newSchema
operator|.
name|dynamicFields
operator|=
name|dynamicFields
expr_stmt|;
name|newSchema
operator|.
name|dynamicCopyFields
operator|=
name|dynamicCopyFields
expr_stmt|;
name|newSchema
operator|.
name|copyFieldsMap
operator|=
name|copyFieldsMap
expr_stmt|;
name|newSchema
operator|.
name|copyFieldTargetCounts
operator|=
name|copyFieldTargetCounts
expr_stmt|;
name|newSchema
operator|.
name|schemaAware
operator|=
name|schemaAware
expr_stmt|;
return|return
name|newSchema
return|;
block|}
annotation|@
name|Override
DECL|method|getSchemaUpdateLock
specifier|public
name|Object
name|getSchemaUpdateLock
parameter_list|()
block|{
return|return
name|schemaUpdateLock
return|;
block|}
block|}
end_class
end_unit
