begin_unit
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_package
DECL|package|org.apache.solr.schema
package|package
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|schema
package|;
end_package
begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|xpath
operator|.
name|XPath
import|;
end_import
begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|xpath
operator|.
name|XPathConstants
import|;
end_import
begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|xpath
operator|.
name|XPathExpressionException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Writer
import|;
end_import
begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|invoke
operator|.
name|MethodHandles
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|*
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Pattern
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|Analyzer
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|DelegatingAnalyzerWrapper
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|DocValuesType
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|FieldInfo
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|IndexOptions
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|IndexReader
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|IndexableField
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|MultiFields
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|StorableField
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|StoredDocument
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|similarities
operator|.
name|Similarity
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|uninverting
operator|.
name|UninvertingReader
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|Version
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|SolrException
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|SolrException
operator|.
name|ErrorCode
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|params
operator|.
name|SolrParams
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|params
operator|.
name|ModifiableSolrParams
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|util
operator|.
name|NamedList
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|util
operator|.
name|SimpleOrderedMap
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|core
operator|.
name|Config
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|core
operator|.
name|SolrConfig
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|core
operator|.
name|SolrResourceLoader
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|request
operator|.
name|LocalSolrQueryRequest
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|response
operator|.
name|SchemaXmlWriter
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|response
operator|.
name|SolrQueryResponse
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|search
operator|.
name|similarities
operator|.
name|ClassicSimilarityFactory
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|search
operator|.
name|similarities
operator|.
name|SchemaSimilarityFactory
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|util
operator|.
name|DOMUtil
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|util
operator|.
name|plugin
operator|.
name|SolrCoreAware
import|;
end_import
begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import
begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import
begin_import
import|import
name|org
operator|.
name|w3c
operator|.
name|dom
operator|.
name|Document
import|;
end_import
begin_import
import|import
name|org
operator|.
name|w3c
operator|.
name|dom
operator|.
name|Element
import|;
end_import
begin_import
import|import
name|org
operator|.
name|w3c
operator|.
name|dom
operator|.
name|NamedNodeMap
import|;
end_import
begin_import
import|import
name|org
operator|.
name|w3c
operator|.
name|dom
operator|.
name|Node
import|;
end_import
begin_import
import|import
name|org
operator|.
name|w3c
operator|.
name|dom
operator|.
name|NodeList
import|;
end_import
begin_import
import|import
name|org
operator|.
name|xml
operator|.
name|sax
operator|.
name|InputSource
import|;
end_import
begin_import
import|import static
name|java
operator|.
name|util
operator|.
name|Collections
operator|.
name|singletonList
import|;
end_import
begin_import
import|import static
name|java
operator|.
name|util
operator|.
name|Collections
operator|.
name|singletonMap
import|;
end_import
begin_comment
comment|/**  *<code>IndexSchema</code> contains information about the valid fields in an index  * and the types of those fields.  *  *  */
end_comment
begin_class
DECL|class|IndexSchema
specifier|public
class|class
name|IndexSchema
block|{
DECL|field|COPY_FIELD
specifier|public
specifier|static
specifier|final
name|String
name|COPY_FIELD
init|=
literal|"copyField"
decl_stmt|;
DECL|field|COPY_FIELDS
specifier|public
specifier|static
specifier|final
name|String
name|COPY_FIELDS
init|=
name|COPY_FIELD
operator|+
literal|"s"
decl_stmt|;
DECL|field|DEFAULT_OPERATOR
specifier|public
specifier|static
specifier|final
name|String
name|DEFAULT_OPERATOR
init|=
literal|"defaultOperator"
decl_stmt|;
DECL|field|DEFAULT_SCHEMA_FILE
specifier|public
specifier|static
specifier|final
name|String
name|DEFAULT_SCHEMA_FILE
init|=
literal|"schema.xml"
decl_stmt|;
DECL|field|DEFAULT_SEARCH_FIELD
specifier|public
specifier|static
specifier|final
name|String
name|DEFAULT_SEARCH_FIELD
init|=
literal|"defaultSearchField"
decl_stmt|;
DECL|field|DESTINATION
specifier|public
specifier|static
specifier|final
name|String
name|DESTINATION
init|=
literal|"dest"
decl_stmt|;
DECL|field|DYNAMIC_FIELD
specifier|public
specifier|static
specifier|final
name|String
name|DYNAMIC_FIELD
init|=
literal|"dynamicField"
decl_stmt|;
DECL|field|DYNAMIC_FIELDS
specifier|public
specifier|static
specifier|final
name|String
name|DYNAMIC_FIELDS
init|=
name|DYNAMIC_FIELD
operator|+
literal|"s"
decl_stmt|;
DECL|field|FIELD
specifier|public
specifier|static
specifier|final
name|String
name|FIELD
init|=
literal|"field"
decl_stmt|;
DECL|field|FIELDS
specifier|public
specifier|static
specifier|final
name|String
name|FIELDS
init|=
name|FIELD
operator|+
literal|"s"
decl_stmt|;
DECL|field|FIELD_TYPE
specifier|public
specifier|static
specifier|final
name|String
name|FIELD_TYPE
init|=
literal|"fieldType"
decl_stmt|;
DECL|field|FIELD_TYPES
specifier|public
specifier|static
specifier|final
name|String
name|FIELD_TYPES
init|=
name|FIELD_TYPE
operator|+
literal|"s"
decl_stmt|;
DECL|field|INTERNAL_POLY_FIELD_PREFIX
specifier|public
specifier|static
specifier|final
name|String
name|INTERNAL_POLY_FIELD_PREFIX
init|=
literal|"*"
operator|+
name|FieldType
operator|.
name|POLY_FIELD_SEPARATOR
decl_stmt|;
DECL|field|LUCENE_MATCH_VERSION_PARAM
specifier|public
specifier|static
specifier|final
name|String
name|LUCENE_MATCH_VERSION_PARAM
init|=
literal|"luceneMatchVersion"
decl_stmt|;
DECL|field|MAX_CHARS
specifier|public
specifier|static
specifier|final
name|String
name|MAX_CHARS
init|=
literal|"maxChars"
decl_stmt|;
DECL|field|NAME
specifier|public
specifier|static
specifier|final
name|String
name|NAME
init|=
literal|"name"
decl_stmt|;
DECL|field|REQUIRED
specifier|public
specifier|static
specifier|final
name|String
name|REQUIRED
init|=
literal|"required"
decl_stmt|;
DECL|field|SCHEMA
specifier|public
specifier|static
specifier|final
name|String
name|SCHEMA
init|=
literal|"schema"
decl_stmt|;
DECL|field|SIMILARITY
specifier|public
specifier|static
specifier|final
name|String
name|SIMILARITY
init|=
literal|"similarity"
decl_stmt|;
DECL|field|SLASH
specifier|public
specifier|static
specifier|final
name|String
name|SLASH
init|=
literal|"/"
decl_stmt|;
DECL|field|SOLR_QUERY_PARSER
specifier|public
specifier|static
specifier|final
name|String
name|SOLR_QUERY_PARSER
init|=
literal|"solrQueryParser"
decl_stmt|;
DECL|field|SOURCE
specifier|public
specifier|static
specifier|final
name|String
name|SOURCE
init|=
literal|"source"
decl_stmt|;
DECL|field|TYPE
specifier|public
specifier|static
specifier|final
name|String
name|TYPE
init|=
literal|"type"
decl_stmt|;
DECL|field|TYPES
specifier|public
specifier|static
specifier|final
name|String
name|TYPES
init|=
literal|"types"
decl_stmt|;
DECL|field|UNIQUE_KEY
specifier|public
specifier|static
specifier|final
name|String
name|UNIQUE_KEY
init|=
literal|"uniqueKey"
decl_stmt|;
DECL|field|VERSION
specifier|public
specifier|static
specifier|final
name|String
name|VERSION
init|=
literal|"version"
decl_stmt|;
DECL|field|AT
specifier|private
specifier|static
specifier|final
name|String
name|AT
init|=
literal|"@"
decl_stmt|;
DECL|field|DESTINATION_DYNAMIC_BASE
specifier|private
specifier|static
specifier|final
name|String
name|DESTINATION_DYNAMIC_BASE
init|=
literal|"destDynamicBase"
decl_stmt|;
DECL|field|SOLR_CORE_NAME
specifier|private
specifier|static
specifier|final
name|String
name|SOLR_CORE_NAME
init|=
literal|"solr.core.name"
decl_stmt|;
DECL|field|SOURCE_DYNAMIC_BASE
specifier|private
specifier|static
specifier|final
name|String
name|SOURCE_DYNAMIC_BASE
init|=
literal|"sourceDynamicBase"
decl_stmt|;
DECL|field|SOURCE_EXPLICIT_FIELDS
specifier|private
specifier|static
specifier|final
name|String
name|SOURCE_EXPLICIT_FIELDS
init|=
literal|"sourceExplicitFields"
decl_stmt|;
DECL|field|TEXT_FUNCTION
specifier|private
specifier|static
specifier|final
name|String
name|TEXT_FUNCTION
init|=
literal|"text()"
decl_stmt|;
DECL|field|XPATH_OR
specifier|private
specifier|static
specifier|final
name|String
name|XPATH_OR
init|=
literal|" | "
decl_stmt|;
DECL|field|log
specifier|private
specifier|static
specifier|final
name|Logger
name|log
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|MethodHandles
operator|.
name|lookup
argument_list|()
operator|.
name|lookupClass
argument_list|()
argument_list|)
decl_stmt|;
DECL|field|solrConfig
specifier|protected
specifier|final
name|SolrConfig
name|solrConfig
decl_stmt|;
DECL|field|resourceName
specifier|protected
name|String
name|resourceName
decl_stmt|;
DECL|field|name
specifier|protected
name|String
name|name
decl_stmt|;
DECL|field|version
specifier|protected
name|float
name|version
decl_stmt|;
DECL|field|loader
specifier|protected
specifier|final
name|SolrResourceLoader
name|loader
decl_stmt|;
DECL|field|fields
specifier|protected
name|Map
argument_list|<
name|String
argument_list|,
name|SchemaField
argument_list|>
name|fields
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
DECL|field|fieldTypes
specifier|protected
name|Map
argument_list|<
name|String
argument_list|,
name|FieldType
argument_list|>
name|fieldTypes
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
DECL|field|fieldsWithDefaultValue
specifier|protected
name|List
argument_list|<
name|SchemaField
argument_list|>
name|fieldsWithDefaultValue
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
DECL|field|requiredFields
specifier|protected
name|Collection
argument_list|<
name|SchemaField
argument_list|>
name|requiredFields
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
DECL|field|dynamicFields
specifier|protected
specifier|volatile
name|DynamicField
index|[]
name|dynamicFields
decl_stmt|;
DECL|method|getDynamicFields
specifier|public
name|DynamicField
index|[]
name|getDynamicFields
parameter_list|()
block|{
return|return
name|dynamicFields
return|;
block|}
DECL|field|indexAnalyzer
specifier|private
name|Analyzer
name|indexAnalyzer
decl_stmt|;
DECL|field|queryAnalyzer
specifier|private
name|Analyzer
name|queryAnalyzer
decl_stmt|;
DECL|field|schemaAware
specifier|protected
name|List
argument_list|<
name|SchemaAware
argument_list|>
name|schemaAware
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
DECL|field|defaultSearchFieldName
specifier|protected
name|String
name|defaultSearchFieldName
init|=
literal|null
decl_stmt|;
DECL|field|queryParserDefaultOperator
specifier|protected
name|String
name|queryParserDefaultOperator
init|=
literal|"OR"
decl_stmt|;
DECL|field|isExplicitQueryParserDefaultOperator
specifier|protected
name|boolean
name|isExplicitQueryParserDefaultOperator
init|=
literal|false
decl_stmt|;
DECL|field|copyFieldsMap
specifier|protected
name|Map
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|CopyField
argument_list|>
argument_list|>
name|copyFieldsMap
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
DECL|method|getCopyFieldsMap
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|CopyField
argument_list|>
argument_list|>
name|getCopyFieldsMap
parameter_list|()
block|{
return|return
name|Collections
operator|.
name|unmodifiableMap
argument_list|(
name|copyFieldsMap
argument_list|)
return|;
block|}
DECL|field|dynamicCopyFields
specifier|protected
name|DynamicCopy
index|[]
name|dynamicCopyFields
decl_stmt|;
DECL|method|getDynamicCopyFields
specifier|public
name|DynamicCopy
index|[]
name|getDynamicCopyFields
parameter_list|()
block|{
return|return
name|dynamicCopyFields
return|;
block|}
comment|/**    * keys are all fields copied to, count is num of copyField    * directives that target them.    */
DECL|field|copyFieldTargetCounts
specifier|protected
name|Map
argument_list|<
name|SchemaField
argument_list|,
name|Integer
argument_list|>
name|copyFieldTargetCounts
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
comment|/**    * Constructs a schema using the specified resource name and stream.    * @see SolrResourceLoader#openSchema    * By default, this follows the normal config path directory searching rules.    * @see SolrResourceLoader#openResource    */
DECL|method|IndexSchema
specifier|public
name|IndexSchema
parameter_list|(
name|SolrConfig
name|solrConfig
parameter_list|,
name|String
name|name
parameter_list|,
name|InputSource
name|is
parameter_list|)
block|{
assert|assert
literal|null
operator|!=
name|solrConfig
operator|:
literal|"SolrConfig should never be null"
assert|;
assert|assert
literal|null
operator|!=
name|name
operator|:
literal|"schema resource name should never be null"
assert|;
assert|assert
literal|null
operator|!=
name|is
operator|:
literal|"schema InputSource should never be null"
assert|;
name|this
operator|.
name|solrConfig
operator|=
name|solrConfig
expr_stmt|;
name|this
operator|.
name|resourceName
operator|=
name|name
expr_stmt|;
name|loader
operator|=
name|solrConfig
operator|.
name|getResourceLoader
argument_list|()
expr_stmt|;
try|try
block|{
name|readSchema
argument_list|(
name|is
argument_list|)
expr_stmt|;
name|loader
operator|.
name|inform
argument_list|(
name|loader
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**    * @since solr 1.4    */
DECL|method|getResourceLoader
specifier|public
name|SolrResourceLoader
name|getResourceLoader
parameter_list|()
block|{
return|return
name|loader
return|;
block|}
comment|/** Gets the name of the resource used to instantiate this schema. */
DECL|method|getResourceName
specifier|public
name|String
name|getResourceName
parameter_list|()
block|{
return|return
name|resourceName
return|;
block|}
comment|/** Sets the name of the resource used to instantiate this schema. */
DECL|method|setResourceName
specifier|public
name|void
name|setResourceName
parameter_list|(
name|String
name|resourceName
parameter_list|)
block|{
name|this
operator|.
name|resourceName
operator|=
name|resourceName
expr_stmt|;
block|}
comment|/** Gets the name of the schema as specified in the schema resource. */
DECL|method|getSchemaName
specifier|public
name|String
name|getSchemaName
parameter_list|()
block|{
return|return
name|name
return|;
block|}
comment|/** The Default Lucene Match Version for this IndexSchema */
DECL|method|getDefaultLuceneMatchVersion
specifier|public
name|Version
name|getDefaultLuceneMatchVersion
parameter_list|()
block|{
return|return
name|solrConfig
operator|.
name|luceneMatchVersion
return|;
block|}
DECL|method|getVersion
specifier|public
name|float
name|getVersion
parameter_list|()
block|{
return|return
name|version
return|;
block|}
comment|/**    * Provides direct access to the Map containing all explicit    * (ie: non-dynamic) fields in the index, keyed on field name.    *    *<p>    * Modifying this Map (or any item in it) will affect the real schema    *</p>    *     *<p>    * NOTE: this function is not thread safe.  However, it is safe to use within the standard    *<code>inform( SolrCore core )</code> function for<code>SolrCoreAware</code> classes.    * Outside<code>inform</code>, this could potentially throw a ConcurrentModificationException    *</p>    */
DECL|method|getFields
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|SchemaField
argument_list|>
name|getFields
parameter_list|()
block|{
return|return
name|fields
return|;
block|}
comment|/**    * Provides direct access to the Map containing all Field Types    * in the index, keyed on field type name.    *    *<p>    * Modifying this Map (or any item in it) will affect the real schema.  However if you     * make any modifications, be sure to call {@link IndexSchema#refreshAnalyzers()} to    * update the Analyzers for the registered fields.    *</p>    *     *<p>    * NOTE: this function is not thread safe.  However, it is safe to use within the standard    *<code>inform( SolrCore core )</code> function for<code>SolrCoreAware</code> classes.    * Outside<code>inform</code>, this could potentially throw a ConcurrentModificationException    *</p>    */
DECL|method|getFieldTypes
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|FieldType
argument_list|>
name|getFieldTypes
parameter_list|()
block|{
return|return
name|fieldTypes
return|;
block|}
comment|/**    * Provides direct access to the List containing all fields with a default value    */
DECL|method|getFieldsWithDefaultValue
specifier|public
name|List
argument_list|<
name|SchemaField
argument_list|>
name|getFieldsWithDefaultValue
parameter_list|()
block|{
return|return
name|fieldsWithDefaultValue
return|;
block|}
comment|/**    * Provides direct access to the List containing all required fields.  This    * list contains all fields with default values.    */
DECL|method|getRequiredFields
specifier|public
name|Collection
argument_list|<
name|SchemaField
argument_list|>
name|getRequiredFields
parameter_list|()
block|{
return|return
name|requiredFields
return|;
block|}
DECL|field|similarity
specifier|protected
name|Similarity
name|similarity
decl_stmt|;
comment|/**    * Returns the Similarity used for this index    */
DECL|method|getSimilarity
specifier|public
name|Similarity
name|getSimilarity
parameter_list|()
block|{
if|if
condition|(
literal|null
operator|==
name|similarity
condition|)
block|{
name|similarity
operator|=
name|similarityFactory
operator|.
name|getSimilarity
argument_list|()
expr_stmt|;
block|}
return|return
name|similarity
return|;
block|}
DECL|field|similarityFactory
specifier|protected
name|SimilarityFactory
name|similarityFactory
decl_stmt|;
DECL|field|isExplicitSimilarity
specifier|protected
name|boolean
name|isExplicitSimilarity
init|=
literal|false
decl_stmt|;
comment|/** Returns the SimilarityFactory that constructed the Similarity for this index */
DECL|method|getSimilarityFactory
specifier|public
name|SimilarityFactory
name|getSimilarityFactory
parameter_list|()
block|{
return|return
name|similarityFactory
return|;
block|}
comment|/**    * Returns the Analyzer used when indexing documents for this index    *    *<p>    * This Analyzer is field (and dynamic field) name aware, and delegates to    * a field specific Analyzer based on the field type.    *</p>    */
DECL|method|getIndexAnalyzer
specifier|public
name|Analyzer
name|getIndexAnalyzer
parameter_list|()
block|{
return|return
name|indexAnalyzer
return|;
block|}
comment|/**    * Returns the Analyzer used when searching this index    *    *<p>    * This Analyzer is field (and dynamic field) name aware, and delegates to    * a field specific Analyzer based on the field type.    *</p>    */
DECL|method|getQueryAnalyzer
specifier|public
name|Analyzer
name|getQueryAnalyzer
parameter_list|()
block|{
return|return
name|queryAnalyzer
return|;
block|}
comment|/**    * Name of the default search field specified in the schema file.    *<br><b>Note:</b>Avoid calling this, try to use this method so that the 'df' param is consulted as an override:    * {@link org.apache.solr.search.QueryParsing#getDefaultField(IndexSchema, String)}    */
DECL|method|getDefaultSearchFieldName
specifier|public
name|String
name|getDefaultSearchFieldName
parameter_list|()
block|{
return|return
name|defaultSearchFieldName
return|;
block|}
comment|/**    * default operator ("AND" or "OR") for QueryParser    */
DECL|method|getQueryParserDefaultOperator
specifier|public
name|String
name|getQueryParserDefaultOperator
parameter_list|()
block|{
return|return
name|queryParserDefaultOperator
return|;
block|}
DECL|field|uniqueKeyField
specifier|protected
name|SchemaField
name|uniqueKeyField
decl_stmt|;
comment|/**    * Unique Key field specified in the schema file    * @return null if this schema has no unique key field    */
DECL|method|getUniqueKeyField
specifier|public
name|SchemaField
name|getUniqueKeyField
parameter_list|()
block|{
return|return
name|uniqueKeyField
return|;
block|}
DECL|field|uniqueKeyFieldName
specifier|protected
name|String
name|uniqueKeyFieldName
decl_stmt|;
DECL|field|uniqueKeyFieldType
specifier|protected
name|FieldType
name|uniqueKeyFieldType
decl_stmt|;
comment|/**    * The raw (field type encoded) value of the Unique Key field for    * the specified Document    * @return null if this schema has no unique key field    * @see #printableUniqueKey    */
DECL|method|getUniqueKeyField
specifier|public
name|IndexableField
name|getUniqueKeyField
parameter_list|(
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|document
operator|.
name|Document
name|doc
parameter_list|)
block|{
return|return
name|doc
operator|.
name|getField
argument_list|(
name|uniqueKeyFieldName
argument_list|)
return|;
comment|// this should return null if name is null
block|}
comment|/**    * The printable value of the Unique Key field for    * the specified Document    * @return null if this schema has no unique key field    */
DECL|method|printableUniqueKey
specifier|public
name|String
name|printableUniqueKey
parameter_list|(
name|StoredDocument
name|doc
parameter_list|)
block|{
name|StorableField
name|f
init|=
name|doc
operator|.
name|getField
argument_list|(
name|uniqueKeyFieldName
argument_list|)
decl_stmt|;
return|return
name|f
operator|==
literal|null
condition|?
literal|null
else|:
name|uniqueKeyFieldType
operator|.
name|toExternal
argument_list|(
name|f
argument_list|)
return|;
block|}
DECL|method|getIndexedField
specifier|private
name|SchemaField
name|getIndexedField
parameter_list|(
name|String
name|fname
parameter_list|)
block|{
name|SchemaField
name|f
init|=
name|getFields
argument_list|()
operator|.
name|get
argument_list|(
name|fname
argument_list|)
decl_stmt|;
if|if
condition|(
name|f
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"unknown field '"
operator|+
name|fname
operator|+
literal|"'"
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|f
operator|.
name|indexed
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"'"
operator|+
name|fname
operator|+
literal|"' is not an indexed field:"
operator|+
name|f
argument_list|)
throw|;
block|}
return|return
name|f
return|;
block|}
comment|/**    * This will re-create the Analyzers.  If you make any modifications to    * the Field map ({@link IndexSchema#getFields()}, this function is required    * to synch the internally cached field analyzers.    *     * @since solr 1.3    */
DECL|method|refreshAnalyzers
specifier|public
name|void
name|refreshAnalyzers
parameter_list|()
block|{
name|indexAnalyzer
operator|=
operator|new
name|SolrIndexAnalyzer
argument_list|()
expr_stmt|;
name|queryAnalyzer
operator|=
operator|new
name|SolrQueryAnalyzer
argument_list|()
expr_stmt|;
block|}
DECL|method|getUninversionMap
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|UninvertingReader
operator|.
name|Type
argument_list|>
name|getUninversionMap
parameter_list|(
name|IndexReader
name|reader
parameter_list|)
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|UninvertingReader
operator|.
name|Type
argument_list|>
name|map
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|FieldInfo
name|f
range|:
name|MultiFields
operator|.
name|getMergedFieldInfos
argument_list|(
name|reader
argument_list|)
control|)
block|{
if|if
condition|(
name|f
operator|.
name|getDocValuesType
argument_list|()
operator|==
name|DocValuesType
operator|.
name|NONE
operator|&&
name|f
operator|.
name|getIndexOptions
argument_list|()
operator|!=
name|IndexOptions
operator|.
name|NONE
condition|)
block|{
name|SchemaField
name|sf
init|=
name|getFieldOrNull
argument_list|(
name|f
operator|.
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|sf
operator|!=
literal|null
condition|)
block|{
name|UninvertingReader
operator|.
name|Type
name|type
init|=
name|sf
operator|.
name|getType
argument_list|()
operator|.
name|getUninversionType
argument_list|(
name|sf
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
operator|!=
literal|null
condition|)
block|{
name|map
operator|.
name|put
argument_list|(
name|f
operator|.
name|name
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
name|map
return|;
block|}
comment|/**    * Writes the schema in schema.xml format to the given writer     */
DECL|method|persist
name|void
name|persist
parameter_list|(
name|Writer
name|writer
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|SolrQueryResponse
name|response
init|=
operator|new
name|SolrQueryResponse
argument_list|()
decl_stmt|;
name|response
operator|.
name|add
argument_list|(
name|IndexSchema
operator|.
name|SCHEMA
argument_list|,
name|getNamedPropertyValues
argument_list|()
argument_list|)
expr_stmt|;
specifier|final
name|NamedList
name|args
init|=
operator|new
name|NamedList
argument_list|(
name|Arrays
operator|.
expr|<
name|Object
operator|>
name|asList
argument_list|(
literal|"indent"
argument_list|,
literal|"on"
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|LocalSolrQueryRequest
name|req
init|=
operator|new
name|LocalSolrQueryRequest
argument_list|(
literal|null
argument_list|,
name|args
argument_list|)
decl_stmt|;
specifier|final
name|SchemaXmlWriter
name|schemaXmlWriter
init|=
operator|new
name|SchemaXmlWriter
argument_list|(
name|writer
argument_list|,
name|req
argument_list|,
name|response
argument_list|)
decl_stmt|;
name|schemaXmlWriter
operator|.
name|setEmitManagedSchemaDoNotEditWarning
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|schemaXmlWriter
operator|.
name|writeResponse
argument_list|()
expr_stmt|;
name|schemaXmlWriter
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
DECL|method|isMutable
specifier|public
name|boolean
name|isMutable
parameter_list|()
block|{
return|return
literal|false
return|;
block|}
DECL|class|SolrIndexAnalyzer
specifier|private
class|class
name|SolrIndexAnalyzer
extends|extends
name|DelegatingAnalyzerWrapper
block|{
DECL|field|analyzers
specifier|protected
specifier|final
name|HashMap
argument_list|<
name|String
argument_list|,
name|Analyzer
argument_list|>
name|analyzers
decl_stmt|;
DECL|method|SolrIndexAnalyzer
name|SolrIndexAnalyzer
parameter_list|()
block|{
name|super
argument_list|(
name|PER_FIELD_REUSE_STRATEGY
argument_list|)
expr_stmt|;
name|analyzers
operator|=
name|analyzerCache
argument_list|()
expr_stmt|;
block|}
DECL|method|analyzerCache
specifier|protected
name|HashMap
argument_list|<
name|String
argument_list|,
name|Analyzer
argument_list|>
name|analyzerCache
parameter_list|()
block|{
name|HashMap
argument_list|<
name|String
argument_list|,
name|Analyzer
argument_list|>
name|cache
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|SchemaField
name|f
range|:
name|getFields
argument_list|()
operator|.
name|values
argument_list|()
control|)
block|{
name|Analyzer
name|analyzer
init|=
name|f
operator|.
name|getType
argument_list|()
operator|.
name|getIndexAnalyzer
argument_list|()
decl_stmt|;
name|cache
operator|.
name|put
argument_list|(
name|f
operator|.
name|getName
argument_list|()
argument_list|,
name|analyzer
argument_list|)
expr_stmt|;
block|}
return|return
name|cache
return|;
block|}
annotation|@
name|Override
DECL|method|getWrappedAnalyzer
specifier|protected
name|Analyzer
name|getWrappedAnalyzer
parameter_list|(
name|String
name|fieldName
parameter_list|)
block|{
name|Analyzer
name|analyzer
init|=
name|analyzers
operator|.
name|get
argument_list|(
name|fieldName
argument_list|)
decl_stmt|;
return|return
name|analyzer
operator|!=
literal|null
condition|?
name|analyzer
else|:
name|getDynamicFieldType
argument_list|(
name|fieldName
argument_list|)
operator|.
name|getIndexAnalyzer
argument_list|()
return|;
block|}
block|}
DECL|class|SolrQueryAnalyzer
specifier|private
class|class
name|SolrQueryAnalyzer
extends|extends
name|SolrIndexAnalyzer
block|{
DECL|method|SolrQueryAnalyzer
name|SolrQueryAnalyzer
parameter_list|()
block|{}
annotation|@
name|Override
DECL|method|analyzerCache
specifier|protected
name|HashMap
argument_list|<
name|String
argument_list|,
name|Analyzer
argument_list|>
name|analyzerCache
parameter_list|()
block|{
name|HashMap
argument_list|<
name|String
argument_list|,
name|Analyzer
argument_list|>
name|cache
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|SchemaField
name|f
range|:
name|getFields
argument_list|()
operator|.
name|values
argument_list|()
control|)
block|{
name|Analyzer
name|analyzer
init|=
name|f
operator|.
name|getType
argument_list|()
operator|.
name|getQueryAnalyzer
argument_list|()
decl_stmt|;
name|cache
operator|.
name|put
argument_list|(
name|f
operator|.
name|getName
argument_list|()
argument_list|,
name|analyzer
argument_list|)
expr_stmt|;
block|}
return|return
name|cache
return|;
block|}
annotation|@
name|Override
DECL|method|getWrappedAnalyzer
specifier|protected
name|Analyzer
name|getWrappedAnalyzer
parameter_list|(
name|String
name|fieldName
parameter_list|)
block|{
name|Analyzer
name|analyzer
init|=
name|analyzers
operator|.
name|get
argument_list|(
name|fieldName
argument_list|)
decl_stmt|;
return|return
name|analyzer
operator|!=
literal|null
condition|?
name|analyzer
else|:
name|getDynamicFieldType
argument_list|(
name|fieldName
argument_list|)
operator|.
name|getQueryAnalyzer
argument_list|()
return|;
block|}
block|}
DECL|method|readSchema
specifier|protected
name|void
name|readSchema
parameter_list|(
name|InputSource
name|is
parameter_list|)
block|{
try|try
block|{
comment|// pass the config resource loader to avoid building an empty one for no reason:
comment|// in the current case though, the stream is valid so we wont load the resource by name
name|Config
name|schemaConf
init|=
operator|new
name|Config
argument_list|(
name|loader
argument_list|,
name|SCHEMA
argument_list|,
name|is
argument_list|,
name|SLASH
operator|+
name|SCHEMA
operator|+
name|SLASH
argument_list|)
decl_stmt|;
name|Document
name|document
init|=
name|schemaConf
operator|.
name|getDocument
argument_list|()
decl_stmt|;
specifier|final
name|XPath
name|xpath
init|=
name|schemaConf
operator|.
name|getXPath
argument_list|()
decl_stmt|;
name|String
name|expression
init|=
name|stepsToPath
argument_list|(
name|SCHEMA
argument_list|,
name|AT
operator|+
name|NAME
argument_list|)
decl_stmt|;
name|Node
name|nd
init|=
operator|(
name|Node
operator|)
name|xpath
operator|.
name|evaluate
argument_list|(
name|expression
argument_list|,
name|document
argument_list|,
name|XPathConstants
operator|.
name|NODE
argument_list|)
decl_stmt|;
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
comment|// Another case where the initialization from the test harness is different than the "real world"
name|sb
operator|.
name|append
argument_list|(
literal|"["
argument_list|)
expr_stmt|;
if|if
condition|(
name|loader
operator|.
name|getCoreProperties
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|loader
operator|.
name|getCoreProperties
argument_list|()
operator|.
name|getProperty
argument_list|(
name|SOLR_CORE_NAME
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sb
operator|.
name|append
argument_list|(
literal|"null"
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
literal|"] "
argument_list|)
expr_stmt|;
if|if
condition|(
name|nd
operator|==
literal|null
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|"schema has no name!"
argument_list|)
expr_stmt|;
name|log
operator|.
name|warn
argument_list|(
name|sb
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|name
operator|=
name|nd
operator|.
name|getNodeValue
argument_list|()
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"Schema "
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|NAME
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"="
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
name|sb
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|//                      /schema/@version
name|expression
operator|=
name|stepsToPath
argument_list|(
name|SCHEMA
argument_list|,
name|AT
operator|+
name|VERSION
argument_list|)
expr_stmt|;
name|version
operator|=
name|schemaConf
operator|.
name|getFloat
argument_list|(
name|expression
argument_list|,
literal|1.0f
argument_list|)
expr_stmt|;
comment|// load the Field Types
specifier|final
name|FieldTypePluginLoader
name|typeLoader
init|=
operator|new
name|FieldTypePluginLoader
argument_list|(
name|this
argument_list|,
name|fieldTypes
argument_list|,
name|schemaAware
argument_list|)
decl_stmt|;
name|expression
operator|=
name|getFieldTypeXPathExpressions
argument_list|()
expr_stmt|;
name|NodeList
name|nodes
init|=
operator|(
name|NodeList
operator|)
name|xpath
operator|.
name|evaluate
argument_list|(
name|expression
argument_list|,
name|document
argument_list|,
name|XPathConstants
operator|.
name|NODESET
argument_list|)
decl_stmt|;
name|typeLoader
operator|.
name|load
argument_list|(
name|loader
argument_list|,
name|nodes
argument_list|)
expr_stmt|;
comment|// load the fields
name|Map
argument_list|<
name|String
argument_list|,
name|Boolean
argument_list|>
name|explicitRequiredProp
init|=
name|loadFields
argument_list|(
name|document
argument_list|,
name|xpath
argument_list|)
decl_stmt|;
name|expression
operator|=
name|stepsToPath
argument_list|(
name|SCHEMA
argument_list|,
name|SIMILARITY
argument_list|)
expr_stmt|;
comment|//   /schema/similarity
name|Node
name|node
init|=
operator|(
name|Node
operator|)
name|xpath
operator|.
name|evaluate
argument_list|(
name|expression
argument_list|,
name|document
argument_list|,
name|XPathConstants
operator|.
name|NODE
argument_list|)
decl_stmt|;
name|similarityFactory
operator|=
name|readSimilarity
argument_list|(
name|loader
argument_list|,
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|similarityFactory
operator|==
literal|null
condition|)
block|{
specifier|final
name|boolean
name|modernSim
init|=
name|getDefaultLuceneMatchVersion
argument_list|()
operator|.
name|onOrAfter
argument_list|(
name|Version
operator|.
name|LUCENE_6_0_0
argument_list|)
decl_stmt|;
specifier|final
name|Class
name|simClass
init|=
name|modernSim
condition|?
name|SchemaSimilarityFactory
operator|.
name|class
else|:
name|ClassicSimilarityFactory
operator|.
name|class
decl_stmt|;
comment|// use the loader to ensure proper SolrCoreAware handling
name|similarityFactory
operator|=
name|loader
operator|.
name|newInstance
argument_list|(
name|simClass
operator|.
name|getName
argument_list|()
argument_list|,
name|SimilarityFactory
operator|.
name|class
argument_list|)
expr_stmt|;
name|similarityFactory
operator|.
name|init
argument_list|(
operator|new
name|ModifiableSolrParams
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|isExplicitSimilarity
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|similarityFactory
operator|instanceof
name|SolrCoreAware
operator|)
condition|)
block|{
comment|// if the sim factory isn't SolrCoreAware (and hence schema aware),
comment|// then we are responsible for erroring if a field type is trying to specify a sim.
for|for
control|(
name|FieldType
name|ft
range|:
name|fieldTypes
operator|.
name|values
argument_list|()
control|)
block|{
if|if
condition|(
literal|null
operator|!=
name|ft
operator|.
name|getSimilarity
argument_list|()
condition|)
block|{
name|String
name|msg
init|=
literal|"FieldType '"
operator|+
name|ft
operator|.
name|getTypeName
argument_list|()
operator|+
literal|"' is configured with a similarity, but the global similarity does not support it: "
operator|+
name|similarityFactory
operator|.
name|getClass
argument_list|()
decl_stmt|;
name|log
operator|.
name|error
argument_list|(
name|msg
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|SERVER_ERROR
argument_list|,
name|msg
argument_list|)
throw|;
block|}
block|}
block|}
comment|//                      /schema/defaultSearchField/text()
name|expression
operator|=
name|stepsToPath
argument_list|(
name|SCHEMA
argument_list|,
name|DEFAULT_SEARCH_FIELD
argument_list|,
name|TEXT_FUNCTION
argument_list|)
expr_stmt|;
name|node
operator|=
operator|(
name|Node
operator|)
name|xpath
operator|.
name|evaluate
argument_list|(
name|expression
argument_list|,
name|document
argument_list|,
name|XPathConstants
operator|.
name|NODE
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|==
literal|null
condition|)
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"no default search field specified in schema."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|defaultSearchFieldName
operator|=
name|node
operator|.
name|getNodeValue
argument_list|()
operator|.
name|trim
argument_list|()
expr_stmt|;
comment|// throw exception if specified, but not found or not indexed
if|if
condition|(
name|defaultSearchFieldName
operator|!=
literal|null
condition|)
block|{
name|SchemaField
name|defaultSearchField
init|=
name|getFields
argument_list|()
operator|.
name|get
argument_list|(
name|defaultSearchFieldName
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|defaultSearchField
operator|==
literal|null
operator|)
operator|||
operator|!
name|defaultSearchField
operator|.
name|indexed
argument_list|()
condition|)
block|{
name|String
name|msg
init|=
literal|"default search field '"
operator|+
name|defaultSearchFieldName
operator|+
literal|"' not defined or not indexed"
decl_stmt|;
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|SERVER_ERROR
argument_list|,
name|msg
argument_list|)
throw|;
block|}
block|}
name|log
operator|.
name|info
argument_list|(
literal|"default search field in schema is "
operator|+
name|defaultSearchFieldName
argument_list|)
expr_stmt|;
block|}
comment|//                      /schema/solrQueryParser/@defaultOperator
name|expression
operator|=
name|stepsToPath
argument_list|(
name|SCHEMA
argument_list|,
name|SOLR_QUERY_PARSER
argument_list|,
name|AT
operator|+
name|DEFAULT_OPERATOR
argument_list|)
expr_stmt|;
name|node
operator|=
operator|(
name|Node
operator|)
name|xpath
operator|.
name|evaluate
argument_list|(
name|expression
argument_list|,
name|document
argument_list|,
name|XPathConstants
operator|.
name|NODE
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|==
literal|null
condition|)
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"using default query parser operator (OR)"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|isExplicitQueryParserDefaultOperator
operator|=
literal|true
expr_stmt|;
name|queryParserDefaultOperator
operator|=
name|node
operator|.
name|getNodeValue
argument_list|()
operator|.
name|trim
argument_list|()
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"query parser default operator is "
operator|+
name|queryParserDefaultOperator
argument_list|)
expr_stmt|;
block|}
comment|//                      /schema/uniqueKey/text()
name|expression
operator|=
name|stepsToPath
argument_list|(
name|SCHEMA
argument_list|,
name|UNIQUE_KEY
argument_list|,
name|TEXT_FUNCTION
argument_list|)
expr_stmt|;
name|node
operator|=
operator|(
name|Node
operator|)
name|xpath
operator|.
name|evaluate
argument_list|(
name|expression
argument_list|,
name|document
argument_list|,
name|XPathConstants
operator|.
name|NODE
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|==
literal|null
condition|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"no "
operator|+
name|UNIQUE_KEY
operator|+
literal|" specified in schema."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|uniqueKeyField
operator|=
name|getIndexedField
argument_list|(
name|node
operator|.
name|getNodeValue
argument_list|()
operator|.
name|trim
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
literal|null
operator|!=
name|uniqueKeyField
operator|.
name|getDefaultValue
argument_list|()
condition|)
block|{
name|String
name|msg
init|=
name|UNIQUE_KEY
operator|+
literal|" field ("
operator|+
name|uniqueKeyFieldName
operator|+
literal|") can not be configured with a default value ("
operator|+
name|uniqueKeyField
operator|.
name|getDefaultValue
argument_list|()
operator|+
literal|")"
decl_stmt|;
name|log
operator|.
name|error
argument_list|(
name|msg
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|SERVER_ERROR
argument_list|,
name|msg
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|uniqueKeyField
operator|.
name|stored
argument_list|()
condition|)
block|{
name|log
operator|.
name|warn
argument_list|(
name|UNIQUE_KEY
operator|+
literal|" is not stored - distributed search and MoreLikeThis will not work"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|uniqueKeyField
operator|.
name|multiValued
argument_list|()
condition|)
block|{
name|String
name|msg
init|=
name|UNIQUE_KEY
operator|+
literal|" field ("
operator|+
name|uniqueKeyFieldName
operator|+
literal|") can not be configured to be multivalued"
decl_stmt|;
name|log
operator|.
name|error
argument_list|(
name|msg
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|SERVER_ERROR
argument_list|,
name|msg
argument_list|)
throw|;
block|}
name|uniqueKeyFieldName
operator|=
name|uniqueKeyField
operator|.
name|getName
argument_list|()
expr_stmt|;
name|uniqueKeyFieldType
operator|=
name|uniqueKeyField
operator|.
name|getType
argument_list|()
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"unique key field: "
operator|+
name|uniqueKeyFieldName
argument_list|)
expr_stmt|;
comment|// Unless the uniqueKeyField is marked 'required=false' then make sure it exists
if|if
condition|(
name|Boolean
operator|.
name|FALSE
operator|!=
name|explicitRequiredProp
operator|.
name|get
argument_list|(
name|uniqueKeyFieldName
argument_list|)
condition|)
block|{
name|uniqueKeyField
operator|.
name|required
operator|=
literal|true
expr_stmt|;
name|requiredFields
operator|.
name|add
argument_list|(
name|uniqueKeyField
argument_list|)
expr_stmt|;
block|}
block|}
comment|/////////////// parse out copyField commands ///////////////
comment|// Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();
comment|// expression = "/schema/copyField";
name|dynamicCopyFields
operator|=
operator|new
name|DynamicCopy
index|[]
block|{}
expr_stmt|;
name|loadCopyFields
argument_list|(
name|document
argument_list|,
name|xpath
argument_list|)
expr_stmt|;
name|postReadInform
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SolrException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|getErrorCode
argument_list|(
name|e
operator|.
name|code
argument_list|()
argument_list|)
argument_list|,
literal|"Can't load schema "
operator|+
name|loader
operator|.
name|resourceLocation
argument_list|(
name|resourceName
argument_list|)
operator|+
literal|": "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
comment|// unexpected exception...
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|SERVER_ERROR
argument_list|,
literal|"Can't load schema "
operator|+
name|loader
operator|.
name|resourceLocation
argument_list|(
name|resourceName
argument_list|)
operator|+
literal|": "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
comment|// create the field analyzers
name|refreshAnalyzers
argument_list|()
expr_stmt|;
block|}
DECL|method|postReadInform
specifier|protected
name|void
name|postReadInform
parameter_list|()
block|{
comment|//Run the callbacks on SchemaAware now that everything else is done
for|for
control|(
name|SchemaAware
name|aware
range|:
name|schemaAware
control|)
block|{
name|aware
operator|.
name|inform
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**     * Loads fields and dynamic fields.    *     * @return a map from field name to explicit required value      */
DECL|method|loadFields
specifier|protected
specifier|synchronized
name|Map
argument_list|<
name|String
argument_list|,
name|Boolean
argument_list|>
name|loadFields
parameter_list|(
name|Document
name|document
parameter_list|,
name|XPath
name|xpath
parameter_list|)
throws|throws
name|XPathExpressionException
block|{
comment|// Hang on to the fields that say if they are required -- this lets us set a reasonable default for the unique key
name|Map
argument_list|<
name|String
argument_list|,
name|Boolean
argument_list|>
name|explicitRequiredProp
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|DynamicField
argument_list|>
name|dFields
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
comment|//                  /schema/field | /schema/dynamicField | /schema/fields/field | /schema/fields/dynamicField
name|String
name|expression
init|=
name|stepsToPath
argument_list|(
name|SCHEMA
argument_list|,
name|FIELD
argument_list|)
operator|+
name|XPATH_OR
operator|+
name|stepsToPath
argument_list|(
name|SCHEMA
argument_list|,
name|DYNAMIC_FIELD
argument_list|)
operator|+
name|XPATH_OR
operator|+
name|stepsToPath
argument_list|(
name|SCHEMA
argument_list|,
name|FIELDS
argument_list|,
name|FIELD
argument_list|)
operator|+
name|XPATH_OR
operator|+
name|stepsToPath
argument_list|(
name|SCHEMA
argument_list|,
name|FIELDS
argument_list|,
name|DYNAMIC_FIELD
argument_list|)
decl_stmt|;
name|NodeList
name|nodes
init|=
operator|(
name|NodeList
operator|)
name|xpath
operator|.
name|evaluate
argument_list|(
name|expression
argument_list|,
name|document
argument_list|,
name|XPathConstants
operator|.
name|NODESET
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nodes
operator|.
name|getLength
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|Node
name|node
init|=
name|nodes
operator|.
name|item
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|NamedNodeMap
name|attrs
init|=
name|node
operator|.
name|getAttributes
argument_list|()
decl_stmt|;
name|String
name|name
init|=
name|DOMUtil
operator|.
name|getAttr
argument_list|(
name|attrs
argument_list|,
name|NAME
argument_list|,
literal|"field definition"
argument_list|)
decl_stmt|;
name|log
operator|.
name|trace
argument_list|(
literal|"reading field def "
operator|+
name|name
argument_list|)
expr_stmt|;
name|String
name|type
init|=
name|DOMUtil
operator|.
name|getAttr
argument_list|(
name|attrs
argument_list|,
name|TYPE
argument_list|,
literal|"field "
operator|+
name|name
argument_list|)
decl_stmt|;
name|FieldType
name|ft
init|=
name|fieldTypes
operator|.
name|get
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|ft
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
literal|"Unknown "
operator|+
name|FIELD_TYPE
operator|+
literal|" '"
operator|+
name|type
operator|+
literal|"' specified on field "
operator|+
name|name
argument_list|)
throw|;
block|}
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|args
init|=
name|DOMUtil
operator|.
name|toMapExcept
argument_list|(
name|attrs
argument_list|,
name|NAME
argument_list|,
name|TYPE
argument_list|)
decl_stmt|;
if|if
condition|(
literal|null
operator|!=
name|args
operator|.
name|get
argument_list|(
name|REQUIRED
argument_list|)
condition|)
block|{
name|explicitRequiredProp
operator|.
name|put
argument_list|(
name|name
argument_list|,
name|Boolean
operator|.
name|valueOf
argument_list|(
name|args
operator|.
name|get
argument_list|(
name|REQUIRED
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|SchemaField
name|f
init|=
name|SchemaField
operator|.
name|create
argument_list|(
name|name
argument_list|,
name|ft
argument_list|,
name|args
argument_list|)
decl_stmt|;
if|if
condition|(
name|node
operator|.
name|getNodeName
argument_list|()
operator|.
name|equals
argument_list|(
name|FIELD
argument_list|)
condition|)
block|{
name|SchemaField
name|old
init|=
name|fields
operator|.
name|put
argument_list|(
name|f
operator|.
name|getName
argument_list|()
argument_list|,
name|f
argument_list|)
decl_stmt|;
if|if
condition|(
name|old
operator|!=
literal|null
condition|)
block|{
name|String
name|msg
init|=
literal|"[schema.xml] Duplicate field definition for '"
operator|+
name|f
operator|.
name|getName
argument_list|()
operator|+
literal|"' [[["
operator|+
name|old
operator|.
name|toString
argument_list|()
operator|+
literal|"]]] and [[["
operator|+
name|f
operator|.
name|toString
argument_list|()
operator|+
literal|"]]]"
decl_stmt|;
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|SERVER_ERROR
argument_list|,
name|msg
argument_list|)
throw|;
block|}
name|log
operator|.
name|debug
argument_list|(
literal|"field defined: "
operator|+
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|.
name|getDefaultValue
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|log
operator|.
name|debug
argument_list|(
name|name
operator|+
literal|" contains default value: "
operator|+
name|f
operator|.
name|getDefaultValue
argument_list|()
argument_list|)
expr_stmt|;
name|fieldsWithDefaultValue
operator|.
name|add
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|f
operator|.
name|isRequired
argument_list|()
condition|)
block|{
name|log
operator|.
name|debug
argument_list|(
name|name
operator|+
literal|" is required in this schema"
argument_list|)
expr_stmt|;
name|requiredFields
operator|.
name|add
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|node
operator|.
name|getNodeName
argument_list|()
operator|.
name|equals
argument_list|(
name|DYNAMIC_FIELD
argument_list|)
condition|)
block|{
if|if
condition|(
name|isValidDynamicField
argument_list|(
name|dFields
argument_list|,
name|f
argument_list|)
condition|)
block|{
name|addDynamicFieldNoDupCheck
argument_list|(
name|dFields
argument_list|,
name|f
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// we should never get here
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Unknown field type"
argument_list|)
throw|;
block|}
block|}
comment|//fields with default values are by definition required
comment|//add them to required fields, and we only have to loop once
comment|// in DocumentBuilder.getDoc()
name|requiredFields
operator|.
name|addAll
argument_list|(
name|fieldsWithDefaultValue
argument_list|)
expr_stmt|;
name|dynamicFields
operator|=
name|dynamicFieldListToSortedArray
argument_list|(
name|dFields
argument_list|)
expr_stmt|;
return|return
name|explicitRequiredProp
return|;
block|}
comment|/**    * Sort the dynamic fields and stuff them in a normal array for faster access.    */
DECL|method|dynamicFieldListToSortedArray
specifier|protected
specifier|static
name|DynamicField
index|[]
name|dynamicFieldListToSortedArray
parameter_list|(
name|List
argument_list|<
name|DynamicField
argument_list|>
name|dynamicFieldList
parameter_list|)
block|{
comment|// Avoid creating the array twice by converting to an array first and using Arrays.sort(),
comment|// rather than Collections.sort() then converting to an array, since Collections.sort()
comment|// copies to an array first, then sets each collection member from the array.
name|DynamicField
index|[]
name|dFields
init|=
name|dynamicFieldList
operator|.
name|toArray
argument_list|(
operator|new
name|DynamicField
index|[
name|dynamicFieldList
operator|.
name|size
argument_list|()
index|]
argument_list|)
decl_stmt|;
name|Arrays
operator|.
name|sort
argument_list|(
name|dFields
argument_list|)
expr_stmt|;
name|log
operator|.
name|trace
argument_list|(
literal|"Dynamic Field Ordering:"
operator|+
name|Arrays
operator|.
name|toString
argument_list|(
name|dFields
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|dFields
return|;
block|}
comment|/**    * Loads the copy fields    */
DECL|method|loadCopyFields
specifier|protected
specifier|synchronized
name|void
name|loadCopyFields
parameter_list|(
name|Document
name|document
parameter_list|,
name|XPath
name|xpath
parameter_list|)
throws|throws
name|XPathExpressionException
block|{
name|String
name|expression
init|=
literal|"//"
operator|+
name|COPY_FIELD
decl_stmt|;
name|NodeList
name|nodes
init|=
operator|(
name|NodeList
operator|)
name|xpath
operator|.
name|evaluate
argument_list|(
name|expression
argument_list|,
name|document
argument_list|,
name|XPathConstants
operator|.
name|NODESET
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nodes
operator|.
name|getLength
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|Node
name|node
init|=
name|nodes
operator|.
name|item
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|NamedNodeMap
name|attrs
init|=
name|node
operator|.
name|getAttributes
argument_list|()
decl_stmt|;
name|String
name|source
init|=
name|DOMUtil
operator|.
name|getAttr
argument_list|(
name|attrs
argument_list|,
name|SOURCE
argument_list|,
name|COPY_FIELD
operator|+
literal|" definition"
argument_list|)
decl_stmt|;
name|String
name|dest
init|=
name|DOMUtil
operator|.
name|getAttr
argument_list|(
name|attrs
argument_list|,
name|DESTINATION
argument_list|,
name|COPY_FIELD
operator|+
literal|" definition"
argument_list|)
decl_stmt|;
name|String
name|maxChars
init|=
name|DOMUtil
operator|.
name|getAttr
argument_list|(
name|attrs
argument_list|,
name|MAX_CHARS
argument_list|)
decl_stmt|;
name|int
name|maxCharsInt
init|=
name|CopyField
operator|.
name|UNLIMITED
decl_stmt|;
if|if
condition|(
name|maxChars
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|maxCharsInt
operator|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|maxChars
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|e
parameter_list|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Couldn't parse "
operator|+
name|MAX_CHARS
operator|+
literal|" attribute for "
operator|+
name|COPY_FIELD
operator|+
literal|" from "
operator|+
name|source
operator|+
literal|" to "
operator|+
name|dest
operator|+
literal|" as integer. The whole field will be copied."
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|dest
operator|.
name|equals
argument_list|(
name|uniqueKeyFieldName
argument_list|)
condition|)
block|{
name|String
name|msg
init|=
name|UNIQUE_KEY
operator|+
literal|" field ("
operator|+
name|uniqueKeyFieldName
operator|+
literal|") can not be the "
operator|+
name|DESTINATION
operator|+
literal|" of a "
operator|+
name|COPY_FIELD
operator|+
literal|"("
operator|+
name|SOURCE
operator|+
literal|"="
operator|+
name|source
operator|+
literal|")"
decl_stmt|;
name|log
operator|.
name|error
argument_list|(
name|msg
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|SERVER_ERROR
argument_list|,
name|msg
argument_list|)
throw|;
block|}
name|registerCopyField
argument_list|(
name|source
argument_list|,
name|dest
argument_list|,
name|maxCharsInt
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|SchemaField
argument_list|,
name|Integer
argument_list|>
name|entry
range|:
name|copyFieldTargetCounts
operator|.
name|entrySet
argument_list|()
control|)
block|{
if|if
condition|(
name|entry
operator|.
name|getValue
argument_list|()
operator|>
literal|1
operator|&&
operator|!
name|entry
operator|.
name|getKey
argument_list|()
operator|.
name|multiValued
argument_list|()
condition|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Field "
operator|+
name|entry
operator|.
name|getKey
argument_list|()
operator|.
name|name
operator|+
literal|" is not multivalued "
operator|+
literal|"and destination for multiple "
operator|+
name|COPY_FIELDS
operator|+
literal|" ("
operator|+
name|entry
operator|.
name|getValue
argument_list|()
operator|+
literal|")"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Converts a sequence of path steps into a rooted path, by inserting slashes in front of each step.    * @param steps The steps to join with slashes to form a path    * @return a rooted path: a leading slash followed by the given steps joined with slashes    */
DECL|method|stepsToPath
specifier|private
name|String
name|stepsToPath
parameter_list|(
name|String
modifier|...
name|steps
parameter_list|)
block|{
name|StringBuilder
name|builder
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|step
range|:
name|steps
control|)
block|{
name|builder
operator|.
name|append
argument_list|(
name|SLASH
argument_list|)
operator|.
name|append
argument_list|(
name|step
argument_list|)
expr_stmt|;
block|}
return|return
name|builder
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/** Returns true if the given name has exactly one asterisk either at the start or end of the name */
DECL|method|isValidFieldGlob
specifier|protected
specifier|static
name|boolean
name|isValidFieldGlob
parameter_list|(
name|String
name|name
parameter_list|)
block|{
if|if
condition|(
name|name
operator|.
name|startsWith
argument_list|(
literal|"*"
argument_list|)
operator|||
name|name
operator|.
name|endsWith
argument_list|(
literal|"*"
argument_list|)
condition|)
block|{
name|int
name|count
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|pos
init|=
literal|0
init|;
name|pos
operator|<
name|name
operator|.
name|length
argument_list|()
operator|&&
operator|-
literal|1
operator|!=
operator|(
name|pos
operator|=
name|name
operator|.
name|indexOf
argument_list|(
literal|'*'
argument_list|,
name|pos
argument_list|)
operator|)
condition|;
operator|++
name|pos
control|)
operator|++
name|count
expr_stmt|;
if|if
condition|(
literal|1
operator|==
name|count
condition|)
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
DECL|method|isValidDynamicField
specifier|protected
name|boolean
name|isValidDynamicField
parameter_list|(
name|List
argument_list|<
name|DynamicField
argument_list|>
name|dFields
parameter_list|,
name|SchemaField
name|f
parameter_list|)
block|{
name|String
name|glob
init|=
name|f
operator|.
name|getName
argument_list|()
decl_stmt|;
if|if
condition|(
name|f
operator|.
name|getDefaultValue
argument_list|()
operator|!=
literal|null
condition|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|SERVER_ERROR
argument_list|,
name|DYNAMIC_FIELD
operator|+
literal|" can not have a default value: "
operator|+
name|glob
argument_list|)
throw|;
block|}
if|if
condition|(
name|f
operator|.
name|isRequired
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|SERVER_ERROR
argument_list|,
name|DYNAMIC_FIELD
operator|+
literal|" can not be required: "
operator|+
name|glob
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|isValidFieldGlob
argument_list|(
name|glob
argument_list|)
condition|)
block|{
name|String
name|msg
init|=
literal|"Dynamic field name '"
operator|+
name|glob
operator|+
literal|"' should have either a leading or a trailing asterisk, and no others."
decl_stmt|;
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|SERVER_ERROR
argument_list|,
name|msg
argument_list|)
throw|;
block|}
if|if
condition|(
name|isDuplicateDynField
argument_list|(
name|dFields
argument_list|,
name|f
argument_list|)
condition|)
block|{
name|String
name|msg
init|=
literal|"[schema.xml] Duplicate DynamicField definition for '"
operator|+
name|glob
operator|+
literal|"'"
decl_stmt|;
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|SERVER_ERROR
argument_list|,
name|msg
argument_list|)
throw|;
block|}
return|return
literal|true
return|;
block|}
comment|/**    * Register one or more new Dynamic Fields with the Schema.    * @param fields The sequence of {@link org.apache.solr.schema.SchemaField}    */
DECL|method|registerDynamicFields
specifier|public
name|void
name|registerDynamicFields
parameter_list|(
name|SchemaField
modifier|...
name|fields
parameter_list|)
block|{
name|List
argument_list|<
name|DynamicField
argument_list|>
name|dynFields
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|dynamicFields
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|SchemaField
name|field
range|:
name|fields
control|)
block|{
if|if
condition|(
name|isDuplicateDynField
argument_list|(
name|dynFields
argument_list|,
name|field
argument_list|)
condition|)
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"dynamic field already exists: dynamic field: ["
operator|+
name|field
operator|.
name|getName
argument_list|()
operator|+
literal|"]"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"dynamic field creation for schema field: "
operator|+
name|field
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|addDynamicFieldNoDupCheck
argument_list|(
name|dynFields
argument_list|,
name|field
argument_list|)
expr_stmt|;
block|}
block|}
name|dynamicFields
operator|=
name|dynamicFieldListToSortedArray
argument_list|(
name|dynFields
argument_list|)
expr_stmt|;
block|}
DECL|method|addDynamicFieldNoDupCheck
specifier|private
name|void
name|addDynamicFieldNoDupCheck
parameter_list|(
name|List
argument_list|<
name|DynamicField
argument_list|>
name|dFields
parameter_list|,
name|SchemaField
name|f
parameter_list|)
block|{
name|dFields
operator|.
name|add
argument_list|(
operator|new
name|DynamicField
argument_list|(
name|f
argument_list|)
argument_list|)
expr_stmt|;
name|log
operator|.
name|debug
argument_list|(
literal|"dynamic field defined: "
operator|+
name|f
argument_list|)
expr_stmt|;
block|}
DECL|method|isDuplicateDynField
specifier|protected
name|boolean
name|isDuplicateDynField
parameter_list|(
name|List
argument_list|<
name|DynamicField
argument_list|>
name|dFields
parameter_list|,
name|SchemaField
name|f
parameter_list|)
block|{
for|for
control|(
name|DynamicField
name|df
range|:
name|dFields
control|)
block|{
if|if
condition|(
name|df
operator|.
name|getRegex
argument_list|()
operator|.
name|equals
argument_list|(
name|f
operator|.
name|name
argument_list|)
condition|)
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
DECL|method|registerCopyField
specifier|public
name|void
name|registerCopyField
parameter_list|(
name|String
name|source
parameter_list|,
name|String
name|dest
parameter_list|)
block|{
name|registerCopyField
argument_list|(
name|source
argument_list|,
name|dest
argument_list|,
name|CopyField
operator|.
name|UNLIMITED
argument_list|)
expr_stmt|;
block|}
comment|/**    *<p>    * NOTE: this function is not thread safe.  However, it is safe to use within the standard    *<code>inform( SolrCore core )</code> function for<code>SolrCoreAware</code> classes.    * Outside<code>inform</code>, this could potentially throw a ConcurrentModificationException    *</p>    *     * @see SolrCoreAware    */
DECL|method|registerCopyField
specifier|public
name|void
name|registerCopyField
parameter_list|(
name|String
name|source
parameter_list|,
name|String
name|dest
parameter_list|,
name|int
name|maxChars
parameter_list|)
block|{
name|log
operator|.
name|debug
argument_list|(
name|COPY_FIELD
operator|+
literal|" "
operator|+
name|SOURCE
operator|+
literal|"='"
operator|+
name|source
operator|+
literal|"' "
operator|+
name|DESTINATION
operator|+
literal|"='"
operator|+
name|dest
operator|+
literal|"' "
operator|+
name|MAX_CHARS
operator|+
literal|"="
operator|+
name|maxChars
argument_list|)
expr_stmt|;
name|DynamicField
name|destDynamicField
init|=
literal|null
decl_stmt|;
name|SchemaField
name|destSchemaField
init|=
name|fields
operator|.
name|get
argument_list|(
name|dest
argument_list|)
decl_stmt|;
name|SchemaField
name|sourceSchemaField
init|=
name|fields
operator|.
name|get
argument_list|(
name|source
argument_list|)
decl_stmt|;
name|DynamicField
name|sourceDynamicBase
init|=
literal|null
decl_stmt|;
name|DynamicField
name|destDynamicBase
init|=
literal|null
decl_stmt|;
name|boolean
name|sourceIsDynamicFieldReference
init|=
literal|false
decl_stmt|;
name|boolean
name|sourceIsExplicitFieldGlob
init|=
literal|false
decl_stmt|;
specifier|final
name|String
name|invalidGlobMessage
init|=
literal|"is an invalid glob: either it contains more than one asterisk,"
operator|+
literal|" or the asterisk occurs neither at the start nor at the end."
decl_stmt|;
specifier|final
name|boolean
name|sourceIsGlob
init|=
name|isValidFieldGlob
argument_list|(
name|source
argument_list|)
decl_stmt|;
if|if
condition|(
name|source
operator|.
name|contains
argument_list|(
literal|"*"
argument_list|)
operator|&&
operator|!
name|sourceIsGlob
condition|)
block|{
name|String
name|msg
init|=
literal|"copyField source :'"
operator|+
name|source
operator|+
literal|"' "
operator|+
name|invalidGlobMessage
decl_stmt|;
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|SERVER_ERROR
argument_list|,
name|msg
argument_list|)
throw|;
block|}
if|if
condition|(
name|dest
operator|.
name|contains
argument_list|(
literal|"*"
argument_list|)
operator|&&
operator|!
name|isValidFieldGlob
argument_list|(
name|dest
argument_list|)
condition|)
block|{
name|String
name|msg
init|=
literal|"copyField dest :'"
operator|+
name|dest
operator|+
literal|"' "
operator|+
name|invalidGlobMessage
decl_stmt|;
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|SERVER_ERROR
argument_list|,
name|msg
argument_list|)
throw|;
block|}
if|if
condition|(
literal|null
operator|==
name|sourceSchemaField
operator|&&
name|sourceIsGlob
condition|)
block|{
name|Pattern
name|pattern
init|=
name|Pattern
operator|.
name|compile
argument_list|(
name|source
operator|.
name|replace
argument_list|(
literal|"*"
argument_list|,
literal|".*"
argument_list|)
argument_list|)
decl_stmt|;
comment|// glob->regex
for|for
control|(
name|String
name|field
range|:
name|fields
operator|.
name|keySet
argument_list|()
control|)
block|{
if|if
condition|(
name|pattern
operator|.
name|matcher
argument_list|(
name|field
argument_list|)
operator|.
name|matches
argument_list|()
condition|)
block|{
name|sourceIsExplicitFieldGlob
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
literal|null
operator|==
name|destSchemaField
operator|||
operator|(
literal|null
operator|==
name|sourceSchemaField
operator|&&
operator|!
name|sourceIsExplicitFieldGlob
operator|)
condition|)
block|{
comment|// Go through dynamicFields array only once, collecting info for both source and dest fields, if needed
for|for
control|(
name|DynamicField
name|dynamicField
range|:
name|dynamicFields
control|)
block|{
if|if
condition|(
literal|null
operator|==
name|sourceSchemaField
operator|&&
operator|!
name|sourceIsDynamicFieldReference
operator|&&
operator|!
name|sourceIsExplicitFieldGlob
condition|)
block|{
if|if
condition|(
name|dynamicField
operator|.
name|matches
argument_list|(
name|source
argument_list|)
condition|)
block|{
name|sourceIsDynamicFieldReference
operator|=
literal|true
expr_stmt|;
if|if
condition|(
operator|!
name|source
operator|.
name|equals
argument_list|(
name|dynamicField
operator|.
name|getRegex
argument_list|()
argument_list|)
condition|)
block|{
name|sourceDynamicBase
operator|=
name|dynamicField
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
literal|null
operator|==
name|destSchemaField
condition|)
block|{
if|if
condition|(
name|dest
operator|.
name|equals
argument_list|(
name|dynamicField
operator|.
name|getRegex
argument_list|()
argument_list|)
condition|)
block|{
name|destDynamicField
operator|=
name|dynamicField
expr_stmt|;
name|destSchemaField
operator|=
name|dynamicField
operator|.
name|prototype
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dynamicField
operator|.
name|matches
argument_list|(
name|dest
argument_list|)
condition|)
block|{
name|destSchemaField
operator|=
name|dynamicField
operator|.
name|makeSchemaField
argument_list|(
name|dest
argument_list|)
expr_stmt|;
name|destDynamicField
operator|=
operator|new
name|DynamicField
argument_list|(
name|destSchemaField
argument_list|)
expr_stmt|;
name|destDynamicBase
operator|=
name|dynamicField
expr_stmt|;
block|}
block|}
if|if
condition|(
literal|null
operator|!=
name|destSchemaField
operator|&&
operator|(
literal|null
operator|!=
name|sourceSchemaField
operator|||
name|sourceIsDynamicFieldReference
operator|||
name|sourceIsExplicitFieldGlob
operator|)
condition|)
block|{
break|break;
block|}
block|}
block|}
if|if
condition|(
literal|null
operator|==
name|sourceSchemaField
operator|&&
operator|!
name|sourceIsGlob
operator|&&
operator|!
name|sourceIsDynamicFieldReference
condition|)
block|{
name|String
name|msg
init|=
literal|"copyField source :'"
operator|+
name|source
operator|+
literal|"' is not a glob and doesn't match any explicit field or dynamicField."
decl_stmt|;
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|SERVER_ERROR
argument_list|,
name|msg
argument_list|)
throw|;
block|}
if|if
condition|(
literal|null
operator|==
name|destSchemaField
condition|)
block|{
name|String
name|msg
init|=
literal|"copyField dest :'"
operator|+
name|dest
operator|+
literal|"' is not an explicit field and doesn't match a dynamicField."
decl_stmt|;
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|SERVER_ERROR
argument_list|,
name|msg
argument_list|)
throw|;
block|}
if|if
condition|(
name|sourceIsGlob
condition|)
block|{
if|if
condition|(
literal|null
operator|!=
name|destDynamicField
condition|)
block|{
comment|// source: glob ; dest: dynamic field ref
name|registerDynamicCopyField
argument_list|(
operator|new
name|DynamicCopy
argument_list|(
name|source
argument_list|,
name|destDynamicField
argument_list|,
name|maxChars
argument_list|,
name|sourceDynamicBase
argument_list|,
name|destDynamicBase
argument_list|)
argument_list|)
expr_stmt|;
name|incrementCopyFieldTargetCount
argument_list|(
name|destSchemaField
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// source: glob ; dest: explicit field
name|destDynamicField
operator|=
operator|new
name|DynamicField
argument_list|(
name|destSchemaField
argument_list|)
expr_stmt|;
name|registerDynamicCopyField
argument_list|(
operator|new
name|DynamicCopy
argument_list|(
name|source
argument_list|,
name|destDynamicField
argument_list|,
name|maxChars
argument_list|,
name|sourceDynamicBase
argument_list|,
literal|null
argument_list|)
argument_list|)
expr_stmt|;
name|incrementCopyFieldTargetCount
argument_list|(
name|destSchemaField
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|sourceIsDynamicFieldReference
condition|)
block|{
if|if
condition|(
literal|null
operator|!=
name|destDynamicField
condition|)
block|{
comment|// source: no-asterisk dynamic field ref ; dest: dynamic field ref
name|registerDynamicCopyField
argument_list|(
operator|new
name|DynamicCopy
argument_list|(
name|source
argument_list|,
name|destDynamicField
argument_list|,
name|maxChars
argument_list|,
name|sourceDynamicBase
argument_list|,
name|destDynamicBase
argument_list|)
argument_list|)
expr_stmt|;
name|incrementCopyFieldTargetCount
argument_list|(
name|destSchemaField
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// source: no-asterisk dynamic field ref ; dest: explicit field
name|sourceSchemaField
operator|=
name|getField
argument_list|(
name|source
argument_list|)
expr_stmt|;
name|registerExplicitSrcAndDestFields
argument_list|(
name|source
argument_list|,
name|maxChars
argument_list|,
name|destSchemaField
argument_list|,
name|sourceSchemaField
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
literal|null
operator|!=
name|destDynamicField
condition|)
block|{
comment|// source: explicit field ; dest: dynamic field reference
if|if
condition|(
name|destDynamicField
operator|.
name|pattern
operator|instanceof
name|DynamicReplacement
operator|.
name|DynamicPattern
operator|.
name|NameEquals
condition|)
block|{
comment|// Dynamic dest with no asterisk is acceptable
name|registerDynamicCopyField
argument_list|(
operator|new
name|DynamicCopy
argument_list|(
name|source
argument_list|,
name|destDynamicField
argument_list|,
name|maxChars
argument_list|,
name|sourceDynamicBase
argument_list|,
name|destDynamicBase
argument_list|)
argument_list|)
expr_stmt|;
name|incrementCopyFieldTargetCount
argument_list|(
name|destSchemaField
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// source: explicit field ; dest: dynamic field with an asterisk
name|String
name|msg
init|=
literal|"copyField only supports a dynamic destination with an asterisk "
operator|+
literal|"if the source also has an asterisk"
decl_stmt|;
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|SERVER_ERROR
argument_list|,
name|msg
argument_list|)
throw|;
block|}
block|}
else|else
block|{
comment|// source& dest: explicit fields
name|registerExplicitSrcAndDestFields
argument_list|(
name|source
argument_list|,
name|maxChars
argument_list|,
name|destSchemaField
argument_list|,
name|sourceSchemaField
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|registerExplicitSrcAndDestFields
specifier|protected
name|void
name|registerExplicitSrcAndDestFields
parameter_list|(
name|String
name|source
parameter_list|,
name|int
name|maxChars
parameter_list|,
name|SchemaField
name|destSchemaField
parameter_list|,
name|SchemaField
name|sourceSchemaField
parameter_list|)
block|{
name|List
argument_list|<
name|CopyField
argument_list|>
name|copyFieldList
init|=
name|copyFieldsMap
operator|.
name|get
argument_list|(
name|source
argument_list|)
decl_stmt|;
if|if
condition|(
name|copyFieldList
operator|==
literal|null
condition|)
block|{
name|copyFieldList
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
expr_stmt|;
name|copyFieldsMap
operator|.
name|put
argument_list|(
name|source
argument_list|,
name|copyFieldList
argument_list|)
expr_stmt|;
block|}
name|copyFieldList
operator|.
name|add
argument_list|(
operator|new
name|CopyField
argument_list|(
name|sourceSchemaField
argument_list|,
name|destSchemaField
argument_list|,
name|maxChars
argument_list|)
argument_list|)
expr_stmt|;
name|incrementCopyFieldTargetCount
argument_list|(
name|destSchemaField
argument_list|)
expr_stmt|;
block|}
DECL|method|incrementCopyFieldTargetCount
specifier|private
name|void
name|incrementCopyFieldTargetCount
parameter_list|(
name|SchemaField
name|dest
parameter_list|)
block|{
name|copyFieldTargetCounts
operator|.
name|put
argument_list|(
name|dest
argument_list|,
name|copyFieldTargetCounts
operator|.
name|containsKey
argument_list|(
name|dest
argument_list|)
condition|?
name|copyFieldTargetCounts
operator|.
name|get
argument_list|(
name|dest
argument_list|)
operator|+
literal|1
else|:
literal|1
argument_list|)
expr_stmt|;
block|}
DECL|method|registerDynamicCopyField
specifier|private
name|void
name|registerDynamicCopyField
parameter_list|(
name|DynamicCopy
name|dcopy
parameter_list|)
block|{
if|if
condition|(
name|dynamicCopyFields
operator|==
literal|null
condition|)
block|{
name|dynamicCopyFields
operator|=
operator|new
name|DynamicCopy
index|[]
block|{
name|dcopy
block|}
expr_stmt|;
block|}
else|else
block|{
name|DynamicCopy
index|[]
name|temp
init|=
operator|new
name|DynamicCopy
index|[
name|dynamicCopyFields
operator|.
name|length
operator|+
literal|1
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|dynamicCopyFields
argument_list|,
literal|0
argument_list|,
name|temp
argument_list|,
literal|0
argument_list|,
name|dynamicCopyFields
operator|.
name|length
argument_list|)
expr_stmt|;
name|temp
index|[
name|temp
operator|.
name|length
operator|-
literal|1
index|]
operator|=
name|dcopy
expr_stmt|;
name|dynamicCopyFields
operator|=
name|temp
expr_stmt|;
block|}
name|log
operator|.
name|trace
argument_list|(
literal|"Dynamic Copy Field:"
operator|+
name|dcopy
argument_list|)
expr_stmt|;
block|}
DECL|method|readSimilarity
specifier|static
name|SimilarityFactory
name|readSimilarity
parameter_list|(
name|SolrResourceLoader
name|loader
parameter_list|,
name|Node
name|node
parameter_list|)
block|{
if|if
condition|(
name|node
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
else|else
block|{
name|SimilarityFactory
name|similarityFactory
decl_stmt|;
specifier|final
name|String
name|classArg
init|=
operator|(
operator|(
name|Element
operator|)
name|node
operator|)
operator|.
name|getAttribute
argument_list|(
name|SimilarityFactory
operator|.
name|CLASS_NAME
argument_list|)
decl_stmt|;
specifier|final
name|Object
name|obj
init|=
name|loader
operator|.
name|newInstance
argument_list|(
name|classArg
argument_list|,
name|Object
operator|.
name|class
argument_list|,
literal|"search.similarities."
argument_list|)
decl_stmt|;
if|if
condition|(
name|obj
operator|instanceof
name|SimilarityFactory
condition|)
block|{
comment|// configure a factory, get a similarity back
specifier|final
name|NamedList
argument_list|<
name|Object
argument_list|>
name|namedList
init|=
name|DOMUtil
operator|.
name|childNodesToNamedList
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|namedList
operator|.
name|add
argument_list|(
name|SimilarityFactory
operator|.
name|CLASS_NAME
argument_list|,
name|classArg
argument_list|)
expr_stmt|;
name|SolrParams
name|params
init|=
name|SolrParams
operator|.
name|toSolrParams
argument_list|(
name|namedList
argument_list|)
decl_stmt|;
name|similarityFactory
operator|=
operator|(
name|SimilarityFactory
operator|)
name|obj
expr_stmt|;
name|similarityFactory
operator|.
name|init
argument_list|(
name|params
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// just like always, assume it's a Similarity and get a ClassCastException - reasonable error handling
name|similarityFactory
operator|=
operator|new
name|SimilarityFactory
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Similarity
name|getSimilarity
parameter_list|()
block|{
return|return
operator|(
name|Similarity
operator|)
name|obj
return|;
block|}
block|}
expr_stmt|;
block|}
return|return
name|similarityFactory
return|;
block|}
block|}
DECL|class|DynamicReplacement
specifier|public
specifier|static
specifier|abstract
class|class
name|DynamicReplacement
implements|implements
name|Comparable
argument_list|<
name|DynamicReplacement
argument_list|>
block|{
DECL|class|DynamicPattern
specifier|abstract
specifier|protected
specifier|static
class|class
name|DynamicPattern
block|{
DECL|field|regex
specifier|protected
specifier|final
name|String
name|regex
decl_stmt|;
DECL|field|fixedStr
specifier|protected
specifier|final
name|String
name|fixedStr
decl_stmt|;
DECL|method|DynamicPattern
specifier|protected
name|DynamicPattern
parameter_list|(
name|String
name|regex
parameter_list|,
name|String
name|fixedStr
parameter_list|)
block|{
name|this
operator|.
name|regex
operator|=
name|regex
expr_stmt|;
name|this
operator|.
name|fixedStr
operator|=
name|fixedStr
expr_stmt|;
block|}
DECL|method|createPattern
specifier|static
name|DynamicPattern
name|createPattern
parameter_list|(
name|String
name|regex
parameter_list|)
block|{
if|if
condition|(
name|regex
operator|.
name|startsWith
argument_list|(
literal|"*"
argument_list|)
condition|)
block|{
return|return
operator|new
name|NameEndsWith
argument_list|(
name|regex
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|regex
operator|.
name|endsWith
argument_list|(
literal|"*"
argument_list|)
condition|)
block|{
return|return
operator|new
name|NameStartsWith
argument_list|(
name|regex
argument_list|)
return|;
block|}
else|else
block|{
return|return
operator|new
name|NameEquals
argument_list|(
name|regex
argument_list|)
return|;
block|}
block|}
comment|/** Returns true if the given name matches this pattern */
DECL|method|matches
specifier|abstract
name|boolean
name|matches
parameter_list|(
name|String
name|name
parameter_list|)
function_decl|;
comment|/** Returns the remainder of the given name after removing this pattern's fixed string component */
DECL|method|remainder
specifier|abstract
name|String
name|remainder
parameter_list|(
name|String
name|name
parameter_list|)
function_decl|;
comment|/** Returns the result of combining this pattern's fixed string component with the given replacement */
DECL|method|subst
specifier|abstract
name|String
name|subst
parameter_list|(
name|String
name|replacement
parameter_list|)
function_decl|;
comment|/** Returns the length of the original regex, including the asterisk, if any. */
DECL|method|length
specifier|public
name|int
name|length
parameter_list|()
block|{
return|return
name|regex
operator|.
name|length
argument_list|()
return|;
block|}
DECL|class|NameStartsWith
specifier|private
specifier|static
class|class
name|NameStartsWith
extends|extends
name|DynamicPattern
block|{
DECL|method|NameStartsWith
name|NameStartsWith
parameter_list|(
name|String
name|regex
parameter_list|)
block|{
name|super
argument_list|(
name|regex
argument_list|,
name|regex
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|regex
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|matches
name|boolean
name|matches
parameter_list|(
name|String
name|name
parameter_list|)
block|{
return|return
name|name
operator|.
name|startsWith
argument_list|(
name|fixedStr
argument_list|)
return|;
block|}
DECL|method|remainder
name|String
name|remainder
parameter_list|(
name|String
name|name
parameter_list|)
block|{
return|return
name|name
operator|.
name|substring
argument_list|(
name|fixedStr
operator|.
name|length
argument_list|()
argument_list|)
return|;
block|}
DECL|method|subst
name|String
name|subst
parameter_list|(
name|String
name|replacement
parameter_list|)
block|{
return|return
name|fixedStr
operator|+
name|replacement
return|;
block|}
block|}
DECL|class|NameEndsWith
specifier|private
specifier|static
class|class
name|NameEndsWith
extends|extends
name|DynamicPattern
block|{
DECL|method|NameEndsWith
name|NameEndsWith
parameter_list|(
name|String
name|regex
parameter_list|)
block|{
name|super
argument_list|(
name|regex
argument_list|,
name|regex
operator|.
name|substring
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|matches
name|boolean
name|matches
parameter_list|(
name|String
name|name
parameter_list|)
block|{
return|return
name|name
operator|.
name|endsWith
argument_list|(
name|fixedStr
argument_list|)
return|;
block|}
DECL|method|remainder
name|String
name|remainder
parameter_list|(
name|String
name|name
parameter_list|)
block|{
return|return
name|name
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|name
operator|.
name|length
argument_list|()
operator|-
name|fixedStr
operator|.
name|length
argument_list|()
argument_list|)
return|;
block|}
DECL|method|subst
name|String
name|subst
parameter_list|(
name|String
name|replacement
parameter_list|)
block|{
return|return
name|replacement
operator|+
name|fixedStr
return|;
block|}
block|}
DECL|class|NameEquals
specifier|private
specifier|static
class|class
name|NameEquals
extends|extends
name|DynamicPattern
block|{
DECL|method|NameEquals
name|NameEquals
parameter_list|(
name|String
name|regex
parameter_list|)
block|{
name|super
argument_list|(
name|regex
argument_list|,
name|regex
argument_list|)
expr_stmt|;
block|}
DECL|method|matches
name|boolean
name|matches
parameter_list|(
name|String
name|name
parameter_list|)
block|{
return|return
name|regex
operator|.
name|equals
argument_list|(
name|name
argument_list|)
return|;
block|}
DECL|method|remainder
name|String
name|remainder
parameter_list|(
name|String
name|name
parameter_list|)
block|{
return|return
literal|""
return|;
block|}
DECL|method|subst
name|String
name|subst
parameter_list|(
name|String
name|replacement
parameter_list|)
block|{
return|return
name|fixedStr
return|;
block|}
block|}
block|}
DECL|field|pattern
specifier|protected
name|DynamicPattern
name|pattern
decl_stmt|;
DECL|method|matches
specifier|public
name|boolean
name|matches
parameter_list|(
name|String
name|name
parameter_list|)
block|{
return|return
name|pattern
operator|.
name|matches
argument_list|(
name|name
argument_list|)
return|;
block|}
DECL|method|DynamicReplacement
specifier|protected
name|DynamicReplacement
parameter_list|(
name|String
name|regex
parameter_list|)
block|{
name|pattern
operator|=
name|DynamicPattern
operator|.
name|createPattern
argument_list|(
name|regex
argument_list|)
expr_stmt|;
block|}
comment|/**      * Sort order is based on length of regex.  Longest comes first.      * @param other The object to compare to.      * @return a negative integer, zero, or a positive integer      * as this object is less than, equal to, or greater than      * the specified object.      */
annotation|@
name|Override
DECL|method|compareTo
specifier|public
name|int
name|compareTo
parameter_list|(
name|DynamicReplacement
name|other
parameter_list|)
block|{
return|return
name|other
operator|.
name|pattern
operator|.
name|length
argument_list|()
operator|-
name|pattern
operator|.
name|length
argument_list|()
return|;
block|}
comment|/** Returns the regex used to create this instance's pattern */
DECL|method|getRegex
specifier|public
name|String
name|getRegex
parameter_list|()
block|{
return|return
name|pattern
operator|.
name|regex
return|;
block|}
block|}
DECL|class|DynamicField
specifier|public
specifier|final
specifier|static
class|class
name|DynamicField
extends|extends
name|DynamicReplacement
block|{
DECL|field|prototype
specifier|private
specifier|final
name|SchemaField
name|prototype
decl_stmt|;
DECL|method|getPrototype
specifier|public
name|SchemaField
name|getPrototype
parameter_list|()
block|{
return|return
name|prototype
return|;
block|}
DECL|method|DynamicField
name|DynamicField
parameter_list|(
name|SchemaField
name|prototype
parameter_list|)
block|{
name|super
argument_list|(
name|prototype
operator|.
name|name
argument_list|)
expr_stmt|;
name|this
operator|.
name|prototype
operator|=
name|prototype
expr_stmt|;
block|}
DECL|method|makeSchemaField
name|SchemaField
name|makeSchemaField
parameter_list|(
name|String
name|name
parameter_list|)
block|{
comment|// could have a cache instead of returning a new one each time, but it might
comment|// not be worth it.
comment|// Actually, a higher level cache could be worth it to avoid too many
comment|// .startsWith() and .endsWith() comparisons.  it depends on how many
comment|// dynamic fields there are.
return|return
operator|new
name|SchemaField
argument_list|(
name|prototype
argument_list|,
name|name
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|prototype
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
DECL|class|DynamicCopy
specifier|public
specifier|static
class|class
name|DynamicCopy
extends|extends
name|DynamicReplacement
block|{
DECL|field|destination
specifier|private
specifier|final
name|DynamicField
name|destination
decl_stmt|;
DECL|field|maxChars
specifier|private
specifier|final
name|int
name|maxChars
decl_stmt|;
DECL|method|getMaxChars
specifier|public
name|int
name|getMaxChars
parameter_list|()
block|{
return|return
name|maxChars
return|;
block|}
DECL|field|sourceDynamicBase
specifier|final
name|DynamicField
name|sourceDynamicBase
decl_stmt|;
DECL|method|getSourceDynamicBase
specifier|public
name|DynamicField
name|getSourceDynamicBase
parameter_list|()
block|{
return|return
name|sourceDynamicBase
return|;
block|}
DECL|field|destDynamicBase
specifier|final
name|DynamicField
name|destDynamicBase
decl_stmt|;
DECL|method|getDestDynamicBase
specifier|public
name|DynamicField
name|getDestDynamicBase
parameter_list|()
block|{
return|return
name|destDynamicBase
return|;
block|}
DECL|method|DynamicCopy
name|DynamicCopy
parameter_list|(
name|String
name|sourceRegex
parameter_list|,
name|DynamicField
name|destination
parameter_list|,
name|int
name|maxChars
parameter_list|,
name|DynamicField
name|sourceDynamicBase
parameter_list|,
name|DynamicField
name|destDynamicBase
parameter_list|)
block|{
name|super
argument_list|(
name|sourceRegex
argument_list|)
expr_stmt|;
name|this
operator|.
name|destination
operator|=
name|destination
expr_stmt|;
name|this
operator|.
name|maxChars
operator|=
name|maxChars
expr_stmt|;
name|this
operator|.
name|sourceDynamicBase
operator|=
name|sourceDynamicBase
expr_stmt|;
name|this
operator|.
name|destDynamicBase
operator|=
name|destDynamicBase
expr_stmt|;
block|}
DECL|method|getDestination
specifier|public
name|DynamicField
name|getDestination
parameter_list|()
block|{
return|return
name|destination
return|;
block|}
DECL|method|getDestFieldName
specifier|public
name|String
name|getDestFieldName
parameter_list|()
block|{
return|return
name|destination
operator|.
name|getRegex
argument_list|()
return|;
block|}
comment|/**      *  Generates a destination field name based on this source pattern,      *  by substituting the remainder of this source pattern into the      *  the given destination pattern.      */
DECL|method|getTargetField
specifier|public
name|SchemaField
name|getTargetField
parameter_list|(
name|String
name|sourceField
parameter_list|)
block|{
name|String
name|remainder
init|=
name|pattern
operator|.
name|remainder
argument_list|(
name|sourceField
argument_list|)
decl_stmt|;
name|String
name|targetFieldName
init|=
name|destination
operator|.
name|pattern
operator|.
name|subst
argument_list|(
name|remainder
argument_list|)
decl_stmt|;
return|return
name|destination
operator|.
name|makeSchemaField
argument_list|(
name|targetFieldName
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|destination
operator|.
name|prototype
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
DECL|method|getDynamicFieldPrototypes
specifier|public
name|SchemaField
index|[]
name|getDynamicFieldPrototypes
parameter_list|()
block|{
name|SchemaField
index|[]
name|df
init|=
operator|new
name|SchemaField
index|[
name|dynamicFields
operator|.
name|length
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|dynamicFields
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|df
index|[
name|i
index|]
operator|=
name|dynamicFields
index|[
name|i
index|]
operator|.
name|prototype
expr_stmt|;
block|}
return|return
name|df
return|;
block|}
DECL|method|getDynamicPattern
specifier|public
name|String
name|getDynamicPattern
parameter_list|(
name|String
name|fieldName
parameter_list|)
block|{
for|for
control|(
name|DynamicField
name|df
range|:
name|dynamicFields
control|)
block|{
if|if
condition|(
name|df
operator|.
name|matches
argument_list|(
name|fieldName
argument_list|)
condition|)
return|return
name|df
operator|.
name|getRegex
argument_list|()
return|;
block|}
return|return
literal|null
return|;
block|}
comment|/**    * Does the schema explicitly define the specified field, i.e. not as a result    * of a copyField declaration?  We consider it explicitly defined if it matches    * a field name or a dynamicField name.    * @return true if explicitly declared in the schema.    */
DECL|method|hasExplicitField
specifier|public
name|boolean
name|hasExplicitField
parameter_list|(
name|String
name|fieldName
parameter_list|)
block|{
if|if
condition|(
name|fields
operator|.
name|containsKey
argument_list|(
name|fieldName
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
for|for
control|(
name|DynamicField
name|df
range|:
name|dynamicFields
control|)
block|{
if|if
condition|(
name|fieldName
operator|.
name|equals
argument_list|(
name|df
operator|.
name|getRegex
argument_list|()
argument_list|)
condition|)
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
comment|/**    * Is the specified field dynamic or not.    * @return true if the specified field is dynamic    */
DECL|method|isDynamicField
specifier|public
name|boolean
name|isDynamicField
parameter_list|(
name|String
name|fieldName
parameter_list|)
block|{
if|if
condition|(
name|fields
operator|.
name|containsKey
argument_list|(
name|fieldName
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
for|for
control|(
name|DynamicField
name|df
range|:
name|dynamicFields
control|)
block|{
if|if
condition|(
name|df
operator|.
name|matches
argument_list|(
name|fieldName
argument_list|)
condition|)
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
comment|/**    * Returns the SchemaField that should be used for the specified field name, or    * null if none exists.    *    * @param fieldName may be an explicitly defined field or a name that    * matches a dynamic field.    * @see #getFieldType    * @see #getField(String)    * @return The {@link org.apache.solr.schema.SchemaField}    */
DECL|method|getFieldOrNull
specifier|public
name|SchemaField
name|getFieldOrNull
parameter_list|(
name|String
name|fieldName
parameter_list|)
block|{
name|SchemaField
name|f
init|=
name|fields
operator|.
name|get
argument_list|(
name|fieldName
argument_list|)
decl_stmt|;
if|if
condition|(
name|f
operator|!=
literal|null
condition|)
return|return
name|f
return|;
for|for
control|(
name|DynamicField
name|df
range|:
name|dynamicFields
control|)
block|{
if|if
condition|(
name|df
operator|.
name|matches
argument_list|(
name|fieldName
argument_list|)
condition|)
return|return
name|df
operator|.
name|makeSchemaField
argument_list|(
name|fieldName
argument_list|)
return|;
block|}
return|return
name|f
return|;
block|}
comment|/**    * Returns the SchemaField that should be used for the specified field name    *    * @param fieldName may be an explicitly defined field or a name that    * matches a dynamic field.    * @throws SolrException if no such field exists    * @see #getFieldType    * @see #getFieldOrNull(String)    * @return The {@link SchemaField}    */
DECL|method|getField
specifier|public
name|SchemaField
name|getField
parameter_list|(
name|String
name|fieldName
parameter_list|)
block|{
name|SchemaField
name|f
init|=
name|getFieldOrNull
argument_list|(
name|fieldName
argument_list|)
decl_stmt|;
if|if
condition|(
name|f
operator|!=
literal|null
condition|)
return|return
name|f
return|;
comment|// Hmmm, default field could also be implemented with a dynamic field of "*".
comment|// It would have to be special-cased and only used if nothing else matched.
comment|/***  REMOVED -YCS     if (defaultFieldType != null) return new SchemaField(fieldName,defaultFieldType);     ***/
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
literal|"undefined field: \""
operator|+
name|fieldName
operator|+
literal|"\""
argument_list|)
throw|;
block|}
comment|/**    * Returns the FieldType for the specified field name.    *    *<p>    * This method exists because it can be more efficient then    * {@link #getField} for dynamic fields if a full SchemaField isn't needed.    *</p>    *    * @param fieldName may be an explicitly created field, or a name that    *  excercises a dynamic field.    * @throws SolrException if no such field exists    * @see #getField(String)    * @see #getFieldTypeNoEx    */
DECL|method|getFieldType
specifier|public
name|FieldType
name|getFieldType
parameter_list|(
name|String
name|fieldName
parameter_list|)
block|{
name|SchemaField
name|f
init|=
name|fields
operator|.
name|get
argument_list|(
name|fieldName
argument_list|)
decl_stmt|;
if|if
condition|(
name|f
operator|!=
literal|null
condition|)
return|return
name|f
operator|.
name|getType
argument_list|()
return|;
return|return
name|getDynamicFieldType
argument_list|(
name|fieldName
argument_list|)
return|;
block|}
comment|/**    * Given the name of a {@link org.apache.solr.schema.FieldType} (not to be confused with {@link #getFieldType(String)} which    * takes in the name of a field), return the {@link org.apache.solr.schema.FieldType}.    * @param fieldTypeName The name of the {@link org.apache.solr.schema.FieldType}    * @return The {@link org.apache.solr.schema.FieldType} or null.    */
DECL|method|getFieldTypeByName
specifier|public
name|FieldType
name|getFieldTypeByName
parameter_list|(
name|String
name|fieldTypeName
parameter_list|)
block|{
return|return
name|fieldTypes
operator|.
name|get
argument_list|(
name|fieldTypeName
argument_list|)
return|;
block|}
comment|/**    * Returns the FieldType for the specified field name.    *    *<p>    * This method exists because it can be more efficient then    * {@link #getField} for dynamic fields if a full SchemaField isn't needed.    *</p>    *    * @param fieldName may be an explicitly created field, or a name that    * exercises a dynamic field.    * @return null if field is not defined.    * @see #getField(String)    * @see #getFieldTypeNoEx    */
DECL|method|getFieldTypeNoEx
specifier|public
name|FieldType
name|getFieldTypeNoEx
parameter_list|(
name|String
name|fieldName
parameter_list|)
block|{
name|SchemaField
name|f
init|=
name|fields
operator|.
name|get
argument_list|(
name|fieldName
argument_list|)
decl_stmt|;
if|if
condition|(
name|f
operator|!=
literal|null
condition|)
return|return
name|f
operator|.
name|getType
argument_list|()
return|;
return|return
name|dynFieldType
argument_list|(
name|fieldName
argument_list|)
return|;
block|}
comment|/**    * Returns the FieldType of the best matching dynamic field for    * the specified field name    *    * @param fieldName may be an explicitly created field, or a name that    * exercises a dynamic field.    * @throws SolrException if no such field exists    * @see #getField(String)    * @see #getFieldTypeNoEx    */
DECL|method|getDynamicFieldType
specifier|public
name|FieldType
name|getDynamicFieldType
parameter_list|(
name|String
name|fieldName
parameter_list|)
block|{
for|for
control|(
name|DynamicField
name|df
range|:
name|dynamicFields
control|)
block|{
if|if
condition|(
name|df
operator|.
name|matches
argument_list|(
name|fieldName
argument_list|)
condition|)
return|return
name|df
operator|.
name|prototype
operator|.
name|getType
argument_list|()
return|;
block|}
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
literal|"undefined field "
operator|+
name|fieldName
argument_list|)
throw|;
block|}
DECL|method|dynFieldType
specifier|private
name|FieldType
name|dynFieldType
parameter_list|(
name|String
name|fieldName
parameter_list|)
block|{
for|for
control|(
name|DynamicField
name|df
range|:
name|dynamicFields
control|)
block|{
if|if
condition|(
name|df
operator|.
name|matches
argument_list|(
name|fieldName
argument_list|)
condition|)
return|return
name|df
operator|.
name|prototype
operator|.
name|getType
argument_list|()
return|;
block|}
return|return
literal|null
return|;
block|}
comment|/**    * Get all copy fields, both the static and the dynamic ones.    * @return Array of fields copied into this field    */
DECL|method|getCopySources
specifier|public
name|List
argument_list|<
name|String
argument_list|>
name|getCopySources
parameter_list|(
name|String
name|destField
parameter_list|)
block|{
name|SchemaField
name|f
init|=
name|getField
argument_list|(
name|destField
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|isCopyFieldTarget
argument_list|(
name|f
argument_list|)
condition|)
block|{
return|return
name|Collections
operator|.
name|emptyList
argument_list|()
return|;
block|}
name|List
argument_list|<
name|String
argument_list|>
name|fieldNames
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|CopyField
argument_list|>
argument_list|>
name|cfs
range|:
name|copyFieldsMap
operator|.
name|entrySet
argument_list|()
control|)
block|{
for|for
control|(
name|CopyField
name|copyField
range|:
name|cfs
operator|.
name|getValue
argument_list|()
control|)
block|{
if|if
condition|(
name|copyField
operator|.
name|getDestination
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
name|destField
argument_list|)
condition|)
block|{
name|fieldNames
operator|.
name|add
argument_list|(
name|copyField
operator|.
name|getSource
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
literal|null
operator|!=
name|dynamicCopyFields
condition|)
block|{
for|for
control|(
name|DynamicCopy
name|dynamicCopy
range|:
name|dynamicCopyFields
control|)
block|{
if|if
condition|(
name|dynamicCopy
operator|.
name|getDestFieldName
argument_list|()
operator|.
name|equals
argument_list|(
name|destField
argument_list|)
condition|)
block|{
name|fieldNames
operator|.
name|add
argument_list|(
name|dynamicCopy
operator|.
name|getRegex
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|fieldNames
return|;
block|}
comment|/**    * Get all copy fields for a specified source field, both static    * and dynamic ones.    * @return List of CopyFields to copy to.    * @since solr 1.4    */
comment|// This is useful when we need the maxSize param of each CopyField
DECL|method|getCopyFieldsList
specifier|public
name|List
argument_list|<
name|CopyField
argument_list|>
name|getCopyFieldsList
parameter_list|(
specifier|final
name|String
name|sourceField
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|CopyField
argument_list|>
name|result
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
if|if
condition|(
literal|null
operator|!=
name|dynamicCopyFields
condition|)
block|{
for|for
control|(
name|DynamicCopy
name|dynamicCopy
range|:
name|dynamicCopyFields
control|)
block|{
if|if
condition|(
name|dynamicCopy
operator|.
name|matches
argument_list|(
name|sourceField
argument_list|)
condition|)
block|{
name|result
operator|.
name|add
argument_list|(
operator|new
name|CopyField
argument_list|(
name|getField
argument_list|(
name|sourceField
argument_list|)
argument_list|,
name|dynamicCopy
operator|.
name|getTargetField
argument_list|(
name|sourceField
argument_list|)
argument_list|,
name|dynamicCopy
operator|.
name|maxChars
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|List
argument_list|<
name|CopyField
argument_list|>
name|fixedCopyFields
init|=
name|copyFieldsMap
operator|.
name|get
argument_list|(
name|sourceField
argument_list|)
decl_stmt|;
if|if
condition|(
literal|null
operator|!=
name|fixedCopyFields
condition|)
block|{
name|result
operator|.
name|addAll
argument_list|(
name|fixedCopyFields
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
comment|/**    * Check if a field is used as the destination of a copyField operation     *     * @since solr 1.3    */
DECL|method|isCopyFieldTarget
specifier|public
name|boolean
name|isCopyFieldTarget
parameter_list|(
name|SchemaField
name|f
parameter_list|)
block|{
return|return
name|copyFieldTargetCounts
operator|.
name|containsKey
argument_list|(
name|f
argument_list|)
return|;
block|}
comment|/**    * Get a map of property name -&gt; value for the whole schema.    */
DECL|method|getNamedPropertyValues
specifier|public
name|SimpleOrderedMap
argument_list|<
name|Object
argument_list|>
name|getNamedPropertyValues
parameter_list|()
block|{
name|SimpleOrderedMap
argument_list|<
name|Object
argument_list|>
name|topLevel
init|=
operator|new
name|SimpleOrderedMap
argument_list|<>
argument_list|()
decl_stmt|;
name|topLevel
operator|.
name|add
argument_list|(
name|NAME
argument_list|,
name|getSchemaName
argument_list|()
argument_list|)
expr_stmt|;
name|topLevel
operator|.
name|add
argument_list|(
name|VERSION
argument_list|,
name|getVersion
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
literal|null
operator|!=
name|uniqueKeyFieldName
condition|)
block|{
name|topLevel
operator|.
name|add
argument_list|(
name|UNIQUE_KEY
argument_list|,
name|uniqueKeyFieldName
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
literal|null
operator|!=
name|defaultSearchFieldName
condition|)
block|{
name|topLevel
operator|.
name|add
argument_list|(
name|DEFAULT_SEARCH_FIELD
argument_list|,
name|defaultSearchFieldName
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|isExplicitQueryParserDefaultOperator
condition|)
block|{
name|SimpleOrderedMap
argument_list|<
name|Object
argument_list|>
name|solrQueryParserProperties
init|=
operator|new
name|SimpleOrderedMap
argument_list|<>
argument_list|()
decl_stmt|;
name|solrQueryParserProperties
operator|.
name|add
argument_list|(
name|DEFAULT_OPERATOR
argument_list|,
name|queryParserDefaultOperator
argument_list|)
expr_stmt|;
name|topLevel
operator|.
name|add
argument_list|(
name|SOLR_QUERY_PARSER
argument_list|,
name|solrQueryParserProperties
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|isExplicitSimilarity
condition|)
block|{
name|topLevel
operator|.
name|add
argument_list|(
name|SIMILARITY
argument_list|,
name|similarityFactory
operator|.
name|getNamedPropertyValues
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|List
argument_list|<
name|SimpleOrderedMap
argument_list|<
name|Object
argument_list|>
argument_list|>
name|fieldTypeProperties
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|SortedMap
argument_list|<
name|String
argument_list|,
name|FieldType
argument_list|>
name|sortedFieldTypes
init|=
operator|new
name|TreeMap
argument_list|<>
argument_list|(
name|fieldTypes
argument_list|)
decl_stmt|;
for|for
control|(
name|FieldType
name|fieldType
range|:
name|sortedFieldTypes
operator|.
name|values
argument_list|()
control|)
block|{
name|fieldTypeProperties
operator|.
name|add
argument_list|(
name|fieldType
operator|.
name|getNamedPropertyValues
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|topLevel
operator|.
name|add
argument_list|(
name|FIELD_TYPES
argument_list|,
name|fieldTypeProperties
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|SimpleOrderedMap
argument_list|<
name|Object
argument_list|>
argument_list|>
name|fieldProperties
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|SortedSet
argument_list|<
name|String
argument_list|>
name|fieldNames
init|=
operator|new
name|TreeSet
argument_list|<>
argument_list|(
name|fields
operator|.
name|keySet
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|fieldName
range|:
name|fieldNames
control|)
block|{
name|fieldProperties
operator|.
name|add
argument_list|(
name|fields
operator|.
name|get
argument_list|(
name|fieldName
argument_list|)
operator|.
name|getNamedPropertyValues
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|topLevel
operator|.
name|add
argument_list|(
name|FIELDS
argument_list|,
name|fieldProperties
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|SimpleOrderedMap
argument_list|<
name|Object
argument_list|>
argument_list|>
name|dynamicFieldProperties
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|IndexSchema
operator|.
name|DynamicField
name|dynamicField
range|:
name|dynamicFields
control|)
block|{
if|if
condition|(
operator|!
name|dynamicField
operator|.
name|getRegex
argument_list|()
operator|.
name|startsWith
argument_list|(
name|INTERNAL_POLY_FIELD_PREFIX
argument_list|)
condition|)
block|{
comment|// omit internal polyfields
name|dynamicFieldProperties
operator|.
name|add
argument_list|(
name|dynamicField
operator|.
name|getPrototype
argument_list|()
operator|.
name|getNamedPropertyValues
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|topLevel
operator|.
name|add
argument_list|(
name|DYNAMIC_FIELDS
argument_list|,
name|dynamicFieldProperties
argument_list|)
expr_stmt|;
name|topLevel
operator|.
name|add
argument_list|(
name|COPY_FIELDS
argument_list|,
name|getCopyFieldProperties
argument_list|(
literal|false
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|topLevel
return|;
block|}
comment|/**    * Returns a list of copyField directives, with optional details and optionally restricting to those    * directives that contain the requested source and/or destination field names.    *     * @param showDetails If true, source and destination dynamic bases, and explicit fields matched by source globs,    *                    will be added to dynamic copyField directives where appropriate    * @param requestedSourceFields If not null, output is restricted to those copyField directives    *                              with the requested source field names     * @param requestedDestinationFields If not null, output is restricted to those copyField directives    *                                   with the requested destination field names     * @return a list of copyField directives     */
DECL|method|getCopyFieldProperties
specifier|public
name|List
argument_list|<
name|SimpleOrderedMap
argument_list|<
name|Object
argument_list|>
argument_list|>
name|getCopyFieldProperties
parameter_list|(
name|boolean
name|showDetails
parameter_list|,
name|Set
argument_list|<
name|String
argument_list|>
name|requestedSourceFields
parameter_list|,
name|Set
argument_list|<
name|String
argument_list|>
name|requestedDestinationFields
parameter_list|)
block|{
name|List
argument_list|<
name|SimpleOrderedMap
argument_list|<
name|Object
argument_list|>
argument_list|>
name|copyFieldProperties
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|SortedMap
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|CopyField
argument_list|>
argument_list|>
name|sortedCopyFields
init|=
operator|new
name|TreeMap
argument_list|<>
argument_list|(
name|copyFieldsMap
argument_list|)
decl_stmt|;
for|for
control|(
name|List
argument_list|<
name|CopyField
argument_list|>
name|copyFields
range|:
name|sortedCopyFields
operator|.
name|values
argument_list|()
control|)
block|{
name|copyFields
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|copyFields
argument_list|)
expr_stmt|;
name|Collections
operator|.
name|sort
argument_list|(
name|copyFields
argument_list|,
operator|new
name|Comparator
argument_list|<
name|CopyField
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|int
name|compare
parameter_list|(
name|CopyField
name|cf1
parameter_list|,
name|CopyField
name|cf2
parameter_list|)
block|{
comment|// sources are all the same, just sorting by destination here
return|return
name|cf1
operator|.
name|getDestination
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|compareTo
argument_list|(
name|cf2
operator|.
name|getDestination
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
return|;
block|}
block|}
argument_list|)
expr_stmt|;
for|for
control|(
name|CopyField
name|copyField
range|:
name|copyFields
control|)
block|{
specifier|final
name|String
name|source
init|=
name|copyField
operator|.
name|getSource
argument_list|()
operator|.
name|getName
argument_list|()
decl_stmt|;
specifier|final
name|String
name|destination
init|=
name|copyField
operator|.
name|getDestination
argument_list|()
operator|.
name|getName
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
literal|null
operator|==
name|requestedSourceFields
operator|||
name|requestedSourceFields
operator|.
name|contains
argument_list|(
name|source
argument_list|)
operator|)
operator|&&
operator|(
literal|null
operator|==
name|requestedDestinationFields
operator|||
name|requestedDestinationFields
operator|.
name|contains
argument_list|(
name|destination
argument_list|)
operator|)
condition|)
block|{
name|SimpleOrderedMap
argument_list|<
name|Object
argument_list|>
name|props
init|=
operator|new
name|SimpleOrderedMap
argument_list|<>
argument_list|()
decl_stmt|;
name|props
operator|.
name|add
argument_list|(
name|SOURCE
argument_list|,
name|source
argument_list|)
expr_stmt|;
name|props
operator|.
name|add
argument_list|(
name|DESTINATION
argument_list|,
name|destination
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|!=
name|copyField
operator|.
name|getMaxChars
argument_list|()
condition|)
block|{
name|props
operator|.
name|add
argument_list|(
name|MAX_CHARS
argument_list|,
name|copyField
operator|.
name|getMaxChars
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|copyFieldProperties
operator|.
name|add
argument_list|(
name|props
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
literal|null
operator|!=
name|dynamicCopyFields
condition|)
block|{
for|for
control|(
name|IndexSchema
operator|.
name|DynamicCopy
name|dynamicCopy
range|:
name|dynamicCopyFields
control|)
block|{
specifier|final
name|String
name|source
init|=
name|dynamicCopy
operator|.
name|getRegex
argument_list|()
decl_stmt|;
specifier|final
name|String
name|destination
init|=
name|dynamicCopy
operator|.
name|getDestFieldName
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
literal|null
operator|==
name|requestedSourceFields
operator|||
name|requestedSourceFields
operator|.
name|contains
argument_list|(
name|source
argument_list|)
operator|)
operator|&&
operator|(
literal|null
operator|==
name|requestedDestinationFields
operator|||
name|requestedDestinationFields
operator|.
name|contains
argument_list|(
name|destination
argument_list|)
operator|)
condition|)
block|{
name|SimpleOrderedMap
argument_list|<
name|Object
argument_list|>
name|dynamicCopyProps
init|=
operator|new
name|SimpleOrderedMap
argument_list|<>
argument_list|()
decl_stmt|;
name|dynamicCopyProps
operator|.
name|add
argument_list|(
name|SOURCE
argument_list|,
name|dynamicCopy
operator|.
name|getRegex
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|showDetails
condition|)
block|{
name|IndexSchema
operator|.
name|DynamicField
name|sourceDynamicBase
init|=
name|dynamicCopy
operator|.
name|getSourceDynamicBase
argument_list|()
decl_stmt|;
if|if
condition|(
literal|null
operator|!=
name|sourceDynamicBase
condition|)
block|{
name|dynamicCopyProps
operator|.
name|add
argument_list|(
name|SOURCE_DYNAMIC_BASE
argument_list|,
name|sourceDynamicBase
operator|.
name|getRegex
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|source
operator|.
name|contains
argument_list|(
literal|"*"
argument_list|)
condition|)
block|{
name|List
argument_list|<
name|String
argument_list|>
name|sourceExplicitFields
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|Pattern
name|pattern
init|=
name|Pattern
operator|.
name|compile
argument_list|(
name|source
operator|.
name|replace
argument_list|(
literal|"*"
argument_list|,
literal|".*"
argument_list|)
argument_list|)
decl_stmt|;
comment|// glob->regex
for|for
control|(
name|String
name|field
range|:
name|fields
operator|.
name|keySet
argument_list|()
control|)
block|{
if|if
condition|(
name|pattern
operator|.
name|matcher
argument_list|(
name|field
argument_list|)
operator|.
name|matches
argument_list|()
condition|)
block|{
name|sourceExplicitFields
operator|.
name|add
argument_list|(
name|field
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sourceExplicitFields
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|Collections
operator|.
name|sort
argument_list|(
name|sourceExplicitFields
argument_list|)
expr_stmt|;
name|dynamicCopyProps
operator|.
name|add
argument_list|(
name|SOURCE_EXPLICIT_FIELDS
argument_list|,
name|sourceExplicitFields
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|dynamicCopyProps
operator|.
name|add
argument_list|(
name|DESTINATION
argument_list|,
name|dynamicCopy
operator|.
name|getDestFieldName
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|showDetails
condition|)
block|{
name|IndexSchema
operator|.
name|DynamicField
name|destDynamicBase
init|=
name|dynamicCopy
operator|.
name|getDestDynamicBase
argument_list|()
decl_stmt|;
if|if
condition|(
literal|null
operator|!=
name|destDynamicBase
condition|)
block|{
name|dynamicCopyProps
operator|.
name|add
argument_list|(
name|DESTINATION_DYNAMIC_BASE
argument_list|,
name|destDynamicBase
operator|.
name|getRegex
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
literal|0
operator|!=
name|dynamicCopy
operator|.
name|getMaxChars
argument_list|()
condition|)
block|{
name|dynamicCopyProps
operator|.
name|add
argument_list|(
name|MAX_CHARS
argument_list|,
name|dynamicCopy
operator|.
name|getMaxChars
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|copyFieldProperties
operator|.
name|add
argument_list|(
name|dynamicCopyProps
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|copyFieldProperties
return|;
block|}
DECL|method|IndexSchema
specifier|protected
name|IndexSchema
parameter_list|(
specifier|final
name|SolrConfig
name|solrConfig
parameter_list|,
specifier|final
name|SolrResourceLoader
name|loader
parameter_list|)
block|{
name|this
operator|.
name|solrConfig
operator|=
name|solrConfig
expr_stmt|;
name|this
operator|.
name|loader
operator|=
name|loader
expr_stmt|;
block|}
comment|/**    * Copies this schema, adds the given field to the copy    * Requires synchronizing on the object returned by    * {@link #getSchemaUpdateLock()}.    *    * @param newField the SchemaField to add     * @param persist to persist the schema or not    * @return a new IndexSchema based on this schema with newField added    * @see #newField(String, String, Map)    */
DECL|method|addField
specifier|public
name|IndexSchema
name|addField
parameter_list|(
name|SchemaField
name|newField
parameter_list|,
name|boolean
name|persist
parameter_list|)
block|{
return|return
name|addFields
argument_list|(
name|Collections
operator|.
name|singletonList
argument_list|(
name|newField
argument_list|)
argument_list|,
name|Collections
operator|.
name|emptyMap
argument_list|()
argument_list|,
name|persist
argument_list|)
return|;
block|}
DECL|method|addField
specifier|public
name|IndexSchema
name|addField
parameter_list|(
name|SchemaField
name|newField
parameter_list|)
block|{
return|return
name|addField
argument_list|(
name|newField
argument_list|,
literal|true
argument_list|)
return|;
block|}
comment|/**    * Copies this schema, adds the given field to the copy    *  Requires synchronizing on the object returned by    * {@link #getSchemaUpdateLock()}.    *    * @param newField the SchemaField to add    * @param copyFieldNames 0 or more names of targets to copy this field to.  The targets must already exist.    * @return a new IndexSchema based on this schema with newField added    * @see #newField(String, String, Map)    */
DECL|method|addField
specifier|public
name|IndexSchema
name|addField
parameter_list|(
name|SchemaField
name|newField
parameter_list|,
name|Collection
argument_list|<
name|String
argument_list|>
name|copyFieldNames
parameter_list|)
block|{
return|return
name|addFields
argument_list|(
name|singletonList
argument_list|(
name|newField
argument_list|)
argument_list|,
name|singletonMap
argument_list|(
name|newField
operator|.
name|getName
argument_list|()
argument_list|,
name|copyFieldNames
argument_list|)
argument_list|,
literal|true
argument_list|)
return|;
block|}
comment|/**    * Copies this schema, adds the given fields to the copy.    * Requires synchronizing on the object returned by    * {@link #getSchemaUpdateLock()}.    *    * @param newFields the SchemaFields to add    * @return a new IndexSchema based on this schema with newFields added    * @see #newField(String, String, Map)    */
DECL|method|addFields
specifier|public
name|IndexSchema
name|addFields
parameter_list|(
name|Collection
argument_list|<
name|SchemaField
argument_list|>
name|newFields
parameter_list|)
block|{
return|return
name|addFields
argument_list|(
name|newFields
argument_list|,
name|Collections
operator|.
expr|<
name|String
argument_list|,
name|Collection
argument_list|<
name|String
argument_list|>
operator|>
name|emptyMap
argument_list|()
argument_list|,
literal|true
argument_list|)
return|;
block|}
comment|/**    * Copies this schema, adds the given fields to the copy    * Requires synchronizing on the object returned by    * {@link #getSchemaUpdateLock()}.    *    * @param newFields the SchemaFields to add    * @param copyFieldNames 0 or more names of targets to copy this field to.  The target fields must already exist.    * @param persist Persist the schema or not    * @return a new IndexSchema based on this schema with newFields added    * @see #newField(String, String, Map)    */
DECL|method|addFields
specifier|public
name|IndexSchema
name|addFields
parameter_list|(
name|Collection
argument_list|<
name|SchemaField
argument_list|>
name|newFields
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|Collection
argument_list|<
name|String
argument_list|>
argument_list|>
name|copyFieldNames
parameter_list|,
name|boolean
name|persist
parameter_list|)
block|{
name|String
name|msg
init|=
literal|"This IndexSchema is not mutable."
decl_stmt|;
name|log
operator|.
name|error
argument_list|(
name|msg
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|SERVER_ERROR
argument_list|,
name|msg
argument_list|)
throw|;
block|}
comment|/**    * Copies this schema, deletes the named fields from the copy.    *<p>    * The schema will not be persisted.    *<p>    * Requires synchronizing on the object returned by    * {@link #getSchemaUpdateLock()}.    *    * @param names the names of the fields to delete    * @return a new IndexSchema based on this schema with the named fields deleted    */
DECL|method|deleteFields
specifier|public
name|IndexSchema
name|deleteFields
parameter_list|(
name|Collection
argument_list|<
name|String
argument_list|>
name|names
parameter_list|)
block|{
name|String
name|msg
init|=
literal|"This IndexSchema is not mutable."
decl_stmt|;
name|log
operator|.
name|error
argument_list|(
name|msg
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|SERVER_ERROR
argument_list|,
name|msg
argument_list|)
throw|;
block|}
comment|/**    * Copies this schema, deletes the named field from the copy, creates a new field     * with the same name using the given args, then rebinds any referring copy fields    * to the replacement field.    *    *<p>    * The schema will not be persisted.    *<p>    * Requires synchronizing on the object returned by {@link #getSchemaUpdateLock()}.    *    * @param fieldName The name of the field to be replaced    * @param replacementFieldType  The field type of the replacement field                                       * @param replacementArgs Initialization params for the replacement field    * @return a new IndexSchema based on this schema with the named field replaced    */
DECL|method|replaceField
specifier|public
name|IndexSchema
name|replaceField
parameter_list|(
name|String
name|fieldName
parameter_list|,
name|FieldType
name|replacementFieldType
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|?
argument_list|>
name|replacementArgs
parameter_list|)
block|{
name|String
name|msg
init|=
literal|"This IndexSchema is not mutable."
decl_stmt|;
name|log
operator|.
name|error
argument_list|(
name|msg
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|SERVER_ERROR
argument_list|,
name|msg
argument_list|)
throw|;
block|}
comment|/**    * Copies this schema, adds the given dynamic fields to the copy,    * Requires synchronizing on the object returned by    * {@link #getSchemaUpdateLock()}.    *    * @param newDynamicFields the SchemaFields to add    * @param copyFieldNames 0 or more names of targets to copy this field to.  The target fields must already exist.    * @param persist to persist the schema or not    * @return a new IndexSchema based on this schema with newDynamicFields added    * @see #newDynamicField(String, String, Map)    */
DECL|method|addDynamicFields
specifier|public
name|IndexSchema
name|addDynamicFields
parameter_list|(
name|Collection
argument_list|<
name|SchemaField
argument_list|>
name|newDynamicFields
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|Collection
argument_list|<
name|String
argument_list|>
argument_list|>
name|copyFieldNames
parameter_list|,
name|boolean
name|persist
parameter_list|)
block|{
name|String
name|msg
init|=
literal|"This IndexSchema is not mutable."
decl_stmt|;
name|log
operator|.
name|error
argument_list|(
name|msg
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|SERVER_ERROR
argument_list|,
name|msg
argument_list|)
throw|;
block|}
comment|/**    * Copies this schema, deletes the named dynamic fields from the copy.    *<p>    * The schema will not be persisted.    *<p>    * Requires synchronizing on the object returned by    * {@link #getSchemaUpdateLock()}.    *    * @param fieldNamePatterns the names of the dynamic fields to delete    * @return a new IndexSchema based on this schema with the named dynamic fields deleted    */
DECL|method|deleteDynamicFields
specifier|public
name|IndexSchema
name|deleteDynamicFields
parameter_list|(
name|Collection
argument_list|<
name|String
argument_list|>
name|fieldNamePatterns
parameter_list|)
block|{
name|String
name|msg
init|=
literal|"This IndexSchema is not mutable."
decl_stmt|;
name|log
operator|.
name|error
argument_list|(
name|msg
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|SERVER_ERROR
argument_list|,
name|msg
argument_list|)
throw|;
block|}
comment|/**    * Copies this schema, deletes the named dynamic field from the copy, creates a new dynamic    * field with the same field name pattern using the given args, then rebinds any referring    * dynamic copy fields to the replacement dynamic field.    *    *<p>    * The schema will not be persisted.    *<p>    * Requires synchronizing on the object returned by {@link #getSchemaUpdateLock()}.    *    * @param fieldNamePattern The glob for the dynamic field to be replaced    * @param replacementFieldType  The field type of the replacement dynamic field                                       * @param replacementArgs Initialization params for the replacement dynamic field    * @return a new IndexSchema based on this schema with the named dynamic field replaced    */
DECL|method|replaceDynamicField
specifier|public
name|ManagedIndexSchema
name|replaceDynamicField
parameter_list|(
name|String
name|fieldNamePattern
parameter_list|,
name|FieldType
name|replacementFieldType
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|?
argument_list|>
name|replacementArgs
parameter_list|)
block|{
name|String
name|msg
init|=
literal|"This IndexSchema is not mutable."
decl_stmt|;
name|log
operator|.
name|error
argument_list|(
name|msg
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|SERVER_ERROR
argument_list|,
name|msg
argument_list|)
throw|;
block|}
comment|/**      * Copies this schema and adds the new copy fields to the copy      * Requires synchronizing on the object returned by      * {@link #getSchemaUpdateLock()}.      *      * @see #addCopyFields(String,Collection,int) to limit the number of copied characters.      *      * @param copyFields Key is the name of the source field name, value is a collection of target field names.  Fields must exist.      * @param persist to persist the schema or not      * @return The new Schema with the copy fields added      */
DECL|method|addCopyFields
specifier|public
name|IndexSchema
name|addCopyFields
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|Collection
argument_list|<
name|String
argument_list|>
argument_list|>
name|copyFields
parameter_list|,
name|boolean
name|persist
parameter_list|)
block|{
name|String
name|msg
init|=
literal|"This IndexSchema is not mutable."
decl_stmt|;
name|log
operator|.
name|error
argument_list|(
name|msg
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|SERVER_ERROR
argument_list|,
name|msg
argument_list|)
throw|;
block|}
comment|/**    * Copies this schema and adds the new copy fields to the copy.    *     * Requires synchronizing on the object returned by     * {@link #getSchemaUpdateLock()}    *     * @param source source field name    * @param destinations collection of target field names    * @param maxChars max number of characters to copy from the source to each    *                 of the destinations.  Use {@link CopyField#UNLIMITED}    *                 if you don't want to limit the number of copied chars.    * @return The new Schema with the copy fields added    */
DECL|method|addCopyFields
specifier|public
name|IndexSchema
name|addCopyFields
parameter_list|(
name|String
name|source
parameter_list|,
name|Collection
argument_list|<
name|String
argument_list|>
name|destinations
parameter_list|,
name|int
name|maxChars
parameter_list|)
block|{
name|String
name|msg
init|=
literal|"This IndexSchema is not mutable."
decl_stmt|;
name|log
operator|.
name|error
argument_list|(
name|msg
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|SERVER_ERROR
argument_list|,
name|msg
argument_list|)
throw|;
block|}
comment|/**    * Copies this schema and deletes the given copy fields from the copy.    *<p>    * The schema will not be persisted.    *<p>    * Requires synchronizing on the object returned by    * {@link #getSchemaUpdateLock()}.    *    * @param copyFields Key is the name of the source field name, value is a collection of target field names.     *                   Each corresponding copy field directives must exist.    * @return The new Schema with the copy fields deleted    */
DECL|method|deleteCopyFields
specifier|public
name|IndexSchema
name|deleteCopyFields
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|Collection
argument_list|<
name|String
argument_list|>
argument_list|>
name|copyFields
parameter_list|)
block|{
name|String
name|msg
init|=
literal|"This IndexSchema is not mutable."
decl_stmt|;
name|log
operator|.
name|error
argument_list|(
name|msg
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|SERVER_ERROR
argument_list|,
name|msg
argument_list|)
throw|;
block|}
comment|/**    * Returns a SchemaField if the given fieldName does not already     * exist in this schema, and does not match any dynamic fields     * in this schema.  The resulting SchemaField can be used in a call    * to {@link #addField(SchemaField)}.    *    * @param fieldName the name of the field to add    * @param fieldType the field type for the new field    * @param options the options to use when creating the SchemaField    * @return The created SchemaField    * @see #addField(SchemaField)    */
DECL|method|newField
specifier|public
name|SchemaField
name|newField
parameter_list|(
name|String
name|fieldName
parameter_list|,
name|String
name|fieldType
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|?
argument_list|>
name|options
parameter_list|)
block|{
name|String
name|msg
init|=
literal|"This IndexSchema is not mutable."
decl_stmt|;
name|log
operator|.
name|error
argument_list|(
name|msg
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|SERVER_ERROR
argument_list|,
name|msg
argument_list|)
throw|;
block|}
comment|/**    * Returns a SchemaField if the given dynamic field glob does not already     * exist in this schema, and does not match any dynamic fields     * in this schema.  The resulting SchemaField can be used in a call    * to {@link #addField(SchemaField)}.    *    * @param fieldNamePattern the pattern for the dynamic field to add    * @param fieldType the field type for the new field    * @param options the options to use when creating the SchemaField    * @return The created SchemaField    * @see #addField(SchemaField)    */
DECL|method|newDynamicField
specifier|public
name|SchemaField
name|newDynamicField
parameter_list|(
name|String
name|fieldNamePattern
parameter_list|,
name|String
name|fieldType
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|?
argument_list|>
name|options
parameter_list|)
block|{
name|String
name|msg
init|=
literal|"This IndexSchema is not mutable."
decl_stmt|;
name|log
operator|.
name|error
argument_list|(
name|msg
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|SERVER_ERROR
argument_list|,
name|msg
argument_list|)
throw|;
block|}
comment|/**    * Returns the schema update lock that should be synchronized on    * to update the schema.  Only applicable to mutable schemas.    *    * @return the schema update lock object to synchronize on    */
DECL|method|getSchemaUpdateLock
specifier|public
name|Object
name|getSchemaUpdateLock
parameter_list|()
block|{
name|String
name|msg
init|=
literal|"This IndexSchema is not mutable."
decl_stmt|;
name|log
operator|.
name|error
argument_list|(
name|msg
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|SERVER_ERROR
argument_list|,
name|msg
argument_list|)
throw|;
block|}
comment|/**    * Copies this schema, adds the given field type to the copy,    * Requires synchronizing on the object returned by    * {@link #getSchemaUpdateLock()}.    *    * @param fieldTypeList a list of FieldTypes to add    * @param persist to persist the schema or not    * @return a new IndexSchema based on this schema with the new types added    * @see #newFieldType(String, String, Map)    */
DECL|method|addFieldTypes
specifier|public
name|IndexSchema
name|addFieldTypes
parameter_list|(
name|List
argument_list|<
name|FieldType
argument_list|>
name|fieldTypeList
parameter_list|,
name|boolean
name|persist
parameter_list|)
block|{
name|String
name|msg
init|=
literal|"This IndexSchema is not mutable."
decl_stmt|;
name|log
operator|.
name|error
argument_list|(
name|msg
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|SERVER_ERROR
argument_list|,
name|msg
argument_list|)
throw|;
block|}
comment|/**    * Copies this schema, deletes the named field types from the copy.    *<p>    * The schema will not be persisted.    *<p>    * Requires synchronizing on the object returned by {@link #getSchemaUpdateLock()}.    *    * @param names the names of the field types to delete    * @return a new IndexSchema based on this schema with the named field types deleted    */
DECL|method|deleteFieldTypes
specifier|public
name|IndexSchema
name|deleteFieldTypes
parameter_list|(
name|Collection
argument_list|<
name|String
argument_list|>
name|names
parameter_list|)
block|{
name|String
name|msg
init|=
literal|"This IndexSchema is not mutable."
decl_stmt|;
name|log
operator|.
name|error
argument_list|(
name|msg
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|SERVER_ERROR
argument_list|,
name|msg
argument_list|)
throw|;
block|}
comment|/**    * Copies this schema, deletes the named field type from the copy, creates a new field type     * with the same name using the given args, rebuilds fields and dynamic fields of the given    * type, then rebinds any referring copy fields to the rebuilt fields.    *     *<p>    * The schema will not be persisted.    *<p>    * Requires synchronizing on the object returned by {@link #getSchemaUpdateLock()}.    *      * @param typeName The name of the field type to be replaced    * @param replacementClassName The class name of the replacement field type    * @param replacementArgs Initialization params for the replacement field type    * @return a new IndexSchema based on this schema with the named field type replaced    */
DECL|method|replaceFieldType
specifier|public
name|IndexSchema
name|replaceFieldType
parameter_list|(
name|String
name|typeName
parameter_list|,
name|String
name|replacementClassName
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|replacementArgs
parameter_list|)
block|{
name|String
name|msg
init|=
literal|"This IndexSchema is not mutable."
decl_stmt|;
name|log
operator|.
name|error
argument_list|(
name|msg
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|SERVER_ERROR
argument_list|,
name|msg
argument_list|)
throw|;
block|}
comment|/**    * Returns a FieldType if the given typeName does not already    * exist in this schema. The resulting FieldType can be used in a call    * to {@link #addFieldTypes(java.util.List, boolean)}.    *    * @param typeName the name of the type to add    * @param className the name of the FieldType class    * @param options the options to use when creating the FieldType    * @return The created FieldType    * @see #addFieldTypes(java.util.List, boolean)    */
DECL|method|newFieldType
specifier|public
name|FieldType
name|newFieldType
parameter_list|(
name|String
name|typeName
parameter_list|,
name|String
name|className
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|?
argument_list|>
name|options
parameter_list|)
block|{
name|String
name|msg
init|=
literal|"This IndexSchema is not mutable."
decl_stmt|;
name|log
operator|.
name|error
argument_list|(
name|msg
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|SERVER_ERROR
argument_list|,
name|msg
argument_list|)
throw|;
block|}
DECL|method|getFieldTypeXPathExpressions
specifier|protected
name|String
name|getFieldTypeXPathExpressions
parameter_list|()
block|{
comment|//               /schema/fieldtype | /schema/fieldType | /schema/types/fieldtype | /schema/types/fieldType
name|String
name|expression
init|=
name|stepsToPath
argument_list|(
name|SCHEMA
argument_list|,
name|FIELD_TYPE
operator|.
name|toLowerCase
argument_list|(
name|Locale
operator|.
name|ROOT
argument_list|)
argument_list|)
comment|// backcompat(?)
operator|+
name|XPATH_OR
operator|+
name|stepsToPath
argument_list|(
name|SCHEMA
argument_list|,
name|FIELD_TYPE
argument_list|)
operator|+
name|XPATH_OR
operator|+
name|stepsToPath
argument_list|(
name|SCHEMA
argument_list|,
name|TYPES
argument_list|,
name|FIELD_TYPE
operator|.
name|toLowerCase
argument_list|(
name|Locale
operator|.
name|ROOT
argument_list|)
argument_list|)
operator|+
name|XPATH_OR
operator|+
name|stepsToPath
argument_list|(
name|SCHEMA
argument_list|,
name|TYPES
argument_list|,
name|FIELD_TYPE
argument_list|)
decl_stmt|;
return|return
name|expression
return|;
block|}
block|}
end_class
end_unit
