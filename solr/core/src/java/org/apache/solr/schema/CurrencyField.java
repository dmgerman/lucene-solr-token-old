begin_unit
begin_package
DECL|package|org.apache.solr.schema
package|package
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|schema
package|;
end_package
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|util
operator|.
name|ResourceLoader
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|util
operator|.
name|ResourceLoaderAware
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|AtomicReaderContext
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|StorableField
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|queries
operator|.
name|function
operator|.
name|FunctionValues
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|queries
operator|.
name|function
operator|.
name|ValueSource
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|Query
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|SortField
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|Filter
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|FieldValueFilter
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|queries
operator|.
name|ChainedFilter
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|SolrException
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|SolrException
operator|.
name|ErrorCode
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|response
operator|.
name|TextResponseWriter
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|search
operator|.
name|QParser
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|search
operator|.
name|SolrConstantScoreQuery
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|search
operator|.
name|function
operator|.
name|ValueSourceRangeFilter
import|;
end_import
begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import
begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import
begin_import
import|import
name|org
operator|.
name|w3c
operator|.
name|dom
operator|.
name|Document
import|;
end_import
begin_import
import|import
name|org
operator|.
name|w3c
operator|.
name|dom
operator|.
name|NamedNodeMap
import|;
end_import
begin_import
import|import
name|org
operator|.
name|w3c
operator|.
name|dom
operator|.
name|Node
import|;
end_import
begin_import
import|import
name|org
operator|.
name|w3c
operator|.
name|dom
operator|.
name|NodeList
import|;
end_import
begin_import
import|import
name|org
operator|.
name|xml
operator|.
name|sax
operator|.
name|SAXException
import|;
end_import
begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|parsers
operator|.
name|DocumentBuilderFactory
import|;
end_import
begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|parsers
operator|.
name|ParserConfigurationException
import|;
end_import
begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|xpath
operator|.
name|XPath
import|;
end_import
begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|xpath
operator|.
name|XPathConstants
import|;
end_import
begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|xpath
operator|.
name|XPathExpressionException
import|;
end_import
begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|xpath
operator|.
name|XPathFactory
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Currency
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import
begin_comment
comment|/**  * Field type for support of monetary values.  *<p>  * See<a href="http://wiki.apache.org/solr/CurrencyField">http://wiki.apache.org/solr/CurrencyField</a>  */
end_comment
begin_class
DECL|class|CurrencyField
specifier|public
class|class
name|CurrencyField
extends|extends
name|FieldType
implements|implements
name|SchemaAware
implements|,
name|ResourceLoaderAware
block|{
DECL|field|PARAM_DEFAULT_CURRENCY
specifier|protected
specifier|static
specifier|final
name|String
name|PARAM_DEFAULT_CURRENCY
init|=
literal|"defaultCurrency"
decl_stmt|;
DECL|field|PARAM_RATE_PROVIDER_CLASS
specifier|protected
specifier|static
specifier|final
name|String
name|PARAM_RATE_PROVIDER_CLASS
init|=
literal|"providerClass"
decl_stmt|;
DECL|field|PARAM_PRECISION_STEP
specifier|protected
specifier|static
specifier|final
name|Object
name|PARAM_PRECISION_STEP
init|=
literal|"precisionStep"
decl_stmt|;
DECL|field|DEFAULT_RATE_PROVIDER_CLASS
specifier|protected
specifier|static
specifier|final
name|String
name|DEFAULT_RATE_PROVIDER_CLASS
init|=
literal|"solr.FileExchangeRateProvider"
decl_stmt|;
DECL|field|DEFAULT_DEFAULT_CURRENCY
specifier|protected
specifier|static
specifier|final
name|String
name|DEFAULT_DEFAULT_CURRENCY
init|=
literal|"USD"
decl_stmt|;
DECL|field|DEFAULT_PRECISION_STEP
specifier|protected
specifier|static
specifier|final
name|String
name|DEFAULT_PRECISION_STEP
init|=
literal|"0"
decl_stmt|;
DECL|field|FIELD_SUFFIX_AMOUNT_RAW
specifier|protected
specifier|static
specifier|final
name|String
name|FIELD_SUFFIX_AMOUNT_RAW
init|=
literal|"_amount_raw"
decl_stmt|;
DECL|field|FIELD_SUFFIX_CURRENCY
specifier|protected
specifier|static
specifier|final
name|String
name|FIELD_SUFFIX_CURRENCY
init|=
literal|"_currency"
decl_stmt|;
DECL|field|schema
specifier|private
name|IndexSchema
name|schema
decl_stmt|;
DECL|field|fieldTypeCurrency
specifier|protected
name|FieldType
name|fieldTypeCurrency
decl_stmt|;
DECL|field|fieldTypeAmountRaw
specifier|protected
name|FieldType
name|fieldTypeAmountRaw
decl_stmt|;
DECL|field|exchangeRateProviderClass
specifier|private
name|String
name|exchangeRateProviderClass
decl_stmt|;
DECL|field|defaultCurrency
specifier|private
name|String
name|defaultCurrency
decl_stmt|;
DECL|field|provider
specifier|private
name|ExchangeRateProvider
name|provider
decl_stmt|;
DECL|field|log
specifier|public
specifier|static
name|Logger
name|log
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|CurrencyField
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/**    * A wrapper arround<code>Currency.getInstance</code> that returns null    * instead of throwing<code>IllegalArgumentException</code>    * if the specified Currency does not exist in this JVM.    *    * @see Currency#getInstance(String)    */
DECL|method|getCurrency
specifier|public
specifier|static
name|Currency
name|getCurrency
parameter_list|(
specifier|final
name|String
name|code
parameter_list|)
block|{
try|try
block|{
return|return
name|Currency
operator|.
name|getInstance
argument_list|(
name|code
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|e
parameter_list|)
block|{
comment|/* :NOOP: */
block|}
return|return
literal|null
return|;
block|}
annotation|@
name|Override
DECL|method|init
specifier|protected
name|void
name|init
parameter_list|(
name|IndexSchema
name|schema
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|args
parameter_list|)
block|{
name|super
operator|.
name|init
argument_list|(
name|schema
argument_list|,
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|isMultiValued
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|SolrException
operator|.
name|ErrorCode
operator|.
name|SERVER_ERROR
argument_list|,
literal|"CurrencyField types can not be multiValued: "
operator|+
name|this
operator|.
name|typeName
argument_list|)
throw|;
block|}
name|this
operator|.
name|schema
operator|=
name|schema
expr_stmt|;
name|this
operator|.
name|exchangeRateProviderClass
operator|=
name|args
operator|.
name|get
argument_list|(
name|PARAM_RATE_PROVIDER_CLASS
argument_list|)
expr_stmt|;
name|this
operator|.
name|defaultCurrency
operator|=
name|args
operator|.
name|get
argument_list|(
name|PARAM_DEFAULT_CURRENCY
argument_list|)
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|defaultCurrency
operator|==
literal|null
condition|)
block|{
name|this
operator|.
name|defaultCurrency
operator|=
name|DEFAULT_DEFAULT_CURRENCY
expr_stmt|;
block|}
if|if
condition|(
name|this
operator|.
name|exchangeRateProviderClass
operator|==
literal|null
condition|)
block|{
name|this
operator|.
name|exchangeRateProviderClass
operator|=
name|DEFAULT_RATE_PROVIDER_CLASS
expr_stmt|;
block|}
if|if
condition|(
literal|null
operator|==
name|getCurrency
argument_list|(
name|this
operator|.
name|defaultCurrency
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|SolrException
operator|.
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
literal|"Default currency code is not supported by this JVM: "
operator|+
name|this
operator|.
name|defaultCurrency
argument_list|)
throw|;
block|}
name|String
name|precisionStepString
init|=
name|args
operator|.
name|get
argument_list|(
name|PARAM_PRECISION_STEP
argument_list|)
decl_stmt|;
if|if
condition|(
name|precisionStepString
operator|==
literal|null
condition|)
block|{
name|precisionStepString
operator|=
name|DEFAULT_PRECISION_STEP
expr_stmt|;
block|}
comment|// Initialize field type for amount
name|fieldTypeAmountRaw
operator|=
operator|new
name|TrieLongField
argument_list|()
expr_stmt|;
name|fieldTypeAmountRaw
operator|.
name|setTypeName
argument_list|(
literal|"amount_raw_type_tlong"
argument_list|)
expr_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|map
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|map
operator|.
name|put
argument_list|(
literal|"precisionStep"
argument_list|,
name|precisionStepString
argument_list|)
expr_stmt|;
name|fieldTypeAmountRaw
operator|.
name|init
argument_list|(
name|schema
argument_list|,
name|map
argument_list|)
expr_stmt|;
comment|// Initialize field type for currency string
name|fieldTypeCurrency
operator|=
operator|new
name|StrField
argument_list|()
expr_stmt|;
name|fieldTypeCurrency
operator|.
name|setTypeName
argument_list|(
literal|"currency_type_string"
argument_list|)
expr_stmt|;
name|fieldTypeCurrency
operator|.
name|init
argument_list|(
name|schema
argument_list|,
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
name|args
operator|.
name|remove
argument_list|(
name|PARAM_RATE_PROVIDER_CLASS
argument_list|)
expr_stmt|;
name|args
operator|.
name|remove
argument_list|(
name|PARAM_DEFAULT_CURRENCY
argument_list|)
expr_stmt|;
name|args
operator|.
name|remove
argument_list|(
name|PARAM_PRECISION_STEP
argument_list|)
expr_stmt|;
try|try
block|{
name|Class
argument_list|<
name|?
extends|extends
name|ExchangeRateProvider
argument_list|>
name|c
init|=
name|schema
operator|.
name|getResourceLoader
argument_list|()
operator|.
name|findClass
argument_list|(
name|exchangeRateProviderClass
argument_list|,
name|ExchangeRateProvider
operator|.
name|class
argument_list|)
decl_stmt|;
name|provider
operator|=
name|c
operator|.
name|newInstance
argument_list|()
expr_stmt|;
name|provider
operator|.
name|init
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
literal|"Error instantiating exhange rate provider "
operator|+
name|exchangeRateProviderClass
operator|+
literal|": "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
DECL|method|isPolyField
specifier|public
name|boolean
name|isPolyField
parameter_list|()
block|{
return|return
literal|true
return|;
block|}
annotation|@
name|Override
DECL|method|checkSchemaField
specifier|public
name|void
name|checkSchemaField
parameter_list|(
specifier|final
name|SchemaField
name|field
parameter_list|)
throws|throws
name|SolrException
block|{
name|super
operator|.
name|checkSchemaField
argument_list|(
name|field
argument_list|)
expr_stmt|;
if|if
condition|(
name|field
operator|.
name|multiValued
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|SolrException
operator|.
name|ErrorCode
operator|.
name|SERVER_ERROR
argument_list|,
literal|"CurrencyFields can not be multiValued: "
operator|+
name|field
operator|.
name|getName
argument_list|()
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
DECL|method|createFields
specifier|public
name|List
argument_list|<
name|StorableField
argument_list|>
name|createFields
parameter_list|(
name|SchemaField
name|field
parameter_list|,
name|Object
name|externalVal
parameter_list|,
name|float
name|boost
parameter_list|)
block|{
name|CurrencyValue
name|value
init|=
name|CurrencyValue
operator|.
name|parse
argument_list|(
name|externalVal
operator|.
name|toString
argument_list|()
argument_list|,
name|defaultCurrency
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|StorableField
argument_list|>
name|f
init|=
operator|new
name|ArrayList
argument_list|<
name|StorableField
argument_list|>
argument_list|()
decl_stmt|;
name|SchemaField
name|amountField
init|=
name|getAmountField
argument_list|(
name|field
argument_list|)
decl_stmt|;
name|f
operator|.
name|add
argument_list|(
name|amountField
operator|.
name|createField
argument_list|(
name|String
operator|.
name|valueOf
argument_list|(
name|value
operator|.
name|getAmount
argument_list|()
argument_list|)
argument_list|,
name|amountField
operator|.
name|indexed
argument_list|()
operator|&&
operator|!
name|amountField
operator|.
name|omitNorms
argument_list|()
condition|?
name|boost
else|:
literal|1F
argument_list|)
argument_list|)
expr_stmt|;
name|SchemaField
name|currencyField
init|=
name|getCurrencyField
argument_list|(
name|field
argument_list|)
decl_stmt|;
name|f
operator|.
name|add
argument_list|(
name|currencyField
operator|.
name|createField
argument_list|(
name|value
operator|.
name|getCurrencyCode
argument_list|()
argument_list|,
name|currencyField
operator|.
name|indexed
argument_list|()
operator|&&
operator|!
name|currencyField
operator|.
name|omitNorms
argument_list|()
condition|?
name|boost
else|:
literal|1F
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|field
operator|.
name|stored
argument_list|()
condition|)
block|{
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|document
operator|.
name|FieldType
name|customType
init|=
operator|new
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|document
operator|.
name|FieldType
argument_list|()
decl_stmt|;
assert|assert
operator|!
name|customType
operator|.
name|omitNorms
argument_list|()
assert|;
name|customType
operator|.
name|setStored
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|String
name|storedValue
init|=
name|externalVal
operator|.
name|toString
argument_list|()
operator|.
name|trim
argument_list|()
decl_stmt|;
if|if
condition|(
name|storedValue
operator|.
name|indexOf
argument_list|(
literal|","
argument_list|)
operator|<
literal|0
condition|)
block|{
name|storedValue
operator|+=
literal|","
operator|+
name|defaultCurrency
expr_stmt|;
block|}
name|f
operator|.
name|add
argument_list|(
name|createField
argument_list|(
name|field
operator|.
name|getName
argument_list|()
argument_list|,
name|storedValue
argument_list|,
name|customType
argument_list|,
literal|1F
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|f
return|;
block|}
DECL|method|getAmountField
specifier|private
name|SchemaField
name|getAmountField
parameter_list|(
name|SchemaField
name|field
parameter_list|)
block|{
return|return
name|schema
operator|.
name|getField
argument_list|(
name|field
operator|.
name|getName
argument_list|()
operator|+
name|POLY_FIELD_SEPARATOR
operator|+
name|FIELD_SUFFIX_AMOUNT_RAW
argument_list|)
return|;
block|}
DECL|method|getCurrencyField
specifier|private
name|SchemaField
name|getCurrencyField
parameter_list|(
name|SchemaField
name|field
parameter_list|)
block|{
return|return
name|schema
operator|.
name|getField
argument_list|(
name|field
operator|.
name|getName
argument_list|()
operator|+
name|POLY_FIELD_SEPARATOR
operator|+
name|FIELD_SUFFIX_CURRENCY
argument_list|)
return|;
block|}
DECL|method|createDynamicCurrencyField
specifier|private
name|void
name|createDynamicCurrencyField
parameter_list|(
name|String
name|suffix
parameter_list|,
name|FieldType
name|type
parameter_list|)
block|{
name|String
name|name
init|=
literal|"*"
operator|+
name|POLY_FIELD_SEPARATOR
operator|+
name|suffix
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|props
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|props
operator|.
name|put
argument_list|(
literal|"indexed"
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
name|props
operator|.
name|put
argument_list|(
literal|"stored"
argument_list|,
literal|"false"
argument_list|)
expr_stmt|;
name|props
operator|.
name|put
argument_list|(
literal|"multiValued"
argument_list|,
literal|"false"
argument_list|)
expr_stmt|;
name|props
operator|.
name|put
argument_list|(
literal|"omitNorms"
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
name|int
name|p
init|=
name|SchemaField
operator|.
name|calcProps
argument_list|(
name|name
argument_list|,
name|type
argument_list|,
name|props
argument_list|)
decl_stmt|;
name|schema
operator|.
name|registerDynamicField
argument_list|(
name|SchemaField
operator|.
name|create
argument_list|(
name|name
argument_list|,
name|type
argument_list|,
name|p
argument_list|,
literal|null
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * When index schema is informed, add dynamic fields.    *    * @param indexSchema The index schema.    */
annotation|@
name|Override
DECL|method|inform
specifier|public
name|void
name|inform
parameter_list|(
name|IndexSchema
name|indexSchema
parameter_list|)
block|{
name|createDynamicCurrencyField
argument_list|(
name|FIELD_SUFFIX_CURRENCY
argument_list|,
name|fieldTypeCurrency
argument_list|)
expr_stmt|;
name|createDynamicCurrencyField
argument_list|(
name|FIELD_SUFFIX_AMOUNT_RAW
argument_list|,
name|fieldTypeAmountRaw
argument_list|)
expr_stmt|;
block|}
comment|/**    * Load the currency config when resource loader initialized.    *    * @param resourceLoader The resource loader.    */
annotation|@
name|Override
DECL|method|inform
specifier|public
name|void
name|inform
parameter_list|(
name|ResourceLoader
name|resourceLoader
parameter_list|)
block|{
name|provider
operator|.
name|inform
argument_list|(
name|resourceLoader
argument_list|)
expr_stmt|;
name|boolean
name|reloaded
init|=
name|provider
operator|.
name|reload
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|reloaded
condition|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Failed reloading currencies"
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|getFieldQuery
specifier|public
name|Query
name|getFieldQuery
parameter_list|(
name|QParser
name|parser
parameter_list|,
name|SchemaField
name|field
parameter_list|,
name|String
name|externalVal
parameter_list|)
block|{
name|CurrencyValue
name|value
init|=
name|CurrencyValue
operator|.
name|parse
argument_list|(
name|externalVal
argument_list|,
name|defaultCurrency
argument_list|)
decl_stmt|;
name|CurrencyValue
name|valueDefault
decl_stmt|;
name|valueDefault
operator|=
name|value
operator|.
name|convertTo
argument_list|(
name|provider
argument_list|,
name|defaultCurrency
argument_list|)
expr_stmt|;
return|return
name|getRangeQuery
argument_list|(
name|parser
argument_list|,
name|field
argument_list|,
name|valueDefault
argument_list|,
name|valueDefault
argument_list|,
literal|true
argument_list|,
literal|true
argument_list|)
return|;
block|}
comment|/**    *<p>    * Returns a ValueSource over this field in which the numeric value for     * each document represents the indexed value as converted to the default     * currency for the field, normalized to it's most granular form based     * on the default fractional digits.    *</p>    *<p>    * For example: If the default Currency specified for a field is     *<code>USD</code>, then the values returned by this value source would     * represent the equivilent number of "cents" (ie: value in dollars * 100)     * after converting each document's native currency to USD -- because the     * default fractional digits for<code>USD</code> is "<code>2</code>".      * So for a document whose indexed value was currently equivilent to     * "<code>5.43,USD</code>" using the the exchange provider for this field,     * this ValueSource would return a value of "<code>543<code>"    *</p>    *    * @see #PARAM_DEFAULT_CURRENCY    * @see #DEFAULT_DEFAULT_CURRENCY    * @see Currency#getDefaultFractionDigits    * @see getConvertedValueSource    */
DECL|method|getValueSource
specifier|public
name|RawCurrencyValueSource
name|getValueSource
parameter_list|(
name|SchemaField
name|field
parameter_list|,
name|QParser
name|parser
parameter_list|)
block|{
name|field
operator|.
name|checkFieldCacheSource
argument_list|(
name|parser
argument_list|)
expr_stmt|;
return|return
operator|new
name|RawCurrencyValueSource
argument_list|(
name|field
argument_list|,
name|defaultCurrency
argument_list|,
name|parser
argument_list|)
return|;
block|}
comment|/**    *<p>    * Returns a ValueSource over this field in which the numeric value for     * each document represents the value from the underlying     *<code>RawCurrencyValueSource</code> as converted to the specified target     * Currency.    *</p>    *<p>    * For example: If the<code>targetCurrencyCode</code> param is set to    *<code>USD</code>, then the values returned by this value source would     * represent the equivilent number of dollars after converting each     * document's raw value to<code>USD</code>.  So for a document whose     * indexed value was currently equivilent to "<code>5.43,USD</code>"     * using the the exchange provider for this field, this ValueSource would     * return a value of "<code>5.43<code>"    *</p>    *    * @param targetCurrencyCode The target currency for the resulting value source, if null the defaultCurrency for this field type will be used    * @param source the raw ValueSource to wrap    * @see #PARAM_DEFAULT_CURRENCY    * @see #DEFAULT_DEFAULT_CURRENCY    * @see getValueSource    */
DECL|method|getConvertedValueSource
specifier|public
name|ValueSource
name|getConvertedValueSource
parameter_list|(
name|String
name|targetCurrencyCode
parameter_list|,
name|RawCurrencyValueSource
name|source
parameter_list|)
block|{
if|if
condition|(
literal|null
operator|==
name|targetCurrencyCode
condition|)
block|{
name|targetCurrencyCode
operator|=
name|defaultCurrency
expr_stmt|;
block|}
return|return
operator|new
name|ConvertedCurrencyValueSource
argument_list|(
name|targetCurrencyCode
argument_list|,
name|source
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|getRangeQuery
specifier|public
name|Query
name|getRangeQuery
parameter_list|(
name|QParser
name|parser
parameter_list|,
name|SchemaField
name|field
parameter_list|,
name|String
name|part1
parameter_list|,
name|String
name|part2
parameter_list|,
specifier|final
name|boolean
name|minInclusive
parameter_list|,
specifier|final
name|boolean
name|maxInclusive
parameter_list|)
block|{
specifier|final
name|CurrencyValue
name|p1
init|=
name|CurrencyValue
operator|.
name|parse
argument_list|(
name|part1
argument_list|,
name|defaultCurrency
argument_list|)
decl_stmt|;
specifier|final
name|CurrencyValue
name|p2
init|=
name|CurrencyValue
operator|.
name|parse
argument_list|(
name|part2
argument_list|,
name|defaultCurrency
argument_list|)
decl_stmt|;
if|if
condition|(
name|p1
operator|!=
literal|null
operator|&&
name|p2
operator|!=
literal|null
operator|&&
operator|!
name|p1
operator|.
name|getCurrencyCode
argument_list|()
operator|.
name|equals
argument_list|(
name|p2
operator|.
name|getCurrencyCode
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|SolrException
operator|.
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
literal|"Cannot parse range query "
operator|+
name|part1
operator|+
literal|" to "
operator|+
name|part2
operator|+
literal|": range queries only supported when upper and lower bound have same currency."
argument_list|)
throw|;
block|}
return|return
name|getRangeQuery
argument_list|(
name|parser
argument_list|,
name|field
argument_list|,
name|p1
argument_list|,
name|p2
argument_list|,
name|minInclusive
argument_list|,
name|maxInclusive
argument_list|)
return|;
block|}
DECL|method|getRangeQuery
specifier|public
name|Query
name|getRangeQuery
parameter_list|(
name|QParser
name|parser
parameter_list|,
name|SchemaField
name|field
parameter_list|,
specifier|final
name|CurrencyValue
name|p1
parameter_list|,
specifier|final
name|CurrencyValue
name|p2
parameter_list|,
specifier|final
name|boolean
name|minInclusive
parameter_list|,
specifier|final
name|boolean
name|maxInclusive
parameter_list|)
block|{
name|String
name|currencyCode
init|=
operator|(
name|p1
operator|!=
literal|null
operator|)
condition|?
name|p1
operator|.
name|getCurrencyCode
argument_list|()
else|:
operator|(
name|p2
operator|!=
literal|null
operator|)
condition|?
name|p2
operator|.
name|getCurrencyCode
argument_list|()
else|:
name|defaultCurrency
decl_stmt|;
comment|// ValueSourceRangeFilter doesn't check exists(), so we have to
specifier|final
name|Filter
name|docsWithValues
init|=
operator|new
name|FieldValueFilter
argument_list|(
name|getAmountField
argument_list|(
name|field
argument_list|)
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|Filter
name|vsRangeFilter
init|=
operator|new
name|ValueSourceRangeFilter
argument_list|(
operator|new
name|RawCurrencyValueSource
argument_list|(
name|field
argument_list|,
name|currencyCode
argument_list|,
name|parser
argument_list|)
argument_list|,
name|p1
operator|==
literal|null
condition|?
literal|null
else|:
name|p1
operator|.
name|getAmount
argument_list|()
operator|+
literal|""
argument_list|,
name|p2
operator|==
literal|null
condition|?
literal|null
else|:
name|p2
operator|.
name|getAmount
argument_list|()
operator|+
literal|""
argument_list|,
name|minInclusive
argument_list|,
name|maxInclusive
argument_list|)
decl_stmt|;
specifier|final
name|Filter
name|docsInRange
init|=
operator|new
name|ChainedFilter
argument_list|(
operator|new
name|Filter
index|[]
block|{
name|docsWithValues
block|,
name|vsRangeFilter
block|}
argument_list|,
name|ChainedFilter
operator|.
name|AND
argument_list|)
decl_stmt|;
return|return
operator|new
name|SolrConstantScoreQuery
argument_list|(
name|docsInRange
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|getSortField
specifier|public
name|SortField
name|getSortField
parameter_list|(
name|SchemaField
name|field
parameter_list|,
name|boolean
name|reverse
parameter_list|)
block|{
comment|// Convert all values to default currency for sorting.
return|return
operator|(
operator|new
name|RawCurrencyValueSource
argument_list|(
name|field
argument_list|,
name|defaultCurrency
argument_list|,
literal|null
argument_list|)
operator|)
operator|.
name|getSortField
argument_list|(
name|reverse
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|write
specifier|public
name|void
name|write
parameter_list|(
name|TextResponseWriter
name|writer
parameter_list|,
name|String
name|name
parameter_list|,
name|StorableField
name|field
parameter_list|)
throws|throws
name|IOException
block|{
name|writer
operator|.
name|writeStr
argument_list|(
name|name
argument_list|,
name|field
operator|.
name|stringValue
argument_list|()
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
DECL|method|getProvider
specifier|public
name|ExchangeRateProvider
name|getProvider
parameter_list|()
block|{
return|return
name|provider
return|;
block|}
comment|/**    *<p>    * A value source whose values represent the "normal" values    * in the specified target currency.    *</p>    * @see RawCurrencyValueSource    */
DECL|class|ConvertedCurrencyValueSource
class|class
name|ConvertedCurrencyValueSource
extends|extends
name|ValueSource
block|{
DECL|field|targetCurrency
specifier|private
specifier|final
name|Currency
name|targetCurrency
decl_stmt|;
DECL|field|source
specifier|private
specifier|final
name|RawCurrencyValueSource
name|source
decl_stmt|;
DECL|field|rate
specifier|private
specifier|final
name|double
name|rate
decl_stmt|;
DECL|method|ConvertedCurrencyValueSource
specifier|public
name|ConvertedCurrencyValueSource
parameter_list|(
name|String
name|targetCurrencyCode
parameter_list|,
name|RawCurrencyValueSource
name|source
parameter_list|)
block|{
name|this
operator|.
name|source
operator|=
name|source
expr_stmt|;
name|this
operator|.
name|targetCurrency
operator|=
name|getCurrency
argument_list|(
name|targetCurrencyCode
argument_list|)
expr_stmt|;
if|if
condition|(
literal|null
operator|==
name|targetCurrency
condition|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|SolrException
operator|.
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
literal|"Currency code not supported by this JVM: "
operator|+
name|targetCurrencyCode
argument_list|)
throw|;
block|}
comment|// the target digits& currency of our source,
comment|// become the source digits& currency of ourselves
name|this
operator|.
name|rate
operator|=
name|provider
operator|.
name|getExchangeRate
argument_list|(
name|source
operator|.
name|getTargetCurrency
argument_list|()
operator|.
name|getCurrencyCode
argument_list|()
argument_list|,
name|targetCurrency
operator|.
name|getCurrencyCode
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|getValues
specifier|public
name|FunctionValues
name|getValues
parameter_list|(
name|Map
name|context
parameter_list|,
name|AtomicReaderContext
name|reader
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|FunctionValues
name|amounts
init|=
name|source
operator|.
name|getValues
argument_list|(
name|context
argument_list|,
name|reader
argument_list|)
decl_stmt|;
comment|// the target digits& currency of our source,
comment|// become the source digits& currency of ourselves
specifier|final
name|String
name|sourceCurrencyCode
init|=
name|source
operator|.
name|getTargetCurrency
argument_list|()
operator|.
name|getCurrencyCode
argument_list|()
decl_stmt|;
specifier|final
name|int
name|sourceFractionDigits
init|=
name|source
operator|.
name|getTargetCurrency
argument_list|()
operator|.
name|getDefaultFractionDigits
argument_list|()
decl_stmt|;
specifier|final
name|double
name|divisor
init|=
name|Math
operator|.
name|pow
argument_list|(
literal|10D
argument_list|,
name|targetCurrency
operator|.
name|getDefaultFractionDigits
argument_list|()
argument_list|)
decl_stmt|;
return|return
operator|new
name|FunctionValues
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|boolean
name|exists
parameter_list|(
name|int
name|doc
parameter_list|)
block|{
return|return
name|amounts
operator|.
name|exists
argument_list|(
name|doc
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|long
name|longVal
parameter_list|(
name|int
name|doc
parameter_list|)
block|{
return|return
operator|(
name|long
operator|)
name|doubleVal
argument_list|(
name|doc
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|intVal
parameter_list|(
name|int
name|doc
parameter_list|)
block|{
return|return
operator|(
name|int
operator|)
name|doubleVal
argument_list|(
name|doc
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|double
name|doubleVal
parameter_list|(
name|int
name|doc
parameter_list|)
block|{
return|return
name|CurrencyValue
operator|.
name|convertAmount
argument_list|(
name|rate
argument_list|,
name|sourceCurrencyCode
argument_list|,
name|amounts
operator|.
name|longVal
argument_list|(
name|doc
argument_list|)
argument_list|,
name|targetCurrency
operator|.
name|getCurrencyCode
argument_list|()
argument_list|)
operator|/
name|divisor
return|;
block|}
annotation|@
name|Override
specifier|public
name|float
name|floatVal
parameter_list|(
name|int
name|doc
parameter_list|)
block|{
return|return
name|CurrencyValue
operator|.
name|convertAmount
argument_list|(
name|rate
argument_list|,
name|sourceCurrencyCode
argument_list|,
name|amounts
operator|.
name|longVal
argument_list|(
name|doc
argument_list|)
argument_list|,
name|targetCurrency
operator|.
name|getCurrencyCode
argument_list|()
argument_list|)
operator|/
operator|(
operator|(
name|float
operator|)
name|divisor
operator|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|strVal
parameter_list|(
name|int
name|doc
parameter_list|)
block|{
return|return
name|Double
operator|.
name|toString
argument_list|(
name|doubleVal
argument_list|(
name|doc
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|(
name|int
name|doc
parameter_list|)
block|{
return|return
name|name
argument_list|()
operator|+
literal|'('
operator|+
name|strVal
argument_list|(
name|doc
argument_list|)
operator|+
literal|')'
return|;
block|}
block|}
return|;
block|}
DECL|method|name
specifier|public
name|String
name|name
parameter_list|()
block|{
return|return
literal|"currency"
return|;
block|}
annotation|@
name|Override
DECL|method|description
specifier|public
name|String
name|description
parameter_list|()
block|{
return|return
name|name
argument_list|()
operator|+
literal|"("
operator|+
name|source
operator|.
name|getField
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|","
operator|+
name|targetCurrency
operator|.
name|getCurrencyCode
argument_list|()
operator|+
literal|")"
return|;
block|}
annotation|@
name|Override
DECL|method|equals
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
if|if
condition|(
name|this
operator|==
name|o
condition|)
return|return
literal|true
return|;
if|if
condition|(
name|o
operator|==
literal|null
operator|||
name|getClass
argument_list|()
operator|!=
name|o
operator|.
name|getClass
argument_list|()
condition|)
return|return
literal|false
return|;
name|ConvertedCurrencyValueSource
name|that
init|=
operator|(
name|ConvertedCurrencyValueSource
operator|)
name|o
decl_stmt|;
return|return
operator|!
operator|(
name|source
operator|!=
literal|null
condition|?
operator|!
name|source
operator|.
name|equals
argument_list|(
name|that
operator|.
name|source
argument_list|)
else|:
name|that
operator|.
name|source
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|rate
operator|==
name|that
operator|.
name|rate
operator|)
operator|&&
operator|!
operator|(
name|targetCurrency
operator|!=
literal|null
condition|?
operator|!
name|targetCurrency
operator|.
name|equals
argument_list|(
name|that
operator|.
name|targetCurrency
argument_list|)
else|:
name|that
operator|.
name|targetCurrency
operator|!=
literal|null
operator|)
return|;
block|}
annotation|@
name|Override
DECL|method|hashCode
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
name|int
name|result
init|=
name|targetCurrency
operator|!=
literal|null
condition|?
name|targetCurrency
operator|.
name|hashCode
argument_list|()
else|:
literal|0
decl_stmt|;
name|result
operator|=
literal|31
operator|*
name|result
operator|+
operator|(
name|source
operator|!=
literal|null
condition|?
name|source
operator|.
name|hashCode
argument_list|()
else|:
literal|0
operator|)
expr_stmt|;
name|result
operator|=
literal|31
operator|*
operator|(
name|int
operator|)
name|Double
operator|.
name|doubleToLongBits
argument_list|(
name|rate
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
block|}
comment|/**    *<p>    * A value source whose values represent the "raw" (ie: normalized using     * the number of default fractional digits) values in the specified     * target currency).    *</p>    *<p>    * For example: if the specified target currency is "<code>USD</code>"     * then the numeric values are the number of pennies in the value     * (ie:<code>$n * 100</code>) since the number of defalt fractional     * digits for<code>USD</code> is "<code>2</code>")    *</p>    * @see ConvertedCurrencValueSource    */
DECL|class|RawCurrencyValueSource
class|class
name|RawCurrencyValueSource
extends|extends
name|ValueSource
block|{
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|1L
decl_stmt|;
DECL|field|targetCurrency
specifier|private
specifier|final
name|Currency
name|targetCurrency
decl_stmt|;
DECL|field|currencyValues
specifier|private
name|ValueSource
name|currencyValues
decl_stmt|;
DECL|field|amountValues
specifier|private
name|ValueSource
name|amountValues
decl_stmt|;
DECL|field|sf
specifier|private
specifier|final
name|SchemaField
name|sf
decl_stmt|;
DECL|method|RawCurrencyValueSource
specifier|public
name|RawCurrencyValueSource
parameter_list|(
name|SchemaField
name|sfield
parameter_list|,
name|String
name|targetCurrencyCode
parameter_list|,
name|QParser
name|parser
parameter_list|)
block|{
name|this
operator|.
name|sf
operator|=
name|sfield
expr_stmt|;
name|this
operator|.
name|targetCurrency
operator|=
name|getCurrency
argument_list|(
name|targetCurrencyCode
argument_list|)
expr_stmt|;
if|if
condition|(
literal|null
operator|==
name|targetCurrency
condition|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|SolrException
operator|.
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
literal|"Currency code not supported by this JVM: "
operator|+
name|targetCurrencyCode
argument_list|)
throw|;
block|}
name|SchemaField
name|amountField
init|=
name|schema
operator|.
name|getField
argument_list|(
name|sf
operator|.
name|getName
argument_list|()
operator|+
name|POLY_FIELD_SEPARATOR
operator|+
name|FIELD_SUFFIX_AMOUNT_RAW
argument_list|)
decl_stmt|;
name|SchemaField
name|currencyField
init|=
name|schema
operator|.
name|getField
argument_list|(
name|sf
operator|.
name|getName
argument_list|()
operator|+
name|POLY_FIELD_SEPARATOR
operator|+
name|FIELD_SUFFIX_CURRENCY
argument_list|)
decl_stmt|;
name|currencyValues
operator|=
name|currencyField
operator|.
name|getType
argument_list|()
operator|.
name|getValueSource
argument_list|(
name|currencyField
argument_list|,
name|parser
argument_list|)
expr_stmt|;
name|amountValues
operator|=
name|amountField
operator|.
name|getType
argument_list|()
operator|.
name|getValueSource
argument_list|(
name|amountField
argument_list|,
name|parser
argument_list|)
expr_stmt|;
block|}
DECL|method|getField
specifier|public
name|SchemaField
name|getField
parameter_list|()
block|{
return|return
name|sf
return|;
block|}
DECL|method|getTargetCurrency
specifier|public
name|Currency
name|getTargetCurrency
parameter_list|()
block|{
return|return
name|targetCurrency
return|;
block|}
annotation|@
name|Override
DECL|method|getValues
specifier|public
name|FunctionValues
name|getValues
parameter_list|(
name|Map
name|context
parameter_list|,
name|AtomicReaderContext
name|reader
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|FunctionValues
name|amounts
init|=
name|amountValues
operator|.
name|getValues
argument_list|(
name|context
argument_list|,
name|reader
argument_list|)
decl_stmt|;
specifier|final
name|FunctionValues
name|currencies
init|=
name|currencyValues
operator|.
name|getValues
argument_list|(
name|context
argument_list|,
name|reader
argument_list|)
decl_stmt|;
return|return
operator|new
name|FunctionValues
argument_list|()
block|{
specifier|private
specifier|final
name|int
name|MAX_CURRENCIES_TO_CACHE
init|=
literal|256
decl_stmt|;
specifier|private
specifier|final
name|int
index|[]
name|fractionDigitCache
init|=
operator|new
name|int
index|[
name|MAX_CURRENCIES_TO_CACHE
index|]
decl_stmt|;
specifier|private
specifier|final
name|String
index|[]
name|currencyOrdToCurrencyCache
init|=
operator|new
name|String
index|[
name|MAX_CURRENCIES_TO_CACHE
index|]
decl_stmt|;
specifier|private
specifier|final
name|double
index|[]
name|exchangeRateCache
init|=
operator|new
name|double
index|[
name|MAX_CURRENCIES_TO_CACHE
index|]
decl_stmt|;
specifier|private
name|int
name|targetFractionDigits
init|=
operator|-
literal|1
decl_stmt|;
specifier|private
name|int
name|targetCurrencyOrd
init|=
operator|-
literal|1
decl_stmt|;
specifier|private
name|boolean
name|initializedCache
decl_stmt|;
specifier|private
name|String
name|getDocCurrencyCode
parameter_list|(
name|int
name|doc
parameter_list|,
name|int
name|currencyOrd
parameter_list|)
block|{
if|if
condition|(
name|currencyOrd
operator|<
name|MAX_CURRENCIES_TO_CACHE
condition|)
block|{
name|String
name|currency
init|=
name|currencyOrdToCurrencyCache
index|[
name|currencyOrd
index|]
decl_stmt|;
if|if
condition|(
name|currency
operator|==
literal|null
condition|)
block|{
name|currencyOrdToCurrencyCache
index|[
name|currencyOrd
index|]
operator|=
name|currency
operator|=
name|currencies
operator|.
name|strVal
argument_list|(
name|doc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|currency
operator|==
literal|null
condition|)
block|{
name|currency
operator|=
name|defaultCurrency
expr_stmt|;
block|}
if|if
condition|(
name|targetCurrencyOrd
operator|==
operator|-
literal|1
operator|&&
name|currency
operator|.
name|equals
argument_list|(
name|targetCurrency
operator|.
name|getCurrencyCode
argument_list|()
argument_list|)
condition|)
block|{
name|targetCurrencyOrd
operator|=
name|currencyOrd
expr_stmt|;
block|}
return|return
name|currency
return|;
block|}
else|else
block|{
return|return
name|currencies
operator|.
name|strVal
argument_list|(
name|doc
argument_list|)
return|;
block|}
block|}
comment|/** throws a (Server Error) SolrException if the code is not valid */
specifier|private
name|Currency
name|getDocCurrency
parameter_list|(
name|int
name|doc
parameter_list|,
name|int
name|currencyOrd
parameter_list|)
block|{
name|String
name|code
init|=
name|getDocCurrencyCode
argument_list|(
name|doc
argument_list|,
name|currencyOrd
argument_list|)
decl_stmt|;
name|Currency
name|c
init|=
name|getCurrency
argument_list|(
name|code
argument_list|)
decl_stmt|;
if|if
condition|(
literal|null
operator|==
name|c
condition|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|SolrException
operator|.
name|ErrorCode
operator|.
name|SERVER_ERROR
argument_list|,
literal|"Currency code of document is not supported by this JVM: "
operator|+
name|code
argument_list|)
throw|;
block|}
return|return
name|c
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|exists
parameter_list|(
name|int
name|doc
parameter_list|)
block|{
return|return
name|amounts
operator|.
name|exists
argument_list|(
name|doc
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|long
name|longVal
parameter_list|(
name|int
name|doc
parameter_list|)
block|{
name|long
name|amount
init|=
name|amounts
operator|.
name|longVal
argument_list|(
name|doc
argument_list|)
decl_stmt|;
comment|// bail fast using whatever ammounts defaults to if no value
comment|// (if we don't do this early, currencyOrd may be< 0,
comment|// causing index bounds exception
if|if
condition|(
operator|!
name|exists
argument_list|(
name|doc
argument_list|)
condition|)
block|{
return|return
name|amount
return|;
block|}
if|if
condition|(
operator|!
name|initializedCache
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fractionDigitCache
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|fractionDigitCache
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|initializedCache
operator|=
literal|true
expr_stmt|;
block|}
name|int
name|currencyOrd
init|=
name|currencies
operator|.
name|ordVal
argument_list|(
name|doc
argument_list|)
decl_stmt|;
if|if
condition|(
name|currencyOrd
operator|==
name|targetCurrencyOrd
condition|)
block|{
return|return
name|amount
return|;
block|}
name|double
name|exchangeRate
decl_stmt|;
name|int
name|sourceFractionDigits
decl_stmt|;
if|if
condition|(
name|targetFractionDigits
operator|==
operator|-
literal|1
condition|)
block|{
name|targetFractionDigits
operator|=
name|targetCurrency
operator|.
name|getDefaultFractionDigits
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|currencyOrd
operator|<
name|MAX_CURRENCIES_TO_CACHE
condition|)
block|{
name|exchangeRate
operator|=
name|exchangeRateCache
index|[
name|currencyOrd
index|]
expr_stmt|;
if|if
condition|(
name|exchangeRate
operator|<=
literal|0.0
condition|)
block|{
name|String
name|sourceCurrencyCode
init|=
name|getDocCurrencyCode
argument_list|(
name|doc
argument_list|,
name|currencyOrd
argument_list|)
decl_stmt|;
name|exchangeRate
operator|=
name|exchangeRateCache
index|[
name|currencyOrd
index|]
operator|=
name|provider
operator|.
name|getExchangeRate
argument_list|(
name|sourceCurrencyCode
argument_list|,
name|targetCurrency
operator|.
name|getCurrencyCode
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|sourceFractionDigits
operator|=
name|fractionDigitCache
index|[
name|currencyOrd
index|]
expr_stmt|;
if|if
condition|(
name|sourceFractionDigits
operator|==
operator|-
literal|1
condition|)
block|{
name|sourceFractionDigits
operator|=
name|fractionDigitCache
index|[
name|currencyOrd
index|]
operator|=
name|getDocCurrency
argument_list|(
name|doc
argument_list|,
name|currencyOrd
argument_list|)
operator|.
name|getDefaultFractionDigits
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
name|Currency
name|source
init|=
name|getDocCurrency
argument_list|(
name|doc
argument_list|,
name|currencyOrd
argument_list|)
decl_stmt|;
name|exchangeRate
operator|=
name|provider
operator|.
name|getExchangeRate
argument_list|(
name|source
operator|.
name|getCurrencyCode
argument_list|()
argument_list|,
name|targetCurrency
operator|.
name|getCurrencyCode
argument_list|()
argument_list|)
expr_stmt|;
name|sourceFractionDigits
operator|=
name|source
operator|.
name|getDefaultFractionDigits
argument_list|()
expr_stmt|;
block|}
return|return
name|CurrencyValue
operator|.
name|convertAmount
argument_list|(
name|exchangeRate
argument_list|,
name|sourceFractionDigits
argument_list|,
name|amount
argument_list|,
name|targetFractionDigits
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|intVal
parameter_list|(
name|int
name|doc
parameter_list|)
block|{
return|return
operator|(
name|int
operator|)
name|longVal
argument_list|(
name|doc
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|double
name|doubleVal
parameter_list|(
name|int
name|doc
parameter_list|)
block|{
return|return
operator|(
name|double
operator|)
name|longVal
argument_list|(
name|doc
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|float
name|floatVal
parameter_list|(
name|int
name|doc
parameter_list|)
block|{
return|return
operator|(
name|float
operator|)
name|longVal
argument_list|(
name|doc
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|strVal
parameter_list|(
name|int
name|doc
parameter_list|)
block|{
return|return
name|Long
operator|.
name|toString
argument_list|(
name|longVal
argument_list|(
name|doc
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|(
name|int
name|doc
parameter_list|)
block|{
return|return
name|name
argument_list|()
operator|+
literal|'('
operator|+
name|amounts
operator|.
name|toString
argument_list|(
name|doc
argument_list|)
operator|+
literal|','
operator|+
name|currencies
operator|.
name|toString
argument_list|(
name|doc
argument_list|)
operator|+
literal|')'
return|;
block|}
block|}
return|;
block|}
DECL|method|name
specifier|public
name|String
name|name
parameter_list|()
block|{
return|return
literal|"rawcurrency"
return|;
block|}
annotation|@
name|Override
DECL|method|description
specifier|public
name|String
name|description
parameter_list|()
block|{
return|return
name|name
argument_list|()
operator|+
literal|"("
operator|+
name|sf
operator|.
name|getName
argument_list|()
operator|+
literal|",target="
operator|+
name|targetCurrency
operator|.
name|getCurrencyCode
argument_list|()
operator|+
literal|")"
return|;
block|}
annotation|@
name|Override
DECL|method|equals
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
if|if
condition|(
name|this
operator|==
name|o
condition|)
return|return
literal|true
return|;
if|if
condition|(
name|o
operator|==
literal|null
operator|||
name|getClass
argument_list|()
operator|!=
name|o
operator|.
name|getClass
argument_list|()
condition|)
return|return
literal|false
return|;
name|RawCurrencyValueSource
name|that
init|=
operator|(
name|RawCurrencyValueSource
operator|)
name|o
decl_stmt|;
return|return
operator|!
operator|(
name|amountValues
operator|!=
literal|null
condition|?
operator|!
name|amountValues
operator|.
name|equals
argument_list|(
name|that
operator|.
name|amountValues
argument_list|)
else|:
name|that
operator|.
name|amountValues
operator|!=
literal|null
operator|)
operator|&&
operator|!
operator|(
name|currencyValues
operator|!=
literal|null
condition|?
operator|!
name|currencyValues
operator|.
name|equals
argument_list|(
name|that
operator|.
name|currencyValues
argument_list|)
else|:
name|that
operator|.
name|currencyValues
operator|!=
literal|null
operator|)
operator|&&
operator|!
operator|(
name|targetCurrency
operator|!=
literal|null
condition|?
operator|!
name|targetCurrency
operator|.
name|equals
argument_list|(
name|that
operator|.
name|targetCurrency
argument_list|)
else|:
name|that
operator|.
name|targetCurrency
operator|!=
literal|null
operator|)
return|;
block|}
annotation|@
name|Override
DECL|method|hashCode
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
name|int
name|result
init|=
name|targetCurrency
operator|!=
literal|null
condition|?
name|targetCurrency
operator|.
name|hashCode
argument_list|()
else|:
literal|0
decl_stmt|;
name|result
operator|=
literal|31
operator|*
name|result
operator|+
operator|(
name|currencyValues
operator|!=
literal|null
condition|?
name|currencyValues
operator|.
name|hashCode
argument_list|()
else|:
literal|0
operator|)
expr_stmt|;
name|result
operator|=
literal|31
operator|*
name|result
operator|+
operator|(
name|amountValues
operator|!=
literal|null
condition|?
name|amountValues
operator|.
name|hashCode
argument_list|()
else|:
literal|0
operator|)
expr_stmt|;
return|return
name|result
return|;
block|}
block|}
block|}
end_class
begin_comment
comment|/**  * Configuration for currency. Provides currency exchange rates.  */
end_comment
begin_class
DECL|class|FileExchangeRateProvider
class|class
name|FileExchangeRateProvider
implements|implements
name|ExchangeRateProvider
block|{
DECL|field|log
specifier|public
specifier|static
name|Logger
name|log
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|FileExchangeRateProvider
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|PARAM_CURRENCY_CONFIG
specifier|protected
specifier|static
specifier|final
name|String
name|PARAM_CURRENCY_CONFIG
init|=
literal|"currencyConfig"
decl_stmt|;
comment|// Exchange rate map, maps Currency Code -> Currency Code -> Rate
DECL|field|rates
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|Double
argument_list|>
argument_list|>
name|rates
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|Double
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
DECL|field|currencyConfigFile
specifier|private
name|String
name|currencyConfigFile
decl_stmt|;
DECL|field|loader
specifier|private
name|ResourceLoader
name|loader
decl_stmt|;
comment|/**    * Returns the currently known exchange rate between two currencies. If a direct rate has been loaded,    * it is used. Otherwise, if a rate is known to convert the target currency to the source, the inverse    * exchange rate is computed.    *    * @param sourceCurrencyCode The source currency being converted from.    * @param targetCurrencyCode The target currency being converted to.    * @return The exchange rate.    * @throws SolrException if the requested currency pair cannot be found    */
annotation|@
name|Override
DECL|method|getExchangeRate
specifier|public
name|double
name|getExchangeRate
parameter_list|(
name|String
name|sourceCurrencyCode
parameter_list|,
name|String
name|targetCurrencyCode
parameter_list|)
block|{
if|if
condition|(
name|sourceCurrencyCode
operator|==
literal|null
operator|||
name|targetCurrencyCode
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|SolrException
operator|.
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
literal|"Cannot get exchange rate; currency was null."
argument_list|)
throw|;
block|}
if|if
condition|(
name|sourceCurrencyCode
operator|.
name|equals
argument_list|(
name|targetCurrencyCode
argument_list|)
condition|)
block|{
return|return
literal|1.0
return|;
block|}
name|Double
name|directRate
init|=
name|lookupRate
argument_list|(
name|sourceCurrencyCode
argument_list|,
name|targetCurrencyCode
argument_list|)
decl_stmt|;
if|if
condition|(
name|directRate
operator|!=
literal|null
condition|)
block|{
return|return
name|directRate
return|;
block|}
name|Double
name|symmetricRate
init|=
name|lookupRate
argument_list|(
name|targetCurrencyCode
argument_list|,
name|sourceCurrencyCode
argument_list|)
decl_stmt|;
if|if
condition|(
name|symmetricRate
operator|!=
literal|null
condition|)
block|{
return|return
literal|1.0
operator|/
name|symmetricRate
return|;
block|}
throw|throw
operator|new
name|SolrException
argument_list|(
name|SolrException
operator|.
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
literal|"No available conversion rate between "
operator|+
name|sourceCurrencyCode
operator|+
literal|" to "
operator|+
name|targetCurrencyCode
argument_list|)
throw|;
block|}
comment|/**    * Looks up the current known rate, if any, between the source and target currencies.    *    * @param sourceCurrencyCode The source currency being converted from.    * @param targetCurrencyCode The target currency being converted to.    * @return The exchange rate, or null if no rate has been registered.    */
DECL|method|lookupRate
specifier|private
name|Double
name|lookupRate
parameter_list|(
name|String
name|sourceCurrencyCode
parameter_list|,
name|String
name|targetCurrencyCode
parameter_list|)
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|Double
argument_list|>
name|rhs
init|=
name|rates
operator|.
name|get
argument_list|(
name|sourceCurrencyCode
argument_list|)
decl_stmt|;
if|if
condition|(
name|rhs
operator|!=
literal|null
condition|)
block|{
return|return
name|rhs
operator|.
name|get
argument_list|(
name|targetCurrencyCode
argument_list|)
return|;
block|}
return|return
literal|null
return|;
block|}
comment|/**    * Registers the specified exchange rate.    *    * @param ratesMap           The map to add rate to    * @param sourceCurrencyCode The source currency.    * @param targetCurrencyCode The target currency.    * @param rate               The known exchange rate.    */
DECL|method|addRate
specifier|private
name|void
name|addRate
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|Double
argument_list|>
argument_list|>
name|ratesMap
parameter_list|,
name|String
name|sourceCurrencyCode
parameter_list|,
name|String
name|targetCurrencyCode
parameter_list|,
name|double
name|rate
parameter_list|)
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|Double
argument_list|>
name|rhs
init|=
name|ratesMap
operator|.
name|get
argument_list|(
name|sourceCurrencyCode
argument_list|)
decl_stmt|;
if|if
condition|(
name|rhs
operator|==
literal|null
condition|)
block|{
name|rhs
operator|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Double
argument_list|>
argument_list|()
expr_stmt|;
name|ratesMap
operator|.
name|put
argument_list|(
name|sourceCurrencyCode
argument_list|,
name|rhs
argument_list|)
expr_stmt|;
block|}
name|rhs
operator|.
name|put
argument_list|(
name|targetCurrencyCode
argument_list|,
name|rate
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|equals
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
if|if
condition|(
name|this
operator|==
name|o
condition|)
return|return
literal|true
return|;
if|if
condition|(
name|o
operator|==
literal|null
operator|||
name|getClass
argument_list|()
operator|!=
name|o
operator|.
name|getClass
argument_list|()
condition|)
return|return
literal|false
return|;
name|FileExchangeRateProvider
name|that
init|=
operator|(
name|FileExchangeRateProvider
operator|)
name|o
decl_stmt|;
return|return
operator|!
operator|(
name|rates
operator|!=
literal|null
condition|?
operator|!
name|rates
operator|.
name|equals
argument_list|(
name|that
operator|.
name|rates
argument_list|)
else|:
name|that
operator|.
name|rates
operator|!=
literal|null
operator|)
return|;
block|}
annotation|@
name|Override
DECL|method|hashCode
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
name|rates
operator|!=
literal|null
condition|?
name|rates
operator|.
name|hashCode
argument_list|()
else|:
literal|0
return|;
block|}
annotation|@
name|Override
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"["
operator|+
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|" : "
operator|+
name|rates
operator|.
name|size
argument_list|()
operator|+
literal|" rates.]"
return|;
block|}
annotation|@
name|Override
DECL|method|listAvailableCurrencies
specifier|public
name|Set
argument_list|<
name|String
argument_list|>
name|listAvailableCurrencies
parameter_list|()
block|{
name|Set
argument_list|<
name|String
argument_list|>
name|currencies
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|from
range|:
name|rates
operator|.
name|keySet
argument_list|()
control|)
block|{
name|currencies
operator|.
name|add
argument_list|(
name|from
argument_list|)
expr_stmt|;
for|for
control|(
name|String
name|to
range|:
name|rates
operator|.
name|get
argument_list|(
name|from
argument_list|)
operator|.
name|keySet
argument_list|()
control|)
block|{
name|currencies
operator|.
name|add
argument_list|(
name|to
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|currencies
return|;
block|}
annotation|@
name|Override
DECL|method|reload
specifier|public
name|boolean
name|reload
parameter_list|()
throws|throws
name|SolrException
block|{
name|InputStream
name|is
init|=
literal|null
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|Double
argument_list|>
argument_list|>
name|tmpRates
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|Double
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
try|try
block|{
name|log
operator|.
name|info
argument_list|(
literal|"Reloading exchange rates from file "
operator|+
name|this
operator|.
name|currencyConfigFile
argument_list|)
expr_stmt|;
name|is
operator|=
name|loader
operator|.
name|openResource
argument_list|(
name|currencyConfigFile
argument_list|)
expr_stmt|;
name|javax
operator|.
name|xml
operator|.
name|parsers
operator|.
name|DocumentBuilderFactory
name|dbf
init|=
name|DocumentBuilderFactory
operator|.
name|newInstance
argument_list|()
decl_stmt|;
try|try
block|{
name|dbf
operator|.
name|setXIncludeAware
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|dbf
operator|.
name|setNamespaceAware
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedOperationException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|SolrException
operator|.
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
literal|"XML parser doesn't support XInclude option"
argument_list|,
name|e
argument_list|)
throw|;
block|}
try|try
block|{
name|Document
name|doc
init|=
name|dbf
operator|.
name|newDocumentBuilder
argument_list|()
operator|.
name|parse
argument_list|(
name|is
argument_list|)
decl_stmt|;
name|XPathFactory
name|xpathFactory
init|=
name|XPathFactory
operator|.
name|newInstance
argument_list|()
decl_stmt|;
name|XPath
name|xpath
init|=
name|xpathFactory
operator|.
name|newXPath
argument_list|()
decl_stmt|;
comment|// Parse exchange rates.
name|NodeList
name|nodes
init|=
operator|(
name|NodeList
operator|)
name|xpath
operator|.
name|evaluate
argument_list|(
literal|"/currencyConfig/rates/rate"
argument_list|,
name|doc
argument_list|,
name|XPathConstants
operator|.
name|NODESET
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nodes
operator|.
name|getLength
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|Node
name|rateNode
init|=
name|nodes
operator|.
name|item
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|NamedNodeMap
name|attributes
init|=
name|rateNode
operator|.
name|getAttributes
argument_list|()
decl_stmt|;
name|Node
name|from
init|=
name|attributes
operator|.
name|getNamedItem
argument_list|(
literal|"from"
argument_list|)
decl_stmt|;
name|Node
name|to
init|=
name|attributes
operator|.
name|getNamedItem
argument_list|(
literal|"to"
argument_list|)
decl_stmt|;
name|Node
name|rate
init|=
name|attributes
operator|.
name|getNamedItem
argument_list|(
literal|"rate"
argument_list|)
decl_stmt|;
if|if
condition|(
name|from
operator|==
literal|null
operator|||
name|to
operator|==
literal|null
operator|||
name|rate
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|SolrException
operator|.
name|ErrorCode
operator|.
name|SERVER_ERROR
argument_list|,
literal|"Exchange rate missing attributes (required: from, to, rate) "
operator|+
name|rateNode
argument_list|)
throw|;
block|}
name|String
name|fromCurrency
init|=
name|from
operator|.
name|getNodeValue
argument_list|()
decl_stmt|;
name|String
name|toCurrency
init|=
name|to
operator|.
name|getNodeValue
argument_list|()
decl_stmt|;
name|Double
name|exchangeRate
decl_stmt|;
if|if
condition|(
literal|null
operator|==
name|CurrencyField
operator|.
name|getCurrency
argument_list|(
name|fromCurrency
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|SolrException
operator|.
name|ErrorCode
operator|.
name|SERVER_ERROR
argument_list|,
literal|"Specified 'from' currency not supported in this JVM: "
operator|+
name|fromCurrency
argument_list|)
throw|;
block|}
if|if
condition|(
literal|null
operator|==
name|CurrencyField
operator|.
name|getCurrency
argument_list|(
name|toCurrency
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|SolrException
operator|.
name|ErrorCode
operator|.
name|SERVER_ERROR
argument_list|,
literal|"Specified 'to' currency not supported in this JVM: "
operator|+
name|toCurrency
argument_list|)
throw|;
block|}
try|try
block|{
name|exchangeRate
operator|=
name|Double
operator|.
name|parseDouble
argument_list|(
name|rate
operator|.
name|getNodeValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|SolrException
operator|.
name|ErrorCode
operator|.
name|SERVER_ERROR
argument_list|,
literal|"Could not parse exchange rate: "
operator|+
name|rateNode
argument_list|,
name|e
argument_list|)
throw|;
block|}
name|addRate
argument_list|(
name|tmpRates
argument_list|,
name|fromCurrency
argument_list|,
name|toCurrency
argument_list|,
name|exchangeRate
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|SAXException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|SolrException
operator|.
name|ErrorCode
operator|.
name|SERVER_ERROR
argument_list|,
literal|"Error parsing currency config."
argument_list|,
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|SolrException
operator|.
name|ErrorCode
operator|.
name|SERVER_ERROR
argument_list|,
literal|"Error parsing currency config."
argument_list|,
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|ParserConfigurationException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|SolrException
operator|.
name|ErrorCode
operator|.
name|SERVER_ERROR
argument_list|,
literal|"Error parsing currency config."
argument_list|,
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|XPathExpressionException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|SolrException
operator|.
name|ErrorCode
operator|.
name|SERVER_ERROR
argument_list|,
literal|"Error parsing currency config."
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|SERVER_ERROR
argument_list|,
literal|"Error while opening Currency configuration file "
operator|+
name|currencyConfigFile
argument_list|,
name|e
argument_list|)
throw|;
block|}
finally|finally
block|{
try|try
block|{
if|if
condition|(
name|is
operator|!=
literal|null
condition|)
block|{
name|is
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|e
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
block|}
block|}
comment|// Atomically swap in the new rates map, if it loaded successfully
name|this
operator|.
name|rates
operator|=
name|tmpRates
expr_stmt|;
return|return
literal|true
return|;
block|}
annotation|@
name|Override
DECL|method|init
specifier|public
name|void
name|init
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|params
parameter_list|)
throws|throws
name|SolrException
block|{
name|this
operator|.
name|currencyConfigFile
operator|=
name|params
operator|.
name|get
argument_list|(
name|PARAM_CURRENCY_CONFIG
argument_list|)
expr_stmt|;
if|if
condition|(
name|currencyConfigFile
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|NOT_FOUND
argument_list|,
literal|"Missing required configuration "
operator|+
name|PARAM_CURRENCY_CONFIG
argument_list|)
throw|;
block|}
comment|// Removing config params custom to us
name|params
operator|.
name|remove
argument_list|(
name|PARAM_CURRENCY_CONFIG
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|inform
specifier|public
name|void
name|inform
parameter_list|(
name|ResourceLoader
name|loader
parameter_list|)
throws|throws
name|SolrException
block|{
if|if
condition|(
name|loader
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|SERVER_ERROR
argument_list|,
literal|"Needs ResourceLoader in order to load config file"
argument_list|)
throw|;
block|}
name|this
operator|.
name|loader
operator|=
name|loader
expr_stmt|;
name|reload
argument_list|()
expr_stmt|;
block|}
block|}
end_class
begin_comment
comment|/**  * Represents a Currency field value, which includes a long amount and ISO currency code.  */
end_comment
begin_class
DECL|class|CurrencyValue
class|class
name|CurrencyValue
block|{
DECL|field|amount
specifier|private
name|long
name|amount
decl_stmt|;
DECL|field|currencyCode
specifier|private
name|String
name|currencyCode
decl_stmt|;
comment|/**    * Constructs a new currency value.    *    * @param amount       The amount.    * @param currencyCode The currency code.    */
DECL|method|CurrencyValue
specifier|public
name|CurrencyValue
parameter_list|(
name|long
name|amount
parameter_list|,
name|String
name|currencyCode
parameter_list|)
block|{
name|this
operator|.
name|amount
operator|=
name|amount
expr_stmt|;
name|this
operator|.
name|currencyCode
operator|=
name|currencyCode
expr_stmt|;
block|}
comment|/**    * Constructs a new currency value by parsing the specific input.    *<p/>    * Currency values are expected to be in the format&lt;amount&gt;,&lt;currency code&gt;,    * for example, "500,USD" would represent 5 U.S. Dollars.    *<p/>    * If no currency code is specified, the default is assumed.    *    * @param externalVal The value to parse.    * @param defaultCurrency The default currency.    * @return The parsed CurrencyValue.    */
DECL|method|parse
specifier|public
specifier|static
name|CurrencyValue
name|parse
parameter_list|(
name|String
name|externalVal
parameter_list|,
name|String
name|defaultCurrency
parameter_list|)
block|{
if|if
condition|(
name|externalVal
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|String
name|amount
init|=
name|externalVal
decl_stmt|;
name|String
name|code
init|=
name|defaultCurrency
decl_stmt|;
if|if
condition|(
name|externalVal
operator|.
name|contains
argument_list|(
literal|","
argument_list|)
condition|)
block|{
name|String
index|[]
name|amountAndCode
init|=
name|externalVal
operator|.
name|split
argument_list|(
literal|","
argument_list|)
decl_stmt|;
name|amount
operator|=
name|amountAndCode
index|[
literal|0
index|]
expr_stmt|;
name|code
operator|=
name|amountAndCode
index|[
literal|1
index|]
expr_stmt|;
block|}
if|if
condition|(
name|amount
operator|.
name|equals
argument_list|(
literal|"*"
argument_list|)
condition|)
block|{
return|return
literal|null
return|;
block|}
name|Currency
name|currency
init|=
name|CurrencyField
operator|.
name|getCurrency
argument_list|(
name|code
argument_list|)
decl_stmt|;
if|if
condition|(
name|currency
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|SolrException
operator|.
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
literal|"Currency code not supported by this JVM: "
operator|+
name|code
argument_list|)
throw|;
block|}
try|try
block|{
name|double
name|value
init|=
name|Double
operator|.
name|parseDouble
argument_list|(
name|amount
argument_list|)
decl_stmt|;
name|long
name|currencyValue
init|=
name|Math
operator|.
name|round
argument_list|(
name|value
operator|*
name|Math
operator|.
name|pow
argument_list|(
literal|10.0
argument_list|,
name|currency
operator|.
name|getDefaultFractionDigits
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
return|return
operator|new
name|CurrencyValue
argument_list|(
name|currencyValue
argument_list|,
name|code
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|SolrException
operator|.
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**    * The amount of the CurrencyValue.    *    * @return The amount.    */
DECL|method|getAmount
specifier|public
name|long
name|getAmount
parameter_list|()
block|{
return|return
name|amount
return|;
block|}
comment|/**    * The ISO currency code of the CurrencyValue.    *    * @return The currency code.    */
DECL|method|getCurrencyCode
specifier|public
name|String
name|getCurrencyCode
parameter_list|()
block|{
return|return
name|currencyCode
return|;
block|}
comment|/**    * Performs a currency conversion& unit conversion.    *    * @param exchangeRates      Exchange rates to apply.    * @param sourceCurrencyCode The source currency code.    * @param sourceAmount       The source amount.    * @param targetCurrencyCode The target currency code.    * @return The converted indexable units after the exchange rate and currency fraction digits are applied.    */
DECL|method|convertAmount
specifier|public
specifier|static
name|long
name|convertAmount
parameter_list|(
name|ExchangeRateProvider
name|exchangeRates
parameter_list|,
name|String
name|sourceCurrencyCode
parameter_list|,
name|long
name|sourceAmount
parameter_list|,
name|String
name|targetCurrencyCode
parameter_list|)
block|{
name|double
name|exchangeRate
init|=
name|exchangeRates
operator|.
name|getExchangeRate
argument_list|(
name|sourceCurrencyCode
argument_list|,
name|targetCurrencyCode
argument_list|)
decl_stmt|;
return|return
name|convertAmount
argument_list|(
name|exchangeRate
argument_list|,
name|sourceCurrencyCode
argument_list|,
name|sourceAmount
argument_list|,
name|targetCurrencyCode
argument_list|)
return|;
block|}
comment|/**    * Performs a currency conversion& unit conversion.    *    * @param exchangeRate         Exchange rate to apply.    * @param sourceFractionDigits The fraction digits of the source.    * @param sourceAmount         The source amount.    * @param targetFractionDigits The fraction digits of the target.    * @return The converted indexable units after the exchange rate and currency fraction digits are applied.    */
DECL|method|convertAmount
specifier|public
specifier|static
name|long
name|convertAmount
parameter_list|(
specifier|final
name|double
name|exchangeRate
parameter_list|,
specifier|final
name|int
name|sourceFractionDigits
parameter_list|,
specifier|final
name|long
name|sourceAmount
parameter_list|,
specifier|final
name|int
name|targetFractionDigits
parameter_list|)
block|{
name|int
name|digitDelta
init|=
name|targetFractionDigits
operator|-
name|sourceFractionDigits
decl_stmt|;
name|double
name|value
init|=
operator|(
operator|(
name|double
operator|)
name|sourceAmount
operator|*
name|exchangeRate
operator|)
decl_stmt|;
if|if
condition|(
name|digitDelta
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|digitDelta
operator|<
literal|0
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
operator|-
name|digitDelta
condition|;
name|i
operator|++
control|)
block|{
name|value
operator|*=
literal|0.1
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|digitDelta
condition|;
name|i
operator|++
control|)
block|{
name|value
operator|*=
literal|10.0
expr_stmt|;
block|}
block|}
block|}
return|return
operator|(
name|long
operator|)
name|value
return|;
block|}
comment|/**    * Performs a currency conversion& unit conversion.    *    * @param exchangeRate       Exchange rate to apply.    * @param sourceCurrencyCode The source currency code.    * @param sourceAmount       The source amount.    * @param targetCurrencyCode The target currency code.    * @return The converted indexable units after the exchange rate and currency fraction digits are applied.    */
DECL|method|convertAmount
specifier|public
specifier|static
name|long
name|convertAmount
parameter_list|(
name|double
name|exchangeRate
parameter_list|,
name|String
name|sourceCurrencyCode
parameter_list|,
name|long
name|sourceAmount
parameter_list|,
name|String
name|targetCurrencyCode
parameter_list|)
block|{
if|if
condition|(
name|targetCurrencyCode
operator|.
name|equals
argument_list|(
name|sourceCurrencyCode
argument_list|)
condition|)
block|{
return|return
name|sourceAmount
return|;
block|}
name|int
name|sourceFractionDigits
init|=
name|Currency
operator|.
name|getInstance
argument_list|(
name|sourceCurrencyCode
argument_list|)
operator|.
name|getDefaultFractionDigits
argument_list|()
decl_stmt|;
name|Currency
name|targetCurrency
init|=
name|Currency
operator|.
name|getInstance
argument_list|(
name|targetCurrencyCode
argument_list|)
decl_stmt|;
name|int
name|targetFractionDigits
init|=
name|targetCurrency
operator|.
name|getDefaultFractionDigits
argument_list|()
decl_stmt|;
return|return
name|convertAmount
argument_list|(
name|exchangeRate
argument_list|,
name|sourceFractionDigits
argument_list|,
name|sourceAmount
argument_list|,
name|targetFractionDigits
argument_list|)
return|;
block|}
comment|/**    * Returns a new CurrencyValue that is the conversion of this CurrencyValue to the specified currency.    *    * @param exchangeRates      The exchange rate provider.    * @param targetCurrencyCode The target currency code to convert this CurrencyValue to.    * @return The converted CurrencyValue.    */
DECL|method|convertTo
specifier|public
name|CurrencyValue
name|convertTo
parameter_list|(
name|ExchangeRateProvider
name|exchangeRates
parameter_list|,
name|String
name|targetCurrencyCode
parameter_list|)
block|{
return|return
operator|new
name|CurrencyValue
argument_list|(
name|convertAmount
argument_list|(
name|exchangeRates
argument_list|,
name|this
operator|.
name|getCurrencyCode
argument_list|()
argument_list|,
name|this
operator|.
name|getAmount
argument_list|()
argument_list|,
name|targetCurrencyCode
argument_list|)
argument_list|,
name|targetCurrencyCode
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|String
operator|.
name|valueOf
argument_list|(
name|amount
argument_list|)
operator|+
literal|","
operator|+
name|currencyCode
return|;
block|}
block|}
end_class
end_unit
