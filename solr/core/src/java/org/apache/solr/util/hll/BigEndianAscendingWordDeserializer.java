begin_unit
begin_package
DECL|package|org.apache.solr.util.hll
package|package
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|util
operator|.
name|hll
package|;
end_package
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_comment
comment|/**  * A corresponding deserializer for {@link BigEndianAscendingWordSerializer}.  */
end_comment
begin_class
DECL|class|BigEndianAscendingWordDeserializer
class|class
name|BigEndianAscendingWordDeserializer
implements|implements
name|IWordDeserializer
block|{
comment|// The number of bits per byte.
DECL|field|BITS_PER_BYTE
specifier|private
specifier|static
specifier|final
name|int
name|BITS_PER_BYTE
init|=
literal|8
decl_stmt|;
comment|// long mask for the maximum value stored in a byte
DECL|field|BYTE_MASK
specifier|private
specifier|static
specifier|final
name|long
name|BYTE_MASK
init|=
operator|(
literal|1L
operator|<<
name|BITS_PER_BYTE
operator|)
operator|-
literal|1L
decl_stmt|;
comment|// ************************************************************************
comment|// The length in bits of the words to be read.
DECL|field|wordLength
specifier|private
specifier|final
name|int
name|wordLength
decl_stmt|;
comment|// The byte array to which the words are serialized.
DECL|field|bytes
specifier|private
specifier|final
name|byte
index|[]
name|bytes
decl_stmt|;
comment|// The number of leading padding bytes in 'bytes' to be ignored.
DECL|field|bytePadding
specifier|private
specifier|final
name|int
name|bytePadding
decl_stmt|;
comment|// The number of words that the byte array contains.
DECL|field|wordCount
specifier|private
specifier|final
name|int
name|wordCount
decl_stmt|;
comment|// The current read state.
DECL|field|currentWordIndex
specifier|private
name|int
name|currentWordIndex
decl_stmt|;
comment|// ========================================================================
comment|/**      * @param wordLength the length in bits of the words to be deserialized. Must      *        be less than or equal to 64 and greater than or equal to 1.      * @param bytePadding the number of leading bytes that pad the serialized words.      *        Must be greater than or equal to zero.      * @param bytes the byte array containing the serialized words. Cannot be      *<code>null</code>.      */
DECL|method|BigEndianAscendingWordDeserializer
specifier|public
name|BigEndianAscendingWordDeserializer
parameter_list|(
specifier|final
name|int
name|wordLength
parameter_list|,
specifier|final
name|int
name|bytePadding
parameter_list|,
specifier|final
name|byte
index|[]
name|bytes
parameter_list|)
block|{
if|if
condition|(
operator|(
name|wordLength
operator|<
literal|1
operator|)
operator|||
operator|(
name|wordLength
operator|>
literal|64
operator|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Word length must be>= 1 and<= 64. (was: "
operator|+
name|wordLength
operator|+
literal|")"
argument_list|)
throw|;
block|}
if|if
condition|(
name|bytePadding
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Byte padding must be>= zero. (was: "
operator|+
name|bytePadding
operator|+
literal|")"
argument_list|)
throw|;
block|}
name|this
operator|.
name|wordLength
operator|=
name|wordLength
expr_stmt|;
name|this
operator|.
name|bytes
operator|=
name|bytes
expr_stmt|;
name|this
operator|.
name|bytePadding
operator|=
name|bytePadding
expr_stmt|;
specifier|final
name|int
name|dataBytes
init|=
operator|(
name|bytes
operator|.
name|length
operator|-
name|bytePadding
operator|)
decl_stmt|;
specifier|final
name|long
name|dataBits
init|=
operator|(
name|dataBytes
operator|*
name|BITS_PER_BYTE
operator|)
decl_stmt|;
name|this
operator|.
name|wordCount
operator|=
call|(
name|int
call|)
argument_list|(
name|dataBits
operator|/
name|wordLength
argument_list|)
expr_stmt|;
name|currentWordIndex
operator|=
literal|0
expr_stmt|;
block|}
comment|// ========================================================================
comment|/* (non-Javadoc)      * @see net.agkn.hll.serialization.IWordDeserializer#readWord()      */
annotation|@
name|Override
DECL|method|readWord
specifier|public
name|long
name|readWord
parameter_list|()
block|{
specifier|final
name|long
name|word
init|=
name|readWord
argument_list|(
name|currentWordIndex
argument_list|)
decl_stmt|;
name|currentWordIndex
operator|++
expr_stmt|;
return|return
name|word
return|;
block|}
comment|// ------------------------------------------------------------------------
comment|/**      * Reads the word at the specified sequence position (zero-indexed).      *      * @param  position the zero-indexed position of the word to be read. This      *         must be greater than or equal to zero.      * @return the value of the serialized word at the specified position.      */
DECL|method|readWord
specifier|private
name|long
name|readWord
parameter_list|(
specifier|final
name|int
name|position
parameter_list|)
block|{
if|if
condition|(
name|position
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|ArrayIndexOutOfBoundsException
argument_list|(
name|position
argument_list|)
throw|;
block|}
comment|// First bit of the word
specifier|final
name|long
name|firstBitIndex
init|=
operator|(
name|position
operator|*
name|wordLength
operator|)
decl_stmt|;
specifier|final
name|int
name|firstByteIndex
init|=
operator|(
name|bytePadding
operator|+
call|(
name|int
call|)
argument_list|(
name|firstBitIndex
operator|/
name|BITS_PER_BYTE
argument_list|)
operator|)
decl_stmt|;
specifier|final
name|int
name|firstByteSkipBits
init|=
call|(
name|int
call|)
argument_list|(
name|firstBitIndex
operator|%
name|BITS_PER_BYTE
argument_list|)
decl_stmt|;
comment|// Last bit of the word
specifier|final
name|long
name|lastBitIndex
init|=
operator|(
name|firstBitIndex
operator|+
name|wordLength
operator|-
literal|1
operator|)
decl_stmt|;
specifier|final
name|int
name|lastByteIndex
init|=
operator|(
name|bytePadding
operator|+
call|(
name|int
call|)
argument_list|(
name|lastBitIndex
operator|/
name|BITS_PER_BYTE
argument_list|)
operator|)
decl_stmt|;
specifier|final
name|int
name|lastByteBitsToConsume
decl_stmt|;
specifier|final
name|int
name|bitsAfterByteBoundary
init|=
call|(
name|int
call|)
argument_list|(
operator|(
name|lastBitIndex
operator|+
literal|1
operator|)
operator|%
name|BITS_PER_BYTE
argument_list|)
decl_stmt|;
comment|// If the word terminates at the end of the last byte, consume the whole
comment|// last byte.
if|if
condition|(
name|bitsAfterByteBoundary
operator|==
literal|0
condition|)
block|{
name|lastByteBitsToConsume
operator|=
name|BITS_PER_BYTE
expr_stmt|;
block|}
else|else
block|{
comment|// Otherwise, only consume what is necessary.
name|lastByteBitsToConsume
operator|=
name|bitsAfterByteBoundary
expr_stmt|;
block|}
if|if
condition|(
name|lastByteIndex
operator|>=
name|bytes
operator|.
name|length
condition|)
block|{
throw|throw
operator|new
name|ArrayIndexOutOfBoundsException
argument_list|(
literal|"Word out of bounds of backing array."
argument_list|)
throw|;
block|}
comment|// Accumulator
name|long
name|value
init|=
literal|0
decl_stmt|;
comment|// --------------------------------------------------------------------
comment|// First byte
specifier|final
name|int
name|bitsRemainingInFirstByte
init|=
operator|(
name|BITS_PER_BYTE
operator|-
name|firstByteSkipBits
operator|)
decl_stmt|;
specifier|final
name|int
name|bitsToConsumeInFirstByte
init|=
name|Math
operator|.
name|min
argument_list|(
name|bitsRemainingInFirstByte
argument_list|,
name|wordLength
argument_list|)
decl_stmt|;
name|long
name|firstByte
init|=
operator|(
name|long
operator|)
name|bytes
index|[
name|firstByteIndex
index|]
decl_stmt|;
comment|// Mask off the bits to skip in the first byte.
specifier|final
name|long
name|firstByteMask
init|=
operator|(
operator|(
literal|1L
operator|<<
name|bitsRemainingInFirstByte
operator|)
operator|-
literal|1L
operator|)
decl_stmt|;
name|firstByte
operator|&=
name|firstByteMask
expr_stmt|;
comment|// Right-align relevant bits of first byte.
name|firstByte
operator|>>>=
operator|(
name|bitsRemainingInFirstByte
operator|-
name|bitsToConsumeInFirstByte
operator|)
expr_stmt|;
name|value
operator||=
name|firstByte
expr_stmt|;
comment|// If the first byte contains the whole word, short-circuit.
if|if
condition|(
name|firstByteIndex
operator|==
name|lastByteIndex
condition|)
block|{
return|return
name|value
return|;
block|}
comment|// --------------------------------------------------------------------
comment|// Middle bytes
specifier|final
name|int
name|middleByteCount
init|=
operator|(
name|lastByteIndex
operator|-
name|firstByteIndex
operator|-
literal|1
operator|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|middleByteCount
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|long
name|middleByte
init|=
operator|(
name|bytes
index|[
name|firstByteIndex
operator|+
name|i
operator|+
literal|1
index|]
operator|&
name|BYTE_MASK
operator|)
decl_stmt|;
comment|// Push middle byte onto accumulator.
name|value
operator|<<=
name|BITS_PER_BYTE
expr_stmt|;
name|value
operator||=
name|middleByte
expr_stmt|;
block|}
comment|// --------------------------------------------------------------------
comment|// Last byte
name|long
name|lastByte
init|=
operator|(
name|bytes
index|[
name|lastByteIndex
index|]
operator|&
name|BYTE_MASK
operator|)
decl_stmt|;
name|lastByte
operator|>>=
operator|(
name|BITS_PER_BYTE
operator|-
name|lastByteBitsToConsume
operator|)
expr_stmt|;
name|value
operator|<<=
name|lastByteBitsToConsume
expr_stmt|;
name|value
operator||=
name|lastByte
expr_stmt|;
return|return
name|value
return|;
block|}
comment|/* (non-Javadoc)      * @see net.agkn.hll.serialization.IWordDeserializer#totalWordCount()      */
annotation|@
name|Override
DECL|method|totalWordCount
specifier|public
name|int
name|totalWordCount
parameter_list|()
block|{
return|return
name|wordCount
return|;
block|}
block|}
end_class
end_unit
