begin_unit
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_package
DECL|package|org.apache.solr.util.hll
package|package
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|util
operator|.
name|hll
package|;
end_package
begin_comment
comment|/**  * A vector (array) of bits that is accessed in units ("registers") of<code>width</code>  * bits which are stored as 64bit "words" (<code>long</code>s).  In this context  * a register is at most 64bits.  */
end_comment
begin_class
DECL|class|BitVector
class|class
name|BitVector
implements|implements
name|Cloneable
block|{
comment|// NOTE:  in this context, a word is 64bits
comment|// rather than doing division to determine how a bit index fits into 64bit
comment|// words (i.e. longs), bit shifting is used
DECL|field|LOG2_BITS_PER_WORD
specifier|private
specifier|static
specifier|final
name|int
name|LOG2_BITS_PER_WORD
init|=
literal|6
comment|/*=>64bits*/
decl_stmt|;
DECL|field|BITS_PER_WORD
specifier|private
specifier|static
specifier|final
name|int
name|BITS_PER_WORD
init|=
literal|1
operator|<<
name|LOG2_BITS_PER_WORD
decl_stmt|;
DECL|field|BITS_PER_WORD_MASK
specifier|private
specifier|static
specifier|final
name|int
name|BITS_PER_WORD_MASK
init|=
name|BITS_PER_WORD
operator|-
literal|1
decl_stmt|;
comment|// ditto from above but for bytes (for output)
DECL|field|LOG2_BITS_PER_BYTE
specifier|private
specifier|static
specifier|final
name|int
name|LOG2_BITS_PER_BYTE
init|=
literal|3
comment|/*=>8bits*/
decl_stmt|;
DECL|field|BITS_PER_BYTE
specifier|public
specifier|static
specifier|final
name|int
name|BITS_PER_BYTE
init|=
literal|1
operator|<<
name|LOG2_BITS_PER_BYTE
decl_stmt|;
comment|// ========================================================================
DECL|field|BYTES_PER_WORD
specifier|public
specifier|static
specifier|final
name|int
name|BYTES_PER_WORD
init|=
literal|8
comment|/*8 bytes in a long*/
decl_stmt|;
comment|// ************************************************************************
comment|// 64bit words
DECL|field|words
specifier|private
specifier|final
name|long
index|[]
name|words
decl_stmt|;
DECL|method|words
specifier|public
specifier|final
name|long
index|[]
name|words
parameter_list|()
block|{
return|return
name|words
return|;
block|}
DECL|method|wordCount
specifier|public
specifier|final
name|int
name|wordCount
parameter_list|()
block|{
return|return
name|words
operator|.
name|length
return|;
block|}
DECL|method|byteCount
specifier|public
specifier|final
name|int
name|byteCount
parameter_list|()
block|{
return|return
name|wordCount
argument_list|()
operator|*
name|BYTES_PER_WORD
return|;
block|}
comment|// the width of a register in bits (this cannot be more than 64 (the word size))
DECL|field|registerWidth
specifier|private
specifier|final
name|int
name|registerWidth
decl_stmt|;
DECL|method|registerWidth
specifier|public
specifier|final
name|int
name|registerWidth
parameter_list|()
block|{
return|return
name|registerWidth
return|;
block|}
DECL|field|count
specifier|private
specifier|final
name|long
name|count
decl_stmt|;
comment|// ------------------------------------------------------------------------
DECL|field|registerMask
specifier|private
specifier|final
name|long
name|registerMask
decl_stmt|;
comment|// ========================================================================
comment|/**      * @param  width the width of each register.  This cannot be negative or      *         zero or greater than 63 (the signed word size).      * @param  count the number of registers.  This cannot be negative or zero      */
DECL|method|BitVector
specifier|public
name|BitVector
parameter_list|(
specifier|final
name|int
name|width
parameter_list|,
specifier|final
name|long
name|count
parameter_list|)
block|{
comment|// ceil((width * count)/BITS_PER_WORD)
name|this
operator|.
name|words
operator|=
operator|new
name|long
index|[
call|(
name|int
call|)
argument_list|(
operator|(
operator|(
name|width
operator|*
name|count
operator|)
operator|+
name|BITS_PER_WORD_MASK
operator|)
operator|>>>
name|LOG2_BITS_PER_WORD
argument_list|)
index|]
expr_stmt|;
name|this
operator|.
name|registerWidth
operator|=
name|width
expr_stmt|;
name|this
operator|.
name|count
operator|=
name|count
expr_stmt|;
name|this
operator|.
name|registerMask
operator|=
operator|(
literal|1L
operator|<<
name|width
operator|)
operator|-
literal|1
expr_stmt|;
block|}
comment|// ========================================================================
comment|/**      * @param  registerIndex the index of the register whose value is to be      *         retrieved.  This cannot be negative.      * @return the value at the specified register index      * @see #setRegister(long, long)      * @see #setMaxRegister(long, long)      */
comment|// NOTE:  if this changes then setMaxRegister() must change
DECL|method|getRegister
specifier|public
name|long
name|getRegister
parameter_list|(
specifier|final
name|long
name|registerIndex
parameter_list|)
block|{
specifier|final
name|long
name|bitIndex
init|=
name|registerIndex
operator|*
name|registerWidth
decl_stmt|;
specifier|final
name|int
name|firstWordIndex
init|=
call|(
name|int
call|)
argument_list|(
name|bitIndex
operator|>>>
name|LOG2_BITS_PER_WORD
argument_list|)
comment|/*aka (bitIndex / BITS_PER_WORD)*/
decl_stmt|;
specifier|final
name|int
name|secondWordIndex
init|=
call|(
name|int
call|)
argument_list|(
operator|(
name|bitIndex
operator|+
name|registerWidth
operator|-
literal|1
operator|)
operator|>>>
name|LOG2_BITS_PER_WORD
argument_list|)
comment|/*see above*/
decl_stmt|;
specifier|final
name|int
name|bitRemainder
init|=
call|(
name|int
call|)
argument_list|(
name|bitIndex
operator|&
name|BITS_PER_WORD_MASK
argument_list|)
comment|/*aka (bitIndex % BITS_PER_WORD)*/
decl_stmt|;
if|if
condition|(
name|firstWordIndex
operator|==
name|secondWordIndex
condition|)
return|return
operator|(
operator|(
name|words
index|[
name|firstWordIndex
index|]
operator|>>>
name|bitRemainder
operator|)
operator|&
name|registerMask
operator|)
return|;
comment|/* else -- register spans words */
return|return
operator|(
name|words
index|[
name|firstWordIndex
index|]
operator|>>>
name|bitRemainder
operator|)
comment|/*no need to mask since at top of word*/
operator||
operator|(
name|words
index|[
name|secondWordIndex
index|]
operator|<<
operator|(
name|BITS_PER_WORD
operator|-
name|bitRemainder
operator|)
operator|)
operator|&
name|registerMask
return|;
block|}
comment|/**      * @param registerIndex the index of the register whose value is to be set.      *        This cannot be negative      * @param value the value to set in the register      * @see #getRegister(long)      * @see #setMaxRegister(long, long)      */
comment|// NOTE:  if this changes then setMaxRegister() must change
DECL|method|setRegister
specifier|public
name|void
name|setRegister
parameter_list|(
specifier|final
name|long
name|registerIndex
parameter_list|,
specifier|final
name|long
name|value
parameter_list|)
block|{
specifier|final
name|long
name|bitIndex
init|=
name|registerIndex
operator|*
name|registerWidth
decl_stmt|;
specifier|final
name|int
name|firstWordIndex
init|=
call|(
name|int
call|)
argument_list|(
name|bitIndex
operator|>>>
name|LOG2_BITS_PER_WORD
argument_list|)
comment|/*aka (bitIndex / BITS_PER_WORD)*/
decl_stmt|;
specifier|final
name|int
name|secondWordIndex
init|=
call|(
name|int
call|)
argument_list|(
operator|(
name|bitIndex
operator|+
name|registerWidth
operator|-
literal|1
operator|)
operator|>>>
name|LOG2_BITS_PER_WORD
argument_list|)
comment|/*see above*/
decl_stmt|;
specifier|final
name|int
name|bitRemainder
init|=
call|(
name|int
call|)
argument_list|(
name|bitIndex
operator|&
name|BITS_PER_WORD_MASK
argument_list|)
comment|/*aka (bitIndex % BITS_PER_WORD)*/
decl_stmt|;
specifier|final
name|long
name|words
index|[]
init|=
name|this
operator|.
name|words
comment|/*for convenience/performance*/
decl_stmt|;
if|if
condition|(
name|firstWordIndex
operator|==
name|secondWordIndex
condition|)
block|{
comment|// clear then set
name|words
index|[
name|firstWordIndex
index|]
operator|&=
operator|~
operator|(
name|registerMask
operator|<<
name|bitRemainder
operator|)
expr_stmt|;
name|words
index|[
name|firstWordIndex
index|]
operator||=
operator|(
name|value
operator|<<
name|bitRemainder
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/*register spans words*/
comment|// clear then set each partial word
name|words
index|[
name|firstWordIndex
index|]
operator|&=
operator|(
literal|1L
operator|<<
name|bitRemainder
operator|)
operator|-
literal|1
expr_stmt|;
name|words
index|[
name|firstWordIndex
index|]
operator||=
operator|(
name|value
operator|<<
name|bitRemainder
operator|)
expr_stmt|;
name|words
index|[
name|secondWordIndex
index|]
operator|&=
operator|~
operator|(
name|registerMask
operator|>>>
operator|(
name|BITS_PER_WORD
operator|-
name|bitRemainder
operator|)
operator|)
expr_stmt|;
name|words
index|[
name|secondWordIndex
index|]
operator||=
operator|(
name|value
operator|>>>
operator|(
name|BITS_PER_WORD
operator|-
name|bitRemainder
operator|)
operator|)
expr_stmt|;
block|}
block|}
comment|// ------------------------------------------------------------------------
comment|/**      * @return a<code>LongIterator</code> for iterating starting at the register      *         with index zero. This will never be<code>null</code>.      */
DECL|method|registerIterator
specifier|public
name|LongIterator
name|registerIterator
parameter_list|()
block|{
return|return
operator|new
name|LongIterator
argument_list|()
block|{
specifier|final
name|int
name|registerWidth
init|=
name|BitVector
operator|.
name|this
operator|.
name|registerWidth
decl_stmt|;
specifier|final
name|long
index|[]
name|words
init|=
name|BitVector
operator|.
name|this
operator|.
name|words
decl_stmt|;
specifier|final
name|long
name|registerMask
init|=
name|BitVector
operator|.
name|this
operator|.
name|registerMask
decl_stmt|;
comment|// register setup
name|long
name|registerIndex
init|=
literal|0
decl_stmt|;
name|int
name|wordIndex
init|=
literal|0
decl_stmt|;
name|int
name|remainingWordBits
init|=
name|BITS_PER_WORD
decl_stmt|;
name|long
name|word
init|=
name|words
index|[
name|wordIndex
index|]
decl_stmt|;
annotation|@
name|Override
specifier|public
name|long
name|next
parameter_list|()
block|{
name|long
name|register
decl_stmt|;
if|if
condition|(
name|remainingWordBits
operator|>=
name|registerWidth
condition|)
block|{
name|register
operator|=
name|word
operator|&
name|registerMask
expr_stmt|;
comment|// shift to the next register
name|word
operator|>>>=
name|registerWidth
expr_stmt|;
name|remainingWordBits
operator|-=
name|registerWidth
expr_stmt|;
block|}
else|else
block|{
comment|/*insufficient bits remaining in current word*/
name|wordIndex
operator|++
comment|/*move to the next word*/
expr_stmt|;
name|register
operator|=
operator|(
name|word
operator||
operator|(
name|words
index|[
name|wordIndex
index|]
operator|<<
name|remainingWordBits
operator|)
operator|)
operator|&
name|registerMask
expr_stmt|;
comment|// shift to the next partial register (word)
name|word
operator|=
name|words
index|[
name|wordIndex
index|]
operator|>>>
operator|(
name|registerWidth
operator|-
name|remainingWordBits
operator|)
expr_stmt|;
name|remainingWordBits
operator|+=
name|BITS_PER_WORD
operator|-
name|registerWidth
expr_stmt|;
block|}
name|registerIndex
operator|++
expr_stmt|;
return|return
name|register
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
return|return
name|registerIndex
operator|<
name|count
return|;
block|}
block|}
return|;
block|}
comment|// ------------------------------------------------------------------------
comment|// composite accessors
comment|/**      * Sets the value of the specified index register if and only if the specified      * value is greater than the current value in the register.  This is equivalent      * to but much more performant than:<p/>      *      *<pre>vector.setRegister(index, Math.max(vector.getRegister(index), value));</pre>      *      * @param  registerIndex the index of the register whose value is to be set.      *         This cannot be negative      * @param  value the value to set in the register if and only if this value      *         is greater than the current value in the register      * @return<code>true</code> if and only if the specified value is greater      *         than or equal to the current register value.<code>false</code>      *         otherwise.      * @see #getRegister(long)      * @see #setRegister(long, long)      * @see java.lang.Math#max(long, long)      */
comment|// NOTE:  if this changes then setRegister() must change
DECL|method|setMaxRegister
specifier|public
name|boolean
name|setMaxRegister
parameter_list|(
specifier|final
name|long
name|registerIndex
parameter_list|,
specifier|final
name|long
name|value
parameter_list|)
block|{
specifier|final
name|long
name|bitIndex
init|=
name|registerIndex
operator|*
name|registerWidth
decl_stmt|;
specifier|final
name|int
name|firstWordIndex
init|=
call|(
name|int
call|)
argument_list|(
name|bitIndex
operator|>>>
name|LOG2_BITS_PER_WORD
argument_list|)
comment|/*aka (bitIndex / BITS_PER_WORD)*/
decl_stmt|;
specifier|final
name|int
name|secondWordIndex
init|=
call|(
name|int
call|)
argument_list|(
operator|(
name|bitIndex
operator|+
name|registerWidth
operator|-
literal|1
operator|)
operator|>>>
name|LOG2_BITS_PER_WORD
argument_list|)
comment|/*see above*/
decl_stmt|;
specifier|final
name|int
name|bitRemainder
init|=
call|(
name|int
call|)
argument_list|(
name|bitIndex
operator|&
name|BITS_PER_WORD_MASK
argument_list|)
comment|/*aka (bitIndex % BITS_PER_WORD)*/
decl_stmt|;
comment|// NOTE:  matches getRegister()
specifier|final
name|long
name|registerValue
decl_stmt|;
specifier|final
name|long
name|words
index|[]
init|=
name|this
operator|.
name|words
comment|/*for convenience/performance*/
decl_stmt|;
if|if
condition|(
name|firstWordIndex
operator|==
name|secondWordIndex
condition|)
name|registerValue
operator|=
operator|(
operator|(
name|words
index|[
name|firstWordIndex
index|]
operator|>>>
name|bitRemainder
operator|)
operator|&
name|registerMask
operator|)
expr_stmt|;
else|else
comment|/*register spans words*/
name|registerValue
operator|=
operator|(
name|words
index|[
name|firstWordIndex
index|]
operator|>>>
name|bitRemainder
operator|)
comment|/*no need to mask since at top of word*/
operator||
operator|(
name|words
index|[
name|secondWordIndex
index|]
operator|<<
operator|(
name|BITS_PER_WORD
operator|-
name|bitRemainder
operator|)
operator|)
operator|&
name|registerMask
expr_stmt|;
comment|// determine which is the larger and update as necessary
if|if
condition|(
name|value
operator|>
name|registerValue
condition|)
block|{
comment|// NOTE:  matches setRegister()
if|if
condition|(
name|firstWordIndex
operator|==
name|secondWordIndex
condition|)
block|{
comment|// clear then set
name|words
index|[
name|firstWordIndex
index|]
operator|&=
operator|~
operator|(
name|registerMask
operator|<<
name|bitRemainder
operator|)
expr_stmt|;
name|words
index|[
name|firstWordIndex
index|]
operator||=
operator|(
name|value
operator|<<
name|bitRemainder
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/*register spans words*/
comment|// clear then set each partial word
name|words
index|[
name|firstWordIndex
index|]
operator|&=
operator|(
literal|1L
operator|<<
name|bitRemainder
operator|)
operator|-
literal|1
expr_stmt|;
name|words
index|[
name|firstWordIndex
index|]
operator||=
operator|(
name|value
operator|<<
name|bitRemainder
operator|)
expr_stmt|;
name|words
index|[
name|secondWordIndex
index|]
operator|&=
operator|~
operator|(
name|registerMask
operator|>>>
operator|(
name|BITS_PER_WORD
operator|-
name|bitRemainder
operator|)
operator|)
expr_stmt|;
name|words
index|[
name|secondWordIndex
index|]
operator||=
operator|(
name|value
operator|>>>
operator|(
name|BITS_PER_WORD
operator|-
name|bitRemainder
operator|)
operator|)
expr_stmt|;
block|}
block|}
comment|/* else -- the register value is greater (or equal) so nothing needs to be done */
return|return
operator|(
name|value
operator|>=
name|registerValue
operator|)
return|;
block|}
comment|// ========================================================================
comment|/**      * Fills this bit vector with the specified bit value.  This can be used to      * clear the vector by specifying<code>0</code>.      *      * @param  value the value to set all bits to (only the lowest bit is used)      */
DECL|method|fill
specifier|public
name|void
name|fill
parameter_list|(
specifier|final
name|long
name|value
parameter_list|)
block|{
for|for
control|(
name|long
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|setRegister
argument_list|(
name|i
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
block|}
comment|// ------------------------------------------------------------------------
comment|/**      * Serializes the registers of the vector using the specified serializer.      *      * @param serializer the serializer to use. This cannot be<code>null</code>.      */
DECL|method|getRegisterContents
specifier|public
name|void
name|getRegisterContents
parameter_list|(
specifier|final
name|IWordSerializer
name|serializer
parameter_list|)
block|{
for|for
control|(
specifier|final
name|LongIterator
name|iter
init|=
name|registerIterator
argument_list|()
init|;
name|iter
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|serializer
operator|.
name|writeWord
argument_list|(
name|iter
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Creates a deep copy of this vector.      *      * @see java.lang.Object#clone()      */
annotation|@
name|Override
DECL|method|clone
specifier|public
name|BitVector
name|clone
parameter_list|()
block|{
specifier|final
name|BitVector
name|copy
init|=
operator|new
name|BitVector
argument_list|(
name|registerWidth
argument_list|,
name|count
argument_list|)
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|words
argument_list|,
literal|0
argument_list|,
name|copy
operator|.
name|words
argument_list|,
literal|0
argument_list|,
name|words
operator|.
name|length
argument_list|)
expr_stmt|;
return|return
name|copy
return|;
block|}
block|}
end_class
end_unit
