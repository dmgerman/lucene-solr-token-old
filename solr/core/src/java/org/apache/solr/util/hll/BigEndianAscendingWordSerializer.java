begin_unit
begin_package
DECL|package|org.apache.solr.util.hll
package|package
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|util
operator|.
name|hll
package|;
end_package
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_comment
comment|/**  * A serializer that writes a sequence of fixed bit-width 'words' to a byte array.  * Bitwise OR is used to write words into bytes, so a low bit in a word is also  * a low bit in a byte. However, a high byte in a word is written at a lower index  * in the array than a low byte in a word. The first word is written at the lowest  * array index. Each serializer is one time use and returns its backing byte  * array.<p/>  *  * This encoding was chosen so that when reading bytes as octets in the typical  * first-octet-is-the-high-nibble fashion, an octet-to-binary conversion  * would yield a high-to-low, left-to-right view of the "short words".<p/>  *  * Example:<p/>  *  * Say short words are 5 bits wide. Our word sequence is the values  *<code>[31, 1, 5]</code>. In big-endian binary format, the values are  *<code>[0b11111, 0b00001, 0b00101]</code>. We use 15 of 16 bits in two bytes  * and pad the last (lowest) bit of the last byte with a zero:  *  *<code>  *  [0b11111000, 0b01001010] = [0xF8, 0x4A]  *</code>.  */
end_comment
begin_class
DECL|class|BigEndianAscendingWordSerializer
class|class
name|BigEndianAscendingWordSerializer
implements|implements
name|IWordSerializer
block|{
comment|// The number of bits per byte.
DECL|field|BITS_PER_BYTE
specifier|private
specifier|static
specifier|final
name|int
name|BITS_PER_BYTE
init|=
literal|8
decl_stmt|;
comment|// ************************************************************************
comment|// The length in bits of the words to be written.
DECL|field|wordLength
specifier|private
specifier|final
name|int
name|wordLength
decl_stmt|;
comment|// The number of words to be written.
DECL|field|wordCount
specifier|private
specifier|final
name|int
name|wordCount
decl_stmt|;
comment|// The byte array to which the words are serialized.
DECL|field|bytes
specifier|private
specifier|final
name|byte
index|[]
name|bytes
decl_stmt|;
comment|// ------------------------------------------------------------------------
comment|// Write state
comment|// Number of bits that remain writable in the current byte.
DECL|field|bitsLeftInByte
specifier|private
name|int
name|bitsLeftInByte
decl_stmt|;
comment|// Index of byte currently being written to.
DECL|field|byteIndex
specifier|private
name|int
name|byteIndex
decl_stmt|;
comment|// Number of words written.
DECL|field|wordsWritten
specifier|private
name|int
name|wordsWritten
decl_stmt|;
comment|// ========================================================================
comment|/**      * @param wordLength the length in bits of the words to be serialized. Must      *        be greater than or equal to 1 and less than or equal to 64.      * @param wordCount the number of words to be serialized. Must be greater than      *        or equal to zero.      * @param bytePadding the number of leading bytes that should pad the      *        serialized words. Must be greater than or equal to zero.      */
DECL|method|BigEndianAscendingWordSerializer
specifier|public
name|BigEndianAscendingWordSerializer
parameter_list|(
specifier|final
name|int
name|wordLength
parameter_list|,
specifier|final
name|int
name|wordCount
parameter_list|,
specifier|final
name|int
name|bytePadding
parameter_list|)
block|{
if|if
condition|(
operator|(
name|wordLength
operator|<
literal|1
operator|)
operator|||
operator|(
name|wordLength
operator|>
literal|64
operator|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Word length must be>= 1 and<= 64. (was: "
operator|+
name|wordLength
operator|+
literal|")"
argument_list|)
throw|;
block|}
if|if
condition|(
name|wordCount
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Word count must be>= 0. (was: "
operator|+
name|wordCount
operator|+
literal|")"
argument_list|)
throw|;
block|}
if|if
condition|(
name|bytePadding
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Byte padding must be must be>= 0. (was: "
operator|+
name|bytePadding
operator|+
literal|")"
argument_list|)
throw|;
block|}
name|this
operator|.
name|wordLength
operator|=
name|wordLength
expr_stmt|;
name|this
operator|.
name|wordCount
operator|=
name|wordCount
expr_stmt|;
specifier|final
name|long
name|bitsRequired
init|=
operator|(
operator|(
name|long
operator|)
name|wordLength
operator|)
operator|*
operator|(
operator|(
name|long
operator|)
name|wordCount
operator|)
decl_stmt|;
specifier|final
name|boolean
name|leftoverBits
init|=
operator|(
operator|(
name|bitsRequired
operator|%
name|BITS_PER_BYTE
operator|)
operator|!=
literal|0
operator|)
decl_stmt|;
specifier|final
name|int
name|bytesRequired
init|=
call|(
name|int
call|)
argument_list|(
name|bitsRequired
operator|/
name|BITS_PER_BYTE
argument_list|)
operator|+
operator|(
name|leftoverBits
condition|?
literal|1
else|:
literal|0
operator|)
operator|+
name|bytePadding
decl_stmt|;
name|bytes
operator|=
operator|new
name|byte
index|[
name|bytesRequired
index|]
expr_stmt|;
name|bitsLeftInByte
operator|=
name|BITS_PER_BYTE
expr_stmt|;
name|byteIndex
operator|=
name|bytePadding
expr_stmt|;
name|wordsWritten
operator|=
literal|0
expr_stmt|;
block|}
comment|/* (non-Javadoc)      * @see net.agkn.hll.serialization.IWordSerializer#writeWord(long)      * @throws RuntimeException if the number of words written is greater than the      *<code>wordCount</code> parameter in the constructor.      */
annotation|@
name|Override
DECL|method|writeWord
specifier|public
name|void
name|writeWord
parameter_list|(
specifier|final
name|long
name|word
parameter_list|)
block|{
if|if
condition|(
name|wordsWritten
operator|==
name|wordCount
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Cannot write more words, backing array full!"
argument_list|)
throw|;
block|}
name|int
name|bitsLeftInWord
init|=
name|wordLength
decl_stmt|;
while|while
condition|(
name|bitsLeftInWord
operator|>
literal|0
condition|)
block|{
comment|// Move to the next byte if the current one is fully packed.
if|if
condition|(
name|bitsLeftInByte
operator|==
literal|0
condition|)
block|{
name|byteIndex
operator|++
expr_stmt|;
name|bitsLeftInByte
operator|=
name|BITS_PER_BYTE
expr_stmt|;
block|}
specifier|final
name|long
name|consumedMask
decl_stmt|;
if|if
condition|(
name|bitsLeftInWord
operator|==
literal|64
condition|)
block|{
name|consumedMask
operator|=
operator|~
literal|0L
expr_stmt|;
block|}
else|else
block|{
name|consumedMask
operator|=
operator|(
operator|(
literal|1L
operator|<<
name|bitsLeftInWord
operator|)
operator|-
literal|1L
operator|)
expr_stmt|;
block|}
comment|// Fix how many bits will be written in this cycle. Choose the
comment|// smaller of the remaining bits in the word or byte.
specifier|final
name|int
name|numberOfBitsToWrite
init|=
name|Math
operator|.
name|min
argument_list|(
name|bitsLeftInByte
argument_list|,
name|bitsLeftInWord
argument_list|)
decl_stmt|;
specifier|final
name|int
name|bitsInByteRemainingAfterWrite
init|=
operator|(
name|bitsLeftInByte
operator|-
name|numberOfBitsToWrite
operator|)
decl_stmt|;
comment|// In general, we write the highest bits of the word first, so we
comment|// strip the highest bits that were consumed in previous cycles.
specifier|final
name|long
name|remainingBitsOfWordToWrite
init|=
operator|(
name|word
operator|&
name|consumedMask
operator|)
decl_stmt|;
specifier|final
name|long
name|bitsThatTheByteCanAccept
decl_stmt|;
comment|// If there is more left in the word than can be written to this
comment|// byte, shift off the bits that can't be written off the bottom.
if|if
condition|(
name|bitsLeftInWord
operator|>
name|numberOfBitsToWrite
condition|)
block|{
name|bitsThatTheByteCanAccept
operator|=
operator|(
name|remainingBitsOfWordToWrite
operator|>>>
operator|(
name|bitsLeftInWord
operator|-
name|bitsLeftInByte
operator|)
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|// If the byte can accept all remaining bits, there is no need
comment|// to shift off the bits that won't be written in this cycle.
name|bitsThatTheByteCanAccept
operator|=
name|remainingBitsOfWordToWrite
expr_stmt|;
block|}
comment|// Align the word bits to write up against the byte bits that have
comment|// already been written. This shift may do nothing if the remainder
comment|// of the byte is being consumed in this cycle.
specifier|final
name|long
name|alignedBits
init|=
operator|(
name|bitsThatTheByteCanAccept
operator|<<
name|bitsInByteRemainingAfterWrite
operator|)
decl_stmt|;
comment|// Update the byte with the alignedBits.
name|bytes
index|[
name|byteIndex
index|]
operator||=
operator|(
name|byte
operator|)
name|alignedBits
expr_stmt|;
comment|// Update state with bit count written.
name|bitsLeftInWord
operator|-=
name|numberOfBitsToWrite
expr_stmt|;
name|bitsLeftInByte
operator|=
name|bitsInByteRemainingAfterWrite
expr_stmt|;
block|}
name|wordsWritten
operator|++
expr_stmt|;
block|}
comment|/* (non-Javadoc)      * @see net.agkn.hll.serialization.IWordSerializer#getBytes()      * @throws RuntimeException if the number of words written is fewer than the      *<code>wordCount</code> parameter in the constructor.      */
annotation|@
name|Override
DECL|method|getBytes
specifier|public
name|byte
index|[]
name|getBytes
parameter_list|()
block|{
if|if
condition|(
name|wordsWritten
operator|<
name|wordCount
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Not all words have been written! ("
operator|+
name|wordsWritten
operator|+
literal|"/"
operator|+
name|wordCount
operator|+
literal|")"
argument_list|)
throw|;
block|}
return|return
name|bytes
return|;
block|}
block|}
end_class
end_unit
