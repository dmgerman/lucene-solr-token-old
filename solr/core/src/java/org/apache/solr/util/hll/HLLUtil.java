begin_unit
begin_package
DECL|package|org.apache.solr.util.hll
package|package
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|util
operator|.
name|hll
package|;
end_package
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_comment
comment|/**  * Static functions for computing constants and parameters used in the HLL  * algorithm.  */
end_comment
begin_class
DECL|class|HLLUtil
specifier|final
class|class
name|HLLUtil
block|{
comment|/**      * Precomputed<code>pwMaxMask</code> values indexed by<code>registerSizeInBits</code>.      * Calculated with this formula:      *<pre>      *     int maxRegisterValue = (1<< registerSizeInBits) - 1;      *     // Mask with all bits set except for (maxRegisterValue - 1) least significant bits (see #addRaw())      *     return ~((1L<< (maxRegisterValue - 1)) - 1);      *</pre>      *      * @see #pwMaxMask(int)      */
DECL|field|PW_MASK
specifier|private
specifier|static
specifier|final
name|long
index|[]
name|PW_MASK
init|=
block|{
operator|~
operator|(
operator|(
literal|1L
operator|<<
operator|(
operator|(
operator|(
literal|1
operator|<<
literal|0
operator|)
operator|-
literal|1
operator|)
operator|-
literal|1
operator|)
operator|)
operator|-
literal|1
operator|)
block|,
operator|~
operator|(
operator|(
literal|1L
operator|<<
operator|(
operator|(
operator|(
literal|1
operator|<<
literal|1
operator|)
operator|-
literal|1
operator|)
operator|-
literal|1
operator|)
operator|)
operator|-
literal|1
operator|)
block|,
operator|~
operator|(
operator|(
literal|1L
operator|<<
operator|(
operator|(
operator|(
literal|1
operator|<<
literal|2
operator|)
operator|-
literal|1
operator|)
operator|-
literal|1
operator|)
operator|)
operator|-
literal|1
operator|)
block|,
operator|~
operator|(
operator|(
literal|1L
operator|<<
operator|(
operator|(
operator|(
literal|1
operator|<<
literal|3
operator|)
operator|-
literal|1
operator|)
operator|-
literal|1
operator|)
operator|)
operator|-
literal|1
operator|)
block|,
operator|~
operator|(
operator|(
literal|1L
operator|<<
operator|(
operator|(
operator|(
literal|1
operator|<<
literal|4
operator|)
operator|-
literal|1
operator|)
operator|-
literal|1
operator|)
operator|)
operator|-
literal|1
operator|)
block|,
operator|~
operator|(
operator|(
literal|1L
operator|<<
operator|(
operator|(
operator|(
literal|1
operator|<<
literal|5
operator|)
operator|-
literal|1
operator|)
operator|-
literal|1
operator|)
operator|)
operator|-
literal|1
operator|)
block|,
operator|~
operator|(
operator|(
literal|1L
operator|<<
operator|(
operator|(
operator|(
literal|1
operator|<<
literal|6
operator|)
operator|-
literal|1
operator|)
operator|-
literal|1
operator|)
operator|)
operator|-
literal|1
operator|)
block|,
operator|~
operator|(
operator|(
literal|1L
operator|<<
operator|(
operator|(
operator|(
literal|1
operator|<<
literal|7
operator|)
operator|-
literal|1
operator|)
operator|-
literal|1
operator|)
operator|)
operator|-
literal|1
operator|)
block|,
operator|~
operator|(
operator|(
literal|1L
operator|<<
operator|(
operator|(
operator|(
literal|1
operator|<<
literal|8
operator|)
operator|-
literal|1
operator|)
operator|-
literal|1
operator|)
operator|)
operator|-
literal|1
operator|)
block|}
decl_stmt|;
comment|/**      * Precomputed<code>twoToL</code> values indexed by a linear combination of      *<code>regWidth</code> and<code>log2m</code>.      *      * The array is one-dimensional and can be accessed by using index      *<code>(REG_WIDTH_INDEX_MULTIPLIER * regWidth) + log2m</code>      * for<code>regWidth</code> and<code>log2m</code> between the specified      *<code>HLL.{MINIMUM,MAXIMUM}_{REGWIDTH,LOG2M}_PARAM</code> constants.      *      * @see #largeEstimator(int, int, double)      * @see #largeEstimatorCutoff(int, int)      * @see "<a href='http://research.neustar.biz/2013/01/24/hyperloglog-googles-take-on-engineering-hll/'>Blog post with section on 2^L</a>"      */
DECL|field|TWO_TO_L
specifier|private
specifier|static
specifier|final
name|double
index|[]
name|TWO_TO_L
init|=
operator|new
name|double
index|[
operator|(
name|HLL
operator|.
name|MAXIMUM_REGWIDTH_PARAM
operator|+
literal|1
operator|)
operator|*
operator|(
name|HLL
operator|.
name|MAXIMUM_LOG2M_PARAM
operator|+
literal|1
operator|)
index|]
decl_stmt|;
comment|/**      * Spacing constant used to compute offsets into {@link #TWO_TO_L}.      */
DECL|field|REG_WIDTH_INDEX_MULTIPLIER
specifier|private
specifier|static
specifier|final
name|int
name|REG_WIDTH_INDEX_MULTIPLIER
init|=
name|HLL
operator|.
name|MAXIMUM_LOG2M_PARAM
operator|+
literal|1
decl_stmt|;
static|static
block|{
for|for
control|(
name|int
name|regWidth
init|=
name|HLL
operator|.
name|MINIMUM_REGWIDTH_PARAM
init|;
name|regWidth
operator|<=
name|HLL
operator|.
name|MAXIMUM_REGWIDTH_PARAM
condition|;
name|regWidth
operator|++
control|)
block|{
for|for
control|(
name|int
name|log2m
init|=
name|HLL
operator|.
name|MINIMUM_LOG2M_PARAM
init|;
name|log2m
operator|<=
name|HLL
operator|.
name|MAXIMUM_LOG2M_PARAM
condition|;
name|log2m
operator|++
control|)
block|{
name|int
name|maxRegisterValue
init|=
operator|(
literal|1
operator|<<
name|regWidth
operator|)
operator|-
literal|1
decl_stmt|;
comment|// Since 1 is added to p(w) in the insertion algorithm, only
comment|// (maxRegisterValue - 1) bits are inspected hence the hash
comment|// space is one power of two smaller.
specifier|final
name|int
name|pwBits
init|=
operator|(
name|maxRegisterValue
operator|-
literal|1
operator|)
decl_stmt|;
specifier|final
name|int
name|totalBits
init|=
operator|(
name|pwBits
operator|+
name|log2m
operator|)
decl_stmt|;
specifier|final
name|double
name|twoToL
init|=
name|Math
operator|.
name|pow
argument_list|(
literal|2
argument_list|,
name|totalBits
argument_list|)
decl_stmt|;
name|TWO_TO_L
index|[
operator|(
name|REG_WIDTH_INDEX_MULTIPLIER
operator|*
name|regWidth
operator|)
operator|+
name|log2m
index|]
operator|=
name|twoToL
expr_stmt|;
block|}
block|}
block|}
comment|// ************************************************************************
comment|/**      * Computes the bit-width of HLL registers necessary to estimate a set of      * the specified cardinality.      *      * @param  expectedUniqueElements an upper bound on the number of unique      *         elements that are expected.  This must be greater than zero.      * @return a register size in bits (i.e.<code>log2(log2(n))</code>)      */
DECL|method|registerBitSize
specifier|public
specifier|static
name|int
name|registerBitSize
parameter_list|(
specifier|final
name|long
name|expectedUniqueElements
parameter_list|)
block|{
return|return
name|Math
operator|.
name|max
argument_list|(
name|HLL
operator|.
name|MINIMUM_REGWIDTH_PARAM
argument_list|,
operator|(
name|int
operator|)
name|Math
operator|.
name|ceil
argument_list|(
name|NumberUtil
operator|.
name|log2
argument_list|(
name|NumberUtil
operator|.
name|log2
argument_list|(
name|expectedUniqueElements
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
comment|// ========================================================================
comment|/**      * Computes the 'alpha-m-squared' constant used by the HyperLogLog algorithm.      *      * @param  m this must be a power of two, cannot be less than      *         16 (2<sup>4</sup>), and cannot be greater than 65536 (2<sup>16</sup>).      * @return gamma times<code>registerCount</code> squared where gamma is      *         based on the value of<code>registerCount</code>.      * @throws IllegalArgumentException if<code>registerCount</code> is less      *         than 16.      */
DECL|method|alphaMSquared
specifier|public
specifier|static
name|double
name|alphaMSquared
parameter_list|(
specifier|final
name|int
name|m
parameter_list|)
block|{
switch|switch
condition|(
name|m
condition|)
block|{
case|case
literal|1
comment|/*2^0*/
case|:
case|case
literal|2
comment|/*2^1*/
case|:
case|case
literal|4
comment|/*2^2*/
case|:
case|case
literal|8
comment|/*2^3*/
case|:
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"'m' cannot be less than 16 ("
operator|+
name|m
operator|+
literal|"< 16)."
argument_list|)
throw|;
case|case
literal|16
comment|/*2^4*/
case|:
return|return
literal|0.673
operator|*
name|m
operator|*
name|m
return|;
case|case
literal|32
comment|/*2^5*/
case|:
return|return
literal|0.697
operator|*
name|m
operator|*
name|m
return|;
case|case
literal|64
comment|/*2^6*/
case|:
return|return
literal|0.709
operator|*
name|m
operator|*
name|m
return|;
default|default
comment|/*>2^6*/
default|:
return|return
operator|(
literal|0.7213
operator|/
operator|(
literal|1.0
operator|+
literal|1.079
operator|/
name|m
operator|)
operator|)
operator|*
name|m
operator|*
name|m
return|;
block|}
block|}
comment|// ========================================================================
comment|/**      * Computes a mask that prevents overflow of HyperLogLog registers.      *      * @param  registerSizeInBits the size of the HLL registers, in bits.      * @return mask a<code>long</code> mask to prevent overflow of the registers      * @see #registerBitSize(long)      */
DECL|method|pwMaxMask
specifier|public
specifier|static
name|long
name|pwMaxMask
parameter_list|(
specifier|final
name|int
name|registerSizeInBits
parameter_list|)
block|{
return|return
name|PW_MASK
index|[
name|registerSizeInBits
index|]
return|;
block|}
comment|// ========================================================================
comment|/**      * The cutoff for using the "small range correction" formula, in the      * HyperLogLog algorithm.      *      * @param  m the number of registers in the HLL.<em>m<em> in the paper.      * @return the cutoff for the small range correction.      * @see #smallEstimator(int, int)      */
DECL|method|smallEstimatorCutoff
specifier|public
specifier|static
name|double
name|smallEstimatorCutoff
parameter_list|(
specifier|final
name|int
name|m
parameter_list|)
block|{
return|return
operator|(
operator|(
name|double
operator|)
name|m
operator|*
literal|5
operator|)
operator|/
literal|2
return|;
block|}
comment|/**      * The "small range correction" formula from the HyperLogLog algorithm. Only      * appropriate if both the estimator is smaller than<pre>(5/2) * m</pre> and      * there are still registers that have the zero value.      *      * @param  m the number of registers in the HLL.<em>m<em> in the paper.      * @param  numberOfZeroes the number of registers with value zero.<em>V</em>      *         in the paper.      * @return a corrected cardinality estimate.      */
DECL|method|smallEstimator
specifier|public
specifier|static
name|double
name|smallEstimator
parameter_list|(
specifier|final
name|int
name|m
parameter_list|,
specifier|final
name|int
name|numberOfZeroes
parameter_list|)
block|{
return|return
name|m
operator|*
name|Math
operator|.
name|log
argument_list|(
operator|(
name|double
operator|)
name|m
operator|/
name|numberOfZeroes
argument_list|)
return|;
block|}
comment|/**      * The cutoff for using the "large range correction" formula, from the      * HyperLogLog algorithm, adapted for 64 bit hashes.      *      * @param  log2m log-base-2 of the number of registers in the HLL.<em>b<em> in the paper.      * @param  registerSizeInBits the size of the HLL registers, in bits.      * @return the cutoff for the large range correction.      * @see #largeEstimator(int, int, double)      * @see "<a href='http://research.neustar.biz/2013/01/24/hyperloglog-googles-take-on-engineering-hll/'>Blog post with section on 64 bit hashes and 'large range correction' cutoff</a>"      */
DECL|method|largeEstimatorCutoff
specifier|public
specifier|static
name|double
name|largeEstimatorCutoff
parameter_list|(
specifier|final
name|int
name|log2m
parameter_list|,
specifier|final
name|int
name|registerSizeInBits
parameter_list|)
block|{
return|return
operator|(
name|TWO_TO_L
index|[
operator|(
name|REG_WIDTH_INDEX_MULTIPLIER
operator|*
name|registerSizeInBits
operator|)
operator|+
name|log2m
index|]
operator|)
operator|/
literal|30.0
return|;
block|}
comment|/**      * The "large range correction" formula from the HyperLogLog algorithm, adapted      * for 64 bit hashes. Only appropriate for estimators whose value exceeds      * the return of {@link #largeEstimatorCutoff(int, int)}.      *      * @param  log2m log-base-2 of the number of registers in the HLL.<em>b<em> in the paper.      * @param  registerSizeInBits the size of the HLL registers, in bits.      * @param  estimator the original estimator ("E" in the paper).      * @return a corrected cardinality estimate.      * @see "<a href='http://research.neustar.biz/2013/01/24/hyperloglog-googles-take-on-engineering-hll/'>Blog post with section on 64 bit hashes and 'large range correction'</a>"      */
DECL|method|largeEstimator
specifier|public
specifier|static
name|double
name|largeEstimator
parameter_list|(
specifier|final
name|int
name|log2m
parameter_list|,
specifier|final
name|int
name|registerSizeInBits
parameter_list|,
specifier|final
name|double
name|estimator
parameter_list|)
block|{
specifier|final
name|double
name|twoToL
init|=
name|TWO_TO_L
index|[
operator|(
name|REG_WIDTH_INDEX_MULTIPLIER
operator|*
name|registerSizeInBits
operator|)
operator|+
name|log2m
index|]
decl_stmt|;
return|return
operator|-
literal|1
operator|*
name|twoToL
operator|*
name|Math
operator|.
name|log
argument_list|(
literal|1.0
operator|-
operator|(
name|estimator
operator|/
name|twoToL
operator|)
argument_list|)
return|;
block|}
block|}
end_class
end_unit
