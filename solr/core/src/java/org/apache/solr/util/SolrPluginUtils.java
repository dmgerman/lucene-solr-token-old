begin_unit
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_package
DECL|package|org.apache.solr.util
package|package
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|util
package|;
end_package
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|InvocationTargetException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Method
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeMap
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Pattern
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|StorableField
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|StoredDocument
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|BooleanClause
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|BooleanClause
operator|.
name|Occur
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|BooleanQuery
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|DisjunctionMaxQuery
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|Explanation
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|Query
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|Sort
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|SolrDocument
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|SolrDocumentList
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|SolrException
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|params
operator|.
name|CommonParams
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|params
operator|.
name|MapSolrParams
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|params
operator|.
name|SolrParams
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|util
operator|.
name|NamedList
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|util
operator|.
name|SimpleOrderedMap
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|util
operator|.
name|StrUtils
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|core
operator|.
name|InitParams
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|core
operator|.
name|RequestParams
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|core
operator|.
name|SolrCore
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|handler
operator|.
name|component
operator|.
name|HighlightComponent
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|handler
operator|.
name|component
operator|.
name|ResponseBuilder
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|handler
operator|.
name|component
operator|.
name|ShardRequest
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|highlight
operator|.
name|SolrHighlighter
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|parser
operator|.
name|QueryParser
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|request
operator|.
name|SolrQueryRequest
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|response
operator|.
name|SolrQueryResponse
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|schema
operator|.
name|IndexSchema
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|schema
operator|.
name|SchemaField
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|search
operator|.
name|CacheRegenerator
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|search
operator|.
name|DocIterator
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|search
operator|.
name|DocList
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|search
operator|.
name|DocSet
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|search
operator|.
name|FieldParams
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|search
operator|.
name|QParser
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|search
operator|.
name|QueryParsing
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|search
operator|.
name|ReturnFields
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|search
operator|.
name|SolrCache
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|search
operator|.
name|SolrIndexSearcher
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|search
operator|.
name|SolrQueryParser
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|search
operator|.
name|SyntaxError
import|;
end_import
begin_comment
comment|/**  *<p>Utilities that may be of use to RequestHandlers.</p>  *  *<p>  * Many of these functions have code that was stolen/mutated from  * StandardRequestHandler.  *</p>  *  *<p>:TODO: refactor StandardRequestHandler to use these utilities</p>  *  *<p>:TODO: Many "standard" functionality methods are not cognisant of  * default parameter settings.  */
end_comment
begin_class
DECL|class|SolrPluginUtils
specifier|public
class|class
name|SolrPluginUtils
block|{
comment|/**    * Map containing all the possible purposes codes of a request as key and    * the corresponding readable purpose as value    */
DECL|field|purposes
specifier|private
specifier|static
specifier|final
name|Map
argument_list|<
name|Integer
argument_list|,
name|String
argument_list|>
name|purposes
decl_stmt|;
static|static
block|{
name|Map
argument_list|<
name|Integer
argument_list|,
name|String
argument_list|>
name|map
init|=
operator|new
name|TreeMap
argument_list|<>
argument_list|()
decl_stmt|;
name|map
operator|.
name|put
argument_list|(
name|ShardRequest
operator|.
name|PURPOSE_PRIVATE
argument_list|,
literal|"PRIVATE"
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
name|ShardRequest
operator|.
name|PURPOSE_GET_TERM_STATS
argument_list|,
literal|"GET_TERM_STATS"
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
name|ShardRequest
operator|.
name|PURPOSE_GET_TOP_IDS
argument_list|,
literal|"GET_TOP_IDS"
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
name|ShardRequest
operator|.
name|PURPOSE_REFINE_TOP_IDS
argument_list|,
literal|"REFINE_TOP_IDS"
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
name|ShardRequest
operator|.
name|PURPOSE_GET_FACETS
argument_list|,
literal|"GET_FACETS"
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
name|ShardRequest
operator|.
name|PURPOSE_REFINE_FACETS
argument_list|,
literal|"REFINE_FACETS"
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
name|ShardRequest
operator|.
name|PURPOSE_GET_FIELDS
argument_list|,
literal|"GET_FIELDS"
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
name|ShardRequest
operator|.
name|PURPOSE_GET_HIGHLIGHTS
argument_list|,
literal|"GET_HIGHLIGHTS"
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
name|ShardRequest
operator|.
name|PURPOSE_GET_DEBUG
argument_list|,
literal|"GET_DEBUG"
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
name|ShardRequest
operator|.
name|PURPOSE_GET_STATS
argument_list|,
literal|"GET_STATS"
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
name|ShardRequest
operator|.
name|PURPOSE_GET_TERMS
argument_list|,
literal|"GET_TERMS"
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
name|ShardRequest
operator|.
name|PURPOSE_GET_TOP_GROUPS
argument_list|,
literal|"GET_TOP_GROUPS"
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
name|ShardRequest
operator|.
name|PURPOSE_GET_MLT_RESULTS
argument_list|,
literal|"GET_MLT_RESULTS"
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
name|ShardRequest
operator|.
name|PURPOSE_SET_TERM_STATS
argument_list|,
literal|"SET_TERM_STATS"
argument_list|)
expr_stmt|;
name|purposes
operator|=
name|Collections
operator|.
name|unmodifiableMap
argument_list|(
name|map
argument_list|)
expr_stmt|;
block|}
comment|/**    * Set default-ish params on a SolrQueryRequest.    *    * RequestHandlers can use this method to ensure their defaults and    * overrides are visible to other components such as the response writer    *    * @param req The request whose params we are interested i    * @param defaults values to be used if no values are specified in the request params    * @param appends values to be appended to those from the request (or defaults) when dealing with multi-val params, or treated as another layer of defaults for singl-val params.    * @param invariants values which will be used instead of any request, or default values, regardless of context.    */
DECL|method|setDefaults
specifier|public
specifier|static
name|void
name|setDefaults
parameter_list|(
name|SolrQueryRequest
name|req
parameter_list|,
name|SolrParams
name|defaults
parameter_list|,
name|SolrParams
name|appends
parameter_list|,
name|SolrParams
name|invariants
parameter_list|)
block|{
name|List
argument_list|<
name|String
argument_list|>
name|paramNames
init|=
literal|null
decl_stmt|;
name|String
name|useParams
init|=
name|req
operator|.
name|getParams
argument_list|()
operator|.
name|get
argument_list|(
name|RequestParams
operator|.
name|USEPARAM
argument_list|)
decl_stmt|;
if|if
condition|(
name|useParams
operator|==
literal|null
condition|)
name|useParams
operator|=
operator|(
name|String
operator|)
name|req
operator|.
name|getContext
argument_list|()
operator|.
name|get
argument_list|(
name|RequestParams
operator|.
name|USEPARAM
argument_list|)
expr_stmt|;
if|if
condition|(
name|useParams
operator|!=
literal|null
condition|)
name|paramNames
operator|=
name|StrUtils
operator|.
name|splitSmart
argument_list|(
name|useParams
argument_list|,
literal|','
argument_list|)
expr_stmt|;
if|if
condition|(
name|paramNames
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|String
name|name
range|:
name|paramNames
control|)
block|{
name|SolrParams
name|requestParams
init|=
name|req
operator|.
name|getCore
argument_list|()
operator|.
name|getSolrConfig
argument_list|()
operator|.
name|getRequestParams
argument_list|()
operator|.
name|getParams
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|requestParams
operator|!=
literal|null
condition|)
block|{
name|defaults
operator|=
name|SolrParams
operator|.
name|wrapDefaults
argument_list|(
name|requestParams
argument_list|,
name|defaults
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|SolrParams
name|p
init|=
name|req
operator|.
name|getParams
argument_list|()
decl_stmt|;
name|p
operator|=
name|SolrParams
operator|.
name|wrapDefaults
argument_list|(
name|p
argument_list|,
name|defaults
argument_list|)
expr_stmt|;
name|p
operator|=
name|SolrParams
operator|.
name|wrapAppended
argument_list|(
name|p
argument_list|,
name|appends
argument_list|)
expr_stmt|;
name|p
operator|=
name|SolrParams
operator|.
name|wrapDefaults
argument_list|(
name|invariants
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|req
operator|.
name|setParams
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
comment|/**    * SolrIndexSearch.numDocs(Query,Query) freaks out if the filtering    * query is null, so we use this workarround.    */
DECL|method|numDocs
specifier|public
specifier|static
name|int
name|numDocs
parameter_list|(
name|SolrIndexSearcher
name|s
parameter_list|,
name|Query
name|q
parameter_list|,
name|Query
name|f
parameter_list|)
throws|throws
name|IOException
block|{
return|return
operator|(
literal|null
operator|==
name|f
operator|)
condition|?
name|s
operator|.
name|getDocSet
argument_list|(
name|q
argument_list|)
operator|.
name|size
argument_list|()
else|:
name|s
operator|.
name|numDocs
argument_list|(
name|q
argument_list|,
name|f
argument_list|)
return|;
block|}
DECL|field|splitList
specifier|private
specifier|final
specifier|static
name|Pattern
name|splitList
init|=
name|Pattern
operator|.
name|compile
argument_list|(
literal|",| "
argument_list|)
decl_stmt|;
comment|/** Split a value that may contain a comma, space of bar separated list. */
DECL|method|split
specifier|public
specifier|static
name|String
index|[]
name|split
parameter_list|(
name|String
name|value
parameter_list|)
block|{
return|return
name|splitList
operator|.
name|split
argument_list|(
name|value
operator|.
name|trim
argument_list|()
argument_list|,
literal|0
argument_list|)
return|;
block|}
comment|/**    * Pre-fetch documents into the index searcher's document cache.    *    * This is an entirely optional step which you might want to perform for    * the following reasons:    *    *<ul>    *<li>Locates the document-retrieval costs in one spot, which helps    *     detailed performance measurement</li>    *    *<li>Determines a priori what fields will be needed to be fetched by    *     various subtasks, like response writing and highlighting.  This    *     minimizes the chance that many needed fields will be loaded lazily.    *     (it is more efficient to load all the field we require normally).</li>    *</ul>    *    * If lazy field loading is disabled, this method does nothing.    */
DECL|method|optimizePreFetchDocs
specifier|public
specifier|static
name|void
name|optimizePreFetchDocs
parameter_list|(
name|ResponseBuilder
name|rb
parameter_list|,
name|DocList
name|docs
parameter_list|,
name|Query
name|query
parameter_list|,
name|SolrQueryRequest
name|req
parameter_list|,
name|SolrQueryResponse
name|res
parameter_list|)
throws|throws
name|IOException
block|{
name|SolrIndexSearcher
name|searcher
init|=
name|req
operator|.
name|getSearcher
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|searcher
operator|.
name|enableLazyFieldLoading
condition|)
block|{
comment|// nothing to do
return|return;
block|}
name|ReturnFields
name|returnFields
init|=
name|res
operator|.
name|getReturnFields
argument_list|()
decl_stmt|;
if|if
condition|(
name|returnFields
operator|.
name|getLuceneFieldNames
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|Set
argument_list|<
name|String
argument_list|>
name|fieldFilter
init|=
name|returnFields
operator|.
name|getLuceneFieldNames
argument_list|()
decl_stmt|;
if|if
condition|(
name|rb
operator|.
name|doHighlights
condition|)
block|{
comment|// copy return fields list
name|fieldFilter
operator|=
operator|new
name|HashSet
argument_list|<>
argument_list|(
name|fieldFilter
argument_list|)
expr_stmt|;
comment|// add highlight fields
name|SolrHighlighter
name|highlighter
init|=
name|HighlightComponent
operator|.
name|getHighlighter
argument_list|(
name|req
operator|.
name|getCore
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|field
range|:
name|highlighter
operator|.
name|getHighlightFields
argument_list|(
name|query
argument_list|,
name|req
argument_list|,
literal|null
argument_list|)
control|)
name|fieldFilter
operator|.
name|add
argument_list|(
name|field
argument_list|)
expr_stmt|;
comment|// fetch unique key if one exists.
name|SchemaField
name|keyField
init|=
name|searcher
operator|.
name|getSchema
argument_list|()
operator|.
name|getUniqueKeyField
argument_list|()
decl_stmt|;
if|if
condition|(
literal|null
operator|!=
name|keyField
condition|)
name|fieldFilter
operator|.
name|add
argument_list|(
name|keyField
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// get documents
name|DocIterator
name|iter
init|=
name|docs
operator|.
name|iterator
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|docs
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|searcher
operator|.
name|doc
argument_list|(
name|iter
operator|.
name|nextDoc
argument_list|()
argument_list|,
name|fieldFilter
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|getDebugInterests
specifier|public
specifier|static
name|Set
argument_list|<
name|String
argument_list|>
name|getDebugInterests
parameter_list|(
name|String
index|[]
name|params
parameter_list|,
name|ResponseBuilder
name|rb
parameter_list|)
block|{
name|Set
argument_list|<
name|String
argument_list|>
name|debugInterests
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
if|if
condition|(
name|params
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|params
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|params
index|[
name|i
index|]
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"all"
argument_list|)
operator|||
name|params
index|[
name|i
index|]
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"true"
argument_list|)
condition|)
block|{
name|rb
operator|.
name|setDebug
argument_list|(
literal|true
argument_list|)
expr_stmt|;
break|break;
comment|//still might add others
block|}
elseif|else
if|if
condition|(
name|params
index|[
name|i
index|]
operator|.
name|equals
argument_list|(
name|CommonParams
operator|.
name|TIMING
argument_list|)
condition|)
block|{
name|rb
operator|.
name|setDebugTimings
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|params
index|[
name|i
index|]
operator|.
name|equals
argument_list|(
name|CommonParams
operator|.
name|QUERY
argument_list|)
condition|)
block|{
name|rb
operator|.
name|setDebugQuery
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|params
index|[
name|i
index|]
operator|.
name|equals
argument_list|(
name|CommonParams
operator|.
name|RESULTS
argument_list|)
condition|)
block|{
name|rb
operator|.
name|setDebugResults
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|params
index|[
name|i
index|]
operator|.
name|equals
argument_list|(
name|CommonParams
operator|.
name|TRACK
argument_list|)
condition|)
block|{
name|rb
operator|.
name|setDebugTrack
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|debugInterests
return|;
block|}
comment|/**    *<p>    * Returns a NamedList containing many "standard" pieces of debugging    * information.    *</p>    *    *<ul>    *<li>rawquerystring - the 'q' param exactly as specified by the client    *</li>    *<li>querystring - the 'q' param after any preprocessing done by the plugin    *</li>    *<li>parsedquery - the main query executed formated by the Solr    *     QueryParsing utils class (which knows about field types)    *</li>    *<li>parsedquery_toString - the main query executed formatted by its    *     own toString method (in case it has internal state Solr    *     doesn't know about)    *</li>    *<li>explain - the list of score explanations for each document in    *     results against query.    *</li>    *<li>otherQuery - the query string specified in 'explainOther' query param.    *</li>    *<li>explainOther - the list of score explanations for each document in    *     results against 'otherQuery'    *</li>    *</ul>    *    * @param req the request we are dealing with    * @param userQuery the users query as a string, after any basic    *                  preprocessing has been done    * @param query the query built from the userQuery    *              (and perhaps other clauses) that identifies the main    *              result set of the response.    * @param results the main result set of the response    * @return The debug info    * @throws java.io.IOException if there was an IO error    */
DECL|method|doStandardDebug
specifier|public
specifier|static
name|NamedList
name|doStandardDebug
parameter_list|(
name|SolrQueryRequest
name|req
parameter_list|,
name|String
name|userQuery
parameter_list|,
name|Query
name|query
parameter_list|,
name|DocList
name|results
parameter_list|,
name|boolean
name|dbgQuery
parameter_list|,
name|boolean
name|dbgResults
parameter_list|)
throws|throws
name|IOException
block|{
name|NamedList
name|dbg
init|=
operator|new
name|SimpleOrderedMap
argument_list|()
decl_stmt|;
name|doStandardQueryDebug
argument_list|(
name|req
argument_list|,
name|userQuery
argument_list|,
name|query
argument_list|,
name|dbgQuery
argument_list|,
name|dbg
argument_list|)
expr_stmt|;
name|doStandardResultsDebug
argument_list|(
name|req
argument_list|,
name|query
argument_list|,
name|results
argument_list|,
name|dbgResults
argument_list|,
name|dbg
argument_list|)
expr_stmt|;
return|return
name|dbg
return|;
block|}
DECL|method|doStandardQueryDebug
specifier|public
specifier|static
name|void
name|doStandardQueryDebug
parameter_list|(
name|SolrQueryRequest
name|req
parameter_list|,
name|String
name|userQuery
parameter_list|,
name|Query
name|query
parameter_list|,
name|boolean
name|dbgQuery
parameter_list|,
name|NamedList
name|dbg
parameter_list|)
block|{
if|if
condition|(
name|dbgQuery
condition|)
block|{
comment|/* userQuery may have been pre-processed .. expose that */
name|dbg
operator|.
name|add
argument_list|(
literal|"rawquerystring"
argument_list|,
name|req
operator|.
name|getParams
argument_list|()
operator|.
name|get
argument_list|(
name|CommonParams
operator|.
name|Q
argument_list|)
argument_list|)
expr_stmt|;
name|dbg
operator|.
name|add
argument_list|(
literal|"querystring"
argument_list|,
name|userQuery
argument_list|)
expr_stmt|;
comment|/* QueryParsing.toString isn't perfect, use it to see converted       * values, use regular toString to see any attributes of the       * underlying Query it may have missed.       */
name|dbg
operator|.
name|add
argument_list|(
literal|"parsedquery"
argument_list|,
name|QueryParsing
operator|.
name|toString
argument_list|(
name|query
argument_list|,
name|req
operator|.
name|getSchema
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|dbg
operator|.
name|add
argument_list|(
literal|"parsedquery_toString"
argument_list|,
name|query
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|doStandardResultsDebug
specifier|public
specifier|static
name|void
name|doStandardResultsDebug
parameter_list|(
name|SolrQueryRequest
name|req
parameter_list|,
name|Query
name|query
parameter_list|,
name|DocList
name|results
parameter_list|,
name|boolean
name|dbgResults
parameter_list|,
name|NamedList
name|dbg
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|dbgResults
condition|)
block|{
name|SolrIndexSearcher
name|searcher
init|=
name|req
operator|.
name|getSearcher
argument_list|()
decl_stmt|;
name|IndexSchema
name|schema
init|=
name|searcher
operator|.
name|getSchema
argument_list|()
decl_stmt|;
name|boolean
name|explainStruct
init|=
name|req
operator|.
name|getParams
argument_list|()
operator|.
name|getBool
argument_list|(
name|CommonParams
operator|.
name|EXPLAIN_STRUCT
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|results
operator|!=
literal|null
condition|)
block|{
name|NamedList
argument_list|<
name|Explanation
argument_list|>
name|explain
init|=
name|getExplanations
argument_list|(
name|query
argument_list|,
name|results
argument_list|,
name|searcher
argument_list|,
name|schema
argument_list|)
decl_stmt|;
name|dbg
operator|.
name|add
argument_list|(
literal|"explain"
argument_list|,
name|explainStruct
condition|?
name|explanationsToNamedLists
argument_list|(
name|explain
argument_list|)
else|:
name|explanationsToStrings
argument_list|(
name|explain
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|String
name|otherQueryS
init|=
name|req
operator|.
name|getParams
argument_list|()
operator|.
name|get
argument_list|(
name|CommonParams
operator|.
name|EXPLAIN_OTHER
argument_list|)
decl_stmt|;
if|if
condition|(
name|otherQueryS
operator|!=
literal|null
operator|&&
name|otherQueryS
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
name|DocList
name|otherResults
init|=
name|doSimpleQuery
argument_list|(
name|otherQueryS
argument_list|,
name|req
argument_list|,
literal|0
argument_list|,
literal|10
argument_list|)
decl_stmt|;
name|dbg
operator|.
name|add
argument_list|(
literal|"otherQuery"
argument_list|,
name|otherQueryS
argument_list|)
expr_stmt|;
name|NamedList
argument_list|<
name|Explanation
argument_list|>
name|explainO
init|=
name|getExplanations
argument_list|(
name|query
argument_list|,
name|otherResults
argument_list|,
name|searcher
argument_list|,
name|schema
argument_list|)
decl_stmt|;
name|dbg
operator|.
name|add
argument_list|(
literal|"explainOther"
argument_list|,
name|explainStruct
condition|?
name|explanationsToNamedLists
argument_list|(
name|explainO
argument_list|)
else|:
name|explanationsToStrings
argument_list|(
name|explainO
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|explanationToNamedList
specifier|public
specifier|static
name|NamedList
argument_list|<
name|Object
argument_list|>
name|explanationToNamedList
parameter_list|(
name|Explanation
name|e
parameter_list|)
block|{
name|NamedList
argument_list|<
name|Object
argument_list|>
name|out
init|=
operator|new
name|SimpleOrderedMap
argument_list|<>
argument_list|()
decl_stmt|;
name|out
operator|.
name|add
argument_list|(
literal|"match"
argument_list|,
name|e
operator|.
name|isMatch
argument_list|()
argument_list|)
expr_stmt|;
name|out
operator|.
name|add
argument_list|(
literal|"value"
argument_list|,
name|e
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
name|out
operator|.
name|add
argument_list|(
literal|"description"
argument_list|,
name|e
operator|.
name|getDescription
argument_list|()
argument_list|)
expr_stmt|;
name|Explanation
index|[]
name|details
init|=
name|e
operator|.
name|getDetails
argument_list|()
decl_stmt|;
comment|// short circut out
if|if
condition|(
literal|null
operator|==
name|details
operator|||
literal|0
operator|==
name|details
operator|.
name|length
condition|)
return|return
name|out
return|;
name|List
argument_list|<
name|NamedList
argument_list|<
name|Object
argument_list|>
argument_list|>
name|kids
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|details
operator|.
name|length
argument_list|)
decl_stmt|;
for|for
control|(
name|Explanation
name|d
range|:
name|details
control|)
block|{
name|kids
operator|.
name|add
argument_list|(
name|explanationToNamedList
argument_list|(
name|d
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|out
operator|.
name|add
argument_list|(
literal|"details"
argument_list|,
name|kids
argument_list|)
expr_stmt|;
return|return
name|out
return|;
block|}
DECL|method|explanationsToNamedLists
specifier|public
specifier|static
name|NamedList
argument_list|<
name|NamedList
argument_list|<
name|Object
argument_list|>
argument_list|>
name|explanationsToNamedLists
parameter_list|(
name|NamedList
argument_list|<
name|Explanation
argument_list|>
name|explanations
parameter_list|)
block|{
name|NamedList
argument_list|<
name|NamedList
argument_list|<
name|Object
argument_list|>
argument_list|>
name|out
init|=
operator|new
name|SimpleOrderedMap
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|Explanation
argument_list|>
name|entry
range|:
name|explanations
control|)
block|{
name|out
operator|.
name|add
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|explanationToNamedList
argument_list|(
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|out
return|;
block|}
comment|/**    * Generates an NamedList of Explanations for each item in a list of docs.    *    * @param query The Query you want explanations in the context of    * @param docs The Documents you want explained relative that query    */
DECL|method|getExplanations
specifier|public
specifier|static
name|NamedList
argument_list|<
name|Explanation
argument_list|>
name|getExplanations
parameter_list|(
name|Query
name|query
parameter_list|,
name|DocList
name|docs
parameter_list|,
name|SolrIndexSearcher
name|searcher
parameter_list|,
name|IndexSchema
name|schema
parameter_list|)
throws|throws
name|IOException
block|{
name|NamedList
argument_list|<
name|Explanation
argument_list|>
name|explainList
init|=
operator|new
name|SimpleOrderedMap
argument_list|<>
argument_list|()
decl_stmt|;
name|DocIterator
name|iterator
init|=
name|docs
operator|.
name|iterator
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|docs
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|int
name|id
init|=
name|iterator
operator|.
name|nextDoc
argument_list|()
decl_stmt|;
name|StoredDocument
name|doc
init|=
name|searcher
operator|.
name|doc
argument_list|(
name|id
argument_list|)
decl_stmt|;
name|String
name|strid
init|=
name|schema
operator|.
name|printableUniqueKey
argument_list|(
name|doc
argument_list|)
decl_stmt|;
name|explainList
operator|.
name|add
argument_list|(
name|strid
argument_list|,
name|searcher
operator|.
name|explain
argument_list|(
name|query
argument_list|,
name|id
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|explainList
return|;
block|}
DECL|method|explanationsToStrings
specifier|private
specifier|static
name|NamedList
argument_list|<
name|String
argument_list|>
name|explanationsToStrings
parameter_list|(
name|NamedList
argument_list|<
name|Explanation
argument_list|>
name|explanations
parameter_list|)
block|{
name|NamedList
argument_list|<
name|String
argument_list|>
name|out
init|=
operator|new
name|SimpleOrderedMap
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|Explanation
argument_list|>
name|entry
range|:
name|explanations
control|)
block|{
name|out
operator|.
name|add
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
literal|"\n"
operator|+
name|entry
operator|.
name|getValue
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|out
return|;
block|}
comment|/**    * Executes a basic query    */
DECL|method|doSimpleQuery
specifier|public
specifier|static
name|DocList
name|doSimpleQuery
parameter_list|(
name|String
name|sreq
parameter_list|,
name|SolrQueryRequest
name|req
parameter_list|,
name|int
name|start
parameter_list|,
name|int
name|limit
parameter_list|)
throws|throws
name|IOException
block|{
name|List
argument_list|<
name|String
argument_list|>
name|commands
init|=
name|StrUtils
operator|.
name|splitSmart
argument_list|(
name|sreq
argument_list|,
literal|';'
argument_list|)
decl_stmt|;
name|String
name|qs
init|=
name|commands
operator|.
name|size
argument_list|()
operator|>=
literal|1
condition|?
name|commands
operator|.
name|get
argument_list|(
literal|0
argument_list|)
else|:
literal|""
decl_stmt|;
try|try
block|{
name|Query
name|query
init|=
name|QParser
operator|.
name|getParser
argument_list|(
name|qs
argument_list|,
literal|null
argument_list|,
name|req
argument_list|)
operator|.
name|getQuery
argument_list|()
decl_stmt|;
comment|// If the first non-query, non-filter command is a simple sort on an indexed field, then
comment|// we can use the Lucene sort ability.
name|Sort
name|sort
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|commands
operator|.
name|size
argument_list|()
operator|>=
literal|2
condition|)
block|{
name|sort
operator|=
name|QueryParsing
operator|.
name|parseSortSpec
argument_list|(
name|commands
operator|.
name|get
argument_list|(
literal|1
argument_list|)
argument_list|,
name|req
argument_list|)
operator|.
name|getSort
argument_list|()
expr_stmt|;
block|}
name|DocList
name|results
init|=
name|req
operator|.
name|getSearcher
argument_list|()
operator|.
name|getDocList
argument_list|(
name|query
argument_list|,
operator|(
name|DocSet
operator|)
literal|null
argument_list|,
name|sort
argument_list|,
name|start
argument_list|,
name|limit
argument_list|)
decl_stmt|;
return|return
name|results
return|;
block|}
catch|catch
parameter_list|(
name|SyntaxError
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|SolrException
operator|.
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
literal|"Error parsing query: "
operator|+
name|qs
argument_list|)
throw|;
block|}
block|}
DECL|field|whitespacePattern
specifier|private
specifier|static
specifier|final
name|Pattern
name|whitespacePattern
init|=
name|Pattern
operator|.
name|compile
argument_list|(
literal|"\\s+"
argument_list|)
decl_stmt|;
DECL|field|caratPattern
specifier|private
specifier|static
specifier|final
name|Pattern
name|caratPattern
init|=
name|Pattern
operator|.
name|compile
argument_list|(
literal|"\\^"
argument_list|)
decl_stmt|;
DECL|field|tildePattern
specifier|private
specifier|static
specifier|final
name|Pattern
name|tildePattern
init|=
name|Pattern
operator|.
name|compile
argument_list|(
literal|"[~]"
argument_list|)
decl_stmt|;
comment|/**    * Given a string containing fieldNames and boost info,    * converts it to a Map from field name to boost info.    *    *<p>    * Doesn't care if boost info is negative, you're on your own.    *</p>    *<p>    * Doesn't care if boost info is missing, again: you're on your own.    *</p>    *    * @param in a String like "fieldOne^2.3 fieldTwo fieldThree^-0.4"    * @return Map of fieldOne =&gt; 2.3, fieldTwo =&gt; null, fieldThree =&gt; -0.4    */
DECL|method|parseFieldBoosts
specifier|public
specifier|static
name|Map
argument_list|<
name|String
argument_list|,
name|Float
argument_list|>
name|parseFieldBoosts
parameter_list|(
name|String
name|in
parameter_list|)
block|{
return|return
name|parseFieldBoosts
argument_list|(
operator|new
name|String
index|[]
block|{
name|in
block|}
argument_list|)
return|;
block|}
comment|/**    * Like<code>parseFieldBoosts(String)</code>, but parses all the strings    * in the provided array (which may be null).    *    * @param fieldLists an array of Strings eg.<code>{"fieldOne^2.3", "fieldTwo", fieldThree^-0.4}</code>    * @return Map of fieldOne =&gt; 2.3, fieldTwo =&gt; null, fieldThree =&gt; -0.4    */
DECL|method|parseFieldBoosts
specifier|public
specifier|static
name|Map
argument_list|<
name|String
argument_list|,
name|Float
argument_list|>
name|parseFieldBoosts
parameter_list|(
name|String
index|[]
name|fieldLists
parameter_list|)
block|{
if|if
condition|(
literal|null
operator|==
name|fieldLists
operator|||
literal|0
operator|==
name|fieldLists
operator|.
name|length
condition|)
block|{
return|return
operator|new
name|HashMap
argument_list|<>
argument_list|()
return|;
block|}
name|Map
argument_list|<
name|String
argument_list|,
name|Float
argument_list|>
name|out
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|(
literal|7
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|in
range|:
name|fieldLists
control|)
block|{
if|if
condition|(
literal|null
operator|==
name|in
condition|)
block|{
continue|continue;
block|}
name|in
operator|=
name|in
operator|.
name|trim
argument_list|()
expr_stmt|;
if|if
condition|(
name|in
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
block|{
continue|continue;
block|}
name|String
index|[]
name|bb
init|=
name|whitespacePattern
operator|.
name|split
argument_list|(
name|in
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|s
range|:
name|bb
control|)
block|{
name|String
index|[]
name|bbb
init|=
name|caratPattern
operator|.
name|split
argument_list|(
name|s
argument_list|)
decl_stmt|;
name|out
operator|.
name|put
argument_list|(
name|bbb
index|[
literal|0
index|]
argument_list|,
literal|1
operator|==
name|bbb
operator|.
name|length
condition|?
literal|null
else|:
name|Float
operator|.
name|valueOf
argument_list|(
name|bbb
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|out
return|;
block|}
comment|/**      /**    * Like {@link #parseFieldBoosts}, but allows for an optional slop value prefixed by "~".    *    * @param fieldLists - an array of Strings eg.<code>{"fieldOne^2.3", "fieldTwo", fieldThree~5^-0.4}</code>    * @param wordGrams - (0=all words, 2,3 = shingle size)    * @param defaultSlop - the default slop for this param    * @return - FieldParams containing the fieldname,boost,slop,and shingle size    */
DECL|method|parseFieldBoostsAndSlop
specifier|public
specifier|static
name|List
argument_list|<
name|FieldParams
argument_list|>
name|parseFieldBoostsAndSlop
parameter_list|(
name|String
index|[]
name|fieldLists
parameter_list|,
name|int
name|wordGrams
parameter_list|,
name|int
name|defaultSlop
parameter_list|)
block|{
if|if
condition|(
literal|null
operator|==
name|fieldLists
operator|||
literal|0
operator|==
name|fieldLists
operator|.
name|length
condition|)
block|{
return|return
operator|new
name|ArrayList
argument_list|<>
argument_list|()
return|;
block|}
name|List
argument_list|<
name|FieldParams
argument_list|>
name|out
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|in
range|:
name|fieldLists
control|)
block|{
if|if
condition|(
literal|null
operator|==
name|in
condition|)
block|{
continue|continue;
block|}
name|in
operator|=
name|in
operator|.
name|trim
argument_list|()
expr_stmt|;
if|if
condition|(
name|in
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
block|{
continue|continue;
block|}
name|String
index|[]
name|fieldConfigs
init|=
name|whitespacePattern
operator|.
name|split
argument_list|(
name|in
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|s
range|:
name|fieldConfigs
control|)
block|{
name|String
index|[]
name|fieldAndSlopVsBoost
init|=
name|caratPattern
operator|.
name|split
argument_list|(
name|s
argument_list|)
decl_stmt|;
name|String
index|[]
name|fieldVsSlop
init|=
name|tildePattern
operator|.
name|split
argument_list|(
name|fieldAndSlopVsBoost
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|String
name|field
init|=
name|fieldVsSlop
index|[
literal|0
index|]
decl_stmt|;
name|int
name|slop
init|=
operator|(
literal|2
operator|==
name|fieldVsSlop
operator|.
name|length
operator|)
condition|?
name|Integer
operator|.
name|valueOf
argument_list|(
name|fieldVsSlop
index|[
literal|1
index|]
argument_list|)
else|:
name|defaultSlop
decl_stmt|;
name|Float
name|boost
init|=
operator|(
literal|1
operator|==
name|fieldAndSlopVsBoost
operator|.
name|length
operator|)
condition|?
literal|1
else|:
name|Float
operator|.
name|valueOf
argument_list|(
name|fieldAndSlopVsBoost
index|[
literal|1
index|]
argument_list|)
decl_stmt|;
name|FieldParams
name|fp
init|=
operator|new
name|FieldParams
argument_list|(
name|field
argument_list|,
name|wordGrams
argument_list|,
name|slop
argument_list|,
name|boost
argument_list|)
decl_stmt|;
name|out
operator|.
name|add
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|out
return|;
block|}
comment|/**    * Checks the number of optional clauses in the query, and compares it    * with the specification string to determine the proper value to use.    *    *<p>    * Details about the specification format can be found    *<a href="doc-files/min-should-match.html">here</a>    *</p>    *    *<p>A few important notes...</p>    *<ul>    *<li>    * If the calculations based on the specification determine that no    * optional clauses are needed, BooleanQuerysetMinMumberShouldMatch    * will never be called, but the usual rules about BooleanQueries    * still apply at search time (a BooleanQuery containing no required    * clauses must still match at least one optional clause)    *<li>    *<li>    * No matter what number the calculation arrives at,    * BooleanQuery.setMinShouldMatch() will never be called with a    * value greater then the number of optional clauses (or less then 1)    *</li>    *</ul>    *    *<p>:TODO: should optimize the case where number is same    * as clauses to just make them all "required"    *</p>    */
DECL|method|setMinShouldMatch
specifier|public
specifier|static
name|void
name|setMinShouldMatch
parameter_list|(
name|BooleanQuery
name|q
parameter_list|,
name|String
name|spec
parameter_list|)
block|{
name|int
name|optionalClauses
init|=
literal|0
decl_stmt|;
for|for
control|(
name|BooleanClause
name|c
range|:
name|q
operator|.
name|clauses
argument_list|()
control|)
block|{
if|if
condition|(
name|c
operator|.
name|getOccur
argument_list|()
operator|==
name|Occur
operator|.
name|SHOULD
condition|)
block|{
name|optionalClauses
operator|++
expr_stmt|;
block|}
block|}
name|int
name|msm
init|=
name|calculateMinShouldMatch
argument_list|(
name|optionalClauses
argument_list|,
name|spec
argument_list|)
decl_stmt|;
if|if
condition|(
literal|0
operator|<
name|msm
condition|)
block|{
name|q
operator|.
name|setMinimumNumberShouldMatch
argument_list|(
name|msm
argument_list|)
expr_stmt|;
block|}
block|}
comment|// private static Pattern spaceAroundLessThanPattern = Pattern.compile("\\s*<\\s*");
DECL|field|spaceAroundLessThanPattern
specifier|private
specifier|static
name|Pattern
name|spaceAroundLessThanPattern
init|=
name|Pattern
operator|.
name|compile
argument_list|(
literal|"(\\s+<\\s*)|(\\s*<\\s+)"
argument_list|)
decl_stmt|;
DECL|field|spacePattern
specifier|private
specifier|static
name|Pattern
name|spacePattern
init|=
name|Pattern
operator|.
name|compile
argument_list|(
literal|" "
argument_list|)
decl_stmt|;
DECL|field|lessThanPattern
specifier|private
specifier|static
name|Pattern
name|lessThanPattern
init|=
name|Pattern
operator|.
name|compile
argument_list|(
literal|"<"
argument_list|)
decl_stmt|;
comment|/**    * helper exposed for UnitTests    * @see #setMinShouldMatch    */
DECL|method|calculateMinShouldMatch
specifier|static
name|int
name|calculateMinShouldMatch
parameter_list|(
name|int
name|optionalClauseCount
parameter_list|,
name|String
name|spec
parameter_list|)
block|{
name|int
name|result
init|=
name|optionalClauseCount
decl_stmt|;
name|spec
operator|=
name|spec
operator|.
name|trim
argument_list|()
expr_stmt|;
if|if
condition|(
operator|-
literal|1
operator|<
name|spec
operator|.
name|indexOf
argument_list|(
literal|"<"
argument_list|)
condition|)
block|{
comment|/* we have conditional spec(s) */
name|spec
operator|=
name|spaceAroundLessThanPattern
operator|.
name|matcher
argument_list|(
name|spec
argument_list|)
operator|.
name|replaceAll
argument_list|(
literal|"<"
argument_list|)
expr_stmt|;
for|for
control|(
name|String
name|s
range|:
name|spacePattern
operator|.
name|split
argument_list|(
name|spec
argument_list|)
control|)
block|{
name|String
index|[]
name|parts
init|=
name|lessThanPattern
operator|.
name|split
argument_list|(
name|s
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|int
name|upperBound
init|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|parts
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|optionalClauseCount
operator|<=
name|upperBound
condition|)
block|{
return|return
name|result
return|;
block|}
else|else
block|{
name|result
operator|=
name|calculateMinShouldMatch
argument_list|(
name|optionalClauseCount
argument_list|,
name|parts
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
comment|/* otherwise, simple expresion */
if|if
condition|(
operator|-
literal|1
operator|<
name|spec
operator|.
name|indexOf
argument_list|(
literal|'%'
argument_list|)
condition|)
block|{
comment|/* percentage - assume the % was the last char.  If not, let Integer.parseInt fail. */
name|spec
operator|=
name|spec
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|spec
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
name|int
name|percent
init|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|spec
argument_list|)
decl_stmt|;
name|float
name|calc
init|=
operator|(
name|result
operator|*
name|percent
operator|)
operator|*
operator|(
literal|1
operator|/
literal|100f
operator|)
decl_stmt|;
name|result
operator|=
name|calc
operator|<
literal|0
condition|?
name|result
operator|+
operator|(
name|int
operator|)
name|calc
else|:
operator|(
name|int
operator|)
name|calc
expr_stmt|;
block|}
else|else
block|{
name|int
name|calc
init|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|spec
argument_list|)
decl_stmt|;
name|result
operator|=
name|calc
operator|<
literal|0
condition|?
name|result
operator|+
name|calc
else|:
name|calc
expr_stmt|;
block|}
return|return
operator|(
name|optionalClauseCount
operator|<
name|result
condition|?
name|optionalClauseCount
else|:
operator|(
name|result
operator|<
literal|0
condition|?
literal|0
else|:
name|result
operator|)
operator|)
return|;
block|}
comment|/**    * Recursively walks the "from" query pulling out sub-queries and    * adding them to the "to" query.    *    *<p>    * Boosts are multiplied as needed.  Sub-BooleanQueryies which are not    * optional will not be flattened.  From will be mangled durring the walk,    * so do not attempt to reuse it.    *</p>    */
DECL|method|flattenBooleanQuery
specifier|public
specifier|static
name|void
name|flattenBooleanQuery
parameter_list|(
name|BooleanQuery
name|to
parameter_list|,
name|BooleanQuery
name|from
parameter_list|)
block|{
for|for
control|(
name|BooleanClause
name|clause
range|:
name|from
operator|.
name|clauses
argument_list|()
control|)
block|{
name|Query
name|cq
init|=
name|clause
operator|.
name|getQuery
argument_list|()
decl_stmt|;
name|cq
operator|.
name|setBoost
argument_list|(
name|cq
operator|.
name|getBoost
argument_list|()
operator|*
name|from
operator|.
name|getBoost
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|cq
operator|instanceof
name|BooleanQuery
operator|&&
operator|!
name|clause
operator|.
name|isRequired
argument_list|()
operator|&&
operator|!
name|clause
operator|.
name|isProhibited
argument_list|()
condition|)
block|{
comment|/* we can recurse */
name|flattenBooleanQuery
argument_list|(
name|to
argument_list|,
operator|(
name|BooleanQuery
operator|)
name|cq
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|to
operator|.
name|add
argument_list|(
name|clause
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Escapes all special characters except '"', '-', and '+'    */
DECL|method|partialEscape
specifier|public
specifier|static
name|CharSequence
name|partialEscape
parameter_list|(
name|CharSequence
name|s
parameter_list|)
block|{
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|s
operator|.
name|length
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|char
name|c
init|=
name|s
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\\'
operator|||
name|c
operator|==
literal|'!'
operator|||
name|c
operator|==
literal|'('
operator|||
name|c
operator|==
literal|')'
operator|||
name|c
operator|==
literal|':'
operator|||
name|c
operator|==
literal|'^'
operator|||
name|c
operator|==
literal|'['
operator|||
name|c
operator|==
literal|']'
operator|||
name|c
operator|==
literal|'/'
operator|||
name|c
operator|==
literal|'{'
operator|||
name|c
operator|==
literal|'}'
operator|||
name|c
operator|==
literal|'~'
operator|||
name|c
operator|==
literal|'*'
operator|||
name|c
operator|==
literal|'?'
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|'\\'
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
return|return
name|sb
return|;
block|}
comment|// Pattern to detect dangling operator(s) at end of query
comment|// \s+[-+\s]+$
DECL|field|DANGLING_OP_PATTERN
specifier|private
specifier|final
specifier|static
name|Pattern
name|DANGLING_OP_PATTERN
init|=
name|Pattern
operator|.
name|compile
argument_list|(
literal|"\\s+[-+\\s]+$"
argument_list|)
decl_stmt|;
comment|// Pattern to detect consecutive + and/or - operators
comment|// \s+[+-](?:\s*[+-]+)+
DECL|field|CONSECUTIVE_OP_PATTERN
specifier|private
specifier|final
specifier|static
name|Pattern
name|CONSECUTIVE_OP_PATTERN
init|=
name|Pattern
operator|.
name|compile
argument_list|(
literal|"\\s+[+-](?:\\s*[+-]+)+"
argument_list|)
decl_stmt|;
DECL|field|UNKNOWN_VALUE
specifier|protected
specifier|static
specifier|final
name|String
name|UNKNOWN_VALUE
init|=
literal|"Unknown"
decl_stmt|;
comment|/**    * Strips operators that are used illegally, otherwise returns its    * input.  Some examples of illegal user queries are: "chocolate +-    * chip", "chocolate - - chip", and "chocolate chip -".    */
DECL|method|stripIllegalOperators
specifier|public
specifier|static
name|CharSequence
name|stripIllegalOperators
parameter_list|(
name|CharSequence
name|s
parameter_list|)
block|{
name|String
name|temp
init|=
name|CONSECUTIVE_OP_PATTERN
operator|.
name|matcher
argument_list|(
name|s
argument_list|)
operator|.
name|replaceAll
argument_list|(
literal|" "
argument_list|)
decl_stmt|;
return|return
name|DANGLING_OP_PATTERN
operator|.
name|matcher
argument_list|(
name|temp
argument_list|)
operator|.
name|replaceAll
argument_list|(
literal|""
argument_list|)
return|;
block|}
comment|/**    * Returns its input if there is an even (ie: balanced) number of    * '"' characters -- otherwise returns a String in which all '"'    * characters are striped out.    */
DECL|method|stripUnbalancedQuotes
specifier|public
specifier|static
name|CharSequence
name|stripUnbalancedQuotes
parameter_list|(
name|CharSequence
name|s
parameter_list|)
block|{
name|int
name|count
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|s
operator|.
name|length
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|s
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
operator|==
literal|'\"'
condition|)
block|{
name|count
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
literal|0
operator|==
operator|(
name|count
operator|&
literal|1
operator|)
condition|)
block|{
return|return
name|s
return|;
block|}
return|return
name|s
operator|.
name|toString
argument_list|()
operator|.
name|replace
argument_list|(
literal|"\""
argument_list|,
literal|""
argument_list|)
return|;
block|}
comment|/**    * Adds to {@code dest} all the not-null elements of {@code entries} that have non-null names    *     * @param entries The array of entries to be added to the {@link NamedList} {@code dest}    * @param dest The {@link NamedList} instance where the not-null elements of entries are added    * @return Returns The {@code dest} input object    */
DECL|method|removeNulls
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|NamedList
argument_list|<
name|T
argument_list|>
name|removeNulls
parameter_list|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|T
argument_list|>
index|[]
name|entries
parameter_list|,
name|NamedList
argument_list|<
name|T
argument_list|>
name|dest
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|entries
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|T
argument_list|>
name|entry
init|=
name|entries
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|entry
operator|!=
literal|null
condition|)
block|{
name|String
name|key
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
if|if
condition|(
name|key
operator|!=
literal|null
condition|)
block|{
name|dest
operator|.
name|add
argument_list|(
name|key
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|dest
return|;
block|}
comment|/**    * A subclass of SolrQueryParser that supports aliasing fields for    * constructing DisjunctionMaxQueries.    */
DECL|class|DisjunctionMaxQueryParser
specifier|public
specifier|static
class|class
name|DisjunctionMaxQueryParser
extends|extends
name|SolrQueryParser
block|{
comment|/** A simple container for storing alias info      * @see #aliases      */
DECL|class|Alias
specifier|protected
specifier|static
class|class
name|Alias
block|{
DECL|field|tie
specifier|public
name|float
name|tie
decl_stmt|;
DECL|field|fields
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|Float
argument_list|>
name|fields
decl_stmt|;
block|}
comment|/**      * Where we store a map from field name we expect to see in our query      * string, to Alias object containing the fields to use in our      * DisjunctionMaxQuery and the tiebreaker to use.      */
DECL|field|aliases
specifier|protected
name|Map
argument_list|<
name|String
argument_list|,
name|Alias
argument_list|>
name|aliases
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|(
literal|3
argument_list|)
decl_stmt|;
DECL|method|DisjunctionMaxQueryParser
specifier|public
name|DisjunctionMaxQueryParser
parameter_list|(
name|QParser
name|qp
parameter_list|,
name|String
name|defaultField
parameter_list|)
block|{
name|super
argument_list|(
name|qp
argument_list|,
name|defaultField
argument_list|)
expr_stmt|;
comment|// don't trust that our parent class won't ever change its default
name|setDefaultOperator
argument_list|(
name|QueryParser
operator|.
name|Operator
operator|.
name|OR
argument_list|)
expr_stmt|;
block|}
comment|/**      * Add an alias to this query parser.      *      * @param field the field name that should trigger alias mapping      * @param fieldBoosts the mapping from fieldname to boost value that      *                    should be used to build up the clauses of the      *                    DisjunctionMaxQuery.      * @param tiebreaker to the tiebreaker to be used in the      *                   DisjunctionMaxQuery      * @see SolrPluginUtils#parseFieldBoosts      */
DECL|method|addAlias
specifier|public
name|void
name|addAlias
parameter_list|(
name|String
name|field
parameter_list|,
name|float
name|tiebreaker
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|Float
argument_list|>
name|fieldBoosts
parameter_list|)
block|{
name|Alias
name|a
init|=
operator|new
name|Alias
argument_list|()
decl_stmt|;
name|a
operator|.
name|tie
operator|=
name|tiebreaker
expr_stmt|;
name|a
operator|.
name|fields
operator|=
name|fieldBoosts
expr_stmt|;
name|aliases
operator|.
name|put
argument_list|(
name|field
argument_list|,
name|a
argument_list|)
expr_stmt|;
block|}
comment|/**      * Delegates to the super class unless the field has been specified      * as an alias -- in which case we recurse on each of      * the aliased fields, and the results are composed into a      * DisjunctionMaxQuery.  (so yes: aliases which point at other      * aliases should work)      */
annotation|@
name|Override
DECL|method|getFieldQuery
specifier|protected
name|Query
name|getFieldQuery
parameter_list|(
name|String
name|field
parameter_list|,
name|String
name|queryText
parameter_list|,
name|boolean
name|quoted
parameter_list|)
throws|throws
name|SyntaxError
block|{
if|if
condition|(
name|aliases
operator|.
name|containsKey
argument_list|(
name|field
argument_list|)
condition|)
block|{
name|Alias
name|a
init|=
name|aliases
operator|.
name|get
argument_list|(
name|field
argument_list|)
decl_stmt|;
name|DisjunctionMaxQuery
name|q
init|=
operator|new
name|DisjunctionMaxQuery
argument_list|(
name|a
operator|.
name|tie
argument_list|)
decl_stmt|;
comment|/* we might not get any valid queries from delegation,          * in which case we should return null          */
name|boolean
name|ok
init|=
literal|false
decl_stmt|;
for|for
control|(
name|String
name|f
range|:
name|a
operator|.
name|fields
operator|.
name|keySet
argument_list|()
control|)
block|{
name|Query
name|sub
init|=
name|getFieldQuery
argument_list|(
name|f
argument_list|,
name|queryText
argument_list|,
name|quoted
argument_list|)
decl_stmt|;
if|if
condition|(
literal|null
operator|!=
name|sub
condition|)
block|{
if|if
condition|(
literal|null
operator|!=
name|a
operator|.
name|fields
operator|.
name|get
argument_list|(
name|f
argument_list|)
condition|)
block|{
name|sub
operator|.
name|setBoost
argument_list|(
name|a
operator|.
name|fields
operator|.
name|get
argument_list|(
name|f
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|q
operator|.
name|add
argument_list|(
name|sub
argument_list|)
expr_stmt|;
name|ok
operator|=
literal|true
expr_stmt|;
block|}
block|}
return|return
name|ok
condition|?
name|q
else|:
literal|null
return|;
block|}
else|else
block|{
try|try
block|{
return|return
name|super
operator|.
name|getFieldQuery
argument_list|(
name|field
argument_list|,
name|queryText
argument_list|,
name|quoted
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
return|return
literal|null
return|;
block|}
block|}
block|}
block|}
comment|/**    * Determines the correct Sort based on the request parameter "sort"    *    * @return null if no sort is specified.    */
DECL|method|getSort
specifier|public
specifier|static
name|Sort
name|getSort
parameter_list|(
name|SolrQueryRequest
name|req
parameter_list|)
block|{
name|String
name|sort
init|=
name|req
operator|.
name|getParams
argument_list|()
operator|.
name|get
argument_list|(
name|CommonParams
operator|.
name|SORT
argument_list|)
decl_stmt|;
if|if
condition|(
literal|null
operator|==
name|sort
operator|||
name|sort
operator|.
name|equals
argument_list|(
literal|""
argument_list|)
condition|)
block|{
return|return
literal|null
return|;
block|}
name|SolrException
name|sortE
init|=
literal|null
decl_stmt|;
name|Sort
name|ss
init|=
literal|null
decl_stmt|;
try|try
block|{
name|ss
operator|=
name|QueryParsing
operator|.
name|parseSortSpec
argument_list|(
name|sort
argument_list|,
name|req
argument_list|)
operator|.
name|getSort
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SolrException
name|e
parameter_list|)
block|{
name|sortE
operator|=
name|e
expr_stmt|;
block|}
if|if
condition|(
operator|(
literal|null
operator|==
name|ss
operator|)
operator|||
operator|(
literal|null
operator|!=
name|sortE
operator|)
condition|)
block|{
comment|/* we definitely had some sort of sort string from the user,        * but no SortSpec came out of it        */
name|SolrCore
operator|.
name|log
operator|.
name|warn
argument_list|(
literal|"Invalid sort \""
operator|+
name|sort
operator|+
literal|"\" was specified, ignoring"
argument_list|,
name|sortE
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
return|return
name|ss
return|;
block|}
comment|/** Turns an array of query strings into a List of Query objects.    *    * @return null if no queries are generated    */
DECL|method|parseQueryStrings
specifier|public
specifier|static
name|List
argument_list|<
name|Query
argument_list|>
name|parseQueryStrings
parameter_list|(
name|SolrQueryRequest
name|req
parameter_list|,
name|String
index|[]
name|queries
parameter_list|)
throws|throws
name|SyntaxError
block|{
if|if
condition|(
literal|null
operator|==
name|queries
operator|||
literal|0
operator|==
name|queries
operator|.
name|length
condition|)
return|return
literal|null
return|;
name|List
argument_list|<
name|Query
argument_list|>
name|out
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|queries
operator|.
name|length
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|q
range|:
name|queries
control|)
block|{
if|if
condition|(
literal|null
operator|!=
name|q
operator|&&
literal|0
operator|!=
name|q
operator|.
name|trim
argument_list|()
operator|.
name|length
argument_list|()
condition|)
block|{
name|out
operator|.
name|add
argument_list|(
name|QParser
operator|.
name|getParser
argument_list|(
name|q
argument_list|,
literal|null
argument_list|,
name|req
argument_list|)
operator|.
name|getQuery
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|out
return|;
block|}
comment|/**    * A CacheRegenerator that can be used whenever the items in the cache    * are not dependant on the current searcher.    *    *<p>    * Flat out copies the oldKey=&gt;oldVal pair into the newCache    *</p>    */
DECL|class|IdentityRegenerator
specifier|public
specifier|static
class|class
name|IdentityRegenerator
implements|implements
name|CacheRegenerator
block|{
annotation|@
name|Override
DECL|method|regenerateItem
specifier|public
name|boolean
name|regenerateItem
parameter_list|(
name|SolrIndexSearcher
name|newSearcher
parameter_list|,
name|SolrCache
name|newCache
parameter_list|,
name|SolrCache
name|oldCache
parameter_list|,
name|Object
name|oldKey
parameter_list|,
name|Object
name|oldVal
parameter_list|)
throws|throws
name|IOException
block|{
name|newCache
operator|.
name|put
argument_list|(
name|oldKey
argument_list|,
name|oldVal
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
comment|/**    * Convert a DocList to a SolrDocumentList    *    * The optional param "ids" is populated with the lucene document id    * for each SolrDocument.    *    * @param docs The {@link org.apache.solr.search.DocList} to convert    * @param searcher The {@link org.apache.solr.search.SolrIndexSearcher} to use to load the docs from the Lucene index    * @param fields The names of the Fields to load    * @param ids A map to store the ids of the docs    * @return The new {@link org.apache.solr.common.SolrDocumentList} containing all the loaded docs    * @throws java.io.IOException if there was a problem loading the docs    * @since solr 1.4    */
DECL|method|docListToSolrDocumentList
specifier|public
specifier|static
name|SolrDocumentList
name|docListToSolrDocumentList
parameter_list|(
name|DocList
name|docs
parameter_list|,
name|SolrIndexSearcher
name|searcher
parameter_list|,
name|Set
argument_list|<
name|String
argument_list|>
name|fields
parameter_list|,
name|Map
argument_list|<
name|SolrDocument
argument_list|,
name|Integer
argument_list|>
name|ids
parameter_list|)
throws|throws
name|IOException
block|{
name|IndexSchema
name|schema
init|=
name|searcher
operator|.
name|getSchema
argument_list|()
decl_stmt|;
name|SolrDocumentList
name|list
init|=
operator|new
name|SolrDocumentList
argument_list|()
decl_stmt|;
name|list
operator|.
name|setNumFound
argument_list|(
name|docs
operator|.
name|matches
argument_list|()
argument_list|)
expr_stmt|;
name|list
operator|.
name|setMaxScore
argument_list|(
name|docs
operator|.
name|maxScore
argument_list|()
argument_list|)
expr_stmt|;
name|list
operator|.
name|setStart
argument_list|(
name|docs
operator|.
name|offset
argument_list|()
argument_list|)
expr_stmt|;
name|DocIterator
name|dit
init|=
name|docs
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|dit
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|int
name|docid
init|=
name|dit
operator|.
name|nextDoc
argument_list|()
decl_stmt|;
name|StoredDocument
name|luceneDoc
init|=
name|searcher
operator|.
name|doc
argument_list|(
name|docid
argument_list|,
name|fields
argument_list|)
decl_stmt|;
name|SolrDocument
name|doc
init|=
operator|new
name|SolrDocument
argument_list|()
decl_stmt|;
for|for
control|(
name|StorableField
name|field
range|:
name|luceneDoc
control|)
block|{
if|if
condition|(
literal|null
operator|==
name|fields
operator|||
name|fields
operator|.
name|contains
argument_list|(
name|field
operator|.
name|name
argument_list|()
argument_list|)
condition|)
block|{
name|SchemaField
name|sf
init|=
name|schema
operator|.
name|getField
argument_list|(
name|field
operator|.
name|name
argument_list|()
argument_list|)
decl_stmt|;
name|doc
operator|.
name|addField
argument_list|(
name|field
operator|.
name|name
argument_list|()
argument_list|,
name|sf
operator|.
name|getType
argument_list|()
operator|.
name|toObject
argument_list|(
name|field
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|docs
operator|.
name|hasScores
argument_list|()
operator|&&
operator|(
literal|null
operator|==
name|fields
operator|||
name|fields
operator|.
name|contains
argument_list|(
literal|"score"
argument_list|)
operator|)
condition|)
block|{
name|doc
operator|.
name|addField
argument_list|(
literal|"score"
argument_list|,
name|dit
operator|.
name|score
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|list
operator|.
name|add
argument_list|(
name|doc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ids
operator|!=
literal|null
condition|)
block|{
name|ids
operator|.
name|put
argument_list|(
name|doc
argument_list|,
operator|new
name|Integer
argument_list|(
name|docid
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|list
return|;
block|}
DECL|method|invokeSetters
specifier|public
specifier|static
name|void
name|invokeSetters
parameter_list|(
name|Object
name|bean
parameter_list|,
name|NamedList
name|initArgs
parameter_list|)
block|{
if|if
condition|(
name|initArgs
operator|==
literal|null
condition|)
return|return;
name|Class
name|clazz
init|=
name|bean
operator|.
name|getClass
argument_list|()
decl_stmt|;
name|Method
index|[]
name|methods
init|=
name|clazz
operator|.
name|getMethods
argument_list|()
decl_stmt|;
name|Iterator
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
argument_list|>
name|iterator
init|=
name|initArgs
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|iterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|entry
init|=
name|iterator
operator|.
name|next
argument_list|()
decl_stmt|;
name|String
name|key
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|String
name|setterName
init|=
literal|"set"
operator|+
name|String
operator|.
name|valueOf
argument_list|(
name|Character
operator|.
name|toUpperCase
argument_list|(
name|key
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|+
name|key
operator|.
name|substring
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|Method
name|method
init|=
literal|null
decl_stmt|;
try|try
block|{
for|for
control|(
name|Method
name|m
range|:
name|methods
control|)
block|{
if|if
condition|(
name|m
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
name|setterName
argument_list|)
operator|&&
name|m
operator|.
name|getParameterTypes
argument_list|()
operator|.
name|length
operator|==
literal|1
condition|)
block|{
name|method
operator|=
name|m
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|method
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"no setter corrresponding to '"
operator|+
name|key
operator|+
literal|"' in "
operator|+
name|clazz
operator|.
name|getName
argument_list|()
argument_list|)
throw|;
block|}
name|Class
name|pClazz
init|=
name|method
operator|.
name|getParameterTypes
argument_list|()
index|[
literal|0
index|]
decl_stmt|;
name|Object
name|val
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|method
operator|.
name|invoke
argument_list|(
name|bean
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InvocationTargetException
name|e1
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Error invoking setter "
operator|+
name|setterName
operator|+
literal|" on class : "
operator|+
name|clazz
operator|.
name|getName
argument_list|()
argument_list|,
name|e1
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|IllegalAccessException
name|e1
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Error invoking setter "
operator|+
name|setterName
operator|+
literal|" on class : "
operator|+
name|clazz
operator|.
name|getName
argument_list|()
argument_list|,
name|e1
argument_list|)
throw|;
block|}
block|}
block|}
comment|/**    * Given the integer purpose of a request generates a readable value corresponding     * the request purposes (there can be more than one on a single request). If     * there is a purpose parameter present that's not known this method will     * return {@value #UNKNOWN_VALUE}    * @param reqPurpose Numeric request purpose    * @return a comma separated list of purposes or {@value #UNKNOWN_VALUE}    */
DECL|method|getRequestPurpose
specifier|public
specifier|static
name|String
name|getRequestPurpose
parameter_list|(
name|Integer
name|reqPurpose
parameter_list|)
block|{
if|if
condition|(
name|reqPurpose
operator|!=
literal|null
condition|)
block|{
name|StringBuilder
name|builder
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|Integer
argument_list|,
name|String
argument_list|>
name|entry
range|:
name|purposes
operator|.
name|entrySet
argument_list|()
control|)
block|{
if|if
condition|(
operator|(
name|reqPurpose
operator|&
name|entry
operator|.
name|getKey
argument_list|()
operator|)
operator|!=
literal|0
condition|)
block|{
name|builder
operator|.
name|append
argument_list|(
name|entry
operator|.
name|getValue
argument_list|()
operator|+
literal|","
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|builder
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
name|UNKNOWN_VALUE
return|;
block|}
name|builder
operator|.
name|setLength
argument_list|(
name|builder
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
name|builder
operator|.
name|toString
argument_list|()
return|;
block|}
return|return
name|UNKNOWN_VALUE
return|;
block|}
block|}
end_class
end_unit
