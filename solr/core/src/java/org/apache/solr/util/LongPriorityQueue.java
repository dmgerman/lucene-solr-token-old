begin_unit
begin_package
DECL|package|org.apache.solr.util
package|package
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|util
package|;
end_package
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_comment
comment|/** A native long priority queue.  *   * @lucene.internal */
end_comment
begin_class
DECL|class|LongPriorityQueue
specifier|public
class|class
name|LongPriorityQueue
block|{
DECL|field|size
specifier|protected
name|int
name|size
decl_stmt|;
comment|// number of elements currently in the queue
DECL|field|currentCapacity
specifier|protected
name|int
name|currentCapacity
decl_stmt|;
comment|// number of elements the queue can hold w/o expanding
DECL|field|maxSize
specifier|protected
name|int
name|maxSize
decl_stmt|;
comment|// max number of elements allowed in the queue
DECL|field|heap
specifier|protected
name|long
index|[]
name|heap
decl_stmt|;
DECL|field|sentinel
specifier|protected
specifier|final
name|long
name|sentinel
decl_stmt|;
comment|// represents a null return value
DECL|method|LongPriorityQueue
specifier|public
name|LongPriorityQueue
parameter_list|(
name|int
name|initialSize
parameter_list|,
name|int
name|maxSize
parameter_list|,
name|long
name|sentinel
parameter_list|)
block|{
name|this
operator|.
name|maxSize
operator|=
name|maxSize
expr_stmt|;
name|this
operator|.
name|sentinel
operator|=
name|sentinel
expr_stmt|;
name|initialize
argument_list|(
name|initialSize
argument_list|)
expr_stmt|;
block|}
DECL|method|initialize
specifier|protected
name|void
name|initialize
parameter_list|(
name|int
name|sz
parameter_list|)
block|{
name|int
name|heapSize
decl_stmt|;
if|if
condition|(
literal|0
operator|==
name|sz
condition|)
comment|// We allocate 1 extra to avoid if statement in top()
name|heapSize
operator|=
literal|2
expr_stmt|;
else|else
block|{
comment|// NOTE: we add +1 because all access to heap is
comment|// 1-based not 0-based.  heap[0] is unused.
name|heapSize
operator|=
name|Math
operator|.
name|max
argument_list|(
name|sz
argument_list|,
name|sz
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|// handle overflow
block|}
name|heap
operator|=
operator|new
name|long
index|[
name|heapSize
index|]
expr_stmt|;
name|currentCapacity
operator|=
name|sz
expr_stmt|;
block|}
DECL|method|getCurrentCapacity
specifier|public
name|int
name|getCurrentCapacity
parameter_list|()
block|{
return|return
name|currentCapacity
return|;
block|}
DECL|method|resize
specifier|public
name|void
name|resize
parameter_list|(
name|int
name|sz
parameter_list|)
block|{
name|int
name|heapSize
decl_stmt|;
if|if
condition|(
name|sz
operator|>
name|maxSize
condition|)
block|{
name|maxSize
operator|=
name|sz
expr_stmt|;
block|}
if|if
condition|(
literal|0
operator|==
name|sz
condition|)
comment|// We allocate 1 extra to avoid if statement in top()
name|heapSize
operator|=
literal|2
expr_stmt|;
else|else
block|{
name|heapSize
operator|=
name|Math
operator|.
name|max
argument_list|(
name|sz
argument_list|,
name|sz
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|// handle overflow
block|}
name|heap
operator|=
name|Arrays
operator|.
name|copyOf
argument_list|(
name|heap
argument_list|,
name|heapSize
argument_list|)
expr_stmt|;
name|currentCapacity
operator|=
name|sz
expr_stmt|;
block|}
comment|/**    * Adds an object to a PriorityQueue in log(size) time. If one tries to add    * more objects than maxSize from initialize an    * {@link ArrayIndexOutOfBoundsException} is thrown.    *     * @return the new 'top' element in the queue.    */
DECL|method|add
specifier|public
name|long
name|add
parameter_list|(
name|long
name|element
parameter_list|)
block|{
if|if
condition|(
name|size
operator|>=
name|currentCapacity
condition|)
block|{
name|int
name|newSize
init|=
name|Math
operator|.
name|min
argument_list|(
name|currentCapacity
operator|<<
literal|1
argument_list|,
name|maxSize
argument_list|)
decl_stmt|;
if|if
condition|(
name|newSize
operator|<
name|currentCapacity
condition|)
name|newSize
operator|=
name|Integer
operator|.
name|MAX_VALUE
expr_stmt|;
comment|// handle overflow
name|resize
argument_list|(
name|newSize
argument_list|)
expr_stmt|;
block|}
name|size
operator|++
expr_stmt|;
name|heap
index|[
name|size
index|]
operator|=
name|element
expr_stmt|;
name|upHeap
argument_list|()
expr_stmt|;
return|return
name|heap
index|[
literal|1
index|]
return|;
block|}
comment|/**    * Adds an object to a PriorityQueue in log(size) time. If one tries to add    * more objects than the current capacity, an    * {@link ArrayIndexOutOfBoundsException} is thrown.    */
DECL|method|addNoCheck
specifier|public
name|void
name|addNoCheck
parameter_list|(
name|long
name|element
parameter_list|)
block|{
operator|++
name|size
expr_stmt|;
name|heap
index|[
name|size
index|]
operator|=
name|element
expr_stmt|;
name|upHeap
argument_list|()
expr_stmt|;
block|}
comment|/**    * Adds an object to a PriorityQueue in log(size) time.    * It returns the smallest object (if any) that was    * dropped off the heap because it was full, or    * the sentinel value.    *    *  This can be    * the given parameter (in case it is smaller than the    * full heap's minimum, and couldn't be added), or another    * object that was previously the smallest value in the    * heap and now has been replaced by a larger one, or null    * if the queue wasn't yet full with maxSize elements.    */
DECL|method|insertWithOverflow
specifier|public
name|long
name|insertWithOverflow
parameter_list|(
name|long
name|element
parameter_list|)
block|{
if|if
condition|(
name|size
operator|<
name|maxSize
condition|)
block|{
name|add
argument_list|(
name|element
argument_list|)
expr_stmt|;
return|return
name|sentinel
return|;
block|}
elseif|else
if|if
condition|(
name|element
operator|>
name|heap
index|[
literal|1
index|]
condition|)
block|{
name|long
name|ret
init|=
name|heap
index|[
literal|1
index|]
decl_stmt|;
name|heap
index|[
literal|1
index|]
operator|=
name|element
expr_stmt|;
name|updateTop
argument_list|()
expr_stmt|;
return|return
name|ret
return|;
block|}
else|else
block|{
return|return
name|element
return|;
block|}
block|}
comment|/** inserts the element and returns true if this element caused another element    * to be dropped from the queue. */
DECL|method|insert
specifier|public
name|boolean
name|insert
parameter_list|(
name|long
name|element
parameter_list|)
block|{
if|if
condition|(
name|size
operator|<
name|maxSize
condition|)
block|{
name|add
argument_list|(
name|element
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
elseif|else
if|if
condition|(
name|element
operator|>
name|heap
index|[
literal|1
index|]
condition|)
block|{
comment|// long ret = heap[1];
name|heap
index|[
literal|1
index|]
operator|=
name|element
expr_stmt|;
name|updateTop
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
block|}
comment|/** Returns the least element of the PriorityQueue in constant time. */
DECL|method|top
specifier|public
name|long
name|top
parameter_list|()
block|{
return|return
name|heap
index|[
literal|1
index|]
return|;
block|}
comment|/** Removes and returns the least element of the PriorityQueue in log(size)     time.  Only valid if size()&gt; 0.    */
DECL|method|pop
specifier|public
name|long
name|pop
parameter_list|()
block|{
name|long
name|result
init|=
name|heap
index|[
literal|1
index|]
decl_stmt|;
comment|// save first value
name|heap
index|[
literal|1
index|]
operator|=
name|heap
index|[
name|size
index|]
expr_stmt|;
comment|// move last to first
name|size
operator|--
expr_stmt|;
name|downHeap
argument_list|()
expr_stmt|;
comment|// adjust heap
return|return
name|result
return|;
block|}
comment|/**    * Should be called when the Object at top changes values.    * @return the new 'top' element.    */
DECL|method|updateTop
specifier|public
name|long
name|updateTop
parameter_list|()
block|{
name|downHeap
argument_list|()
expr_stmt|;
return|return
name|heap
index|[
literal|1
index|]
return|;
block|}
comment|/** Returns the number of elements currently stored in the PriorityQueue. */
DECL|method|size
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|size
return|;
block|}
comment|/** Returns the array used to hold the heap, with the smallest item at array[1]    *  and the last (but not necessarily largest) at array[size()].  This is *not*    *  fully sorted.    */
DECL|method|getInternalArray
specifier|public
name|long
index|[]
name|getInternalArray
parameter_list|()
block|{
return|return
name|heap
return|;
block|}
comment|/** Pops the smallest n items from the heap, placing them in the internal array at    *  arr[size] through arr[size-(n-1)] with the smallest (first element popped)    *  being at arr[size].  The internal array is returned.    */
DECL|method|sort
specifier|public
name|long
index|[]
name|sort
parameter_list|(
name|int
name|n
parameter_list|)
block|{
while|while
condition|(
operator|--
name|n
operator|>=
literal|0
condition|)
block|{
name|long
name|result
init|=
name|heap
index|[
literal|1
index|]
decl_stmt|;
comment|// save first value
name|heap
index|[
literal|1
index|]
operator|=
name|heap
index|[
name|size
index|]
expr_stmt|;
comment|// move last to first
name|heap
index|[
name|size
index|]
operator|=
name|result
expr_stmt|;
comment|// place it last
name|size
operator|--
expr_stmt|;
name|downHeap
argument_list|()
expr_stmt|;
comment|// adjust heap
block|}
return|return
name|heap
return|;
block|}
comment|/** Removes all entries from the PriorityQueue. */
DECL|method|clear
specifier|public
name|void
name|clear
parameter_list|()
block|{
name|size
operator|=
literal|0
expr_stmt|;
block|}
DECL|method|upHeap
specifier|private
name|void
name|upHeap
parameter_list|()
block|{
name|int
name|i
init|=
name|size
decl_stmt|;
name|long
name|node
init|=
name|heap
index|[
name|i
index|]
decl_stmt|;
comment|// save bottom node
name|int
name|j
init|=
name|i
operator|>>>
literal|1
decl_stmt|;
while|while
condition|(
name|j
operator|>
literal|0
operator|&&
name|node
operator|<
name|heap
index|[
name|j
index|]
condition|)
block|{
name|heap
index|[
name|i
index|]
operator|=
name|heap
index|[
name|j
index|]
expr_stmt|;
comment|// shift parents down
name|i
operator|=
name|j
expr_stmt|;
name|j
operator|=
name|j
operator|>>>
literal|1
expr_stmt|;
block|}
name|heap
index|[
name|i
index|]
operator|=
name|node
expr_stmt|;
comment|// install saved node
block|}
DECL|method|downHeap
specifier|private
name|void
name|downHeap
parameter_list|()
block|{
name|int
name|i
init|=
literal|1
decl_stmt|;
name|long
name|node
init|=
name|heap
index|[
name|i
index|]
decl_stmt|;
comment|// save top node
name|int
name|j
init|=
name|i
operator|<<
literal|1
decl_stmt|;
comment|// find smaller child
name|int
name|k
init|=
name|j
operator|+
literal|1
decl_stmt|;
if|if
condition|(
name|k
operator|<=
name|size
operator|&&
name|heap
index|[
name|k
index|]
operator|<
name|heap
index|[
name|j
index|]
condition|)
block|{
name|j
operator|=
name|k
expr_stmt|;
block|}
while|while
condition|(
name|j
operator|<=
name|size
operator|&&
name|heap
index|[
name|j
index|]
operator|<
name|node
condition|)
block|{
name|heap
index|[
name|i
index|]
operator|=
name|heap
index|[
name|j
index|]
expr_stmt|;
comment|// shift up child
name|i
operator|=
name|j
expr_stmt|;
name|j
operator|=
name|i
operator|<<
literal|1
expr_stmt|;
name|k
operator|=
name|j
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|k
operator|<=
name|size
operator|&&
name|heap
index|[
name|k
index|]
operator|<
name|heap
index|[
name|j
index|]
condition|)
block|{
name|j
operator|=
name|k
expr_stmt|;
block|}
block|}
name|heap
index|[
name|i
index|]
operator|=
name|node
expr_stmt|;
comment|// install saved node
block|}
block|}
end_class
end_unit
