begin_unit
begin_package
DECL|package|org.apache.solr.util.hll
package|package
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|util
operator|.
name|hll
package|;
end_package
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import
begin_import
import|import
name|com
operator|.
name|carrotsearch
operator|.
name|hppc
operator|.
name|IntByteHashMap
import|;
end_import
begin_import
import|import
name|com
operator|.
name|carrotsearch
operator|.
name|hppc
operator|.
name|LongHashSet
import|;
end_import
begin_import
import|import
name|com
operator|.
name|carrotsearch
operator|.
name|hppc
operator|.
name|cursors
operator|.
name|IntByteCursor
import|;
end_import
begin_import
import|import
name|com
operator|.
name|carrotsearch
operator|.
name|hppc
operator|.
name|cursors
operator|.
name|LongCursor
import|;
end_import
begin_comment
comment|/**  * A probabilistic set of hashed<code>long</code> elements. Useful for computing  * the approximate cardinality of a stream of data in very small storage.  *  * A modified version of the<a href="http://algo.inria.fr/flajolet/Publications/FlFuGaMe07.pdf">  * 'HyperLogLog' data structure and algorithm</a> is used, which combines both  * probabilistic and non-probabilistic techniques to improve the accuracy and  * storage requirements of the original algorithm.  *  * More specifically, initializing and storing a new {@link HLL} will  * allocate a sentinel value symbolizing the empty set ({@link HLLType#EMPTY}).  * After adding the first few values, a sorted list of unique integers is  * stored in a {@link HLLType#EXPLICIT} hash set. When configured, accuracy can  * be sacrificed for memory footprint: the values in the sorted list are  * "promoted" to a "{@link HLLType#SPARSE}" map-based HyperLogLog structure.  * Finally, when enough registers are set, the map-based HLL will be converted  * to a bit-packed "{@link HLLType#FULL}" HyperLogLog structure.  *  * This data structure is interoperable with the implementations found at:  *<ul>  *<li><a href="https://github.com/aggregateknowledge/postgresql-hll">postgresql-hll</a>, and</li>  *<li><a href="https://github.com/aggregateknowledge/js-hll">js-hll</a></li>  *</ul>  * when<a href="https://github.com/aggregateknowledge/postgresql-hll/blob/master/STORAGE.markdown">properly serialized</a>.  */
end_comment
begin_class
DECL|class|HLL
specifier|public
class|class
name|HLL
implements|implements
name|Cloneable
block|{
comment|// minimum and maximum values for the log-base-2 of the number of registers
comment|// in the HLL
DECL|field|MINIMUM_LOG2M_PARAM
specifier|public
specifier|static
specifier|final
name|int
name|MINIMUM_LOG2M_PARAM
init|=
literal|4
decl_stmt|;
DECL|field|MAXIMUM_LOG2M_PARAM
specifier|public
specifier|static
specifier|final
name|int
name|MAXIMUM_LOG2M_PARAM
init|=
literal|30
decl_stmt|;
comment|// minimum and maximum values for the register width of the HLL
DECL|field|MINIMUM_REGWIDTH_PARAM
specifier|public
specifier|static
specifier|final
name|int
name|MINIMUM_REGWIDTH_PARAM
init|=
literal|1
decl_stmt|;
DECL|field|MAXIMUM_REGWIDTH_PARAM
specifier|public
specifier|static
specifier|final
name|int
name|MAXIMUM_REGWIDTH_PARAM
init|=
literal|8
decl_stmt|;
comment|// minimum and maximum values for the 'expthresh' parameter of the
comment|// constructor that is meant to match the PostgreSQL implementation's
comment|// constructor and parameter names
DECL|field|MINIMUM_EXPTHRESH_PARAM
specifier|public
specifier|static
specifier|final
name|int
name|MINIMUM_EXPTHRESH_PARAM
init|=
operator|-
literal|1
decl_stmt|;
DECL|field|MAXIMUM_EXPTHRESH_PARAM
specifier|public
specifier|static
specifier|final
name|int
name|MAXIMUM_EXPTHRESH_PARAM
init|=
literal|18
decl_stmt|;
DECL|field|MAXIMUM_EXPLICIT_THRESHOLD
specifier|public
specifier|static
specifier|final
name|int
name|MAXIMUM_EXPLICIT_THRESHOLD
init|=
operator|(
literal|1
operator|<<
operator|(
name|MAXIMUM_EXPTHRESH_PARAM
operator|-
literal|1
operator|)
comment|/*per storage spec*/
operator|)
decl_stmt|;
comment|// ************************************************************************
comment|// Storage
comment|// storage used when #type is EXPLICIT, null otherwise
DECL|field|explicitStorage
name|LongHashSet
name|explicitStorage
decl_stmt|;
comment|// storage used when #type is SPARSE, null otherwise
DECL|field|sparseProbabilisticStorage
name|IntByteHashMap
name|sparseProbabilisticStorage
decl_stmt|;
comment|// storage used when #type is FULL, null otherwise
DECL|field|probabilisticStorage
name|BitVector
name|probabilisticStorage
decl_stmt|;
comment|// current type of this HLL instance, if this changes then so should the
comment|// storage used (see above)
DECL|field|type
specifier|private
name|HLLType
name|type
decl_stmt|;
comment|// ------------------------------------------------------------------------
comment|// Characteristic parameters
comment|// NOTE:  These members are named to match the PostgreSQL implementation's
comment|//        parameters.
comment|// log2(the number of probabilistic HLL registers)
DECL|field|log2m
specifier|private
specifier|final
name|int
name|log2m
decl_stmt|;
comment|// the size (width) each register in bits
DECL|field|regwidth
specifier|private
specifier|final
name|int
name|regwidth
decl_stmt|;
comment|// ------------------------------------------------------------------------
comment|// Computed constants
comment|// ........................................................................
comment|// EXPLICIT-specific constants
comment|// flag indicating if the EXPLICIT representation should NOT be used
DECL|field|explicitOff
specifier|private
specifier|final
name|boolean
name|explicitOff
decl_stmt|;
comment|// flag indicating that the promotion threshold from EXPLICIT should be
comment|// computed automatically
comment|// NOTE:  this only has meaning when 'explicitOff' is false
DECL|field|explicitAuto
specifier|private
specifier|final
name|boolean
name|explicitAuto
decl_stmt|;
comment|// threshold (in element count) at which a EXPLICIT HLL is converted to a
comment|// SPARSE or FULL HLL, always greater than or equal to zero and always a
comment|// power of two OR simply zero
comment|// NOTE:  this only has meaning when 'explicitOff' is false
DECL|field|explicitThreshold
specifier|private
specifier|final
name|int
name|explicitThreshold
decl_stmt|;
comment|// ........................................................................
comment|// SPARSE-specific constants
comment|// the computed width of the short words
DECL|field|shortWordLength
specifier|private
specifier|final
name|int
name|shortWordLength
decl_stmt|;
comment|// flag indicating if the SPARSE representation should not be used
DECL|field|sparseOff
specifier|private
specifier|final
name|boolean
name|sparseOff
decl_stmt|;
comment|// threshold (in register count) at which a SPARSE HLL is converted to a
comment|// FULL HLL, always greater than zero
DECL|field|sparseThreshold
specifier|private
specifier|final
name|int
name|sparseThreshold
decl_stmt|;
comment|// ........................................................................
comment|// Probabilistic algorithm constants
comment|// the number of registers, will always be a power of 2
DECL|field|m
specifier|private
specifier|final
name|int
name|m
decl_stmt|;
comment|// a mask of the log2m bits set to one and the rest to zero
DECL|field|mBitsMask
specifier|private
specifier|final
name|int
name|mBitsMask
decl_stmt|;
comment|// a mask as wide as a register (see #fromBytes())
DECL|field|valueMask
specifier|private
specifier|final
name|int
name|valueMask
decl_stmt|;
comment|// mask used to ensure that p(w) does not overflow register (see #Constructor() and #addRaw())
DECL|field|pwMaxMask
specifier|private
specifier|final
name|long
name|pwMaxMask
decl_stmt|;
comment|// alpha * m^2 (the constant in the "'raw' HyperLogLog estimator")
DECL|field|alphaMSquared
specifier|private
specifier|final
name|double
name|alphaMSquared
decl_stmt|;
comment|// the cutoff value of the estimator for using the "small" range cardinality
comment|// correction formula
DECL|field|smallEstimatorCutoff
specifier|private
specifier|final
name|double
name|smallEstimatorCutoff
decl_stmt|;
comment|// the cutoff value of the estimator for using the "large" range cardinality
comment|// correction formula
DECL|field|largeEstimatorCutoff
specifier|private
specifier|final
name|double
name|largeEstimatorCutoff
decl_stmt|;
comment|// ========================================================================
comment|/**      * NOTE: Arguments here are named and structured identically to those in the      *       PostgreSQL implementation, which can be found      *<a href="https://github.com/aggregateknowledge/postgresql-hll/blob/master/README.markdown#explanation-of-parameters-and-tuning">here</a>.      *      * @param log2m log-base-2 of the number of registers used in the HyperLogLog      *        algorithm. Must be at least 4 and at most 30.      * @param regwidth number of bits used per register in the HyperLogLog      *        algorithm. Must be at least 1 and at most 8.      * @param expthresh tunes when the {@link HLLType#EXPLICIT} to      *        {@link HLLType#SPARSE} promotion occurs,      *        based on the set's cardinality. Must be at least -1 and at most 18.      * @param sparseon Flag indicating if the {@link HLLType#SPARSE}      *        representation should be used.      * @param type the type in the promotion hierarchy which this instance should      *        start at. This cannot be<code>null</code>.      */
DECL|method|HLL
specifier|public
name|HLL
parameter_list|(
specifier|final
name|int
name|log2m
parameter_list|,
specifier|final
name|int
name|regwidth
parameter_list|,
specifier|final
name|int
name|expthresh
parameter_list|,
specifier|final
name|boolean
name|sparseon
parameter_list|,
specifier|final
name|HLLType
name|type
parameter_list|)
block|{
name|this
operator|.
name|log2m
operator|=
name|log2m
expr_stmt|;
if|if
condition|(
operator|(
name|log2m
operator|<
name|MINIMUM_LOG2M_PARAM
operator|)
operator|||
operator|(
name|log2m
operator|>
name|MAXIMUM_LOG2M_PARAM
operator|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"'log2m' must be at least "
operator|+
name|MINIMUM_LOG2M_PARAM
operator|+
literal|" and at most "
operator|+
name|MAXIMUM_LOG2M_PARAM
operator|+
literal|" (was: "
operator|+
name|log2m
operator|+
literal|")"
argument_list|)
throw|;
block|}
name|this
operator|.
name|regwidth
operator|=
name|regwidth
expr_stmt|;
if|if
condition|(
operator|(
name|regwidth
operator|<
name|MINIMUM_REGWIDTH_PARAM
operator|)
operator|||
operator|(
name|regwidth
operator|>
name|MAXIMUM_REGWIDTH_PARAM
operator|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"'regwidth' must be at least "
operator|+
name|MINIMUM_REGWIDTH_PARAM
operator|+
literal|" and at most "
operator|+
name|MAXIMUM_REGWIDTH_PARAM
operator|+
literal|" (was: "
operator|+
name|regwidth
operator|+
literal|")"
argument_list|)
throw|;
block|}
name|this
operator|.
name|m
operator|=
operator|(
literal|1
operator|<<
name|log2m
operator|)
expr_stmt|;
name|this
operator|.
name|mBitsMask
operator|=
name|m
operator|-
literal|1
expr_stmt|;
name|this
operator|.
name|valueMask
operator|=
operator|(
literal|1
operator|<<
name|regwidth
operator|)
operator|-
literal|1
expr_stmt|;
name|this
operator|.
name|pwMaxMask
operator|=
name|HLLUtil
operator|.
name|pwMaxMask
argument_list|(
name|regwidth
argument_list|)
expr_stmt|;
name|this
operator|.
name|alphaMSquared
operator|=
name|HLLUtil
operator|.
name|alphaMSquared
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|this
operator|.
name|smallEstimatorCutoff
operator|=
name|HLLUtil
operator|.
name|smallEstimatorCutoff
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|this
operator|.
name|largeEstimatorCutoff
operator|=
name|HLLUtil
operator|.
name|largeEstimatorCutoff
argument_list|(
name|log2m
argument_list|,
name|regwidth
argument_list|)
expr_stmt|;
if|if
condition|(
name|expthresh
operator|==
operator|-
literal|1
condition|)
block|{
name|this
operator|.
name|explicitAuto
operator|=
literal|true
expr_stmt|;
name|this
operator|.
name|explicitOff
operator|=
literal|false
expr_stmt|;
comment|// NOTE:  This math matches the size calculation in the PostgreSQL impl.
specifier|final
name|long
name|fullRepresentationSize
init|=
operator|(
name|this
operator|.
name|regwidth
operator|*
operator|(
name|long
operator|)
name|this
operator|.
name|m
operator|+
literal|7
comment|/*round up to next whole byte*/
operator|)
operator|/
name|Byte
operator|.
name|SIZE
decl_stmt|;
specifier|final
name|int
name|numLongs
init|=
call|(
name|int
call|)
argument_list|(
name|fullRepresentationSize
operator|/
literal|8
comment|/*integer division to round down*/
argument_list|)
decl_stmt|;
if|if
condition|(
name|numLongs
operator|>
name|MAXIMUM_EXPLICIT_THRESHOLD
condition|)
block|{
name|this
operator|.
name|explicitThreshold
operator|=
name|MAXIMUM_EXPLICIT_THRESHOLD
expr_stmt|;
block|}
else|else
block|{
name|this
operator|.
name|explicitThreshold
operator|=
name|numLongs
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|expthresh
operator|==
literal|0
condition|)
block|{
name|this
operator|.
name|explicitAuto
operator|=
literal|false
expr_stmt|;
name|this
operator|.
name|explicitOff
operator|=
literal|true
expr_stmt|;
name|this
operator|.
name|explicitThreshold
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|expthresh
operator|>
literal|0
operator|)
operator|&&
operator|(
name|expthresh
operator|<=
name|MAXIMUM_EXPTHRESH_PARAM
operator|)
condition|)
block|{
name|this
operator|.
name|explicitAuto
operator|=
literal|false
expr_stmt|;
name|this
operator|.
name|explicitOff
operator|=
literal|false
expr_stmt|;
name|this
operator|.
name|explicitThreshold
operator|=
operator|(
literal|1
operator|<<
operator|(
name|expthresh
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"'expthresh' must be at least "
operator|+
name|MINIMUM_EXPTHRESH_PARAM
operator|+
literal|" and at most "
operator|+
name|MAXIMUM_EXPTHRESH_PARAM
operator|+
literal|" (was: "
operator|+
name|expthresh
operator|+
literal|")"
argument_list|)
throw|;
block|}
name|this
operator|.
name|shortWordLength
operator|=
operator|(
name|regwidth
operator|+
name|log2m
operator|)
expr_stmt|;
name|this
operator|.
name|sparseOff
operator|=
operator|!
name|sparseon
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|sparseOff
condition|)
block|{
name|this
operator|.
name|sparseThreshold
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|// TODO improve this cutoff to include the cost overhead of Java
comment|//      members/objects
specifier|final
name|int
name|largestPow2LessThanCutoff
init|=
operator|(
name|int
operator|)
name|NumberUtil
operator|.
name|log2
argument_list|(
operator|(
name|this
operator|.
name|m
operator|*
name|this
operator|.
name|regwidth
operator|)
operator|/
name|this
operator|.
name|shortWordLength
argument_list|)
decl_stmt|;
name|this
operator|.
name|sparseThreshold
operator|=
operator|(
literal|1
operator|<<
name|largestPow2LessThanCutoff
operator|)
expr_stmt|;
block|}
name|initializeStorage
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
comment|/**      *  Construct an empty HLL with the given {@code log2m} and {@code regwidth}.      *      *  This is equivalent to calling<code>HLL(log2m, regwidth, -1, true, HLLType.EMPTY)</code>.      *      * @param log2m log-base-2 of the number of registers used in the HyperLogLog      *        algorithm. Must be at least 4 and at most 30.      * @param regwidth number of bits used per register in the HyperLogLog      *        algorithm. Must be at least 1 and at most 8.      *      * @see #HLL(int, int, int, boolean, HLLType)      */
DECL|method|HLL
specifier|public
name|HLL
parameter_list|(
specifier|final
name|int
name|log2m
parameter_list|,
specifier|final
name|int
name|regwidth
parameter_list|)
block|{
name|this
argument_list|(
name|log2m
argument_list|,
name|regwidth
argument_list|,
operator|-
literal|1
argument_list|,
literal|true
argument_list|,
name|HLLType
operator|.
name|EMPTY
argument_list|)
expr_stmt|;
block|}
comment|// -------------------------------------------------------------------------
comment|/**      * Convenience constructor for testing. Assumes that both {@link HLLType#EXPLICIT}      * and {@link HLLType#SPARSE} representations should be enabled.      *      * @param log2m log-base-2 of the number of registers used in the HyperLogLog      *        algorithm. Must be at least 4 and at most 30.      * @param regwidth number of bits used per register in the HyperLogLog      *        algorithm. Must be at least 1 and at most 8.      * @param explicitThreshold cardinality threshold at which the {@link HLLType#EXPLICIT}      *        representation should be promoted to {@link HLLType#SPARSE}.      *        This must be greater than zero and less than or equal to {@value #MAXIMUM_EXPLICIT_THRESHOLD}.      * @param sparseThreshold register count threshold at which the {@link HLLType#SPARSE}      *        representation should be promoted to {@link HLLType#FULL}.      *        This must be greater than zero.      * @param type the type in the promotion hierarchy which this instance should      *        start at. This cannot be<code>null</code>.      */
DECL|method|HLL
comment|/*package, for testing*/
name|HLL
parameter_list|(
specifier|final
name|int
name|log2m
parameter_list|,
specifier|final
name|int
name|regwidth
parameter_list|,
specifier|final
name|int
name|explicitThreshold
parameter_list|,
specifier|final
name|int
name|sparseThreshold
parameter_list|,
specifier|final
name|HLLType
name|type
parameter_list|)
block|{
name|this
operator|.
name|log2m
operator|=
name|log2m
expr_stmt|;
if|if
condition|(
operator|(
name|log2m
operator|<
name|MINIMUM_LOG2M_PARAM
operator|)
operator|||
operator|(
name|log2m
operator|>
name|MAXIMUM_LOG2M_PARAM
operator|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"'log2m' must be at least "
operator|+
name|MINIMUM_LOG2M_PARAM
operator|+
literal|" and at most "
operator|+
name|MAXIMUM_LOG2M_PARAM
operator|+
literal|" (was: "
operator|+
name|log2m
operator|+
literal|")"
argument_list|)
throw|;
block|}
name|this
operator|.
name|regwidth
operator|=
name|regwidth
expr_stmt|;
if|if
condition|(
operator|(
name|regwidth
operator|<
name|MINIMUM_REGWIDTH_PARAM
operator|)
operator|||
operator|(
name|regwidth
operator|>
name|MAXIMUM_REGWIDTH_PARAM
operator|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"'regwidth' must be at least "
operator|+
name|MINIMUM_REGWIDTH_PARAM
operator|+
literal|" and at most "
operator|+
name|MAXIMUM_REGWIDTH_PARAM
operator|+
literal|" (was: "
operator|+
name|regwidth
operator|+
literal|")"
argument_list|)
throw|;
block|}
name|this
operator|.
name|m
operator|=
operator|(
literal|1
operator|<<
name|log2m
operator|)
expr_stmt|;
name|this
operator|.
name|mBitsMask
operator|=
name|m
operator|-
literal|1
expr_stmt|;
name|this
operator|.
name|valueMask
operator|=
operator|(
literal|1
operator|<<
name|regwidth
operator|)
operator|-
literal|1
expr_stmt|;
name|this
operator|.
name|pwMaxMask
operator|=
name|HLLUtil
operator|.
name|pwMaxMask
argument_list|(
name|regwidth
argument_list|)
expr_stmt|;
name|this
operator|.
name|alphaMSquared
operator|=
name|HLLUtil
operator|.
name|alphaMSquared
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|this
operator|.
name|smallEstimatorCutoff
operator|=
name|HLLUtil
operator|.
name|smallEstimatorCutoff
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|this
operator|.
name|largeEstimatorCutoff
operator|=
name|HLLUtil
operator|.
name|largeEstimatorCutoff
argument_list|(
name|log2m
argument_list|,
name|regwidth
argument_list|)
expr_stmt|;
name|this
operator|.
name|explicitAuto
operator|=
literal|false
expr_stmt|;
name|this
operator|.
name|explicitOff
operator|=
literal|false
expr_stmt|;
name|this
operator|.
name|explicitThreshold
operator|=
name|explicitThreshold
expr_stmt|;
if|if
condition|(
operator|(
name|explicitThreshold
operator|<
literal|1
operator|)
operator|||
operator|(
name|explicitThreshold
operator|>
name|MAXIMUM_EXPLICIT_THRESHOLD
operator|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"'explicitThreshold' must be at least 1 and at most "
operator|+
name|MAXIMUM_EXPLICIT_THRESHOLD
operator|+
literal|" (was: "
operator|+
name|explicitThreshold
operator|+
literal|")"
argument_list|)
throw|;
block|}
name|this
operator|.
name|shortWordLength
operator|=
operator|(
name|regwidth
operator|+
name|log2m
operator|)
expr_stmt|;
name|this
operator|.
name|sparseOff
operator|=
literal|false
expr_stmt|;
name|this
operator|.
name|sparseThreshold
operator|=
name|sparseThreshold
expr_stmt|;
name|initializeStorage
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
comment|/**      * @return the type in the promotion hierarchy of this instance. This will      *         never be<code>null</code>.      */
DECL|method|getType
specifier|public
name|HLLType
name|getType
parameter_list|()
block|{
return|return
name|type
return|;
block|}
comment|// ========================================================================
comment|// Add
comment|/**      * Adds<code>rawValue</code> directly to the HLL.      *      * @param  rawValue the value to be added. It is very important that this      *         value<em>already be hashed</em> with a strong (but not      *         necessarily cryptographic) hash function. For instance, the      *         Murmur3 implementation in      *<a href="http://guava-libraries.googlecode.com/git/guava/src/com/google/common/hash/Murmur3_128HashFunction.java">      *         Google's Guava</a> library is an excellent hash function for this      *         purpose and, for seeds greater than zero, matches the output      *         of the hash provided in the PostgreSQL implementation.      */
DECL|method|addRaw
specifier|public
name|void
name|addRaw
parameter_list|(
specifier|final
name|long
name|rawValue
parameter_list|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|EMPTY
case|:
block|{
comment|// NOTE:  EMPTY type is always promoted on #addRaw()
if|if
condition|(
name|explicitThreshold
operator|>
literal|0
condition|)
block|{
name|initializeStorage
argument_list|(
name|HLLType
operator|.
name|EXPLICIT
argument_list|)
expr_stmt|;
name|explicitStorage
operator|.
name|add
argument_list|(
name|rawValue
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|sparseOff
condition|)
block|{
name|initializeStorage
argument_list|(
name|HLLType
operator|.
name|SPARSE
argument_list|)
expr_stmt|;
name|addRawSparseProbabilistic
argument_list|(
name|rawValue
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|initializeStorage
argument_list|(
name|HLLType
operator|.
name|FULL
argument_list|)
expr_stmt|;
name|addRawProbabilistic
argument_list|(
name|rawValue
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
case|case
name|EXPLICIT
case|:
block|{
name|explicitStorage
operator|.
name|add
argument_list|(
name|rawValue
argument_list|)
expr_stmt|;
comment|// promotion, if necessary
if|if
condition|(
name|explicitStorage
operator|.
name|size
argument_list|()
operator|>
name|explicitThreshold
condition|)
block|{
if|if
condition|(
operator|!
name|sparseOff
condition|)
block|{
name|initializeStorage
argument_list|(
name|HLLType
operator|.
name|SPARSE
argument_list|)
expr_stmt|;
for|for
control|(
name|LongCursor
name|c
range|:
name|explicitStorage
control|)
block|{
name|addRawSparseProbabilistic
argument_list|(
name|c
operator|.
name|value
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|initializeStorage
argument_list|(
name|HLLType
operator|.
name|FULL
argument_list|)
expr_stmt|;
for|for
control|(
name|LongCursor
name|c
range|:
name|explicitStorage
control|)
block|{
name|addRawProbabilistic
argument_list|(
name|c
operator|.
name|value
argument_list|)
expr_stmt|;
block|}
block|}
name|explicitStorage
operator|=
literal|null
expr_stmt|;
block|}
return|return;
block|}
case|case
name|SPARSE
case|:
block|{
name|addRawSparseProbabilistic
argument_list|(
name|rawValue
argument_list|)
expr_stmt|;
comment|// promotion, if necessary
if|if
condition|(
name|sparseProbabilisticStorage
operator|.
name|size
argument_list|()
operator|>
name|sparseThreshold
condition|)
block|{
name|initializeStorage
argument_list|(
name|HLLType
operator|.
name|FULL
argument_list|)
expr_stmt|;
for|for
control|(
name|IntByteCursor
name|c
range|:
name|sparseProbabilisticStorage
control|)
block|{
specifier|final
name|int
name|registerIndex
init|=
name|c
operator|.
name|key
decl_stmt|;
specifier|final
name|byte
name|registerValue
init|=
name|c
operator|.
name|value
decl_stmt|;
name|probabilisticStorage
operator|.
name|setMaxRegister
argument_list|(
name|registerIndex
argument_list|,
name|registerValue
argument_list|)
expr_stmt|;
block|}
name|sparseProbabilisticStorage
operator|=
literal|null
expr_stmt|;
block|}
return|return;
block|}
case|case
name|FULL
case|:
name|addRawProbabilistic
argument_list|(
name|rawValue
argument_list|)
expr_stmt|;
return|return;
default|default:
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Unsupported HLL type "
operator|+
name|type
argument_list|)
throw|;
block|}
block|}
comment|// ------------------------------------------------------------------------
comment|// #addRaw(..) helpers
comment|/**      * Adds the raw value to the {@link #sparseProbabilisticStorage}.      * {@link #type} must be {@link HLLType#SPARSE}.      *      * @param rawValue the raw value to add to the sparse storage.      */
DECL|method|addRawSparseProbabilistic
specifier|private
name|void
name|addRawSparseProbabilistic
parameter_list|(
specifier|final
name|long
name|rawValue
parameter_list|)
block|{
comment|// p(w): position of the least significant set bit (one-indexed)
comment|// By contract: p(w)<= 2^(registerValueInBits) - 1 (the max register value)
comment|//
comment|// By construction of pwMaxMask (see #Constructor()),
comment|//      lsb(pwMaxMask) = 2^(registerValueInBits) - 2,
comment|// thus lsb(any_long | pwMaxMask)<= 2^(registerValueInBits) - 2,
comment|// thus 1 + lsb(any_long | pwMaxMask)<= 2^(registerValueInBits) -1.
specifier|final
name|long
name|substreamValue
init|=
operator|(
name|rawValue
operator|>>>
name|log2m
operator|)
decl_stmt|;
specifier|final
name|byte
name|p_w
decl_stmt|;
if|if
condition|(
name|substreamValue
operator|==
literal|0L
condition|)
block|{
comment|// The paper does not cover p(0x0), so the special value 0 is used.
comment|// 0 is the original initialization value of the registers, so by
comment|// doing this the multiset simply ignores it. This is acceptable
comment|// because the probability is 1/(2^(2^registerSizeInBits)).
name|p_w
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|p_w
operator|=
call|(
name|byte
call|)
argument_list|(
literal|1
operator|+
name|BitUtil
operator|.
name|leastSignificantBit
argument_list|(
name|substreamValue
operator||
name|pwMaxMask
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// Short-circuit if the register is being set to zero, since algorithmically
comment|// this corresponds to an "unset" register, and "unset" registers aren't
comment|// stored to save memory. (The very reason this sparse implementation
comment|// exists.) If a register is set to zero it will break the #algorithmCardinality
comment|// code.
if|if
condition|(
name|p_w
operator|==
literal|0
condition|)
block|{
return|return;
block|}
comment|// NOTE:  no +1 as in paper since 0-based indexing
specifier|final
name|int
name|j
init|=
call|(
name|int
call|)
argument_list|(
name|rawValue
operator|&
name|mBitsMask
argument_list|)
decl_stmt|;
specifier|final
name|byte
name|currentValue
decl_stmt|;
specifier|final
name|int
name|index
init|=
name|sparseProbabilisticStorage
operator|.
name|indexOf
argument_list|(
name|j
argument_list|)
decl_stmt|;
if|if
condition|(
name|index
operator|>=
literal|0
condition|)
block|{
name|currentValue
operator|=
name|sparseProbabilisticStorage
operator|.
name|indexGet
argument_list|(
name|index
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|currentValue
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|p_w
operator|>
name|currentValue
condition|)
block|{
name|sparseProbabilisticStorage
operator|.
name|put
argument_list|(
name|j
argument_list|,
name|p_w
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Adds the raw value to the {@link #probabilisticStorage}.      * {@link #type} must be {@link HLLType#FULL}.      *      * @param rawValue the raw value to add to the full probabilistic storage.      */
DECL|method|addRawProbabilistic
specifier|private
name|void
name|addRawProbabilistic
parameter_list|(
specifier|final
name|long
name|rawValue
parameter_list|)
block|{
comment|// p(w): position of the least significant set bit (one-indexed)
comment|// By contract: p(w)<= 2^(registerValueInBits) - 1 (the max register value)
comment|//
comment|// By construction of pwMaxMask (see #Constructor()),
comment|//      lsb(pwMaxMask) = 2^(registerValueInBits) - 2,
comment|// thus lsb(any_long | pwMaxMask)<= 2^(registerValueInBits) - 2,
comment|// thus 1 + lsb(any_long | pwMaxMask)<= 2^(registerValueInBits) -1.
specifier|final
name|long
name|substreamValue
init|=
operator|(
name|rawValue
operator|>>>
name|log2m
operator|)
decl_stmt|;
specifier|final
name|byte
name|p_w
decl_stmt|;
if|if
condition|(
name|substreamValue
operator|==
literal|0L
condition|)
block|{
comment|// The paper does not cover p(0x0), so the special value 0 is used.
comment|// 0 is the original initialization value of the registers, so by
comment|// doing this the multiset simply ignores it. This is acceptable
comment|// because the probability is 1/(2^(2^registerSizeInBits)).
name|p_w
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|p_w
operator|=
call|(
name|byte
call|)
argument_list|(
literal|1
operator|+
name|BitUtil
operator|.
name|leastSignificantBit
argument_list|(
name|substreamValue
operator||
name|pwMaxMask
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// Short-circuit if the register is being set to zero, since algorithmically
comment|// this corresponds to an "unset" register, and "unset" registers aren't
comment|// stored to save memory. (The very reason this sparse implementation
comment|// exists.) If a register is set to zero it will break the #algorithmCardinality
comment|// code.
if|if
condition|(
name|p_w
operator|==
literal|0
condition|)
block|{
return|return;
block|}
comment|// NOTE:  no +1 as in paper since 0-based indexing
specifier|final
name|int
name|j
init|=
call|(
name|int
call|)
argument_list|(
name|rawValue
operator|&
name|mBitsMask
argument_list|)
decl_stmt|;
name|probabilisticStorage
operator|.
name|setMaxRegister
argument_list|(
name|j
argument_list|,
name|p_w
argument_list|)
expr_stmt|;
block|}
comment|// ------------------------------------------------------------------------
comment|// Storage helper
comment|/**      * Initializes storage for the specified {@link HLLType} and changes the      * instance's {@link #type}.      *      * @param type the {@link HLLType} to initialize storage for. This cannot be      *<code>null</code> and must be an instantiable type.      */
DECL|method|initializeStorage
specifier|private
name|void
name|initializeStorage
parameter_list|(
specifier|final
name|HLLType
name|type
parameter_list|)
block|{
name|this
operator|.
name|type
operator|=
name|type
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|EMPTY
case|:
comment|// nothing to be done
break|break;
case|case
name|EXPLICIT
case|:
name|this
operator|.
name|explicitStorage
operator|=
operator|new
name|LongHashSet
argument_list|()
expr_stmt|;
break|break;
case|case
name|SPARSE
case|:
name|this
operator|.
name|sparseProbabilisticStorage
operator|=
operator|new
name|IntByteHashMap
argument_list|()
expr_stmt|;
break|break;
case|case
name|FULL
case|:
name|this
operator|.
name|probabilisticStorage
operator|=
operator|new
name|BitVector
argument_list|(
name|regwidth
argument_list|,
name|m
argument_list|)
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Unsupported HLL type "
operator|+
name|type
argument_list|)
throw|;
block|}
block|}
comment|// ========================================================================
comment|// Cardinality
comment|/**      * Computes the cardinality of the HLL.      *      * @return the cardinality of HLL. This will never be negative.      */
DECL|method|cardinality
specifier|public
name|long
name|cardinality
parameter_list|()
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|EMPTY
case|:
return|return
literal|0
comment|/*by definition*/
return|;
case|case
name|EXPLICIT
case|:
return|return
name|explicitStorage
operator|.
name|size
argument_list|()
return|;
case|case
name|SPARSE
case|:
return|return
operator|(
name|long
operator|)
name|Math
operator|.
name|ceil
argument_list|(
name|sparseProbabilisticAlgorithmCardinality
argument_list|()
argument_list|)
return|;
case|case
name|FULL
case|:
return|return
operator|(
name|long
operator|)
name|Math
operator|.
name|ceil
argument_list|(
name|fullProbabilisticAlgorithmCardinality
argument_list|()
argument_list|)
return|;
default|default:
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Unsupported HLL type "
operator|+
name|type
argument_list|)
throw|;
block|}
block|}
comment|// ------------------------------------------------------------------------
comment|// Cardinality helpers
comment|/**      * Computes the exact cardinality value returned by the HLL algorithm when      * represented as a {@link HLLType#SPARSE} HLL. Kept      * separate from {@link #cardinality()} for testing purposes. {@link #type}      * must be {@link HLLType#SPARSE}.      *      * @return the exact, unrounded cardinality given by the HLL algorithm      */
DECL|method|sparseProbabilisticAlgorithmCardinality
comment|/*package, for testing*/
name|double
name|sparseProbabilisticAlgorithmCardinality
parameter_list|()
block|{
specifier|final
name|int
name|m
init|=
name|this
operator|.
name|m
comment|/*for performance*/
decl_stmt|;
comment|// compute the "indicator function" -- sum(2^(-M[j])) where M[j] is the
comment|// 'j'th register value
name|double
name|sum
init|=
literal|0
decl_stmt|;
name|int
name|numberOfZeroes
init|=
literal|0
comment|/*"V" in the paper*/
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|m
condition|;
name|j
operator|++
control|)
block|{
specifier|final
name|long
name|register
decl_stmt|;
if|if
condition|(
name|sparseProbabilisticStorage
operator|.
name|containsKey
argument_list|(
name|j
argument_list|)
condition|)
block|{
name|register
operator|=
name|sparseProbabilisticStorage
operator|.
name|get
argument_list|(
name|j
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|register
operator|=
literal|0
expr_stmt|;
block|}
name|sum
operator|+=
literal|1.0
operator|/
operator|(
literal|1L
operator|<<
name|register
operator|)
expr_stmt|;
if|if
condition|(
name|register
operator|==
literal|0L
condition|)
name|numberOfZeroes
operator|++
expr_stmt|;
block|}
comment|// apply the estimate and correction to the indicator function
specifier|final
name|double
name|estimator
init|=
name|alphaMSquared
operator|/
name|sum
decl_stmt|;
if|if
condition|(
operator|(
name|numberOfZeroes
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|estimator
operator|<
name|smallEstimatorCutoff
operator|)
condition|)
block|{
return|return
name|HLLUtil
operator|.
name|smallEstimator
argument_list|(
name|m
argument_list|,
name|numberOfZeroes
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|estimator
operator|<=
name|largeEstimatorCutoff
condition|)
block|{
return|return
name|estimator
return|;
block|}
else|else
block|{
return|return
name|HLLUtil
operator|.
name|largeEstimator
argument_list|(
name|log2m
argument_list|,
name|regwidth
argument_list|,
name|estimator
argument_list|)
return|;
block|}
block|}
comment|/**      * Computes the exact cardinality value returned by the HLL algorithm when      * represented as a {@link HLLType#FULL} HLL. Kept      * separate from {@link #cardinality()} for testing purposes. {@link #type}      * must be {@link HLLType#FULL}.      *      * @return the exact, unrounded cardinality given by the HLL algorithm      */
DECL|method|fullProbabilisticAlgorithmCardinality
comment|/*package, for testing*/
name|double
name|fullProbabilisticAlgorithmCardinality
parameter_list|()
block|{
specifier|final
name|int
name|m
init|=
name|this
operator|.
name|m
comment|/*for performance*/
decl_stmt|;
comment|// compute the "indicator function" -- sum(2^(-M[j])) where M[j] is the
comment|// 'j'th register value
name|double
name|sum
init|=
literal|0
decl_stmt|;
name|int
name|numberOfZeroes
init|=
literal|0
comment|/*"V" in the paper*/
decl_stmt|;
specifier|final
name|LongIterator
name|iterator
init|=
name|probabilisticStorage
operator|.
name|registerIterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|iterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
specifier|final
name|long
name|register
init|=
name|iterator
operator|.
name|next
argument_list|()
decl_stmt|;
name|sum
operator|+=
literal|1.0
operator|/
operator|(
literal|1L
operator|<<
name|register
operator|)
expr_stmt|;
if|if
condition|(
name|register
operator|==
literal|0L
condition|)
name|numberOfZeroes
operator|++
expr_stmt|;
block|}
comment|// apply the estimate and correction to the indicator function
specifier|final
name|double
name|estimator
init|=
name|alphaMSquared
operator|/
name|sum
decl_stmt|;
if|if
condition|(
operator|(
name|numberOfZeroes
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|estimator
operator|<
name|smallEstimatorCutoff
operator|)
condition|)
block|{
return|return
name|HLLUtil
operator|.
name|smallEstimator
argument_list|(
name|m
argument_list|,
name|numberOfZeroes
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|estimator
operator|<=
name|largeEstimatorCutoff
condition|)
block|{
return|return
name|estimator
return|;
block|}
else|else
block|{
return|return
name|HLLUtil
operator|.
name|largeEstimator
argument_list|(
name|log2m
argument_list|,
name|regwidth
argument_list|,
name|estimator
argument_list|)
return|;
block|}
block|}
comment|// ========================================================================
comment|// Clear
comment|/**      * Clears the HLL. The HLL will have cardinality zero and will act as if no      * elements have been added.      *      * NOTE: Unlike {@link #addRaw(long)},<code>clear</code> does NOT handle      * transitions between {@link HLLType}s - a probabilistic type will remain      * probabilistic after being cleared.      */
DECL|method|clear
specifier|public
name|void
name|clear
parameter_list|()
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|EMPTY
case|:
return|return
comment|/*do nothing*/
return|;
case|case
name|EXPLICIT
case|:
name|explicitStorage
operator|.
name|clear
argument_list|()
expr_stmt|;
return|return;
case|case
name|SPARSE
case|:
name|sparseProbabilisticStorage
operator|.
name|clear
argument_list|()
expr_stmt|;
return|return;
case|case
name|FULL
case|:
name|probabilisticStorage
operator|.
name|fill
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return;
default|default:
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Unsupported HLL type "
operator|+
name|type
argument_list|)
throw|;
block|}
block|}
comment|// ========================================================================
comment|// Union
comment|/**      * Computes the union of HLLs and stores the result in this instance.      *      * @param other the other {@link HLL} instance to union into this one. This      *        cannot be<code>null</code>.      */
DECL|method|union
specifier|public
name|void
name|union
parameter_list|(
specifier|final
name|HLL
name|other
parameter_list|)
block|{
comment|// TODO: verify HLLs are compatible
specifier|final
name|HLLType
name|otherType
init|=
name|other
operator|.
name|getType
argument_list|()
decl_stmt|;
if|if
condition|(
name|type
operator|.
name|equals
argument_list|(
name|otherType
argument_list|)
condition|)
block|{
name|homogeneousUnion
argument_list|(
name|other
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
name|heterogenousUnion
argument_list|(
name|other
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|// ------------------------------------------------------------------------
comment|// Union helpers
comment|/**      * Computes the union of two HLLs, of different types, and stores the      * result in this instance.      *      * @param other the other {@link HLL} instance to union into this one. This      *        cannot be<code>null</code>.      */
DECL|method|heterogenousUnion
comment|/*package, for testing*/
name|void
name|heterogenousUnion
parameter_list|(
specifier|final
name|HLL
name|other
parameter_list|)
block|{
comment|/*          * The logic here is divided into two sections: unions with an EMPTY          * HLL, and unions between EXPLICIT/SPARSE/FULL          * HLL.          *          * Between those two sections, all possible heterogeneous unions are          * covered. Should another type be added to HLLType whose unions          * are not easily reduced (say, as EMPTY's are below) this may be more          * easily implemented as Strategies. However, that is unnecessary as it          * stands.          */
comment|// ....................................................................
comment|// Union with an EMPTY
if|if
condition|(
name|HLLType
operator|.
name|EMPTY
operator|.
name|equals
argument_list|(
name|type
argument_list|)
condition|)
block|{
comment|// NOTE:  The union of empty with non-empty HLL is just a
comment|//        clone of the non-empty.
switch|switch
condition|(
name|other
operator|.
name|getType
argument_list|()
condition|)
block|{
case|case
name|EXPLICIT
case|:
block|{
comment|// src:  EXPLICIT
comment|// dest: EMPTY
if|if
condition|(
name|other
operator|.
name|explicitStorage
operator|.
name|size
argument_list|()
operator|<=
name|explicitThreshold
condition|)
block|{
name|type
operator|=
name|HLLType
operator|.
name|EXPLICIT
expr_stmt|;
name|explicitStorage
operator|=
name|other
operator|.
name|explicitStorage
operator|.
name|clone
argument_list|()
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|sparseOff
condition|)
block|{
name|initializeStorage
argument_list|(
name|HLLType
operator|.
name|SPARSE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|initializeStorage
argument_list|(
name|HLLType
operator|.
name|FULL
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|LongCursor
name|c
range|:
name|other
operator|.
name|explicitStorage
control|)
block|{
name|addRaw
argument_list|(
name|c
operator|.
name|value
argument_list|)
expr_stmt|;
block|}
block|}
return|return;
block|}
case|case
name|SPARSE
case|:
block|{
comment|// src:  SPARSE
comment|// dest: EMPTY
if|if
condition|(
operator|!
name|sparseOff
condition|)
block|{
name|type
operator|=
name|HLLType
operator|.
name|SPARSE
expr_stmt|;
name|sparseProbabilisticStorage
operator|=
name|other
operator|.
name|sparseProbabilisticStorage
operator|.
name|clone
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|initializeStorage
argument_list|(
name|HLLType
operator|.
name|FULL
argument_list|)
expr_stmt|;
for|for
control|(
name|IntByteCursor
name|c
range|:
name|other
operator|.
name|sparseProbabilisticStorage
control|)
block|{
specifier|final
name|int
name|registerIndex
init|=
name|c
operator|.
name|key
decl_stmt|;
specifier|final
name|byte
name|registerValue
init|=
name|c
operator|.
name|value
decl_stmt|;
name|probabilisticStorage
operator|.
name|setMaxRegister
argument_list|(
name|registerIndex
argument_list|,
name|registerValue
argument_list|)
expr_stmt|;
block|}
block|}
return|return;
block|}
default|default
comment|/*case FULL*/
default|:
block|{
comment|// src:  FULL
comment|// dest: EMPTY
name|type
operator|=
name|HLLType
operator|.
name|FULL
expr_stmt|;
name|probabilisticStorage
operator|=
name|other
operator|.
name|probabilisticStorage
operator|.
name|clone
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|HLLType
operator|.
name|EMPTY
operator|.
name|equals
argument_list|(
name|other
operator|.
name|getType
argument_list|()
argument_list|)
condition|)
block|{
comment|// source is empty, so just return destination since it is unchanged
return|return;
block|}
comment|/* else -- both of the sets are not empty */
comment|// ....................................................................
comment|// NOTE: Since EMPTY is handled above, the HLLs are non-EMPTY below
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|EXPLICIT
case|:
block|{
comment|// src:  FULL/SPARSE
comment|// dest: EXPLICIT
comment|// "Storing into destination" cannot be done (since destination
comment|// is by definition of smaller capacity than source), so a clone
comment|// of source is made and values from destination are inserted
comment|// into that.
comment|// Determine source and destination storage.
comment|// NOTE:  destination storage may change through promotion if
comment|//        source is SPARSE.
if|if
condition|(
name|HLLType
operator|.
name|SPARSE
operator|.
name|equals
argument_list|(
name|other
operator|.
name|getType
argument_list|()
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|sparseOff
condition|)
block|{
name|type
operator|=
name|HLLType
operator|.
name|SPARSE
expr_stmt|;
name|sparseProbabilisticStorage
operator|=
name|other
operator|.
name|sparseProbabilisticStorage
operator|.
name|clone
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|initializeStorage
argument_list|(
name|HLLType
operator|.
name|FULL
argument_list|)
expr_stmt|;
for|for
control|(
name|IntByteCursor
name|c
range|:
name|other
operator|.
name|sparseProbabilisticStorage
control|)
block|{
specifier|final
name|int
name|registerIndex
init|=
name|c
operator|.
name|key
decl_stmt|;
specifier|final
name|byte
name|registerValue
init|=
name|c
operator|.
name|value
decl_stmt|;
name|probabilisticStorage
operator|.
name|setMaxRegister
argument_list|(
name|registerIndex
argument_list|,
name|registerValue
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
comment|/*source is HLLType.FULL*/
block|{
name|type
operator|=
name|HLLType
operator|.
name|FULL
expr_stmt|;
name|probabilisticStorage
operator|=
name|other
operator|.
name|probabilisticStorage
operator|.
name|clone
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|LongCursor
name|c
range|:
name|explicitStorage
control|)
block|{
name|addRaw
argument_list|(
name|c
operator|.
name|value
argument_list|)
expr_stmt|;
block|}
name|explicitStorage
operator|=
literal|null
expr_stmt|;
return|return;
block|}
case|case
name|SPARSE
case|:
block|{
if|if
condition|(
name|HLLType
operator|.
name|EXPLICIT
operator|.
name|equals
argument_list|(
name|other
operator|.
name|getType
argument_list|()
argument_list|)
condition|)
block|{
comment|// src:  EXPLICIT
comment|// dest: SPARSE
comment|// Add the raw values from the source to the destination.
for|for
control|(
name|LongCursor
name|c
range|:
name|other
operator|.
name|explicitStorage
control|)
block|{
name|addRaw
argument_list|(
name|c
operator|.
name|value
argument_list|)
expr_stmt|;
block|}
comment|// NOTE:  addRaw will handle promotion cleanup
block|}
else|else
comment|/*source is HLLType.FULL*/
block|{
comment|// src:  FULL
comment|// dest: SPARSE
comment|// "Storing into destination" cannot be done (since destination
comment|// is by definition of smaller capacity than source), so a
comment|// clone of source is made and registers from the destination
comment|// are merged into the clone.
name|type
operator|=
name|HLLType
operator|.
name|FULL
expr_stmt|;
name|probabilisticStorage
operator|=
name|other
operator|.
name|probabilisticStorage
operator|.
name|clone
argument_list|()
expr_stmt|;
for|for
control|(
name|IntByteCursor
name|c
range|:
name|sparseProbabilisticStorage
control|)
block|{
specifier|final
name|int
name|registerIndex
init|=
name|c
operator|.
name|key
decl_stmt|;
specifier|final
name|byte
name|registerValue
init|=
name|c
operator|.
name|value
decl_stmt|;
name|probabilisticStorage
operator|.
name|setMaxRegister
argument_list|(
name|registerIndex
argument_list|,
name|registerValue
argument_list|)
expr_stmt|;
block|}
name|sparseProbabilisticStorage
operator|=
literal|null
expr_stmt|;
block|}
return|return;
block|}
default|default
comment|/*destination is HLLType.FULL*/
default|:
block|{
if|if
condition|(
name|HLLType
operator|.
name|EXPLICIT
operator|.
name|equals
argument_list|(
name|other
operator|.
name|getType
argument_list|()
argument_list|)
condition|)
block|{
comment|// src:  EXPLICIT
comment|// dest: FULL
comment|// Add the raw values from the source to the destination.
comment|// Promotion is not possible, so don't bother checking.
for|for
control|(
name|LongCursor
name|c
range|:
name|other
operator|.
name|explicitStorage
control|)
block|{
name|addRaw
argument_list|(
name|c
operator|.
name|value
argument_list|)
expr_stmt|;
block|}
block|}
else|else
comment|/*source is HLLType.SPARSE*/
block|{
comment|// src:  SPARSE
comment|// dest: FULL
comment|// Merge the registers from the source into the destination.
comment|// Promotion is not possible, so don't bother checking.
for|for
control|(
name|IntByteCursor
name|c
range|:
name|other
operator|.
name|sparseProbabilisticStorage
control|)
block|{
specifier|final
name|int
name|registerIndex
init|=
name|c
operator|.
name|key
decl_stmt|;
specifier|final
name|byte
name|registerValue
init|=
name|c
operator|.
name|value
decl_stmt|;
name|probabilisticStorage
operator|.
name|setMaxRegister
argument_list|(
name|registerIndex
argument_list|,
name|registerValue
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
comment|/**      * Computes the union of two HLLs of the same type, and stores the      * result in this instance.      *      * @param other the other {@link HLL} instance to union into this one. This      *        cannot be<code>null</code>.      */
DECL|method|homogeneousUnion
specifier|private
name|void
name|homogeneousUnion
parameter_list|(
specifier|final
name|HLL
name|other
parameter_list|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|EMPTY
case|:
comment|// union of empty and empty is empty
return|return;
case|case
name|EXPLICIT
case|:
for|for
control|(
name|LongCursor
name|c
range|:
name|other
operator|.
name|explicitStorage
control|)
block|{
name|addRaw
argument_list|(
name|c
operator|.
name|value
argument_list|)
expr_stmt|;
block|}
comment|// NOTE:  #addRaw() will handle promotion, if necessary
return|return;
case|case
name|SPARSE
case|:
for|for
control|(
name|IntByteCursor
name|c
range|:
name|other
operator|.
name|sparseProbabilisticStorage
control|)
block|{
specifier|final
name|int
name|registerIndex
init|=
name|c
operator|.
name|key
decl_stmt|;
specifier|final
name|byte
name|registerValue
init|=
name|c
operator|.
name|value
decl_stmt|;
specifier|final
name|byte
name|currentRegisterValue
init|=
name|sparseProbabilisticStorage
operator|.
name|get
argument_list|(
name|registerIndex
argument_list|)
decl_stmt|;
if|if
condition|(
name|registerValue
operator|>
name|currentRegisterValue
condition|)
block|{
name|sparseProbabilisticStorage
operator|.
name|put
argument_list|(
name|registerIndex
argument_list|,
name|registerValue
argument_list|)
expr_stmt|;
block|}
block|}
comment|// promotion, if necessary
if|if
condition|(
name|sparseProbabilisticStorage
operator|.
name|size
argument_list|()
operator|>
name|sparseThreshold
condition|)
block|{
name|initializeStorage
argument_list|(
name|HLLType
operator|.
name|FULL
argument_list|)
expr_stmt|;
for|for
control|(
name|IntByteCursor
name|c
range|:
name|sparseProbabilisticStorage
control|)
block|{
specifier|final
name|int
name|registerIndex
init|=
name|c
operator|.
name|key
decl_stmt|;
specifier|final
name|byte
name|registerValue
init|=
name|c
operator|.
name|value
decl_stmt|;
name|probabilisticStorage
operator|.
name|setMaxRegister
argument_list|(
name|registerIndex
argument_list|,
name|registerValue
argument_list|)
expr_stmt|;
block|}
name|sparseProbabilisticStorage
operator|=
literal|null
expr_stmt|;
block|}
return|return;
case|case
name|FULL
case|:
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|m
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|long
name|registerValue
init|=
name|other
operator|.
name|probabilisticStorage
operator|.
name|getRegister
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|probabilisticStorage
operator|.
name|setMaxRegister
argument_list|(
name|i
argument_list|,
name|registerValue
argument_list|)
expr_stmt|;
block|}
return|return;
default|default:
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Unsupported HLL type "
operator|+
name|type
argument_list|)
throw|;
block|}
block|}
comment|// ========================================================================
comment|// Serialization
comment|/**      * Serializes the HLL to an array of bytes in correspondence with the format      * of the default schema version, {@link SerializationUtil#DEFAULT_SCHEMA_VERSION}.      *      * @return the array of bytes representing the HLL. This will never be      *<code>null</code> or empty.      */
DECL|method|toBytes
specifier|public
name|byte
index|[]
name|toBytes
parameter_list|()
block|{
return|return
name|toBytes
argument_list|(
name|SerializationUtil
operator|.
name|DEFAULT_SCHEMA_VERSION
argument_list|)
return|;
block|}
comment|/**      * Serializes the HLL to an array of bytes in correspondence with the format      * of the specified schema version.      *      * @param  schemaVersion the schema version dictating the serialization format      * @return the array of bytes representing the HLL. This will never be      *<code>null</code> or empty.      */
DECL|method|toBytes
specifier|public
name|byte
index|[]
name|toBytes
parameter_list|(
specifier|final
name|ISchemaVersion
name|schemaVersion
parameter_list|)
block|{
specifier|final
name|byte
index|[]
name|bytes
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|EMPTY
case|:
name|bytes
operator|=
operator|new
name|byte
index|[
name|schemaVersion
operator|.
name|paddingBytes
argument_list|(
name|type
argument_list|)
index|]
expr_stmt|;
break|break;
case|case
name|EXPLICIT
case|:
block|{
specifier|final
name|IWordSerializer
name|serializer
init|=
name|schemaVersion
operator|.
name|getSerializer
argument_list|(
name|type
argument_list|,
name|Long
operator|.
name|SIZE
argument_list|,
name|explicitStorage
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|long
index|[]
name|values
init|=
name|explicitStorage
operator|.
name|toArray
argument_list|()
decl_stmt|;
name|Arrays
operator|.
name|sort
argument_list|(
name|values
argument_list|)
expr_stmt|;
for|for
control|(
specifier|final
name|long
name|value
range|:
name|values
control|)
block|{
name|serializer
operator|.
name|writeWord
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
name|bytes
operator|=
name|serializer
operator|.
name|getBytes
argument_list|()
expr_stmt|;
break|break;
block|}
case|case
name|SPARSE
case|:
block|{
specifier|final
name|IWordSerializer
name|serializer
init|=
name|schemaVersion
operator|.
name|getSerializer
argument_list|(
name|type
argument_list|,
name|shortWordLength
argument_list|,
name|sparseProbabilisticStorage
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|int
index|[]
name|indices
init|=
name|sparseProbabilisticStorage
operator|.
name|keys
argument_list|()
operator|.
name|toArray
argument_list|()
decl_stmt|;
name|Arrays
operator|.
name|sort
argument_list|(
name|indices
argument_list|)
expr_stmt|;
for|for
control|(
specifier|final
name|int
name|registerIndex
range|:
name|indices
control|)
block|{
assert|assert
name|sparseProbabilisticStorage
operator|.
name|containsKey
argument_list|(
name|registerIndex
argument_list|)
assert|;
specifier|final
name|long
name|registerValue
init|=
name|sparseProbabilisticStorage
operator|.
name|get
argument_list|(
name|registerIndex
argument_list|)
decl_stmt|;
comment|// pack index and value into "short word"
specifier|final
name|long
name|shortWord
init|=
operator|(
operator|(
name|registerIndex
operator|<<
name|regwidth
operator|)
operator||
name|registerValue
operator|)
decl_stmt|;
name|serializer
operator|.
name|writeWord
argument_list|(
name|shortWord
argument_list|)
expr_stmt|;
block|}
name|bytes
operator|=
name|serializer
operator|.
name|getBytes
argument_list|()
expr_stmt|;
break|break;
block|}
case|case
name|FULL
case|:
block|{
specifier|final
name|IWordSerializer
name|serializer
init|=
name|schemaVersion
operator|.
name|getSerializer
argument_list|(
name|type
argument_list|,
name|regwidth
argument_list|,
name|m
argument_list|)
decl_stmt|;
name|probabilisticStorage
operator|.
name|getRegisterContents
argument_list|(
name|serializer
argument_list|)
expr_stmt|;
name|bytes
operator|=
name|serializer
operator|.
name|getBytes
argument_list|()
expr_stmt|;
break|break;
block|}
default|default:
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Unsupported HLL type "
operator|+
name|type
argument_list|)
throw|;
block|}
specifier|final
name|IHLLMetadata
name|metadata
init|=
operator|new
name|HLLMetadata
argument_list|(
name|schemaVersion
operator|.
name|schemaVersionNumber
argument_list|()
argument_list|,
name|type
argument_list|,
name|log2m
argument_list|,
name|regwidth
argument_list|,
operator|(
name|int
operator|)
name|NumberUtil
operator|.
name|log2
argument_list|(
name|explicitThreshold
argument_list|)
argument_list|,
name|explicitOff
argument_list|,
name|explicitAuto
argument_list|,
operator|!
name|sparseOff
argument_list|)
decl_stmt|;
name|schemaVersion
operator|.
name|writeMetadata
argument_list|(
name|bytes
argument_list|,
name|metadata
argument_list|)
expr_stmt|;
return|return
name|bytes
return|;
block|}
comment|/**      * Deserializes the HLL (in {@link #toBytes(ISchemaVersion)} format) serialized      * into<code>bytes</code>.      *      * @param  bytes the serialized bytes of new HLL      * @return the deserialized HLL. This will never be<code>null</code>.      *      * @see #toBytes(ISchemaVersion)      */
DECL|method|fromBytes
specifier|public
specifier|static
name|HLL
name|fromBytes
parameter_list|(
specifier|final
name|byte
index|[]
name|bytes
parameter_list|)
block|{
specifier|final
name|ISchemaVersion
name|schemaVersion
init|=
name|SerializationUtil
operator|.
name|getSchemaVersion
argument_list|(
name|bytes
argument_list|)
decl_stmt|;
specifier|final
name|IHLLMetadata
name|metadata
init|=
name|schemaVersion
operator|.
name|readMetadata
argument_list|(
name|bytes
argument_list|)
decl_stmt|;
specifier|final
name|HLLType
name|type
init|=
name|metadata
operator|.
name|HLLType
argument_list|()
decl_stmt|;
specifier|final
name|int
name|regwidth
init|=
name|metadata
operator|.
name|registerWidth
argument_list|()
decl_stmt|;
specifier|final
name|int
name|log2m
init|=
name|metadata
operator|.
name|registerCountLog2
argument_list|()
decl_stmt|;
specifier|final
name|boolean
name|sparseon
init|=
name|metadata
operator|.
name|sparseEnabled
argument_list|()
decl_stmt|;
specifier|final
name|int
name|expthresh
decl_stmt|;
if|if
condition|(
name|metadata
operator|.
name|explicitAuto
argument_list|()
condition|)
block|{
name|expthresh
operator|=
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|metadata
operator|.
name|explicitOff
argument_list|()
condition|)
block|{
name|expthresh
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|// NOTE: take into account that the postgres-compatible constructor
comment|//       subtracts one before taking a power of two.
name|expthresh
operator|=
name|metadata
operator|.
name|log2ExplicitCutoff
argument_list|()
operator|+
literal|1
expr_stmt|;
block|}
specifier|final
name|HLL
name|hll
init|=
operator|new
name|HLL
argument_list|(
name|log2m
argument_list|,
name|regwidth
argument_list|,
name|expthresh
argument_list|,
name|sparseon
argument_list|,
name|type
argument_list|)
decl_stmt|;
comment|// Short-circuit on empty, which needs no other deserialization.
if|if
condition|(
name|HLLType
operator|.
name|EMPTY
operator|.
name|equals
argument_list|(
name|type
argument_list|)
condition|)
block|{
return|return
name|hll
return|;
block|}
specifier|final
name|int
name|wordLength
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|EXPLICIT
case|:
name|wordLength
operator|=
name|Long
operator|.
name|SIZE
expr_stmt|;
break|break;
case|case
name|SPARSE
case|:
name|wordLength
operator|=
name|hll
operator|.
name|shortWordLength
expr_stmt|;
break|break;
case|case
name|FULL
case|:
name|wordLength
operator|=
name|hll
operator|.
name|regwidth
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Unsupported HLL type "
operator|+
name|type
argument_list|)
throw|;
block|}
specifier|final
name|IWordDeserializer
name|deserializer
init|=
name|schemaVersion
operator|.
name|getDeserializer
argument_list|(
name|type
argument_list|,
name|wordLength
argument_list|,
name|bytes
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|EXPLICIT
case|:
comment|// NOTE:  This should not exceed expthresh and this will always
comment|//        be exactly the number of words that were encoded,
comment|//        because the word length is at least a byte wide.
comment|// SEE:   IWordDeserializer#totalWordCount()
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|deserializer
operator|.
name|totalWordCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|hll
operator|.
name|explicitStorage
operator|.
name|add
argument_list|(
name|deserializer
operator|.
name|readWord
argument_list|()
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SPARSE
case|:
comment|// NOTE:  If the shortWordLength were smaller than 8 bits
comment|//        (1 byte) there would be a possibility (because of
comment|//        padding arithmetic) of having one or more extra
comment|//        registers read. However, this is not relevant as the
comment|//        extra registers will be all zeroes, which are ignored
comment|//        in the sparse representation.
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|deserializer
operator|.
name|totalWordCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|long
name|shortWord
init|=
name|deserializer
operator|.
name|readWord
argument_list|()
decl_stmt|;
specifier|final
name|byte
name|registerValue
init|=
call|(
name|byte
call|)
argument_list|(
name|shortWord
operator|&
name|hll
operator|.
name|valueMask
argument_list|)
decl_stmt|;
comment|// Only set non-zero registers.
if|if
condition|(
name|registerValue
operator|!=
literal|0
condition|)
block|{
name|hll
operator|.
name|sparseProbabilisticStorage
operator|.
name|put
argument_list|(
call|(
name|int
call|)
argument_list|(
name|shortWord
operator|>>>
name|hll
operator|.
name|regwidth
argument_list|)
argument_list|,
name|registerValue
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|FULL
case|:
comment|// NOTE:  Iteration is done using m (register count) and NOT
comment|//        deserializer#totalWordCount() because regwidth may be
comment|//        less than 8 and as such the padding on the 'last' byte
comment|//        may be larger than regwidth, causing an extra register
comment|//        to be read.
comment|// SEE: IWordDeserializer#totalWordCount()
for|for
control|(
name|long
name|i
init|=
literal|0
init|;
name|i
operator|<
name|hll
operator|.
name|m
condition|;
name|i
operator|++
control|)
block|{
name|hll
operator|.
name|probabilisticStorage
operator|.
name|setRegister
argument_list|(
name|i
argument_list|,
name|deserializer
operator|.
name|readWord
argument_list|()
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Unsupported HLL type "
operator|+
name|type
argument_list|)
throw|;
block|}
return|return
name|hll
return|;
block|}
comment|/**      * Create a deep copy of this HLL.      *      * @see java.lang.Object#clone()      */
annotation|@
name|Override
DECL|method|clone
specifier|public
name|HLL
name|clone
parameter_list|()
throws|throws
name|CloneNotSupportedException
block|{
comment|// NOTE: Since the package-only constructor assumes both explicit and
comment|//       sparse are enabled, the easiest thing to do here is to re-derive
comment|//       the expthresh parameter and create a new HLL with the public
comment|//       constructor.
comment|// TODO: add a more sensible constructor to make this less obfuscated
specifier|final
name|int
name|copyExpthresh
decl_stmt|;
if|if
condition|(
name|explicitAuto
condition|)
block|{
name|copyExpthresh
operator|=
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|explicitOff
condition|)
block|{
name|copyExpthresh
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|// explicitThreshold is defined as:
comment|//
comment|//      this.explicitThreshold = (1<< (expthresh - 1));
comment|//
comment|// Since explicitThreshold is a power of two and only has a single
comment|// bit set, finding the LSB is the same as finding the inverse
name|copyExpthresh
operator|=
name|BitUtil
operator|.
name|leastSignificantBit
argument_list|(
name|explicitThreshold
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
specifier|final
name|HLL
name|copy
init|=
operator|new
name|HLL
argument_list|(
name|log2m
argument_list|,
name|regwidth
argument_list|,
name|copyExpthresh
argument_list|,
operator|!
name|sparseOff
comment|/*sparseOn*/
argument_list|,
name|type
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|EMPTY
case|:
comment|// nothing to be done
break|break;
case|case
name|EXPLICIT
case|:
name|copy
operator|.
name|explicitStorage
operator|=
name|this
operator|.
name|explicitStorage
operator|.
name|clone
argument_list|()
expr_stmt|;
break|break;
case|case
name|SPARSE
case|:
name|copy
operator|.
name|sparseProbabilisticStorage
operator|=
name|this
operator|.
name|sparseProbabilisticStorage
operator|.
name|clone
argument_list|()
expr_stmt|;
break|break;
case|case
name|FULL
case|:
name|copy
operator|.
name|probabilisticStorage
operator|=
name|this
operator|.
name|probabilisticStorage
operator|.
name|clone
argument_list|()
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Unsupported HLL type "
operator|+
name|type
argument_list|)
throw|;
block|}
return|return
name|copy
return|;
block|}
block|}
end_class
end_unit
