begin_unit
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_package
DECL|package|org.apache.solr.client.solrj.impl
package|package
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|client
operator|.
name|solrj
operator|.
name|impl
package|;
end_package
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|ref
operator|.
name|WeakReference
import|;
end_import
begin_import
import|import
name|java
operator|.
name|net
operator|.
name|ConnectException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|net
operator|.
name|MalformedURLException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|net
operator|.
name|SocketException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|net
operator|.
name|SocketTimeoutException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URL
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashMap
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentHashMap
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Executors
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ScheduledExecutorService
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicInteger
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|http
operator|.
name|client
operator|.
name|HttpClient
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|client
operator|.
name|solrj
operator|.
name|ResponseParser
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|client
operator|.
name|solrj
operator|.
name|SolrClient
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|client
operator|.
name|solrj
operator|.
name|SolrQuery
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|client
operator|.
name|solrj
operator|.
name|SolrRequest
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|client
operator|.
name|solrj
operator|.
name|SolrServerException
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|client
operator|.
name|solrj
operator|.
name|request
operator|.
name|IsUpdateRequest
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|client
operator|.
name|solrj
operator|.
name|request
operator|.
name|RequestWriter
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|client
operator|.
name|solrj
operator|.
name|response
operator|.
name|QueryResponse
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|SolrException
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|params
operator|.
name|CommonParams
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|params
operator|.
name|ModifiableSolrParams
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|params
operator|.
name|SolrParams
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|util
operator|.
name|NamedList
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|util
operator|.
name|SolrjNamedThreadFactory
import|;
end_import
begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|MDC
import|;
end_import
begin_comment
comment|/**  * LBHttpSolrClient or "LoadBalanced HttpSolrClient" is a load balancing wrapper around  * {@link HttpSolrClient}. This is useful when you  * have multiple Solr servers and the requests need to be Load Balanced among them.  *  * Do<b>NOT</b> use this class for indexing in master/slave scenarios since documents must be sent to the  * correct master; no inter-node routing is done.  *  * In SolrCloud (leader/replica) scenarios, it is usually better to use  * {@link CloudSolrClient}, but this class may be used  * for updates because the server will forward them to the appropriate leader.  *  *<p>  * It offers automatic failover when a server goes down and it detects when the server comes back up.  *<p>  * Load balancing is done using a simple round-robin on the list of servers.  *<p>  * If a request to a server fails by an IOException due to a connection timeout or read timeout then the host is taken  * off the list of live servers and moved to a 'dead server list' and the request is resent to the next live server.  * This process is continued till it tries all the live servers. If at least one server is alive, the request succeeds,  * and if not it fails.  *<blockquote><pre>  * SolrClient lbHttpSolrClient = new LBHttpSolrClient("http://host1:8080/solr/", "http://host2:8080/solr", "http://host2:8080/solr");  * //or if you wish to pass the HttpClient do as follows  * httpClient httpClient = new HttpClient();  * SolrClient lbHttpSolrClient = new LBHttpSolrClient(httpClient, "http://host1:8080/solr/", "http://host2:8080/solr", "http://host2:8080/solr");  *</pre></blockquote>  * This detects if a dead server comes alive automatically. The check is done in fixed intervals in a dedicated thread.  * This interval can be set using {@link #setAliveCheckInterval} , the default is set to one minute.  *<p>  *<b>When to use this?</b><br> This can be used as a software load balancer when you do not wish to setup an external  * load balancer. Alternatives to this code are to use  * a dedicated hardware load balancer or using Apache httpd with mod_proxy_balancer as a load balancer. See<a  * href="http://en.wikipedia.org/wiki/Load_balancing_(computing)">Load balancing on Wikipedia</a>  *  * @since solr 1.4  */
end_comment
begin_class
DECL|class|LBHttpSolrClient
specifier|public
class|class
name|LBHttpSolrClient
extends|extends
name|SolrClient
block|{
DECL|field|RETRY_CODES
specifier|private
specifier|static
name|Set
argument_list|<
name|Integer
argument_list|>
name|RETRY_CODES
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|(
literal|4
argument_list|)
decl_stmt|;
static|static
block|{
name|RETRY_CODES
operator|.
name|add
argument_list|(
literal|404
argument_list|)
expr_stmt|;
name|RETRY_CODES
operator|.
name|add
argument_list|(
literal|403
argument_list|)
expr_stmt|;
name|RETRY_CODES
operator|.
name|add
argument_list|(
literal|503
argument_list|)
expr_stmt|;
name|RETRY_CODES
operator|.
name|add
argument_list|(
literal|500
argument_list|)
expr_stmt|;
block|}
comment|// keys to the maps are currently of the form "http://localhost:8983/solr"
comment|// which should be equivalent to HttpSolrServer.getBaseURL()
DECL|field|aliveServers
specifier|private
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|ServerWrapper
argument_list|>
name|aliveServers
init|=
operator|new
name|LinkedHashMap
argument_list|<>
argument_list|()
decl_stmt|;
comment|// access to aliveServers should be synchronized on itself
DECL|field|zombieServers
specifier|protected
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|ServerWrapper
argument_list|>
name|zombieServers
init|=
operator|new
name|ConcurrentHashMap
argument_list|<>
argument_list|()
decl_stmt|;
comment|// changes to aliveServers are reflected in this array, no need to synchronize
DECL|field|aliveServerList
specifier|private
specifier|volatile
name|ServerWrapper
index|[]
name|aliveServerList
init|=
operator|new
name|ServerWrapper
index|[
literal|0
index|]
decl_stmt|;
DECL|field|aliveCheckExecutor
specifier|private
name|ScheduledExecutorService
name|aliveCheckExecutor
decl_stmt|;
DECL|field|httpClient
specifier|private
specifier|final
name|HttpClient
name|httpClient
decl_stmt|;
DECL|field|clientIsInternal
specifier|private
specifier|final
name|boolean
name|clientIsInternal
decl_stmt|;
DECL|field|counter
specifier|private
specifier|final
name|AtomicInteger
name|counter
init|=
operator|new
name|AtomicInteger
argument_list|(
operator|-
literal|1
argument_list|)
decl_stmt|;
DECL|field|solrQuery
specifier|private
specifier|static
specifier|final
name|SolrQuery
name|solrQuery
init|=
operator|new
name|SolrQuery
argument_list|(
literal|"*:*"
argument_list|)
decl_stmt|;
DECL|field|parser
specifier|private
specifier|volatile
name|ResponseParser
name|parser
decl_stmt|;
DECL|field|requestWriter
specifier|private
specifier|volatile
name|RequestWriter
name|requestWriter
decl_stmt|;
DECL|field|queryParams
specifier|private
name|Set
argument_list|<
name|String
argument_list|>
name|queryParams
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
DECL|field|connectionTimeout
specifier|private
name|Integer
name|connectionTimeout
decl_stmt|;
DECL|field|soTimeout
specifier|private
name|Integer
name|soTimeout
decl_stmt|;
static|static
block|{
name|solrQuery
operator|.
name|setRows
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/**      * Default sort (if we don't supply a sort) is by score and since      * we request 0 rows any sorting and scoring is not necessary.      * SolrQuery.DOCID schema-independently specifies a non-scoring sort.      *<code>_docid_ asc</code> sort is efficient,      *<code>_docid_ desc</code> sort is not, so choose ascending DOCID sort.      */
name|solrQuery
operator|.
name|setSort
argument_list|(
name|SolrQuery
operator|.
name|DOCID
argument_list|,
name|SolrQuery
operator|.
name|ORDER
operator|.
name|asc
argument_list|)
expr_stmt|;
comment|// not a top-level request, we are interested only in the server being sent to i.e. it need not distribute our request to further servers
name|solrQuery
operator|.
name|setDistrib
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
DECL|class|ServerWrapper
specifier|protected
specifier|static
class|class
name|ServerWrapper
block|{
DECL|field|client
specifier|final
name|HttpSolrClient
name|client
decl_stmt|;
comment|// "standard" servers are used by default.  They normally live in the alive list
comment|// and move to the zombie list when unavailable.  When they become available again,
comment|// they move back to the alive list.
DECL|field|standard
name|boolean
name|standard
init|=
literal|true
decl_stmt|;
DECL|field|failedPings
name|int
name|failedPings
init|=
literal|0
decl_stmt|;
DECL|method|ServerWrapper
specifier|public
name|ServerWrapper
parameter_list|(
name|HttpSolrClient
name|client
parameter_list|)
block|{
name|this
operator|.
name|client
operator|=
name|client
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|client
operator|.
name|getBaseURL
argument_list|()
return|;
block|}
DECL|method|getKey
specifier|public
name|String
name|getKey
parameter_list|()
block|{
return|return
name|client
operator|.
name|getBaseURL
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|hashCode
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
name|this
operator|.
name|getKey
argument_list|()
operator|.
name|hashCode
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|equals
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|obj
parameter_list|)
block|{
if|if
condition|(
name|this
operator|==
name|obj
condition|)
return|return
literal|true
return|;
if|if
condition|(
operator|!
operator|(
name|obj
operator|instanceof
name|ServerWrapper
operator|)
condition|)
return|return
literal|false
return|;
return|return
name|this
operator|.
name|getKey
argument_list|()
operator|.
name|equals
argument_list|(
operator|(
operator|(
name|ServerWrapper
operator|)
name|obj
operator|)
operator|.
name|getKey
argument_list|()
argument_list|)
return|;
block|}
block|}
DECL|class|Req
specifier|public
specifier|static
class|class
name|Req
block|{
DECL|field|request
specifier|protected
name|SolrRequest
name|request
decl_stmt|;
DECL|field|servers
specifier|protected
name|List
argument_list|<
name|String
argument_list|>
name|servers
decl_stmt|;
DECL|field|numDeadServersToTry
specifier|protected
name|int
name|numDeadServersToTry
decl_stmt|;
DECL|method|Req
specifier|public
name|Req
parameter_list|(
name|SolrRequest
name|request
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|servers
parameter_list|)
block|{
name|this
operator|.
name|request
operator|=
name|request
expr_stmt|;
name|this
operator|.
name|servers
operator|=
name|servers
expr_stmt|;
name|this
operator|.
name|numDeadServersToTry
operator|=
name|servers
operator|.
name|size
argument_list|()
expr_stmt|;
block|}
DECL|method|getRequest
specifier|public
name|SolrRequest
name|getRequest
parameter_list|()
block|{
return|return
name|request
return|;
block|}
DECL|method|getServers
specifier|public
name|List
argument_list|<
name|String
argument_list|>
name|getServers
parameter_list|()
block|{
return|return
name|servers
return|;
block|}
comment|/** @return the number of dead servers to try if there are no live servers left */
DECL|method|getNumDeadServersToTry
specifier|public
name|int
name|getNumDeadServersToTry
parameter_list|()
block|{
return|return
name|numDeadServersToTry
return|;
block|}
comment|/** @param numDeadServersToTry The number of dead servers to try if there are no live servers left.      * Defaults to the number of servers in this request. */
DECL|method|setNumDeadServersToTry
specifier|public
name|void
name|setNumDeadServersToTry
parameter_list|(
name|int
name|numDeadServersToTry
parameter_list|)
block|{
name|this
operator|.
name|numDeadServersToTry
operator|=
name|numDeadServersToTry
expr_stmt|;
block|}
block|}
DECL|class|Rsp
specifier|public
specifier|static
class|class
name|Rsp
block|{
DECL|field|server
specifier|protected
name|String
name|server
decl_stmt|;
DECL|field|rsp
specifier|protected
name|NamedList
argument_list|<
name|Object
argument_list|>
name|rsp
decl_stmt|;
comment|/** The response from the server */
DECL|method|getResponse
specifier|public
name|NamedList
argument_list|<
name|Object
argument_list|>
name|getResponse
parameter_list|()
block|{
return|return
name|rsp
return|;
block|}
comment|/** The server that returned the response */
DECL|method|getServer
specifier|public
name|String
name|getServer
parameter_list|()
block|{
return|return
name|server
return|;
block|}
block|}
comment|/**    * @deprecated use {@link Builder} instead.    */
annotation|@
name|Deprecated
DECL|method|LBHttpSolrClient
specifier|public
name|LBHttpSolrClient
parameter_list|(
name|String
modifier|...
name|solrServerUrls
parameter_list|)
throws|throws
name|MalformedURLException
block|{
name|this
argument_list|(
literal|null
argument_list|,
name|solrServerUrls
argument_list|)
expr_stmt|;
block|}
comment|/**    * The provided httpClient should use a multi-threaded connection manager    * @deprecated use {@link Builder} instead.    */
annotation|@
name|Deprecated
DECL|method|LBHttpSolrClient
specifier|public
name|LBHttpSolrClient
parameter_list|(
name|HttpClient
name|httpClient
parameter_list|,
name|String
modifier|...
name|solrServerUrl
parameter_list|)
block|{
name|this
argument_list|(
name|httpClient
argument_list|,
operator|new
name|BinaryResponseParser
argument_list|()
argument_list|,
name|solrServerUrl
argument_list|)
expr_stmt|;
block|}
comment|/**    * The provided httpClient should use a multi-threaded connection manager    * @deprecated use {@link Builder} instead.  This will soon be a protected    * method and will only be available for use in implementing subclasses.    */
annotation|@
name|Deprecated
DECL|method|LBHttpSolrClient
specifier|public
name|LBHttpSolrClient
parameter_list|(
name|HttpClient
name|httpClient
parameter_list|,
name|ResponseParser
name|parser
parameter_list|,
name|String
modifier|...
name|solrServerUrl
parameter_list|)
block|{
name|clientIsInternal
operator|=
operator|(
name|httpClient
operator|==
literal|null
operator|)
expr_stmt|;
if|if
condition|(
name|httpClient
operator|==
literal|null
condition|)
block|{
name|ModifiableSolrParams
name|params
init|=
operator|new
name|ModifiableSolrParams
argument_list|()
decl_stmt|;
if|if
condition|(
name|solrServerUrl
operator|.
name|length
operator|>
literal|1
condition|)
block|{
comment|// we prefer retrying another server
name|params
operator|.
name|set
argument_list|(
name|HttpClientUtil
operator|.
name|PROP_USE_RETRY
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|params
operator|.
name|set
argument_list|(
name|HttpClientUtil
operator|.
name|PROP_USE_RETRY
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|httpClient
operator|=
name|HttpClientUtil
operator|.
name|createClient
argument_list|(
name|params
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|this
operator|.
name|httpClient
operator|=
name|httpClient
expr_stmt|;
block|}
name|this
operator|.
name|parser
operator|=
name|parser
expr_stmt|;
for|for
control|(
name|String
name|s
range|:
name|solrServerUrl
control|)
block|{
name|ServerWrapper
name|wrapper
init|=
operator|new
name|ServerWrapper
argument_list|(
name|makeSolrClient
argument_list|(
name|s
argument_list|)
argument_list|)
decl_stmt|;
name|aliveServers
operator|.
name|put
argument_list|(
name|wrapper
operator|.
name|getKey
argument_list|()
argument_list|,
name|wrapper
argument_list|)
expr_stmt|;
block|}
name|updateAliveList
argument_list|()
expr_stmt|;
block|}
DECL|method|getQueryParams
specifier|public
name|Set
argument_list|<
name|String
argument_list|>
name|getQueryParams
parameter_list|()
block|{
return|return
name|queryParams
return|;
block|}
comment|/**    * Expert Method.    * @param queryParams set of param keys to only send via the query string    */
DECL|method|setQueryParams
specifier|public
name|void
name|setQueryParams
parameter_list|(
name|Set
argument_list|<
name|String
argument_list|>
name|queryParams
parameter_list|)
block|{
name|this
operator|.
name|queryParams
operator|=
name|queryParams
expr_stmt|;
block|}
DECL|method|addQueryParams
specifier|public
name|void
name|addQueryParams
parameter_list|(
name|String
name|queryOnlyParam
parameter_list|)
block|{
name|this
operator|.
name|queryParams
operator|.
name|add
argument_list|(
name|queryOnlyParam
argument_list|)
expr_stmt|;
block|}
DECL|method|normalize
specifier|public
specifier|static
name|String
name|normalize
parameter_list|(
name|String
name|server
parameter_list|)
block|{
if|if
condition|(
name|server
operator|.
name|endsWith
argument_list|(
literal|"/"
argument_list|)
condition|)
name|server
operator|=
name|server
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|server
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
name|server
return|;
block|}
DECL|method|makeSolrClient
specifier|protected
name|HttpSolrClient
name|makeSolrClient
parameter_list|(
name|String
name|server
parameter_list|)
block|{
name|HttpSolrClient
name|client
init|=
operator|new
name|HttpSolrClient
operator|.
name|Builder
argument_list|(
name|server
argument_list|)
operator|.
name|withHttpClient
argument_list|(
name|httpClient
argument_list|)
operator|.
name|withResponseParser
argument_list|(
name|parser
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
if|if
condition|(
name|connectionTimeout
operator|!=
literal|null
condition|)
block|{
name|client
operator|.
name|setConnectionTimeout
argument_list|(
name|connectionTimeout
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|soTimeout
operator|!=
literal|null
condition|)
block|{
name|client
operator|.
name|setSoTimeout
argument_list|(
name|soTimeout
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|requestWriter
operator|!=
literal|null
condition|)
block|{
name|client
operator|.
name|setRequestWriter
argument_list|(
name|requestWriter
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|queryParams
operator|!=
literal|null
condition|)
block|{
name|client
operator|.
name|setQueryParams
argument_list|(
name|queryParams
argument_list|)
expr_stmt|;
block|}
return|return
name|client
return|;
block|}
comment|/**    * Tries to query a live server from the list provided in Req. Servers in the dead pool are skipped.    * If a request fails due to an IOException, the server is moved to the dead pool for a certain period of    * time, or until a test request on that server succeeds.    *    * Servers are queried in the exact order given (except servers currently in the dead pool are skipped).    * If no live servers from the provided list remain to be tried, a number of previously skipped dead servers will be tried.    * Req.getNumDeadServersToTry() controls how many dead servers will be tried.    *    * If no live servers are found a SolrServerException is thrown.    *    * @param req contains both the request as well as the list of servers to query    *    * @return the result of the request    *    * @throws IOException If there is a low-level I/O error.    */
DECL|method|request
specifier|public
name|Rsp
name|request
parameter_list|(
name|Req
name|req
parameter_list|)
throws|throws
name|SolrServerException
throws|,
name|IOException
block|{
name|Rsp
name|rsp
init|=
operator|new
name|Rsp
argument_list|()
decl_stmt|;
name|Exception
name|ex
init|=
literal|null
decl_stmt|;
name|boolean
name|isUpdate
init|=
name|req
operator|.
name|request
operator|instanceof
name|IsUpdateRequest
decl_stmt|;
name|List
argument_list|<
name|ServerWrapper
argument_list|>
name|skipped
init|=
literal|null
decl_stmt|;
name|long
name|timeAllowedNano
init|=
name|getTimeAllowedInNanos
argument_list|(
name|req
operator|.
name|getRequest
argument_list|()
argument_list|)
decl_stmt|;
name|long
name|timeOutTime
init|=
name|System
operator|.
name|nanoTime
argument_list|()
operator|+
name|timeAllowedNano
decl_stmt|;
for|for
control|(
name|String
name|serverStr
range|:
name|req
operator|.
name|getServers
argument_list|()
control|)
block|{
if|if
condition|(
name|isTimeExceeded
argument_list|(
name|timeAllowedNano
argument_list|,
name|timeOutTime
argument_list|)
condition|)
block|{
break|break;
block|}
name|serverStr
operator|=
name|normalize
argument_list|(
name|serverStr
argument_list|)
expr_stmt|;
comment|// if the server is currently a zombie, just skip to the next one
name|ServerWrapper
name|wrapper
init|=
name|zombieServers
operator|.
name|get
argument_list|(
name|serverStr
argument_list|)
decl_stmt|;
if|if
condition|(
name|wrapper
operator|!=
literal|null
condition|)
block|{
comment|// System.out.println("ZOMBIE SERVER QUERIED: " + serverStr);
specifier|final
name|int
name|numDeadServersToTry
init|=
name|req
operator|.
name|getNumDeadServersToTry
argument_list|()
decl_stmt|;
if|if
condition|(
name|numDeadServersToTry
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|skipped
operator|==
literal|null
condition|)
block|{
name|skipped
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|numDeadServersToTry
argument_list|)
expr_stmt|;
name|skipped
operator|.
name|add
argument_list|(
name|wrapper
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|skipped
operator|.
name|size
argument_list|()
operator|<
name|numDeadServersToTry
condition|)
block|{
name|skipped
operator|.
name|add
argument_list|(
name|wrapper
argument_list|)
expr_stmt|;
block|}
block|}
continue|continue;
block|}
name|rsp
operator|.
name|server
operator|=
name|serverStr
expr_stmt|;
try|try
block|{
name|MDC
operator|.
name|put
argument_list|(
literal|"LBHttpSolrClient.url"
argument_list|,
name|serverStr
argument_list|)
expr_stmt|;
name|HttpSolrClient
name|client
init|=
name|makeSolrClient
argument_list|(
name|serverStr
argument_list|)
decl_stmt|;
name|ex
operator|=
name|doRequest
argument_list|(
name|client
argument_list|,
name|req
argument_list|,
name|rsp
argument_list|,
name|isUpdate
argument_list|,
literal|false
argument_list|,
literal|null
argument_list|)
expr_stmt|;
if|if
condition|(
name|ex
operator|==
literal|null
condition|)
block|{
return|return
name|rsp
return|;
comment|// SUCCESS
block|}
block|}
finally|finally
block|{
name|MDC
operator|.
name|remove
argument_list|(
literal|"LBHttpSolrClient.url"
argument_list|)
expr_stmt|;
block|}
block|}
comment|// try the servers we previously skipped
if|if
condition|(
name|skipped
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|ServerWrapper
name|wrapper
range|:
name|skipped
control|)
block|{
if|if
condition|(
name|isTimeExceeded
argument_list|(
name|timeAllowedNano
argument_list|,
name|timeOutTime
argument_list|)
condition|)
block|{
break|break;
block|}
name|ex
operator|=
name|doRequest
argument_list|(
name|wrapper
operator|.
name|client
argument_list|,
name|req
argument_list|,
name|rsp
argument_list|,
name|isUpdate
argument_list|,
literal|true
argument_list|,
name|wrapper
operator|.
name|getKey
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|ex
operator|==
literal|null
condition|)
block|{
return|return
name|rsp
return|;
comment|// SUCCESS
block|}
block|}
block|}
if|if
condition|(
name|ex
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|SolrServerException
argument_list|(
literal|"No live SolrServers available to handle this request"
argument_list|)
throw|;
block|}
else|else
block|{
throw|throw
operator|new
name|SolrServerException
argument_list|(
literal|"No live SolrServers available to handle this request:"
operator|+
name|zombieServers
operator|.
name|keySet
argument_list|()
argument_list|,
name|ex
argument_list|)
throw|;
block|}
block|}
DECL|method|addZombie
specifier|protected
name|Exception
name|addZombie
parameter_list|(
name|HttpSolrClient
name|server
parameter_list|,
name|Exception
name|e
parameter_list|)
block|{
name|ServerWrapper
name|wrapper
decl_stmt|;
name|wrapper
operator|=
operator|new
name|ServerWrapper
argument_list|(
name|server
argument_list|)
expr_stmt|;
name|wrapper
operator|.
name|standard
operator|=
literal|false
expr_stmt|;
name|zombieServers
operator|.
name|put
argument_list|(
name|wrapper
operator|.
name|getKey
argument_list|()
argument_list|,
name|wrapper
argument_list|)
expr_stmt|;
name|startAliveCheckExecutor
argument_list|()
expr_stmt|;
return|return
name|e
return|;
block|}
DECL|method|doRequest
specifier|protected
name|Exception
name|doRequest
parameter_list|(
name|HttpSolrClient
name|client
parameter_list|,
name|Req
name|req
parameter_list|,
name|Rsp
name|rsp
parameter_list|,
name|boolean
name|isUpdate
parameter_list|,
name|boolean
name|isZombie
parameter_list|,
name|String
name|zombieKey
parameter_list|)
throws|throws
name|SolrServerException
throws|,
name|IOException
block|{
name|Exception
name|ex
init|=
literal|null
decl_stmt|;
try|try
block|{
name|rsp
operator|.
name|rsp
operator|=
name|client
operator|.
name|request
argument_list|(
name|req
operator|.
name|getRequest
argument_list|()
argument_list|,
operator|(
name|String
operator|)
literal|null
argument_list|)
expr_stmt|;
if|if
condition|(
name|isZombie
condition|)
block|{
name|zombieServers
operator|.
name|remove
argument_list|(
name|zombieKey
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|SolrException
name|e
parameter_list|)
block|{
comment|// we retry on 404 or 403 or 503 or 500
comment|// unless it's an update - then we only retry on connect exception
if|if
condition|(
operator|!
name|isUpdate
operator|&&
name|RETRY_CODES
operator|.
name|contains
argument_list|(
name|e
operator|.
name|code
argument_list|()
argument_list|)
condition|)
block|{
name|ex
operator|=
operator|(
operator|!
name|isZombie
operator|)
condition|?
name|addZombie
argument_list|(
name|client
argument_list|,
name|e
argument_list|)
else|:
name|e
expr_stmt|;
block|}
else|else
block|{
comment|// Server is alive but the request was likely malformed or invalid
if|if
condition|(
name|isZombie
condition|)
block|{
name|zombieServers
operator|.
name|remove
argument_list|(
name|zombieKey
argument_list|)
expr_stmt|;
block|}
throw|throw
name|e
throw|;
block|}
block|}
catch|catch
parameter_list|(
name|SocketException
name|e
parameter_list|)
block|{
if|if
condition|(
operator|!
name|isUpdate
operator|||
name|e
operator|instanceof
name|ConnectException
condition|)
block|{
name|ex
operator|=
operator|(
operator|!
name|isZombie
operator|)
condition|?
name|addZombie
argument_list|(
name|client
argument_list|,
name|e
argument_list|)
else|:
name|e
expr_stmt|;
block|}
else|else
block|{
throw|throw
name|e
throw|;
block|}
block|}
catch|catch
parameter_list|(
name|SocketTimeoutException
name|e
parameter_list|)
block|{
if|if
condition|(
operator|!
name|isUpdate
condition|)
block|{
name|ex
operator|=
operator|(
operator|!
name|isZombie
operator|)
condition|?
name|addZombie
argument_list|(
name|client
argument_list|,
name|e
argument_list|)
else|:
name|e
expr_stmt|;
block|}
else|else
block|{
throw|throw
name|e
throw|;
block|}
block|}
catch|catch
parameter_list|(
name|SolrServerException
name|e
parameter_list|)
block|{
name|Throwable
name|rootCause
init|=
name|e
operator|.
name|getRootCause
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|isUpdate
operator|&&
name|rootCause
operator|instanceof
name|IOException
condition|)
block|{
name|ex
operator|=
operator|(
operator|!
name|isZombie
operator|)
condition|?
name|addZombie
argument_list|(
name|client
argument_list|,
name|e
argument_list|)
else|:
name|e
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isUpdate
operator|&&
name|rootCause
operator|instanceof
name|ConnectException
condition|)
block|{
name|ex
operator|=
operator|(
operator|!
name|isZombie
operator|)
condition|?
name|addZombie
argument_list|(
name|client
argument_list|,
name|e
argument_list|)
else|:
name|e
expr_stmt|;
block|}
else|else
block|{
throw|throw
name|e
throw|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SolrServerException
argument_list|(
name|e
argument_list|)
throw|;
block|}
return|return
name|ex
return|;
block|}
DECL|method|updateAliveList
specifier|private
name|void
name|updateAliveList
parameter_list|()
block|{
synchronized|synchronized
init|(
name|aliveServers
init|)
block|{
name|aliveServerList
operator|=
name|aliveServers
operator|.
name|values
argument_list|()
operator|.
name|toArray
argument_list|(
operator|new
name|ServerWrapper
index|[
name|aliveServers
operator|.
name|size
argument_list|()
index|]
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|removeFromAlive
specifier|private
name|ServerWrapper
name|removeFromAlive
parameter_list|(
name|String
name|key
parameter_list|)
block|{
synchronized|synchronized
init|(
name|aliveServers
init|)
block|{
name|ServerWrapper
name|wrapper
init|=
name|aliveServers
operator|.
name|remove
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|wrapper
operator|!=
literal|null
condition|)
name|updateAliveList
argument_list|()
expr_stmt|;
return|return
name|wrapper
return|;
block|}
block|}
DECL|method|addToAlive
specifier|private
name|void
name|addToAlive
parameter_list|(
name|ServerWrapper
name|wrapper
parameter_list|)
block|{
synchronized|synchronized
init|(
name|aliveServers
init|)
block|{
name|ServerWrapper
name|prev
init|=
name|aliveServers
operator|.
name|put
argument_list|(
name|wrapper
operator|.
name|getKey
argument_list|()
argument_list|,
name|wrapper
argument_list|)
decl_stmt|;
comment|// TODO: warn if there was a previous entry?
name|updateAliveList
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|addSolrServer
specifier|public
name|void
name|addSolrServer
parameter_list|(
name|String
name|server
parameter_list|)
throws|throws
name|MalformedURLException
block|{
name|HttpSolrClient
name|client
init|=
name|makeSolrClient
argument_list|(
name|server
argument_list|)
decl_stmt|;
name|addToAlive
argument_list|(
operator|new
name|ServerWrapper
argument_list|(
name|client
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|removeSolrServer
specifier|public
name|String
name|removeSolrServer
parameter_list|(
name|String
name|server
parameter_list|)
block|{
try|try
block|{
name|server
operator|=
operator|new
name|URL
argument_list|(
name|server
argument_list|)
operator|.
name|toExternalForm
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|MalformedURLException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
if|if
condition|(
name|server
operator|.
name|endsWith
argument_list|(
literal|"/"
argument_list|)
condition|)
block|{
name|server
operator|=
name|server
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|server
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|// there is a small race condition here - if the server is in the process of being moved between
comment|// lists, we could fail to remove it.
name|removeFromAlive
argument_list|(
name|server
argument_list|)
expr_stmt|;
name|zombieServers
operator|.
name|remove
argument_list|(
name|server
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
DECL|method|setConnectionTimeout
specifier|public
name|void
name|setConnectionTimeout
parameter_list|(
name|int
name|timeout
parameter_list|)
block|{
name|this
operator|.
name|connectionTimeout
operator|=
name|timeout
expr_stmt|;
synchronized|synchronized
init|(
name|aliveServers
init|)
block|{
name|Iterator
argument_list|<
name|ServerWrapper
argument_list|>
name|wrappersIt
init|=
name|aliveServers
operator|.
name|values
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|wrappersIt
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|wrappersIt
operator|.
name|next
argument_list|()
operator|.
name|client
operator|.
name|setConnectionTimeout
argument_list|(
name|timeout
argument_list|)
expr_stmt|;
block|}
block|}
name|Iterator
argument_list|<
name|ServerWrapper
argument_list|>
name|wrappersIt
init|=
name|zombieServers
operator|.
name|values
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|wrappersIt
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|wrappersIt
operator|.
name|next
argument_list|()
operator|.
name|client
operator|.
name|setConnectionTimeout
argument_list|(
name|timeout
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * set soTimeout (read timeout) on the underlying HttpConnectionManager. This is desirable for queries, but probably    * not for indexing.    */
DECL|method|setSoTimeout
specifier|public
name|void
name|setSoTimeout
parameter_list|(
name|int
name|timeout
parameter_list|)
block|{
name|this
operator|.
name|soTimeout
operator|=
name|timeout
expr_stmt|;
synchronized|synchronized
init|(
name|aliveServers
init|)
block|{
name|Iterator
argument_list|<
name|ServerWrapper
argument_list|>
name|wrappersIt
init|=
name|aliveServers
operator|.
name|values
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|wrappersIt
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|wrappersIt
operator|.
name|next
argument_list|()
operator|.
name|client
operator|.
name|setSoTimeout
argument_list|(
name|timeout
argument_list|)
expr_stmt|;
block|}
block|}
name|Iterator
argument_list|<
name|ServerWrapper
argument_list|>
name|wrappersIt
init|=
name|zombieServers
operator|.
name|values
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|wrappersIt
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|wrappersIt
operator|.
name|next
argument_list|()
operator|.
name|client
operator|.
name|setSoTimeout
argument_list|(
name|timeout
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|close
specifier|public
name|void
name|close
parameter_list|()
block|{
if|if
condition|(
name|aliveCheckExecutor
operator|!=
literal|null
condition|)
block|{
name|aliveCheckExecutor
operator|.
name|shutdownNow
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|clientIsInternal
condition|)
block|{
name|HttpClientUtil
operator|.
name|close
argument_list|(
name|httpClient
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Tries to query a live server. A SolrServerException is thrown if all servers are dead.    * If the request failed due to IOException then the live server is moved to dead pool and the request is    * retried on another live server.  After live servers are exhausted, any servers previously marked as dead    * will be tried before failing the request.    *    * @param request the SolrRequest.    *    * @return response    *    * @throws IOException If there is a low-level I/O error.    */
annotation|@
name|Override
DECL|method|request
specifier|public
name|NamedList
argument_list|<
name|Object
argument_list|>
name|request
parameter_list|(
specifier|final
name|SolrRequest
name|request
parameter_list|,
name|String
name|collection
parameter_list|)
throws|throws
name|SolrServerException
throws|,
name|IOException
block|{
name|Exception
name|ex
init|=
literal|null
decl_stmt|;
name|ServerWrapper
index|[]
name|serverList
init|=
name|aliveServerList
decl_stmt|;
name|int
name|maxTries
init|=
name|serverList
operator|.
name|length
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|ServerWrapper
argument_list|>
name|justFailed
init|=
literal|null
decl_stmt|;
name|long
name|timeAllowedNano
init|=
name|getTimeAllowedInNanos
argument_list|(
name|request
argument_list|)
decl_stmt|;
name|long
name|timeOutTime
init|=
name|System
operator|.
name|nanoTime
argument_list|()
operator|+
name|timeAllowedNano
decl_stmt|;
for|for
control|(
name|int
name|attempts
init|=
literal|0
init|;
name|attempts
operator|<
name|maxTries
condition|;
name|attempts
operator|++
control|)
block|{
if|if
condition|(
name|isTimeExceeded
argument_list|(
name|timeAllowedNano
argument_list|,
name|timeOutTime
argument_list|)
condition|)
block|{
break|break;
block|}
name|int
name|count
init|=
name|counter
operator|.
name|incrementAndGet
argument_list|()
operator|&
name|Integer
operator|.
name|MAX_VALUE
decl_stmt|;
name|ServerWrapper
name|wrapper
init|=
name|serverList
index|[
name|count
operator|%
name|serverList
operator|.
name|length
index|]
decl_stmt|;
try|try
block|{
return|return
name|wrapper
operator|.
name|client
operator|.
name|request
argument_list|(
name|request
argument_list|,
name|collection
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|SolrException
name|e
parameter_list|)
block|{
comment|// Server is alive but the request was malformed or invalid
throw|throw
name|e
throw|;
block|}
catch|catch
parameter_list|(
name|SolrServerException
name|e
parameter_list|)
block|{
if|if
condition|(
name|e
operator|.
name|getRootCause
argument_list|()
operator|instanceof
name|IOException
condition|)
block|{
name|ex
operator|=
name|e
expr_stmt|;
name|moveAliveToDead
argument_list|(
name|wrapper
argument_list|)
expr_stmt|;
if|if
condition|(
name|justFailed
operator|==
literal|null
condition|)
name|justFailed
operator|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
expr_stmt|;
name|justFailed
operator|.
name|put
argument_list|(
name|wrapper
operator|.
name|getKey
argument_list|()
argument_list|,
name|wrapper
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
name|e
throw|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SolrServerException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
comment|// try other standard servers that we didn't try just now
for|for
control|(
name|ServerWrapper
name|wrapper
range|:
name|zombieServers
operator|.
name|values
argument_list|()
control|)
block|{
if|if
condition|(
name|isTimeExceeded
argument_list|(
name|timeAllowedNano
argument_list|,
name|timeOutTime
argument_list|)
condition|)
block|{
break|break;
block|}
if|if
condition|(
name|wrapper
operator|.
name|standard
operator|==
literal|false
operator|||
name|justFailed
operator|!=
literal|null
operator|&&
name|justFailed
operator|.
name|containsKey
argument_list|(
name|wrapper
operator|.
name|getKey
argument_list|()
argument_list|)
condition|)
continue|continue;
try|try
block|{
name|NamedList
argument_list|<
name|Object
argument_list|>
name|rsp
init|=
name|wrapper
operator|.
name|client
operator|.
name|request
argument_list|(
name|request
argument_list|,
name|collection
argument_list|)
decl_stmt|;
comment|// remove from zombie list *before* adding to alive to avoid a race that could lose a server
name|zombieServers
operator|.
name|remove
argument_list|(
name|wrapper
operator|.
name|getKey
argument_list|()
argument_list|)
expr_stmt|;
name|addToAlive
argument_list|(
name|wrapper
argument_list|)
expr_stmt|;
return|return
name|rsp
return|;
block|}
catch|catch
parameter_list|(
name|SolrException
name|e
parameter_list|)
block|{
comment|// Server is alive but the request was malformed or invalid
throw|throw
name|e
throw|;
block|}
catch|catch
parameter_list|(
name|SolrServerException
name|e
parameter_list|)
block|{
if|if
condition|(
name|e
operator|.
name|getRootCause
argument_list|()
operator|instanceof
name|IOException
condition|)
block|{
name|ex
operator|=
name|e
expr_stmt|;
comment|// still dead
block|}
else|else
block|{
throw|throw
name|e
throw|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SolrServerException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
if|if
condition|(
name|ex
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|SolrServerException
argument_list|(
literal|"No live SolrServers available to handle this request"
argument_list|)
throw|;
block|}
else|else
block|{
throw|throw
operator|new
name|SolrServerException
argument_list|(
literal|"No live SolrServers available to handle this request"
argument_list|,
name|ex
argument_list|)
throw|;
block|}
block|}
comment|/**    * @return time allowed in nanos, returns -1 if no time_allowed is specified.    */
DECL|method|getTimeAllowedInNanos
specifier|private
name|long
name|getTimeAllowedInNanos
parameter_list|(
specifier|final
name|SolrRequest
name|req
parameter_list|)
block|{
name|SolrParams
name|reqParams
init|=
name|req
operator|.
name|getParams
argument_list|()
decl_stmt|;
return|return
name|reqParams
operator|==
literal|null
condition|?
operator|-
literal|1
else|:
name|TimeUnit
operator|.
name|NANOSECONDS
operator|.
name|convert
argument_list|(
name|reqParams
operator|.
name|getInt
argument_list|(
name|CommonParams
operator|.
name|TIME_ALLOWED
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|,
name|TimeUnit
operator|.
name|MILLISECONDS
argument_list|)
return|;
block|}
DECL|method|isTimeExceeded
specifier|private
name|boolean
name|isTimeExceeded
parameter_list|(
name|long
name|timeAllowedNano
parameter_list|,
name|long
name|timeOutTime
parameter_list|)
block|{
return|return
name|timeAllowedNano
operator|>
literal|0
operator|&&
name|System
operator|.
name|nanoTime
argument_list|()
operator|>
name|timeOutTime
return|;
block|}
comment|/**    * Takes up one dead server and check for aliveness. The check is done in a roundrobin. Each server is checked for    * aliveness once in 'x' millis where x is decided by the setAliveCheckinterval() or it is defaulted to 1 minute    *    * @param zombieServer a server in the dead pool    */
DECL|method|checkAZombieServer
specifier|private
name|void
name|checkAZombieServer
parameter_list|(
name|ServerWrapper
name|zombieServer
parameter_list|)
block|{
try|try
block|{
name|QueryResponse
name|resp
init|=
name|zombieServer
operator|.
name|client
operator|.
name|query
argument_list|(
name|solrQuery
argument_list|)
decl_stmt|;
if|if
condition|(
name|resp
operator|.
name|getStatus
argument_list|()
operator|==
literal|0
condition|)
block|{
comment|// server has come back up.
comment|// make sure to remove from zombies before adding to alive to avoid a race condition
comment|// where another thread could mark it down, move it back to zombie, and then we delete
comment|// from zombie and lose it forever.
name|ServerWrapper
name|wrapper
init|=
name|zombieServers
operator|.
name|remove
argument_list|(
name|zombieServer
operator|.
name|getKey
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|wrapper
operator|!=
literal|null
condition|)
block|{
name|wrapper
operator|.
name|failedPings
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|wrapper
operator|.
name|standard
condition|)
block|{
name|addToAlive
argument_list|(
name|wrapper
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// something else already moved the server from zombie to alive
block|}
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
comment|//Expected. The server is still down.
name|zombieServer
operator|.
name|failedPings
operator|++
expr_stmt|;
comment|// If the server doesn't belong in the standard set belonging to this load balancer
comment|// then simply drop it after a certain number of failed pings.
if|if
condition|(
operator|!
name|zombieServer
operator|.
name|standard
operator|&&
name|zombieServer
operator|.
name|failedPings
operator|>=
name|NONSTANDARD_PING_LIMIT
condition|)
block|{
name|zombieServers
operator|.
name|remove
argument_list|(
name|zombieServer
operator|.
name|getKey
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|moveAliveToDead
specifier|private
name|void
name|moveAliveToDead
parameter_list|(
name|ServerWrapper
name|wrapper
parameter_list|)
block|{
name|wrapper
operator|=
name|removeFromAlive
argument_list|(
name|wrapper
operator|.
name|getKey
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|wrapper
operator|==
literal|null
condition|)
return|return;
comment|// another thread already detected the failure and removed it
name|zombieServers
operator|.
name|put
argument_list|(
name|wrapper
operator|.
name|getKey
argument_list|()
argument_list|,
name|wrapper
argument_list|)
expr_stmt|;
name|startAliveCheckExecutor
argument_list|()
expr_stmt|;
block|}
DECL|field|interval
specifier|private
name|int
name|interval
init|=
name|CHECK_INTERVAL
decl_stmt|;
comment|/**    * LBHttpSolrServer keeps pinging the dead servers at fixed interval to find if it is alive. Use this to set that    * interval    *    * @param interval time in milliseconds    */
DECL|method|setAliveCheckInterval
specifier|public
name|void
name|setAliveCheckInterval
parameter_list|(
name|int
name|interval
parameter_list|)
block|{
if|if
condition|(
name|interval
operator|<=
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Alive check interval must be "
operator|+
literal|"positive, specified value = "
operator|+
name|interval
argument_list|)
throw|;
block|}
name|this
operator|.
name|interval
operator|=
name|interval
expr_stmt|;
block|}
DECL|method|startAliveCheckExecutor
specifier|private
name|void
name|startAliveCheckExecutor
parameter_list|()
block|{
comment|// double-checked locking, but it's OK because we don't *do* anything with aliveCheckExecutor
comment|// if it's not null.
if|if
condition|(
name|aliveCheckExecutor
operator|==
literal|null
condition|)
block|{
synchronized|synchronized
init|(
name|this
init|)
block|{
if|if
condition|(
name|aliveCheckExecutor
operator|==
literal|null
condition|)
block|{
name|aliveCheckExecutor
operator|=
name|Executors
operator|.
name|newSingleThreadScheduledExecutor
argument_list|(
operator|new
name|SolrjNamedThreadFactory
argument_list|(
literal|"aliveCheckExecutor"
argument_list|)
argument_list|)
expr_stmt|;
name|aliveCheckExecutor
operator|.
name|scheduleAtFixedRate
argument_list|(
name|getAliveCheckRunner
argument_list|(
operator|new
name|WeakReference
argument_list|<>
argument_list|(
name|this
argument_list|)
argument_list|)
argument_list|,
name|this
operator|.
name|interval
argument_list|,
name|this
operator|.
name|interval
argument_list|,
name|TimeUnit
operator|.
name|MILLISECONDS
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
DECL|method|getAliveCheckRunner
specifier|private
specifier|static
name|Runnable
name|getAliveCheckRunner
parameter_list|(
specifier|final
name|WeakReference
argument_list|<
name|LBHttpSolrClient
argument_list|>
name|lbRef
parameter_list|)
block|{
return|return
parameter_list|()
lambda|->
block|{
name|LBHttpSolrClient
name|lb
init|=
name|lbRef
operator|.
name|get
argument_list|()
decl_stmt|;
if|if
condition|(
name|lb
operator|!=
literal|null
operator|&&
name|lb
operator|.
name|zombieServers
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|ServerWrapper
name|zombieServer
range|:
name|lb
operator|.
name|zombieServers
operator|.
name|values
argument_list|()
control|)
block|{
name|lb
operator|.
name|checkAZombieServer
argument_list|(
name|zombieServer
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|;
block|}
comment|/**    * Return the HttpClient this instance uses.    */
DECL|method|getHttpClient
specifier|public
name|HttpClient
name|getHttpClient
parameter_list|()
block|{
return|return
name|httpClient
return|;
block|}
DECL|method|getParser
specifier|public
name|ResponseParser
name|getParser
parameter_list|()
block|{
return|return
name|parser
return|;
block|}
comment|/**    * Changes the {@link ResponseParser} that will be used for the internal    * SolrServer objects.    *    * @param parser Default Response Parser chosen to parse the response if the parser    *               were not specified as part of the request.    * @see org.apache.solr.client.solrj.SolrRequest#getResponseParser()    */
DECL|method|setParser
specifier|public
name|void
name|setParser
parameter_list|(
name|ResponseParser
name|parser
parameter_list|)
block|{
name|this
operator|.
name|parser
operator|=
name|parser
expr_stmt|;
block|}
comment|/**    * Changes the {@link RequestWriter} that will be used for the internal    * SolrServer objects.    *    * @param requestWriter Default RequestWriter, used to encode requests sent to the server.    */
DECL|method|setRequestWriter
specifier|public
name|void
name|setRequestWriter
parameter_list|(
name|RequestWriter
name|requestWriter
parameter_list|)
block|{
name|this
operator|.
name|requestWriter
operator|=
name|requestWriter
expr_stmt|;
block|}
DECL|method|getRequestWriter
specifier|public
name|RequestWriter
name|getRequestWriter
parameter_list|()
block|{
return|return
name|requestWriter
return|;
block|}
annotation|@
name|Override
DECL|method|finalize
specifier|protected
name|void
name|finalize
parameter_list|()
throws|throws
name|Throwable
block|{
try|try
block|{
if|if
condition|(
name|this
operator|.
name|aliveCheckExecutor
operator|!=
literal|null
condition|)
name|this
operator|.
name|aliveCheckExecutor
operator|.
name|shutdownNow
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|super
operator|.
name|finalize
argument_list|()
expr_stmt|;
block|}
block|}
comment|// defaults
DECL|field|CHECK_INTERVAL
specifier|private
specifier|static
specifier|final
name|int
name|CHECK_INTERVAL
init|=
literal|60
operator|*
literal|1000
decl_stmt|;
comment|//1 minute between checks
DECL|field|NONSTANDARD_PING_LIMIT
specifier|private
specifier|static
specifier|final
name|int
name|NONSTANDARD_PING_LIMIT
init|=
literal|5
decl_stmt|;
comment|// number of times we'll ping dead servers not in the server list
comment|/**    * Constructs {@link LBHttpSolrClient} instances from provided configuration.    */
DECL|class|Builder
specifier|public
specifier|static
class|class
name|Builder
block|{
DECL|field|baseSolrUrls
specifier|private
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|baseSolrUrls
decl_stmt|;
DECL|field|httpClient
specifier|private
name|HttpClient
name|httpClient
decl_stmt|;
DECL|field|responseParser
specifier|private
name|ResponseParser
name|responseParser
decl_stmt|;
DECL|method|Builder
specifier|public
name|Builder
parameter_list|()
block|{
name|this
operator|.
name|baseSolrUrls
operator|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
expr_stmt|;
name|this
operator|.
name|responseParser
operator|=
operator|new
name|BinaryResponseParser
argument_list|()
expr_stmt|;
block|}
comment|/**      * Provide a Solr endpoint to be used when configuring {@link LBHttpSolrClient} instances.      *       * Method may be called multiple times.  All provided values will be used.      */
DECL|method|withBaseSolrUrl
specifier|public
name|Builder
name|withBaseSolrUrl
parameter_list|(
name|String
name|baseSolrUrl
parameter_list|)
block|{
name|this
operator|.
name|baseSolrUrls
operator|.
name|add
argument_list|(
name|baseSolrUrl
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**      * Provide Solr endpoints to be used when configuring {@link LBHttpSolrClient} instances.      *       * Method may be called multiple times.  All provided values will be used.      */
DECL|method|withBaseSolrUrls
specifier|public
name|Builder
name|withBaseSolrUrls
parameter_list|(
name|String
modifier|...
name|solrUrls
parameter_list|)
block|{
for|for
control|(
name|String
name|baseSolrUrl
range|:
name|solrUrls
control|)
block|{
name|this
operator|.
name|baseSolrUrls
operator|.
name|add
argument_list|(
name|baseSolrUrl
argument_list|)
expr_stmt|;
block|}
return|return
name|this
return|;
block|}
comment|/**      * Provides a {@link HttpClient} for the builder to use when creating clients.      */
DECL|method|withHttpClient
specifier|public
name|Builder
name|withHttpClient
parameter_list|(
name|HttpClient
name|httpClient
parameter_list|)
block|{
name|this
operator|.
name|httpClient
operator|=
name|httpClient
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**      * Provides a {@link ResponseParser} for created clients to use when handling requests.      */
DECL|method|withResponseParser
specifier|public
name|Builder
name|withResponseParser
parameter_list|(
name|ResponseParser
name|responseParser
parameter_list|)
block|{
name|this
operator|.
name|responseParser
operator|=
name|responseParser
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**      * Create a {@link HttpSolrClient} based on provided configuration.      */
DECL|method|build
specifier|public
name|LBHttpSolrClient
name|build
parameter_list|()
block|{
specifier|final
name|String
index|[]
name|baseUrlArray
init|=
operator|new
name|String
index|[
name|baseSolrUrls
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
return|return
operator|new
name|LBHttpSolrClient
argument_list|(
name|httpClient
argument_list|,
name|responseParser
argument_list|,
name|baseSolrUrls
operator|.
name|toArray
argument_list|(
name|baseUrlArray
argument_list|)
argument_list|)
return|;
block|}
block|}
block|}
end_class
end_unit
