begin_unit
begin_package
DECL|package|org.apache.solr.client.solrj.impl
package|package
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|client
operator|.
name|solrj
operator|.
name|impl
package|;
end_package
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|http
operator|.
name|NoHttpResponseException
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|http
operator|.
name|client
operator|.
name|HttpClient
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|http
operator|.
name|conn
operator|.
name|ConnectTimeoutException
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|client
operator|.
name|solrj
operator|.
name|ResponseParser
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|client
operator|.
name|solrj
operator|.
name|SolrClient
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|client
operator|.
name|solrj
operator|.
name|SolrRequest
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|client
operator|.
name|solrj
operator|.
name|SolrServerException
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|client
operator|.
name|solrj
operator|.
name|request
operator|.
name|AbstractUpdateRequest
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|client
operator|.
name|solrj
operator|.
name|request
operator|.
name|IsUpdateRequest
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|client
operator|.
name|solrj
operator|.
name|request
operator|.
name|RequestWriter
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|client
operator|.
name|solrj
operator|.
name|request
operator|.
name|UpdateRequest
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|client
operator|.
name|solrj
operator|.
name|util
operator|.
name|ClientUtils
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|SolrException
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|SolrException
operator|.
name|ErrorCode
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|cloud
operator|.
name|Aliases
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|cloud
operator|.
name|ClusterState
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|cloud
operator|.
name|DocCollection
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|cloud
operator|.
name|DocRouter
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|cloud
operator|.
name|ImplicitDocRouter
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|cloud
operator|.
name|Replica
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|cloud
operator|.
name|Slice
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|cloud
operator|.
name|ZkCoreNodeProps
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|cloud
operator|.
name|ZkNodeProps
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|cloud
operator|.
name|ZkStateReader
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|cloud
operator|.
name|ZooKeeperException
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|params
operator|.
name|ModifiableSolrParams
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|params
operator|.
name|ShardParams
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|params
operator|.
name|SolrParams
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|params
operator|.
name|UpdateParams
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|util
operator|.
name|Hash
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|util
operator|.
name|NamedList
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|util
operator|.
name|SolrjNamedThreadFactory
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|util
operator|.
name|StrUtils
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|KeeperException
import|;
end_import
begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import
begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|net
operator|.
name|ConnectException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|net
operator|.
name|SocketException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|Path
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Random
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Callable
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentHashMap
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ExecutionException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ExecutorService
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Executors
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Future
import|;
end_import
begin_comment
comment|/**  * SolrJ client class to communicate with SolrCloud.  * Instances of this class communicate with Zookeeper to discover  * Solr endpoints for SolrCloud collections, and then use the   * {@link LBHttpSolrClient} to issue requests.  *   * This class assumes the id field for your documents is called  * 'id' - if this is not the case, you must set the right name  * with {@link #setIdField(String)}.  */
end_comment
begin_class
annotation|@
name|SuppressWarnings
argument_list|(
literal|"serial"
argument_list|)
DECL|class|CloudSolrClient
specifier|public
class|class
name|CloudSolrClient
extends|extends
name|SolrClient
block|{
DECL|field|log
specifier|protected
specifier|static
specifier|final
name|Logger
name|log
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|CloudSolrClient
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|zkStateReader
specifier|private
specifier|volatile
name|ZkStateReader
name|zkStateReader
decl_stmt|;
DECL|field|zkHost
specifier|private
name|String
name|zkHost
decl_stmt|;
comment|// the zk server connect string
DECL|field|zkConnectTimeout
specifier|private
name|int
name|zkConnectTimeout
init|=
literal|10000
decl_stmt|;
DECL|field|zkClientTimeout
specifier|private
name|int
name|zkClientTimeout
init|=
literal|10000
decl_stmt|;
DECL|field|defaultCollection
specifier|private
specifier|volatile
name|String
name|defaultCollection
decl_stmt|;
DECL|field|lbClient
specifier|private
specifier|final
name|LBHttpSolrClient
name|lbClient
decl_stmt|;
DECL|field|shutdownLBHttpSolrServer
specifier|private
specifier|final
name|boolean
name|shutdownLBHttpSolrServer
decl_stmt|;
DECL|field|myClient
specifier|private
name|HttpClient
name|myClient
decl_stmt|;
DECL|field|clientIsInternal
specifier|private
specifier|final
name|boolean
name|clientIsInternal
decl_stmt|;
comment|//no of times collection state to be reloaded if stale state error is received
DECL|field|MAX_STALE_RETRIES
specifier|private
specifier|static
specifier|final
name|int
name|MAX_STALE_RETRIES
init|=
literal|5
decl_stmt|;
DECL|field|rand
name|Random
name|rand
init|=
operator|new
name|Random
argument_list|()
decl_stmt|;
DECL|field|updatesToLeaders
specifier|private
specifier|final
name|boolean
name|updatesToLeaders
decl_stmt|;
DECL|field|parallelUpdates
specifier|private
name|boolean
name|parallelUpdates
init|=
literal|true
decl_stmt|;
DECL|field|threadPool
specifier|private
name|ExecutorService
name|threadPool
init|=
name|Executors
operator|.
name|newCachedThreadPool
argument_list|(
operator|new
name|SolrjNamedThreadFactory
argument_list|(
literal|"CloudSolrServer ThreadPool"
argument_list|)
argument_list|)
decl_stmt|;
DECL|field|idField
specifier|private
name|String
name|idField
init|=
literal|"id"
decl_stmt|;
DECL|field|STATE_VERSION
specifier|public
specifier|static
specifier|final
name|String
name|STATE_VERSION
init|=
literal|"_stateVer_"
decl_stmt|;
DECL|field|NON_ROUTABLE_PARAMS
specifier|private
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|NON_ROUTABLE_PARAMS
decl_stmt|;
block|{
name|NON_ROUTABLE_PARAMS
operator|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
expr_stmt|;
name|NON_ROUTABLE_PARAMS
operator|.
name|add
parameter_list|(
name|UpdateParams
operator|.
name|EXPUNGE_DELETES
parameter_list|)
constructor_decl|;
name|NON_ROUTABLE_PARAMS
operator|.
name|add
parameter_list|(
name|UpdateParams
operator|.
name|MAX_OPTIMIZE_SEGMENTS
parameter_list|)
constructor_decl|;
name|NON_ROUTABLE_PARAMS
operator|.
name|add
parameter_list|(
name|UpdateParams
operator|.
name|COMMIT
parameter_list|)
constructor_decl|;
name|NON_ROUTABLE_PARAMS
operator|.
name|add
parameter_list|(
name|UpdateParams
operator|.
name|WAIT_SEARCHER
parameter_list|)
constructor_decl|;
name|NON_ROUTABLE_PARAMS
operator|.
name|add
parameter_list|(
name|UpdateParams
operator|.
name|OPEN_SEARCHER
parameter_list|)
constructor_decl|;
name|NON_ROUTABLE_PARAMS
operator|.
name|add
parameter_list|(
name|UpdateParams
operator|.
name|SOFT_COMMIT
parameter_list|)
constructor_decl|;
name|NON_ROUTABLE_PARAMS
operator|.
name|add
parameter_list|(
name|UpdateParams
operator|.
name|PREPARE_COMMIT
parameter_list|)
constructor_decl|;
name|NON_ROUTABLE_PARAMS
operator|.
name|add
parameter_list|(
name|UpdateParams
operator|.
name|OPTIMIZE
parameter_list|)
constructor_decl|;
comment|// Not supported via SolrCloud
comment|// NON_ROUTABLE_PARAMS.add(UpdateParams.ROLLBACK);
block|}
DECL|field|timeToLive
specifier|private
specifier|volatile
name|long
name|timeToLive
init|=
literal|60
operator|*
literal|1000L
decl_stmt|;
DECL|field|locks
specifier|private
specifier|volatile
name|List
argument_list|<
name|Object
argument_list|>
name|locks
init|=
name|objectList
argument_list|(
literal|3
argument_list|)
decl_stmt|;
DECL|field|collectionStateCache
specifier|protected
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|ExpiringCachedDocCollection
argument_list|>
name|collectionStateCache
init|=
operator|new
name|ConcurrentHashMap
argument_list|<
name|String
argument_list|,
name|ExpiringCachedDocCollection
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|ExpiringCachedDocCollection
name|get
parameter_list|(
name|Object
name|key
parameter_list|)
block|{
name|ExpiringCachedDocCollection
name|val
init|=
name|super
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|val
operator|==
literal|null
condition|)
return|return
literal|null
return|;
if|if
condition|(
name|val
operator|.
name|isExpired
argument_list|(
name|timeToLive
argument_list|)
condition|)
block|{
name|super
operator|.
name|remove
argument_list|(
name|key
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
return|return
name|val
return|;
block|}
block|}
decl_stmt|;
DECL|class|ExpiringCachedDocCollection
class|class
name|ExpiringCachedDocCollection
block|{
DECL|field|cached
specifier|final
name|DocCollection
name|cached
decl_stmt|;
DECL|field|cachedAt
name|long
name|cachedAt
decl_stmt|;
DECL|method|ExpiringCachedDocCollection
name|ExpiringCachedDocCollection
parameter_list|(
name|DocCollection
name|cached
parameter_list|)
block|{
name|this
operator|.
name|cached
operator|=
name|cached
expr_stmt|;
name|this
operator|.
name|cachedAt
operator|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
expr_stmt|;
block|}
DECL|method|isExpired
name|boolean
name|isExpired
parameter_list|(
name|long
name|timeToLive
parameter_list|)
block|{
return|return
operator|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|-
name|cachedAt
operator|)
operator|>
name|timeToLive
return|;
block|}
block|}
comment|/**    * Create a new client object that connects to Zookeeper and is always aware    * of the SolrCloud state. If there is a fully redundant Zookeeper quorum and    * SolrCloud has enough replicas for every shard in a collection, there is no    * single point of failure. Updates will be sent to shard leaders by default.    *     * @param zkHost    *          The client endpoint of the zookeeper quorum containing the cloud    *          state. The full specification for this string is one or more comma    *          separated HOST:PORT values, followed by an optional chroot value    *          that starts with a forward slash. Using a chroot allows multiple    *          applications to coexist in one ensemble. For full details, see the    *          Zookeeper documentation. Some examples:    *<p>    *          "host1:2181"    *<p>    *          "host1:2181,host2:2181,host3:2181/mysolrchroot"    *<p>    *          "zoo1.example.com:2181,zoo2.example.com:2181,zoo3.example.com:2181"    */
DECL|method|CloudSolrClient
specifier|public
name|CloudSolrClient
parameter_list|(
name|String
name|zkHost
parameter_list|)
block|{
name|this
operator|.
name|zkHost
operator|=
name|zkHost
expr_stmt|;
name|this
operator|.
name|clientIsInternal
operator|=
literal|true
expr_stmt|;
name|this
operator|.
name|myClient
operator|=
name|HttpClientUtil
operator|.
name|createClient
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|this
operator|.
name|lbClient
operator|=
operator|new
name|LBHttpSolrClient
argument_list|(
name|myClient
argument_list|)
expr_stmt|;
name|this
operator|.
name|lbClient
operator|.
name|setRequestWriter
argument_list|(
operator|new
name|BinaryRequestWriter
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|lbClient
operator|.
name|setParser
argument_list|(
operator|new
name|BinaryResponseParser
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|updatesToLeaders
operator|=
literal|true
expr_stmt|;
name|shutdownLBHttpSolrServer
operator|=
literal|true
expr_stmt|;
name|lbClient
operator|.
name|addQueryParams
argument_list|(
name|STATE_VERSION
argument_list|)
expr_stmt|;
block|}
comment|/**    * Create a new client object that connects to Zookeeper and is always aware    * of the SolrCloud state. If there is a fully redundant Zookeeper quorum and    * SolrCloud has enough replicas for every shard in a collection, there is no    * single point of failure. Updates will be sent to shard leaders by default.    *    * @param zkHost    *          The client endpoint of the zookeeper quorum containing the cloud    *          state. The full specification for this string is one or more comma    *          separated HOST:PORT values, followed by an optional chroot value    *          that starts with a forward slash. Using a chroot allows multiple    *          applications to coexist in one ensemble. For full details, see the    *          Zookeeper documentation. Some examples:    *<p>    *          "host1:2181"    *<p>    *          "host1:2181,host2:2181,host3:2181/mysolrchroot"    *<p>    *          "zoo1.example.com:2181,zoo2.example.com:2181,zoo3.example.com:2181"    * @param httpClient    *          the {@link HttpClient} instance to be used for all requests. The    *          provided httpClient should use a multi-threaded connection manager.    */
DECL|method|CloudSolrClient
specifier|public
name|CloudSolrClient
parameter_list|(
name|String
name|zkHost
parameter_list|,
name|HttpClient
name|httpClient
parameter_list|)
block|{
name|this
operator|.
name|zkHost
operator|=
name|zkHost
expr_stmt|;
name|this
operator|.
name|clientIsInternal
operator|=
name|httpClient
operator|==
literal|null
expr_stmt|;
name|this
operator|.
name|myClient
operator|=
name|httpClient
operator|==
literal|null
condition|?
name|HttpClientUtil
operator|.
name|createClient
argument_list|(
literal|null
argument_list|)
else|:
name|httpClient
expr_stmt|;
name|this
operator|.
name|lbClient
operator|=
operator|new
name|LBHttpSolrClient
argument_list|(
name|myClient
argument_list|)
expr_stmt|;
name|this
operator|.
name|lbClient
operator|.
name|setRequestWriter
argument_list|(
operator|new
name|BinaryRequestWriter
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|lbClient
operator|.
name|setParser
argument_list|(
operator|new
name|BinaryResponseParser
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|updatesToLeaders
operator|=
literal|true
expr_stmt|;
name|shutdownLBHttpSolrServer
operator|=
literal|true
expr_stmt|;
name|lbClient
operator|.
name|addQueryParams
argument_list|(
name|STATE_VERSION
argument_list|)
expr_stmt|;
block|}
comment|/**    * Create a new client object using multiple string values in a Collection    * instead of a standard zkHost connection string. Note that this method will    * not be used if there is only one String argument - that will use    * {@link #CloudSolrClient(String)} instead.    *     * @param zkHosts    *          A Java Collection (List, Set, etc) of HOST:PORT strings, one for    *          each host in the zookeeper ensemble. Note that with certain    *          Collection types like HashSet, the order of hosts in the final    *          connect string may not be in the same order you added them.    * @param chroot    *          A chroot value for zookeeper, starting with a forward slash. If no    *          chroot is required, use null.    * @throws IllegalArgumentException    *           if the chroot value does not start with a forward slash.    * @see #CloudSolrClient(String)    */
DECL|method|CloudSolrClient
specifier|public
name|CloudSolrClient
parameter_list|(
name|Collection
argument_list|<
name|String
argument_list|>
name|zkHosts
parameter_list|,
name|String
name|chroot
parameter_list|)
block|{
name|this
argument_list|(
name|zkHosts
argument_list|,
name|chroot
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/**    * Create a new client object using multiple string values in a Collection    * instead of a standard zkHost connection string. Note that this method will    * not be used if there is only one String argument - that will use    * {@link #CloudSolrClient(String)} instead.    *    * @param zkHosts    *          A Java Collection (List, Set, etc) of HOST:PORT strings, one for    *          each host in the zookeeper ensemble. Note that with certain    *          Collection types like HashSet, the order of hosts in the final    *          connect string may not be in the same order you added them.    * @param chroot    *          A chroot value for zookeeper, starting with a forward slash. If no    *          chroot is required, use null.    * @param httpClient    *          the {@link HttpClient} instance to be used for all requests. The provided httpClient should use a    *          multi-threaded connection manager.    * @throws IllegalArgumentException    *           if the chroot value does not start with a forward slash.    * @see #CloudSolrClient(String)    */
DECL|method|CloudSolrClient
specifier|public
name|CloudSolrClient
parameter_list|(
name|Collection
argument_list|<
name|String
argument_list|>
name|zkHosts
parameter_list|,
name|String
name|chroot
parameter_list|,
name|HttpClient
name|httpClient
parameter_list|)
block|{
name|StringBuilder
name|zkBuilder
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|int
name|lastIndexValue
init|=
name|zkHosts
operator|.
name|size
argument_list|()
operator|-
literal|1
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
name|String
name|zkHost
range|:
name|zkHosts
control|)
block|{
name|zkBuilder
operator|.
name|append
argument_list|(
name|zkHost
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|lastIndexValue
condition|)
block|{
name|zkBuilder
operator|.
name|append
argument_list|(
literal|","
argument_list|)
expr_stmt|;
block|}
name|i
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|chroot
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|chroot
operator|.
name|startsWith
argument_list|(
literal|"/"
argument_list|)
condition|)
block|{
name|zkBuilder
operator|.
name|append
argument_list|(
name|chroot
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The chroot must start with a forward slash."
argument_list|)
throw|;
block|}
block|}
comment|/* Log the constructed connection string and then initialize. */
name|log
operator|.
name|info
argument_list|(
literal|"Final constructed zkHost string: "
operator|+
name|zkBuilder
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|zkHost
operator|=
name|zkBuilder
operator|.
name|toString
argument_list|()
expr_stmt|;
name|this
operator|.
name|clientIsInternal
operator|=
name|httpClient
operator|==
literal|null
expr_stmt|;
name|this
operator|.
name|myClient
operator|=
name|httpClient
operator|==
literal|null
condition|?
name|HttpClientUtil
operator|.
name|createClient
argument_list|(
literal|null
argument_list|)
else|:
name|httpClient
expr_stmt|;
name|this
operator|.
name|lbClient
operator|=
operator|new
name|LBHttpSolrClient
argument_list|(
name|myClient
argument_list|)
expr_stmt|;
name|this
operator|.
name|lbClient
operator|.
name|setRequestWriter
argument_list|(
operator|new
name|BinaryRequestWriter
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|lbClient
operator|.
name|setParser
argument_list|(
operator|new
name|BinaryResponseParser
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|updatesToLeaders
operator|=
literal|true
expr_stmt|;
name|shutdownLBHttpSolrServer
operator|=
literal|true
expr_stmt|;
block|}
comment|/**    * @param zkHost    *          A zookeeper client endpoint.    * @param updatesToLeaders    *          If true, sends updates only to shard leaders.    * @see #CloudSolrClient(String) for full description and details on zkHost    */
DECL|method|CloudSolrClient
specifier|public
name|CloudSolrClient
parameter_list|(
name|String
name|zkHost
parameter_list|,
name|boolean
name|updatesToLeaders
parameter_list|)
block|{
name|this
argument_list|(
name|zkHost
argument_list|,
name|updatesToLeaders
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/**    * @param zkHost    *          A zookeeper client endpoint.    * @param updatesToLeaders    *          If true, sends updates only to shard leaders.    * @param httpClient    *          the {@link HttpClient} instance to be used for all requests. The provided httpClient should use a    *          multi-threaded connection manager.    * @see #CloudSolrClient(String) for full description and details on zkHost    */
DECL|method|CloudSolrClient
specifier|public
name|CloudSolrClient
parameter_list|(
name|String
name|zkHost
parameter_list|,
name|boolean
name|updatesToLeaders
parameter_list|,
name|HttpClient
name|httpClient
parameter_list|)
block|{
name|this
operator|.
name|zkHost
operator|=
name|zkHost
expr_stmt|;
name|this
operator|.
name|clientIsInternal
operator|=
name|httpClient
operator|==
literal|null
expr_stmt|;
name|this
operator|.
name|myClient
operator|=
name|httpClient
operator|==
literal|null
condition|?
name|HttpClientUtil
operator|.
name|createClient
argument_list|(
literal|null
argument_list|)
else|:
name|httpClient
expr_stmt|;
name|this
operator|.
name|lbClient
operator|=
operator|new
name|LBHttpSolrClient
argument_list|(
name|myClient
argument_list|)
expr_stmt|;
name|this
operator|.
name|lbClient
operator|.
name|setRequestWriter
argument_list|(
operator|new
name|BinaryRequestWriter
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|lbClient
operator|.
name|setParser
argument_list|(
operator|new
name|BinaryResponseParser
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|updatesToLeaders
operator|=
name|updatesToLeaders
expr_stmt|;
name|shutdownLBHttpSolrServer
operator|=
literal|true
expr_stmt|;
name|lbClient
operator|.
name|addQueryParams
argument_list|(
name|STATE_VERSION
argument_list|)
expr_stmt|;
block|}
comment|/**Sets the cache ttl for DocCollection Objects cached  . This is only applicable for collections which are persisted outside of clusterstate.json    * @param seconds ttl value in seconds    */
DECL|method|setCollectionCacheTTl
specifier|public
name|void
name|setCollectionCacheTTl
parameter_list|(
name|int
name|seconds
parameter_list|)
block|{
assert|assert
name|seconds
operator|>
literal|0
assert|;
name|timeToLive
operator|=
name|seconds
operator|*
literal|1000L
expr_stmt|;
block|}
comment|/**    * @param zkHost    *          A zookeeper client endpoint.    * @param lbClient    *          LBHttpSolrServer instance for requests.    * @see #CloudSolrClient(String) for full description and details on zkHost    */
DECL|method|CloudSolrClient
specifier|public
name|CloudSolrClient
parameter_list|(
name|String
name|zkHost
parameter_list|,
name|LBHttpSolrClient
name|lbClient
parameter_list|)
block|{
name|this
argument_list|(
name|zkHost
argument_list|,
name|lbClient
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
comment|/**    * @param zkHost    *          A zookeeper client endpoint.    * @param lbClient    *          LBHttpSolrServer instance for requests.    * @param updatesToLeaders    *          If true, sends updates only to shard leaders.    * @see #CloudSolrClient(String) for full description and details on zkHost    */
DECL|method|CloudSolrClient
specifier|public
name|CloudSolrClient
parameter_list|(
name|String
name|zkHost
parameter_list|,
name|LBHttpSolrClient
name|lbClient
parameter_list|,
name|boolean
name|updatesToLeaders
parameter_list|)
block|{
name|this
operator|.
name|zkHost
operator|=
name|zkHost
expr_stmt|;
name|this
operator|.
name|lbClient
operator|=
name|lbClient
expr_stmt|;
name|this
operator|.
name|updatesToLeaders
operator|=
name|updatesToLeaders
expr_stmt|;
name|shutdownLBHttpSolrServer
operator|=
literal|false
expr_stmt|;
name|this
operator|.
name|clientIsInternal
operator|=
literal|false
expr_stmt|;
name|lbClient
operator|.
name|addQueryParams
argument_list|(
name|STATE_VERSION
argument_list|)
expr_stmt|;
block|}
DECL|method|getParser
specifier|public
name|ResponseParser
name|getParser
parameter_list|()
block|{
return|return
name|lbClient
operator|.
name|getParser
argument_list|()
return|;
block|}
comment|/**    * Note: This setter method is<b>not thread-safe</b>.    *     * @param processor    *          Default Response Parser chosen to parse the response if the parser    *          were not specified as part of the request.    * @see org.apache.solr.client.solrj.SolrRequest#getResponseParser()    */
DECL|method|setParser
specifier|public
name|void
name|setParser
parameter_list|(
name|ResponseParser
name|processor
parameter_list|)
block|{
name|lbClient
operator|.
name|setParser
argument_list|(
name|processor
argument_list|)
expr_stmt|;
block|}
DECL|method|getRequestWriter
specifier|public
name|RequestWriter
name|getRequestWriter
parameter_list|()
block|{
return|return
name|lbClient
operator|.
name|getRequestWriter
argument_list|()
return|;
block|}
DECL|method|setRequestWriter
specifier|public
name|void
name|setRequestWriter
parameter_list|(
name|RequestWriter
name|requestWriter
parameter_list|)
block|{
name|lbClient
operator|.
name|setRequestWriter
argument_list|(
name|requestWriter
argument_list|)
expr_stmt|;
block|}
comment|/**    * @return the zkHost value used to connect to zookeeper.    */
DECL|method|getZkHost
specifier|public
name|String
name|getZkHost
parameter_list|()
block|{
return|return
name|zkHost
return|;
block|}
DECL|method|getZkStateReader
specifier|public
name|ZkStateReader
name|getZkStateReader
parameter_list|()
block|{
return|return
name|zkStateReader
return|;
block|}
comment|/**    * @param idField the field to route documents on.    */
DECL|method|setIdField
specifier|public
name|void
name|setIdField
parameter_list|(
name|String
name|idField
parameter_list|)
block|{
name|this
operator|.
name|idField
operator|=
name|idField
expr_stmt|;
block|}
comment|/**    * @return the field that updates are routed on.    */
DECL|method|getIdField
specifier|public
name|String
name|getIdField
parameter_list|()
block|{
return|return
name|idField
return|;
block|}
comment|/** Sets the default collection for request */
DECL|method|setDefaultCollection
specifier|public
name|void
name|setDefaultCollection
parameter_list|(
name|String
name|collection
parameter_list|)
block|{
name|this
operator|.
name|defaultCollection
operator|=
name|collection
expr_stmt|;
block|}
comment|/** Gets the default collection for request */
DECL|method|getDefaultCollection
specifier|public
name|String
name|getDefaultCollection
parameter_list|()
block|{
return|return
name|defaultCollection
return|;
block|}
comment|/** Set the connect timeout to the zookeeper ensemble in ms */
DECL|method|setZkConnectTimeout
specifier|public
name|void
name|setZkConnectTimeout
parameter_list|(
name|int
name|zkConnectTimeout
parameter_list|)
block|{
name|this
operator|.
name|zkConnectTimeout
operator|=
name|zkConnectTimeout
expr_stmt|;
block|}
comment|/** Set the timeout to the zookeeper ensemble in ms */
DECL|method|setZkClientTimeout
specifier|public
name|void
name|setZkClientTimeout
parameter_list|(
name|int
name|zkClientTimeout
parameter_list|)
block|{
name|this
operator|.
name|zkClientTimeout
operator|=
name|zkClientTimeout
expr_stmt|;
block|}
comment|/**    * Connect to the zookeeper ensemble.    * This is an optional method that may be used to force a connect before any other requests are sent.    *    */
DECL|method|connect
specifier|public
name|void
name|connect
parameter_list|()
block|{
if|if
condition|(
name|zkStateReader
operator|==
literal|null
condition|)
block|{
synchronized|synchronized
init|(
name|this
init|)
block|{
if|if
condition|(
name|zkStateReader
operator|==
literal|null
condition|)
block|{
name|ZkStateReader
name|zk
init|=
literal|null
decl_stmt|;
try|try
block|{
name|zk
operator|=
operator|new
name|ZkStateReader
argument_list|(
name|zkHost
argument_list|,
name|zkClientTimeout
argument_list|,
name|zkConnectTimeout
argument_list|)
expr_stmt|;
name|zk
operator|.
name|createClusterStateWatchersAndUpdate
argument_list|()
expr_stmt|;
name|zkStateReader
operator|=
name|zk
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|zk
operator|.
name|close
argument_list|()
expr_stmt|;
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
throw|throw
operator|new
name|ZooKeeperException
argument_list|(
name|SolrException
operator|.
name|ErrorCode
operator|.
name|SERVER_ERROR
argument_list|,
literal|""
argument_list|,
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|KeeperException
name|e
parameter_list|)
block|{
name|zk
operator|.
name|close
argument_list|()
expr_stmt|;
throw|throw
operator|new
name|ZooKeeperException
argument_list|(
name|SolrException
operator|.
name|ErrorCode
operator|.
name|SERVER_ERROR
argument_list|,
literal|""
argument_list|,
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
if|if
condition|(
name|zk
operator|!=
literal|null
condition|)
name|zk
operator|.
name|close
argument_list|()
expr_stmt|;
comment|// do not wrap because clients may be relying on the underlying exception being thrown
throw|throw
name|e
throw|;
block|}
block|}
block|}
block|}
block|}
DECL|method|setParallelUpdates
specifier|public
name|void
name|setParallelUpdates
parameter_list|(
name|boolean
name|parallelUpdates
parameter_list|)
block|{
name|this
operator|.
name|parallelUpdates
operator|=
name|parallelUpdates
expr_stmt|;
block|}
comment|/**    * Upload a set of config files to Zookeeper and give it a name    *    * NOTE: You should only allow trusted users to upload configs.  If you    * are allowing client access to zookeeper, you should protect the    * /configs node against unauthorised write access.    *    * @param configPath {@link java.nio.file.Path} to the config files    * @param configName the name of the config    * @throws IOException if an IO error occurs    */
DECL|method|uploadConfig
specifier|public
name|void
name|uploadConfig
parameter_list|(
name|Path
name|configPath
parameter_list|,
name|String
name|configName
parameter_list|)
throws|throws
name|IOException
block|{
name|zkStateReader
operator|.
name|getConfigManager
argument_list|()
operator|.
name|uploadConfigDir
argument_list|(
name|configPath
argument_list|,
name|configName
argument_list|)
expr_stmt|;
block|}
comment|/**    * Download a named config from Zookeeper to a location on the filesystem    * @param configName    the name of the config    * @param downloadPath  the path to write config files to    * @throws IOException  if an I/O exception occurs    */
DECL|method|downloadConfig
specifier|public
name|void
name|downloadConfig
parameter_list|(
name|String
name|configName
parameter_list|,
name|Path
name|downloadPath
parameter_list|)
throws|throws
name|IOException
block|{
name|zkStateReader
operator|.
name|getConfigManager
argument_list|()
operator|.
name|downloadConfigDir
argument_list|(
name|configName
argument_list|,
name|downloadPath
argument_list|)
expr_stmt|;
block|}
DECL|method|directUpdate
specifier|private
name|NamedList
argument_list|<
name|Object
argument_list|>
name|directUpdate
parameter_list|(
name|AbstractUpdateRequest
name|request
parameter_list|,
name|ClusterState
name|clusterState
parameter_list|)
throws|throws
name|SolrServerException
block|{
name|UpdateRequest
name|updateRequest
init|=
operator|(
name|UpdateRequest
operator|)
name|request
decl_stmt|;
name|ModifiableSolrParams
name|params
init|=
operator|(
name|ModifiableSolrParams
operator|)
name|request
operator|.
name|getParams
argument_list|()
decl_stmt|;
name|ModifiableSolrParams
name|routableParams
init|=
operator|new
name|ModifiableSolrParams
argument_list|()
decl_stmt|;
name|ModifiableSolrParams
name|nonRoutableParams
init|=
operator|new
name|ModifiableSolrParams
argument_list|()
decl_stmt|;
if|if
condition|(
name|params
operator|!=
literal|null
condition|)
block|{
name|nonRoutableParams
operator|.
name|add
argument_list|(
name|params
argument_list|)
expr_stmt|;
name|routableParams
operator|.
name|add
argument_list|(
name|params
argument_list|)
expr_stmt|;
for|for
control|(
name|String
name|param
range|:
name|NON_ROUTABLE_PARAMS
control|)
block|{
name|routableParams
operator|.
name|remove
argument_list|(
name|param
argument_list|)
expr_stmt|;
block|}
block|}
name|String
name|collection
init|=
name|nonRoutableParams
operator|.
name|get
argument_list|(
name|UpdateParams
operator|.
name|COLLECTION
argument_list|,
name|defaultCollection
argument_list|)
decl_stmt|;
if|if
condition|(
name|collection
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|SolrServerException
argument_list|(
literal|"No collection param specified on request and no default collection has been set."
argument_list|)
throw|;
block|}
comment|//Check to see if the collection is an alias.
name|Aliases
name|aliases
init|=
name|zkStateReader
operator|.
name|getAliases
argument_list|()
decl_stmt|;
if|if
condition|(
name|aliases
operator|!=
literal|null
condition|)
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|collectionAliases
init|=
name|aliases
operator|.
name|getCollectionAliasMap
argument_list|()
decl_stmt|;
if|if
condition|(
name|collectionAliases
operator|!=
literal|null
operator|&&
name|collectionAliases
operator|.
name|containsKey
argument_list|(
name|collection
argument_list|)
condition|)
block|{
name|collection
operator|=
name|collectionAliases
operator|.
name|get
argument_list|(
name|collection
argument_list|)
expr_stmt|;
block|}
block|}
name|DocCollection
name|col
init|=
name|getDocCollection
argument_list|(
name|clusterState
argument_list|,
name|collection
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|DocRouter
name|router
init|=
name|col
operator|.
name|getRouter
argument_list|()
decl_stmt|;
if|if
condition|(
name|router
operator|instanceof
name|ImplicitDocRouter
condition|)
block|{
comment|// short circuit as optimization
return|return
literal|null
return|;
block|}
comment|//Create the URL map, which is keyed on slice name.
comment|//The value is a list of URLs for each replica in the slice.
comment|//The first value in the list is the leader for the slice.
name|Map
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|urlMap
init|=
name|buildUrlMap
argument_list|(
name|col
argument_list|)
decl_stmt|;
if|if
condition|(
name|urlMap
operator|==
literal|null
condition|)
block|{
comment|// we could not find a leader yet - use unoptimized general path
return|return
literal|null
return|;
block|}
name|NamedList
argument_list|<
name|Throwable
argument_list|>
name|exceptions
init|=
operator|new
name|NamedList
argument_list|<>
argument_list|()
decl_stmt|;
name|NamedList
argument_list|<
name|NamedList
argument_list|>
name|shardResponses
init|=
operator|new
name|NamedList
argument_list|<>
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|LBHttpSolrClient
operator|.
name|Req
argument_list|>
name|routes
init|=
name|updateRequest
operator|.
name|getRoutes
argument_list|(
name|router
argument_list|,
name|col
argument_list|,
name|urlMap
argument_list|,
name|routableParams
argument_list|,
name|this
operator|.
name|idField
argument_list|)
decl_stmt|;
if|if
condition|(
name|routes
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|long
name|start
init|=
name|System
operator|.
name|nanoTime
argument_list|()
decl_stmt|;
if|if
condition|(
name|parallelUpdates
condition|)
block|{
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|Future
argument_list|<
name|NamedList
argument_list|<
name|?
argument_list|>
argument_list|>
argument_list|>
name|responseFutures
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|(
name|routes
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
specifier|final
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|LBHttpSolrClient
operator|.
name|Req
argument_list|>
name|entry
range|:
name|routes
operator|.
name|entrySet
argument_list|()
control|)
block|{
specifier|final
name|String
name|url
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
specifier|final
name|LBHttpSolrClient
operator|.
name|Req
name|lbRequest
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|responseFutures
operator|.
name|put
argument_list|(
name|url
argument_list|,
name|threadPool
operator|.
name|submit
argument_list|(
operator|new
name|Callable
argument_list|<
name|NamedList
argument_list|<
name|?
argument_list|>
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|NamedList
argument_list|<
name|?
argument_list|>
name|call
parameter_list|()
throws|throws
name|Exception
block|{
return|return
name|lbClient
operator|.
name|request
argument_list|(
name|lbRequest
argument_list|)
operator|.
name|getResponse
argument_list|()
return|;
block|}
block|}
block|)
block|)
empty_stmt|;
block|}
for|for
control|(
specifier|final
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|Future
argument_list|<
name|NamedList
argument_list|<
name|?
argument_list|>
argument_list|>
argument_list|>
name|entry
range|:
name|responseFutures
operator|.
name|entrySet
argument_list|()
control|)
block|{
specifier|final
name|String
name|url
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
specifier|final
name|Future
argument_list|<
name|NamedList
argument_list|<
name|?
argument_list|>
argument_list|>
name|responseFuture
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
try|try
block|{
name|shardResponses
operator|.
name|add
argument_list|(
name|url
argument_list|,
name|responseFuture
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|ExecutionException
name|e
parameter_list|)
block|{
name|exceptions
operator|.
name|add
argument_list|(
name|url
argument_list|,
name|e
operator|.
name|getCause
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|exceptions
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
throw|throw
operator|new
name|RouteException
argument_list|(
name|ErrorCode
operator|.
name|SERVER_ERROR
argument_list|,
name|exceptions
argument_list|,
name|routes
argument_list|)
throw|;
block|}
block|}
end_class
begin_else
else|else
block|{
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|LBHttpSolrClient
operator|.
name|Req
argument_list|>
name|entry
range|:
name|routes
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|String
name|url
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|LBHttpSolrClient
operator|.
name|Req
name|lbRequest
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
try|try
block|{
name|NamedList
argument_list|<
name|Object
argument_list|>
name|rsp
init|=
name|lbClient
operator|.
name|request
argument_list|(
name|lbRequest
argument_list|)
operator|.
name|getResponse
argument_list|()
decl_stmt|;
name|shardResponses
operator|.
name|add
argument_list|(
name|url
argument_list|,
name|rsp
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SolrServerException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
block|}
end_else
begin_decl_stmt
name|UpdateRequest
name|nonRoutableRequest
init|=
literal|null
decl_stmt|;
end_decl_stmt
begin_decl_stmt
name|List
argument_list|<
name|String
argument_list|>
name|deleteQuery
init|=
name|updateRequest
operator|.
name|getDeleteQuery
argument_list|()
decl_stmt|;
end_decl_stmt
begin_if
if|if
condition|(
name|deleteQuery
operator|!=
literal|null
operator|&&
name|deleteQuery
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|UpdateRequest
name|deleteQueryRequest
init|=
operator|new
name|UpdateRequest
argument_list|()
decl_stmt|;
name|deleteQueryRequest
operator|.
name|setDeleteQuery
argument_list|(
name|deleteQuery
argument_list|)
expr_stmt|;
name|nonRoutableRequest
operator|=
name|deleteQueryRequest
expr_stmt|;
block|}
end_if
begin_decl_stmt
name|Set
argument_list|<
name|String
argument_list|>
name|paramNames
init|=
name|nonRoutableParams
operator|.
name|getParameterNames
argument_list|()
decl_stmt|;
end_decl_stmt
begin_decl_stmt
name|Set
argument_list|<
name|String
argument_list|>
name|intersection
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|(
name|paramNames
argument_list|)
decl_stmt|;
end_decl_stmt
begin_expr_stmt
name|intersection
operator|.
name|retainAll
argument_list|(
name|NON_ROUTABLE_PARAMS
argument_list|)
expr_stmt|;
end_expr_stmt
begin_if
if|if
condition|(
name|nonRoutableRequest
operator|!=
literal|null
operator|||
name|intersection
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|nonRoutableRequest
operator|==
literal|null
condition|)
block|{
name|nonRoutableRequest
operator|=
operator|new
name|UpdateRequest
argument_list|()
expr_stmt|;
block|}
name|nonRoutableRequest
operator|.
name|setParams
argument_list|(
name|nonRoutableParams
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|urlList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|urlList
operator|.
name|addAll
argument_list|(
name|routes
operator|.
name|keySet
argument_list|()
argument_list|)
expr_stmt|;
name|Collections
operator|.
name|shuffle
argument_list|(
name|urlList
argument_list|,
name|rand
argument_list|)
expr_stmt|;
name|LBHttpSolrClient
operator|.
name|Req
name|req
init|=
operator|new
name|LBHttpSolrClient
operator|.
name|Req
argument_list|(
name|nonRoutableRequest
argument_list|,
name|urlList
argument_list|)
decl_stmt|;
try|try
block|{
name|LBHttpSolrClient
operator|.
name|Rsp
name|rsp
init|=
name|lbClient
operator|.
name|request
argument_list|(
name|req
argument_list|)
decl_stmt|;
name|shardResponses
operator|.
name|add
argument_list|(
name|urlList
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
name|rsp
operator|.
name|getResponse
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|SERVER_ERROR
argument_list|,
name|urlList
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
end_if
begin_decl_stmt
name|long
name|end
init|=
name|System
operator|.
name|nanoTime
argument_list|()
decl_stmt|;
end_decl_stmt
begin_decl_stmt
name|RouteResponse
name|rr
init|=
name|condenseResponse
argument_list|(
name|shardResponses
argument_list|,
call|(
name|long
call|)
argument_list|(
operator|(
name|end
operator|-
name|start
operator|)
operator|/
literal|1000000
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt
begin_expr_stmt
name|rr
operator|.
name|setRouteResponses
argument_list|(
name|shardResponses
argument_list|)
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|rr
operator|.
name|setRoutes
argument_list|(
name|routes
argument_list|)
expr_stmt|;
end_expr_stmt
begin_return
return|return
name|rr
return|;
end_return
begin_function
unit|}    private
DECL|method|buildUrlMap
name|Map
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|buildUrlMap
parameter_list|(
name|DocCollection
name|col
parameter_list|)
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|urlMap
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|Collection
argument_list|<
name|Slice
argument_list|>
name|slices
init|=
name|col
operator|.
name|getActiveSlices
argument_list|()
decl_stmt|;
name|Iterator
argument_list|<
name|Slice
argument_list|>
name|sliceIterator
init|=
name|slices
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|sliceIterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Slice
name|slice
init|=
name|sliceIterator
operator|.
name|next
argument_list|()
decl_stmt|;
name|String
name|name
init|=
name|slice
operator|.
name|getName
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|urls
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|Replica
name|leader
init|=
name|slice
operator|.
name|getLeader
argument_list|()
decl_stmt|;
if|if
condition|(
name|leader
operator|==
literal|null
condition|)
block|{
comment|// take unoptimized general path - we cannot find a leader yet
return|return
literal|null
return|;
block|}
name|ZkCoreNodeProps
name|zkProps
init|=
operator|new
name|ZkCoreNodeProps
argument_list|(
name|leader
argument_list|)
decl_stmt|;
name|String
name|url
init|=
name|zkProps
operator|.
name|getCoreUrl
argument_list|()
decl_stmt|;
name|urls
operator|.
name|add
argument_list|(
name|url
argument_list|)
expr_stmt|;
name|Collection
argument_list|<
name|Replica
argument_list|>
name|replicas
init|=
name|slice
operator|.
name|getReplicas
argument_list|()
decl_stmt|;
name|Iterator
argument_list|<
name|Replica
argument_list|>
name|replicaIterator
init|=
name|replicas
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|replicaIterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Replica
name|replica
init|=
name|replicaIterator
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|replica
operator|.
name|getNodeName
argument_list|()
operator|.
name|equals
argument_list|(
name|leader
operator|.
name|getNodeName
argument_list|()
argument_list|)
operator|&&
operator|!
name|replica
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
name|leader
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
block|{
name|ZkCoreNodeProps
name|zkProps1
init|=
operator|new
name|ZkCoreNodeProps
argument_list|(
name|replica
argument_list|)
decl_stmt|;
name|String
name|url1
init|=
name|zkProps1
operator|.
name|getCoreUrl
argument_list|()
decl_stmt|;
name|urls
operator|.
name|add
argument_list|(
name|url1
argument_list|)
expr_stmt|;
block|}
block|}
name|urlMap
operator|.
name|put
argument_list|(
name|name
argument_list|,
name|urls
argument_list|)
expr_stmt|;
block|}
return|return
name|urlMap
return|;
block|}
end_function
begin_function
DECL|method|condenseResponse
specifier|public
name|RouteResponse
name|condenseResponse
parameter_list|(
name|NamedList
name|response
parameter_list|,
name|long
name|timeMillis
parameter_list|)
block|{
name|RouteResponse
name|condensed
init|=
operator|new
name|RouteResponse
argument_list|()
decl_stmt|;
name|int
name|status
init|=
literal|0
decl_stmt|;
name|Integer
name|rf
init|=
literal|null
decl_stmt|;
name|Integer
name|minRf
init|=
literal|null
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|response
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|NamedList
name|shardResponse
init|=
operator|(
name|NamedList
operator|)
name|response
operator|.
name|getVal
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|NamedList
name|header
init|=
operator|(
name|NamedList
operator|)
name|shardResponse
operator|.
name|get
argument_list|(
literal|"responseHeader"
argument_list|)
decl_stmt|;
name|Integer
name|shardStatus
init|=
operator|(
name|Integer
operator|)
name|header
operator|.
name|get
argument_list|(
literal|"status"
argument_list|)
decl_stmt|;
name|int
name|s
init|=
name|shardStatus
operator|.
name|intValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|s
operator|>
literal|0
condition|)
block|{
name|status
operator|=
name|s
expr_stmt|;
block|}
name|Object
name|rfObj
init|=
name|header
operator|.
name|get
argument_list|(
name|UpdateRequest
operator|.
name|REPFACT
argument_list|)
decl_stmt|;
if|if
condition|(
name|rfObj
operator|!=
literal|null
operator|&&
name|rfObj
operator|instanceof
name|Integer
condition|)
block|{
name|Integer
name|routeRf
init|=
operator|(
name|Integer
operator|)
name|rfObj
decl_stmt|;
if|if
condition|(
name|rf
operator|==
literal|null
operator|||
name|routeRf
operator|<
name|rf
condition|)
name|rf
operator|=
name|routeRf
expr_stmt|;
block|}
name|minRf
operator|=
operator|(
name|Integer
operator|)
name|header
operator|.
name|get
argument_list|(
name|UpdateRequest
operator|.
name|MIN_REPFACT
argument_list|)
expr_stmt|;
block|}
name|NamedList
name|cheader
init|=
operator|new
name|NamedList
argument_list|()
decl_stmt|;
name|cheader
operator|.
name|add
argument_list|(
literal|"status"
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|cheader
operator|.
name|add
argument_list|(
literal|"QTime"
argument_list|,
name|timeMillis
argument_list|)
expr_stmt|;
if|if
condition|(
name|rf
operator|!=
literal|null
condition|)
name|cheader
operator|.
name|add
argument_list|(
name|UpdateRequest
operator|.
name|REPFACT
argument_list|,
name|rf
argument_list|)
expr_stmt|;
if|if
condition|(
name|minRf
operator|!=
literal|null
condition|)
name|cheader
operator|.
name|add
argument_list|(
name|UpdateRequest
operator|.
name|MIN_REPFACT
argument_list|,
name|minRf
argument_list|)
expr_stmt|;
name|condensed
operator|.
name|add
argument_list|(
literal|"responseHeader"
argument_list|,
name|cheader
argument_list|)
expr_stmt|;
return|return
name|condensed
return|;
block|}
end_function
begin_class
DECL|class|RouteResponse
specifier|public
specifier|static
class|class
name|RouteResponse
extends|extends
name|NamedList
block|{
DECL|field|routeResponses
specifier|private
name|NamedList
name|routeResponses
decl_stmt|;
DECL|field|routes
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|LBHttpSolrClient
operator|.
name|Req
argument_list|>
name|routes
decl_stmt|;
DECL|method|setRouteResponses
specifier|public
name|void
name|setRouteResponses
parameter_list|(
name|NamedList
name|routeResponses
parameter_list|)
block|{
name|this
operator|.
name|routeResponses
operator|=
name|routeResponses
expr_stmt|;
block|}
DECL|method|getRouteResponses
specifier|public
name|NamedList
name|getRouteResponses
parameter_list|()
block|{
return|return
name|routeResponses
return|;
block|}
DECL|method|setRoutes
specifier|public
name|void
name|setRoutes
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|LBHttpSolrClient
operator|.
name|Req
argument_list|>
name|routes
parameter_list|)
block|{
name|this
operator|.
name|routes
operator|=
name|routes
expr_stmt|;
block|}
DECL|method|getRoutes
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|LBHttpSolrClient
operator|.
name|Req
argument_list|>
name|getRoutes
parameter_list|()
block|{
return|return
name|routes
return|;
block|}
block|}
end_class
begin_class
DECL|class|RouteException
specifier|public
specifier|static
class|class
name|RouteException
extends|extends
name|SolrException
block|{
DECL|field|throwables
specifier|private
name|NamedList
argument_list|<
name|Throwable
argument_list|>
name|throwables
decl_stmt|;
DECL|field|routes
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|LBHttpSolrClient
operator|.
name|Req
argument_list|>
name|routes
decl_stmt|;
DECL|method|RouteException
specifier|public
name|RouteException
parameter_list|(
name|ErrorCode
name|errorCode
parameter_list|,
name|NamedList
argument_list|<
name|Throwable
argument_list|>
name|throwables
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|LBHttpSolrClient
operator|.
name|Req
argument_list|>
name|routes
parameter_list|)
block|{
name|super
argument_list|(
name|errorCode
argument_list|,
name|throwables
operator|.
name|getVal
argument_list|(
literal|0
argument_list|)
operator|.
name|getMessage
argument_list|()
argument_list|,
name|throwables
operator|.
name|getVal
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|throwables
operator|=
name|throwables
expr_stmt|;
name|this
operator|.
name|routes
operator|=
name|routes
expr_stmt|;
block|}
DECL|method|getThrowables
specifier|public
name|NamedList
argument_list|<
name|Throwable
argument_list|>
name|getThrowables
parameter_list|()
block|{
return|return
name|throwables
return|;
block|}
DECL|method|getRoutes
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|LBHttpSolrClient
operator|.
name|Req
argument_list|>
name|getRoutes
parameter_list|()
block|{
return|return
name|this
operator|.
name|routes
return|;
block|}
block|}
end_class
begin_function
annotation|@
name|Override
DECL|method|request
specifier|public
name|NamedList
argument_list|<
name|Object
argument_list|>
name|request
parameter_list|(
name|SolrRequest
name|request
parameter_list|)
throws|throws
name|SolrServerException
throws|,
name|IOException
block|{
name|SolrParams
name|reqParams
init|=
name|request
operator|.
name|getParams
argument_list|()
decl_stmt|;
name|String
name|collection
init|=
operator|(
name|reqParams
operator|!=
literal|null
operator|)
condition|?
name|reqParams
operator|.
name|get
argument_list|(
literal|"collection"
argument_list|,
name|getDefaultCollection
argument_list|()
argument_list|)
else|:
name|getDefaultCollection
argument_list|()
decl_stmt|;
return|return
name|requestWithRetryOnStaleState
argument_list|(
name|request
argument_list|,
literal|0
argument_list|,
name|collection
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/**    * As this class doesn't watch external collections on the client side,    * there's a chance that the request will fail due to cached stale state,    * which means the state must be refreshed from ZK and retried.    */
end_comment
begin_function
DECL|method|requestWithRetryOnStaleState
specifier|protected
name|NamedList
argument_list|<
name|Object
argument_list|>
name|requestWithRetryOnStaleState
parameter_list|(
name|SolrRequest
name|request
parameter_list|,
name|int
name|retryCount
parameter_list|,
name|String
name|collection
parameter_list|)
throws|throws
name|SolrServerException
throws|,
name|IOException
block|{
name|connect
argument_list|()
expr_stmt|;
comment|// important to call this before you start working with the ZkStateReader
comment|// build up a _stateVer_ param to pass to the server containing all of the
comment|// external collection state versions involved in this request, which allows
comment|// the server to notify us that our cached state for one or more of the external
comment|// collections is stale and needs to be refreshed ... this code has no impact on internal collections
name|String
name|stateVerParam
init|=
literal|null
decl_stmt|;
name|List
argument_list|<
name|DocCollection
argument_list|>
name|requestedCollections
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|collection
operator|!=
literal|null
operator|&&
operator|!
name|request
operator|.
name|getPath
argument_list|()
operator|.
name|startsWith
argument_list|(
literal|"/admin"
argument_list|)
condition|)
block|{
comment|// don't do _stateVer_ checking for admin requests
name|Set
argument_list|<
name|String
argument_list|>
name|requestedCollectionNames
init|=
name|getCollectionNames
argument_list|(
name|getZkStateReader
argument_list|()
operator|.
name|getClusterState
argument_list|()
argument_list|,
name|collection
argument_list|)
decl_stmt|;
name|StringBuilder
name|stateVerParamBuilder
init|=
literal|null
decl_stmt|;
for|for
control|(
name|String
name|requestedCollection
range|:
name|requestedCollectionNames
control|)
block|{
comment|// track the version of state we're using on the client side using the _stateVer_ param
name|DocCollection
name|coll
init|=
name|getDocCollection
argument_list|(
name|getZkStateReader
argument_list|()
operator|.
name|getClusterState
argument_list|()
argument_list|,
name|requestedCollection
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|int
name|collVer
init|=
name|coll
operator|.
name|getZNodeVersion
argument_list|()
decl_stmt|;
if|if
condition|(
name|coll
operator|.
name|getStateFormat
argument_list|()
operator|>
literal|1
condition|)
block|{
if|if
condition|(
name|requestedCollections
operator|==
literal|null
condition|)
name|requestedCollections
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|requestedCollectionNames
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|requestedCollections
operator|.
name|add
argument_list|(
name|coll
argument_list|)
expr_stmt|;
if|if
condition|(
name|stateVerParamBuilder
operator|==
literal|null
condition|)
block|{
name|stateVerParamBuilder
operator|=
operator|new
name|StringBuilder
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|stateVerParamBuilder
operator|.
name|append
argument_list|(
literal|"|"
argument_list|)
expr_stmt|;
comment|// hopefully pipe is not an allowed char in a collection name
block|}
name|stateVerParamBuilder
operator|.
name|append
argument_list|(
name|coll
operator|.
name|getName
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|":"
argument_list|)
operator|.
name|append
argument_list|(
name|collVer
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|stateVerParamBuilder
operator|!=
literal|null
condition|)
block|{
name|stateVerParam
operator|=
name|stateVerParamBuilder
operator|.
name|toString
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|request
operator|.
name|getParams
argument_list|()
operator|instanceof
name|ModifiableSolrParams
condition|)
block|{
name|ModifiableSolrParams
name|params
init|=
operator|(
name|ModifiableSolrParams
operator|)
name|request
operator|.
name|getParams
argument_list|()
decl_stmt|;
if|if
condition|(
name|stateVerParam
operator|!=
literal|null
condition|)
block|{
name|params
operator|.
name|set
argument_list|(
name|STATE_VERSION
argument_list|,
name|stateVerParam
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|params
operator|.
name|remove
argument_list|(
name|STATE_VERSION
argument_list|)
expr_stmt|;
block|}
block|}
comment|// else: ??? how to set this ???
name|NamedList
argument_list|<
name|Object
argument_list|>
name|resp
init|=
literal|null
decl_stmt|;
try|try
block|{
name|resp
operator|=
name|sendRequest
argument_list|(
name|request
argument_list|)
expr_stmt|;
name|Object
name|o
init|=
name|resp
operator|.
name|get
argument_list|(
name|STATE_VERSION
argument_list|,
name|resp
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|o
operator|!=
literal|null
operator|&&
name|o
operator|instanceof
name|Map
condition|)
block|{
name|Map
name|invalidStates
init|=
operator|(
name|Map
operator|)
name|o
decl_stmt|;
for|for
control|(
name|Object
name|invalidEntries
range|:
name|invalidStates
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|Map
operator|.
name|Entry
name|e
init|=
operator|(
name|Map
operator|.
name|Entry
operator|)
name|invalidEntries
decl_stmt|;
name|getDocCollection
argument_list|(
name|getZkStateReader
argument_list|()
operator|.
name|getClusterState
argument_list|()
argument_list|,
operator|(
name|String
operator|)
name|e
operator|.
name|getKey
argument_list|()
argument_list|,
operator|(
name|Integer
operator|)
name|e
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|exc
parameter_list|)
block|{
name|Throwable
name|rootCause
init|=
name|SolrException
operator|.
name|getRootCause
argument_list|(
name|exc
argument_list|)
decl_stmt|;
comment|// don't do retry support for admin requests or if the request doesn't have a collection specified
if|if
condition|(
name|collection
operator|==
literal|null
operator|||
name|request
operator|.
name|getPath
argument_list|()
operator|.
name|startsWith
argument_list|(
literal|"/admin"
argument_list|)
condition|)
block|{
if|if
condition|(
name|exc
operator|instanceof
name|SolrServerException
condition|)
block|{
throw|throw
operator|(
name|SolrServerException
operator|)
name|exc
throw|;
block|}
elseif|else
if|if
condition|(
name|exc
operator|instanceof
name|IOException
condition|)
block|{
throw|throw
operator|(
name|IOException
operator|)
name|exc
throw|;
block|}
elseif|else
if|if
condition|(
name|exc
operator|instanceof
name|RuntimeException
condition|)
block|{
throw|throw
operator|(
name|RuntimeException
operator|)
name|exc
throw|;
block|}
else|else
block|{
throw|throw
operator|new
name|SolrServerException
argument_list|(
name|rootCause
argument_list|)
throw|;
block|}
block|}
name|int
name|errorCode
init|=
operator|(
name|rootCause
operator|instanceof
name|SolrException
operator|)
condition|?
operator|(
operator|(
name|SolrException
operator|)
name|rootCause
operator|)
operator|.
name|code
argument_list|()
else|:
name|SolrException
operator|.
name|ErrorCode
operator|.
name|UNKNOWN
operator|.
name|code
decl_stmt|;
name|log
operator|.
name|error
argument_list|(
literal|"Request to collection {} failed due to ("
operator|+
name|errorCode
operator|+
literal|") {}, retry? "
operator|+
name|retryCount
argument_list|,
name|collection
argument_list|,
name|rootCause
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|boolean
name|wasCommError
init|=
operator|(
name|rootCause
operator|instanceof
name|ConnectException
operator|||
name|rootCause
operator|instanceof
name|ConnectTimeoutException
operator|||
name|rootCause
operator|instanceof
name|NoHttpResponseException
operator|||
name|rootCause
operator|instanceof
name|SocketException
operator|)
decl_stmt|;
name|boolean
name|stateWasStale
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|retryCount
operator|<
name|MAX_STALE_RETRIES
operator|&&
name|requestedCollections
operator|!=
literal|null
operator|&&
operator|!
name|requestedCollections
operator|.
name|isEmpty
argument_list|()
operator|&&
name|SolrException
operator|.
name|ErrorCode
operator|.
name|getErrorCode
argument_list|(
name|errorCode
argument_list|)
operator|==
name|SolrException
operator|.
name|ErrorCode
operator|.
name|INVALID_STATE
condition|)
block|{
comment|// cached state for one or more external collections was stale
comment|// re-issue request using updated state
name|stateWasStale
operator|=
literal|true
expr_stmt|;
comment|// just re-read state for all of them, which is a little heavy handed but hopefully a rare occurrence
for|for
control|(
name|DocCollection
name|ext
range|:
name|requestedCollections
control|)
block|{
name|collectionStateCache
operator|.
name|remove
argument_list|(
name|ext
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|// if we experienced a communication error, it's worth checking the state
comment|// with ZK just to make sure the node we're trying to hit is still part of the collection
if|if
condition|(
name|retryCount
operator|<
name|MAX_STALE_RETRIES
operator|&&
operator|!
name|stateWasStale
operator|&&
name|requestedCollections
operator|!=
literal|null
operator|&&
operator|!
name|requestedCollections
operator|.
name|isEmpty
argument_list|()
operator|&&
name|wasCommError
condition|)
block|{
for|for
control|(
name|DocCollection
name|ext
range|:
name|requestedCollections
control|)
block|{
name|DocCollection
name|latestStateFromZk
init|=
name|getDocCollection
argument_list|(
name|zkStateReader
operator|.
name|getClusterState
argument_list|()
argument_list|,
name|ext
operator|.
name|getName
argument_list|()
argument_list|,
literal|null
argument_list|)
decl_stmt|;
if|if
condition|(
name|latestStateFromZk
operator|.
name|getZNodeVersion
argument_list|()
operator|!=
name|ext
operator|.
name|getZNodeVersion
argument_list|()
condition|)
block|{
comment|// looks like we couldn't reach the server because the state was stale == retry
name|stateWasStale
operator|=
literal|true
expr_stmt|;
comment|// we just pulled state from ZK, so update the cache so that the retry uses it
name|collectionStateCache
operator|.
name|put
argument_list|(
name|ext
operator|.
name|getName
argument_list|()
argument_list|,
operator|new
name|ExpiringCachedDocCollection
argument_list|(
name|latestStateFromZk
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|requestedCollections
operator|!=
literal|null
condition|)
block|{
name|requestedCollections
operator|.
name|clear
argument_list|()
expr_stmt|;
comment|// done with this
block|}
comment|// if the state was stale, then we retry the request once with new state pulled from Zk
if|if
condition|(
name|stateWasStale
condition|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Re-trying request to  collection(s) "
operator|+
name|collection
operator|+
literal|" after stale state error from server."
argument_list|)
expr_stmt|;
name|resp
operator|=
name|requestWithRetryOnStaleState
argument_list|(
name|request
argument_list|,
name|retryCount
operator|+
literal|1
argument_list|,
name|collection
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|exc
operator|instanceof
name|SolrServerException
condition|)
block|{
throw|throw
operator|(
name|SolrServerException
operator|)
name|exc
throw|;
block|}
elseif|else
if|if
condition|(
name|exc
operator|instanceof
name|IOException
condition|)
block|{
throw|throw
operator|(
name|IOException
operator|)
name|exc
throw|;
block|}
else|else
block|{
throw|throw
operator|new
name|SolrServerException
argument_list|(
name|rootCause
argument_list|)
throw|;
block|}
block|}
block|}
return|return
name|resp
return|;
block|}
end_function
begin_function
DECL|method|sendRequest
specifier|protected
name|NamedList
argument_list|<
name|Object
argument_list|>
name|sendRequest
parameter_list|(
name|SolrRequest
name|request
parameter_list|)
throws|throws
name|SolrServerException
throws|,
name|IOException
block|{
name|connect
argument_list|()
expr_stmt|;
name|ClusterState
name|clusterState
init|=
name|zkStateReader
operator|.
name|getClusterState
argument_list|()
decl_stmt|;
name|boolean
name|sendToLeaders
init|=
literal|false
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|replicas
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|request
operator|instanceof
name|IsUpdateRequest
condition|)
block|{
if|if
condition|(
name|request
operator|instanceof
name|UpdateRequest
condition|)
block|{
name|NamedList
argument_list|<
name|Object
argument_list|>
name|response
init|=
name|directUpdate
argument_list|(
operator|(
name|AbstractUpdateRequest
operator|)
name|request
argument_list|,
name|clusterState
argument_list|)
decl_stmt|;
if|if
condition|(
name|response
operator|!=
literal|null
condition|)
block|{
return|return
name|response
return|;
block|}
block|}
name|sendToLeaders
operator|=
literal|true
expr_stmt|;
name|replicas
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
expr_stmt|;
block|}
name|SolrParams
name|reqParams
init|=
name|request
operator|.
name|getParams
argument_list|()
decl_stmt|;
if|if
condition|(
name|reqParams
operator|==
literal|null
condition|)
block|{
name|reqParams
operator|=
operator|new
name|ModifiableSolrParams
argument_list|()
expr_stmt|;
block|}
name|List
argument_list|<
name|String
argument_list|>
name|theUrlList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
if|if
condition|(
name|request
operator|.
name|getPath
argument_list|()
operator|.
name|equals
argument_list|(
literal|"/admin/collections"
argument_list|)
operator|||
name|request
operator|.
name|getPath
argument_list|()
operator|.
name|equals
argument_list|(
literal|"/admin/cores"
argument_list|)
condition|)
block|{
name|Set
argument_list|<
name|String
argument_list|>
name|liveNodes
init|=
name|clusterState
operator|.
name|getLiveNodes
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|liveNode
range|:
name|liveNodes
control|)
block|{
name|theUrlList
operator|.
name|add
argument_list|(
name|zkStateReader
operator|.
name|getBaseUrlForNodeName
argument_list|(
name|liveNode
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|String
name|collection
init|=
name|reqParams
operator|.
name|get
argument_list|(
name|UpdateParams
operator|.
name|COLLECTION
argument_list|,
name|defaultCollection
argument_list|)
decl_stmt|;
if|if
condition|(
name|collection
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|SolrServerException
argument_list|(
literal|"No collection param specified on request and no default collection has been set."
argument_list|)
throw|;
block|}
name|Set
argument_list|<
name|String
argument_list|>
name|collectionNames
init|=
name|getCollectionNames
argument_list|(
name|clusterState
argument_list|,
name|collection
argument_list|)
decl_stmt|;
if|if
condition|(
name|collectionNames
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
literal|"Could not find collection: "
operator|+
name|collection
argument_list|)
throw|;
block|}
name|String
name|shardKeys
init|=
name|reqParams
operator|.
name|get
argument_list|(
name|ShardParams
operator|.
name|_ROUTE_
argument_list|)
decl_stmt|;
comment|// TODO: not a big deal because of the caching, but we could avoid looking
comment|// at every shard
comment|// when getting leaders if we tweaked some things
comment|// Retrieve slices from the cloud state and, for each collection
comment|// specified,
comment|// add it to the Map of slices.
name|Map
argument_list|<
name|String
argument_list|,
name|Slice
argument_list|>
name|slices
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|collectionName
range|:
name|collectionNames
control|)
block|{
name|DocCollection
name|col
init|=
name|getDocCollection
argument_list|(
name|clusterState
argument_list|,
name|collectionName
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|Collection
argument_list|<
name|Slice
argument_list|>
name|routeSlices
init|=
name|col
operator|.
name|getRouter
argument_list|()
operator|.
name|getSearchSlices
argument_list|(
name|shardKeys
argument_list|,
name|reqParams
argument_list|,
name|col
argument_list|)
decl_stmt|;
name|ClientUtils
operator|.
name|addSlices
argument_list|(
name|slices
argument_list|,
name|collectionName
argument_list|,
name|routeSlices
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
name|Set
argument_list|<
name|String
argument_list|>
name|liveNodes
init|=
name|clusterState
operator|.
name|getLiveNodes
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|leaderUrlList
init|=
literal|null
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|urlList
init|=
literal|null
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|replicasList
init|=
literal|null
decl_stmt|;
comment|// build a map of unique nodes
comment|// TODO: allow filtering by group, role, etc
name|Map
argument_list|<
name|String
argument_list|,
name|ZkNodeProps
argument_list|>
name|nodes
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|urlList2
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|Slice
name|slice
range|:
name|slices
operator|.
name|values
argument_list|()
control|)
block|{
for|for
control|(
name|ZkNodeProps
name|nodeProps
range|:
name|slice
operator|.
name|getReplicasMap
argument_list|()
operator|.
name|values
argument_list|()
control|)
block|{
name|ZkCoreNodeProps
name|coreNodeProps
init|=
operator|new
name|ZkCoreNodeProps
argument_list|(
name|nodeProps
argument_list|)
decl_stmt|;
name|String
name|node
init|=
name|coreNodeProps
operator|.
name|getNodeName
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|liveNodes
operator|.
name|contains
argument_list|(
name|coreNodeProps
operator|.
name|getNodeName
argument_list|()
argument_list|)
operator|||
operator|!
name|coreNodeProps
operator|.
name|getState
argument_list|()
operator|.
name|equals
argument_list|(
name|ZkStateReader
operator|.
name|ACTIVE
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|nodes
operator|.
name|put
argument_list|(
name|node
argument_list|,
name|nodeProps
argument_list|)
operator|==
literal|null
condition|)
block|{
if|if
condition|(
operator|!
name|sendToLeaders
operator|||
operator|(
name|sendToLeaders
operator|&&
name|coreNodeProps
operator|.
name|isLeader
argument_list|()
operator|)
condition|)
block|{
name|String
name|url
decl_stmt|;
if|if
condition|(
name|reqParams
operator|.
name|get
argument_list|(
name|UpdateParams
operator|.
name|COLLECTION
argument_list|)
operator|==
literal|null
condition|)
block|{
name|url
operator|=
name|ZkCoreNodeProps
operator|.
name|getCoreUrl
argument_list|(
name|nodeProps
operator|.
name|getStr
argument_list|(
name|ZkStateReader
operator|.
name|BASE_URL_PROP
argument_list|)
argument_list|,
name|defaultCollection
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|url
operator|=
name|coreNodeProps
operator|.
name|getCoreUrl
argument_list|()
expr_stmt|;
block|}
name|urlList2
operator|.
name|add
argument_list|(
name|url
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sendToLeaders
condition|)
block|{
name|String
name|url
decl_stmt|;
if|if
condition|(
name|reqParams
operator|.
name|get
argument_list|(
name|UpdateParams
operator|.
name|COLLECTION
argument_list|)
operator|==
literal|null
condition|)
block|{
name|url
operator|=
name|ZkCoreNodeProps
operator|.
name|getCoreUrl
argument_list|(
name|nodeProps
operator|.
name|getStr
argument_list|(
name|ZkStateReader
operator|.
name|BASE_URL_PROP
argument_list|)
argument_list|,
name|defaultCollection
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|url
operator|=
name|coreNodeProps
operator|.
name|getCoreUrl
argument_list|()
expr_stmt|;
block|}
name|replicas
operator|.
name|add
argument_list|(
name|url
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|sendToLeaders
condition|)
block|{
name|leaderUrlList
operator|=
name|urlList2
expr_stmt|;
name|replicasList
operator|=
name|replicas
expr_stmt|;
block|}
else|else
block|{
name|urlList
operator|=
name|urlList2
expr_stmt|;
block|}
if|if
condition|(
name|sendToLeaders
condition|)
block|{
name|theUrlList
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|leaderUrlList
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|theUrlList
operator|.
name|addAll
argument_list|(
name|leaderUrlList
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|theUrlList
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|urlList
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|theUrlList
operator|.
name|addAll
argument_list|(
name|urlList
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|theUrlList
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
for|for
control|(
name|String
name|s
range|:
name|collectionNames
control|)
block|{
if|if
condition|(
name|s
operator|!=
literal|null
condition|)
name|collectionStateCache
operator|.
name|remove
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
throw|throw
operator|new
name|SolrException
argument_list|(
name|SolrException
operator|.
name|ErrorCode
operator|.
name|INVALID_STATE
argument_list|,
literal|"Not enough nodes to handle the request"
argument_list|)
throw|;
block|}
name|Collections
operator|.
name|shuffle
argument_list|(
name|theUrlList
argument_list|,
name|rand
argument_list|)
expr_stmt|;
if|if
condition|(
name|sendToLeaders
condition|)
block|{
name|ArrayList
argument_list|<
name|String
argument_list|>
name|theReplicas
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|replicasList
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
name|theReplicas
operator|.
name|addAll
argument_list|(
name|replicasList
argument_list|)
expr_stmt|;
name|Collections
operator|.
name|shuffle
argument_list|(
name|theReplicas
argument_list|,
name|rand
argument_list|)
expr_stmt|;
name|theUrlList
operator|.
name|addAll
argument_list|(
name|theReplicas
argument_list|)
expr_stmt|;
block|}
block|}
name|LBHttpSolrClient
operator|.
name|Req
name|req
init|=
operator|new
name|LBHttpSolrClient
operator|.
name|Req
argument_list|(
name|request
argument_list|,
name|theUrlList
argument_list|)
decl_stmt|;
name|LBHttpSolrClient
operator|.
name|Rsp
name|rsp
init|=
name|lbClient
operator|.
name|request
argument_list|(
name|req
argument_list|)
decl_stmt|;
return|return
name|rsp
operator|.
name|getResponse
argument_list|()
return|;
block|}
end_function
begin_function
DECL|method|getCollectionNames
specifier|private
name|Set
argument_list|<
name|String
argument_list|>
name|getCollectionNames
parameter_list|(
name|ClusterState
name|clusterState
parameter_list|,
name|String
name|collection
parameter_list|)
block|{
comment|// Extract each comma separated collection name and store in a List.
name|List
argument_list|<
name|String
argument_list|>
name|rawCollectionsList
init|=
name|StrUtils
operator|.
name|splitSmart
argument_list|(
name|collection
argument_list|,
literal|","
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|Set
argument_list|<
name|String
argument_list|>
name|collectionNames
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
comment|// validate collections
for|for
control|(
name|String
name|collectionName
range|:
name|rawCollectionsList
control|)
block|{
if|if
condition|(
operator|!
name|clusterState
operator|.
name|getCollections
argument_list|()
operator|.
name|contains
argument_list|(
name|collectionName
argument_list|)
condition|)
block|{
name|Aliases
name|aliases
init|=
name|zkStateReader
operator|.
name|getAliases
argument_list|()
decl_stmt|;
name|String
name|alias
init|=
name|aliases
operator|.
name|getCollectionAlias
argument_list|(
name|collectionName
argument_list|)
decl_stmt|;
if|if
condition|(
name|alias
operator|!=
literal|null
condition|)
block|{
name|List
argument_list|<
name|String
argument_list|>
name|aliasList
init|=
name|StrUtils
operator|.
name|splitSmart
argument_list|(
name|alias
argument_list|,
literal|","
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|collectionNames
operator|.
name|addAll
argument_list|(
name|aliasList
argument_list|)
expr_stmt|;
continue|continue;
block|}
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
literal|"Collection not found: "
operator|+
name|collectionName
argument_list|)
throw|;
block|}
name|collectionNames
operator|.
name|add
argument_list|(
name|collectionName
argument_list|)
expr_stmt|;
block|}
return|return
name|collectionNames
return|;
block|}
end_function
begin_function
annotation|@
name|Override
DECL|method|close
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|zkStateReader
operator|!=
literal|null
condition|)
block|{
synchronized|synchronized
init|(
name|this
init|)
block|{
if|if
condition|(
name|zkStateReader
operator|!=
literal|null
condition|)
name|zkStateReader
operator|.
name|close
argument_list|()
expr_stmt|;
name|zkStateReader
operator|=
literal|null
expr_stmt|;
block|}
block|}
if|if
condition|(
name|shutdownLBHttpSolrServer
condition|)
block|{
name|lbClient
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|clientIsInternal
operator|&&
name|myClient
operator|!=
literal|null
condition|)
block|{
name|HttpClientUtil
operator|.
name|close
argument_list|(
name|myClient
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|this
operator|.
name|threadPool
operator|!=
literal|null
operator|&&
operator|!
name|this
operator|.
name|threadPool
operator|.
name|isShutdown
argument_list|()
condition|)
block|{
name|this
operator|.
name|threadPool
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|method|getLbClient
specifier|public
name|LBHttpSolrClient
name|getLbClient
parameter_list|()
block|{
return|return
name|lbClient
return|;
block|}
end_function
begin_function
DECL|method|isUpdatesToLeaders
specifier|public
name|boolean
name|isUpdatesToLeaders
parameter_list|()
block|{
return|return
name|updatesToLeaders
return|;
block|}
end_function
begin_comment
comment|/**If caches are expired they are refreshed after acquiring a lock.    * use this to set the number of locks    */
end_comment
begin_function
DECL|method|setParallelCacheRefreshes
specifier|public
name|void
name|setParallelCacheRefreshes
parameter_list|(
name|int
name|n
parameter_list|)
block|{
name|locks
operator|=
name|objectList
argument_list|(
name|n
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|method|objectList
specifier|private
specifier|static
name|ArrayList
argument_list|<
name|Object
argument_list|>
name|objectList
parameter_list|(
name|int
name|n
parameter_list|)
block|{
name|ArrayList
argument_list|<
name|Object
argument_list|>
name|l
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|n
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
name|l
operator|.
name|add
argument_list|(
operator|new
name|Object
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|l
return|;
block|}
end_function
begin_function
DECL|method|getDocCollection
specifier|protected
name|DocCollection
name|getDocCollection
parameter_list|(
name|ClusterState
name|clusterState
parameter_list|,
name|String
name|collection
parameter_list|,
name|Integer
name|expectedVersion
parameter_list|)
throws|throws
name|SolrException
block|{
if|if
condition|(
name|collection
operator|==
literal|null
condition|)
return|return
literal|null
return|;
name|DocCollection
name|col
init|=
name|getFromCache
argument_list|(
name|collection
argument_list|)
decl_stmt|;
if|if
condition|(
name|col
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|expectedVersion
operator|==
literal|null
condition|)
return|return
name|col
return|;
if|if
condition|(
name|expectedVersion
operator|.
name|intValue
argument_list|()
operator|==
name|col
operator|.
name|getZNodeVersion
argument_list|()
condition|)
return|return
name|col
return|;
block|}
name|ClusterState
operator|.
name|CollectionRef
name|ref
init|=
name|clusterState
operator|.
name|getCollectionRef
argument_list|(
name|collection
argument_list|)
decl_stmt|;
if|if
condition|(
name|ref
operator|==
literal|null
condition|)
block|{
comment|//no such collection exists
return|return
literal|null
return|;
block|}
if|if
condition|(
operator|!
name|ref
operator|.
name|isLazilyLoaded
argument_list|()
condition|)
block|{
comment|//it is readily available just return it
return|return
name|ref
operator|.
name|get
argument_list|()
return|;
block|}
name|List
name|locks
init|=
name|this
operator|.
name|locks
decl_stmt|;
specifier|final
name|Object
name|lock
init|=
name|locks
operator|.
name|get
argument_list|(
name|Math
operator|.
name|abs
argument_list|(
name|Hash
operator|.
name|murmurhash3_x86_32
argument_list|(
name|collection
argument_list|,
literal|0
argument_list|,
name|collection
operator|.
name|length
argument_list|()
argument_list|,
literal|0
argument_list|)
operator|%
name|locks
operator|.
name|size
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
synchronized|synchronized
init|(
name|lock
init|)
block|{
comment|//we have waited for sometime just check once again
name|col
operator|=
name|getFromCache
argument_list|(
name|collection
argument_list|)
expr_stmt|;
if|if
condition|(
name|col
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|expectedVersion
operator|==
literal|null
condition|)
return|return
name|col
return|;
if|if
condition|(
name|expectedVersion
operator|.
name|intValue
argument_list|()
operator|==
name|col
operator|.
name|getZNodeVersion
argument_list|()
condition|)
block|{
return|return
name|col
return|;
block|}
else|else
block|{
name|collectionStateCache
operator|.
name|remove
argument_list|(
name|collection
argument_list|)
expr_stmt|;
block|}
block|}
name|col
operator|=
name|ref
operator|.
name|get
argument_list|()
expr_stmt|;
comment|//this is a call to ZK
block|}
if|if
condition|(
name|col
operator|==
literal|null
condition|)
return|return
literal|null
return|;
if|if
condition|(
name|col
operator|.
name|getStateFormat
argument_list|()
operator|>
literal|1
condition|)
name|collectionStateCache
operator|.
name|put
argument_list|(
name|collection
argument_list|,
operator|new
name|ExpiringCachedDocCollection
argument_list|(
name|col
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|col
return|;
block|}
end_function
begin_function
DECL|method|getFromCache
specifier|private
name|DocCollection
name|getFromCache
parameter_list|(
name|String
name|c
parameter_list|)
block|{
name|ExpiringCachedDocCollection
name|cachedState
init|=
name|collectionStateCache
operator|.
name|get
argument_list|(
name|c
argument_list|)
decl_stmt|;
return|return
name|cachedState
operator|!=
literal|null
condition|?
name|cachedState
operator|.
name|cached
else|:
literal|null
return|;
block|}
end_function
begin_comment
comment|/**    * Useful for determining the minimum achieved replication factor across    * all shards involved in processing an update request, typically useful    * for gauging the replication factor of a batch.     */
end_comment
begin_function
annotation|@
name|SuppressWarnings
argument_list|(
literal|"rawtypes"
argument_list|)
DECL|method|getMinAchievedReplicationFactor
specifier|public
name|int
name|getMinAchievedReplicationFactor
parameter_list|(
name|String
name|collection
parameter_list|,
name|NamedList
name|resp
parameter_list|)
block|{
comment|// it's probably already on the top-level header set by condense
name|NamedList
name|header
init|=
operator|(
name|NamedList
operator|)
name|resp
operator|.
name|get
argument_list|(
literal|"responseHeader"
argument_list|)
decl_stmt|;
name|Integer
name|achRf
init|=
operator|(
name|Integer
operator|)
name|header
operator|.
name|get
argument_list|(
name|UpdateRequest
operator|.
name|REPFACT
argument_list|)
decl_stmt|;
if|if
condition|(
name|achRf
operator|!=
literal|null
condition|)
return|return
name|achRf
operator|.
name|intValue
argument_list|()
return|;
comment|// not on the top-level header, walk the shard route tree
name|Map
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|shardRf
init|=
name|getShardReplicationFactor
argument_list|(
name|collection
argument_list|,
name|resp
argument_list|)
decl_stmt|;
for|for
control|(
name|Integer
name|rf
range|:
name|shardRf
operator|.
name|values
argument_list|()
control|)
block|{
if|if
condition|(
name|achRf
operator|==
literal|null
operator|||
name|rf
operator|<
name|achRf
condition|)
block|{
name|achRf
operator|=
name|rf
expr_stmt|;
block|}
block|}
return|return
operator|(
name|achRf
operator|!=
literal|null
operator|)
condition|?
name|achRf
operator|.
name|intValue
argument_list|()
else|:
operator|-
literal|1
return|;
block|}
end_function
begin_comment
comment|/**    * Walks the NamedList response after performing an update request looking for    * the replication factor that was achieved in each shard involved in the request.    * For single doc updates, there will be only one shard in the return value.     */
end_comment
begin_function
annotation|@
name|SuppressWarnings
argument_list|(
literal|"rawtypes"
argument_list|)
DECL|method|getShardReplicationFactor
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|getShardReplicationFactor
parameter_list|(
name|String
name|collection
parameter_list|,
name|NamedList
name|resp
parameter_list|)
block|{
name|connect
argument_list|()
expr_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|results
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
name|resp
operator|instanceof
name|CloudSolrClient
operator|.
name|RouteResponse
condition|)
block|{
name|NamedList
name|routes
init|=
operator|(
operator|(
name|CloudSolrClient
operator|.
name|RouteResponse
operator|)
name|resp
operator|)
operator|.
name|getRouteResponses
argument_list|()
decl_stmt|;
name|ClusterState
name|clusterState
init|=
name|zkStateReader
operator|.
name|getClusterState
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|leaders
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|Slice
name|slice
range|:
name|clusterState
operator|.
name|getActiveSlices
argument_list|(
name|collection
argument_list|)
control|)
block|{
name|Replica
name|leader
init|=
name|slice
operator|.
name|getLeader
argument_list|()
decl_stmt|;
if|if
condition|(
name|leader
operator|!=
literal|null
condition|)
block|{
name|ZkCoreNodeProps
name|zkProps
init|=
operator|new
name|ZkCoreNodeProps
argument_list|(
name|leader
argument_list|)
decl_stmt|;
name|String
name|leaderUrl
init|=
name|zkProps
operator|.
name|getBaseUrl
argument_list|()
operator|+
literal|"/"
operator|+
name|zkProps
operator|.
name|getCoreName
argument_list|()
decl_stmt|;
name|leaders
operator|.
name|put
argument_list|(
name|leaderUrl
argument_list|,
name|slice
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|String
name|altLeaderUrl
init|=
name|zkProps
operator|.
name|getBaseUrl
argument_list|()
operator|+
literal|"/"
operator|+
name|collection
decl_stmt|;
name|leaders
operator|.
name|put
argument_list|(
name|altLeaderUrl
argument_list|,
name|slice
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|Iterator
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
argument_list|>
name|routeIter
init|=
name|routes
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|routeIter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|next
init|=
name|routeIter
operator|.
name|next
argument_list|()
decl_stmt|;
name|String
name|host
init|=
name|next
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|NamedList
name|hostResp
init|=
operator|(
name|NamedList
operator|)
name|next
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|Integer
name|rf
init|=
call|(
name|Integer
call|)
argument_list|(
operator|(
name|NamedList
operator|)
name|hostResp
operator|.
name|get
argument_list|(
literal|"responseHeader"
argument_list|)
argument_list|)
operator|.
name|get
argument_list|(
name|UpdateRequest
operator|.
name|REPFACT
argument_list|)
decl_stmt|;
if|if
condition|(
name|rf
operator|!=
literal|null
condition|)
block|{
name|String
name|shard
init|=
name|leaders
operator|.
name|get
argument_list|(
name|host
argument_list|)
decl_stmt|;
if|if
condition|(
name|shard
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|host
operator|.
name|endsWith
argument_list|(
literal|"/"
argument_list|)
condition|)
name|shard
operator|=
name|leaders
operator|.
name|get
argument_list|(
name|host
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|host
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|shard
operator|==
literal|null
condition|)
block|{
name|shard
operator|=
name|host
expr_stmt|;
block|}
block|}
name|results
operator|.
name|put
argument_list|(
name|shard
argument_list|,
name|rf
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|results
return|;
block|}
end_function
unit|}
end_unit
