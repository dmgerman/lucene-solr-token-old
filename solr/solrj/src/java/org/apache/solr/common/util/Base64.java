begin_unit
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_package
DECL|package|org.apache.solr.common.util
package|package
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|util
package|;
end_package
begin_comment
comment|/**  * Static methods for translating Base64 encoded strings to byte arrays  * and vice-versa.   */
end_comment
begin_class
DECL|class|Base64
specifier|public
class|class
name|Base64
block|{
comment|/**    * This array is a lookup table that translates 6-bit positive integer    * index values into their "Base64 Alphabet" equivalents as specified    * in Table 1 of RFC 2045.    */
DECL|field|intToBase64
specifier|private
specifier|static
specifier|final
name|char
name|intToBase64
index|[]
init|=
block|{
literal|'A'
block|,
literal|'B'
block|,
literal|'C'
block|,
literal|'D'
block|,
literal|'E'
block|,
literal|'F'
block|,
literal|'G'
block|,
literal|'H'
block|,
literal|'I'
block|,
literal|'J'
block|,
literal|'K'
block|,
literal|'L'
block|,
literal|'M'
block|,
literal|'N'
block|,
literal|'O'
block|,
literal|'P'
block|,
literal|'Q'
block|,
literal|'R'
block|,
literal|'S'
block|,
literal|'T'
block|,
literal|'U'
block|,
literal|'V'
block|,
literal|'W'
block|,
literal|'X'
block|,
literal|'Y'
block|,
literal|'Z'
block|,
literal|'a'
block|,
literal|'b'
block|,
literal|'c'
block|,
literal|'d'
block|,
literal|'e'
block|,
literal|'f'
block|,
literal|'g'
block|,
literal|'h'
block|,
literal|'i'
block|,
literal|'j'
block|,
literal|'k'
block|,
literal|'l'
block|,
literal|'m'
block|,
literal|'n'
block|,
literal|'o'
block|,
literal|'p'
block|,
literal|'q'
block|,
literal|'r'
block|,
literal|'s'
block|,
literal|'t'
block|,
literal|'u'
block|,
literal|'v'
block|,
literal|'w'
block|,
literal|'x'
block|,
literal|'y'
block|,
literal|'z'
block|,
literal|'0'
block|,
literal|'1'
block|,
literal|'2'
block|,
literal|'3'
block|,
literal|'4'
block|,
literal|'5'
block|,
literal|'6'
block|,
literal|'7'
block|,
literal|'8'
block|,
literal|'9'
block|,
literal|'+'
block|,
literal|'/'
block|}
decl_stmt|;
comment|/**    * This array is a lookup table that translates unicode characters    * drawn from the "Base64 Alphabet" (as specified in Table 1 of RFC 2045)    * into their 6-bit positive integer equivalents.  Characters that    * are not in the Base64 alphabet but fall within the bounds of the    * array are translated to -1.    */
DECL|field|base64ToInt
specifier|private
specifier|static
specifier|final
name|byte
name|base64ToInt
index|[]
init|=
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|62
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|63
block|,
literal|52
block|,
literal|53
block|,
literal|54
block|,
literal|55
block|,
literal|56
block|,
literal|57
block|,
literal|58
block|,
literal|59
block|,
literal|60
block|,
literal|61
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|3
block|,
literal|4
block|,
literal|5
block|,
literal|6
block|,
literal|7
block|,
literal|8
block|,
literal|9
block|,
literal|10
block|,
literal|11
block|,
literal|12
block|,
literal|13
block|,
literal|14
block|,
literal|15
block|,
literal|16
block|,
literal|17
block|,
literal|18
block|,
literal|19
block|,
literal|20
block|,
literal|21
block|,
literal|22
block|,
literal|23
block|,
literal|24
block|,
literal|25
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|26
block|,
literal|27
block|,
literal|28
block|,
literal|29
block|,
literal|30
block|,
literal|31
block|,
literal|32
block|,
literal|33
block|,
literal|34
block|,
literal|35
block|,
literal|36
block|,
literal|37
block|,
literal|38
block|,
literal|39
block|,
literal|40
block|,
literal|41
block|,
literal|42
block|,
literal|43
block|,
literal|44
block|,
literal|45
block|,
literal|46
block|,
literal|47
block|,
literal|48
block|,
literal|49
block|,
literal|50
block|,
literal|51
block|}
decl_stmt|;
DECL|method|byteArrayToBase64
specifier|public
specifier|static
name|String
name|byteArrayToBase64
parameter_list|(
name|byte
index|[]
name|a
parameter_list|)
block|{
return|return
name|byteArrayToBase64
argument_list|(
name|a
argument_list|,
literal|0
argument_list|,
name|a
operator|.
name|length
argument_list|)
return|;
block|}
DECL|method|byteArrayToBase64
specifier|public
specifier|static
name|String
name|byteArrayToBase64
parameter_list|(
name|byte
index|[]
name|a
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|int
name|aLen
init|=
name|len
decl_stmt|;
name|int
name|numFullGroups
init|=
name|aLen
operator|/
literal|3
decl_stmt|;
name|int
name|numBytesInPartialGroup
init|=
name|aLen
operator|-
literal|3
operator|*
name|numFullGroups
decl_stmt|;
name|int
name|resultLen
init|=
literal|4
operator|*
operator|(
operator|(
name|aLen
operator|+
literal|2
operator|)
operator|/
literal|3
operator|)
decl_stmt|;
name|StringBuilder
name|result
init|=
operator|new
name|StringBuilder
argument_list|(
name|resultLen
argument_list|)
decl_stmt|;
name|char
index|[]
name|intToAlpha
init|=
name|intToBase64
decl_stmt|;
comment|// Translate all full groups from byte array elements to Base64
name|int
name|inCursor
init|=
name|offset
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numFullGroups
condition|;
name|i
operator|++
control|)
block|{
name|int
name|byte0
init|=
name|a
index|[
name|inCursor
operator|++
index|]
operator|&
literal|0xff
decl_stmt|;
name|int
name|byte1
init|=
name|a
index|[
name|inCursor
operator|++
index|]
operator|&
literal|0xff
decl_stmt|;
name|int
name|byte2
init|=
name|a
index|[
name|inCursor
operator|++
index|]
operator|&
literal|0xff
decl_stmt|;
name|result
operator|.
name|append
argument_list|(
name|intToAlpha
index|[
name|byte0
operator|>>
literal|2
index|]
argument_list|)
expr_stmt|;
name|result
operator|.
name|append
argument_list|(
name|intToAlpha
index|[
operator|(
name|byte0
operator|<<
literal|4
operator|)
operator|&
literal|0x3f
operator||
operator|(
name|byte1
operator|>>
literal|4
operator|)
index|]
argument_list|)
expr_stmt|;
name|result
operator|.
name|append
argument_list|(
name|intToAlpha
index|[
operator|(
name|byte1
operator|<<
literal|2
operator|)
operator|&
literal|0x3f
operator||
operator|(
name|byte2
operator|>>
literal|6
operator|)
index|]
argument_list|)
expr_stmt|;
name|result
operator|.
name|append
argument_list|(
name|intToAlpha
index|[
name|byte2
operator|&
literal|0x3f
index|]
argument_list|)
expr_stmt|;
block|}
comment|// Translate partial group if present
if|if
condition|(
name|numBytesInPartialGroup
operator|!=
literal|0
condition|)
block|{
name|int
name|byte0
init|=
name|a
index|[
name|inCursor
operator|++
index|]
operator|&
literal|0xff
decl_stmt|;
name|result
operator|.
name|append
argument_list|(
name|intToAlpha
index|[
name|byte0
operator|>>
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|numBytesInPartialGroup
operator|==
literal|1
condition|)
block|{
name|result
operator|.
name|append
argument_list|(
name|intToAlpha
index|[
operator|(
name|byte0
operator|<<
literal|4
operator|)
operator|&
literal|0x3f
index|]
argument_list|)
expr_stmt|;
name|result
operator|.
name|append
argument_list|(
literal|"=="
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// assert numBytesInPartialGroup == 2;
name|int
name|byte1
init|=
name|a
index|[
name|inCursor
operator|++
index|]
operator|&
literal|0xff
decl_stmt|;
name|result
operator|.
name|append
argument_list|(
name|intToAlpha
index|[
operator|(
name|byte0
operator|<<
literal|4
operator|)
operator|&
literal|0x3f
operator||
operator|(
name|byte1
operator|>>
literal|4
operator|)
index|]
argument_list|)
expr_stmt|;
name|result
operator|.
name|append
argument_list|(
name|intToAlpha
index|[
operator|(
name|byte1
operator|<<
literal|2
operator|)
operator|&
literal|0x3f
index|]
argument_list|)
expr_stmt|;
name|result
operator|.
name|append
argument_list|(
literal|'='
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|result
operator|.
name|toString
argument_list|()
return|;
block|}
DECL|method|base64ToByteArray
specifier|public
specifier|static
name|byte
index|[]
name|base64ToByteArray
parameter_list|(
name|String
name|s
parameter_list|)
block|{
name|byte
index|[]
name|alphaToInt
init|=
name|base64ToInt
decl_stmt|;
name|int
name|sLen
init|=
name|s
operator|.
name|length
argument_list|()
decl_stmt|;
name|int
name|numGroups
init|=
name|sLen
operator|/
literal|4
decl_stmt|;
if|if
condition|(
literal|4
operator|*
name|numGroups
operator|!=
name|sLen
condition|)
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"String length must be a multiple of four."
argument_list|)
throw|;
name|int
name|missingBytesInLastGroup
init|=
literal|0
decl_stmt|;
name|int
name|numFullGroups
init|=
name|numGroups
decl_stmt|;
if|if
condition|(
name|sLen
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|s
operator|.
name|charAt
argument_list|(
name|sLen
operator|-
literal|1
argument_list|)
operator|==
literal|'='
condition|)
block|{
name|missingBytesInLastGroup
operator|++
expr_stmt|;
name|numFullGroups
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|s
operator|.
name|charAt
argument_list|(
name|sLen
operator|-
literal|2
argument_list|)
operator|==
literal|'='
condition|)
name|missingBytesInLastGroup
operator|++
expr_stmt|;
block|}
name|byte
index|[]
name|result
init|=
operator|new
name|byte
index|[
literal|3
operator|*
name|numGroups
operator|-
name|missingBytesInLastGroup
index|]
decl_stmt|;
comment|// Translate all full groups from base64 to byte array elements
name|int
name|inCursor
init|=
literal|0
decl_stmt|,
name|outCursor
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numFullGroups
condition|;
name|i
operator|++
control|)
block|{
name|int
name|ch0
init|=
name|base64toInt
argument_list|(
name|s
operator|.
name|charAt
argument_list|(
name|inCursor
operator|++
argument_list|)
argument_list|,
name|alphaToInt
argument_list|)
decl_stmt|;
name|int
name|ch1
init|=
name|base64toInt
argument_list|(
name|s
operator|.
name|charAt
argument_list|(
name|inCursor
operator|++
argument_list|)
argument_list|,
name|alphaToInt
argument_list|)
decl_stmt|;
name|int
name|ch2
init|=
name|base64toInt
argument_list|(
name|s
operator|.
name|charAt
argument_list|(
name|inCursor
operator|++
argument_list|)
argument_list|,
name|alphaToInt
argument_list|)
decl_stmt|;
name|int
name|ch3
init|=
name|base64toInt
argument_list|(
name|s
operator|.
name|charAt
argument_list|(
name|inCursor
operator|++
argument_list|)
argument_list|,
name|alphaToInt
argument_list|)
decl_stmt|;
name|result
index|[
name|outCursor
operator|++
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
operator|(
name|ch0
operator|<<
literal|2
operator|)
operator||
operator|(
name|ch1
operator|>>
literal|4
operator|)
argument_list|)
expr_stmt|;
name|result
index|[
name|outCursor
operator|++
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
operator|(
name|ch1
operator|<<
literal|4
operator|)
operator||
operator|(
name|ch2
operator|>>
literal|2
operator|)
argument_list|)
expr_stmt|;
name|result
index|[
name|outCursor
operator|++
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
operator|(
name|ch2
operator|<<
literal|6
operator|)
operator||
name|ch3
argument_list|)
expr_stmt|;
block|}
comment|// Translate partial group, if present
if|if
condition|(
name|missingBytesInLastGroup
operator|!=
literal|0
condition|)
block|{
name|int
name|ch0
init|=
name|base64toInt
argument_list|(
name|s
operator|.
name|charAt
argument_list|(
name|inCursor
operator|++
argument_list|)
argument_list|,
name|alphaToInt
argument_list|)
decl_stmt|;
name|int
name|ch1
init|=
name|base64toInt
argument_list|(
name|s
operator|.
name|charAt
argument_list|(
name|inCursor
operator|++
argument_list|)
argument_list|,
name|alphaToInt
argument_list|)
decl_stmt|;
name|result
index|[
name|outCursor
operator|++
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
operator|(
name|ch0
operator|<<
literal|2
operator|)
operator||
operator|(
name|ch1
operator|>>
literal|4
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|missingBytesInLastGroup
operator|==
literal|1
condition|)
block|{
name|int
name|ch2
init|=
name|base64toInt
argument_list|(
name|s
operator|.
name|charAt
argument_list|(
name|inCursor
operator|++
argument_list|)
argument_list|,
name|alphaToInt
argument_list|)
decl_stmt|;
name|result
index|[
name|outCursor
operator|++
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
operator|(
name|ch1
operator|<<
literal|4
operator|)
operator||
operator|(
name|ch2
operator|>>
literal|2
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|// assert inCursor == s.length()-missingBytesInLastGroup;
comment|// assert outCursor == result.length;
return|return
name|result
return|;
block|}
comment|/**    * Translates the specified character, which is assumed to be in the    * "Base 64 Alphabet" into its equivalent 6-bit positive integer.    *    * @throw IllegalArgumentException or ArrayOutOfBoundsException if    * c is not in the Base64 Alphabet.    */
DECL|method|base64toInt
specifier|private
specifier|static
name|int
name|base64toInt
parameter_list|(
name|char
name|c
parameter_list|,
name|byte
index|[]
name|alphaToInt
parameter_list|)
block|{
name|int
name|result
init|=
name|alphaToInt
index|[
name|c
index|]
decl_stmt|;
if|if
condition|(
name|result
operator|<
literal|0
condition|)
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Illegal character "
operator|+
name|c
argument_list|)
throw|;
return|return
name|result
return|;
block|}
block|}
end_class
end_unit
