begin_unit
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_package
DECL|package|org.apache.solr.common.cloud
package|package
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|cloud
package|;
end_package
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Closeable
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|UnsupportedEncodingException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|invoke
operator|.
name|MethodHandles
import|;
end_import
begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URLDecoder
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashMap
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
operator|.
name|Entry
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Objects
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeSet
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentHashMap
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|CountDownLatch
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ExecutorService
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|RejectedExecutionException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeoutException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicBoolean
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicReference
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|Callable
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|SolrException
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|SolrException
operator|.
name|ErrorCode
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|util
operator|.
name|ExecutorUtil
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|util
operator|.
name|Pair
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|util
operator|.
name|Utils
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|CreateMode
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|KeeperException
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|WatchedEvent
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|Watcher
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|Watcher
operator|.
name|Event
operator|.
name|EventType
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|data
operator|.
name|Stat
import|;
end_import
begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import
begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import
begin_import
import|import static
name|java
operator|.
name|util
operator|.
name|Arrays
operator|.
name|asList
import|;
end_import
begin_import
import|import static
name|java
operator|.
name|util
operator|.
name|Collections
operator|.
name|EMPTY_MAP
import|;
end_import
begin_import
import|import static
name|java
operator|.
name|util
operator|.
name|Collections
operator|.
name|emptyMap
import|;
end_import
begin_import
import|import static
name|java
operator|.
name|util
operator|.
name|Collections
operator|.
name|emptySet
import|;
end_import
begin_import
import|import static
name|java
operator|.
name|util
operator|.
name|Collections
operator|.
name|unmodifiableSet
import|;
end_import
begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|util
operator|.
name|Utils
operator|.
name|fromJSON
import|;
end_import
begin_class
DECL|class|ZkStateReader
specifier|public
class|class
name|ZkStateReader
implements|implements
name|Closeable
block|{
DECL|field|LOG
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|MethodHandles
operator|.
name|lookup
argument_list|()
operator|.
name|lookupClass
argument_list|()
argument_list|)
decl_stmt|;
DECL|field|BASE_URL_PROP
specifier|public
specifier|static
specifier|final
name|String
name|BASE_URL_PROP
init|=
literal|"base_url"
decl_stmt|;
DECL|field|NODE_NAME_PROP
specifier|public
specifier|static
specifier|final
name|String
name|NODE_NAME_PROP
init|=
literal|"node_name"
decl_stmt|;
DECL|field|CORE_NODE_NAME_PROP
specifier|public
specifier|static
specifier|final
name|String
name|CORE_NODE_NAME_PROP
init|=
literal|"core_node_name"
decl_stmt|;
DECL|field|ROLES_PROP
specifier|public
specifier|static
specifier|final
name|String
name|ROLES_PROP
init|=
literal|"roles"
decl_stmt|;
DECL|field|STATE_PROP
specifier|public
specifier|static
specifier|final
name|String
name|STATE_PROP
init|=
literal|"state"
decl_stmt|;
DECL|field|CORE_NAME_PROP
specifier|public
specifier|static
specifier|final
name|String
name|CORE_NAME_PROP
init|=
literal|"core"
decl_stmt|;
DECL|field|COLLECTION_PROP
specifier|public
specifier|static
specifier|final
name|String
name|COLLECTION_PROP
init|=
literal|"collection"
decl_stmt|;
DECL|field|ELECTION_NODE_PROP
specifier|public
specifier|static
specifier|final
name|String
name|ELECTION_NODE_PROP
init|=
literal|"election_node"
decl_stmt|;
DECL|field|SHARD_ID_PROP
specifier|public
specifier|static
specifier|final
name|String
name|SHARD_ID_PROP
init|=
literal|"shard"
decl_stmt|;
DECL|field|REPLICA_PROP
specifier|public
specifier|static
specifier|final
name|String
name|REPLICA_PROP
init|=
literal|"replica"
decl_stmt|;
DECL|field|SHARD_RANGE_PROP
specifier|public
specifier|static
specifier|final
name|String
name|SHARD_RANGE_PROP
init|=
literal|"shard_range"
decl_stmt|;
DECL|field|SHARD_STATE_PROP
specifier|public
specifier|static
specifier|final
name|String
name|SHARD_STATE_PROP
init|=
literal|"shard_state"
decl_stmt|;
DECL|field|SHARD_PARENT_PROP
specifier|public
specifier|static
specifier|final
name|String
name|SHARD_PARENT_PROP
init|=
literal|"shard_parent"
decl_stmt|;
DECL|field|NUM_SHARDS_PROP
specifier|public
specifier|static
specifier|final
name|String
name|NUM_SHARDS_PROP
init|=
literal|"numShards"
decl_stmt|;
DECL|field|LEADER_PROP
specifier|public
specifier|static
specifier|final
name|String
name|LEADER_PROP
init|=
literal|"leader"
decl_stmt|;
DECL|field|PROPERTY_PROP
specifier|public
specifier|static
specifier|final
name|String
name|PROPERTY_PROP
init|=
literal|"property"
decl_stmt|;
DECL|field|PROPERTY_VALUE_PROP
specifier|public
specifier|static
specifier|final
name|String
name|PROPERTY_VALUE_PROP
init|=
literal|"property.value"
decl_stmt|;
DECL|field|MAX_AT_ONCE_PROP
specifier|public
specifier|static
specifier|final
name|String
name|MAX_AT_ONCE_PROP
init|=
literal|"maxAtOnce"
decl_stmt|;
DECL|field|MAX_WAIT_SECONDS_PROP
specifier|public
specifier|static
specifier|final
name|String
name|MAX_WAIT_SECONDS_PROP
init|=
literal|"maxWaitSeconds"
decl_stmt|;
DECL|field|COLLECTIONS_ZKNODE
specifier|public
specifier|static
specifier|final
name|String
name|COLLECTIONS_ZKNODE
init|=
literal|"/collections"
decl_stmt|;
DECL|field|LIVE_NODES_ZKNODE
specifier|public
specifier|static
specifier|final
name|String
name|LIVE_NODES_ZKNODE
init|=
literal|"/live_nodes"
decl_stmt|;
DECL|field|ALIASES
specifier|public
specifier|static
specifier|final
name|String
name|ALIASES
init|=
literal|"/aliases.json"
decl_stmt|;
DECL|field|CLUSTER_STATE
specifier|public
specifier|static
specifier|final
name|String
name|CLUSTER_STATE
init|=
literal|"/clusterstate.json"
decl_stmt|;
DECL|field|CLUSTER_PROPS
specifier|public
specifier|static
specifier|final
name|String
name|CLUSTER_PROPS
init|=
literal|"/clusterprops.json"
decl_stmt|;
DECL|field|REJOIN_AT_HEAD_PROP
specifier|public
specifier|static
specifier|final
name|String
name|REJOIN_AT_HEAD_PROP
init|=
literal|"rejoinAtHead"
decl_stmt|;
DECL|field|SOLR_SECURITY_CONF_PATH
specifier|public
specifier|static
specifier|final
name|String
name|SOLR_SECURITY_CONF_PATH
init|=
literal|"/security.json"
decl_stmt|;
DECL|field|REPLICATION_FACTOR
specifier|public
specifier|static
specifier|final
name|String
name|REPLICATION_FACTOR
init|=
literal|"replicationFactor"
decl_stmt|;
DECL|field|MAX_SHARDS_PER_NODE
specifier|public
specifier|static
specifier|final
name|String
name|MAX_SHARDS_PER_NODE
init|=
literal|"maxShardsPerNode"
decl_stmt|;
DECL|field|AUTO_ADD_REPLICAS
specifier|public
specifier|static
specifier|final
name|String
name|AUTO_ADD_REPLICAS
init|=
literal|"autoAddReplicas"
decl_stmt|;
DECL|field|MAX_CORES_PER_NODE
specifier|public
specifier|static
specifier|final
name|String
name|MAX_CORES_PER_NODE
init|=
literal|"maxCoresPerNode"
decl_stmt|;
DECL|field|ROLES
specifier|public
specifier|static
specifier|final
name|String
name|ROLES
init|=
literal|"/roles.json"
decl_stmt|;
DECL|field|CONFIGS_ZKNODE
specifier|public
specifier|static
specifier|final
name|String
name|CONFIGS_ZKNODE
init|=
literal|"/configs"
decl_stmt|;
DECL|field|CONFIGNAME_PROP
specifier|public
specifier|final
specifier|static
name|String
name|CONFIGNAME_PROP
init|=
literal|"configName"
decl_stmt|;
DECL|field|LEGACY_CLOUD
specifier|public
specifier|static
specifier|final
name|String
name|LEGACY_CLOUD
init|=
literal|"legacyCloud"
decl_stmt|;
DECL|field|URL_SCHEME
specifier|public
specifier|static
specifier|final
name|String
name|URL_SCHEME
init|=
literal|"urlScheme"
decl_stmt|;
DECL|field|BACKUP_LOCATION
specifier|public
specifier|static
specifier|final
name|String
name|BACKUP_LOCATION
init|=
literal|"location"
decl_stmt|;
comment|/** A view of the current state of all collections; combines all the different state sources into a single view. */
DECL|field|clusterState
specifier|protected
specifier|volatile
name|ClusterState
name|clusterState
decl_stmt|;
DECL|field|GET_LEADER_RETRY_INTERVAL_MS
specifier|private
specifier|static
specifier|final
name|int
name|GET_LEADER_RETRY_INTERVAL_MS
init|=
literal|50
decl_stmt|;
DECL|field|GET_LEADER_RETRY_DEFAULT_TIMEOUT
specifier|private
specifier|static
specifier|final
name|int
name|GET_LEADER_RETRY_DEFAULT_TIMEOUT
init|=
literal|4000
decl_stmt|;
DECL|field|LEADER_ELECT_ZKNODE
specifier|public
specifier|static
specifier|final
name|String
name|LEADER_ELECT_ZKNODE
init|=
literal|"leader_elect"
decl_stmt|;
DECL|field|SHARD_LEADERS_ZKNODE
specifier|public
specifier|static
specifier|final
name|String
name|SHARD_LEADERS_ZKNODE
init|=
literal|"leaders"
decl_stmt|;
DECL|field|ELECTION_NODE
specifier|public
specifier|static
specifier|final
name|String
name|ELECTION_NODE
init|=
literal|"election"
decl_stmt|;
comment|/** Collections tracked in the legacy (shared) state format, reflects the contents of clusterstate.json. */
DECL|field|legacyCollectionStates
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|ClusterState
operator|.
name|CollectionRef
argument_list|>
name|legacyCollectionStates
init|=
name|emptyMap
argument_list|()
decl_stmt|;
comment|/** Last seen ZK version of clusterstate.json. */
DECL|field|legacyClusterStateVersion
specifier|private
name|int
name|legacyClusterStateVersion
init|=
literal|0
decl_stmt|;
comment|/** Collections with format2 state.json, "interesting" and actively watched. */
DECL|field|watchedCollectionStates
specifier|private
specifier|final
name|ConcurrentHashMap
argument_list|<
name|String
argument_list|,
name|DocCollection
argument_list|>
name|watchedCollectionStates
init|=
operator|new
name|ConcurrentHashMap
argument_list|<>
argument_list|()
decl_stmt|;
comment|/** Collections with format2 state.json, not "interesting" and not actively watched. */
DECL|field|lazyCollectionStates
specifier|private
specifier|final
name|ConcurrentHashMap
argument_list|<
name|String
argument_list|,
name|LazyCollectionRef
argument_list|>
name|lazyCollectionStates
init|=
operator|new
name|ConcurrentHashMap
argument_list|<>
argument_list|()
decl_stmt|;
DECL|field|liveNodes
specifier|private
specifier|volatile
name|Set
argument_list|<
name|String
argument_list|>
name|liveNodes
init|=
name|emptySet
argument_list|()
decl_stmt|;
DECL|field|configManager
specifier|private
specifier|final
name|ZkConfigManager
name|configManager
decl_stmt|;
DECL|field|securityData
specifier|private
name|ConfigData
name|securityData
decl_stmt|;
DECL|field|securityNodeListener
specifier|private
specifier|final
name|Runnable
name|securityNodeListener
decl_stmt|;
DECL|field|collectionWatches
specifier|private
name|ConcurrentHashMap
argument_list|<
name|String
argument_list|,
name|CollectionWatch
argument_list|>
name|collectionWatches
init|=
operator|new
name|ConcurrentHashMap
argument_list|<>
argument_list|()
decl_stmt|;
DECL|field|notifications
specifier|private
specifier|final
name|ExecutorService
name|notifications
init|=
name|ExecutorUtil
operator|.
name|newMDCAwareCachedThreadPool
argument_list|(
literal|"watches"
argument_list|)
decl_stmt|;
DECL|class|CollectionWatch
specifier|private
class|class
name|CollectionWatch
block|{
DECL|field|coreRefCount
name|int
name|coreRefCount
init|=
literal|0
decl_stmt|;
DECL|field|stateWatchers
name|Set
argument_list|<
name|CollectionStateWatcher
argument_list|>
name|stateWatchers
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
DECL|method|canBeRemoved
specifier|public
name|boolean
name|canBeRemoved
parameter_list|()
block|{
return|return
name|coreRefCount
operator|+
name|stateWatchers
operator|.
name|size
argument_list|()
operator|==
literal|0
return|;
block|}
block|}
DECL|field|KNOWN_CLUSTER_PROPS
specifier|public
specifier|static
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|KNOWN_CLUSTER_PROPS
init|=
name|unmodifiableSet
argument_list|(
operator|new
name|HashSet
argument_list|<>
argument_list|(
name|asList
argument_list|(
name|LEGACY_CLOUD
argument_list|,
name|URL_SCHEME
argument_list|,
name|AUTO_ADD_REPLICAS
argument_list|,
name|BACKUP_LOCATION
argument_list|,
name|MAX_CORES_PER_NODE
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
comment|/**    * Returns config set name for collection.    *    * @param collection to return config set name for    */
DECL|method|readConfigName
specifier|public
name|String
name|readConfigName
parameter_list|(
name|String
name|collection
parameter_list|)
block|{
name|String
name|configName
init|=
literal|null
decl_stmt|;
name|String
name|path
init|=
name|COLLECTIONS_ZKNODE
operator|+
literal|"/"
operator|+
name|collection
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Load collection config from: [{}]"
argument_list|,
name|path
argument_list|)
expr_stmt|;
try|try
block|{
name|byte
index|[]
name|data
init|=
name|zkClient
operator|.
name|getData
argument_list|(
name|path
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
name|data
operator|!=
literal|null
condition|)
block|{
name|ZkNodeProps
name|props
init|=
name|ZkNodeProps
operator|.
name|load
argument_list|(
name|data
argument_list|)
decl_stmt|;
name|configName
operator|=
name|props
operator|.
name|getStr
argument_list|(
name|CONFIGNAME_PROP
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|configName
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
operator|!
name|zkClient
operator|.
name|exists
argument_list|(
name|CONFIGS_ZKNODE
operator|+
literal|"/"
operator|+
name|configName
argument_list|,
literal|true
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Specified config does not exist in ZooKeeper: [{}]"
argument_list|,
name|configName
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|ZooKeeperException
argument_list|(
name|ErrorCode
operator|.
name|SERVER_ERROR
argument_list|,
literal|"Specified config does not exist in ZooKeeper: "
operator|+
name|configName
argument_list|)
throw|;
block|}
else|else
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"path=[{}] [{}]=[{}] specified config exists in ZooKeeper"
argument_list|,
name|path
argument_list|,
name|CONFIGNAME_PROP
argument_list|,
name|configName
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
throw|throw
operator|new
name|ZooKeeperException
argument_list|(
name|ErrorCode
operator|.
name|INVALID_STATE
argument_list|,
literal|"No config data found at path: "
operator|+
name|path
argument_list|)
throw|;
block|}
block|}
catch|catch
parameter_list|(
name|KeeperException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|SERVER_ERROR
argument_list|,
literal|"Error loading config name for collection "
operator|+
name|collection
argument_list|,
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|SERVER_ERROR
argument_list|,
literal|"Error loading config name for collection "
operator|+
name|collection
argument_list|,
name|e
argument_list|)
throw|;
block|}
return|return
name|configName
return|;
block|}
DECL|field|zkClient
specifier|private
specifier|final
name|SolrZkClient
name|zkClient
decl_stmt|;
DECL|field|closeClient
specifier|private
specifier|final
name|boolean
name|closeClient
decl_stmt|;
DECL|field|aliases
specifier|private
specifier|volatile
name|Aliases
name|aliases
init|=
operator|new
name|Aliases
argument_list|()
decl_stmt|;
DECL|field|closed
specifier|private
specifier|volatile
name|boolean
name|closed
init|=
literal|false
decl_stmt|;
DECL|method|ZkStateReader
specifier|public
name|ZkStateReader
parameter_list|(
name|SolrZkClient
name|zkClient
parameter_list|)
block|{
name|this
argument_list|(
name|zkClient
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
DECL|method|ZkStateReader
specifier|public
name|ZkStateReader
parameter_list|(
name|SolrZkClient
name|zkClient
parameter_list|,
name|Runnable
name|securityNodeListener
parameter_list|)
block|{
name|this
operator|.
name|zkClient
operator|=
name|zkClient
expr_stmt|;
name|this
operator|.
name|configManager
operator|=
operator|new
name|ZkConfigManager
argument_list|(
name|zkClient
argument_list|)
expr_stmt|;
name|this
operator|.
name|closeClient
operator|=
literal|false
expr_stmt|;
name|this
operator|.
name|securityNodeListener
operator|=
name|securityNodeListener
expr_stmt|;
block|}
DECL|method|ZkStateReader
specifier|public
name|ZkStateReader
parameter_list|(
name|String
name|zkServerAddress
parameter_list|,
name|int
name|zkClientTimeout
parameter_list|,
name|int
name|zkClientConnectTimeout
parameter_list|)
block|{
name|this
operator|.
name|zkClient
operator|=
operator|new
name|SolrZkClient
argument_list|(
name|zkServerAddress
argument_list|,
name|zkClientTimeout
argument_list|,
name|zkClientConnectTimeout
argument_list|,
comment|// on reconnect, reload cloud info
operator|new
name|OnReconnect
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|command
parameter_list|()
block|{
try|try
block|{
name|ZkStateReader
operator|.
name|this
operator|.
name|createClusterStateWatchersAndUpdate
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|KeeperException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"A ZK error has occurred"
argument_list|,
name|e
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|ZooKeeperException
argument_list|(
name|SolrException
operator|.
name|ErrorCode
operator|.
name|SERVER_ERROR
argument_list|,
literal|"A ZK error has occurred"
argument_list|,
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
comment|// Restore the interrupted status
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|error
argument_list|(
literal|"Interrupted"
argument_list|,
name|e
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|ZooKeeperException
argument_list|(
name|SolrException
operator|.
name|ErrorCode
operator|.
name|SERVER_ERROR
argument_list|,
literal|"Interrupted"
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
block|}
argument_list|)
expr_stmt|;
name|this
operator|.
name|configManager
operator|=
operator|new
name|ZkConfigManager
argument_list|(
name|zkClient
argument_list|)
expr_stmt|;
name|this
operator|.
name|closeClient
operator|=
literal|true
expr_stmt|;
name|this
operator|.
name|securityNodeListener
operator|=
literal|null
expr_stmt|;
block|}
DECL|method|getConfigManager
specifier|public
name|ZkConfigManager
name|getConfigManager
parameter_list|()
block|{
return|return
name|configManager
return|;
block|}
comment|/**    * Forcibly refresh cluster state from ZK. Do this only to avoid race conditions because it's expensive.    *    * @deprecated Don't call this, call {@link #forceUpdateCollection(String)} on a single collection if you must.    */
annotation|@
name|Deprecated
DECL|method|updateClusterState
specifier|public
name|void
name|updateClusterState
parameter_list|()
throws|throws
name|KeeperException
throws|,
name|InterruptedException
block|{
synchronized|synchronized
init|(
name|getUpdateLock
argument_list|()
init|)
block|{
if|if
condition|(
name|clusterState
operator|==
literal|null
condition|)
block|{
comment|// Never initialized, just run normal initialization.
name|createClusterStateWatchersAndUpdate
argument_list|()
expr_stmt|;
return|return;
block|}
comment|// No need to set watchers because we should already have watchers registered for everything.
name|refreshLegacyClusterState
argument_list|(
literal|null
argument_list|)
expr_stmt|;
comment|// Need a copy so we don't delete from what we're iterating over.
name|Collection
argument_list|<
name|String
argument_list|>
name|safeCopy
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|watchedCollectionStates
operator|.
name|keySet
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|coll
range|:
name|safeCopy
control|)
block|{
name|DocCollection
name|newState
init|=
name|fetchCollectionState
argument_list|(
name|coll
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|updateWatchedCollection
argument_list|(
name|coll
argument_list|,
name|newState
argument_list|)
expr_stmt|;
block|}
name|refreshCollectionList
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|refreshLiveNodes
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|constructState
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Forcibly refresh a collection's internal state from ZK. Try to avoid having to resort to this when    * a better design is possible.    */
DECL|method|forceUpdateCollection
specifier|public
name|void
name|forceUpdateCollection
parameter_list|(
name|String
name|collection
parameter_list|)
throws|throws
name|KeeperException
throws|,
name|InterruptedException
block|{
synchronized|synchronized
init|(
name|getUpdateLock
argument_list|()
init|)
block|{
if|if
condition|(
name|clusterState
operator|==
literal|null
condition|)
block|{
return|return;
block|}
name|ClusterState
operator|.
name|CollectionRef
name|ref
init|=
name|clusterState
operator|.
name|getCollectionRef
argument_list|(
name|collection
argument_list|)
decl_stmt|;
if|if
condition|(
name|ref
operator|==
literal|null
operator|||
name|legacyCollectionStates
operator|.
name|containsKey
argument_list|(
name|collection
argument_list|)
condition|)
block|{
comment|// We either don't know anything about this collection (maybe it's new?) or it's legacy.
comment|// First update the legacy cluster state.
name|refreshLegacyClusterState
argument_list|(
literal|null
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|legacyCollectionStates
operator|.
name|containsKey
argument_list|(
name|collection
argument_list|)
condition|)
block|{
comment|// No dice, see if a new collection just got created.
name|LazyCollectionRef
name|tryLazyCollection
init|=
operator|new
name|LazyCollectionRef
argument_list|(
name|collection
argument_list|)
decl_stmt|;
if|if
condition|(
name|tryLazyCollection
operator|.
name|get
argument_list|()
operator|==
literal|null
condition|)
block|{
comment|// No dice, just give up.
return|return;
block|}
comment|// What do you know, it exists!
name|lazyCollectionStates
operator|.
name|putIfAbsent
argument_list|(
name|collection
argument_list|,
name|tryLazyCollection
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|ref
operator|.
name|isLazilyLoaded
argument_list|()
condition|)
block|{
if|if
condition|(
name|ref
operator|.
name|get
argument_list|()
operator|!=
literal|null
condition|)
block|{
return|return;
block|}
comment|// Edge case: if there's no external collection, try refreshing legacy cluster state in case it's there.
name|refreshLegacyClusterState
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|watchedCollectionStates
operator|.
name|containsKey
argument_list|(
name|collection
argument_list|)
condition|)
block|{
comment|// Exists as a watched collection, force a refresh.
name|DocCollection
name|newState
init|=
name|fetchCollectionState
argument_list|(
name|collection
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|updateWatchedCollection
argument_list|(
name|collection
argument_list|,
name|newState
argument_list|)
expr_stmt|;
block|}
name|constructState
argument_list|()
expr_stmt|;
block|}
block|}
comment|/** Refresh the set of live nodes. */
DECL|method|updateLiveNodes
specifier|public
name|void
name|updateLiveNodes
parameter_list|()
throws|throws
name|KeeperException
throws|,
name|InterruptedException
block|{
name|refreshLiveNodes
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
DECL|method|getAliases
specifier|public
name|Aliases
name|getAliases
parameter_list|()
block|{
return|return
name|aliases
return|;
block|}
DECL|method|compareStateVersions
specifier|public
name|Integer
name|compareStateVersions
parameter_list|(
name|String
name|coll
parameter_list|,
name|int
name|version
parameter_list|)
block|{
name|DocCollection
name|collection
init|=
name|clusterState
operator|.
name|getCollectionOrNull
argument_list|(
name|coll
argument_list|)
decl_stmt|;
if|if
condition|(
name|collection
operator|==
literal|null
condition|)
return|return
literal|null
return|;
if|if
condition|(
name|collection
operator|.
name|getZNodeVersion
argument_list|()
operator|<
name|version
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Server older than client {}<{}"
argument_list|,
name|collection
operator|.
name|getZNodeVersion
argument_list|()
argument_list|,
name|version
argument_list|)
expr_stmt|;
name|DocCollection
name|nu
init|=
name|getCollectionLive
argument_list|(
name|this
argument_list|,
name|coll
argument_list|)
decl_stmt|;
if|if
condition|(
name|nu
operator|==
literal|null
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|nu
operator|.
name|getZNodeVersion
argument_list|()
operator|>
name|collection
operator|.
name|getZNodeVersion
argument_list|()
condition|)
block|{
name|updateWatchedCollection
argument_list|(
name|coll
argument_list|,
name|nu
argument_list|)
expr_stmt|;
name|collection
operator|=
name|nu
expr_stmt|;
block|}
block|}
if|if
condition|(
name|collection
operator|.
name|getZNodeVersion
argument_list|()
operator|==
name|version
condition|)
block|{
return|return
literal|null
return|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Wrong version from client [{}]!=[{}]"
argument_list|,
name|version
argument_list|,
name|collection
operator|.
name|getZNodeVersion
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|collection
operator|.
name|getZNodeVersion
argument_list|()
return|;
block|}
DECL|method|createClusterStateWatchersAndUpdate
specifier|public
specifier|synchronized
name|void
name|createClusterStateWatchersAndUpdate
parameter_list|()
throws|throws
name|KeeperException
throws|,
name|InterruptedException
block|{
comment|// We need to fetch the current cluster state and the set of live nodes
name|LOG
operator|.
name|info
argument_list|(
literal|"Updating cluster state from ZooKeeper... "
argument_list|)
expr_stmt|;
comment|// Sanity check ZK structure.
if|if
condition|(
operator|!
name|zkClient
operator|.
name|exists
argument_list|(
name|CLUSTER_STATE
argument_list|,
literal|true
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|SERVICE_UNAVAILABLE
argument_list|,
literal|"Cannot connect to cluster at "
operator|+
name|zkClient
operator|.
name|getZkServerAddress
argument_list|()
operator|+
literal|": cluster not found/not ready"
argument_list|)
throw|;
block|}
comment|// on reconnect of SolrZkClient force refresh and re-add watches.
name|refreshLiveNodes
argument_list|(
operator|new
name|LiveNodeWatcher
argument_list|()
argument_list|)
expr_stmt|;
name|refreshLegacyClusterState
argument_list|(
operator|new
name|LegacyClusterStateWatcher
argument_list|()
argument_list|)
expr_stmt|;
name|refreshStateFormat2Collections
argument_list|()
expr_stmt|;
name|refreshCollectionList
argument_list|(
operator|new
name|CollectionsChildWatcher
argument_list|()
argument_list|)
expr_stmt|;
synchronized|synchronized
init|(
name|ZkStateReader
operator|.
name|this
operator|.
name|getUpdateLock
argument_list|()
init|)
block|{
name|constructState
argument_list|()
expr_stmt|;
name|zkClient
operator|.
name|exists
argument_list|(
name|ALIASES
argument_list|,
operator|new
name|Watcher
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|process
parameter_list|(
name|WatchedEvent
name|event
parameter_list|)
block|{
comment|// session events are not change events, and do not remove the watcher
if|if
condition|(
name|EventType
operator|.
name|None
operator|.
name|equals
argument_list|(
name|event
operator|.
name|getType
argument_list|()
argument_list|)
condition|)
block|{
return|return;
block|}
try|try
block|{
synchronized|synchronized
init|(
name|ZkStateReader
operator|.
name|this
operator|.
name|getUpdateLock
argument_list|()
init|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Updating aliases... "
argument_list|)
expr_stmt|;
comment|// remake watch
specifier|final
name|Watcher
name|thisWatch
init|=
name|this
decl_stmt|;
specifier|final
name|Stat
name|stat
init|=
operator|new
name|Stat
argument_list|()
decl_stmt|;
specifier|final
name|byte
index|[]
name|data
init|=
name|zkClient
operator|.
name|getData
argument_list|(
name|ALIASES
argument_list|,
name|thisWatch
argument_list|,
name|stat
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|ZkStateReader
operator|.
name|this
operator|.
name|aliases
operator|=
name|ClusterState
operator|.
name|load
argument_list|(
name|data
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|KeeperException
operator|.
name|ConnectionLossException
decl||
name|KeeperException
operator|.
name|SessionExpiredException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"ZooKeeper watch triggered, but Solr cannot talk to ZK: [{}]"
argument_list|,
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|KeeperException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"A ZK error has occurred"
argument_list|,
name|e
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|ZooKeeperException
argument_list|(
name|SolrException
operator|.
name|ErrorCode
operator|.
name|SERVER_ERROR
argument_list|,
literal|"A ZK error has occurred"
argument_list|,
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
comment|// Restore the interrupted status
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
literal|"Interrupted"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
name|updateAliases
argument_list|()
expr_stmt|;
if|if
condition|(
name|securityNodeListener
operator|!=
literal|null
condition|)
block|{
name|addSecuritynodeWatcher
argument_list|(
name|pair
lambda|->
block|{
name|ConfigData
name|cd
init|=
operator|new
name|ConfigData
argument_list|()
decl_stmt|;
name|cd
operator|.
name|data
operator|=
name|pair
operator|.
name|first
argument_list|()
operator|==
literal|null
operator|||
name|pair
operator|.
name|first
argument_list|()
operator|.
name|length
operator|==
literal|0
condition|?
name|EMPTY_MAP
else|:
name|Utils
operator|.
name|getDeepCopy
argument_list|(
operator|(
name|Map
operator|)
name|fromJSON
argument_list|(
name|pair
operator|.
name|first
argument_list|()
argument_list|)
argument_list|,
literal|4
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|cd
operator|.
name|version
operator|=
name|pair
operator|.
name|second
argument_list|()
operator|==
literal|null
condition|?
operator|-
literal|1
else|:
name|pair
operator|.
name|second
argument_list|()
operator|.
name|getVersion
argument_list|()
expr_stmt|;
name|securityData
operator|=
name|cd
expr_stmt|;
name|securityNodeListener
operator|.
name|run
argument_list|()
expr_stmt|;
block|}
argument_list|)
expr_stmt|;
name|securityData
operator|=
name|getSecurityProps
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|addSecuritynodeWatcher
specifier|private
name|void
name|addSecuritynodeWatcher
parameter_list|(
specifier|final
name|Callable
argument_list|<
name|Pair
argument_list|<
name|byte
index|[]
argument_list|,
name|Stat
argument_list|>
argument_list|>
name|callback
parameter_list|)
throws|throws
name|KeeperException
throws|,
name|InterruptedException
block|{
name|zkClient
operator|.
name|exists
argument_list|(
name|SOLR_SECURITY_CONF_PATH
argument_list|,
operator|new
name|Watcher
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|process
parameter_list|(
name|WatchedEvent
name|event
parameter_list|)
block|{
comment|// session events are not change events, and do not remove the watcher
if|if
condition|(
name|EventType
operator|.
name|None
operator|.
name|equals
argument_list|(
name|event
operator|.
name|getType
argument_list|()
argument_list|)
condition|)
block|{
return|return;
block|}
try|try
block|{
synchronized|synchronized
init|(
name|ZkStateReader
operator|.
name|this
operator|.
name|getUpdateLock
argument_list|()
init|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Updating [{}] ... "
argument_list|,
name|SOLR_SECURITY_CONF_PATH
argument_list|)
expr_stmt|;
comment|// remake watch
specifier|final
name|Watcher
name|thisWatch
init|=
name|this
decl_stmt|;
specifier|final
name|Stat
name|stat
init|=
operator|new
name|Stat
argument_list|()
decl_stmt|;
specifier|final
name|byte
index|[]
name|data
init|=
name|getZkClient
argument_list|()
operator|.
name|getData
argument_list|(
name|SOLR_SECURITY_CONF_PATH
argument_list|,
name|thisWatch
argument_list|,
name|stat
argument_list|,
literal|true
argument_list|)
decl_stmt|;
try|try
block|{
name|callback
operator|.
name|call
argument_list|(
operator|new
name|Pair
argument_list|<>
argument_list|(
name|data
argument_list|,
name|stat
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Error running collections node listener"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|KeeperException
operator|.
name|ConnectionLossException
decl||
name|KeeperException
operator|.
name|SessionExpiredException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"ZooKeeper watch triggered, but Solr cannot talk to ZK: [{}]"
argument_list|,
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|KeeperException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"A ZK error has occurred"
argument_list|,
name|e
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|ZooKeeperException
argument_list|(
name|ErrorCode
operator|.
name|SERVER_ERROR
argument_list|,
literal|""
argument_list|,
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
comment|// Restore the interrupted status
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
literal|"Interrupted"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
comment|/**    * Construct the total state view from all sources.    * Must hold {@link #getUpdateLock()} before calling this.    */
DECL|method|constructState
specifier|private
name|void
name|constructState
parameter_list|()
block|{
comment|// Legacy clusterstate is authoritative, for backwards compatibility.
comment|// To move a collection's state to format2, first create the new state2 format node, then remove legacy entry.
name|Map
argument_list|<
name|String
argument_list|,
name|ClusterState
operator|.
name|CollectionRef
argument_list|>
name|result
init|=
operator|new
name|LinkedHashMap
argument_list|<>
argument_list|(
name|legacyCollectionStates
argument_list|)
decl_stmt|;
comment|// Add state format2 collections, but don't override legacy collection states.
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|DocCollection
argument_list|>
name|entry
range|:
name|watchedCollectionStates
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|result
operator|.
name|putIfAbsent
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
operator|new
name|ClusterState
operator|.
name|CollectionRef
argument_list|(
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// Finally, add any lazy collections that aren't already accounted for.
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|LazyCollectionRef
argument_list|>
name|entry
range|:
name|lazyCollectionStates
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|result
operator|.
name|putIfAbsent
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|clusterState
operator|=
operator|new
name|ClusterState
argument_list|(
name|liveNodes
argument_list|,
name|result
argument_list|,
name|legacyClusterStateVersion
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"clusterStateSet: legacy [{}] interesting [{}] watched [{}] lazy [{}] total [{}]"
argument_list|,
name|legacyCollectionStates
operator|.
name|keySet
argument_list|()
operator|.
name|size
argument_list|()
argument_list|,
name|collectionWatches
operator|.
name|keySet
argument_list|()
operator|.
name|size
argument_list|()
argument_list|,
name|watchedCollectionStates
operator|.
name|keySet
argument_list|()
operator|.
name|size
argument_list|()
argument_list|,
name|lazyCollectionStates
operator|.
name|keySet
argument_list|()
operator|.
name|size
argument_list|()
argument_list|,
name|clusterState
operator|.
name|getCollectionStates
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"clusterStateSet: legacy [{}] interesting [{}] watched [{}] lazy [{}] total [{}]"
argument_list|,
name|legacyCollectionStates
operator|.
name|keySet
argument_list|()
argument_list|,
name|collectionWatches
operator|.
name|keySet
argument_list|()
argument_list|,
name|watchedCollectionStates
operator|.
name|keySet
argument_list|()
argument_list|,
name|lazyCollectionStates
operator|.
name|keySet
argument_list|()
argument_list|,
name|clusterState
operator|.
name|getCollectionStates
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Refresh legacy (shared) clusterstate.json    */
DECL|method|refreshLegacyClusterState
specifier|private
name|void
name|refreshLegacyClusterState
parameter_list|(
name|Watcher
name|watcher
parameter_list|)
throws|throws
name|KeeperException
throws|,
name|InterruptedException
block|{
try|try
block|{
specifier|final
name|Stat
name|stat
init|=
operator|new
name|Stat
argument_list|()
decl_stmt|;
specifier|final
name|byte
index|[]
name|data
init|=
name|zkClient
operator|.
name|getData
argument_list|(
name|CLUSTER_STATE
argument_list|,
name|watcher
argument_list|,
name|stat
argument_list|,
literal|true
argument_list|)
decl_stmt|;
specifier|final
name|ClusterState
name|loadedData
init|=
name|ClusterState
operator|.
name|load
argument_list|(
name|stat
operator|.
name|getVersion
argument_list|()
argument_list|,
name|data
argument_list|,
name|emptySet
argument_list|()
argument_list|,
name|CLUSTER_STATE
argument_list|)
decl_stmt|;
synchronized|synchronized
init|(
name|getUpdateLock
argument_list|()
init|)
block|{
if|if
condition|(
name|this
operator|.
name|legacyClusterStateVersion
operator|>=
name|stat
operator|.
name|getVersion
argument_list|()
condition|)
block|{
comment|// Nothing to do, someone else updated same or newer.
return|return;
block|}
name|Set
argument_list|<
name|String
argument_list|>
name|liveNodes
init|=
name|this
operator|.
name|liveNodes
decl_stmt|;
comment|// volatile read
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|CollectionWatch
argument_list|>
name|watchEntry
range|:
name|this
operator|.
name|collectionWatches
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|String
name|coll
init|=
name|watchEntry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|CollectionWatch
name|collWatch
init|=
name|watchEntry
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|ClusterState
operator|.
name|CollectionRef
name|ref
init|=
name|this
operator|.
name|legacyCollectionStates
operator|.
name|get
argument_list|(
name|coll
argument_list|)
decl_stmt|;
if|if
condition|(
name|ref
operator|==
literal|null
condition|)
continue|continue;
comment|// legacy collections are always in-memory
name|DocCollection
name|newState
init|=
name|ref
operator|.
name|get
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|collWatch
operator|.
name|stateWatchers
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|!
name|Objects
operator|.
name|equals
argument_list|(
name|loadedData
operator|.
name|getCollectionStates
argument_list|()
operator|.
name|get
argument_list|(
name|coll
argument_list|)
operator|.
name|get
argument_list|()
argument_list|,
name|newState
argument_list|)
condition|)
block|{
name|notifyStateWatchers
argument_list|(
name|liveNodes
argument_list|,
name|coll
argument_list|,
name|newState
argument_list|)
expr_stmt|;
block|}
block|}
name|this
operator|.
name|legacyCollectionStates
operator|=
name|loadedData
operator|.
name|getCollectionStates
argument_list|()
expr_stmt|;
name|this
operator|.
name|legacyClusterStateVersion
operator|=
name|stat
operator|.
name|getVersion
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|KeeperException
operator|.
name|NoNodeException
name|e
parameter_list|)
block|{
comment|// Ignore missing legacy clusterstate.json.
synchronized|synchronized
init|(
name|getUpdateLock
argument_list|()
init|)
block|{
name|this
operator|.
name|legacyCollectionStates
operator|=
name|emptyMap
argument_list|()
expr_stmt|;
name|this
operator|.
name|legacyClusterStateVersion
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Refresh state format2 collections.    */
DECL|method|refreshStateFormat2Collections
specifier|private
name|void
name|refreshStateFormat2Collections
parameter_list|()
block|{
for|for
control|(
name|String
name|coll
range|:
name|collectionWatches
operator|.
name|keySet
argument_list|()
control|)
block|{
operator|new
name|StateWatcher
argument_list|(
name|coll
argument_list|)
operator|.
name|refreshAndWatch
argument_list|()
expr_stmt|;
block|}
block|}
comment|// We don't get a Stat or track versions on getChildren() calls, so force linearization.
DECL|field|refreshCollectionListLock
specifier|private
specifier|final
name|Object
name|refreshCollectionListLock
init|=
operator|new
name|Object
argument_list|()
decl_stmt|;
comment|/**    * Search for any lazy-loadable state format2 collections.    *    * A stateFormat=1 collection which is not interesting to us can also    * be put into the {@link #lazyCollectionStates} map here. But that is okay    * because {@link #constructState()} will give priority to collections in the    * shared collection state over this map.    * In fact this is a clever way to avoid doing a ZK exists check on    * the /collections/collection_name/state.json znode    * Such an exists check is done in {@link ClusterState#hasCollection(String)} and    * {@link ClusterState#getCollections()} and {@link ClusterState#getCollectionsMap()} methods    * have a safeguard against exposing wrong collection names to the users    */
DECL|method|refreshCollectionList
specifier|private
name|void
name|refreshCollectionList
parameter_list|(
name|Watcher
name|watcher
parameter_list|)
throws|throws
name|KeeperException
throws|,
name|InterruptedException
block|{
synchronized|synchronized
init|(
name|refreshCollectionListLock
init|)
block|{
name|List
argument_list|<
name|String
argument_list|>
name|children
init|=
literal|null
decl_stmt|;
try|try
block|{
name|children
operator|=
name|zkClient
operator|.
name|getChildren
argument_list|(
name|COLLECTIONS_ZKNODE
argument_list|,
name|watcher
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|KeeperException
operator|.
name|NoNodeException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Error fetching collection names: [{}]"
argument_list|,
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
comment|// fall through
block|}
if|if
condition|(
name|children
operator|==
literal|null
operator|||
name|children
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|lazyCollectionStates
operator|.
name|clear
argument_list|()
expr_stmt|;
return|return;
block|}
comment|// Don't lock getUpdateLock() here, we don't need it and it would cause deadlock.
comment|// Don't mess with watchedCollections, they should self-manage.
comment|// First, drop any children that disappeared.
name|this
operator|.
name|lazyCollectionStates
operator|.
name|keySet
argument_list|()
operator|.
name|retainAll
argument_list|(
name|children
argument_list|)
expr_stmt|;
for|for
control|(
name|String
name|coll
range|:
name|children
control|)
block|{
comment|// We will create an eager collection for any interesting collections, so don't add to lazy.
if|if
condition|(
operator|!
name|collectionWatches
operator|.
name|containsKey
argument_list|(
name|coll
argument_list|)
condition|)
block|{
comment|// Double check contains just to avoid allocating an object.
name|LazyCollectionRef
name|existing
init|=
name|lazyCollectionStates
operator|.
name|get
argument_list|(
name|coll
argument_list|)
decl_stmt|;
if|if
condition|(
name|existing
operator|==
literal|null
condition|)
block|{
name|lazyCollectionStates
operator|.
name|putIfAbsent
argument_list|(
name|coll
argument_list|,
operator|new
name|LazyCollectionRef
argument_list|(
name|coll
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
DECL|class|LazyCollectionRef
specifier|private
class|class
name|LazyCollectionRef
extends|extends
name|ClusterState
operator|.
name|CollectionRef
block|{
DECL|field|collName
specifier|private
specifier|final
name|String
name|collName
decl_stmt|;
DECL|method|LazyCollectionRef
specifier|public
name|LazyCollectionRef
parameter_list|(
name|String
name|collName
parameter_list|)
block|{
name|super
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|this
operator|.
name|collName
operator|=
name|collName
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|get
specifier|public
name|DocCollection
name|get
parameter_list|()
block|{
comment|// TODO: consider limited caching
return|return
name|getCollectionLive
argument_list|(
name|ZkStateReader
operator|.
name|this
argument_list|,
name|collName
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|isLazilyLoaded
specifier|public
name|boolean
name|isLazilyLoaded
parameter_list|()
block|{
return|return
literal|true
return|;
block|}
annotation|@
name|Override
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"LazyCollectionRef("
operator|+
name|collName
operator|+
literal|")"
return|;
block|}
block|}
comment|// We don't get a Stat or track versions on getChildren() calls, so force linearization.
DECL|field|refreshLiveNodesLock
specifier|private
specifier|final
name|Object
name|refreshLiveNodesLock
init|=
operator|new
name|Object
argument_list|()
decl_stmt|;
comment|// Ensures that only the latest getChildren fetch gets applied.
DECL|field|lastFetchedLiveNodes
specifier|private
specifier|final
name|AtomicReference
argument_list|<
name|Set
argument_list|<
name|String
argument_list|>
argument_list|>
name|lastFetchedLiveNodes
init|=
operator|new
name|AtomicReference
argument_list|<>
argument_list|()
decl_stmt|;
comment|/**    * Refresh live_nodes.    */
DECL|method|refreshLiveNodes
specifier|private
name|void
name|refreshLiveNodes
parameter_list|(
name|Watcher
name|watcher
parameter_list|)
throws|throws
name|KeeperException
throws|,
name|InterruptedException
block|{
synchronized|synchronized
init|(
name|refreshLiveNodesLock
init|)
block|{
name|Set
argument_list|<
name|String
argument_list|>
name|newLiveNodes
decl_stmt|;
try|try
block|{
name|List
argument_list|<
name|String
argument_list|>
name|nodeList
init|=
name|zkClient
operator|.
name|getChildren
argument_list|(
name|LIVE_NODES_ZKNODE
argument_list|,
name|watcher
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|newLiveNodes
operator|=
operator|new
name|HashSet
argument_list|<>
argument_list|(
name|nodeList
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|KeeperException
operator|.
name|NoNodeException
name|e
parameter_list|)
block|{
name|newLiveNodes
operator|=
name|emptySet
argument_list|()
expr_stmt|;
block|}
name|lastFetchedLiveNodes
operator|.
name|set
argument_list|(
name|newLiveNodes
argument_list|)
expr_stmt|;
block|}
comment|// Can't lock getUpdateLock() until we release the other, it would cause deadlock.
name|Set
argument_list|<
name|String
argument_list|>
name|oldLiveNodes
decl_stmt|,
name|newLiveNodes
decl_stmt|;
synchronized|synchronized
init|(
name|getUpdateLock
argument_list|()
init|)
block|{
name|newLiveNodes
operator|=
name|lastFetchedLiveNodes
operator|.
name|getAndSet
argument_list|(
literal|null
argument_list|)
expr_stmt|;
if|if
condition|(
name|newLiveNodes
operator|==
literal|null
condition|)
block|{
comment|// Someone else won the race to apply the last update, just exit.
return|return;
block|}
name|oldLiveNodes
operator|=
name|this
operator|.
name|liveNodes
expr_stmt|;
name|this
operator|.
name|liveNodes
operator|=
name|newLiveNodes
expr_stmt|;
if|if
condition|(
name|clusterState
operator|!=
literal|null
condition|)
block|{
name|clusterState
operator|.
name|setLiveNodes
argument_list|(
name|newLiveNodes
argument_list|)
expr_stmt|;
block|}
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Updated live nodes from ZooKeeper... ({}) -> ({})"
argument_list|,
name|oldLiveNodes
operator|.
name|size
argument_list|()
argument_list|,
name|newLiveNodes
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Updated live nodes from ZooKeeper... {} -> {}"
argument_list|,
operator|new
name|TreeSet
argument_list|<>
argument_list|(
name|oldLiveNodes
argument_list|)
argument_list|,
operator|new
name|TreeSet
argument_list|<>
argument_list|(
name|newLiveNodes
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * @return information about the cluster from ZooKeeper    */
DECL|method|getClusterState
specifier|public
name|ClusterState
name|getClusterState
parameter_list|()
block|{
return|return
name|clusterState
return|;
block|}
DECL|method|getUpdateLock
specifier|public
name|Object
name|getUpdateLock
parameter_list|()
block|{
return|return
name|this
return|;
block|}
DECL|method|close
specifier|public
name|void
name|close
parameter_list|()
block|{
name|this
operator|.
name|closed
operator|=
literal|true
expr_stmt|;
name|notifications
operator|.
name|shutdown
argument_list|()
expr_stmt|;
if|if
condition|(
name|closeClient
condition|)
block|{
name|zkClient
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|getLeaderUrl
specifier|public
name|String
name|getLeaderUrl
parameter_list|(
name|String
name|collection
parameter_list|,
name|String
name|shard
parameter_list|,
name|int
name|timeout
parameter_list|)
throws|throws
name|InterruptedException
block|{
name|ZkCoreNodeProps
name|props
init|=
operator|new
name|ZkCoreNodeProps
argument_list|(
name|getLeaderRetry
argument_list|(
name|collection
argument_list|,
name|shard
argument_list|,
name|timeout
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|props
operator|.
name|getCoreUrl
argument_list|()
return|;
block|}
DECL|method|getLeader
specifier|public
name|Replica
name|getLeader
parameter_list|(
name|String
name|collection
parameter_list|,
name|String
name|shard
parameter_list|)
block|{
if|if
condition|(
name|clusterState
operator|!=
literal|null
condition|)
block|{
name|DocCollection
name|docCollection
init|=
name|clusterState
operator|.
name|getCollectionOrNull
argument_list|(
name|collection
argument_list|)
decl_stmt|;
name|Replica
name|replica
init|=
name|docCollection
operator|!=
literal|null
condition|?
name|docCollection
operator|.
name|getLeader
argument_list|(
name|shard
argument_list|)
else|:
literal|null
decl_stmt|;
if|if
condition|(
name|replica
operator|!=
literal|null
operator|&&
name|getClusterState
argument_list|()
operator|.
name|liveNodesContain
argument_list|(
name|replica
operator|.
name|getNodeName
argument_list|()
argument_list|)
condition|)
block|{
return|return
name|replica
return|;
block|}
block|}
return|return
literal|null
return|;
block|}
comment|/**    * Get shard leader properties, with retry if none exist.    */
DECL|method|getLeaderRetry
specifier|public
name|Replica
name|getLeaderRetry
parameter_list|(
name|String
name|collection
parameter_list|,
name|String
name|shard
parameter_list|)
throws|throws
name|InterruptedException
block|{
return|return
name|getLeaderRetry
argument_list|(
name|collection
argument_list|,
name|shard
argument_list|,
name|GET_LEADER_RETRY_DEFAULT_TIMEOUT
argument_list|)
return|;
block|}
comment|/**    * Get shard leader properties, with retry if none exist.    */
DECL|method|getLeaderRetry
specifier|public
name|Replica
name|getLeaderRetry
parameter_list|(
name|String
name|collection
parameter_list|,
name|String
name|shard
parameter_list|,
name|int
name|timeout
parameter_list|)
throws|throws
name|InterruptedException
block|{
name|long
name|timeoutAt
init|=
name|System
operator|.
name|nanoTime
argument_list|()
operator|+
name|TimeUnit
operator|.
name|NANOSECONDS
operator|.
name|convert
argument_list|(
name|timeout
argument_list|,
name|TimeUnit
operator|.
name|MILLISECONDS
argument_list|)
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|Replica
name|leader
init|=
name|getLeader
argument_list|(
name|collection
argument_list|,
name|shard
argument_list|)
decl_stmt|;
if|if
condition|(
name|leader
operator|!=
literal|null
condition|)
return|return
name|leader
return|;
if|if
condition|(
name|System
operator|.
name|nanoTime
argument_list|()
operator|>=
name|timeoutAt
operator|||
name|closed
condition|)
break|break;
name|Thread
operator|.
name|sleep
argument_list|(
name|GET_LEADER_RETRY_INTERVAL_MS
argument_list|)
expr_stmt|;
block|}
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|SERVICE_UNAVAILABLE
argument_list|,
literal|"No registered leader was found after waiting for "
operator|+
name|timeout
operator|+
literal|"ms "
operator|+
literal|", collection: "
operator|+
name|collection
operator|+
literal|" slice: "
operator|+
name|shard
argument_list|)
throw|;
block|}
comment|/**    * Get path where shard leader properties live in zookeeper.    */
DECL|method|getShardLeadersPath
specifier|public
specifier|static
name|String
name|getShardLeadersPath
parameter_list|(
name|String
name|collection
parameter_list|,
name|String
name|shardId
parameter_list|)
block|{
return|return
name|COLLECTIONS_ZKNODE
operator|+
literal|"/"
operator|+
name|collection
operator|+
literal|"/"
operator|+
name|SHARD_LEADERS_ZKNODE
operator|+
operator|(
name|shardId
operator|!=
literal|null
condition|?
operator|(
literal|"/"
operator|+
name|shardId
operator|)
else|:
literal|""
operator|)
operator|+
literal|"/leader"
return|;
block|}
comment|/**    * Get path where shard leader elections ephemeral nodes are.    */
DECL|method|getShardLeadersElectPath
specifier|public
specifier|static
name|String
name|getShardLeadersElectPath
parameter_list|(
name|String
name|collection
parameter_list|,
name|String
name|shardId
parameter_list|)
block|{
return|return
name|COLLECTIONS_ZKNODE
operator|+
literal|"/"
operator|+
name|collection
operator|+
literal|"/"
operator|+
name|LEADER_ELECT_ZKNODE
operator|+
operator|(
name|shardId
operator|!=
literal|null
condition|?
operator|(
literal|"/"
operator|+
name|shardId
operator|+
literal|"/"
operator|+
name|ELECTION_NODE
operator|)
else|:
literal|""
operator|)
return|;
block|}
DECL|method|getReplicaProps
specifier|public
name|List
argument_list|<
name|ZkCoreNodeProps
argument_list|>
name|getReplicaProps
parameter_list|(
name|String
name|collection
parameter_list|,
name|String
name|shardId
parameter_list|,
name|String
name|thisCoreNodeName
parameter_list|)
block|{
return|return
name|getReplicaProps
argument_list|(
name|collection
argument_list|,
name|shardId
argument_list|,
name|thisCoreNodeName
argument_list|,
literal|null
argument_list|)
return|;
block|}
DECL|method|getReplicaProps
specifier|public
name|List
argument_list|<
name|ZkCoreNodeProps
argument_list|>
name|getReplicaProps
parameter_list|(
name|String
name|collection
parameter_list|,
name|String
name|shardId
parameter_list|,
name|String
name|thisCoreNodeName
parameter_list|,
name|Replica
operator|.
name|State
name|mustMatchStateFilter
parameter_list|)
block|{
return|return
name|getReplicaProps
argument_list|(
name|collection
argument_list|,
name|shardId
argument_list|,
name|thisCoreNodeName
argument_list|,
name|mustMatchStateFilter
argument_list|,
literal|null
argument_list|)
return|;
block|}
DECL|method|getReplicaProps
specifier|public
name|List
argument_list|<
name|ZkCoreNodeProps
argument_list|>
name|getReplicaProps
parameter_list|(
name|String
name|collection
parameter_list|,
name|String
name|shardId
parameter_list|,
name|String
name|thisCoreNodeName
parameter_list|,
name|Replica
operator|.
name|State
name|mustMatchStateFilter
parameter_list|,
name|Replica
operator|.
name|State
name|mustNotMatchStateFilter
parameter_list|)
block|{
assert|assert
name|thisCoreNodeName
operator|!=
literal|null
assert|;
name|ClusterState
name|clusterState
init|=
name|this
operator|.
name|clusterState
decl_stmt|;
if|if
condition|(
name|clusterState
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|Map
argument_list|<
name|String
argument_list|,
name|Slice
argument_list|>
name|slices
init|=
name|clusterState
operator|.
name|getSlicesMap
argument_list|(
name|collection
argument_list|)
decl_stmt|;
if|if
condition|(
name|slices
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|ZooKeeperException
argument_list|(
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
literal|"Could not find collection in zk: "
operator|+
name|collection
argument_list|)
throw|;
block|}
name|Slice
name|replicas
init|=
name|slices
operator|.
name|get
argument_list|(
name|shardId
argument_list|)
decl_stmt|;
if|if
condition|(
name|replicas
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|ZooKeeperException
argument_list|(
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
literal|"Could not find shardId in zk: "
operator|+
name|shardId
argument_list|)
throw|;
block|}
name|Map
argument_list|<
name|String
argument_list|,
name|Replica
argument_list|>
name|shardMap
init|=
name|replicas
operator|.
name|getReplicasMap
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|ZkCoreNodeProps
argument_list|>
name|nodes
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|shardMap
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|Entry
argument_list|<
name|String
argument_list|,
name|Replica
argument_list|>
name|entry
range|:
name|shardMap
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|ZkCoreNodeProps
name|nodeProps
init|=
operator|new
name|ZkCoreNodeProps
argument_list|(
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
decl_stmt|;
name|String
name|coreNodeName
init|=
name|entry
operator|.
name|getValue
argument_list|()
operator|.
name|getName
argument_list|()
decl_stmt|;
if|if
condition|(
name|clusterState
operator|.
name|liveNodesContain
argument_list|(
name|nodeProps
operator|.
name|getNodeName
argument_list|()
argument_list|)
operator|&&
operator|!
name|coreNodeName
operator|.
name|equals
argument_list|(
name|thisCoreNodeName
argument_list|)
condition|)
block|{
if|if
condition|(
name|mustMatchStateFilter
operator|==
literal|null
operator|||
name|mustMatchStateFilter
operator|==
name|Replica
operator|.
name|State
operator|.
name|getState
argument_list|(
name|nodeProps
operator|.
name|getState
argument_list|()
argument_list|)
condition|)
block|{
if|if
condition|(
name|mustNotMatchStateFilter
operator|==
literal|null
operator|||
name|mustNotMatchStateFilter
operator|!=
name|Replica
operator|.
name|State
operator|.
name|getState
argument_list|(
name|nodeProps
operator|.
name|getState
argument_list|()
argument_list|)
condition|)
block|{
name|nodes
operator|.
name|add
argument_list|(
name|nodeProps
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|nodes
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
comment|// no replicas
return|return
literal|null
return|;
block|}
return|return
name|nodes
return|;
block|}
DECL|method|getZkClient
specifier|public
name|SolrZkClient
name|getZkClient
parameter_list|()
block|{
return|return
name|zkClient
return|;
block|}
DECL|method|updateAliases
specifier|public
name|void
name|updateAliases
parameter_list|()
throws|throws
name|KeeperException
throws|,
name|InterruptedException
block|{
specifier|final
name|byte
index|[]
name|data
init|=
name|zkClient
operator|.
name|getData
argument_list|(
name|ALIASES
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|this
operator|.
name|aliases
operator|=
name|ClusterState
operator|.
name|load
argument_list|(
name|data
argument_list|)
expr_stmt|;
block|}
DECL|method|getClusterProps
specifier|public
name|Map
name|getClusterProps
parameter_list|()
block|{
try|try
block|{
if|if
condition|(
name|getZkClient
argument_list|()
operator|.
name|exists
argument_list|(
name|ZkStateReader
operator|.
name|CLUSTER_PROPS
argument_list|,
literal|true
argument_list|)
condition|)
block|{
return|return
operator|(
name|Map
operator|)
name|Utils
operator|.
name|fromJSON
argument_list|(
name|getZkClient
argument_list|()
operator|.
name|getData
argument_list|(
name|ZkStateReader
operator|.
name|CLUSTER_PROPS
argument_list|,
literal|null
argument_list|,
operator|new
name|Stat
argument_list|()
argument_list|,
literal|true
argument_list|)
argument_list|)
return|;
block|}
else|else
block|{
return|return
operator|new
name|LinkedHashMap
argument_list|()
return|;
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|SERVER_ERROR
argument_list|,
literal|"Thread interrupted. Error reading cluster properties"
argument_list|,
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|KeeperException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|SERVER_ERROR
argument_list|,
literal|"Error reading cluster properties"
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**    * This method sets a cluster property.    *    * @param propertyName  The property name to be set.    * @param propertyValue The value of the property.    */
DECL|method|setClusterProperty
specifier|public
name|void
name|setClusterProperty
parameter_list|(
name|String
name|propertyName
parameter_list|,
name|String
name|propertyValue
parameter_list|)
block|{
if|if
condition|(
operator|!
name|KNOWN_CLUSTER_PROPS
operator|.
name|contains
argument_list|(
name|propertyName
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
literal|"Not a known cluster property "
operator|+
name|propertyName
argument_list|)
throw|;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
name|Stat
name|s
init|=
operator|new
name|Stat
argument_list|()
decl_stmt|;
try|try
block|{
if|if
condition|(
name|getZkClient
argument_list|()
operator|.
name|exists
argument_list|(
name|CLUSTER_PROPS
argument_list|,
literal|true
argument_list|)
condition|)
block|{
name|Map
name|properties
init|=
operator|(
name|Map
operator|)
name|Utils
operator|.
name|fromJSON
argument_list|(
name|getZkClient
argument_list|()
operator|.
name|getData
argument_list|(
name|CLUSTER_PROPS
argument_list|,
literal|null
argument_list|,
name|s
argument_list|,
literal|true
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|propertyValue
operator|==
literal|null
condition|)
block|{
comment|//Don't update ZK unless absolutely necessary.
if|if
condition|(
name|properties
operator|.
name|get
argument_list|(
name|propertyName
argument_list|)
operator|!=
literal|null
condition|)
block|{
name|properties
operator|.
name|remove
argument_list|(
name|propertyName
argument_list|)
expr_stmt|;
name|getZkClient
argument_list|()
operator|.
name|setData
argument_list|(
name|CLUSTER_PROPS
argument_list|,
name|Utils
operator|.
name|toJSON
argument_list|(
name|properties
argument_list|)
argument_list|,
name|s
operator|.
name|getVersion
argument_list|()
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|//Don't update ZK unless absolutely necessary.
if|if
condition|(
operator|!
name|propertyValue
operator|.
name|equals
argument_list|(
name|properties
operator|.
name|get
argument_list|(
name|propertyName
argument_list|)
argument_list|)
condition|)
block|{
name|properties
operator|.
name|put
argument_list|(
name|propertyName
argument_list|,
name|propertyValue
argument_list|)
expr_stmt|;
name|getZkClient
argument_list|()
operator|.
name|setData
argument_list|(
name|CLUSTER_PROPS
argument_list|,
name|Utils
operator|.
name|toJSON
argument_list|(
name|properties
argument_list|)
argument_list|,
name|s
operator|.
name|getVersion
argument_list|()
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|Map
name|properties
init|=
operator|new
name|LinkedHashMap
argument_list|()
decl_stmt|;
name|properties
operator|.
name|put
argument_list|(
name|propertyName
argument_list|,
name|propertyValue
argument_list|)
expr_stmt|;
name|getZkClient
argument_list|()
operator|.
name|create
argument_list|(
name|CLUSTER_PROPS
argument_list|,
name|Utils
operator|.
name|toJSON
argument_list|(
name|properties
argument_list|)
argument_list|,
name|CreateMode
operator|.
name|PERSISTENT
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|KeeperException
operator|.
name|BadVersionException
decl||
name|KeeperException
operator|.
name|NodeExistsException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Race condition while trying to set a new cluster prop on current version [{}]"
argument_list|,
name|s
operator|.
name|getVersion
argument_list|()
argument_list|)
expr_stmt|;
comment|//race condition
continue|continue;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|error
argument_list|(
literal|"Thread Interrupted. Error updating path [{}]"
argument_list|,
name|CLUSTER_PROPS
argument_list|,
name|e
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|SERVER_ERROR
argument_list|,
literal|"Thread Interrupted. Error updating cluster property "
operator|+
name|propertyName
argument_list|,
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|KeeperException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Error updating path [{}]"
argument_list|,
name|CLUSTER_PROPS
argument_list|,
name|e
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|SERVER_ERROR
argument_list|,
literal|"Error updating cluster property "
operator|+
name|propertyName
argument_list|,
name|e
argument_list|)
throw|;
block|}
break|break;
block|}
block|}
comment|/**    * Returns the content of /security.json from ZooKeeper as a Map    * If the files doesn't exist, it returns null.    */
DECL|method|getSecurityProps
specifier|public
name|ConfigData
name|getSecurityProps
parameter_list|(
name|boolean
name|getFresh
parameter_list|)
block|{
if|if
condition|(
operator|!
name|getFresh
condition|)
block|{
if|if
condition|(
name|securityData
operator|==
literal|null
condition|)
return|return
operator|new
name|ConfigData
argument_list|(
name|EMPTY_MAP
argument_list|,
operator|-
literal|1
argument_list|)
return|;
return|return
operator|new
name|ConfigData
argument_list|(
name|securityData
operator|.
name|data
argument_list|,
name|securityData
operator|.
name|version
argument_list|)
return|;
block|}
try|try
block|{
name|Stat
name|stat
init|=
operator|new
name|Stat
argument_list|()
decl_stmt|;
if|if
condition|(
name|getZkClient
argument_list|()
operator|.
name|exists
argument_list|(
name|SOLR_SECURITY_CONF_PATH
argument_list|,
literal|true
argument_list|)
condition|)
block|{
specifier|final
name|byte
index|[]
name|data
init|=
name|getZkClient
argument_list|()
operator|.
name|getData
argument_list|(
name|ZkStateReader
operator|.
name|SOLR_SECURITY_CONF_PATH
argument_list|,
literal|null
argument_list|,
name|stat
argument_list|,
literal|true
argument_list|)
decl_stmt|;
return|return
name|data
operator|!=
literal|null
operator|&&
name|data
operator|.
name|length
operator|>
literal|0
condition|?
operator|new
name|ConfigData
argument_list|(
operator|(
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
operator|)
name|Utils
operator|.
name|fromJSON
argument_list|(
name|data
argument_list|)
argument_list|,
name|stat
operator|.
name|getVersion
argument_list|()
argument_list|)
else|:
literal|null
return|;
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|SERVER_ERROR
argument_list|,
literal|"Error reading security properties"
argument_list|,
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|KeeperException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|SERVER_ERROR
argument_list|,
literal|"Error reading security properties"
argument_list|,
name|e
argument_list|)
throw|;
block|}
return|return
literal|null
return|;
block|}
comment|/**    * Returns the baseURL corresponding to a given node's nodeName --    * NOTE: does not (currently) imply that the nodeName (or resulting     * baseURL) exists in the cluster.    * @lucene.experimental    */
DECL|method|getBaseUrlForNodeName
specifier|public
name|String
name|getBaseUrlForNodeName
parameter_list|(
specifier|final
name|String
name|nodeName
parameter_list|)
block|{
specifier|final
name|int
name|_offset
init|=
name|nodeName
operator|.
name|indexOf
argument_list|(
literal|"_"
argument_list|)
decl_stmt|;
if|if
condition|(
name|_offset
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"nodeName does not contain expected '_' seperator: "
operator|+
name|nodeName
argument_list|)
throw|;
block|}
specifier|final
name|String
name|hostAndPort
init|=
name|nodeName
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|_offset
argument_list|)
decl_stmt|;
try|try
block|{
specifier|final
name|String
name|path
init|=
name|URLDecoder
operator|.
name|decode
argument_list|(
name|nodeName
operator|.
name|substring
argument_list|(
literal|1
operator|+
name|_offset
argument_list|)
argument_list|,
literal|"UTF-8"
argument_list|)
decl_stmt|;
name|String
name|urlScheme
init|=
operator|(
name|String
operator|)
name|getClusterProps
argument_list|()
operator|.
name|get
argument_list|(
name|URL_SCHEME
argument_list|)
decl_stmt|;
if|if
condition|(
name|urlScheme
operator|==
literal|null
condition|)
block|{
name|urlScheme
operator|=
literal|"http"
expr_stmt|;
block|}
return|return
name|urlScheme
operator|+
literal|"://"
operator|+
name|hostAndPort
operator|+
operator|(
name|path
operator|.
name|isEmpty
argument_list|()
condition|?
literal|""
else|:
operator|(
literal|"/"
operator|+
name|path
operator|)
operator|)
return|;
block|}
catch|catch
parameter_list|(
name|UnsupportedEncodingException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"JVM Does not seem to support UTF-8"
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
comment|/** Watches a single collection's format2 state.json. */
DECL|class|StateWatcher
class|class
name|StateWatcher
implements|implements
name|Watcher
block|{
DECL|field|coll
specifier|private
specifier|final
name|String
name|coll
decl_stmt|;
DECL|method|StateWatcher
name|StateWatcher
parameter_list|(
name|String
name|coll
parameter_list|)
block|{
name|this
operator|.
name|coll
operator|=
name|coll
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|process
specifier|public
name|void
name|process
parameter_list|(
name|WatchedEvent
name|event
parameter_list|)
block|{
comment|// session events are not change events, and do not remove the watcher
if|if
condition|(
name|EventType
operator|.
name|None
operator|.
name|equals
argument_list|(
name|event
operator|.
name|getType
argument_list|()
argument_list|)
condition|)
block|{
return|return;
block|}
if|if
condition|(
operator|!
name|collectionWatches
operator|.
name|containsKey
argument_list|(
name|coll
argument_list|)
condition|)
block|{
comment|// This collection is no longer interesting, stop watching.
name|LOG
operator|.
name|info
argument_list|(
literal|"Uninteresting collection {}"
argument_list|,
name|coll
argument_list|)
expr_stmt|;
return|return;
block|}
name|int
name|liveNodesSize
init|=
name|ZkStateReader
operator|.
name|this
operator|.
name|clusterState
operator|==
literal|null
condition|?
literal|0
else|:
name|ZkStateReader
operator|.
name|this
operator|.
name|clusterState
operator|.
name|getLiveNodes
argument_list|()
operator|.
name|size
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"A cluster state change: [{}] for collection [{}] has occurred - updating... (live nodes size: [{}])"
argument_list|,
name|event
argument_list|,
name|coll
argument_list|,
name|liveNodesSize
argument_list|)
expr_stmt|;
name|refreshAndWatch
argument_list|()
expr_stmt|;
synchronized|synchronized
init|(
name|getUpdateLock
argument_list|()
init|)
block|{
name|constructState
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * Refresh collection state from ZK and leave a watch for future changes.      * As a side effect, updates {@link #clusterState} and {@link #watchedCollectionStates}      * with the results of the refresh.      */
DECL|method|refreshAndWatch
specifier|public
name|void
name|refreshAndWatch
parameter_list|()
block|{
try|try
block|{
name|DocCollection
name|newState
init|=
name|fetchCollectionState
argument_list|(
name|coll
argument_list|,
name|this
argument_list|)
decl_stmt|;
name|updateWatchedCollection
argument_list|(
name|coll
argument_list|,
name|newState
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|KeeperException
operator|.
name|SessionExpiredException
decl||
name|KeeperException
operator|.
name|ConnectionLossException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"ZooKeeper watch triggered, but Solr cannot talk to ZK: [{}]"
argument_list|,
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|KeeperException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Unwatched collection: [{}]"
argument_list|,
name|coll
argument_list|,
name|e
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|ZooKeeperException
argument_list|(
name|ErrorCode
operator|.
name|SERVER_ERROR
argument_list|,
literal|"A ZK error has occurred"
argument_list|,
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|error
argument_list|(
literal|"Unwatched collection: [{}]"
argument_list|,
name|coll
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/** Watches the legacy clusterstate.json. */
DECL|class|LegacyClusterStateWatcher
class|class
name|LegacyClusterStateWatcher
implements|implements
name|Watcher
block|{
annotation|@
name|Override
DECL|method|process
specifier|public
name|void
name|process
parameter_list|(
name|WatchedEvent
name|event
parameter_list|)
block|{
comment|// session events are not change events, and do not remove the watcher
if|if
condition|(
name|EventType
operator|.
name|None
operator|.
name|equals
argument_list|(
name|event
operator|.
name|getType
argument_list|()
argument_list|)
condition|)
block|{
return|return;
block|}
name|int
name|liveNodesSize
init|=
name|ZkStateReader
operator|.
name|this
operator|.
name|clusterState
operator|==
literal|null
condition|?
literal|0
else|:
name|ZkStateReader
operator|.
name|this
operator|.
name|clusterState
operator|.
name|getLiveNodes
argument_list|()
operator|.
name|size
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"A cluster state change: [{}], has occurred - updating... (live nodes size: [{}])"
argument_list|,
name|event
argument_list|,
name|liveNodesSize
argument_list|)
expr_stmt|;
name|refreshAndWatch
argument_list|()
expr_stmt|;
synchronized|synchronized
init|(
name|getUpdateLock
argument_list|()
init|)
block|{
name|constructState
argument_list|()
expr_stmt|;
block|}
block|}
comment|/** Must hold {@link #getUpdateLock()} before calling this method. */
DECL|method|refreshAndWatch
specifier|public
name|void
name|refreshAndWatch
parameter_list|()
block|{
try|try
block|{
name|refreshLegacyClusterState
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|KeeperException
operator|.
name|NoNodeException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|SERVICE_UNAVAILABLE
argument_list|,
literal|"Cannot connect to cluster at "
operator|+
name|zkClient
operator|.
name|getZkServerAddress
argument_list|()
operator|+
literal|": cluster not found/not ready"
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|KeeperException
operator|.
name|SessionExpiredException
decl||
name|KeeperException
operator|.
name|ConnectionLossException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"ZooKeeper watch triggered, but Solr cannot talk to ZK: [{}]"
argument_list|,
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|KeeperException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"A ZK error has occurred"
argument_list|,
name|e
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|ZooKeeperException
argument_list|(
name|SolrException
operator|.
name|ErrorCode
operator|.
name|SERVER_ERROR
argument_list|,
literal|"A ZK error has occurred"
argument_list|,
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
comment|// Restore the interrupted status
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
literal|"Interrupted"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/** Watches /collections children . */
DECL|class|CollectionsChildWatcher
class|class
name|CollectionsChildWatcher
implements|implements
name|Watcher
block|{
annotation|@
name|Override
DECL|method|process
specifier|public
name|void
name|process
parameter_list|(
name|WatchedEvent
name|event
parameter_list|)
block|{
comment|// session events are not change events, and do not remove the watcher
if|if
condition|(
name|EventType
operator|.
name|None
operator|.
name|equals
argument_list|(
name|event
operator|.
name|getType
argument_list|()
argument_list|)
condition|)
block|{
return|return;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"A collections change: [{}], has occurred - updating..."
argument_list|,
name|event
argument_list|)
expr_stmt|;
name|refreshAndWatch
argument_list|()
expr_stmt|;
synchronized|synchronized
init|(
name|getUpdateLock
argument_list|()
init|)
block|{
name|constructState
argument_list|()
expr_stmt|;
block|}
block|}
comment|/** Must hold {@link #getUpdateLock()} before calling this method. */
DECL|method|refreshAndWatch
specifier|public
name|void
name|refreshAndWatch
parameter_list|()
block|{
try|try
block|{
name|refreshCollectionList
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|KeeperException
operator|.
name|SessionExpiredException
decl||
name|KeeperException
operator|.
name|ConnectionLossException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"ZooKeeper watch triggered, but Solr cannot talk to ZK: [{}]"
argument_list|,
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|KeeperException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"A ZK error has occurred"
argument_list|,
name|e
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|ZooKeeperException
argument_list|(
name|SolrException
operator|.
name|ErrorCode
operator|.
name|SERVER_ERROR
argument_list|,
literal|"A ZK error has occurred"
argument_list|,
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
comment|// Restore the interrupted status
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
literal|"Interrupted"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/** Watches the live_nodes and syncs changes. */
DECL|class|LiveNodeWatcher
class|class
name|LiveNodeWatcher
implements|implements
name|Watcher
block|{
annotation|@
name|Override
DECL|method|process
specifier|public
name|void
name|process
parameter_list|(
name|WatchedEvent
name|event
parameter_list|)
block|{
comment|// session events are not change events, and do not remove the watcher
if|if
condition|(
name|EventType
operator|.
name|None
operator|.
name|equals
argument_list|(
name|event
operator|.
name|getType
argument_list|()
argument_list|)
condition|)
block|{
return|return;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"A live node change: [{}], has occurred - updating... (live nodes size: [{}])"
argument_list|,
name|event
argument_list|,
name|liveNodes
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|refreshAndWatch
argument_list|()
expr_stmt|;
block|}
DECL|method|refreshAndWatch
specifier|public
name|void
name|refreshAndWatch
parameter_list|()
block|{
try|try
block|{
name|refreshLiveNodes
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|KeeperException
operator|.
name|SessionExpiredException
decl||
name|KeeperException
operator|.
name|ConnectionLossException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"ZooKeeper watch triggered, but Solr cannot talk to ZK: [{}]"
argument_list|,
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|KeeperException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"A ZK error has occurred"
argument_list|,
name|e
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|ZooKeeperException
argument_list|(
name|SolrException
operator|.
name|ErrorCode
operator|.
name|SERVER_ERROR
argument_list|,
literal|"A ZK error has occurred"
argument_list|,
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
comment|// Restore the interrupted status
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
literal|"Interrupted"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|getCollectionLive
specifier|public
specifier|static
name|DocCollection
name|getCollectionLive
parameter_list|(
name|ZkStateReader
name|zkStateReader
parameter_list|,
name|String
name|coll
parameter_list|)
block|{
try|try
block|{
return|return
name|zkStateReader
operator|.
name|fetchCollectionState
argument_list|(
name|coll
argument_list|,
literal|null
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|KeeperException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
literal|"Could not load collection from ZK: "
operator|+
name|coll
argument_list|,
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
throw|throw
operator|new
name|SolrException
argument_list|(
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
literal|"Could not load collection from ZK: "
operator|+
name|coll
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
DECL|method|fetchCollectionState
specifier|private
name|DocCollection
name|fetchCollectionState
parameter_list|(
name|String
name|coll
parameter_list|,
name|Watcher
name|watcher
parameter_list|)
throws|throws
name|KeeperException
throws|,
name|InterruptedException
block|{
name|String
name|collectionPath
init|=
name|getCollectionPath
argument_list|(
name|coll
argument_list|)
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
try|try
block|{
name|Stat
name|stat
init|=
operator|new
name|Stat
argument_list|()
decl_stmt|;
name|byte
index|[]
name|data
init|=
name|zkClient
operator|.
name|getData
argument_list|(
name|collectionPath
argument_list|,
name|watcher
argument_list|,
name|stat
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|ClusterState
name|state
init|=
name|ClusterState
operator|.
name|load
argument_list|(
name|stat
operator|.
name|getVersion
argument_list|()
argument_list|,
name|data
argument_list|,
name|Collections
operator|.
expr|<
name|String
operator|>
name|emptySet
argument_list|()
argument_list|,
name|collectionPath
argument_list|)
decl_stmt|;
name|ClusterState
operator|.
name|CollectionRef
name|collectionRef
init|=
name|state
operator|.
name|getCollectionStates
argument_list|()
operator|.
name|get
argument_list|(
name|coll
argument_list|)
decl_stmt|;
return|return
name|collectionRef
operator|==
literal|null
condition|?
literal|null
else|:
name|collectionRef
operator|.
name|get
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|KeeperException
operator|.
name|NoNodeException
name|e
parameter_list|)
block|{
if|if
condition|(
name|watcher
operator|!=
literal|null
condition|)
block|{
comment|// Leave an exists watch in place in case a state.json is created later.
name|Stat
name|exists
init|=
name|zkClient
operator|.
name|exists
argument_list|(
name|collectionPath
argument_list|,
name|watcher
argument_list|,
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
name|exists
operator|!=
literal|null
condition|)
block|{
comment|// Rare race condition, we tried to fetch the data and couldn't find it, then we found it exists.
comment|// Loop and try again.
continue|continue;
block|}
block|}
return|return
literal|null
return|;
block|}
block|}
block|}
DECL|method|getCollectionPath
specifier|public
specifier|static
name|String
name|getCollectionPath
parameter_list|(
name|String
name|coll
parameter_list|)
block|{
return|return
name|COLLECTIONS_ZKNODE
operator|+
literal|"/"
operator|+
name|coll
operator|+
literal|"/state.json"
return|;
block|}
comment|/**    * Notify this reader that a local Core is a member of a collection, and so that collection    * state should be watched.    *    * Not a public API.  This method should only be called from ZkController.    *    * The number of cores per-collection is tracked, and adding multiple cores from the same    * collection does not increase the number of watches.    *    * @param collection the collection that the core is a member of    *    * @see ZkStateReader#unregisterCore(String)    */
DECL|method|registerCore
specifier|public
name|void
name|registerCore
parameter_list|(
name|String
name|collection
parameter_list|)
block|{
name|AtomicBoolean
name|reconstructState
init|=
operator|new
name|AtomicBoolean
argument_list|(
literal|false
argument_list|)
decl_stmt|;
name|collectionWatches
operator|.
name|compute
argument_list|(
name|collection
argument_list|,
parameter_list|(
name|k
parameter_list|,
name|v
parameter_list|)
lambda|->
block|{
if|if
condition|(
name|v
operator|==
literal|null
condition|)
block|{
name|reconstructState
operator|.
name|set
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|v
operator|=
operator|new
name|CollectionWatch
argument_list|()
expr_stmt|;
block|}
name|v
operator|.
name|coreRefCount
operator|++
expr_stmt|;
return|return
name|v
return|;
block|}
argument_list|)
expr_stmt|;
if|if
condition|(
name|reconstructState
operator|.
name|get
argument_list|()
condition|)
block|{
operator|new
name|StateWatcher
argument_list|(
name|collection
argument_list|)
operator|.
name|refreshAndWatch
argument_list|()
expr_stmt|;
synchronized|synchronized
init|(
name|getUpdateLock
argument_list|()
init|)
block|{
name|constructState
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Notify this reader that a local core that is a member of a collection has been closed.    *    * Not a public API.  This method should only be called from ZkController.    *    * If no cores are registered for a collection, and there are no {@link CollectionStateWatcher}s    * for that collection either, the collection watch will be removed.    *    * @param collection the collection that the core belongs to    */
DECL|method|unregisterCore
specifier|public
name|void
name|unregisterCore
parameter_list|(
name|String
name|collection
parameter_list|)
block|{
name|AtomicBoolean
name|reconstructState
init|=
operator|new
name|AtomicBoolean
argument_list|(
literal|false
argument_list|)
decl_stmt|;
name|collectionWatches
operator|.
name|compute
argument_list|(
name|collection
argument_list|,
parameter_list|(
name|k
parameter_list|,
name|v
parameter_list|)
lambda|->
block|{
if|if
condition|(
name|v
operator|==
literal|null
condition|)
return|return
literal|null
return|;
if|if
condition|(
name|v
operator|.
name|coreRefCount
operator|>
literal|0
condition|)
name|v
operator|.
name|coreRefCount
operator|--
expr_stmt|;
if|if
condition|(
name|v
operator|.
name|canBeRemoved
argument_list|()
condition|)
block|{
name|watchedCollectionStates
operator|.
name|remove
argument_list|(
name|collection
argument_list|)
expr_stmt|;
name|lazyCollectionStates
operator|.
name|put
argument_list|(
name|collection
argument_list|,
operator|new
name|LazyCollectionRef
argument_list|(
name|collection
argument_list|)
argument_list|)
expr_stmt|;
name|reconstructState
operator|.
name|set
argument_list|(
literal|true
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
return|return
name|v
return|;
block|}
argument_list|)
expr_stmt|;
if|if
condition|(
name|reconstructState
operator|.
name|get
argument_list|()
condition|)
block|{
synchronized|synchronized
init|(
name|getUpdateLock
argument_list|()
init|)
block|{
name|constructState
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Register a CollectionStateWatcher to be called when the state of a collection changes    *    * A given CollectionStateWatcher will be only called once.  If you want to have a persistent watcher,    * it should register itself again in its {@link CollectionStateWatcher#onStateChanged(Set, DocCollection)}    * method.    */
DECL|method|registerCollectionStateWatcher
specifier|public
name|void
name|registerCollectionStateWatcher
parameter_list|(
name|String
name|collection
parameter_list|,
name|CollectionStateWatcher
name|stateWatcher
parameter_list|)
block|{
name|AtomicBoolean
name|watchSet
init|=
operator|new
name|AtomicBoolean
argument_list|(
literal|false
argument_list|)
decl_stmt|;
name|collectionWatches
operator|.
name|compute
argument_list|(
name|collection
argument_list|,
parameter_list|(
name|k
parameter_list|,
name|v
parameter_list|)
lambda|->
block|{
if|if
condition|(
name|v
operator|==
literal|null
condition|)
block|{
name|v
operator|=
operator|new
name|CollectionWatch
argument_list|()
expr_stmt|;
name|watchSet
operator|.
name|set
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
name|v
operator|.
name|stateWatchers
operator|.
name|add
argument_list|(
name|stateWatcher
argument_list|)
expr_stmt|;
return|return
name|v
return|;
block|}
argument_list|)
expr_stmt|;
if|if
condition|(
name|watchSet
operator|.
name|get
argument_list|()
condition|)
block|{
operator|new
name|StateWatcher
argument_list|(
name|collection
argument_list|)
operator|.
name|refreshAndWatch
argument_list|()
expr_stmt|;
synchronized|synchronized
init|(
name|getUpdateLock
argument_list|()
init|)
block|{
name|constructState
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Block until a CollectionStatePredicate returns true, or the wait times out    *    * Note that the predicate may be called again even after it has returned true, so    * implementors should avoid changing state within the predicate call itself.    *    * @param collection the collection to watch    * @param wait       how long to wait    * @param unit       the units of the wait parameter    * @param predicate  the predicate to call on state changes    * @throws InterruptedException on interrupt    * @throws TimeoutException on timeout    */
DECL|method|waitForState
specifier|public
name|void
name|waitForState
parameter_list|(
specifier|final
name|String
name|collection
parameter_list|,
name|long
name|wait
parameter_list|,
name|TimeUnit
name|unit
parameter_list|,
name|CollectionStatePredicate
name|predicate
parameter_list|)
throws|throws
name|InterruptedException
throws|,
name|TimeoutException
block|{
specifier|final
name|CountDownLatch
name|latch
init|=
operator|new
name|CountDownLatch
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|CollectionStateWatcher
name|watcher
init|=
operator|new
name|CollectionStateWatcher
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|onStateChanged
parameter_list|(
name|Set
argument_list|<
name|String
argument_list|>
name|liveNodes
parameter_list|,
name|DocCollection
name|collectionState
parameter_list|)
block|{
if|if
condition|(
name|predicate
operator|.
name|matches
argument_list|(
name|liveNodes
argument_list|,
name|collectionState
argument_list|)
condition|)
block|{
name|latch
operator|.
name|countDown
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|registerCollectionStateWatcher
argument_list|(
name|collection
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
block|}
block|}
decl_stmt|;
name|registerCollectionStateWatcher
argument_list|(
name|collection
argument_list|,
name|watcher
argument_list|)
expr_stmt|;
try|try
block|{
comment|// check the current state
name|DocCollection
name|dc
init|=
name|clusterState
operator|.
name|getCollectionOrNull
argument_list|(
name|collection
argument_list|)
decl_stmt|;
if|if
condition|(
name|predicate
operator|.
name|matches
argument_list|(
name|liveNodes
argument_list|,
name|dc
argument_list|)
condition|)
return|return;
comment|// wait for the watcher predicate to return true, or time out
if|if
condition|(
operator|!
name|latch
operator|.
name|await
argument_list|(
name|wait
argument_list|,
name|unit
argument_list|)
condition|)
throw|throw
operator|new
name|TimeoutException
argument_list|()
throw|;
block|}
finally|finally
block|{
name|removeCollectionStateWatcher
argument_list|(
name|collection
argument_list|,
name|watcher
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Remove a watcher from a collection's watch list.    *    * This allows Zookeeper watches to be removed if there is no interest in the    * collection.    *    * @param collection the collection    * @param watcher    the watcher    */
DECL|method|removeCollectionStateWatcher
specifier|public
name|void
name|removeCollectionStateWatcher
parameter_list|(
name|String
name|collection
parameter_list|,
name|CollectionStateWatcher
name|watcher
parameter_list|)
block|{
name|collectionWatches
operator|.
name|compute
argument_list|(
name|collection
argument_list|,
parameter_list|(
name|k
parameter_list|,
name|v
parameter_list|)
lambda|->
block|{
if|if
condition|(
name|v
operator|==
literal|null
condition|)
return|return
literal|null
return|;
name|v
operator|.
name|stateWatchers
operator|.
name|remove
argument_list|(
name|watcher
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|.
name|canBeRemoved
argument_list|()
condition|)
return|return
literal|null
return|;
return|return
name|v
return|;
block|}
argument_list|)
expr_stmt|;
block|}
comment|/* package-private for testing */
DECL|method|getStateWatchers
name|Set
argument_list|<
name|CollectionStateWatcher
argument_list|>
name|getStateWatchers
parameter_list|(
name|String
name|collection
parameter_list|)
block|{
name|CollectionWatch
name|watch
init|=
name|collectionWatches
operator|.
name|get
argument_list|(
name|collection
argument_list|)
decl_stmt|;
if|if
condition|(
name|watch
operator|==
literal|null
condition|)
return|return
literal|null
return|;
return|return
operator|new
name|HashSet
argument_list|<>
argument_list|(
name|watch
operator|.
name|stateWatchers
argument_list|)
return|;
block|}
comment|// returns true if the state has changed
DECL|method|updateWatchedCollection
specifier|private
name|void
name|updateWatchedCollection
parameter_list|(
name|String
name|coll
parameter_list|,
name|DocCollection
name|newState
parameter_list|)
block|{
name|Set
argument_list|<
name|String
argument_list|>
name|liveNodes
init|=
name|this
operator|.
name|liveNodes
decl_stmt|;
comment|// volatile read
if|if
condition|(
name|newState
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Deleting data for [{}]"
argument_list|,
name|coll
argument_list|)
expr_stmt|;
name|watchedCollectionStates
operator|.
name|remove
argument_list|(
name|coll
argument_list|)
expr_stmt|;
name|notifyStateWatchers
argument_list|(
name|liveNodes
argument_list|,
name|coll
argument_list|,
literal|null
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// CAS update loop
while|while
condition|(
literal|true
condition|)
block|{
if|if
condition|(
operator|!
name|collectionWatches
operator|.
name|containsKey
argument_list|(
name|coll
argument_list|)
condition|)
block|{
break|break;
block|}
name|DocCollection
name|oldState
init|=
name|watchedCollectionStates
operator|.
name|get
argument_list|(
name|coll
argument_list|)
decl_stmt|;
if|if
condition|(
name|oldState
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|watchedCollectionStates
operator|.
name|putIfAbsent
argument_list|(
name|coll
argument_list|,
name|newState
argument_list|)
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Add data for [{}] ver [{}]"
argument_list|,
name|coll
argument_list|,
name|newState
operator|.
name|getZNodeVersion
argument_list|()
argument_list|)
expr_stmt|;
name|notifyStateWatchers
argument_list|(
name|liveNodes
argument_list|,
name|coll
argument_list|,
name|newState
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
if|if
condition|(
name|oldState
operator|.
name|getZNodeVersion
argument_list|()
operator|>=
name|newState
operator|.
name|getZNodeVersion
argument_list|()
condition|)
block|{
comment|// Nothing to do, someone else updated same or newer.
break|break;
block|}
if|if
condition|(
name|watchedCollectionStates
operator|.
name|replace
argument_list|(
name|coll
argument_list|,
name|oldState
argument_list|,
name|newState
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Updating data for [{}] from [{}] to [{}]"
argument_list|,
name|coll
argument_list|,
name|oldState
operator|.
name|getZNodeVersion
argument_list|()
argument_list|,
name|newState
operator|.
name|getZNodeVersion
argument_list|()
argument_list|)
expr_stmt|;
name|notifyStateWatchers
argument_list|(
name|liveNodes
argument_list|,
name|coll
argument_list|,
name|newState
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|// Resolve race with unregisterCore.
if|if
condition|(
operator|!
name|collectionWatches
operator|.
name|containsKey
argument_list|(
name|coll
argument_list|)
condition|)
block|{
name|watchedCollectionStates
operator|.
name|remove
argument_list|(
name|coll
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Removing uninteresting collection [{}]"
argument_list|,
name|coll
argument_list|)
expr_stmt|;
block|}
block|}
DECL|class|ConfigData
specifier|public
specifier|static
class|class
name|ConfigData
block|{
DECL|field|data
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|data
decl_stmt|;
DECL|field|version
specifier|public
name|int
name|version
decl_stmt|;
DECL|method|ConfigData
specifier|public
name|ConfigData
parameter_list|()
block|{     }
DECL|method|ConfigData
specifier|public
name|ConfigData
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|data
parameter_list|,
name|int
name|version
parameter_list|)
block|{
name|this
operator|.
name|data
operator|=
name|data
expr_stmt|;
name|this
operator|.
name|version
operator|=
name|version
expr_stmt|;
block|}
block|}
DECL|method|notifyStateWatchers
specifier|private
name|void
name|notifyStateWatchers
parameter_list|(
name|Set
argument_list|<
name|String
argument_list|>
name|liveNodes
parameter_list|,
name|String
name|collection
parameter_list|,
name|DocCollection
name|collectionState
parameter_list|)
block|{
try|try
block|{
name|notifications
operator|.
name|submit
argument_list|(
operator|new
name|Notification
argument_list|(
name|liveNodes
argument_list|,
name|collection
argument_list|,
name|collectionState
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|RejectedExecutionException
name|e
parameter_list|)
block|{
if|if
condition|(
name|closed
operator|==
literal|false
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Couldn't run collection notifications for {}"
argument_list|,
name|collection
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|class|Notification
specifier|private
class|class
name|Notification
implements|implements
name|Runnable
block|{
DECL|field|liveNodes
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|liveNodes
decl_stmt|;
DECL|field|collection
specifier|final
name|String
name|collection
decl_stmt|;
DECL|field|collectionState
specifier|final
name|DocCollection
name|collectionState
decl_stmt|;
DECL|method|Notification
specifier|private
name|Notification
parameter_list|(
name|Set
argument_list|<
name|String
argument_list|>
name|liveNodes
parameter_list|,
name|String
name|collection
parameter_list|,
name|DocCollection
name|collectionState
parameter_list|)
block|{
name|this
operator|.
name|liveNodes
operator|=
name|liveNodes
expr_stmt|;
name|this
operator|.
name|collection
operator|=
name|collection
expr_stmt|;
name|this
operator|.
name|collectionState
operator|=
name|collectionState
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|run
specifier|public
name|void
name|run
parameter_list|()
block|{
name|List
argument_list|<
name|CollectionStateWatcher
argument_list|>
name|watchers
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|collectionWatches
operator|.
name|compute
argument_list|(
name|collection
argument_list|,
parameter_list|(
name|k
parameter_list|,
name|v
parameter_list|)
lambda|->
block|{
if|if
condition|(
name|v
operator|==
literal|null
condition|)
return|return
literal|null
return|;
name|watchers
operator|.
name|addAll
argument_list|(
name|v
operator|.
name|stateWatchers
argument_list|)
expr_stmt|;
name|v
operator|.
name|stateWatchers
operator|.
name|clear
argument_list|()
expr_stmt|;
return|return
name|v
return|;
block|}
argument_list|)
expr_stmt|;
for|for
control|(
name|CollectionStateWatcher
name|watcher
range|:
name|watchers
control|)
block|{
name|watcher
operator|.
name|onStateChanged
argument_list|(
name|liveNodes
argument_list|,
name|collectionState
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_class
end_unit
