begin_unit
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_package
DECL|package|org.apache.solr.common.util
package|package
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|util
package|;
end_package
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Reader
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|*
import|;
end_import
begin_import
import|import
name|org
operator|.
name|noggit
operator|.
name|JSONParser
import|;
end_import
begin_import
import|import static
name|org
operator|.
name|noggit
operator|.
name|JSONParser
operator|.
name|*
import|;
end_import
begin_comment
comment|/**  * A Streaming parser for json to emit one record at a time.  */
end_comment
begin_class
DECL|class|JsonRecordReader
specifier|public
class|class
name|JsonRecordReader
block|{
DECL|field|DELIM
specifier|public
specifier|static
specifier|final
name|String
name|DELIM
init|=
literal|"."
decl_stmt|;
DECL|field|rootNode
specifier|private
name|Node
name|rootNode
init|=
operator|new
name|Node
argument_list|(
literal|"/"
argument_list|,
operator|(
name|Node
operator|)
literal|null
argument_list|)
decl_stmt|;
DECL|method|getInst
specifier|public
specifier|static
name|JsonRecordReader
name|getInst
parameter_list|(
name|String
name|split
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|fieldMappings
parameter_list|)
block|{
name|JsonRecordReader
name|jsonRecordReader
init|=
operator|new
name|JsonRecordReader
argument_list|(
name|split
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|s
range|:
name|fieldMappings
control|)
block|{
name|String
name|path
init|=
name|s
decl_stmt|;
name|int
name|idx
init|=
name|s
operator|.
name|indexOf
argument_list|(
literal|':'
argument_list|)
decl_stmt|;
name|String
name|fieldName
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|idx
operator|>
literal|0
condition|)
block|{
name|fieldName
operator|=
name|s
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|idx
argument_list|)
expr_stmt|;
name|path
operator|=
name|s
operator|.
name|substring
argument_list|(
name|idx
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
name|jsonRecordReader
operator|.
name|addField
argument_list|(
name|path
argument_list|,
name|fieldName
argument_list|,
literal|true
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
return|return
name|jsonRecordReader
return|;
block|}
comment|/**    * A constructor called with a '|' separated list of path expressions    * which define sub sections of the JSON stream that are to be emitted as    * separate records.    *    * @param splitPath The PATH for which a record is emitted. Once the    *                  path tag is encountered, the Node.getInst method starts collecting wanted    *                  fields and at the close of the tag, a record is emitted containing all    *                  fields collected since the tag start. Once    *                  emitted the collected fields are cleared. Any fields collected in the    *                  parent tag or above will also be included in the record, but these are    *                  not cleared after emitting the record.    *<p>    *                  It uses the ' | ' syntax of PATH to pass in multiple paths.    */
DECL|method|JsonRecordReader
specifier|private
name|JsonRecordReader
parameter_list|(
name|String
name|splitPath
parameter_list|)
block|{
name|String
index|[]
name|splits
init|=
name|splitPath
operator|.
name|split
argument_list|(
literal|"\\|"
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|split
range|:
name|splits
control|)
block|{
name|split
operator|=
name|split
operator|.
name|trim
argument_list|()
expr_stmt|;
if|if
condition|(
name|split
operator|.
name|startsWith
argument_list|(
literal|"//"
argument_list|)
condition|)
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"split cannot start with '//': "
operator|+
name|split
argument_list|)
throw|;
if|if
condition|(
name|split
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
continue|continue;
comment|// The created Node has a name set to the full split attribute path
name|addField
argument_list|(
name|split
argument_list|,
name|split
argument_list|,
literal|false
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Splits the path into a List of segments and calls build() to    * construct a tree of Nodes representing path segments. The resulting    * tree structure ends up describing all the paths we are interested in.    *    * @param path        The path expression for this field    * @param fieldName   The name for this field in the emitted record    * @param multiValued If 'true' then the emitted record will have values in    *                    a List&lt;String&gt;    * @param isRecord    Flags that this PATH is from a forEach statement    */
DECL|method|addField
specifier|private
name|void
name|addField
parameter_list|(
name|String
name|path
parameter_list|,
name|String
name|fieldName
parameter_list|,
name|boolean
name|multiValued
parameter_list|,
name|boolean
name|isRecord
parameter_list|)
block|{
if|if
condition|(
operator|!
name|path
operator|.
name|startsWith
argument_list|(
literal|"/"
argument_list|)
condition|)
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"All paths must start with '/' "
operator|+
name|path
argument_list|)
throw|;
name|List
argument_list|<
name|String
argument_list|>
name|paths
init|=
name|splitEscapeQuote
argument_list|(
name|path
argument_list|)
decl_stmt|;
if|if
condition|(
name|paths
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|isRecord
condition|)
name|rootNode
operator|.
name|isRecord
operator|=
literal|true
expr_stmt|;
return|return;
comment|//the path is "/"
block|}
comment|// deal with how split behaves when separator starts with an empty string!
if|if
condition|(
literal|""
operator|.
name|equals
argument_list|(
name|paths
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|trim
argument_list|()
argument_list|)
condition|)
name|paths
operator|.
name|remove
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|rootNode
operator|.
name|build
argument_list|(
name|paths
argument_list|,
name|fieldName
argument_list|,
name|multiValued
argument_list|,
name|isRecord
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|rootNode
operator|.
name|buildOptimize
argument_list|()
expr_stmt|;
block|}
comment|/**    * Uses {@link #streamRecords streamRecords} to getInst the JSON source but with    * a handler that collects all the emitted records into a single List which    * is returned upon completion.    *    * @param r the stream reader    * @return results a List of emitted records    */
DECL|method|getAllRecords
specifier|public
name|List
argument_list|<
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
argument_list|>
name|getAllRecords
parameter_list|(
name|Reader
name|r
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|List
argument_list|<
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
argument_list|>
name|results
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|streamRecords
argument_list|(
name|r
argument_list|,
operator|new
name|Handler
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|handle
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|record
parameter_list|,
name|String
name|path
parameter_list|)
block|{
name|results
operator|.
name|add
argument_list|(
name|record
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
return|return
name|results
return|;
block|}
comment|/**    * Creates an JSONParser on top of whatever reader has been    * configured. Then calls getInst() with a handler which is    * invoked forEach record emitted.    *    * @param r       the stream reader    * @param handler The callback instance    */
DECL|method|streamRecords
specifier|public
name|void
name|streamRecords
parameter_list|(
name|Reader
name|r
parameter_list|,
name|Handler
name|handler
parameter_list|)
throws|throws
name|IOException
block|{
name|streamRecords
argument_list|(
operator|new
name|JSONParser
argument_list|(
name|r
argument_list|)
argument_list|,
name|handler
argument_list|)
expr_stmt|;
block|}
DECL|method|streamRecords
specifier|public
name|void
name|streamRecords
parameter_list|(
name|JSONParser
name|parser
parameter_list|,
name|Handler
name|handler
parameter_list|)
throws|throws
name|IOException
block|{
name|rootNode
operator|.
name|parse
argument_list|(
name|parser
argument_list|,
name|handler
argument_list|,
operator|new
name|LinkedHashMap
argument_list|<>
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * For each node/leaf in the Node tree there is one object of this class.    * This tree of objects represents all the Paths we are interested in.    * For each path segment of interest we create a node. In most cases the    * node (branch) is rather basic , but for the final portion (leaf) of any    * path we add more information to the Node. When parsing the JSON document    * we step though this tree as we stream records from the reader. If the JSON    * document departs from this tree we skip start tags till we are back on    * the tree.    */
DECL|class|Node
specifier|private
specifier|static
class|class
name|Node
block|{
DECL|field|name
name|String
name|name
decl_stmt|;
comment|// generally: segment of the path represented by this Node
DECL|field|fieldName
name|String
name|fieldName
decl_stmt|;
comment|// the fieldname in the emitted record (key of the map)
DECL|field|splitPath
name|String
name|splitPath
decl_stmt|;
comment|// the full path from the forEach entity attribute
DECL|field|childNodes
specifier|final
name|LinkedHashMap
argument_list|<
name|String
argument_list|,
name|Node
argument_list|>
name|childNodes
init|=
operator|new
name|LinkedHashMap
argument_list|<>
argument_list|()
decl_stmt|;
comment|// List of immediate child Nodes of this node
DECL|field|parent
name|Node
name|parent
decl_stmt|;
comment|// parent Node in the tree
DECL|field|isLeaf
name|boolean
name|isLeaf
init|=
literal|false
decl_stmt|;
comment|// flag: store/emit streamed text for this node
DECL|field|isRecord
name|boolean
name|isRecord
init|=
literal|false
decl_stmt|;
comment|//flag: this Node starts a new record
DECL|field|wildCardChild
name|Node
name|wildCardChild
decl_stmt|;
DECL|field|recursiveWildCardChild
name|Node
name|recursiveWildCardChild
decl_stmt|;
DECL|field|useFqn
specifier|private
name|boolean
name|useFqn
init|=
literal|false
decl_stmt|;
DECL|method|Node
specifier|public
name|Node
parameter_list|(
name|String
name|name
parameter_list|,
name|Node
name|p
parameter_list|)
block|{
comment|// Create a basic Node, suitable for the mid portions of any path.
comment|// Node.pathName and Node.name are set to same value.
name|this
operator|.
name|name
operator|=
name|name
expr_stmt|;
name|parent
operator|=
name|p
expr_stmt|;
block|}
DECL|method|Node
specifier|public
name|Node
parameter_list|(
name|String
name|name
parameter_list|,
name|String
name|fieldName
parameter_list|)
block|{
comment|// This is only called from build() when describing an attribute.
name|this
operator|.
name|name
operator|=
name|name
expr_stmt|;
comment|// a segment from the path
name|this
operator|.
name|fieldName
operator|=
name|fieldName
expr_stmt|;
comment|// name to store collected values against
block|}
comment|/**      * Walk the Node tree propagating any wild Descendant information to      * child nodes.      */
DECL|method|buildOptimize
specifier|private
name|void
name|buildOptimize
parameter_list|()
block|{
if|if
condition|(
name|parent
operator|!=
literal|null
operator|&&
name|parent
operator|.
name|recursiveWildCardChild
operator|!=
literal|null
operator|&&
name|this
operator|.
name|recursiveWildCardChild
operator|==
literal|null
condition|)
block|{
name|this
operator|.
name|recursiveWildCardChild
operator|=
name|parent
operator|.
name|recursiveWildCardChild
expr_stmt|;
block|}
for|for
control|(
name|Node
name|n
range|:
name|childNodes
operator|.
name|values
argument_list|()
control|)
name|n
operator|.
name|buildOptimize
argument_list|()
expr_stmt|;
block|}
DECL|field|WILDCARD_PATH
specifier|static
specifier|final
name|String
name|WILDCARD_PATH
init|=
literal|"*"
decl_stmt|;
DECL|field|RECURSIVE_WILDCARD_PATH
specifier|static
specifier|final
name|String
name|RECURSIVE_WILDCARD_PATH
init|=
literal|"**"
decl_stmt|;
comment|/**      * Build a Node tree structure representing all paths of interest to us.      * This must be done before parsing of the JSON stream starts. Each node      * holds one portion of an path. Taking each path segment in turn this      * method walks the Node tree  and finds where the new segment should be      * inserted. It creates a Node representing a field's name, PATH and      * some flags and inserts the Node into the Node tree.      */
DECL|method|build
specifier|private
name|void
name|build
parameter_list|(
name|List
argument_list|<
name|String
argument_list|>
name|paths
parameter_list|,
comment|// a List of segments from the split paths
name|String
name|fieldName
parameter_list|,
comment|// the fieldName assoc with this path
name|boolean
name|multiValued
parameter_list|,
comment|// flag if this fieldName is multiValued or not
name|boolean
name|record
parameter_list|,
comment|// is this path a record or a field
name|String
name|path
parameter_list|)
block|{
comment|// recursively walk the paths Lists adding new Nodes as required
name|String
name|segment
init|=
name|paths
operator|.
name|remove
argument_list|(
literal|0
argument_list|)
decl_stmt|;
comment|// shift out next path segment
if|if
condition|(
name|segment
operator|.
name|length
argument_list|()
operator|<
literal|1
condition|)
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"all pieces in path must be non empty "
operator|+
name|path
argument_list|)
throw|;
comment|// does this "name" already exist as a child node.
name|Node
name|n
init|=
name|getOrAddNode
argument_list|(
name|segment
argument_list|,
name|childNodes
argument_list|)
decl_stmt|;
if|if
condition|(
name|paths
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// We have emptied paths, we are for the moment a leaf of the tree.
comment|// When parsing the actual input we have traversed to a position
comment|// where we actually have to do something. getOrAddNode() will
comment|// have created and returned a new minimal Node with name and
comment|// pathName already populated. We need to add more information.
if|if
condition|(
name|record
condition|)
block|{
comment|//wild cards cannot be used in split
assert|assert
operator|!
name|WILDCARD_PATH
operator|.
name|equals
argument_list|(
name|n
operator|.
name|name
argument_list|)
assert|;
assert|assert
operator|!
name|RECURSIVE_WILDCARD_PATH
operator|.
name|equals
argument_list|(
name|n
operator|.
name|name
argument_list|)
assert|;
comment|// split attribute
name|n
operator|.
name|isRecord
operator|=
literal|true
expr_stmt|;
comment|// flag: split attribute, prepare to emit rec
name|n
operator|.
name|splitPath
operator|=
name|fieldName
expr_stmt|;
comment|// the full split attribute path
block|}
else|else
block|{
if|if
condition|(
name|n
operator|.
name|name
operator|.
name|equals
argument_list|(
name|WILDCARD_PATH
argument_list|)
condition|)
block|{
name|wildCardChild
operator|=
name|n
expr_stmt|;
block|}
if|if
condition|(
name|n
operator|.
name|name
operator|.
name|equals
argument_list|(
name|RECURSIVE_WILDCARD_PATH
argument_list|)
condition|)
block|{
name|recursiveWildCardChild
operator|=
name|n
operator|.
name|recursiveWildCardChild
operator|=
name|n
expr_stmt|;
block|}
comment|// path with content we want to store and return
name|n
operator|.
name|isLeaf
operator|=
literal|true
expr_stmt|;
comment|// we have to store text found here
name|n
operator|.
name|fieldName
operator|=
name|fieldName
expr_stmt|;
comment|// name to store collected text against
if|if
condition|(
literal|"$FQN"
operator|.
name|equals
argument_list|(
name|n
operator|.
name|fieldName
argument_list|)
condition|)
block|{
name|n
operator|.
name|fieldName
operator|=
literal|null
expr_stmt|;
name|n
operator|.
name|useFqn
operator|=
literal|true
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|//wildcards must only come at the end
if|if
condition|(
name|WILDCARD_PATH
operator|.
name|equals
argument_list|(
name|name
argument_list|)
operator|||
name|RECURSIVE_WILDCARD_PATH
operator|.
name|equals
argument_list|(
name|name
argument_list|)
condition|)
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"wild cards are allowed only in the end "
operator|+
name|path
argument_list|)
throw|;
comment|// recurse to handle next paths segment
name|n
operator|.
name|build
argument_list|(
name|paths
argument_list|,
name|fieldName
argument_list|,
name|multiValued
argument_list|,
name|record
argument_list|,
name|path
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|getOrAddNode
specifier|private
name|Node
name|getOrAddNode
parameter_list|(
name|String
name|pathName
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|Node
argument_list|>
name|children
parameter_list|)
block|{
name|Node
name|n
init|=
name|children
operator|.
name|get
argument_list|(
name|pathName
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
operator|!=
literal|null
condition|)
return|return
name|n
return|;
comment|// new territory! add a new node for this path bitty
name|children
operator|.
name|put
argument_list|(
name|pathName
argument_list|,
name|n
operator|=
operator|new
name|Node
argument_list|(
name|pathName
argument_list|,
name|this
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|n
return|;
block|}
comment|/**      * Copies a supplied Map to a new Map which is returned. Used to copy a      * records values. If a fields value is a List then they have to be      * deep-copied for thread safety      */
DECL|method|getDeepCopy
specifier|private
specifier|static
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|getDeepCopy
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|values
parameter_list|)
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|result
init|=
operator|new
name|LinkedHashMap
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|entry
range|:
name|values
operator|.
name|entrySet
argument_list|()
control|)
block|{
if|if
condition|(
name|entry
operator|.
name|getValue
argument_list|()
operator|instanceof
name|List
condition|)
block|{
name|result
operator|.
name|put
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
operator|new
name|ArrayList
argument_list|(
operator|(
name|List
operator|)
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|result
operator|.
name|put
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
DECL|method|parse
specifier|private
name|void
name|parse
parameter_list|(
name|JSONParser
name|parser
parameter_list|,
name|Handler
name|handler
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|values
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|event
init|=
operator|-
literal|1
decl_stmt|;
name|boolean
name|recordStarted
init|=
literal|false
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|event
operator|=
name|parser
operator|.
name|nextEvent
argument_list|()
expr_stmt|;
if|if
condition|(
name|event
operator|==
name|EOF
condition|)
break|break;
if|if
condition|(
name|event
operator|==
name|OBJECT_START
condition|)
block|{
name|handleObjectStart
argument_list|(
name|parser
argument_list|,
name|handler
argument_list|,
name|values
argument_list|,
operator|new
name|Stack
argument_list|<>
argument_list|()
argument_list|,
name|recordStarted
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|event
operator|==
name|ARRAY_START
condition|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
name|event
operator|=
name|parser
operator|.
name|nextEvent
argument_list|()
expr_stmt|;
if|if
condition|(
name|event
operator|==
name|ARRAY_END
condition|)
break|break;
if|if
condition|(
name|event
operator|==
name|OBJECT_START
condition|)
block|{
name|handleObjectStart
argument_list|(
name|parser
argument_list|,
name|handler
argument_list|,
name|values
argument_list|,
operator|new
name|Stack
argument_list|<>
argument_list|()
argument_list|,
name|recordStarted
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
comment|/**      * If a new tag is encountered, check if it is of interest or not by seeing      * if it matches against our node tree. If we have departed from the node      * tree then walk back though the tree's ancestor nodes checking to see if      * any // expressions exist for the node and compare them against the new      * tag. If matched then "jump" to that node, otherwise ignore the tag.      *<p>      * Note, the list of // expressions found while walking back up the tree      * is cached in the HashMap descendants. Then if the new tag is to be skipped,      * any inner child tags are compared against the cache and jumped to if      * matched.      */
DECL|method|handleObjectStart
specifier|private
name|void
name|handleObjectStart
parameter_list|(
specifier|final
name|JSONParser
name|parser
parameter_list|,
specifier|final
name|Handler
name|handler
parameter_list|,
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|values
parameter_list|,
specifier|final
name|Stack
argument_list|<
name|Set
argument_list|<
name|String
argument_list|>
argument_list|>
name|stack
parameter_list|,
name|boolean
name|recordStarted
parameter_list|,
name|MethodFrameWrapper
name|frameWrapper
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|boolean
name|isRecordStarted
init|=
name|recordStarted
operator|||
name|isRecord
decl_stmt|;
name|Set
argument_list|<
name|String
argument_list|>
name|valuesAddedinThisFrame
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|isRecord
operator|||
operator|!
name|recordStarted
condition|)
block|{
comment|// This Node is a match for an PATH from a forEach attribute,
comment|// prepare for the clean up that will occur when the record
comment|// is emitted after its END_ELEMENT is matched
name|valuesAddedinThisFrame
operator|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
expr_stmt|;
name|stack
operator|.
name|push
argument_list|(
name|valuesAddedinThisFrame
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|recordStarted
condition|)
block|{
comment|// This node is a child of some parent which matched against forEach
comment|// attribute. Continue to add values to an existing record.
name|valuesAddedinThisFrame
operator|=
name|stack
operator|.
name|peek
argument_list|()
expr_stmt|;
block|}
class|class
name|Wrapper
extends|extends
name|MethodFrameWrapper
block|{
name|Wrapper
parameter_list|(
name|Node
name|node
parameter_list|,
name|MethodFrameWrapper
name|parent
parameter_list|,
name|String
name|name
parameter_list|)
block|{
name|this
operator|.
name|node
operator|=
name|node
expr_stmt|;
name|this
operator|.
name|parent
operator|=
name|parent
expr_stmt|;
name|this
operator|.
name|name
operator|=
name|name
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|walk
parameter_list|(
name|int
name|event
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|event
operator|==
name|OBJECT_START
condition|)
block|{
name|node
operator|.
name|handleObjectStart
argument_list|(
name|parser
argument_list|,
name|handler
argument_list|,
name|values
argument_list|,
name|stack
argument_list|,
name|isRecordStarted
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|event
operator|==
name|ARRAY_START
condition|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
name|event
operator|=
name|parser
operator|.
name|nextEvent
argument_list|()
expr_stmt|;
if|if
condition|(
name|event
operator|==
name|ARRAY_END
condition|)
break|break;
if|if
condition|(
name|event
operator|==
name|OBJECT_START
condition|)
block|{
name|node
operator|.
name|handleObjectStart
argument_list|(
name|parser
argument_list|,
name|handler
argument_list|,
name|values
argument_list|,
name|stack
argument_list|,
name|isRecordStarted
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
try|try
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|event
init|=
name|parser
operator|.
name|nextEvent
argument_list|()
decl_stmt|;
if|if
condition|(
name|event
operator|==
name|OBJECT_END
condition|)
block|{
if|if
condition|(
name|isRecord
argument_list|()
condition|)
block|{
name|handler
operator|.
name|handle
argument_list|(
name|getDeepCopy
argument_list|(
name|values
argument_list|)
argument_list|,
name|splitPath
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
assert|assert
name|event
operator|==
name|STRING
assert|;
assert|assert
name|parser
operator|.
name|wasKey
argument_list|()
assert|;
name|String
name|name
init|=
name|parser
operator|.
name|getString
argument_list|()
decl_stmt|;
name|Node
name|node
init|=
name|childNodes
operator|.
name|get
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|node
operator|==
literal|null
condition|)
name|node
operator|=
name|wildCardChild
expr_stmt|;
if|if
condition|(
name|node
operator|==
literal|null
condition|)
name|node
operator|=
name|recursiveWildCardChild
expr_stmt|;
if|if
condition|(
name|node
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|node
operator|.
name|isLeaf
condition|)
block|{
comment|//this is a leaf collect data here
name|event
operator|=
name|parser
operator|.
name|nextEvent
argument_list|()
expr_stmt|;
name|String
name|nameInRecord
init|=
name|node
operator|.
name|fieldName
operator|==
literal|null
condition|?
name|getNameInRecord
argument_list|(
name|name
argument_list|,
name|frameWrapper
argument_list|,
name|node
argument_list|)
else|:
name|node
operator|.
name|fieldName
decl_stmt|;
name|MethodFrameWrapper
name|runnable
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|event
operator|==
name|OBJECT_START
operator|||
name|event
operator|==
name|ARRAY_START
condition|)
block|{
if|if
condition|(
name|node
operator|.
name|recursiveWildCardChild
operator|!=
literal|null
condition|)
name|runnable
operator|=
operator|new
name|Wrapper
argument_list|(
name|node
argument_list|,
name|frameWrapper
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
name|Object
name|val
init|=
name|parseSingleFieldValue
argument_list|(
name|event
argument_list|,
name|parser
argument_list|,
name|runnable
argument_list|)
decl_stmt|;
if|if
condition|(
name|val
operator|!=
literal|null
condition|)
block|{
name|putValue
argument_list|(
name|values
argument_list|,
name|nameInRecord
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|valuesAddedinThisFrame
operator|.
name|add
argument_list|(
name|nameInRecord
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|event
operator|=
name|parser
operator|.
name|nextEvent
argument_list|()
expr_stmt|;
operator|new
name|Wrapper
argument_list|(
name|node
argument_list|,
name|frameWrapper
argument_list|,
name|name
argument_list|)
operator|.
name|walk
argument_list|(
name|event
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|//this is not something we are interested in. Skip it
name|event
operator|=
name|parser
operator|.
name|nextEvent
argument_list|()
expr_stmt|;
if|if
condition|(
name|event
operator|==
name|STRING
operator|||
name|event
operator|==
name|LONG
operator|||
name|event
operator|==
name|NUMBER
operator|||
name|event
operator|==
name|BIGNUMBER
operator|||
name|event
operator|==
name|BOOLEAN
operator|||
name|event
operator|==
name|NULL
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|event
operator|==
name|ARRAY_START
condition|)
block|{
name|consumeTillMatchingEnd
argument_list|(
name|parser
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|event
operator|==
name|OBJECT_START
condition|)
block|{
name|consumeTillMatchingEnd
argument_list|(
name|parser
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
continue|continue;
block|}
else|else
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"unexpected token "
operator|+
name|event
argument_list|)
throw|;
block|}
block|}
block|}
finally|finally
block|{
if|if
condition|(
operator|(
name|isRecord
argument_list|()
operator|||
operator|!
name|isRecordStarted
operator|)
condition|)
block|{
for|for
control|(
name|String
name|fld
range|:
name|valuesAddedinThisFrame
control|)
block|{
name|values
operator|.
name|remove
argument_list|(
name|fld
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
DECL|method|getNameInRecord
specifier|private
name|String
name|getNameInRecord
parameter_list|(
name|String
name|name
parameter_list|,
name|MethodFrameWrapper
name|frameWrapper
parameter_list|,
name|Node
name|n
parameter_list|)
block|{
if|if
condition|(
name|frameWrapper
operator|==
literal|null
operator|||
operator|!
name|n
operator|.
name|useFqn
condition|)
return|return
name|name
return|;
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|frameWrapper
operator|.
name|prependName
argument_list|(
name|sb
argument_list|)
expr_stmt|;
return|return
name|sb
operator|.
name|append
argument_list|(
name|DELIM
argument_list|)
operator|.
name|append
argument_list|(
name|name
argument_list|)
operator|.
name|toString
argument_list|()
return|;
block|}
DECL|method|isRecord
specifier|private
name|boolean
name|isRecord
parameter_list|()
block|{
return|return
name|isRecord
return|;
block|}
DECL|method|putValue
specifier|private
name|void
name|putValue
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|values
parameter_list|,
name|String
name|fieldName
parameter_list|,
name|Object
name|o
parameter_list|)
block|{
if|if
condition|(
name|o
operator|==
literal|null
condition|)
return|return;
name|Object
name|val
init|=
name|values
operator|.
name|get
argument_list|(
name|fieldName
argument_list|)
decl_stmt|;
if|if
condition|(
name|val
operator|==
literal|null
condition|)
block|{
name|values
operator|.
name|put
argument_list|(
name|fieldName
argument_list|,
name|o
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|val
operator|instanceof
name|List
condition|)
block|{
name|List
name|list
init|=
operator|(
name|List
operator|)
name|val
decl_stmt|;
name|list
operator|.
name|add
argument_list|(
name|o
argument_list|)
expr_stmt|;
return|return;
block|}
name|ArrayList
name|l
init|=
operator|new
name|ArrayList
argument_list|()
decl_stmt|;
name|l
operator|.
name|add
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|l
operator|.
name|add
argument_list|(
name|o
argument_list|)
expr_stmt|;
name|values
operator|.
name|put
argument_list|(
name|fieldName
argument_list|,
name|l
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|name
return|;
block|}
block|}
comment|// end of class Node
comment|/**    * The path is split into segments using the '/' as a separator. However    * this method deals with special cases where there is a slash '/' character    * inside the attribute value e.g. x/@html='text/html'. We split by '/' but    * then reassemble things were the '/' appears within a quoted sub-string.    *<p>    * We have already enforced that the string must begin with a separator. This    * method depends heavily on how split behaves if the string starts with the    * seperator or if a sequence of multiple separators appear.    */
DECL|method|splitEscapeQuote
specifier|private
specifier|static
name|List
argument_list|<
name|String
argument_list|>
name|splitEscapeQuote
parameter_list|(
name|String
name|str
parameter_list|)
block|{
name|List
argument_list|<
name|String
argument_list|>
name|result
init|=
operator|new
name|LinkedList
argument_list|<>
argument_list|()
decl_stmt|;
name|String
index|[]
name|ss
init|=
name|str
operator|.
name|split
argument_list|(
literal|"/"
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ss
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
comment|// i=1: skip separator at start of string
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|int
name|quoteCount
init|=
literal|0
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|ss
index|[
name|i
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|ss
index|[
name|i
index|]
operator|.
name|length
argument_list|()
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|ss
index|[
name|i
index|]
operator|.
name|charAt
argument_list|(
name|j
argument_list|)
operator|==
literal|'\''
condition|)
name|quoteCount
operator|++
expr_stmt|;
comment|// have we got a split inside quoted sub-string?
if|if
condition|(
operator|(
name|quoteCount
operator|%
literal|2
operator|)
operator|==
literal|0
condition|)
break|break;
comment|// yes!; replace the '/' and loop to concat next token
name|i
operator|++
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"/"
argument_list|)
expr_stmt|;
block|}
name|result
operator|.
name|add
argument_list|(
name|sb
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
comment|/**    * Implement this interface to stream records as and when one is found.    */
DECL|interface|Handler
specifier|public
interface|interface
name|Handler
block|{
comment|/**      * @param record The record map. The key is the field name as provided in      *               the addField() methods. The value can be a single String (for single      *               valued fields) or a List&lt;String&gt; (for multiValued).      * @param path   The forEach path for which this record is being emitted      *               If there is any change all parsing will be aborted and the Exception      *               is propagated up      */
DECL|method|handle
name|void
name|handle
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|record
parameter_list|,
name|String
name|path
parameter_list|)
function_decl|;
block|}
DECL|method|parseSingleFieldValue
specifier|public
specifier|static
name|Object
name|parseSingleFieldValue
parameter_list|(
name|int
name|ev
parameter_list|,
name|JSONParser
name|parser
parameter_list|,
name|MethodFrameWrapper
name|runnable
parameter_list|)
throws|throws
name|IOException
block|{
switch|switch
condition|(
name|ev
condition|)
block|{
case|case
name|STRING
case|:
return|return
name|parser
operator|.
name|getString
argument_list|()
return|;
case|case
name|LONG
case|:
return|return
name|parser
operator|.
name|getLong
argument_list|()
return|;
case|case
name|NUMBER
case|:
return|return
name|parser
operator|.
name|getDouble
argument_list|()
return|;
case|case
name|BIGNUMBER
case|:
return|return
name|parser
operator|.
name|getNumberChars
argument_list|()
operator|.
name|toString
argument_list|()
return|;
case|case
name|BOOLEAN
case|:
return|return
name|parser
operator|.
name|getBoolean
argument_list|()
return|;
case|case
name|NULL
case|:
name|parser
operator|.
name|getNull
argument_list|()
expr_stmt|;
return|return
literal|null
return|;
case|case
name|ARRAY_START
case|:
return|return
name|parseArrayFieldValue
argument_list|(
name|ev
argument_list|,
name|parser
argument_list|,
name|runnable
argument_list|)
return|;
case|case
name|OBJECT_START
case|:
if|if
condition|(
name|runnable
operator|!=
literal|null
condition|)
block|{
name|runnable
operator|.
name|walk
argument_list|(
name|OBJECT_START
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
name|consumeTillMatchingEnd
argument_list|(
name|parser
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
default|default:
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Error parsing JSON field value. Unexpected "
operator|+
name|JSONParser
operator|.
name|getEventString
argument_list|(
name|ev
argument_list|)
argument_list|)
throw|;
block|}
block|}
DECL|class|MethodFrameWrapper
specifier|static
specifier|abstract
class|class
name|MethodFrameWrapper
block|{
DECL|field|node
name|Node
name|node
decl_stmt|;
DECL|field|parent
name|MethodFrameWrapper
name|parent
decl_stmt|;
DECL|field|name
name|String
name|name
decl_stmt|;
DECL|method|prependName
name|void
name|prependName
parameter_list|(
name|StringBuilder
name|sb
parameter_list|)
block|{
if|if
condition|(
name|parent
operator|!=
literal|null
condition|)
block|{
name|parent
operator|.
name|prependName
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|DELIM
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
DECL|method|walk
specifier|public
specifier|abstract
name|void
name|walk
parameter_list|(
name|int
name|event
parameter_list|)
throws|throws
name|IOException
function_decl|;
block|}
DECL|method|parseArrayFieldValue
specifier|public
specifier|static
name|List
argument_list|<
name|Object
argument_list|>
name|parseArrayFieldValue
parameter_list|(
name|int
name|ev
parameter_list|,
name|JSONParser
name|parser
parameter_list|,
name|MethodFrameWrapper
name|runnable
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|ev
operator|==
name|ARRAY_START
assert|;
name|ArrayList
name|lst
init|=
operator|new
name|ArrayList
argument_list|(
literal|2
argument_list|)
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|ev
operator|=
name|parser
operator|.
name|nextEvent
argument_list|()
expr_stmt|;
if|if
condition|(
name|ev
operator|==
name|ARRAY_END
condition|)
block|{
if|if
condition|(
name|lst
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
literal|null
return|;
return|return
name|lst
return|;
block|}
name|Object
name|val
init|=
name|parseSingleFieldValue
argument_list|(
name|ev
argument_list|,
name|parser
argument_list|,
name|runnable
argument_list|)
decl_stmt|;
if|if
condition|(
name|val
operator|!=
literal|null
condition|)
name|lst
operator|.
name|add
argument_list|(
name|val
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|consumeTillMatchingEnd
specifier|public
specifier|static
name|void
name|consumeTillMatchingEnd
parameter_list|(
name|JSONParser
name|parser
parameter_list|,
name|int
name|obj
parameter_list|,
name|int
name|arr
parameter_list|)
throws|throws
name|IOException
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|event
init|=
name|parser
operator|.
name|nextEvent
argument_list|()
decl_stmt|;
if|if
condition|(
name|event
operator|==
name|OBJECT_START
condition|)
name|obj
operator|++
expr_stmt|;
if|if
condition|(
name|event
operator|==
name|OBJECT_END
condition|)
name|obj
operator|--
expr_stmt|;
assert|assert
name|obj
operator|>=
literal|0
assert|;
if|if
condition|(
name|event
operator|==
name|ARRAY_START
condition|)
name|arr
operator|++
expr_stmt|;
if|if
condition|(
name|event
operator|==
name|ARRAY_END
condition|)
name|arr
operator|--
expr_stmt|;
assert|assert
name|arr
operator|>=
literal|0
assert|;
if|if
condition|(
name|obj
operator|==
literal|0
operator|&&
name|arr
operator|==
literal|0
condition|)
break|break;
block|}
block|}
block|}
end_class
end_unit
