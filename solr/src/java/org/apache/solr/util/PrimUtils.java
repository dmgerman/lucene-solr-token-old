begin_unit
begin_package
DECL|package|org.apache.solr.util
package|package
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|util
package|;
end_package
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_comment
comment|/** Utilities for primitive Java data types. */
end_comment
begin_class
DECL|class|PrimUtils
specifier|public
class|class
name|PrimUtils
block|{
DECL|class|IntComparator
specifier|public
specifier|static
specifier|abstract
class|class
name|IntComparator
block|{
DECL|method|compare
specifier|public
specifier|abstract
name|int
name|compare
parameter_list|(
name|int
name|a
parameter_list|,
name|int
name|b
parameter_list|)
function_decl|;
DECL|method|lessThan
specifier|public
name|boolean
name|lessThan
parameter_list|(
name|int
name|a
parameter_list|,
name|int
name|b
parameter_list|)
block|{
return|return
name|compare
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
operator|<
literal|0
return|;
block|}
DECL|method|equals
specifier|public
name|boolean
name|equals
parameter_list|(
name|int
name|a
parameter_list|,
name|int
name|b
parameter_list|)
block|{
return|return
name|compare
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
operator|==
literal|0
return|;
block|}
block|}
comment|/** Sort the integer array from "start" inclusive to "end" exclusive in ascending order,    *  using the provided comparator.    * TODO: is this an unstable sort?    */
DECL|method|sort
specifier|public
specifier|static
name|void
name|sort
parameter_list|(
name|int
name|start
parameter_list|,
name|int
name|end
parameter_list|,
name|int
index|[]
name|array
parameter_list|,
name|IntComparator
name|comparator
parameter_list|)
block|{
comment|// This code was copied from Apache Harmony's Arrays.sort(double[]) and modified
comment|// to use a comparator, in addition to other small efficiency enhancements
comment|// like replacing divisions with shifts.
name|int
name|temp
decl_stmt|;
name|int
name|length
init|=
name|end
operator|-
name|start
decl_stmt|;
if|if
condition|(
name|length
operator|<
literal|7
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
name|start
operator|+
literal|1
init|;
name|i
operator|<
name|end
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|int
name|j
init|=
name|i
init|;
name|j
operator|>
name|start
operator|&&
name|comparator
operator|.
name|lessThan
argument_list|(
name|array
index|[
name|j
index|]
argument_list|,
name|array
index|[
name|j
operator|-
literal|1
index|]
argument_list|)
condition|;
name|j
operator|--
control|)
block|{
name|temp
operator|=
name|array
index|[
name|j
index|]
expr_stmt|;
name|array
index|[
name|j
index|]
operator|=
name|array
index|[
name|j
operator|-
literal|1
index|]
expr_stmt|;
name|array
index|[
name|j
operator|-
literal|1
index|]
operator|=
name|temp
expr_stmt|;
block|}
block|}
return|return;
block|}
name|int
name|middle
init|=
operator|(
name|start
operator|+
name|end
operator|)
operator|>>>
literal|1
decl_stmt|;
if|if
condition|(
name|length
operator|>
literal|7
condition|)
block|{
name|int
name|bottom
init|=
name|start
decl_stmt|;
name|int
name|top
init|=
name|end
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|length
operator|>
literal|40
condition|)
block|{
name|length
operator|>>=
literal|3
expr_stmt|;
name|bottom
operator|=
name|med3
argument_list|(
name|array
argument_list|,
name|bottom
argument_list|,
name|bottom
operator|+
name|length
argument_list|,
name|bottom
operator|+
operator|(
name|length
operator|<<
literal|1
operator|)
argument_list|,
name|comparator
argument_list|)
expr_stmt|;
name|middle
operator|=
name|med3
argument_list|(
name|array
argument_list|,
name|middle
operator|-
name|length
argument_list|,
name|middle
argument_list|,
name|middle
operator|+
name|length
argument_list|,
name|comparator
argument_list|)
expr_stmt|;
name|top
operator|=
name|med3
argument_list|(
name|array
argument_list|,
name|top
operator|-
operator|(
name|length
operator|<<
literal|1
operator|)
argument_list|,
name|top
operator|-
name|length
argument_list|,
name|top
argument_list|,
name|comparator
argument_list|)
expr_stmt|;
block|}
name|middle
operator|=
name|med3
argument_list|(
name|array
argument_list|,
name|bottom
argument_list|,
name|middle
argument_list|,
name|top
argument_list|,
name|comparator
argument_list|)
expr_stmt|;
block|}
name|int
name|partionValue
init|=
name|array
index|[
name|middle
index|]
decl_stmt|;
name|int
name|a
decl_stmt|,
name|b
decl_stmt|,
name|c
decl_stmt|,
name|d
decl_stmt|;
name|a
operator|=
name|b
operator|=
name|start
expr_stmt|;
name|c
operator|=
name|d
operator|=
name|end
operator|-
literal|1
expr_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
while|while
condition|(
name|b
operator|<=
name|c
operator|&&
operator|!
name|comparator
operator|.
name|lessThan
argument_list|(
name|partionValue
argument_list|,
name|array
index|[
name|b
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
name|comparator
operator|.
name|equals
argument_list|(
name|array
index|[
name|b
index|]
argument_list|,
name|partionValue
argument_list|)
condition|)
block|{
name|temp
operator|=
name|array
index|[
name|a
index|]
expr_stmt|;
name|array
index|[
name|a
operator|++
index|]
operator|=
name|array
index|[
name|b
index|]
expr_stmt|;
name|array
index|[
name|b
index|]
operator|=
name|temp
expr_stmt|;
block|}
name|b
operator|++
expr_stmt|;
block|}
while|while
condition|(
name|c
operator|>=
name|b
operator|&&
operator|!
name|comparator
operator|.
name|lessThan
argument_list|(
name|array
index|[
name|c
index|]
argument_list|,
name|partionValue
argument_list|)
condition|)
block|{
if|if
condition|(
name|comparator
operator|.
name|equals
argument_list|(
name|array
index|[
name|c
index|]
argument_list|,
name|partionValue
argument_list|)
condition|)
block|{
name|temp
operator|=
name|array
index|[
name|c
index|]
expr_stmt|;
name|array
index|[
name|c
index|]
operator|=
name|array
index|[
name|d
index|]
expr_stmt|;
name|array
index|[
name|d
operator|--
index|]
operator|=
name|temp
expr_stmt|;
block|}
name|c
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|b
operator|>
name|c
condition|)
block|{
break|break;
block|}
name|temp
operator|=
name|array
index|[
name|b
index|]
expr_stmt|;
name|array
index|[
name|b
operator|++
index|]
operator|=
name|array
index|[
name|c
index|]
expr_stmt|;
name|array
index|[
name|c
operator|--
index|]
operator|=
name|temp
expr_stmt|;
block|}
name|length
operator|=
name|a
operator|-
name|start
operator|<
name|b
operator|-
name|a
condition|?
name|a
operator|-
name|start
else|:
name|b
operator|-
name|a
expr_stmt|;
name|int
name|l
init|=
name|start
decl_stmt|;
name|int
name|h
init|=
name|b
operator|-
name|length
decl_stmt|;
while|while
condition|(
name|length
operator|--
operator|>
literal|0
condition|)
block|{
name|temp
operator|=
name|array
index|[
name|l
index|]
expr_stmt|;
name|array
index|[
name|l
operator|++
index|]
operator|=
name|array
index|[
name|h
index|]
expr_stmt|;
name|array
index|[
name|h
operator|++
index|]
operator|=
name|temp
expr_stmt|;
block|}
name|length
operator|=
name|d
operator|-
name|c
operator|<
name|end
operator|-
literal|1
operator|-
name|d
condition|?
name|d
operator|-
name|c
else|:
name|end
operator|-
literal|1
operator|-
name|d
expr_stmt|;
name|l
operator|=
name|b
expr_stmt|;
name|h
operator|=
name|end
operator|-
name|length
expr_stmt|;
while|while
condition|(
name|length
operator|--
operator|>
literal|0
condition|)
block|{
name|temp
operator|=
name|array
index|[
name|l
index|]
expr_stmt|;
name|array
index|[
name|l
operator|++
index|]
operator|=
name|array
index|[
name|h
index|]
expr_stmt|;
name|array
index|[
name|h
operator|++
index|]
operator|=
name|temp
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|length
operator|=
name|b
operator|-
name|a
operator|)
operator|>
literal|0
condition|)
block|{
name|sort
argument_list|(
name|start
argument_list|,
name|start
operator|+
name|length
argument_list|,
name|array
argument_list|,
name|comparator
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|length
operator|=
name|d
operator|-
name|c
operator|)
operator|>
literal|0
condition|)
block|{
name|sort
argument_list|(
name|end
operator|-
name|length
argument_list|,
name|end
argument_list|,
name|array
argument_list|,
name|comparator
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|med3
specifier|private
specifier|static
name|int
name|med3
parameter_list|(
name|int
index|[]
name|array
parameter_list|,
name|int
name|a
parameter_list|,
name|int
name|b
parameter_list|,
name|int
name|c
parameter_list|,
name|IntComparator
name|comparator
parameter_list|)
block|{
name|int
name|x
init|=
name|array
index|[
name|a
index|]
decl_stmt|,
name|y
init|=
name|array
index|[
name|b
index|]
decl_stmt|,
name|z
init|=
name|array
index|[
name|c
index|]
decl_stmt|;
return|return
name|comparator
operator|.
name|lessThan
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
condition|?
operator|(
name|comparator
operator|.
name|lessThan
argument_list|(
name|y
argument_list|,
name|z
argument_list|)
condition|?
name|b
else|:
operator|(
name|comparator
operator|.
name|lessThan
argument_list|(
name|x
argument_list|,
name|z
argument_list|)
condition|?
name|c
else|:
name|a
operator|)
operator|)
else|:
operator|(
name|comparator
operator|.
name|lessThan
argument_list|(
name|z
argument_list|,
name|y
argument_list|)
condition|?
name|b
else|:
operator|(
name|comparator
operator|.
name|lessThan
argument_list|(
name|z
argument_list|,
name|x
argument_list|)
condition|?
name|c
else|:
name|a
operator|)
operator|)
return|;
block|}
block|}
end_class
end_unit
