begin_unit
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_package
DECL|package|org.apache.solr.search
package|package
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|search
package|;
end_package
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|document
operator|.
name|Document
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|document
operator|.
name|FieldSelector
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|document
operator|.
name|FieldSelectorResult
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|*
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|IndexReader
operator|.
name|AtomicReaderContext
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|*
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|Directory
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|FSDirectory
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|Bits
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|BytesRef
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|OpenBitSet
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|util
operator|.
name|NamedList
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|util
operator|.
name|SimpleOrderedMap
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|core
operator|.
name|SolrConfig
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|core
operator|.
name|SolrCore
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|core
operator|.
name|SolrInfoMBean
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|request
operator|.
name|UnInvertedField
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|schema
operator|.
name|IndexSchema
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|schema
operator|.
name|SchemaField
import|;
end_import
begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import
begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URL
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|*
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicLong
import|;
end_import
begin_comment
comment|/**  * SolrIndexSearcher adds schema awareness and caching functionality  * over the lucene IndexSearcher.  *  * @version $Id$  * @since solr 0.9  */
end_comment
begin_class
DECL|class|SolrIndexSearcher
specifier|public
class|class
name|SolrIndexSearcher
extends|extends
name|IndexSearcher
implements|implements
name|SolrInfoMBean
block|{
comment|// These should *only* be used for debugging or monitoring purposes
DECL|field|numOpens
specifier|public
specifier|static
specifier|final
name|AtomicLong
name|numOpens
init|=
operator|new
name|AtomicLong
argument_list|()
decl_stmt|;
DECL|field|numCloses
specifier|public
specifier|static
specifier|final
name|AtomicLong
name|numCloses
init|=
operator|new
name|AtomicLong
argument_list|()
decl_stmt|;
DECL|field|log
specifier|private
specifier|static
name|Logger
name|log
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|SolrIndexSearcher
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|core
specifier|private
specifier|final
name|SolrCore
name|core
decl_stmt|;
DECL|field|schema
specifier|private
specifier|final
name|IndexSchema
name|schema
decl_stmt|;
DECL|field|indexDir
specifier|private
name|String
name|indexDir
decl_stmt|;
DECL|field|name
specifier|private
specifier|final
name|String
name|name
decl_stmt|;
DECL|field|openTime
specifier|private
name|long
name|openTime
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
DECL|field|registerTime
specifier|private
name|long
name|registerTime
init|=
literal|0
decl_stmt|;
DECL|field|warmupTime
specifier|private
name|long
name|warmupTime
init|=
literal|0
decl_stmt|;
DECL|field|reader
specifier|private
specifier|final
name|IndexReader
name|reader
decl_stmt|;
DECL|field|closeReader
specifier|private
specifier|final
name|boolean
name|closeReader
decl_stmt|;
DECL|field|queryResultWindowSize
specifier|private
specifier|final
name|int
name|queryResultWindowSize
decl_stmt|;
DECL|field|queryResultMaxDocsCached
specifier|private
specifier|final
name|int
name|queryResultMaxDocsCached
decl_stmt|;
DECL|field|useFilterForSortedQuery
specifier|private
specifier|final
name|boolean
name|useFilterForSortedQuery
decl_stmt|;
DECL|field|enableLazyFieldLoading
specifier|public
specifier|final
name|boolean
name|enableLazyFieldLoading
decl_stmt|;
DECL|field|cachingEnabled
specifier|private
specifier|final
name|boolean
name|cachingEnabled
decl_stmt|;
DECL|field|filterCache
specifier|private
specifier|final
name|SolrCache
argument_list|<
name|Query
argument_list|,
name|DocSet
argument_list|>
name|filterCache
decl_stmt|;
DECL|field|queryResultCache
specifier|private
specifier|final
name|SolrCache
argument_list|<
name|QueryResultKey
argument_list|,
name|DocList
argument_list|>
name|queryResultCache
decl_stmt|;
DECL|field|documentCache
specifier|private
specifier|final
name|SolrCache
argument_list|<
name|Integer
argument_list|,
name|Document
argument_list|>
name|documentCache
decl_stmt|;
DECL|field|fieldValueCache
specifier|private
specifier|final
name|SolrCache
argument_list|<
name|String
argument_list|,
name|UnInvertedField
argument_list|>
name|fieldValueCache
decl_stmt|;
DECL|field|optimizer
specifier|private
specifier|final
name|LuceneQueryOptimizer
name|optimizer
decl_stmt|;
comment|// map of generic caches - not synchronized since it's read-only after the constructor.
DECL|field|cacheMap
specifier|private
specifier|final
name|HashMap
argument_list|<
name|String
argument_list|,
name|SolrCache
argument_list|>
name|cacheMap
decl_stmt|;
DECL|field|noGenericCaches
specifier|private
specifier|static
specifier|final
name|HashMap
argument_list|<
name|String
argument_list|,
name|SolrCache
argument_list|>
name|noGenericCaches
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|SolrCache
argument_list|>
argument_list|(
literal|0
argument_list|)
decl_stmt|;
comment|// list of all caches associated with this searcher.
DECL|field|cacheList
specifier|private
specifier|final
name|SolrCache
index|[]
name|cacheList
decl_stmt|;
DECL|field|noCaches
specifier|private
specifier|static
specifier|final
name|SolrCache
index|[]
name|noCaches
init|=
operator|new
name|SolrCache
index|[
literal|0
index|]
decl_stmt|;
DECL|field|fieldNames
specifier|private
specifier|final
name|Collection
argument_list|<
name|String
argument_list|>
name|fieldNames
decl_stmt|;
DECL|field|storedHighlightFieldNames
specifier|private
name|Collection
argument_list|<
name|String
argument_list|>
name|storedHighlightFieldNames
decl_stmt|;
comment|/*    * Creates a searcher searching the index in the provided directory. Note:    * uses the main IndexReaderFactory for the specified SolrCore.    *     * @see SolrCore#getMainIndexReaderFactory    */
DECL|method|SolrIndexSearcher
specifier|public
name|SolrIndexSearcher
parameter_list|(
name|SolrCore
name|core
parameter_list|,
name|IndexSchema
name|schema
parameter_list|,
name|String
name|name
parameter_list|,
name|Directory
name|directory
parameter_list|,
name|boolean
name|enableCache
parameter_list|)
throws|throws
name|IOException
block|{
name|this
argument_list|(
name|core
argument_list|,
name|schema
argument_list|,
name|name
argument_list|,
name|core
operator|.
name|getIndexReaderFactory
argument_list|()
operator|.
name|newReader
argument_list|(
name|directory
argument_list|,
literal|false
argument_list|)
argument_list|,
literal|true
argument_list|,
name|enableCache
argument_list|)
expr_stmt|;
block|}
comment|/** Creates a searcher searching the index in the provided directory. */
DECL|method|SolrIndexSearcher
specifier|public
name|SolrIndexSearcher
parameter_list|(
name|SolrCore
name|core
parameter_list|,
name|IndexSchema
name|schema
parameter_list|,
name|String
name|name
parameter_list|,
name|Directory
name|directory
parameter_list|,
name|boolean
name|readOnly
parameter_list|,
name|boolean
name|enableCache
parameter_list|)
throws|throws
name|IOException
block|{
name|this
argument_list|(
name|core
argument_list|,
name|schema
argument_list|,
name|name
argument_list|,
name|core
operator|.
name|getIndexReaderFactory
argument_list|()
operator|.
name|newReader
argument_list|(
name|directory
argument_list|,
name|readOnly
argument_list|)
argument_list|,
literal|true
argument_list|,
name|enableCache
argument_list|)
expr_stmt|;
block|}
comment|/** Creates a searcher searching the provided index. */
DECL|method|SolrIndexSearcher
specifier|public
name|SolrIndexSearcher
parameter_list|(
name|SolrCore
name|core
parameter_list|,
name|IndexSchema
name|schema
parameter_list|,
name|String
name|name
parameter_list|,
name|IndexReader
name|r
parameter_list|,
name|boolean
name|enableCache
parameter_list|)
block|{
name|this
argument_list|(
name|core
argument_list|,
name|schema
argument_list|,
name|name
argument_list|,
name|r
argument_list|,
literal|false
argument_list|,
name|enableCache
argument_list|)
expr_stmt|;
block|}
DECL|method|SolrIndexSearcher
specifier|public
name|SolrIndexSearcher
parameter_list|(
name|SolrCore
name|core
parameter_list|,
name|IndexSchema
name|schema
parameter_list|,
name|String
name|name
parameter_list|,
name|IndexReader
name|r
parameter_list|,
name|boolean
name|closeReader
parameter_list|,
name|boolean
name|enableCache
parameter_list|)
block|{
name|super
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|this
operator|.
name|reader
operator|=
name|getIndexReader
argument_list|()
expr_stmt|;
name|this
operator|.
name|core
operator|=
name|core
expr_stmt|;
name|this
operator|.
name|schema
operator|=
name|schema
expr_stmt|;
name|this
operator|.
name|name
operator|=
literal|"Searcher@"
operator|+
name|Integer
operator|.
name|toHexString
argument_list|(
name|hashCode
argument_list|()
argument_list|)
operator|+
operator|(
name|name
operator|!=
literal|null
condition|?
literal|" "
operator|+
name|name
else|:
literal|""
operator|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Opening "
operator|+
name|this
operator|.
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|.
name|directory
argument_list|()
operator|instanceof
name|FSDirectory
condition|)
block|{
name|FSDirectory
name|fsDirectory
init|=
operator|(
name|FSDirectory
operator|)
name|r
operator|.
name|directory
argument_list|()
decl_stmt|;
name|indexDir
operator|=
name|fsDirectory
operator|.
name|getDirectory
argument_list|()
operator|.
name|getAbsolutePath
argument_list|()
expr_stmt|;
block|}
name|this
operator|.
name|closeReader
operator|=
name|closeReader
expr_stmt|;
name|setSimilarityProvider
argument_list|(
name|schema
operator|.
name|getSimilarityProvider
argument_list|()
argument_list|)
expr_stmt|;
name|SolrConfig
name|solrConfig
init|=
name|core
operator|.
name|getSolrConfig
argument_list|()
decl_stmt|;
name|queryResultWindowSize
operator|=
name|solrConfig
operator|.
name|queryResultWindowSize
expr_stmt|;
name|queryResultMaxDocsCached
operator|=
name|solrConfig
operator|.
name|queryResultMaxDocsCached
expr_stmt|;
name|useFilterForSortedQuery
operator|=
name|solrConfig
operator|.
name|useFilterForSortedQuery
expr_stmt|;
name|enableLazyFieldLoading
operator|=
name|solrConfig
operator|.
name|enableLazyFieldLoading
expr_stmt|;
name|cachingEnabled
operator|=
name|enableCache
expr_stmt|;
if|if
condition|(
name|cachingEnabled
condition|)
block|{
name|ArrayList
argument_list|<
name|SolrCache
argument_list|>
name|clist
init|=
operator|new
name|ArrayList
argument_list|<
name|SolrCache
argument_list|>
argument_list|()
decl_stmt|;
name|fieldValueCache
operator|=
name|solrConfig
operator|.
name|fieldValueCacheConfig
operator|==
literal|null
condition|?
literal|null
else|:
name|solrConfig
operator|.
name|fieldValueCacheConfig
operator|.
name|newInstance
argument_list|()
expr_stmt|;
if|if
condition|(
name|fieldValueCache
operator|!=
literal|null
condition|)
name|clist
operator|.
name|add
argument_list|(
name|fieldValueCache
argument_list|)
expr_stmt|;
name|filterCache
operator|=
name|solrConfig
operator|.
name|filterCacheConfig
operator|==
literal|null
condition|?
literal|null
else|:
name|solrConfig
operator|.
name|filterCacheConfig
operator|.
name|newInstance
argument_list|()
expr_stmt|;
if|if
condition|(
name|filterCache
operator|!=
literal|null
condition|)
name|clist
operator|.
name|add
argument_list|(
name|filterCache
argument_list|)
expr_stmt|;
name|queryResultCache
operator|=
name|solrConfig
operator|.
name|queryResultCacheConfig
operator|==
literal|null
condition|?
literal|null
else|:
name|solrConfig
operator|.
name|queryResultCacheConfig
operator|.
name|newInstance
argument_list|()
expr_stmt|;
if|if
condition|(
name|queryResultCache
operator|!=
literal|null
condition|)
name|clist
operator|.
name|add
argument_list|(
name|queryResultCache
argument_list|)
expr_stmt|;
name|documentCache
operator|=
name|solrConfig
operator|.
name|documentCacheConfig
operator|==
literal|null
condition|?
literal|null
else|:
name|solrConfig
operator|.
name|documentCacheConfig
operator|.
name|newInstance
argument_list|()
expr_stmt|;
if|if
condition|(
name|documentCache
operator|!=
literal|null
condition|)
name|clist
operator|.
name|add
argument_list|(
name|documentCache
argument_list|)
expr_stmt|;
if|if
condition|(
name|solrConfig
operator|.
name|userCacheConfigs
operator|==
literal|null
condition|)
block|{
name|cacheMap
operator|=
name|noGenericCaches
expr_stmt|;
block|}
else|else
block|{
name|cacheMap
operator|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|SolrCache
argument_list|>
argument_list|(
name|solrConfig
operator|.
name|userCacheConfigs
operator|.
name|length
argument_list|)
expr_stmt|;
for|for
control|(
name|CacheConfig
name|userCacheConfig
range|:
name|solrConfig
operator|.
name|userCacheConfigs
control|)
block|{
name|SolrCache
name|cache
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|userCacheConfig
operator|!=
literal|null
condition|)
name|cache
operator|=
name|userCacheConfig
operator|.
name|newInstance
argument_list|()
expr_stmt|;
if|if
condition|(
name|cache
operator|!=
literal|null
condition|)
block|{
name|cacheMap
operator|.
name|put
argument_list|(
name|cache
operator|.
name|name
argument_list|()
argument_list|,
name|cache
argument_list|)
expr_stmt|;
name|clist
operator|.
name|add
argument_list|(
name|cache
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|cacheList
operator|=
name|clist
operator|.
name|toArray
argument_list|(
operator|new
name|SolrCache
index|[
name|clist
operator|.
name|size
argument_list|()
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|filterCache
operator|=
literal|null
expr_stmt|;
name|queryResultCache
operator|=
literal|null
expr_stmt|;
name|documentCache
operator|=
literal|null
expr_stmt|;
name|fieldValueCache
operator|=
literal|null
expr_stmt|;
name|cacheMap
operator|=
name|noGenericCaches
expr_stmt|;
name|cacheList
operator|=
name|noCaches
expr_stmt|;
block|}
name|optimizer
operator|=
name|solrConfig
operator|.
name|filtOptEnabled
condition|?
operator|new
name|LuceneQueryOptimizer
argument_list|(
name|solrConfig
operator|.
name|filtOptCacheSize
argument_list|,
name|solrConfig
operator|.
name|filtOptThreshold
argument_list|)
else|:
literal|null
expr_stmt|;
name|fieldNames
operator|=
name|r
operator|.
name|getFieldNames
argument_list|(
name|IndexReader
operator|.
name|FieldOption
operator|.
name|ALL
argument_list|)
expr_stmt|;
comment|// do this at the end since an exception in the constructor means we won't close
name|numOpens
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|name
return|;
block|}
comment|/** Register sub-objects such as caches    */
DECL|method|register
specifier|public
name|void
name|register
parameter_list|()
block|{
comment|// register self
name|core
operator|.
name|getInfoRegistry
argument_list|()
operator|.
name|put
argument_list|(
literal|"searcher"
argument_list|,
name|this
argument_list|)
expr_stmt|;
name|core
operator|.
name|getInfoRegistry
argument_list|()
operator|.
name|put
argument_list|(
name|name
argument_list|,
name|this
argument_list|)
expr_stmt|;
for|for
control|(
name|SolrCache
name|cache
range|:
name|cacheList
control|)
block|{
name|cache
operator|.
name|setState
argument_list|(
name|SolrCache
operator|.
name|State
operator|.
name|LIVE
argument_list|)
expr_stmt|;
name|core
operator|.
name|getInfoRegistry
argument_list|()
operator|.
name|put
argument_list|(
name|cache
operator|.
name|name
argument_list|()
argument_list|,
name|cache
argument_list|)
expr_stmt|;
block|}
name|registerTime
operator|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
expr_stmt|;
block|}
comment|/**    * Free's resources associated with this searcher.    *    * In particular, the underlying reader and any cache's in use are closed.    */
annotation|@
name|Override
DECL|method|close
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|cachingEnabled
condition|)
block|{
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"Closing "
argument_list|)
operator|.
name|append
argument_list|(
name|name
argument_list|)
expr_stmt|;
for|for
control|(
name|SolrCache
name|cache
range|:
name|cacheList
control|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|"\n\t"
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|cache
argument_list|)
expr_stmt|;
block|}
name|log
operator|.
name|info
argument_list|(
name|sb
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"Closing "
operator|+
name|name
argument_list|)
expr_stmt|;
block|}
name|core
operator|.
name|getInfoRegistry
argument_list|()
operator|.
name|remove
argument_list|(
name|name
argument_list|)
expr_stmt|;
comment|// super.close();
comment|// can't use super.close() since it just calls reader.close() and that may only be called once
comment|// per reader (even if incRef() was previously called).
if|if
condition|(
name|closeReader
condition|)
name|reader
operator|.
name|decRef
argument_list|()
expr_stmt|;
for|for
control|(
name|SolrCache
name|cache
range|:
name|cacheList
control|)
block|{
name|cache
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
comment|// do this at the end so it only gets done if there are no exceptions
name|numCloses
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
block|}
comment|/** Direct access to the IndexSchema for use with this searcher */
DECL|method|getSchema
specifier|public
name|IndexSchema
name|getSchema
parameter_list|()
block|{
return|return
name|schema
return|;
block|}
comment|/**    * Returns a collection of all field names the index reader knows about.    */
DECL|method|getFieldNames
specifier|public
name|Collection
argument_list|<
name|String
argument_list|>
name|getFieldNames
parameter_list|()
block|{
return|return
name|fieldNames
return|;
block|}
comment|/**    * Returns a collection of the names of all stored fields which can be    * highlighted the index reader knows about.    */
DECL|method|getStoredHighlightFieldNames
specifier|public
name|Collection
argument_list|<
name|String
argument_list|>
name|getStoredHighlightFieldNames
parameter_list|()
block|{
if|if
condition|(
name|storedHighlightFieldNames
operator|==
literal|null
condition|)
block|{
name|storedHighlightFieldNames
operator|=
operator|new
name|LinkedList
argument_list|<
name|String
argument_list|>
argument_list|()
expr_stmt|;
for|for
control|(
name|String
name|fieldName
range|:
name|fieldNames
control|)
block|{
try|try
block|{
name|SchemaField
name|field
init|=
name|schema
operator|.
name|getField
argument_list|(
name|fieldName
argument_list|)
decl_stmt|;
if|if
condition|(
name|field
operator|.
name|stored
argument_list|()
operator|&&
operator|(
operator|(
name|field
operator|.
name|getType
argument_list|()
operator|instanceof
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|schema
operator|.
name|TextField
operator|)
operator|||
operator|(
name|field
operator|.
name|getType
argument_list|()
operator|instanceof
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|schema
operator|.
name|StrField
operator|)
operator|)
condition|)
block|{
name|storedHighlightFieldNames
operator|.
name|add
argument_list|(
name|fieldName
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|RuntimeException
name|e
parameter_list|)
block|{
comment|// getField() throws a SolrException, but it arrives as a RuntimeException
name|log
operator|.
name|warn
argument_list|(
literal|"Field \""
operator|+
name|fieldName
operator|+
literal|"\" found in index, but not defined in schema."
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|storedHighlightFieldNames
return|;
block|}
comment|//
comment|// Set default regenerators on filter and query caches if they don't have any
comment|//
DECL|method|initRegenerators
specifier|public
specifier|static
name|void
name|initRegenerators
parameter_list|(
name|SolrConfig
name|solrConfig
parameter_list|)
block|{
if|if
condition|(
name|solrConfig
operator|.
name|fieldValueCacheConfig
operator|!=
literal|null
operator|&&
name|solrConfig
operator|.
name|fieldValueCacheConfig
operator|.
name|getRegenerator
argument_list|()
operator|==
literal|null
condition|)
block|{
name|solrConfig
operator|.
name|fieldValueCacheConfig
operator|.
name|setRegenerator
argument_list|(
operator|new
name|CacheRegenerator
argument_list|()
block|{
specifier|public
name|boolean
name|regenerateItem
parameter_list|(
name|SolrIndexSearcher
name|newSearcher
parameter_list|,
name|SolrCache
name|newCache
parameter_list|,
name|SolrCache
name|oldCache
parameter_list|,
name|Object
name|oldKey
parameter_list|,
name|Object
name|oldVal
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|oldVal
operator|instanceof
name|UnInvertedField
condition|)
block|{
name|UnInvertedField
operator|.
name|getUnInvertedField
argument_list|(
operator|(
name|String
operator|)
name|oldKey
argument_list|,
name|newSearcher
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|solrConfig
operator|.
name|filterCacheConfig
operator|!=
literal|null
operator|&&
name|solrConfig
operator|.
name|filterCacheConfig
operator|.
name|getRegenerator
argument_list|()
operator|==
literal|null
condition|)
block|{
name|solrConfig
operator|.
name|filterCacheConfig
operator|.
name|setRegenerator
argument_list|(
operator|new
name|CacheRegenerator
argument_list|()
block|{
specifier|public
name|boolean
name|regenerateItem
parameter_list|(
name|SolrIndexSearcher
name|newSearcher
parameter_list|,
name|SolrCache
name|newCache
parameter_list|,
name|SolrCache
name|oldCache
parameter_list|,
name|Object
name|oldKey
parameter_list|,
name|Object
name|oldVal
parameter_list|)
throws|throws
name|IOException
block|{
name|newSearcher
operator|.
name|cacheDocSet
argument_list|(
operator|(
name|Query
operator|)
name|oldKey
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|solrConfig
operator|.
name|queryResultCacheConfig
operator|!=
literal|null
operator|&&
name|solrConfig
operator|.
name|queryResultCacheConfig
operator|.
name|getRegenerator
argument_list|()
operator|==
literal|null
condition|)
block|{
specifier|final
name|int
name|queryResultWindowSize
init|=
name|solrConfig
operator|.
name|queryResultWindowSize
decl_stmt|;
name|solrConfig
operator|.
name|queryResultCacheConfig
operator|.
name|setRegenerator
argument_list|(
operator|new
name|CacheRegenerator
argument_list|()
block|{
specifier|public
name|boolean
name|regenerateItem
parameter_list|(
name|SolrIndexSearcher
name|newSearcher
parameter_list|,
name|SolrCache
name|newCache
parameter_list|,
name|SolrCache
name|oldCache
parameter_list|,
name|Object
name|oldKey
parameter_list|,
name|Object
name|oldVal
parameter_list|)
throws|throws
name|IOException
block|{
name|QueryResultKey
name|key
init|=
operator|(
name|QueryResultKey
operator|)
name|oldKey
decl_stmt|;
name|int
name|nDocs
init|=
literal|1
decl_stmt|;
comment|// request 1 doc and let caching round up to the next window size...
comment|// unless the window size is<=1, in which case we will pick
comment|// the minimum of the number of documents requested last time and
comment|// a reasonable number such as 40.
comment|// TODO: make more configurable later...
if|if
condition|(
name|queryResultWindowSize
operator|<=
literal|1
condition|)
block|{
name|DocList
name|oldList
init|=
operator|(
name|DocList
operator|)
name|oldVal
decl_stmt|;
name|int
name|oldnDocs
init|=
name|oldList
operator|.
name|offset
argument_list|()
operator|+
name|oldList
operator|.
name|size
argument_list|()
decl_stmt|;
comment|// 40 has factors of 2,4,5,10,20
name|nDocs
operator|=
name|Math
operator|.
name|min
argument_list|(
name|oldnDocs
argument_list|,
literal|40
argument_list|)
expr_stmt|;
block|}
name|int
name|flags
init|=
name|NO_CHECK_QCACHE
operator||
name|key
operator|.
name|nc_flags
decl_stmt|;
name|QueryCommand
name|qc
init|=
operator|new
name|QueryCommand
argument_list|()
decl_stmt|;
name|qc
operator|.
name|setQuery
argument_list|(
name|key
operator|.
name|query
argument_list|)
operator|.
name|setFilterList
argument_list|(
name|key
operator|.
name|filters
argument_list|)
operator|.
name|setSort
argument_list|(
name|key
operator|.
name|sort
argument_list|)
operator|.
name|setLen
argument_list|(
name|nDocs
argument_list|)
operator|.
name|setSupersetMaxDoc
argument_list|(
name|nDocs
argument_list|)
operator|.
name|setFlags
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|QueryResult
name|qr
init|=
operator|new
name|QueryResult
argument_list|()
decl_stmt|;
name|newSearcher
operator|.
name|getDocListC
argument_list|(
name|qr
argument_list|,
name|qc
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|search
specifier|public
name|QueryResult
name|search
parameter_list|(
name|QueryResult
name|qr
parameter_list|,
name|QueryCommand
name|cmd
parameter_list|)
throws|throws
name|IOException
block|{
name|getDocListC
argument_list|(
name|qr
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
return|return
name|qr
return|;
block|}
comment|//  public Hits search(Query query, Filter filter, Sort sort) throws IOException {
comment|//    // todo - when Solr starts accepting filters, need to
comment|//    // change this conditional check (filter!=null) and create a new filter
comment|//    // that ANDs them together if it already exists.
comment|//
comment|//    if (optimizer==null || filter!=null || !(query instanceof BooleanQuery)
comment|//    ) {
comment|//      return super.search(query,filter,sort);
comment|//    } else {
comment|//      Query[] newQuery = new Query[1];
comment|//      Filter[] newFilter = new Filter[1];
comment|//      optimizer.optimize((BooleanQuery)query, this, 0, newQuery, newFilter);
comment|//
comment|//      return super.search(newQuery[0], newFilter[0], sort);
comment|//    }
comment|//  }
comment|/**    * @return the indexDir on which this searcher is opened    * @see #SolrIndexSearcher(SolrCore, IndexSchema, String, Directory, boolean)    */
DECL|method|getIndexDir
specifier|public
name|String
name|getIndexDir
parameter_list|()
block|{
return|return
name|indexDir
return|;
block|}
comment|/* ********************** Document retrieval *************************/
comment|/* Future optimizations (yonik)    *    * If no cache is present:    *   - use NO_LOAD instead of LAZY_LOAD    *   - use LOAD_AND_BREAK if a single field is begin retrieved    */
comment|/**    * FieldSelector which loads the specified fields, and load all other    * field lazily.    */
DECL|class|SetNonLazyFieldSelector
specifier|static
class|class
name|SetNonLazyFieldSelector
implements|implements
name|FieldSelector
block|{
DECL|field|fieldsToLoad
specifier|private
name|Set
argument_list|<
name|String
argument_list|>
name|fieldsToLoad
decl_stmt|;
DECL|method|SetNonLazyFieldSelector
name|SetNonLazyFieldSelector
parameter_list|(
name|Set
argument_list|<
name|String
argument_list|>
name|toLoad
parameter_list|)
block|{
name|fieldsToLoad
operator|=
name|toLoad
expr_stmt|;
block|}
DECL|method|accept
specifier|public
name|FieldSelectorResult
name|accept
parameter_list|(
name|String
name|fieldName
parameter_list|)
block|{
if|if
condition|(
name|fieldsToLoad
operator|.
name|contains
argument_list|(
name|fieldName
argument_list|)
condition|)
return|return
name|FieldSelectorResult
operator|.
name|LOAD
return|;
else|else
return|return
name|FieldSelectorResult
operator|.
name|LAZY_LOAD
return|;
block|}
block|}
comment|/**    * Retrieve the {@link Document} instance corresponding to the document id.    */
annotation|@
name|Override
DECL|method|doc
specifier|public
name|Document
name|doc
parameter_list|(
name|int
name|i
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|doc
argument_list|(
name|i
argument_list|,
operator|(
name|Set
argument_list|<
name|String
argument_list|>
operator|)
literal|null
argument_list|)
return|;
block|}
comment|/** Retrieve a {@link Document} using a {@link org.apache.lucene.document.FieldSelector}    * This method does not currently use the Solr document cache.    *     * @see IndexReader#document(int, FieldSelector) */
annotation|@
name|Override
DECL|method|doc
specifier|public
name|Document
name|doc
parameter_list|(
name|int
name|n
parameter_list|,
name|FieldSelector
name|fieldSelector
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|getIndexReader
argument_list|()
operator|.
name|document
argument_list|(
name|n
argument_list|,
name|fieldSelector
argument_list|)
return|;
block|}
comment|/**    * Retrieve the {@link Document} instance corresponding to the document id.    *    * Note: The document will have all fields accessable, but if a field    * filter is provided, only the provided fields will be loaded (the     * remainder will be available lazily).    */
DECL|method|doc
specifier|public
name|Document
name|doc
parameter_list|(
name|int
name|i
parameter_list|,
name|Set
argument_list|<
name|String
argument_list|>
name|fields
parameter_list|)
throws|throws
name|IOException
block|{
name|Document
name|d
decl_stmt|;
if|if
condition|(
name|documentCache
operator|!=
literal|null
condition|)
block|{
name|d
operator|=
name|documentCache
operator|.
name|get
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|!=
literal|null
condition|)
return|return
name|d
return|;
block|}
if|if
condition|(
operator|!
name|enableLazyFieldLoading
operator|||
name|fields
operator|==
literal|null
condition|)
block|{
name|d
operator|=
name|getIndexReader
argument_list|()
operator|.
name|document
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|d
operator|=
name|getIndexReader
argument_list|()
operator|.
name|document
argument_list|(
name|i
argument_list|,
operator|new
name|SetNonLazyFieldSelector
argument_list|(
name|fields
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|documentCache
operator|!=
literal|null
condition|)
block|{
name|documentCache
operator|.
name|put
argument_list|(
name|i
argument_list|,
name|d
argument_list|)
expr_stmt|;
block|}
return|return
name|d
return|;
block|}
comment|/**    * Takes a list of docs (the doc ids actually), and reads them into an array     * of Documents.    */
DECL|method|readDocs
specifier|public
name|void
name|readDocs
parameter_list|(
name|Document
index|[]
name|docs
parameter_list|,
name|DocList
name|ids
parameter_list|)
throws|throws
name|IOException
block|{
name|readDocs
argument_list|(
name|docs
argument_list|,
name|ids
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/**    * Takes a list of docs (the doc ids actually) and a set of fields to load,    * and reads them into an array of Documents.    */
DECL|method|readDocs
specifier|public
name|void
name|readDocs
parameter_list|(
name|Document
index|[]
name|docs
parameter_list|,
name|DocList
name|ids
parameter_list|,
name|Set
argument_list|<
name|String
argument_list|>
name|fields
parameter_list|)
throws|throws
name|IOException
block|{
name|DocIterator
name|iter
init|=
name|ids
operator|.
name|iterator
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|docs
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|docs
index|[
name|i
index|]
operator|=
name|doc
argument_list|(
name|iter
operator|.
name|nextDoc
argument_list|()
argument_list|,
name|fields
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* ********************** end document retrieval *************************/
comment|////////////////////////////////////////////////////////////////////////////////
comment|////////////////////////////////////////////////////////////////////////////////
comment|////////////////////////////////////////////////////////////////////////////////
comment|/** expert: internal API, subject to change */
DECL|method|getFieldValueCache
specifier|public
name|SolrCache
argument_list|<
name|String
argument_list|,
name|UnInvertedField
argument_list|>
name|getFieldValueCache
parameter_list|()
block|{
return|return
name|fieldValueCache
return|;
block|}
comment|/** Returns a weighted sort according to this searcher */
DECL|method|weightSort
specifier|public
name|Sort
name|weightSort
parameter_list|(
name|Sort
name|sort
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|sort
operator|==
literal|null
condition|)
return|return
literal|null
return|;
name|SortField
index|[]
name|sorts
init|=
name|sort
operator|.
name|getSort
argument_list|()
decl_stmt|;
name|boolean
name|needsWeighting
init|=
literal|false
decl_stmt|;
for|for
control|(
name|SortField
name|sf
range|:
name|sorts
control|)
block|{
if|if
condition|(
name|sf
operator|instanceof
name|SolrSortField
condition|)
block|{
name|needsWeighting
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|needsWeighting
condition|)
return|return
name|sort
return|;
name|SortField
index|[]
name|newSorts
init|=
name|Arrays
operator|.
name|copyOf
argument_list|(
name|sorts
argument_list|,
name|sorts
operator|.
name|length
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|newSorts
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|newSorts
index|[
name|i
index|]
operator|instanceof
name|SolrSortField
condition|)
block|{
name|newSorts
index|[
name|i
index|]
operator|=
operator|(
operator|(
name|SolrSortField
operator|)
name|newSorts
index|[
name|i
index|]
operator|)
operator|.
name|weight
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|new
name|Sort
argument_list|(
name|newSorts
argument_list|)
return|;
block|}
comment|/**    * Returns the first document number containing the term<code>t</code>    * Returns -1 if no document was found.    * This method is primarily intended for clients that want to fetch    * documents using a unique identifier."    * @param t    * @return the first document number containing the term    */
DECL|method|getFirstMatch
specifier|public
name|int
name|getFirstMatch
parameter_list|(
name|Term
name|t
parameter_list|)
throws|throws
name|IOException
block|{
name|Fields
name|fields
init|=
name|MultiFields
operator|.
name|getFields
argument_list|(
name|reader
argument_list|)
decl_stmt|;
if|if
condition|(
name|fields
operator|==
literal|null
condition|)
return|return
operator|-
literal|1
return|;
name|Terms
name|terms
init|=
name|fields
operator|.
name|terms
argument_list|(
name|t
operator|.
name|field
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|terms
operator|==
literal|null
condition|)
return|return
operator|-
literal|1
return|;
name|BytesRef
name|termBytes
init|=
name|t
operator|.
name|bytes
argument_list|()
decl_stmt|;
name|DocsEnum
name|docs
init|=
name|terms
operator|.
name|docs
argument_list|(
name|MultiFields
operator|.
name|getDeletedDocs
argument_list|(
name|reader
argument_list|)
argument_list|,
name|termBytes
argument_list|,
literal|null
argument_list|)
decl_stmt|;
if|if
condition|(
name|docs
operator|==
literal|null
condition|)
return|return
operator|-
literal|1
return|;
name|int
name|id
init|=
name|docs
operator|.
name|nextDoc
argument_list|()
decl_stmt|;
return|return
name|id
operator|==
name|DocIdSetIterator
operator|.
name|NO_MORE_DOCS
condition|?
operator|-
literal|1
else|:
name|id
return|;
block|}
comment|/**    * Compute and cache the DocSet that matches a query.    * The normal usage is expected to be cacheDocSet(myQuery, null,false)    * meaning that Solr will determine if the Query warrants caching, and    * if so, will compute the DocSet that matches the Query and cache it.    * If the answer to the query is already cached, nothing further will be done.    *<p>    * If the optionalAnswer DocSet is provided, it should *not* be modified    * after this call.    *    * @param query           the lucene query that will act as the key    * @param optionalAnswer   the DocSet to be cached - if null, it will be computed.    * @param mustCache        if true, a best effort will be made to cache this entry.    *                         if false, heuristics may be used to determine if it should be cached.    */
DECL|method|cacheDocSet
specifier|public
name|void
name|cacheDocSet
parameter_list|(
name|Query
name|query
parameter_list|,
name|DocSet
name|optionalAnswer
parameter_list|,
name|boolean
name|mustCache
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Even if the cache is null, still compute the DocSet as it may serve to warm the Lucene
comment|// or OS disk cache.
if|if
condition|(
name|optionalAnswer
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|filterCache
operator|!=
literal|null
condition|)
block|{
name|filterCache
operator|.
name|put
argument_list|(
name|query
argument_list|,
name|optionalAnswer
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
comment|// Throw away the result, relying on the fact that getDocSet
comment|// will currently always cache what it found.  If getDocSet() starts
comment|// using heuristics about what to cache, and mustCache==true, (or if we
comment|// want this method to start using heuristics too) then
comment|// this needs to change.
name|getDocSet
argument_list|(
name|query
argument_list|)
expr_stmt|;
block|}
comment|/**    * Returns the set of document ids matching a query.    * This method is cache-aware and attempts to retrieve the answer from the cache if possible.    * If the answer was not cached, it may have been inserted into the cache as a result of this call.    * This method can handle negative queries.    *<p>    * The DocSet returned should<b>not</b> be modified.    */
DECL|method|getDocSet
specifier|public
name|DocSet
name|getDocSet
parameter_list|(
name|Query
name|query
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Get the absolute value (positive version) of this query.  If we
comment|// get back the same reference, we know it's positive.
name|Query
name|absQ
init|=
name|QueryUtils
operator|.
name|getAbs
argument_list|(
name|query
argument_list|)
decl_stmt|;
name|boolean
name|positive
init|=
name|query
operator|==
name|absQ
decl_stmt|;
if|if
condition|(
name|filterCache
operator|!=
literal|null
condition|)
block|{
name|DocSet
name|absAnswer
init|=
name|filterCache
operator|.
name|get
argument_list|(
name|absQ
argument_list|)
decl_stmt|;
if|if
condition|(
name|absAnswer
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|positive
condition|)
return|return
name|absAnswer
return|;
else|else
return|return
name|getPositiveDocSet
argument_list|(
name|matchAllDocsQuery
argument_list|)
operator|.
name|andNot
argument_list|(
name|absAnswer
argument_list|)
return|;
block|}
block|}
name|DocSet
name|absAnswer
init|=
name|getDocSetNC
argument_list|(
name|absQ
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|DocSet
name|answer
init|=
name|positive
condition|?
name|absAnswer
else|:
name|getPositiveDocSet
argument_list|(
name|matchAllDocsQuery
argument_list|)
operator|.
name|andNot
argument_list|(
name|absAnswer
argument_list|)
decl_stmt|;
if|if
condition|(
name|filterCache
operator|!=
literal|null
condition|)
block|{
comment|// cache negative queries as positive
name|filterCache
operator|.
name|put
argument_list|(
name|absQ
argument_list|,
name|absAnswer
argument_list|)
expr_stmt|;
block|}
return|return
name|answer
return|;
block|}
comment|/** lucene.internal */
DECL|method|getDocSet
specifier|public
name|DocSet
name|getDocSet
parameter_list|(
name|Query
name|query
parameter_list|,
name|DocsEnumState
name|deState
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Get the absolute value (positive version) of this query.  If we
comment|// get back the same reference, we know it's positive.
name|Query
name|absQ
init|=
name|QueryUtils
operator|.
name|getAbs
argument_list|(
name|query
argument_list|)
decl_stmt|;
name|boolean
name|positive
init|=
name|query
operator|==
name|absQ
decl_stmt|;
if|if
condition|(
name|filterCache
operator|!=
literal|null
condition|)
block|{
name|DocSet
name|absAnswer
init|=
name|filterCache
operator|.
name|get
argument_list|(
name|absQ
argument_list|)
decl_stmt|;
if|if
condition|(
name|absAnswer
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|positive
condition|)
return|return
name|absAnswer
return|;
else|else
return|return
name|getPositiveDocSet
argument_list|(
name|matchAllDocsQuery
argument_list|)
operator|.
name|andNot
argument_list|(
name|absAnswer
argument_list|)
return|;
block|}
block|}
name|DocSet
name|absAnswer
init|=
name|getDocSetNC
argument_list|(
name|absQ
argument_list|,
literal|null
argument_list|,
name|deState
argument_list|)
decl_stmt|;
name|DocSet
name|answer
init|=
name|positive
condition|?
name|absAnswer
else|:
name|getPositiveDocSet
argument_list|(
name|matchAllDocsQuery
argument_list|,
name|deState
argument_list|)
operator|.
name|andNot
argument_list|(
name|absAnswer
argument_list|)
decl_stmt|;
if|if
condition|(
name|filterCache
operator|!=
literal|null
condition|)
block|{
comment|// cache negative queries as positive
name|filterCache
operator|.
name|put
argument_list|(
name|absQ
argument_list|,
name|absAnswer
argument_list|)
expr_stmt|;
block|}
return|return
name|answer
return|;
block|}
comment|// only handle positive (non negative) queries
DECL|method|getPositiveDocSet
name|DocSet
name|getPositiveDocSet
parameter_list|(
name|Query
name|q
parameter_list|)
throws|throws
name|IOException
block|{
name|DocSet
name|answer
decl_stmt|;
if|if
condition|(
name|filterCache
operator|!=
literal|null
condition|)
block|{
name|answer
operator|=
name|filterCache
operator|.
name|get
argument_list|(
name|q
argument_list|)
expr_stmt|;
if|if
condition|(
name|answer
operator|!=
literal|null
condition|)
return|return
name|answer
return|;
block|}
name|answer
operator|=
name|getDocSetNC
argument_list|(
name|q
argument_list|,
literal|null
argument_list|)
expr_stmt|;
if|if
condition|(
name|filterCache
operator|!=
literal|null
condition|)
name|filterCache
operator|.
name|put
argument_list|(
name|q
argument_list|,
name|answer
argument_list|)
expr_stmt|;
return|return
name|answer
return|;
block|}
comment|// only handle positive (non negative) queries
DECL|method|getPositiveDocSet
name|DocSet
name|getPositiveDocSet
parameter_list|(
name|Query
name|q
parameter_list|,
name|DocsEnumState
name|deState
parameter_list|)
throws|throws
name|IOException
block|{
name|DocSet
name|answer
decl_stmt|;
if|if
condition|(
name|filterCache
operator|!=
literal|null
condition|)
block|{
name|answer
operator|=
name|filterCache
operator|.
name|get
argument_list|(
name|q
argument_list|)
expr_stmt|;
if|if
condition|(
name|answer
operator|!=
literal|null
condition|)
return|return
name|answer
return|;
block|}
name|answer
operator|=
name|getDocSetNC
argument_list|(
name|q
argument_list|,
literal|null
argument_list|,
name|deState
argument_list|)
expr_stmt|;
if|if
condition|(
name|filterCache
operator|!=
literal|null
condition|)
name|filterCache
operator|.
name|put
argument_list|(
name|q
argument_list|,
name|answer
argument_list|)
expr_stmt|;
return|return
name|answer
return|;
block|}
DECL|field|matchAllDocsQuery
specifier|private
specifier|static
name|Query
name|matchAllDocsQuery
init|=
operator|new
name|MatchAllDocsQuery
argument_list|()
decl_stmt|;
comment|/**    * Returns the set of document ids matching all queries.    * This method is cache-aware and attempts to retrieve the answer from the cache if possible.    * If the answer was not cached, it may have been inserted into the cache as a result of this call.    * This method can handle negative queries.    *<p>    * The DocSet returned should<b>not</b> be modified.    */
DECL|method|getDocSet
specifier|public
name|DocSet
name|getDocSet
parameter_list|(
name|List
argument_list|<
name|Query
argument_list|>
name|queries
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|queries
operator|==
literal|null
condition|)
return|return
literal|null
return|;
if|if
condition|(
name|queries
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
return|return
name|getDocSet
argument_list|(
name|queries
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
return|;
name|DocSet
name|answer
init|=
literal|null
decl_stmt|;
name|boolean
index|[]
name|neg
init|=
operator|new
name|boolean
index|[
name|queries
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
name|DocSet
index|[]
name|sets
init|=
operator|new
name|DocSet
index|[
name|queries
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
name|int
name|smallestIndex
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|smallestCount
init|=
name|Integer
operator|.
name|MAX_VALUE
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|sets
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|Query
name|q
init|=
name|queries
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|Query
name|posQuery
init|=
name|QueryUtils
operator|.
name|getAbs
argument_list|(
name|q
argument_list|)
decl_stmt|;
name|sets
index|[
name|i
index|]
operator|=
name|getPositiveDocSet
argument_list|(
name|posQuery
argument_list|)
expr_stmt|;
comment|// Negative query if absolute value different from original
if|if
condition|(
name|q
operator|==
name|posQuery
condition|)
block|{
name|neg
index|[
name|i
index|]
operator|=
literal|false
expr_stmt|;
comment|// keep track of the smallest positive set.
comment|// This optimization is only worth it if size() is cached, which it would
comment|// be if we don't do any set operations.
name|int
name|sz
init|=
name|sets
index|[
name|i
index|]
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|sz
operator|<
name|smallestCount
condition|)
block|{
name|smallestCount
operator|=
name|sz
expr_stmt|;
name|smallestIndex
operator|=
name|i
expr_stmt|;
name|answer
operator|=
name|sets
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
else|else
block|{
name|neg
index|[
name|i
index|]
operator|=
literal|true
expr_stmt|;
block|}
block|}
comment|// if no positive queries, start off with all docs
if|if
condition|(
name|answer
operator|==
literal|null
condition|)
name|answer
operator|=
name|getPositiveDocSet
argument_list|(
name|matchAllDocsQuery
argument_list|)
expr_stmt|;
comment|// do negative queries first to shrink set size
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|sets
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|neg
index|[
name|i
index|]
condition|)
name|answer
operator|=
name|answer
operator|.
name|andNot
argument_list|(
name|sets
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|sets
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|neg
index|[
name|i
index|]
operator|&&
name|i
operator|!=
name|smallestIndex
condition|)
name|answer
operator|=
name|answer
operator|.
name|intersection
argument_list|(
name|sets
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
return|return
name|answer
return|;
block|}
DECL|method|getFilter
name|Filter
name|getFilter
parameter_list|(
name|Query
name|q
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|q
operator|==
literal|null
condition|)
return|return
literal|null
return|;
comment|// TODO: support pure negative queries?
comment|// if (q instanceof) {
comment|// }
return|return
name|getDocSet
argument_list|(
name|q
argument_list|)
operator|.
name|getTopFilter
argument_list|()
return|;
block|}
DECL|method|getFilter
name|Filter
name|getFilter
parameter_list|(
name|DocSet
name|setFilter
parameter_list|,
name|List
argument_list|<
name|Query
argument_list|>
name|queries
parameter_list|)
throws|throws
name|IOException
block|{
name|Filter
name|answer
init|=
name|setFilter
operator|==
literal|null
condition|?
literal|null
else|:
name|setFilter
operator|.
name|getTopFilter
argument_list|()
decl_stmt|;
if|if
condition|(
name|queries
operator|==
literal|null
operator|||
name|queries
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
name|answer
return|;
block|}
if|if
condition|(
name|answer
operator|==
literal|null
operator|&&
name|queries
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
return|return
name|getFilter
argument_list|(
name|queries
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
return|;
block|}
name|DocSet
name|finalSet
init|=
literal|null
decl_stmt|;
name|int
name|nDocSets
init|=
literal|0
decl_stmt|;
name|boolean
index|[]
name|neg
init|=
operator|new
name|boolean
index|[
name|queries
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
name|DocSet
index|[]
name|sets
init|=
operator|new
name|DocSet
index|[
name|queries
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
name|Query
index|[]
name|nocache
init|=
operator|new
name|Query
index|[
name|queries
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
name|int
name|smallestIndex
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|smallestCount
init|=
name|Integer
operator|.
name|MAX_VALUE
decl_stmt|;
for|for
control|(
name|Query
name|q
range|:
name|queries
control|)
block|{
comment|// if (q instanceof)
name|Query
name|posQuery
init|=
name|QueryUtils
operator|.
name|getAbs
argument_list|(
name|q
argument_list|)
decl_stmt|;
name|sets
index|[
name|nDocSets
index|]
operator|=
name|getPositiveDocSet
argument_list|(
name|posQuery
argument_list|)
expr_stmt|;
comment|// Negative query if absolute value different from original
if|if
condition|(
name|q
operator|==
name|posQuery
condition|)
block|{
name|neg
index|[
name|nDocSets
index|]
operator|=
literal|false
expr_stmt|;
comment|// keep track of the smallest positive set.
comment|// This optimization is only worth it if size() is cached, which it would
comment|// be if we don't do any set operations.
name|int
name|sz
init|=
name|sets
index|[
name|nDocSets
index|]
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|sz
operator|<
name|smallestCount
condition|)
block|{
name|smallestCount
operator|=
name|sz
expr_stmt|;
name|smallestIndex
operator|=
name|nDocSets
expr_stmt|;
name|finalSet
operator|=
name|sets
index|[
name|nDocSets
index|]
expr_stmt|;
block|}
block|}
else|else
block|{
name|neg
index|[
name|nDocSets
index|]
operator|=
literal|true
expr_stmt|;
block|}
name|nDocSets
operator|++
expr_stmt|;
block|}
comment|// if no positive queries, start off with all docs
if|if
condition|(
name|finalSet
operator|==
literal|null
condition|)
name|finalSet
operator|=
name|getPositiveDocSet
argument_list|(
name|matchAllDocsQuery
argument_list|)
expr_stmt|;
comment|// do negative queries first to shrink set size
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|sets
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|neg
index|[
name|i
index|]
condition|)
name|finalSet
operator|=
name|finalSet
operator|.
name|andNot
argument_list|(
name|sets
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|sets
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|neg
index|[
name|i
index|]
operator|&&
name|i
operator|!=
name|smallestIndex
condition|)
name|finalSet
operator|=
name|finalSet
operator|.
name|intersection
argument_list|(
name|sets
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
return|return
name|finalSet
operator|.
name|getTopFilter
argument_list|()
return|;
block|}
comment|// query must be positive
DECL|method|getDocSetNC
specifier|protected
name|DocSet
name|getDocSetNC
parameter_list|(
name|Query
name|query
parameter_list|,
name|DocSet
name|filter
parameter_list|,
name|DocsEnumState
name|deState
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|filter
operator|!=
literal|null
condition|)
return|return
name|getDocSetNC
argument_list|(
name|query
argument_list|,
name|filter
argument_list|,
literal|null
argument_list|)
return|;
name|int
name|smallSetSize
init|=
name|maxDoc
argument_list|()
operator|>>
literal|6
decl_stmt|;
name|int
name|largestPossible
init|=
name|deState
operator|.
name|termsEnum
operator|.
name|docFreq
argument_list|()
decl_stmt|;
name|int
index|[]
name|docs
init|=
operator|new
name|int
index|[
name|Math
operator|.
name|min
argument_list|(
name|smallSetSize
argument_list|,
name|largestPossible
argument_list|)
index|]
decl_stmt|;
name|int
name|upto
init|=
literal|0
decl_stmt|;
name|int
name|bitsSet
init|=
literal|0
decl_stmt|;
name|OpenBitSet
name|obs
init|=
literal|null
decl_stmt|;
name|DocsEnum
name|docsEnum
init|=
name|deState
operator|.
name|termsEnum
operator|.
name|docs
argument_list|(
name|deState
operator|.
name|deletedDocs
argument_list|,
name|deState
operator|.
name|reuse
argument_list|)
decl_stmt|;
if|if
condition|(
name|deState
operator|.
name|reuse
operator|==
literal|null
condition|)
block|{
name|deState
operator|.
name|reuse
operator|=
name|docsEnum
expr_stmt|;
block|}
if|if
condition|(
name|docsEnum
operator|instanceof
name|MultiDocsEnum
condition|)
block|{
name|MultiDocsEnum
operator|.
name|EnumWithSlice
index|[]
name|subs
init|=
operator|(
operator|(
name|MultiDocsEnum
operator|)
name|docsEnum
operator|)
operator|.
name|getSubs
argument_list|()
decl_stmt|;
name|int
name|numSubs
init|=
operator|(
operator|(
name|MultiDocsEnum
operator|)
name|docsEnum
operator|)
operator|.
name|getNumSubs
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|subindex
init|=
literal|0
init|;
name|subindex
operator|<
name|numSubs
condition|;
name|subindex
operator|++
control|)
block|{
name|MultiDocsEnum
operator|.
name|EnumWithSlice
name|sub
init|=
name|subs
index|[
name|subindex
index|]
decl_stmt|;
if|if
condition|(
name|sub
operator|.
name|docsEnum
operator|==
literal|null
condition|)
continue|continue;
name|DocsEnum
operator|.
name|BulkReadResult
name|bulk
init|=
name|sub
operator|.
name|docsEnum
operator|.
name|getBulkResult
argument_list|()
decl_stmt|;
name|int
name|base
init|=
name|sub
operator|.
name|slice
operator|.
name|start
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|nDocs
init|=
name|sub
operator|.
name|docsEnum
operator|.
name|read
argument_list|()
decl_stmt|;
if|if
condition|(
name|nDocs
operator|==
literal|0
condition|)
break|break;
name|int
index|[]
name|docArr
init|=
name|bulk
operator|.
name|docs
operator|.
name|ints
decl_stmt|;
name|int
name|end
init|=
name|bulk
operator|.
name|docs
operator|.
name|offset
operator|+
name|nDocs
decl_stmt|;
if|if
condition|(
name|upto
operator|+
name|nDocs
operator|>
name|docs
operator|.
name|length
condition|)
block|{
if|if
condition|(
name|obs
operator|==
literal|null
condition|)
name|obs
operator|=
operator|new
name|OpenBitSet
argument_list|(
name|maxDoc
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
name|bulk
operator|.
name|docs
operator|.
name|offset
init|;
name|i
operator|<
name|end
condition|;
name|i
operator|++
control|)
block|{
name|obs
operator|.
name|fastSet
argument_list|(
name|docArr
index|[
name|i
index|]
operator|+
name|base
argument_list|)
expr_stmt|;
block|}
name|bitsSet
operator|+=
name|nDocs
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|int
name|i
init|=
name|bulk
operator|.
name|docs
operator|.
name|offset
init|;
name|i
operator|<
name|end
condition|;
name|i
operator|++
control|)
block|{
name|docs
index|[
name|upto
operator|++
index|]
operator|=
name|docArr
index|[
name|i
index|]
operator|+
name|base
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
else|else
block|{
name|DocsEnum
operator|.
name|BulkReadResult
name|bulk
init|=
name|docsEnum
operator|.
name|getBulkResult
argument_list|()
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|nDocs
init|=
name|docsEnum
operator|.
name|read
argument_list|()
decl_stmt|;
if|if
condition|(
name|nDocs
operator|==
literal|0
condition|)
break|break;
name|int
index|[]
name|docArr
init|=
name|bulk
operator|.
name|docs
operator|.
name|ints
decl_stmt|;
name|int
name|end
init|=
name|bulk
operator|.
name|docs
operator|.
name|offset
operator|+
name|nDocs
decl_stmt|;
if|if
condition|(
name|upto
operator|+
name|nDocs
operator|>
name|docs
operator|.
name|length
condition|)
block|{
if|if
condition|(
name|obs
operator|==
literal|null
condition|)
name|obs
operator|=
operator|new
name|OpenBitSet
argument_list|(
name|maxDoc
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
name|bulk
operator|.
name|docs
operator|.
name|offset
init|;
name|i
operator|<
name|end
condition|;
name|i
operator|++
control|)
block|{
name|obs
operator|.
name|fastSet
argument_list|(
name|docArr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|bitsSet
operator|+=
name|nDocs
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|int
name|i
init|=
name|bulk
operator|.
name|docs
operator|.
name|offset
init|;
name|i
operator|<
name|end
condition|;
name|i
operator|++
control|)
block|{
name|docs
index|[
name|upto
operator|++
index|]
operator|=
name|docArr
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|obs
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|upto
condition|;
name|i
operator|++
control|)
block|{
name|obs
operator|.
name|fastSet
argument_list|(
name|docs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|bitsSet
operator|+=
name|upto
expr_stmt|;
return|return
operator|new
name|BitDocSet
argument_list|(
name|obs
argument_list|,
name|bitsSet
argument_list|)
return|;
block|}
return|return
operator|new
name|SortedIntDocSet
argument_list|(
name|docs
argument_list|,
name|upto
argument_list|)
return|;
block|}
comment|// query must be positive
DECL|method|getDocSetNC
specifier|protected
name|DocSet
name|getDocSetNC
parameter_list|(
name|Query
name|query
parameter_list|,
name|DocSet
name|filter
parameter_list|)
throws|throws
name|IOException
block|{
name|DocSetCollector
name|collector
init|=
operator|new
name|DocSetCollector
argument_list|(
name|maxDoc
argument_list|()
operator|>>
literal|6
argument_list|,
name|maxDoc
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|filter
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|query
operator|instanceof
name|TermQuery
condition|)
block|{
name|Term
name|t
init|=
operator|(
operator|(
name|TermQuery
operator|)
name|query
operator|)
operator|.
name|getTerm
argument_list|()
decl_stmt|;
specifier|final
name|AtomicReaderContext
index|[]
name|leaves
init|=
name|leafContexts
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|leaves
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|AtomicReaderContext
name|leaf
init|=
name|leaves
index|[
name|i
index|]
decl_stmt|;
specifier|final
name|IndexReader
name|reader
init|=
name|leaf
operator|.
name|reader
decl_stmt|;
name|collector
operator|.
name|setNextReader
argument_list|(
name|leaf
argument_list|)
expr_stmt|;
name|Fields
name|fields
init|=
name|reader
operator|.
name|fields
argument_list|()
decl_stmt|;
name|Terms
name|terms
init|=
name|fields
operator|.
name|terms
argument_list|(
name|t
operator|.
name|field
argument_list|()
argument_list|)
decl_stmt|;
name|BytesRef
name|termBytes
init|=
name|t
operator|.
name|bytes
argument_list|()
decl_stmt|;
name|Bits
name|skipDocs
init|=
name|reader
operator|.
name|getDeletedDocs
argument_list|()
decl_stmt|;
name|DocsEnum
name|docsEnum
init|=
name|terms
operator|==
literal|null
condition|?
literal|null
else|:
name|terms
operator|.
name|docs
argument_list|(
name|skipDocs
argument_list|,
name|termBytes
argument_list|,
literal|null
argument_list|)
decl_stmt|;
if|if
condition|(
name|docsEnum
operator|!=
literal|null
condition|)
block|{
name|DocsEnum
operator|.
name|BulkReadResult
name|readResult
init|=
name|docsEnum
operator|.
name|getBulkResult
argument_list|()
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|n
init|=
name|docsEnum
operator|.
name|read
argument_list|()
decl_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
break|break;
name|int
index|[]
name|arr
init|=
name|readResult
operator|.
name|docs
operator|.
name|ints
decl_stmt|;
name|int
name|end
init|=
name|readResult
operator|.
name|docs
operator|.
name|offset
operator|+
name|n
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
name|readResult
operator|.
name|docs
operator|.
name|offset
init|;
name|j
operator|<
name|end
condition|;
name|j
operator|++
control|)
block|{
name|collector
operator|.
name|collect
argument_list|(
name|arr
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
else|else
block|{
name|super
operator|.
name|search
argument_list|(
name|query
argument_list|,
literal|null
argument_list|,
name|collector
argument_list|)
expr_stmt|;
block|}
return|return
name|collector
operator|.
name|getDocSet
argument_list|()
return|;
block|}
else|else
block|{
name|Filter
name|luceneFilter
init|=
name|filter
operator|.
name|getTopFilter
argument_list|()
decl_stmt|;
name|super
operator|.
name|search
argument_list|(
name|query
argument_list|,
name|luceneFilter
argument_list|,
name|collector
argument_list|)
expr_stmt|;
return|return
name|collector
operator|.
name|getDocSet
argument_list|()
return|;
block|}
block|}
comment|/**    * Returns the set of document ids matching both the query and the filter.    * This method is cache-aware and attempts to retrieve the answer from the cache if possible.    * If the answer was not cached, it may have been inserted into the cache as a result of this call.    *<p>    *    * @param query    * @param filter may be null    * @return DocSet meeting the specified criteria, should<b>not</b> be modified by the caller.    */
DECL|method|getDocSet
specifier|public
name|DocSet
name|getDocSet
parameter_list|(
name|Query
name|query
parameter_list|,
name|DocSet
name|filter
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|filter
operator|==
literal|null
condition|)
return|return
name|getDocSet
argument_list|(
name|query
argument_list|)
return|;
comment|// Negative query if absolute value different from original
name|Query
name|absQ
init|=
name|QueryUtils
operator|.
name|getAbs
argument_list|(
name|query
argument_list|)
decl_stmt|;
name|boolean
name|positive
init|=
name|absQ
operator|==
name|query
decl_stmt|;
name|DocSet
name|first
decl_stmt|;
if|if
condition|(
name|filterCache
operator|!=
literal|null
condition|)
block|{
name|first
operator|=
name|filterCache
operator|.
name|get
argument_list|(
name|absQ
argument_list|)
expr_stmt|;
if|if
condition|(
name|first
operator|==
literal|null
condition|)
block|{
name|first
operator|=
name|getDocSetNC
argument_list|(
name|absQ
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|filterCache
operator|.
name|put
argument_list|(
name|absQ
argument_list|,
name|first
argument_list|)
expr_stmt|;
block|}
return|return
name|positive
condition|?
name|first
operator|.
name|intersection
argument_list|(
name|filter
argument_list|)
else|:
name|filter
operator|.
name|andNot
argument_list|(
name|first
argument_list|)
return|;
block|}
comment|// If there isn't a cache, then do a single filtered query if positive.
return|return
name|positive
condition|?
name|getDocSetNC
argument_list|(
name|absQ
argument_list|,
name|filter
argument_list|)
else|:
name|filter
operator|.
name|andNot
argument_list|(
name|getPositiveDocSet
argument_list|(
name|absQ
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Returns documents matching both<code>query</code> and<code>filter</code>    * and sorted by<code>sort</code>.    *<p>    * This method is cache aware and may retrieve<code>filter</code> from    * the cache or make an insertion into the cache as a result of this call.    *<p>    * FUTURE: The returned DocList may be retrieved from a cache.    *    * @param query    * @param filter   may be null    * @param lsort    criteria by which to sort (if null, query relevance is used)    * @param offset   offset into the list of documents to return    * @param len      maximum number of documents to return    * @return DocList meeting the specified criteria, should<b>not</b> be modified by the caller.    * @throws IOException    */
DECL|method|getDocList
specifier|public
name|DocList
name|getDocList
parameter_list|(
name|Query
name|query
parameter_list|,
name|Query
name|filter
parameter_list|,
name|Sort
name|lsort
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|len
parameter_list|)
throws|throws
name|IOException
block|{
name|QueryCommand
name|qc
init|=
operator|new
name|QueryCommand
argument_list|()
decl_stmt|;
name|qc
operator|.
name|setQuery
argument_list|(
name|query
argument_list|)
operator|.
name|setFilterList
argument_list|(
name|filter
argument_list|)
operator|.
name|setSort
argument_list|(
name|lsort
argument_list|)
operator|.
name|setOffset
argument_list|(
name|offset
argument_list|)
operator|.
name|setLen
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|QueryResult
name|qr
init|=
operator|new
name|QueryResult
argument_list|()
decl_stmt|;
name|search
argument_list|(
name|qr
argument_list|,
name|qc
argument_list|)
expr_stmt|;
return|return
name|qr
operator|.
name|getDocList
argument_list|()
return|;
block|}
comment|/**    * Returns documents matching both<code>query</code> and the     * intersection of the<code>filterList</code>, sorted by<code>sort</code>.    *<p>    * This method is cache aware and may retrieve<code>filter</code> from    * the cache or make an insertion into the cache as a result of this call.    *<p>    * FUTURE: The returned DocList may be retrieved from a cache.    *    * @param query    * @param filterList may be null    * @param lsort    criteria by which to sort (if null, query relevance is used)    * @param offset   offset into the list of documents to return    * @param len      maximum number of documents to return    * @return DocList meeting the specified criteria, should<b>not</b> be modified by the caller.    * @throws IOException    */
DECL|method|getDocList
specifier|public
name|DocList
name|getDocList
parameter_list|(
name|Query
name|query
parameter_list|,
name|List
argument_list|<
name|Query
argument_list|>
name|filterList
parameter_list|,
name|Sort
name|lsort
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|flags
parameter_list|)
throws|throws
name|IOException
block|{
name|QueryCommand
name|qc
init|=
operator|new
name|QueryCommand
argument_list|()
decl_stmt|;
name|qc
operator|.
name|setQuery
argument_list|(
name|query
argument_list|)
operator|.
name|setFilterList
argument_list|(
name|filterList
argument_list|)
operator|.
name|setSort
argument_list|(
name|lsort
argument_list|)
operator|.
name|setOffset
argument_list|(
name|offset
argument_list|)
operator|.
name|setLen
argument_list|(
name|len
argument_list|)
operator|.
name|setFlags
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|QueryResult
name|qr
init|=
operator|new
name|QueryResult
argument_list|()
decl_stmt|;
name|search
argument_list|(
name|qr
argument_list|,
name|qc
argument_list|)
expr_stmt|;
return|return
name|qr
operator|.
name|getDocList
argument_list|()
return|;
block|}
DECL|field|NO_CHECK_QCACHE
specifier|static
specifier|final
name|int
name|NO_CHECK_QCACHE
init|=
literal|0x80000000
decl_stmt|;
DECL|field|GET_DOCSET
specifier|static
specifier|final
name|int
name|GET_DOCSET
init|=
literal|0x40000000
decl_stmt|;
DECL|field|NO_CHECK_FILTERCACHE
specifier|static
specifier|final
name|int
name|NO_CHECK_FILTERCACHE
init|=
literal|0x20000000
decl_stmt|;
DECL|field|GET_DOCLIST
specifier|public
specifier|static
specifier|final
name|int
name|GET_DOCLIST
init|=
literal|0x02
decl_stmt|;
comment|// get the documents actually returned in a response
DECL|field|GET_SCORES
specifier|public
specifier|static
specifier|final
name|int
name|GET_SCORES
init|=
literal|0x01
decl_stmt|;
comment|/**    * getDocList version that uses+populates query and filter caches.    * In the event of a timeout, the cache is not populated.    */
DECL|method|getDocListC
specifier|private
name|void
name|getDocListC
parameter_list|(
name|QueryResult
name|qr
parameter_list|,
name|QueryCommand
name|cmd
parameter_list|)
throws|throws
name|IOException
block|{
name|DocListAndSet
name|out
init|=
operator|new
name|DocListAndSet
argument_list|()
decl_stmt|;
name|qr
operator|.
name|setDocListAndSet
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|QueryResultKey
name|key
init|=
literal|null
decl_stmt|;
name|int
name|maxDocRequested
init|=
name|cmd
operator|.
name|getOffset
argument_list|()
operator|+
name|cmd
operator|.
name|getLen
argument_list|()
decl_stmt|;
comment|// check for overflow, and check for # docs in index
if|if
condition|(
name|maxDocRequested
argument_list|<
literal|0
operator|||
name|maxDocRequested
argument_list|>
name|maxDoc
argument_list|()
condition|)
name|maxDocRequested
operator|=
name|maxDoc
argument_list|()
expr_stmt|;
name|int
name|supersetMaxDoc
init|=
name|maxDocRequested
decl_stmt|;
name|DocList
name|superset
decl_stmt|;
comment|// we can try and look up the complete query in the cache.
comment|// we can't do that if filter!=null though (we don't want to
comment|// do hashCode() and equals() for a big DocSet).
if|if
condition|(
name|queryResultCache
operator|!=
literal|null
operator|&&
name|cmd
operator|.
name|getFilter
argument_list|()
operator|==
literal|null
condition|)
block|{
comment|// all of the current flags can be reused during warming,
comment|// so set all of them on the cache key.
name|key
operator|=
operator|new
name|QueryResultKey
argument_list|(
name|cmd
operator|.
name|getQuery
argument_list|()
argument_list|,
name|cmd
operator|.
name|getFilterList
argument_list|()
argument_list|,
name|cmd
operator|.
name|getSort
argument_list|()
argument_list|,
name|cmd
operator|.
name|getFlags
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cmd
operator|.
name|getFlags
argument_list|()
operator|&
name|NO_CHECK_QCACHE
operator|)
operator|==
literal|0
condition|)
block|{
name|superset
operator|=
name|queryResultCache
operator|.
name|get
argument_list|(
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|superset
operator|!=
literal|null
condition|)
block|{
comment|// check that the cache entry has scores recorded if we need them
if|if
condition|(
operator|(
name|cmd
operator|.
name|getFlags
argument_list|()
operator|&
name|GET_SCORES
operator|)
operator|==
literal|0
operator|||
name|superset
operator|.
name|hasScores
argument_list|()
condition|)
block|{
comment|// NOTE: subset() returns null if the DocList has fewer docs than
comment|// requested
name|out
operator|.
name|docList
operator|=
name|superset
operator|.
name|subset
argument_list|(
name|cmd
operator|.
name|getOffset
argument_list|()
argument_list|,
name|cmd
operator|.
name|getLen
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|out
operator|.
name|docList
operator|!=
literal|null
condition|)
block|{
comment|// found the docList in the cache... now check if we need the docset too.
comment|// OPT: possible future optimization - if the doclist contains all the matches,
comment|// use it to make the docset instead of rerunning the query.
if|if
condition|(
name|out
operator|.
name|docSet
operator|==
literal|null
operator|&&
operator|(
operator|(
name|cmd
operator|.
name|getFlags
argument_list|()
operator|&
name|GET_DOCSET
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|cmd
operator|.
name|getFilterList
argument_list|()
operator|==
literal|null
condition|)
block|{
name|out
operator|.
name|docSet
operator|=
name|getDocSet
argument_list|(
name|cmd
operator|.
name|getQuery
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|List
argument_list|<
name|Query
argument_list|>
name|newList
init|=
operator|new
name|ArrayList
argument_list|<
name|Query
argument_list|>
argument_list|(
name|cmd
operator|.
name|getFilterList
argument_list|()
operator|.
name|size
argument_list|()
operator|+
literal|1
argument_list|)
decl_stmt|;
name|newList
operator|.
name|add
argument_list|(
name|cmd
operator|.
name|getQuery
argument_list|()
argument_list|)
expr_stmt|;
name|newList
operator|.
name|addAll
argument_list|(
name|cmd
operator|.
name|getFilterList
argument_list|()
argument_list|)
expr_stmt|;
name|out
operator|.
name|docSet
operator|=
name|getDocSet
argument_list|(
name|newList
argument_list|)
expr_stmt|;
block|}
block|}
return|return;
block|}
block|}
comment|// If we are going to generate the result, bump up to the
comment|// next resultWindowSize for better caching.
comment|// handle 0 special case as well as avoid idiv in the common case.
if|if
condition|(
name|maxDocRequested
operator|<
name|queryResultWindowSize
condition|)
block|{
name|supersetMaxDoc
operator|=
name|queryResultWindowSize
expr_stmt|;
block|}
else|else
block|{
name|supersetMaxDoc
operator|=
operator|(
operator|(
name|maxDocRequested
operator|-
literal|1
operator|)
operator|/
name|queryResultWindowSize
operator|+
literal|1
operator|)
operator|*
name|queryResultWindowSize
expr_stmt|;
if|if
condition|(
name|supersetMaxDoc
operator|<
literal|0
condition|)
name|supersetMaxDoc
operator|=
name|maxDocRequested
expr_stmt|;
block|}
block|}
comment|// OK, so now we need to generate an answer.
comment|// One way to do that would be to check if we have an unordered list
comment|// of results for the base query.  If so, we can apply the filters and then
comment|// sort by the resulting set.  This can only be used if:
comment|// - the sort doesn't contain score
comment|// - we don't want score returned.
comment|// check if we should try and use the filter cache
name|boolean
name|useFilterCache
init|=
literal|false
decl_stmt|;
if|if
condition|(
operator|(
name|cmd
operator|.
name|getFlags
argument_list|()
operator|&
operator|(
name|GET_SCORES
operator||
name|NO_CHECK_FILTERCACHE
operator|)
operator|)
operator|==
literal|0
operator|&&
name|useFilterForSortedQuery
operator|&&
name|cmd
operator|.
name|getSort
argument_list|()
operator|!=
literal|null
operator|&&
name|filterCache
operator|!=
literal|null
condition|)
block|{
name|useFilterCache
operator|=
literal|true
expr_stmt|;
name|SortField
index|[]
name|sfields
init|=
name|cmd
operator|.
name|getSort
argument_list|()
operator|.
name|getSort
argument_list|()
decl_stmt|;
for|for
control|(
name|SortField
name|sf
range|:
name|sfields
control|)
block|{
if|if
condition|(
name|sf
operator|.
name|getType
argument_list|()
operator|==
name|SortField
operator|.
name|SCORE
condition|)
block|{
name|useFilterCache
operator|=
literal|false
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|// disable useFilterCache optimization temporarily
if|if
condition|(
name|useFilterCache
condition|)
block|{
comment|// now actually use the filter cache.
comment|// for large filters that match few documents, this may be
comment|// slower than simply re-executing the query.
if|if
condition|(
name|out
operator|.
name|docSet
operator|==
literal|null
condition|)
block|{
name|out
operator|.
name|docSet
operator|=
name|getDocSet
argument_list|(
name|cmd
operator|.
name|getQuery
argument_list|()
argument_list|,
name|cmd
operator|.
name|getFilter
argument_list|()
argument_list|)
expr_stmt|;
name|DocSet
name|bigFilt
init|=
name|getDocSet
argument_list|(
name|cmd
operator|.
name|getFilterList
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|bigFilt
operator|!=
literal|null
condition|)
name|out
operator|.
name|docSet
operator|=
name|out
operator|.
name|docSet
operator|.
name|intersection
argument_list|(
name|bigFilt
argument_list|)
expr_stmt|;
block|}
comment|// todo: there could be a sortDocSet that could take a list of
comment|// the filters instead of anding them first...
comment|// perhaps there should be a multi-docset-iterator
name|superset
operator|=
name|sortDocSet
argument_list|(
name|out
operator|.
name|docSet
argument_list|,
name|cmd
operator|.
name|getSort
argument_list|()
argument_list|,
name|supersetMaxDoc
argument_list|)
expr_stmt|;
name|out
operator|.
name|docList
operator|=
name|superset
operator|.
name|subset
argument_list|(
name|cmd
operator|.
name|getOffset
argument_list|()
argument_list|,
name|cmd
operator|.
name|getLen
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// do it the normal way...
name|cmd
operator|.
name|setSupersetMaxDoc
argument_list|(
name|supersetMaxDoc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cmd
operator|.
name|getFlags
argument_list|()
operator|&
name|GET_DOCSET
operator|)
operator|!=
literal|0
condition|)
block|{
comment|// this currently conflates returning the docset for the base query vs
comment|// the base query and all filters.
name|DocSet
name|qDocSet
init|=
name|getDocListAndSetNC
argument_list|(
name|qr
argument_list|,
name|cmd
argument_list|)
decl_stmt|;
comment|// cache the docSet matching the query w/o filtering
if|if
condition|(
name|qDocSet
operator|!=
literal|null
operator|&&
name|filterCache
operator|!=
literal|null
operator|&&
operator|!
name|qr
operator|.
name|isPartialResults
argument_list|()
condition|)
name|filterCache
operator|.
name|put
argument_list|(
name|cmd
operator|.
name|getQuery
argument_list|()
argument_list|,
name|qDocSet
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|getDocListNC
argument_list|(
name|qr
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
comment|//Parameters: cmd.getQuery(),theFilt,cmd.getSort(),0,supersetMaxDoc,cmd.getFlags(),cmd.getTimeAllowed(),responseHeader);
block|}
name|superset
operator|=
name|out
operator|.
name|docList
expr_stmt|;
name|out
operator|.
name|docList
operator|=
name|superset
operator|.
name|subset
argument_list|(
name|cmd
operator|.
name|getOffset
argument_list|()
argument_list|,
name|cmd
operator|.
name|getLen
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// lastly, put the superset in the cache if the size is less than or equal
comment|// to queryResultMaxDocsCached
if|if
condition|(
name|key
operator|!=
literal|null
operator|&&
name|superset
operator|.
name|size
argument_list|()
operator|<=
name|queryResultMaxDocsCached
operator|&&
operator|!
name|qr
operator|.
name|isPartialResults
argument_list|()
condition|)
block|{
name|queryResultCache
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|superset
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|getDocListNC
specifier|private
name|void
name|getDocListNC
parameter_list|(
name|QueryResult
name|qr
parameter_list|,
name|QueryCommand
name|cmd
parameter_list|)
throws|throws
name|IOException
block|{
comment|//Parameters: cmd.getQuery(),theFilt,cmd.getSort(),0,supersetMaxDoc,cmd.getFlags(),cmd.getTimeAllowed(),responseHeader);
comment|//Query query, DocSet filter, Sort lsort, int offset, int len, int flags, long timeAllowed, NamedList<Object> responseHeader
name|DocSet
name|filter
init|=
name|cmd
operator|.
name|getFilter
argument_list|()
operator|!=
literal|null
condition|?
name|cmd
operator|.
name|getFilter
argument_list|()
else|:
name|getDocSet
argument_list|(
name|cmd
operator|.
name|getFilterList
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|long
name|timeAllowed
init|=
name|cmd
operator|.
name|getTimeAllowed
argument_list|()
decl_stmt|;
name|int
name|len
init|=
name|cmd
operator|.
name|getSupersetMaxDoc
argument_list|()
decl_stmt|;
name|int
name|last
init|=
name|len
decl_stmt|;
if|if
condition|(
name|last
argument_list|<
literal|0
operator|||
name|last
argument_list|>
name|maxDoc
argument_list|()
condition|)
name|last
operator|=
name|maxDoc
argument_list|()
expr_stmt|;
specifier|final
name|int
name|lastDocRequested
init|=
name|last
decl_stmt|;
name|int
name|nDocsReturned
decl_stmt|;
name|int
name|totalHits
decl_stmt|;
name|float
name|maxScore
decl_stmt|;
name|int
index|[]
name|ids
decl_stmt|;
name|float
index|[]
name|scores
decl_stmt|;
name|boolean
name|needScores
init|=
operator|(
name|cmd
operator|.
name|getFlags
argument_list|()
operator|&
name|GET_SCORES
operator|)
operator|!=
literal|0
decl_stmt|;
name|Query
name|query
init|=
name|QueryUtils
operator|.
name|makeQueryable
argument_list|(
name|cmd
operator|.
name|getQuery
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|Filter
name|luceneFilter
init|=
name|filter
operator|==
literal|null
condition|?
literal|null
else|:
name|filter
operator|.
name|getTopFilter
argument_list|()
decl_stmt|;
comment|// handle zero case...
if|if
condition|(
name|lastDocRequested
operator|<=
literal|0
condition|)
block|{
specifier|final
name|float
index|[]
name|topscore
init|=
operator|new
name|float
index|[]
block|{
name|Float
operator|.
name|NEGATIVE_INFINITY
block|}
decl_stmt|;
specifier|final
name|int
index|[]
name|numHits
init|=
operator|new
name|int
index|[
literal|1
index|]
decl_stmt|;
name|Collector
name|collector
decl_stmt|;
if|if
condition|(
operator|!
name|needScores
condition|)
block|{
name|collector
operator|=
operator|new
name|Collector
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|setScorer
parameter_list|(
name|Scorer
name|scorer
parameter_list|)
throws|throws
name|IOException
block|{           }
annotation|@
name|Override
specifier|public
name|void
name|collect
parameter_list|(
name|int
name|doc
parameter_list|)
throws|throws
name|IOException
block|{
name|numHits
index|[
literal|0
index|]
operator|++
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|setNextReader
parameter_list|(
name|AtomicReaderContext
name|context
parameter_list|)
throws|throws
name|IOException
block|{           }
annotation|@
name|Override
specifier|public
name|boolean
name|acceptsDocsOutOfOrder
parameter_list|()
block|{
return|return
literal|true
return|;
block|}
block|}
expr_stmt|;
block|}
else|else
block|{
name|collector
operator|=
operator|new
name|Collector
argument_list|()
block|{
name|Scorer
name|scorer
decl_stmt|;
annotation|@
name|Override
specifier|public
name|void
name|setScorer
parameter_list|(
name|Scorer
name|scorer
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|scorer
operator|=
name|scorer
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|collect
parameter_list|(
name|int
name|doc
parameter_list|)
throws|throws
name|IOException
block|{
name|numHits
index|[
literal|0
index|]
operator|++
expr_stmt|;
name|float
name|score
init|=
name|scorer
operator|.
name|score
argument_list|()
decl_stmt|;
if|if
condition|(
name|score
operator|>
name|topscore
index|[
literal|0
index|]
condition|)
name|topscore
index|[
literal|0
index|]
operator|=
name|score
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|setNextReader
parameter_list|(
name|AtomicReaderContext
name|context
parameter_list|)
throws|throws
name|IOException
block|{           }
annotation|@
name|Override
specifier|public
name|boolean
name|acceptsDocsOutOfOrder
parameter_list|()
block|{
return|return
literal|true
return|;
block|}
block|}
expr_stmt|;
block|}
if|if
condition|(
name|timeAllowed
operator|>
literal|0
condition|)
block|{
name|collector
operator|=
operator|new
name|TimeLimitingCollector
argument_list|(
name|collector
argument_list|,
name|timeAllowed
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|super
operator|.
name|search
argument_list|(
name|query
argument_list|,
name|luceneFilter
argument_list|,
name|collector
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|TimeLimitingCollector
operator|.
name|TimeExceededException
name|x
parameter_list|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Query: "
operator|+
name|query
operator|+
literal|"; "
operator|+
name|x
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
name|qr
operator|.
name|setPartialResults
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
name|nDocsReturned
operator|=
literal|0
expr_stmt|;
name|ids
operator|=
operator|new
name|int
index|[
name|nDocsReturned
index|]
expr_stmt|;
name|scores
operator|=
operator|new
name|float
index|[
name|nDocsReturned
index|]
expr_stmt|;
name|totalHits
operator|=
name|numHits
index|[
literal|0
index|]
expr_stmt|;
name|maxScore
operator|=
name|totalHits
operator|>
literal|0
condition|?
name|topscore
index|[
literal|0
index|]
else|:
literal|0.0f
expr_stmt|;
block|}
else|else
block|{
name|TopDocsCollector
name|topCollector
decl_stmt|;
if|if
condition|(
name|cmd
operator|.
name|getSort
argument_list|()
operator|==
literal|null
condition|)
block|{
name|topCollector
operator|=
name|TopScoreDocCollector
operator|.
name|create
argument_list|(
name|len
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|topCollector
operator|=
name|TopFieldCollector
operator|.
name|create
argument_list|(
name|weightSort
argument_list|(
name|cmd
operator|.
name|getSort
argument_list|()
argument_list|)
argument_list|,
name|len
argument_list|,
literal|false
argument_list|,
name|needScores
argument_list|,
name|needScores
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
name|Collector
name|collector
init|=
name|topCollector
decl_stmt|;
if|if
condition|(
name|timeAllowed
operator|>
literal|0
condition|)
block|{
name|collector
operator|=
operator|new
name|TimeLimitingCollector
argument_list|(
name|collector
argument_list|,
name|timeAllowed
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|super
operator|.
name|search
argument_list|(
name|query
argument_list|,
name|luceneFilter
argument_list|,
name|collector
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|TimeLimitingCollector
operator|.
name|TimeExceededException
name|x
parameter_list|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Query: "
operator|+
name|query
operator|+
literal|"; "
operator|+
name|x
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
name|qr
operator|.
name|setPartialResults
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
name|totalHits
operator|=
name|topCollector
operator|.
name|getTotalHits
argument_list|()
expr_stmt|;
name|TopDocs
name|topDocs
init|=
name|topCollector
operator|.
name|topDocs
argument_list|(
literal|0
argument_list|,
name|len
argument_list|)
decl_stmt|;
name|maxScore
operator|=
name|totalHits
operator|>
literal|0
condition|?
name|topDocs
operator|.
name|getMaxScore
argument_list|()
else|:
literal|0.0f
expr_stmt|;
name|nDocsReturned
operator|=
name|topDocs
operator|.
name|scoreDocs
operator|.
name|length
expr_stmt|;
name|ids
operator|=
operator|new
name|int
index|[
name|nDocsReturned
index|]
expr_stmt|;
name|scores
operator|=
operator|(
name|cmd
operator|.
name|getFlags
argument_list|()
operator|&
name|GET_SCORES
operator|)
operator|!=
literal|0
condition|?
operator|new
name|float
index|[
name|nDocsReturned
index|]
else|:
literal|null
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nDocsReturned
condition|;
name|i
operator|++
control|)
block|{
name|ScoreDoc
name|scoreDoc
init|=
name|topDocs
operator|.
name|scoreDocs
index|[
name|i
index|]
decl_stmt|;
name|ids
index|[
name|i
index|]
operator|=
name|scoreDoc
operator|.
name|doc
expr_stmt|;
if|if
condition|(
name|scores
operator|!=
literal|null
condition|)
name|scores
index|[
name|i
index|]
operator|=
name|scoreDoc
operator|.
name|score
expr_stmt|;
block|}
block|}
name|int
name|sliceLen
init|=
name|Math
operator|.
name|min
argument_list|(
name|lastDocRequested
argument_list|,
name|nDocsReturned
argument_list|)
decl_stmt|;
if|if
condition|(
name|sliceLen
operator|<
literal|0
condition|)
name|sliceLen
operator|=
literal|0
expr_stmt|;
name|qr
operator|.
name|setDocList
argument_list|(
operator|new
name|DocSlice
argument_list|(
literal|0
argument_list|,
name|sliceLen
argument_list|,
name|ids
argument_list|,
name|scores
argument_list|,
name|totalHits
argument_list|,
name|maxScore
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// any DocSet returned is for the query only, without any filtering... that way it may
comment|// be cached if desired.
DECL|method|getDocListAndSetNC
specifier|private
name|DocSet
name|getDocListAndSetNC
parameter_list|(
name|QueryResult
name|qr
parameter_list|,
name|QueryCommand
name|cmd
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|len
init|=
name|cmd
operator|.
name|getSupersetMaxDoc
argument_list|()
decl_stmt|;
name|DocSet
name|filter
init|=
name|cmd
operator|.
name|getFilter
argument_list|()
operator|!=
literal|null
condition|?
name|cmd
operator|.
name|getFilter
argument_list|()
else|:
name|getDocSet
argument_list|(
name|cmd
operator|.
name|getFilterList
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|last
init|=
name|len
decl_stmt|;
if|if
condition|(
name|last
argument_list|<
literal|0
operator|||
name|last
argument_list|>
name|maxDoc
argument_list|()
condition|)
name|last
operator|=
name|maxDoc
argument_list|()
expr_stmt|;
specifier|final
name|int
name|lastDocRequested
init|=
name|last
decl_stmt|;
name|int
name|nDocsReturned
decl_stmt|;
name|int
name|totalHits
decl_stmt|;
name|float
name|maxScore
decl_stmt|;
name|int
index|[]
name|ids
decl_stmt|;
name|float
index|[]
name|scores
decl_stmt|;
name|DocSet
name|set
decl_stmt|;
name|boolean
name|needScores
init|=
operator|(
name|cmd
operator|.
name|getFlags
argument_list|()
operator|&
name|GET_SCORES
operator|)
operator|!=
literal|0
decl_stmt|;
name|int
name|maxDoc
init|=
name|maxDoc
argument_list|()
decl_stmt|;
name|int
name|smallSetSize
init|=
name|maxDoc
operator|>>
literal|6
decl_stmt|;
name|Query
name|query
init|=
name|QueryUtils
operator|.
name|makeQueryable
argument_list|(
name|cmd
operator|.
name|getQuery
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|long
name|timeAllowed
init|=
name|cmd
operator|.
name|getTimeAllowed
argument_list|()
decl_stmt|;
specifier|final
name|Filter
name|luceneFilter
init|=
name|filter
operator|==
literal|null
condition|?
literal|null
else|:
name|filter
operator|.
name|getTopFilter
argument_list|()
decl_stmt|;
comment|// handle zero case...
if|if
condition|(
name|lastDocRequested
operator|<=
literal|0
condition|)
block|{
specifier|final
name|float
index|[]
name|topscore
init|=
operator|new
name|float
index|[]
block|{
name|Float
operator|.
name|NEGATIVE_INFINITY
block|}
decl_stmt|;
name|Collector
name|collector
decl_stmt|;
name|DocSetCollector
name|setCollector
decl_stmt|;
if|if
condition|(
operator|!
name|needScores
condition|)
block|{
name|collector
operator|=
name|setCollector
operator|=
operator|new
name|DocSetCollector
argument_list|(
name|smallSetSize
argument_list|,
name|maxDoc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|collector
operator|=
name|setCollector
operator|=
operator|new
name|DocSetDelegateCollector
argument_list|(
name|smallSetSize
argument_list|,
name|maxDoc
argument_list|,
operator|new
name|Collector
argument_list|()
block|{
name|Scorer
name|scorer
decl_stmt|;
annotation|@
name|Override
specifier|public
name|void
name|setScorer
parameter_list|(
name|Scorer
name|scorer
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|scorer
operator|=
name|scorer
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|collect
parameter_list|(
name|int
name|doc
parameter_list|)
throws|throws
name|IOException
block|{
name|float
name|score
init|=
name|scorer
operator|.
name|score
argument_list|()
decl_stmt|;
if|if
condition|(
name|score
operator|>
name|topscore
index|[
literal|0
index|]
condition|)
name|topscore
index|[
literal|0
index|]
operator|=
name|score
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|setNextReader
parameter_list|(
name|AtomicReaderContext
name|context
parameter_list|)
throws|throws
name|IOException
block|{            }
annotation|@
name|Override
specifier|public
name|boolean
name|acceptsDocsOutOfOrder
parameter_list|()
block|{
return|return
literal|false
return|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|timeAllowed
operator|>
literal|0
condition|)
block|{
name|collector
operator|=
operator|new
name|TimeLimitingCollector
argument_list|(
name|collector
argument_list|,
name|timeAllowed
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|super
operator|.
name|search
argument_list|(
name|query
argument_list|,
name|luceneFilter
argument_list|,
name|collector
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|TimeLimitingCollector
operator|.
name|TimeExceededException
name|x
parameter_list|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Query: "
operator|+
name|query
operator|+
literal|"; "
operator|+
name|x
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
name|qr
operator|.
name|setPartialResults
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
name|set
operator|=
name|setCollector
operator|.
name|getDocSet
argument_list|()
expr_stmt|;
name|nDocsReturned
operator|=
literal|0
expr_stmt|;
name|ids
operator|=
operator|new
name|int
index|[
name|nDocsReturned
index|]
expr_stmt|;
name|scores
operator|=
operator|new
name|float
index|[
name|nDocsReturned
index|]
expr_stmt|;
name|totalHits
operator|=
name|set
operator|.
name|size
argument_list|()
expr_stmt|;
name|maxScore
operator|=
name|totalHits
operator|>
literal|0
condition|?
name|topscore
index|[
literal|0
index|]
else|:
literal|0.0f
expr_stmt|;
block|}
else|else
block|{
name|TopDocsCollector
name|topCollector
decl_stmt|;
if|if
condition|(
name|cmd
operator|.
name|getSort
argument_list|()
operator|==
literal|null
condition|)
block|{
name|topCollector
operator|=
name|TopScoreDocCollector
operator|.
name|create
argument_list|(
name|len
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|topCollector
operator|=
name|TopFieldCollector
operator|.
name|create
argument_list|(
name|weightSort
argument_list|(
name|cmd
operator|.
name|getSort
argument_list|()
argument_list|)
argument_list|,
name|len
argument_list|,
literal|false
argument_list|,
name|needScores
argument_list|,
name|needScores
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
name|DocSetCollector
name|setCollector
init|=
operator|new
name|DocSetDelegateCollector
argument_list|(
name|maxDoc
operator|>>
literal|6
argument_list|,
name|maxDoc
argument_list|,
name|topCollector
argument_list|)
decl_stmt|;
name|Collector
name|collector
init|=
name|setCollector
decl_stmt|;
if|if
condition|(
name|timeAllowed
operator|>
literal|0
condition|)
block|{
name|collector
operator|=
operator|new
name|TimeLimitingCollector
argument_list|(
name|collector
argument_list|,
name|timeAllowed
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|super
operator|.
name|search
argument_list|(
name|query
argument_list|,
name|luceneFilter
argument_list|,
name|collector
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|TimeLimitingCollector
operator|.
name|TimeExceededException
name|x
parameter_list|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Query: "
operator|+
name|query
operator|+
literal|"; "
operator|+
name|x
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
name|qr
operator|.
name|setPartialResults
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
name|set
operator|=
name|setCollector
operator|.
name|getDocSet
argument_list|()
expr_stmt|;
name|totalHits
operator|=
name|topCollector
operator|.
name|getTotalHits
argument_list|()
expr_stmt|;
assert|assert
operator|(
name|totalHits
operator|==
name|set
operator|.
name|size
argument_list|()
operator|)
assert|;
name|TopDocs
name|topDocs
init|=
name|topCollector
operator|.
name|topDocs
argument_list|(
literal|0
argument_list|,
name|len
argument_list|)
decl_stmt|;
name|maxScore
operator|=
name|totalHits
operator|>
literal|0
condition|?
name|topDocs
operator|.
name|getMaxScore
argument_list|()
else|:
literal|0.0f
expr_stmt|;
name|nDocsReturned
operator|=
name|topDocs
operator|.
name|scoreDocs
operator|.
name|length
expr_stmt|;
name|ids
operator|=
operator|new
name|int
index|[
name|nDocsReturned
index|]
expr_stmt|;
name|scores
operator|=
operator|(
name|cmd
operator|.
name|getFlags
argument_list|()
operator|&
name|GET_SCORES
operator|)
operator|!=
literal|0
condition|?
operator|new
name|float
index|[
name|nDocsReturned
index|]
else|:
literal|null
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nDocsReturned
condition|;
name|i
operator|++
control|)
block|{
name|ScoreDoc
name|scoreDoc
init|=
name|topDocs
operator|.
name|scoreDocs
index|[
name|i
index|]
decl_stmt|;
name|ids
index|[
name|i
index|]
operator|=
name|scoreDoc
operator|.
name|doc
expr_stmt|;
if|if
condition|(
name|scores
operator|!=
literal|null
condition|)
name|scores
index|[
name|i
index|]
operator|=
name|scoreDoc
operator|.
name|score
expr_stmt|;
block|}
block|}
name|int
name|sliceLen
init|=
name|Math
operator|.
name|min
argument_list|(
name|lastDocRequested
argument_list|,
name|nDocsReturned
argument_list|)
decl_stmt|;
if|if
condition|(
name|sliceLen
operator|<
literal|0
condition|)
name|sliceLen
operator|=
literal|0
expr_stmt|;
name|qr
operator|.
name|setDocList
argument_list|(
operator|new
name|DocSlice
argument_list|(
literal|0
argument_list|,
name|sliceLen
argument_list|,
name|ids
argument_list|,
name|scores
argument_list|,
name|totalHits
argument_list|,
name|maxScore
argument_list|)
argument_list|)
expr_stmt|;
comment|// TODO: if we collect results before the filter, we just need to intersect with
comment|// that filter to generate the DocSet for qr.setDocSet()
name|qr
operator|.
name|setDocSet
argument_list|(
name|set
argument_list|)
expr_stmt|;
comment|// TODO: currently we don't generate the DocSet for the base query,
comment|// but the QueryDocSet == CompleteDocSet if filter==null.
return|return
name|filter
operator|==
literal|null
condition|?
name|qr
operator|.
name|getDocSet
argument_list|()
else|:
literal|null
return|;
block|}
comment|/**    * Returns documents matching both<code>query</code> and<code>filter</code>    * and sorted by<code>sort</code>.    * FUTURE: The returned DocList may be retrieved from a cache.    *    * @param query    * @param filter   may be null    * @param lsort    criteria by which to sort (if null, query relevance is used)    * @param offset   offset into the list of documents to return    * @param len      maximum number of documents to return    * @return DocList meeting the specified criteria, should<b>not</b> be modified by the caller.    * @throws IOException    */
DECL|method|getDocList
specifier|public
name|DocList
name|getDocList
parameter_list|(
name|Query
name|query
parameter_list|,
name|DocSet
name|filter
parameter_list|,
name|Sort
name|lsort
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|len
parameter_list|)
throws|throws
name|IOException
block|{
name|QueryCommand
name|qc
init|=
operator|new
name|QueryCommand
argument_list|()
decl_stmt|;
name|qc
operator|.
name|setQuery
argument_list|(
name|query
argument_list|)
operator|.
name|setFilter
argument_list|(
name|filter
argument_list|)
operator|.
name|setSort
argument_list|(
name|lsort
argument_list|)
operator|.
name|setOffset
argument_list|(
name|offset
argument_list|)
operator|.
name|setLen
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|QueryResult
name|qr
init|=
operator|new
name|QueryResult
argument_list|()
decl_stmt|;
name|search
argument_list|(
name|qr
argument_list|,
name|qc
argument_list|)
expr_stmt|;
return|return
name|qr
operator|.
name|getDocList
argument_list|()
return|;
block|}
comment|/**    * Returns documents matching both<code>query</code> and<code>filter</code>    * and sorted by<code>sort</code>.  Also returns the complete set of documents    * matching<code>query</code> and<code>filter</code> (regardless of<code>offset</code> and<code>len</code>).    *<p>    * This method is cache aware and may retrieve<code>filter</code> from    * the cache or make an insertion into the cache as a result of this call.    *<p>    * FUTURE: The returned DocList may be retrieved from a cache.    *<p>    * The DocList and DocSet returned should<b>not</b> be modified.    *    * @param query    * @param filter   may be null    * @param lsort    criteria by which to sort (if null, query relevance is used)    * @param offset   offset into the list of documents to return    * @param len      maximum number of documents to return    * @return DocListAndSet meeting the specified criteria, should<b>not</b> be modified by the caller.    * @throws IOException    */
DECL|method|getDocListAndSet
specifier|public
name|DocListAndSet
name|getDocListAndSet
parameter_list|(
name|Query
name|query
parameter_list|,
name|Query
name|filter
parameter_list|,
name|Sort
name|lsort
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|len
parameter_list|)
throws|throws
name|IOException
block|{
name|QueryCommand
name|qc
init|=
operator|new
name|QueryCommand
argument_list|()
decl_stmt|;
name|qc
operator|.
name|setQuery
argument_list|(
name|query
argument_list|)
operator|.
name|setFilterList
argument_list|(
name|filter
argument_list|)
operator|.
name|setSort
argument_list|(
name|lsort
argument_list|)
operator|.
name|setOffset
argument_list|(
name|offset
argument_list|)
operator|.
name|setLen
argument_list|(
name|len
argument_list|)
operator|.
name|setNeedDocSet
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|QueryResult
name|qr
init|=
operator|new
name|QueryResult
argument_list|()
decl_stmt|;
name|search
argument_list|(
name|qr
argument_list|,
name|qc
argument_list|)
expr_stmt|;
return|return
name|qr
operator|.
name|getDocListAndSet
argument_list|()
return|;
block|}
comment|/**    * Returns documents matching both<code>query</code> and<code>filter</code>    * and sorted by<code>sort</code>.  Also returns the compete set of documents    * matching<code>query</code> and<code>filter</code> (regardless of<code>offset</code> and<code>len</code>).    *<p>    * This method is cache aware and may retrieve<code>filter</code> from    * the cache or make an insertion into the cache as a result of this call.    *<p>    * FUTURE: The returned DocList may be retrieved from a cache.    *<p>    * The DocList and DocSet returned should<b>not</b> be modified.    *    * @param query    * @param filter   may be null    * @param lsort    criteria by which to sort (if null, query relevance is used)    * @param offset   offset into the list of documents to return    * @param len      maximum number of documents to return    * @param flags    user supplied flags for the result set    * @return DocListAndSet meeting the specified criteria, should<b>not</b> be modified by the caller.    * @throws IOException    */
DECL|method|getDocListAndSet
specifier|public
name|DocListAndSet
name|getDocListAndSet
parameter_list|(
name|Query
name|query
parameter_list|,
name|Query
name|filter
parameter_list|,
name|Sort
name|lsort
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|flags
parameter_list|)
throws|throws
name|IOException
block|{
name|QueryCommand
name|qc
init|=
operator|new
name|QueryCommand
argument_list|()
decl_stmt|;
name|qc
operator|.
name|setQuery
argument_list|(
name|query
argument_list|)
operator|.
name|setFilterList
argument_list|(
name|filter
argument_list|)
operator|.
name|setSort
argument_list|(
name|lsort
argument_list|)
operator|.
name|setOffset
argument_list|(
name|offset
argument_list|)
operator|.
name|setLen
argument_list|(
name|len
argument_list|)
operator|.
name|setFlags
argument_list|(
name|flags
argument_list|)
operator|.
name|setNeedDocSet
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|QueryResult
name|qr
init|=
operator|new
name|QueryResult
argument_list|()
decl_stmt|;
name|search
argument_list|(
name|qr
argument_list|,
name|qc
argument_list|)
expr_stmt|;
return|return
name|qr
operator|.
name|getDocListAndSet
argument_list|()
return|;
block|}
comment|/**    * Returns documents matching both<code>query</code> and the intersection     * of<code>filterList</code>, sorted by<code>sort</code>.      * Also returns the compete set of documents    * matching<code>query</code> and<code>filter</code>     * (regardless of<code>offset</code> and<code>len</code>).    *<p>    * This method is cache aware and may retrieve<code>filter</code> from    * the cache or make an insertion into the cache as a result of this call.    *<p>    * FUTURE: The returned DocList may be retrieved from a cache.    *<p>    * The DocList and DocSet returned should<b>not</b> be modified.    *    * @param query    * @param filterList   may be null    * @param lsort    criteria by which to sort (if null, query relevance is used)    * @param offset   offset into the list of documents to return    * @param len      maximum number of documents to return    * @return DocListAndSet meeting the specified criteria, should<b>not</b> be modified by the caller.    * @throws IOException    */
DECL|method|getDocListAndSet
specifier|public
name|DocListAndSet
name|getDocListAndSet
parameter_list|(
name|Query
name|query
parameter_list|,
name|List
argument_list|<
name|Query
argument_list|>
name|filterList
parameter_list|,
name|Sort
name|lsort
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|len
parameter_list|)
throws|throws
name|IOException
block|{
name|QueryCommand
name|qc
init|=
operator|new
name|QueryCommand
argument_list|()
decl_stmt|;
name|qc
operator|.
name|setQuery
argument_list|(
name|query
argument_list|)
operator|.
name|setFilterList
argument_list|(
name|filterList
argument_list|)
operator|.
name|setSort
argument_list|(
name|lsort
argument_list|)
operator|.
name|setOffset
argument_list|(
name|offset
argument_list|)
operator|.
name|setLen
argument_list|(
name|len
argument_list|)
operator|.
name|setNeedDocSet
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|QueryResult
name|qr
init|=
operator|new
name|QueryResult
argument_list|()
decl_stmt|;
name|search
argument_list|(
name|qr
argument_list|,
name|qc
argument_list|)
expr_stmt|;
return|return
name|qr
operator|.
name|getDocListAndSet
argument_list|()
return|;
block|}
comment|/**    * Returns documents matching both<code>query</code> and the intersection     * of<code>filterList</code>, sorted by<code>sort</code>.      * Also returns the compete set of documents    * matching<code>query</code> and<code>filter</code>     * (regardless of<code>offset</code> and<code>len</code>).    *<p>    * This method is cache aware and may retrieve<code>filter</code> from    * the cache or make an insertion into the cache as a result of this call.    *<p>    * FUTURE: The returned DocList may be retrieved from a cache.    *<p>    * The DocList and DocSet returned should<b>not</b> be modified.    *    * @param query    * @param filterList   may be null    * @param lsort    criteria by which to sort (if null, query relevance is used)    * @param offset   offset into the list of documents to return    * @param len      maximum number of documents to return    * @param flags    user supplied flags for the result set    * @return DocListAndSet meeting the specified criteria, should<b>not</b> be modified by the caller.    * @throws IOException    */
DECL|method|getDocListAndSet
specifier|public
name|DocListAndSet
name|getDocListAndSet
parameter_list|(
name|Query
name|query
parameter_list|,
name|List
argument_list|<
name|Query
argument_list|>
name|filterList
parameter_list|,
name|Sort
name|lsort
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|flags
parameter_list|)
throws|throws
name|IOException
block|{
name|QueryCommand
name|qc
init|=
operator|new
name|QueryCommand
argument_list|()
decl_stmt|;
name|qc
operator|.
name|setQuery
argument_list|(
name|query
argument_list|)
operator|.
name|setFilterList
argument_list|(
name|filterList
argument_list|)
operator|.
name|setSort
argument_list|(
name|lsort
argument_list|)
operator|.
name|setOffset
argument_list|(
name|offset
argument_list|)
operator|.
name|setLen
argument_list|(
name|len
argument_list|)
operator|.
name|setFlags
argument_list|(
name|flags
argument_list|)
operator|.
name|setNeedDocSet
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|QueryResult
name|qr
init|=
operator|new
name|QueryResult
argument_list|()
decl_stmt|;
name|search
argument_list|(
name|qr
argument_list|,
name|qc
argument_list|)
expr_stmt|;
return|return
name|qr
operator|.
name|getDocListAndSet
argument_list|()
return|;
block|}
comment|/**    * Returns documents matching both<code>query</code> and<code>filter</code>    * and sorted by<code>sort</code>. Also returns the compete set of documents    * matching<code>query</code> and<code>filter</code> (regardless of<code>offset</code> and<code>len</code>).    *<p>    * FUTURE: The returned DocList may be retrieved from a cache.    *    * @param query    * @param filter   may be null    * @param lsort    criteria by which to sort (if null, query relevance is used)    * @param offset   offset into the list of documents to return    * @param len      maximum number of documents to return    * @return DocListAndSet meeting the specified criteria, should<b>not</b> be modified by the caller.    * @throws IOException    */
DECL|method|getDocListAndSet
specifier|public
name|DocListAndSet
name|getDocListAndSet
parameter_list|(
name|Query
name|query
parameter_list|,
name|DocSet
name|filter
parameter_list|,
name|Sort
name|lsort
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|len
parameter_list|)
throws|throws
name|IOException
block|{
name|QueryCommand
name|qc
init|=
operator|new
name|QueryCommand
argument_list|()
decl_stmt|;
name|qc
operator|.
name|setQuery
argument_list|(
name|query
argument_list|)
operator|.
name|setFilter
argument_list|(
name|filter
argument_list|)
operator|.
name|setSort
argument_list|(
name|lsort
argument_list|)
operator|.
name|setOffset
argument_list|(
name|offset
argument_list|)
operator|.
name|setLen
argument_list|(
name|len
argument_list|)
operator|.
name|setNeedDocSet
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|QueryResult
name|qr
init|=
operator|new
name|QueryResult
argument_list|()
decl_stmt|;
name|search
argument_list|(
name|qr
argument_list|,
name|qc
argument_list|)
expr_stmt|;
return|return
name|qr
operator|.
name|getDocListAndSet
argument_list|()
return|;
block|}
comment|/**    * Returns documents matching both<code>query</code> and<code>filter</code>    * and sorted by<code>sort</code>.  Also returns the compete set of documents    * matching<code>query</code> and<code>filter</code> (regardless of<code>offset</code> and<code>len</code>).    *<p>    * This method is cache aware and may make an insertion into the cache     * as a result of this call.    *<p>    * FUTURE: The returned DocList may be retrieved from a cache.    *<p>    * The DocList and DocSet returned should<b>not</b> be modified.    *    * @param query    * @param filter   may be null    * @param lsort    criteria by which to sort (if null, query relevance is used)    * @param offset   offset into the list of documents to return    * @param len      maximum number of documents to return    * @param flags    user supplied flags for the result set    * @return DocListAndSet meeting the specified criteria, should<b>not</b> be modified by the caller.    * @throws IOException    */
DECL|method|getDocListAndSet
specifier|public
name|DocListAndSet
name|getDocListAndSet
parameter_list|(
name|Query
name|query
parameter_list|,
name|DocSet
name|filter
parameter_list|,
name|Sort
name|lsort
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|flags
parameter_list|)
throws|throws
name|IOException
block|{
name|QueryCommand
name|qc
init|=
operator|new
name|QueryCommand
argument_list|()
decl_stmt|;
name|qc
operator|.
name|setQuery
argument_list|(
name|query
argument_list|)
operator|.
name|setFilter
argument_list|(
name|filter
argument_list|)
operator|.
name|setSort
argument_list|(
name|lsort
argument_list|)
operator|.
name|setOffset
argument_list|(
name|offset
argument_list|)
operator|.
name|setLen
argument_list|(
name|len
argument_list|)
operator|.
name|setFlags
argument_list|(
name|flags
argument_list|)
operator|.
name|setNeedDocSet
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|QueryResult
name|qr
init|=
operator|new
name|QueryResult
argument_list|()
decl_stmt|;
name|search
argument_list|(
name|qr
argument_list|,
name|qc
argument_list|)
expr_stmt|;
return|return
name|qr
operator|.
name|getDocListAndSet
argument_list|()
return|;
block|}
DECL|method|sortDocSet
specifier|protected
name|DocList
name|sortDocSet
parameter_list|(
name|DocSet
name|set
parameter_list|,
name|Sort
name|sort
parameter_list|,
name|int
name|nDocs
parameter_list|)
throws|throws
name|IOException
block|{
comment|// bit of a hack to tell if a set is sorted - do it better in the futute.
name|boolean
name|inOrder
init|=
name|set
operator|instanceof
name|BitDocSet
operator|||
name|set
operator|instanceof
name|SortedIntDocSet
decl_stmt|;
name|TopDocsCollector
name|topCollector
init|=
name|TopFieldCollector
operator|.
name|create
argument_list|(
name|weightSort
argument_list|(
name|sort
argument_list|)
argument_list|,
name|nDocs
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|,
name|inOrder
argument_list|)
decl_stmt|;
name|DocIterator
name|iter
init|=
name|set
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|int
name|base
init|=
literal|0
decl_stmt|;
name|int
name|end
init|=
literal|0
decl_stmt|;
name|int
name|readerIndex
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|iter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|int
name|doc
init|=
name|iter
operator|.
name|nextDoc
argument_list|()
decl_stmt|;
while|while
condition|(
name|doc
operator|>=
name|end
condition|)
block|{
name|AtomicReaderContext
name|leaf
init|=
name|leafContexts
index|[
name|readerIndex
operator|++
index|]
decl_stmt|;
name|base
operator|=
name|leaf
operator|.
name|docBase
expr_stmt|;
name|end
operator|=
name|base
operator|+
name|leaf
operator|.
name|reader
operator|.
name|maxDoc
argument_list|()
expr_stmt|;
name|topCollector
operator|.
name|setNextReader
argument_list|(
name|leaf
argument_list|)
expr_stmt|;
comment|// we should never need to set the scorer given the settings for the collector
block|}
name|topCollector
operator|.
name|collect
argument_list|(
name|doc
operator|-
name|base
argument_list|)
expr_stmt|;
block|}
name|TopDocs
name|topDocs
init|=
name|topCollector
operator|.
name|topDocs
argument_list|(
literal|0
argument_list|,
name|nDocs
argument_list|)
decl_stmt|;
name|int
name|nDocsReturned
init|=
name|topDocs
operator|.
name|scoreDocs
operator|.
name|length
decl_stmt|;
name|int
index|[]
name|ids
init|=
operator|new
name|int
index|[
name|nDocsReturned
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nDocsReturned
condition|;
name|i
operator|++
control|)
block|{
name|ScoreDoc
name|scoreDoc
init|=
name|topDocs
operator|.
name|scoreDocs
index|[
name|i
index|]
decl_stmt|;
name|ids
index|[
name|i
index|]
operator|=
name|scoreDoc
operator|.
name|doc
expr_stmt|;
block|}
return|return
operator|new
name|DocSlice
argument_list|(
literal|0
argument_list|,
name|nDocsReturned
argument_list|,
name|ids
argument_list|,
literal|null
argument_list|,
name|topDocs
operator|.
name|totalHits
argument_list|,
literal|0.0f
argument_list|)
return|;
block|}
comment|/**    * Returns the number of documents that match both<code>a</code> and<code>b</code>.    *<p>    * This method is cache-aware and may check as well as modify the cache.    *    * @param a    * @param b    * @return the numer of documents in the intersection between<code>a</code> and<code>b</code>.    * @throws IOException    */
DECL|method|numDocs
specifier|public
name|int
name|numDocs
parameter_list|(
name|Query
name|a
parameter_list|,
name|DocSet
name|b
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Negative query if absolute value different from original
name|Query
name|absQ
init|=
name|QueryUtils
operator|.
name|getAbs
argument_list|(
name|a
argument_list|)
decl_stmt|;
name|DocSet
name|positiveA
init|=
name|getPositiveDocSet
argument_list|(
name|absQ
argument_list|)
decl_stmt|;
return|return
name|a
operator|==
name|absQ
condition|?
name|b
operator|.
name|intersectionSize
argument_list|(
name|positiveA
argument_list|)
else|:
name|b
operator|.
name|andNotSize
argument_list|(
name|positiveA
argument_list|)
return|;
block|}
comment|/** @lucene.internal */
DECL|method|numDocs
specifier|public
name|int
name|numDocs
parameter_list|(
name|Query
name|a
parameter_list|,
name|DocSet
name|b
parameter_list|,
name|DocsEnumState
name|deState
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Negative query if absolute value different from original
name|Query
name|absQ
init|=
name|QueryUtils
operator|.
name|getAbs
argument_list|(
name|a
argument_list|)
decl_stmt|;
name|DocSet
name|positiveA
init|=
name|getPositiveDocSet
argument_list|(
name|absQ
argument_list|,
name|deState
argument_list|)
decl_stmt|;
return|return
name|a
operator|==
name|absQ
condition|?
name|b
operator|.
name|intersectionSize
argument_list|(
name|positiveA
argument_list|)
else|:
name|b
operator|.
name|andNotSize
argument_list|(
name|positiveA
argument_list|)
return|;
block|}
DECL|class|DocsEnumState
specifier|public
specifier|static
class|class
name|DocsEnumState
block|{
DECL|field|termsEnum
specifier|public
name|TermsEnum
name|termsEnum
decl_stmt|;
DECL|field|deletedDocs
specifier|public
name|Bits
name|deletedDocs
decl_stmt|;
DECL|field|reuse
specifier|public
name|DocsEnum
name|reuse
decl_stmt|;
block|}
comment|/**    * Returns the number of documents that match both<code>a</code> and<code>b</code>.    *<p>    * This method is cache-aware and may check as well as modify the cache.    *    * @param a    * @param b    * @return the numer of documents in the intersection between<code>a</code> and<code>b</code>.    * @throws IOException    */
DECL|method|numDocs
specifier|public
name|int
name|numDocs
parameter_list|(
name|Query
name|a
parameter_list|,
name|Query
name|b
parameter_list|)
throws|throws
name|IOException
block|{
name|Query
name|absA
init|=
name|QueryUtils
operator|.
name|getAbs
argument_list|(
name|a
argument_list|)
decl_stmt|;
name|Query
name|absB
init|=
name|QueryUtils
operator|.
name|getAbs
argument_list|(
name|b
argument_list|)
decl_stmt|;
name|DocSet
name|positiveA
init|=
name|getPositiveDocSet
argument_list|(
name|absA
argument_list|)
decl_stmt|;
name|DocSet
name|positiveB
init|=
name|getPositiveDocSet
argument_list|(
name|absB
argument_list|)
decl_stmt|;
comment|// Negative query if absolute value different from original
if|if
condition|(
name|a
operator|==
name|absA
condition|)
block|{
if|if
condition|(
name|b
operator|==
name|absB
condition|)
return|return
name|positiveA
operator|.
name|intersectionSize
argument_list|(
name|positiveB
argument_list|)
return|;
return|return
name|positiveA
operator|.
name|andNotSize
argument_list|(
name|positiveB
argument_list|)
return|;
block|}
if|if
condition|(
name|b
operator|==
name|absB
condition|)
return|return
name|positiveB
operator|.
name|andNotSize
argument_list|(
name|positiveA
argument_list|)
return|;
comment|// if both negative, we need to create a temp DocSet since we
comment|// don't have a counting method that takes three.
name|DocSet
name|all
init|=
name|getPositiveDocSet
argument_list|(
name|matchAllDocsQuery
argument_list|)
decl_stmt|;
comment|// -a -b == *:*.andNot(a).andNotSize(b) == *.*.andNotSize(a.union(b))
comment|// we use the last form since the intermediate DocSet should normally be smaller.
return|return
name|all
operator|.
name|andNotSize
argument_list|(
name|positiveA
operator|.
name|union
argument_list|(
name|positiveB
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Takes a list of docs (the doc ids actually), and returns an array     * of Documents containing all of the stored fields.    */
DECL|method|readDocs
specifier|public
name|Document
index|[]
name|readDocs
parameter_list|(
name|DocList
name|ids
parameter_list|)
throws|throws
name|IOException
block|{
name|Document
index|[]
name|docs
init|=
operator|new
name|Document
index|[
name|ids
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
name|readDocs
argument_list|(
name|docs
argument_list|,
name|ids
argument_list|)
expr_stmt|;
return|return
name|docs
return|;
block|}
comment|/**    * Warm this searcher based on an old one (primarily for auto-cache warming).    */
DECL|method|warm
specifier|public
name|void
name|warm
parameter_list|(
name|SolrIndexSearcher
name|old
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Make sure this is first!  filters can help queryResults execute!
name|boolean
name|logme
init|=
name|log
operator|.
name|isInfoEnabled
argument_list|()
decl_stmt|;
name|long
name|warmingStartTime
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
comment|// warm the caches in order...
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|cacheList
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|logme
condition|)
name|log
operator|.
name|info
argument_list|(
literal|"autowarming "
operator|+
name|this
operator|+
literal|" from "
operator|+
name|old
operator|+
literal|"\n\t"
operator|+
name|old
operator|.
name|cacheList
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|this
operator|.
name|cacheList
index|[
name|i
index|]
operator|.
name|warm
argument_list|(
name|this
argument_list|,
name|old
operator|.
name|cacheList
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|logme
condition|)
name|log
operator|.
name|info
argument_list|(
literal|"autowarming result for "
operator|+
name|this
operator|+
literal|"\n\t"
operator|+
name|this
operator|.
name|cacheList
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|warmupTime
operator|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|-
name|warmingStartTime
expr_stmt|;
block|}
comment|/**    * return the named generic cache    */
DECL|method|getCache
specifier|public
name|SolrCache
name|getCache
parameter_list|(
name|String
name|cacheName
parameter_list|)
block|{
return|return
name|cacheMap
operator|.
name|get
argument_list|(
name|cacheName
argument_list|)
return|;
block|}
comment|/**    * lookup an entry in a generic cache    */
DECL|method|cacheLookup
specifier|public
name|Object
name|cacheLookup
parameter_list|(
name|String
name|cacheName
parameter_list|,
name|Object
name|key
parameter_list|)
block|{
name|SolrCache
name|cache
init|=
name|cacheMap
operator|.
name|get
argument_list|(
name|cacheName
argument_list|)
decl_stmt|;
return|return
name|cache
operator|==
literal|null
condition|?
literal|null
else|:
name|cache
operator|.
name|get
argument_list|(
name|key
argument_list|)
return|;
block|}
comment|/**    * insert an entry in a generic cache    */
DECL|method|cacheInsert
specifier|public
name|Object
name|cacheInsert
parameter_list|(
name|String
name|cacheName
parameter_list|,
name|Object
name|key
parameter_list|,
name|Object
name|val
parameter_list|)
block|{
name|SolrCache
name|cache
init|=
name|cacheMap
operator|.
name|get
argument_list|(
name|cacheName
argument_list|)
decl_stmt|;
return|return
name|cache
operator|==
literal|null
condition|?
literal|null
else|:
name|cache
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|val
argument_list|)
return|;
block|}
DECL|method|getOpenTime
specifier|public
name|long
name|getOpenTime
parameter_list|()
block|{
return|return
name|openTime
return|;
block|}
comment|/////////////////////////////////////////////////////////////////////
comment|// SolrInfoMBean stuff: Statistics and Module Info
comment|/////////////////////////////////////////////////////////////////////
DECL|method|getName
specifier|public
name|String
name|getName
parameter_list|()
block|{
return|return
name|SolrIndexSearcher
operator|.
name|class
operator|.
name|getName
argument_list|()
return|;
block|}
DECL|method|getVersion
specifier|public
name|String
name|getVersion
parameter_list|()
block|{
return|return
name|SolrCore
operator|.
name|version
return|;
block|}
DECL|method|getDescription
specifier|public
name|String
name|getDescription
parameter_list|()
block|{
return|return
literal|"index searcher"
return|;
block|}
DECL|method|getCategory
specifier|public
name|Category
name|getCategory
parameter_list|()
block|{
return|return
name|Category
operator|.
name|CORE
return|;
block|}
DECL|method|getSourceId
specifier|public
name|String
name|getSourceId
parameter_list|()
block|{
return|return
literal|"$Id$"
return|;
block|}
DECL|method|getSource
specifier|public
name|String
name|getSource
parameter_list|()
block|{
return|return
literal|"$URL$"
return|;
block|}
DECL|method|getDocs
specifier|public
name|URL
index|[]
name|getDocs
parameter_list|()
block|{
return|return
literal|null
return|;
block|}
DECL|method|getStatistics
specifier|public
name|NamedList
argument_list|<
name|Object
argument_list|>
name|getStatistics
parameter_list|()
block|{
name|NamedList
argument_list|<
name|Object
argument_list|>
name|lst
init|=
operator|new
name|SimpleOrderedMap
argument_list|<
name|Object
argument_list|>
argument_list|()
decl_stmt|;
name|lst
operator|.
name|add
argument_list|(
literal|"searcherName"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|lst
operator|.
name|add
argument_list|(
literal|"caching"
argument_list|,
name|cachingEnabled
argument_list|)
expr_stmt|;
name|lst
operator|.
name|add
argument_list|(
literal|"numDocs"
argument_list|,
name|reader
operator|.
name|numDocs
argument_list|()
argument_list|)
expr_stmt|;
name|lst
operator|.
name|add
argument_list|(
literal|"maxDoc"
argument_list|,
name|reader
operator|.
name|maxDoc
argument_list|()
argument_list|)
expr_stmt|;
name|lst
operator|.
name|add
argument_list|(
literal|"reader"
argument_list|,
name|reader
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|lst
operator|.
name|add
argument_list|(
literal|"readerDir"
argument_list|,
name|reader
operator|.
name|directory
argument_list|()
argument_list|)
expr_stmt|;
name|lst
operator|.
name|add
argument_list|(
literal|"indexVersion"
argument_list|,
name|reader
operator|.
name|getVersion
argument_list|()
argument_list|)
expr_stmt|;
name|lst
operator|.
name|add
argument_list|(
literal|"openedAt"
argument_list|,
operator|new
name|Date
argument_list|(
name|openTime
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|registerTime
operator|!=
literal|0
condition|)
name|lst
operator|.
name|add
argument_list|(
literal|"registeredAt"
argument_list|,
operator|new
name|Date
argument_list|(
name|registerTime
argument_list|)
argument_list|)
expr_stmt|;
name|lst
operator|.
name|add
argument_list|(
literal|"warmupTime"
argument_list|,
name|warmupTime
argument_list|)
expr_stmt|;
return|return
name|lst
return|;
block|}
comment|/**    * A query request command to avoid having to change the method signatures    * if we want to pass additional information to the searcher.    */
DECL|class|QueryCommand
specifier|public
specifier|static
class|class
name|QueryCommand
block|{
DECL|field|query
specifier|private
name|Query
name|query
decl_stmt|;
DECL|field|filterList
specifier|private
name|List
argument_list|<
name|Query
argument_list|>
name|filterList
decl_stmt|;
DECL|field|filter
specifier|private
name|DocSet
name|filter
decl_stmt|;
DECL|field|sort
specifier|private
name|Sort
name|sort
decl_stmt|;
DECL|field|offset
specifier|private
name|int
name|offset
decl_stmt|;
DECL|field|len
specifier|private
name|int
name|len
decl_stmt|;
DECL|field|supersetMaxDoc
specifier|private
name|int
name|supersetMaxDoc
decl_stmt|;
DECL|field|flags
specifier|private
name|int
name|flags
decl_stmt|;
DECL|field|timeAllowed
specifier|private
name|long
name|timeAllowed
init|=
operator|-
literal|1
decl_stmt|;
comment|// public List<Grouping.Command> groupCommands;
DECL|method|getQuery
specifier|public
name|Query
name|getQuery
parameter_list|()
block|{
return|return
name|query
return|;
block|}
DECL|method|setQuery
specifier|public
name|QueryCommand
name|setQuery
parameter_list|(
name|Query
name|query
parameter_list|)
block|{
name|this
operator|.
name|query
operator|=
name|query
expr_stmt|;
return|return
name|this
return|;
block|}
DECL|method|getFilterList
specifier|public
name|List
argument_list|<
name|Query
argument_list|>
name|getFilterList
parameter_list|()
block|{
return|return
name|filterList
return|;
block|}
comment|/**      * @throws IllegalArgumentException if filter is not null.      */
DECL|method|setFilterList
specifier|public
name|QueryCommand
name|setFilterList
parameter_list|(
name|List
argument_list|<
name|Query
argument_list|>
name|filterList
parameter_list|)
block|{
if|if
condition|(
name|filter
operator|!=
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Either filter or filterList may be set in the QueryCommand, but not both."
argument_list|)
throw|;
block|}
name|this
operator|.
name|filterList
operator|=
name|filterList
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**      * A simple setter to build a filterList from a query      * @throws IllegalArgumentException if filter is not null.      */
DECL|method|setFilterList
specifier|public
name|QueryCommand
name|setFilterList
parameter_list|(
name|Query
name|f
parameter_list|)
block|{
if|if
condition|(
name|filter
operator|!=
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Either filter or filterList may be set in the QueryCommand, but not both."
argument_list|)
throw|;
block|}
name|filterList
operator|=
literal|null
expr_stmt|;
if|if
condition|(
name|f
operator|!=
literal|null
condition|)
block|{
name|filterList
operator|=
operator|new
name|ArrayList
argument_list|<
name|Query
argument_list|>
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|filterList
operator|.
name|add
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
return|return
name|this
return|;
block|}
DECL|method|getFilter
specifier|public
name|DocSet
name|getFilter
parameter_list|()
block|{
return|return
name|filter
return|;
block|}
comment|/**      * @throws IllegalArgumentException if filterList is not null.      */
DECL|method|setFilter
specifier|public
name|QueryCommand
name|setFilter
parameter_list|(
name|DocSet
name|filter
parameter_list|)
block|{
if|if
condition|(
name|filterList
operator|!=
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Either filter or filterList may be set in the QueryCommand, but not both."
argument_list|)
throw|;
block|}
name|this
operator|.
name|filter
operator|=
name|filter
expr_stmt|;
return|return
name|this
return|;
block|}
DECL|method|getSort
specifier|public
name|Sort
name|getSort
parameter_list|()
block|{
return|return
name|sort
return|;
block|}
DECL|method|setSort
specifier|public
name|QueryCommand
name|setSort
parameter_list|(
name|Sort
name|sort
parameter_list|)
block|{
name|this
operator|.
name|sort
operator|=
name|sort
expr_stmt|;
return|return
name|this
return|;
block|}
DECL|method|getOffset
specifier|public
name|int
name|getOffset
parameter_list|()
block|{
return|return
name|offset
return|;
block|}
DECL|method|setOffset
specifier|public
name|QueryCommand
name|setOffset
parameter_list|(
name|int
name|offset
parameter_list|)
block|{
name|this
operator|.
name|offset
operator|=
name|offset
expr_stmt|;
return|return
name|this
return|;
block|}
DECL|method|getLen
specifier|public
name|int
name|getLen
parameter_list|()
block|{
return|return
name|len
return|;
block|}
DECL|method|setLen
specifier|public
name|QueryCommand
name|setLen
parameter_list|(
name|int
name|len
parameter_list|)
block|{
name|this
operator|.
name|len
operator|=
name|len
expr_stmt|;
return|return
name|this
return|;
block|}
DECL|method|getSupersetMaxDoc
specifier|public
name|int
name|getSupersetMaxDoc
parameter_list|()
block|{
return|return
name|supersetMaxDoc
return|;
block|}
DECL|method|setSupersetMaxDoc
specifier|public
name|QueryCommand
name|setSupersetMaxDoc
parameter_list|(
name|int
name|supersetMaxDoc
parameter_list|)
block|{
name|this
operator|.
name|supersetMaxDoc
operator|=
name|supersetMaxDoc
expr_stmt|;
return|return
name|this
return|;
block|}
DECL|method|getFlags
specifier|public
name|int
name|getFlags
parameter_list|()
block|{
return|return
name|flags
return|;
block|}
DECL|method|replaceFlags
specifier|public
name|QueryCommand
name|replaceFlags
parameter_list|(
name|int
name|flags
parameter_list|)
block|{
name|this
operator|.
name|flags
operator|=
name|flags
expr_stmt|;
return|return
name|this
return|;
block|}
DECL|method|setFlags
specifier|public
name|QueryCommand
name|setFlags
parameter_list|(
name|int
name|flags
parameter_list|)
block|{
name|this
operator|.
name|flags
operator||=
name|flags
expr_stmt|;
return|return
name|this
return|;
block|}
DECL|method|clearFlags
specifier|public
name|QueryCommand
name|clearFlags
parameter_list|(
name|int
name|flags
parameter_list|)
block|{
name|this
operator|.
name|flags
operator|&=
operator|~
name|flags
expr_stmt|;
return|return
name|this
return|;
block|}
DECL|method|getTimeAllowed
specifier|public
name|long
name|getTimeAllowed
parameter_list|()
block|{
return|return
name|timeAllowed
return|;
block|}
DECL|method|setTimeAllowed
specifier|public
name|QueryCommand
name|setTimeAllowed
parameter_list|(
name|long
name|timeAllowed
parameter_list|)
block|{
name|this
operator|.
name|timeAllowed
operator|=
name|timeAllowed
expr_stmt|;
return|return
name|this
return|;
block|}
DECL|method|isNeedDocSet
specifier|public
name|boolean
name|isNeedDocSet
parameter_list|()
block|{
return|return
operator|(
name|flags
operator|&
name|GET_DOCSET
operator|)
operator|!=
literal|0
return|;
block|}
DECL|method|setNeedDocSet
specifier|public
name|QueryCommand
name|setNeedDocSet
parameter_list|(
name|boolean
name|needDocSet
parameter_list|)
block|{
return|return
name|needDocSet
condition|?
name|setFlags
argument_list|(
name|GET_DOCSET
argument_list|)
else|:
name|clearFlags
argument_list|(
name|GET_DOCSET
argument_list|)
return|;
block|}
block|}
comment|/**    * The result of a search.    */
DECL|class|QueryResult
specifier|public
specifier|static
class|class
name|QueryResult
block|{
DECL|field|partialResults
specifier|private
name|boolean
name|partialResults
decl_stmt|;
DECL|field|docListAndSet
specifier|private
name|DocListAndSet
name|docListAndSet
decl_stmt|;
DECL|field|groupedResults
specifier|public
name|Object
name|groupedResults
decl_stmt|;
comment|// TODO: currently for testing
DECL|method|getDocList
specifier|public
name|DocList
name|getDocList
parameter_list|()
block|{
return|return
name|docListAndSet
operator|.
name|docList
return|;
block|}
DECL|method|setDocList
specifier|public
name|void
name|setDocList
parameter_list|(
name|DocList
name|list
parameter_list|)
block|{
if|if
condition|(
name|docListAndSet
operator|==
literal|null
condition|)
block|{
name|docListAndSet
operator|=
operator|new
name|DocListAndSet
argument_list|()
expr_stmt|;
block|}
name|docListAndSet
operator|.
name|docList
operator|=
name|list
expr_stmt|;
block|}
DECL|method|getDocSet
specifier|public
name|DocSet
name|getDocSet
parameter_list|()
block|{
return|return
name|docListAndSet
operator|.
name|docSet
return|;
block|}
DECL|method|setDocSet
specifier|public
name|void
name|setDocSet
parameter_list|(
name|DocSet
name|set
parameter_list|)
block|{
if|if
condition|(
name|docListAndSet
operator|==
literal|null
condition|)
block|{
name|docListAndSet
operator|=
operator|new
name|DocListAndSet
argument_list|()
expr_stmt|;
block|}
name|docListAndSet
operator|.
name|docSet
operator|=
name|set
expr_stmt|;
block|}
DECL|method|isPartialResults
specifier|public
name|boolean
name|isPartialResults
parameter_list|()
block|{
return|return
name|partialResults
return|;
block|}
DECL|method|setPartialResults
specifier|public
name|void
name|setPartialResults
parameter_list|(
name|boolean
name|partialResults
parameter_list|)
block|{
name|this
operator|.
name|partialResults
operator|=
name|partialResults
expr_stmt|;
block|}
DECL|method|setDocListAndSet
specifier|public
name|void
name|setDocListAndSet
parameter_list|(
name|DocListAndSet
name|listSet
parameter_list|)
block|{
name|docListAndSet
operator|=
name|listSet
expr_stmt|;
block|}
DECL|method|getDocListAndSet
specifier|public
name|DocListAndSet
name|getDocListAndSet
parameter_list|()
block|{
return|return
name|docListAndSet
return|;
block|}
block|}
block|}
end_class
end_unit
