begin_unit
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_comment
comment|/*  * This parser was originally derived from DismaxQParser from Solr.  * All changes are Copyright 2008, Lucid Imagination, Inc.  */
end_comment
begin_package
DECL|package|org.apache.solr.search
package|package
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|search
package|;
end_package
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|queryParser
operator|.
name|ParseException
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|queryParser
operator|.
name|QueryParser
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|*
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|Analyzer
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|TokenStream
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|params
operator|.
name|DefaultSolrParams
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|params
operator|.
name|DisMaxParams
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|params
operator|.
name|SolrParams
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|util
operator|.
name|NamedList
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|request
operator|.
name|SolrQueryRequest
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|schema
operator|.
name|FieldType
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|search
operator|.
name|QueryUtils
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|search
operator|.
name|function
operator|.
name|BoostedQuery
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|search
operator|.
name|function
operator|.
name|FunctionQuery
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|search
operator|.
name|function
operator|.
name|ProductFloatFunction
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|search
operator|.
name|function
operator|.
name|QueryValueSource
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|search
operator|.
name|function
operator|.
name|ValueSource
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|util
operator|.
name|SolrPluginUtils
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|analysis
operator|.
name|*
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|*
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Reader
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_comment
comment|/**  * An advanced multi-field query parser.  * @lucene.experimental  */
end_comment
begin_class
DECL|class|ExtendedDismaxQParserPlugin
specifier|public
class|class
name|ExtendedDismaxQParserPlugin
extends|extends
name|QParserPlugin
block|{
DECL|field|NAME
specifier|public
specifier|static
specifier|final
name|String
name|NAME
init|=
literal|"edismax"
decl_stmt|;
DECL|method|init
specifier|public
name|void
name|init
parameter_list|(
name|NamedList
name|args
parameter_list|)
block|{   }
annotation|@
name|Override
DECL|method|createParser
specifier|public
name|QParser
name|createParser
parameter_list|(
name|String
name|qstr
parameter_list|,
name|SolrParams
name|localParams
parameter_list|,
name|SolrParams
name|params
parameter_list|,
name|SolrQueryRequest
name|req
parameter_list|)
block|{
return|return
operator|new
name|ExtendedDismaxQParser
argument_list|(
name|qstr
argument_list|,
name|localParams
argument_list|,
name|params
argument_list|,
name|req
argument_list|)
return|;
block|}
block|}
end_class
begin_class
DECL|class|ExtendedDismaxQParser
class|class
name|ExtendedDismaxQParser
extends|extends
name|QParser
block|{
comment|/**    * A field we can't ever find in any schema, so we can safely tell    * DisjunctionMaxQueryParser to use it as our defaultField, and    * map aliases from it to any field in our schema.    */
DECL|field|IMPOSSIBLE_FIELD_NAME
specifier|private
specifier|static
name|String
name|IMPOSSIBLE_FIELD_NAME
init|=
literal|"\uFFFC\uFFFC\uFFFC"
decl_stmt|;
comment|/** shorten the class references for utilities */
DECL|class|U
specifier|private
specifier|static
class|class
name|U
extends|extends
name|SolrPluginUtils
block|{
comment|/* :NOOP */
block|}
comment|/** shorten the class references for utilities */
DECL|interface|DMP
specifier|private
specifier|static
interface|interface
name|DMP
extends|extends
name|DisMaxParams
block|{
comment|/* :NOOP */
block|}
DECL|method|ExtendedDismaxQParser
specifier|public
name|ExtendedDismaxQParser
parameter_list|(
name|String
name|qstr
parameter_list|,
name|SolrParams
name|localParams
parameter_list|,
name|SolrParams
name|params
parameter_list|,
name|SolrQueryRequest
name|req
parameter_list|)
block|{
name|super
argument_list|(
name|qstr
argument_list|,
name|localParams
argument_list|,
name|params
argument_list|,
name|req
argument_list|)
expr_stmt|;
block|}
DECL|field|queryFields
name|Map
argument_list|<
name|String
argument_list|,
name|Float
argument_list|>
name|queryFields
decl_stmt|;
DECL|field|parsedUserQuery
name|Query
name|parsedUserQuery
decl_stmt|;
DECL|field|boostParams
specifier|private
name|String
index|[]
name|boostParams
decl_stmt|;
DECL|field|multBoosts
specifier|private
name|String
index|[]
name|multBoosts
decl_stmt|;
DECL|field|boostQueries
specifier|private
name|List
argument_list|<
name|Query
argument_list|>
name|boostQueries
decl_stmt|;
DECL|field|altUserQuery
specifier|private
name|Query
name|altUserQuery
decl_stmt|;
DECL|field|altQParser
specifier|private
name|QParser
name|altQParser
decl_stmt|;
annotation|@
name|Override
DECL|method|parse
specifier|public
name|Query
name|parse
parameter_list|()
throws|throws
name|ParseException
block|{
name|SolrParams
name|localParams
init|=
name|getLocalParams
argument_list|()
decl_stmt|;
name|SolrParams
name|params
init|=
name|getParams
argument_list|()
decl_stmt|;
name|SolrParams
name|solrParams
init|=
name|localParams
operator|==
literal|null
condition|?
name|params
else|:
operator|new
name|DefaultSolrParams
argument_list|(
name|localParams
argument_list|,
name|params
argument_list|)
decl_stmt|;
specifier|final
name|String
name|minShouldMatch
init|=
name|DisMaxQParser
operator|.
name|parseMinShouldMatch
argument_list|(
name|req
operator|.
name|getSchema
argument_list|()
argument_list|,
name|solrParams
argument_list|)
decl_stmt|;
name|queryFields
operator|=
name|U
operator|.
name|parseFieldBoosts
argument_list|(
name|solrParams
operator|.
name|getParams
argument_list|(
name|DMP
operator|.
name|QF
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|==
name|queryFields
operator|.
name|size
argument_list|()
condition|)
block|{
name|queryFields
operator|.
name|put
argument_list|(
name|req
operator|.
name|getSchema
argument_list|()
operator|.
name|getDefaultSearchFieldName
argument_list|()
argument_list|,
literal|1.0f
argument_list|)
expr_stmt|;
block|}
comment|// Boosted phrase of the full query string
name|Map
argument_list|<
name|String
argument_list|,
name|Float
argument_list|>
name|phraseFields
init|=
name|U
operator|.
name|parseFieldBoosts
argument_list|(
name|solrParams
operator|.
name|getParams
argument_list|(
name|DMP
operator|.
name|PF
argument_list|)
argument_list|)
decl_stmt|;
comment|// Boosted Bi-Term Shingles from the query string
name|Map
argument_list|<
name|String
argument_list|,
name|Float
argument_list|>
name|phraseFields2
init|=
name|U
operator|.
name|parseFieldBoosts
argument_list|(
name|solrParams
operator|.
name|getParams
argument_list|(
literal|"pf2"
argument_list|)
argument_list|)
decl_stmt|;
comment|// Boosted Tri-Term Shingles from the query string
name|Map
argument_list|<
name|String
argument_list|,
name|Float
argument_list|>
name|phraseFields3
init|=
name|U
operator|.
name|parseFieldBoosts
argument_list|(
name|solrParams
operator|.
name|getParams
argument_list|(
literal|"pf3"
argument_list|)
argument_list|)
decl_stmt|;
name|float
name|tiebreaker
init|=
name|solrParams
operator|.
name|getFloat
argument_list|(
name|DMP
operator|.
name|TIE
argument_list|,
literal|0.0f
argument_list|)
decl_stmt|;
name|int
name|pslop
init|=
name|solrParams
operator|.
name|getInt
argument_list|(
name|DMP
operator|.
name|PS
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|int
name|qslop
init|=
name|solrParams
operator|.
name|getInt
argument_list|(
name|DMP
operator|.
name|QS
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|// remove stopwords from mandatory "matching" component?
name|boolean
name|stopwords
init|=
name|solrParams
operator|.
name|getBool
argument_list|(
literal|"stopwords"
argument_list|,
literal|true
argument_list|)
decl_stmt|;
comment|/* the main query we will execute.  we disable the coord because      * this query is an artificial construct      */
name|BooleanQuery
name|query
init|=
operator|new
name|BooleanQuery
argument_list|(
literal|true
argument_list|)
decl_stmt|;
comment|/* * * Main User Query * * */
name|parsedUserQuery
operator|=
literal|null
expr_stmt|;
name|String
name|userQuery
init|=
name|getString
argument_list|()
decl_stmt|;
name|altUserQuery
operator|=
literal|null
expr_stmt|;
if|if
condition|(
name|userQuery
operator|==
literal|null
operator|||
name|userQuery
operator|.
name|length
argument_list|()
operator|<
literal|1
condition|)
block|{
comment|// If no query is specified, we may have an alternate
name|String
name|altQ
init|=
name|solrParams
operator|.
name|get
argument_list|(
name|DMP
operator|.
name|ALTQ
argument_list|)
decl_stmt|;
if|if
condition|(
name|altQ
operator|!=
literal|null
condition|)
block|{
name|altQParser
operator|=
name|subQuery
argument_list|(
name|altQ
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|altUserQuery
operator|=
name|altQParser
operator|.
name|getQuery
argument_list|()
expr_stmt|;
name|query
operator|.
name|add
argument_list|(
name|altUserQuery
argument_list|,
name|BooleanClause
operator|.
name|Occur
operator|.
name|MUST
argument_list|)
expr_stmt|;
block|}
else|else
block|{
return|return
literal|null
return|;
comment|// throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, "missing query string" );
block|}
block|}
else|else
block|{
comment|// There is a valid query string
comment|// userQuery = partialEscape(U.stripUnbalancedQuotes(userQuery)).toString();
name|boolean
name|lowercaseOperators
init|=
name|solrParams
operator|.
name|getBool
argument_list|(
literal|"lowercaseOperators"
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|String
name|mainUserQuery
init|=
name|userQuery
decl_stmt|;
name|ExtendedSolrQueryParser
name|up
init|=
operator|new
name|ExtendedSolrQueryParser
argument_list|(
name|this
argument_list|,
name|IMPOSSIBLE_FIELD_NAME
argument_list|)
decl_stmt|;
name|up
operator|.
name|addAlias
argument_list|(
name|IMPOSSIBLE_FIELD_NAME
argument_list|,
name|tiebreaker
argument_list|,
name|queryFields
argument_list|)
expr_stmt|;
name|up
operator|.
name|setPhraseSlop
argument_list|(
name|qslop
argument_list|)
expr_stmt|;
comment|// slop for explicit user phrase queries
name|up
operator|.
name|setAllowLeadingWildcard
argument_list|(
literal|true
argument_list|)
expr_stmt|;
comment|// defer escaping and only do if lucene parsing fails, or we need phrases
comment|// parsing fails.  Need to sloppy phrase queries anyway though.
name|List
argument_list|<
name|Clause
argument_list|>
name|clauses
init|=
literal|null
decl_stmt|;
name|boolean
name|specialSyntax
init|=
literal|false
decl_stmt|;
name|int
name|numPluses
init|=
literal|0
decl_stmt|;
name|int
name|numMinuses
init|=
literal|0
decl_stmt|;
name|int
name|numOptional
init|=
literal|0
decl_stmt|;
name|int
name|numAND
init|=
literal|0
decl_stmt|;
name|int
name|numOR
init|=
literal|0
decl_stmt|;
name|int
name|numNOT
init|=
literal|0
decl_stmt|;
name|boolean
name|sawLowerAnd
init|=
literal|false
decl_stmt|;
name|boolean
name|sawLowerOr
init|=
literal|false
decl_stmt|;
name|clauses
operator|=
name|splitIntoClauses
argument_list|(
name|userQuery
argument_list|,
literal|false
argument_list|)
expr_stmt|;
for|for
control|(
name|Clause
name|clause
range|:
name|clauses
control|)
block|{
if|if
condition|(
operator|!
name|clause
operator|.
name|isPhrase
operator|&&
name|clause
operator|.
name|hasSpecialSyntax
condition|)
block|{
name|specialSyntax
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|clause
operator|.
name|must
operator|==
literal|'+'
condition|)
name|numPluses
operator|++
expr_stmt|;
if|if
condition|(
name|clause
operator|.
name|must
operator|==
literal|'-'
condition|)
name|numMinuses
operator|++
expr_stmt|;
if|if
condition|(
name|clause
operator|.
name|isBareWord
argument_list|()
condition|)
block|{
name|String
name|s
init|=
name|clause
operator|.
name|val
decl_stmt|;
if|if
condition|(
literal|"AND"
operator|.
name|equals
argument_list|(
name|s
argument_list|)
condition|)
block|{
name|numAND
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|"OR"
operator|.
name|equals
argument_list|(
name|s
argument_list|)
condition|)
block|{
name|numOR
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|"NOT"
operator|.
name|equals
argument_list|(
name|s
argument_list|)
condition|)
block|{
name|numNOT
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lowercaseOperators
condition|)
block|{
if|if
condition|(
literal|"and"
operator|.
name|equals
argument_list|(
name|s
argument_list|)
condition|)
block|{
name|numAND
operator|++
expr_stmt|;
name|sawLowerAnd
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|"or"
operator|.
name|equals
argument_list|(
name|s
argument_list|)
condition|)
block|{
name|numOR
operator|++
expr_stmt|;
name|sawLowerOr
operator|=
literal|true
expr_stmt|;
block|}
block|}
block|}
block|}
name|numOptional
operator|=
name|clauses
operator|.
name|size
argument_list|()
operator|-
operator|(
name|numPluses
operator|+
name|numMinuses
operator|)
expr_stmt|;
comment|// convert lower or mixed case operators to uppercase if we saw them.
comment|// only do this for the lucene query part and not for phrase query boosting
comment|// since some fields might not be case insensitive.
comment|// We don't use a regex for this because it might change and AND or OR in
comment|// a phrase query in a case sensitive field.
if|if
condition|(
name|sawLowerAnd
operator|||
name|sawLowerOr
condition|)
block|{
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|clauses
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|Clause
name|clause
init|=
name|clauses
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|String
name|s
init|=
name|clause
operator|.
name|raw
decl_stmt|;
comment|// and and or won't be operators at the start or end
if|if
condition|(
name|i
operator|>
literal|0
operator|&&
name|i
operator|+
literal|1
operator|<
name|clauses
operator|.
name|size
argument_list|()
condition|)
block|{
if|if
condition|(
literal|"AND"
operator|.
name|equalsIgnoreCase
argument_list|(
name|s
argument_list|)
condition|)
block|{
name|s
operator|=
literal|"AND"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|"OR"
operator|.
name|equalsIgnoreCase
argument_list|(
name|s
argument_list|)
condition|)
block|{
name|s
operator|=
literal|"OR"
expr_stmt|;
block|}
block|}
name|sb
operator|.
name|append
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
name|mainUserQuery
operator|=
name|sb
operator|.
name|toString
argument_list|()
expr_stmt|;
block|}
comment|// For correct lucene queries, turn off mm processing if there
comment|// were explicit operators (except for AND).
name|boolean
name|doMinMatched
init|=
operator|(
name|numOR
operator|+
name|numNOT
operator|+
name|numPluses
operator|+
name|numMinuses
operator|)
operator|==
literal|0
decl_stmt|;
try|try
block|{
name|up
operator|.
name|setRemoveStopFilter
argument_list|(
operator|!
name|stopwords
argument_list|)
expr_stmt|;
name|up
operator|.
name|exceptions
operator|=
literal|true
expr_stmt|;
name|parsedUserQuery
operator|=
name|up
operator|.
name|parse
argument_list|(
name|mainUserQuery
argument_list|)
expr_stmt|;
if|if
condition|(
name|stopwords
operator|&&
name|isEmpty
argument_list|(
name|parsedUserQuery
argument_list|)
condition|)
block|{
comment|// if the query was all stop words, remove none of them
name|up
operator|.
name|setRemoveStopFilter
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|parsedUserQuery
operator|=
name|up
operator|.
name|parse
argument_list|(
name|mainUserQuery
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
comment|// ignore failure and reparse later after escaping reserved chars
name|up
operator|.
name|exceptions
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
name|parsedUserQuery
operator|!=
literal|null
operator|&&
name|doMinMatched
condition|)
block|{
if|if
condition|(
name|parsedUserQuery
operator|instanceof
name|BooleanQuery
condition|)
block|{
name|U
operator|.
name|setMinShouldMatch
argument_list|(
operator|(
name|BooleanQuery
operator|)
name|parsedUserQuery
argument_list|,
name|minShouldMatch
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|parsedUserQuery
operator|==
literal|null
condition|)
block|{
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|Clause
name|clause
range|:
name|clauses
control|)
block|{
name|boolean
name|doQuote
init|=
name|clause
operator|.
name|isPhrase
decl_stmt|;
name|String
name|s
init|=
name|clause
operator|.
name|val
decl_stmt|;
if|if
condition|(
operator|!
name|clause
operator|.
name|isPhrase
operator|&&
operator|(
literal|"OR"
operator|.
name|equals
argument_list|(
name|s
argument_list|)
operator|||
literal|"AND"
operator|.
name|equals
argument_list|(
name|s
argument_list|)
operator|||
literal|"NOT"
operator|.
name|equals
argument_list|(
name|s
argument_list|)
operator|)
condition|)
block|{
name|doQuote
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|clause
operator|.
name|must
operator|!=
literal|0
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|clause
operator|.
name|must
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|clause
operator|.
name|field
operator|!=
literal|null
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|clause
operator|.
name|field
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|':'
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|doQuote
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|'"'
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
name|clause
operator|.
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|doQuote
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|'"'
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
name|String
name|escapedUserQuery
init|=
name|sb
operator|.
name|toString
argument_list|()
decl_stmt|;
name|parsedUserQuery
operator|=
name|up
operator|.
name|parse
argument_list|(
name|escapedUserQuery
argument_list|)
expr_stmt|;
if|if
condition|(
name|parsedUserQuery
operator|instanceof
name|BooleanQuery
condition|)
block|{
name|BooleanQuery
name|t
init|=
operator|new
name|BooleanQuery
argument_list|()
decl_stmt|;
name|U
operator|.
name|flattenBooleanQuery
argument_list|(
name|t
argument_list|,
operator|(
name|BooleanQuery
operator|)
name|parsedUserQuery
argument_list|)
expr_stmt|;
name|U
operator|.
name|setMinShouldMatch
argument_list|(
name|t
argument_list|,
name|minShouldMatch
argument_list|)
expr_stmt|;
name|parsedUserQuery
operator|=
name|t
expr_stmt|;
block|}
block|}
name|query
operator|.
name|add
argument_list|(
name|parsedUserQuery
argument_list|,
name|BooleanClause
operator|.
name|Occur
operator|.
name|MUST
argument_list|)
expr_stmt|;
comment|// sloppy phrase queries for proximity
if|if
condition|(
name|phraseFields
operator|.
name|size
argument_list|()
operator|>
literal|0
operator|||
name|phraseFields2
operator|.
name|size
argument_list|()
operator|>
literal|0
operator|||
name|phraseFields3
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
comment|// find non-field clauses
name|List
argument_list|<
name|Clause
argument_list|>
name|normalClauses
init|=
operator|new
name|ArrayList
argument_list|<
name|Clause
argument_list|>
argument_list|(
name|clauses
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|Clause
name|clause
range|:
name|clauses
control|)
block|{
if|if
condition|(
name|clause
operator|.
name|field
operator|!=
literal|null
operator|||
name|clause
operator|.
name|isPhrase
condition|)
continue|continue;
comment|// check for keywords "AND,OR,TO"
if|if
condition|(
name|clause
operator|.
name|isBareWord
argument_list|()
condition|)
block|{
name|String
name|s
init|=
name|clause
operator|.
name|val
operator|.
name|toString
argument_list|()
decl_stmt|;
comment|// avoid putting explict operators in the phrase query
if|if
condition|(
literal|"OR"
operator|.
name|equals
argument_list|(
name|s
argument_list|)
operator|||
literal|"AND"
operator|.
name|equals
argument_list|(
name|s
argument_list|)
operator|||
literal|"NOT"
operator|.
name|equals
argument_list|(
name|s
argument_list|)
operator|||
literal|"TO"
operator|.
name|equals
argument_list|(
name|s
argument_list|)
condition|)
continue|continue;
block|}
name|normalClauses
operator|.
name|add
argument_list|(
name|clause
argument_list|)
expr_stmt|;
block|}
comment|// full phrase...
name|addShingledPhraseQueries
argument_list|(
name|query
argument_list|,
name|normalClauses
argument_list|,
name|phraseFields
argument_list|,
literal|0
argument_list|,
name|tiebreaker
argument_list|,
name|pslop
argument_list|)
expr_stmt|;
comment|// shingles...
name|addShingledPhraseQueries
argument_list|(
name|query
argument_list|,
name|normalClauses
argument_list|,
name|phraseFields2
argument_list|,
literal|2
argument_list|,
name|tiebreaker
argument_list|,
name|pslop
argument_list|)
expr_stmt|;
name|addShingledPhraseQueries
argument_list|(
name|query
argument_list|,
name|normalClauses
argument_list|,
name|phraseFields3
argument_list|,
literal|3
argument_list|,
name|tiebreaker
argument_list|,
name|pslop
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* * * Boosting Query * * */
name|boostParams
operator|=
name|solrParams
operator|.
name|getParams
argument_list|(
name|DMP
operator|.
name|BQ
argument_list|)
expr_stmt|;
comment|//List<Query> boostQueries = U.parseQueryStrings(req, boostParams);
name|boostQueries
operator|=
literal|null
expr_stmt|;
if|if
condition|(
name|boostParams
operator|!=
literal|null
operator|&&
name|boostParams
operator|.
name|length
operator|>
literal|0
condition|)
block|{
name|boostQueries
operator|=
operator|new
name|ArrayList
argument_list|<
name|Query
argument_list|>
argument_list|()
expr_stmt|;
for|for
control|(
name|String
name|qs
range|:
name|boostParams
control|)
block|{
if|if
condition|(
name|qs
operator|.
name|trim
argument_list|()
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
continue|continue;
name|Query
name|q
init|=
name|subQuery
argument_list|(
name|qs
argument_list|,
literal|null
argument_list|)
operator|.
name|getQuery
argument_list|()
decl_stmt|;
name|boostQueries
operator|.
name|add
argument_list|(
name|q
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
literal|null
operator|!=
name|boostQueries
condition|)
block|{
for|for
control|(
name|Query
name|f
range|:
name|boostQueries
control|)
block|{
name|query
operator|.
name|add
argument_list|(
name|f
argument_list|,
name|BooleanClause
operator|.
name|Occur
operator|.
name|SHOULD
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* * * Boosting Functions * * */
name|String
index|[]
name|boostFuncs
init|=
name|solrParams
operator|.
name|getParams
argument_list|(
name|DMP
operator|.
name|BF
argument_list|)
decl_stmt|;
if|if
condition|(
literal|null
operator|!=
name|boostFuncs
operator|&&
literal|0
operator|!=
name|boostFuncs
operator|.
name|length
condition|)
block|{
for|for
control|(
name|String
name|boostFunc
range|:
name|boostFuncs
control|)
block|{
if|if
condition|(
literal|null
operator|==
name|boostFunc
operator|||
literal|""
operator|.
name|equals
argument_list|(
name|boostFunc
argument_list|)
condition|)
continue|continue;
name|Map
argument_list|<
name|String
argument_list|,
name|Float
argument_list|>
name|ff
init|=
name|SolrPluginUtils
operator|.
name|parseFieldBoosts
argument_list|(
name|boostFunc
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|f
range|:
name|ff
operator|.
name|keySet
argument_list|()
control|)
block|{
name|Query
name|fq
init|=
name|subQuery
argument_list|(
name|f
argument_list|,
name|FunctionQParserPlugin
operator|.
name|NAME
argument_list|)
operator|.
name|getQuery
argument_list|()
decl_stmt|;
name|Float
name|b
init|=
name|ff
operator|.
name|get
argument_list|(
name|f
argument_list|)
decl_stmt|;
if|if
condition|(
literal|null
operator|!=
name|b
condition|)
block|{
name|fq
operator|.
name|setBoost
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
name|query
operator|.
name|add
argument_list|(
name|fq
argument_list|,
name|BooleanClause
operator|.
name|Occur
operator|.
name|SHOULD
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|//
comment|// create a boosted query (scores multiplied by boosts)
comment|//
name|Query
name|topQuery
init|=
name|query
decl_stmt|;
name|multBoosts
operator|=
name|solrParams
operator|.
name|getParams
argument_list|(
literal|"boost"
argument_list|)
expr_stmt|;
if|if
condition|(
name|multBoosts
operator|!=
literal|null
operator|&&
name|multBoosts
operator|.
name|length
operator|>
literal|0
condition|)
block|{
name|List
argument_list|<
name|ValueSource
argument_list|>
name|boosts
init|=
operator|new
name|ArrayList
argument_list|<
name|ValueSource
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|boostStr
range|:
name|multBoosts
control|)
block|{
if|if
condition|(
name|boostStr
operator|==
literal|null
operator|||
name|boostStr
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
continue|continue;
name|Query
name|boost
init|=
name|subQuery
argument_list|(
name|boostStr
argument_list|,
name|FunctionQParserPlugin
operator|.
name|NAME
argument_list|)
operator|.
name|getQuery
argument_list|()
decl_stmt|;
name|ValueSource
name|vs
decl_stmt|;
if|if
condition|(
name|boost
operator|instanceof
name|FunctionQuery
condition|)
block|{
name|vs
operator|=
operator|(
operator|(
name|FunctionQuery
operator|)
name|boost
operator|)
operator|.
name|getValueSource
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|vs
operator|=
operator|new
name|QueryValueSource
argument_list|(
name|boost
argument_list|,
literal|1.0f
argument_list|)
expr_stmt|;
block|}
name|boosts
operator|.
name|add
argument_list|(
name|vs
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|boosts
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
name|ValueSource
name|prod
init|=
operator|new
name|ProductFloatFunction
argument_list|(
name|boosts
operator|.
name|toArray
argument_list|(
operator|new
name|ValueSource
index|[
name|boosts
operator|.
name|size
argument_list|()
index|]
argument_list|)
argument_list|)
decl_stmt|;
name|topQuery
operator|=
operator|new
name|BoostedQuery
argument_list|(
name|query
argument_list|,
name|prod
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|boosts
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
name|topQuery
operator|=
operator|new
name|BoostedQuery
argument_list|(
name|query
argument_list|,
name|boosts
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|topQuery
return|;
block|}
comment|/**    * Modifies the main query by adding a new optional Query consisting    * of shingled phrase queries across the specified clauses using the     * specified field =&gt; boost mappings.    *    * @param mainQuery Where the phrase boosting queries will be added    * @param clauses Clauses that will be used to construct the phrases    * @param fields Field =&gt; boost mappings for the phrase queries    * @param shingleSize how big the phrases should be, 0 means a single phrase    * @param tiebreaker tie breker value for the DisjunctionMaxQueries    * @param slop slop value for the constructed phrases    */
DECL|method|addShingledPhraseQueries
specifier|private
name|void
name|addShingledPhraseQueries
parameter_list|(
specifier|final
name|BooleanQuery
name|mainQuery
parameter_list|,
specifier|final
name|List
argument_list|<
name|Clause
argument_list|>
name|clauses
parameter_list|,
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|Float
argument_list|>
name|fields
parameter_list|,
name|int
name|shingleSize
parameter_list|,
specifier|final
name|float
name|tiebreaker
parameter_list|,
specifier|final
name|int
name|slop
parameter_list|)
throws|throws
name|ParseException
block|{
if|if
condition|(
literal|null
operator|==
name|fields
operator|||
name|fields
operator|.
name|isEmpty
argument_list|()
operator|||
literal|null
operator|==
name|clauses
operator|||
name|clauses
operator|.
name|size
argument_list|()
operator|<=
name|shingleSize
condition|)
return|return;
if|if
condition|(
literal|0
operator|==
name|shingleSize
condition|)
name|shingleSize
operator|=
name|clauses
operator|.
name|size
argument_list|()
expr_stmt|;
specifier|final
name|int
name|goat
init|=
name|shingleSize
operator|-
literal|1
decl_stmt|;
comment|// :TODO: better name for var?
name|StringBuilder
name|userPhraseQuery
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|clauses
operator|.
name|size
argument_list|()
operator|-
name|goat
condition|;
name|i
operator|++
control|)
block|{
name|userPhraseQuery
operator|.
name|append
argument_list|(
literal|'"'
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<=
name|goat
condition|;
name|j
operator|++
control|)
block|{
name|userPhraseQuery
operator|.
name|append
argument_list|(
name|clauses
operator|.
name|get
argument_list|(
name|i
operator|+
name|j
argument_list|)
operator|.
name|val
argument_list|)
expr_stmt|;
name|userPhraseQuery
operator|.
name|append
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
name|userPhraseQuery
operator|.
name|append
argument_list|(
literal|'"'
argument_list|)
expr_stmt|;
name|userPhraseQuery
operator|.
name|append
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
comment|/* for parsing sloppy phrases using DisjunctionMaxQueries */
name|ExtendedSolrQueryParser
name|pp
init|=
operator|new
name|ExtendedSolrQueryParser
argument_list|(
name|this
argument_list|,
name|IMPOSSIBLE_FIELD_NAME
argument_list|)
decl_stmt|;
name|pp
operator|.
name|addAlias
argument_list|(
name|IMPOSSIBLE_FIELD_NAME
argument_list|,
name|tiebreaker
argument_list|,
name|fields
argument_list|)
expr_stmt|;
name|pp
operator|.
name|setPhraseSlop
argument_list|(
name|slop
argument_list|)
expr_stmt|;
name|pp
operator|.
name|setRemoveStopFilter
argument_list|(
literal|true
argument_list|)
expr_stmt|;
comment|// remove stop filter and keep stopwords
comment|/* :TODO: reevaluate using makeDismax=true vs false...        *         * The DismaxQueryParser always used DisjunctionMaxQueries for the         * pf boost, for the same reasons it used them for the qf fields.        * When Yonik first wrote the ExtendedDismaxQParserPlugin, he added        * the "makeDismax=false" property to use BooleanQueries instead, but         * when asked why his response was "I honestly don't recall" ...        *        * https://issues.apache.org/jira/browse/SOLR-1553?focusedCommentId=12793813#action_12793813        *        * so for now, we continue to use dismax style queries becuse it         * seems the most logical and is back compatible, but we should         * try to figure out what Yonik was thinking at the time (because he         * rarely does things for no reason)        */
name|pp
operator|.
name|makeDismax
operator|=
literal|true
expr_stmt|;
comment|// minClauseSize is independent of the shingleSize because of stop words
comment|// (if they are removed from the middle, so be it, but we need at least
comment|// two or there shouldn't be a boost)
name|pp
operator|.
name|minClauseSize
operator|=
literal|2
expr_stmt|;
comment|// TODO: perhaps we shouldn't use synonyms either...
name|Query
name|phrase
init|=
name|pp
operator|.
name|parse
argument_list|(
name|userPhraseQuery
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|phrase
operator|!=
literal|null
condition|)
block|{
name|mainQuery
operator|.
name|add
argument_list|(
name|phrase
argument_list|,
name|BooleanClause
operator|.
name|Occur
operator|.
name|SHOULD
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|getDefaultHighlightFields
specifier|public
name|String
index|[]
name|getDefaultHighlightFields
parameter_list|()
block|{
name|String
index|[]
name|highFields
init|=
name|queryFields
operator|.
name|keySet
argument_list|()
operator|.
name|toArray
argument_list|(
operator|new
name|String
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
return|return
name|highFields
return|;
block|}
annotation|@
name|Override
DECL|method|getHighlightQuery
specifier|public
name|Query
name|getHighlightQuery
parameter_list|()
throws|throws
name|ParseException
block|{
return|return
name|parsedUserQuery
operator|==
literal|null
condition|?
name|altUserQuery
else|:
name|parsedUserQuery
return|;
block|}
annotation|@
name|Override
DECL|method|addDebugInfo
specifier|public
name|void
name|addDebugInfo
parameter_list|(
name|NamedList
argument_list|<
name|Object
argument_list|>
name|debugInfo
parameter_list|)
block|{
name|super
operator|.
name|addDebugInfo
argument_list|(
name|debugInfo
argument_list|)
expr_stmt|;
name|debugInfo
operator|.
name|add
argument_list|(
literal|"altquerystring"
argument_list|,
name|altUserQuery
argument_list|)
expr_stmt|;
if|if
condition|(
literal|null
operator|!=
name|boostQueries
condition|)
block|{
name|debugInfo
operator|.
name|add
argument_list|(
literal|"boost_queries"
argument_list|,
name|boostParams
argument_list|)
expr_stmt|;
name|debugInfo
operator|.
name|add
argument_list|(
literal|"parsed_boost_queries"
argument_list|,
name|QueryParsing
operator|.
name|toString
argument_list|(
name|boostQueries
argument_list|,
name|getReq
argument_list|()
operator|.
name|getSchema
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|debugInfo
operator|.
name|add
argument_list|(
literal|"boostfuncs"
argument_list|,
name|getReq
argument_list|()
operator|.
name|getParams
argument_list|()
operator|.
name|getParams
argument_list|(
name|DisMaxParams
operator|.
name|BF
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|partialEscape
specifier|public
specifier|static
name|CharSequence
name|partialEscape
parameter_list|(
name|CharSequence
name|s
parameter_list|)
block|{
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|int
name|len
init|=
name|s
operator|.
name|length
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|char
name|c
init|=
name|s
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|':'
condition|)
block|{
comment|// look forward to make sure it's something that won't
comment|// cause a parse exception (something that won't be escaped... like
comment|// +,-,:, whitespace
if|if
condition|(
name|i
operator|+
literal|1
operator|<
name|len
operator|&&
name|i
operator|>
literal|0
condition|)
block|{
name|char
name|ch
init|=
name|s
operator|.
name|charAt
argument_list|(
name|i
operator|+
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|Character
operator|.
name|isWhitespace
argument_list|(
name|ch
argument_list|)
operator|||
name|ch
operator|==
literal|'+'
operator|||
name|ch
operator|==
literal|'-'
operator|||
name|ch
operator|==
literal|':'
operator|)
condition|)
block|{
comment|// OK, at this point the chars after the ':' will be fine.
comment|// now look back and try to determine if this is a fieldname
comment|// [+,-]? [letter,_] [letter digit,_,-,.]*
comment|// This won't cover *all* possible lucene fieldnames, but we should
comment|// only pick nice names to begin with
name|int
name|start
decl_stmt|,
name|pos
decl_stmt|;
for|for
control|(
name|start
operator|=
name|i
operator|-
literal|1
init|;
name|start
operator|>=
literal|0
condition|;
name|start
operator|--
control|)
block|{
name|ch
operator|=
name|s
operator|.
name|charAt
argument_list|(
name|start
argument_list|)
expr_stmt|;
if|if
condition|(
name|Character
operator|.
name|isWhitespace
argument_list|(
name|ch
argument_list|)
condition|)
break|break;
block|}
comment|// skip whitespace
name|pos
operator|=
name|start
operator|+
literal|1
expr_stmt|;
comment|// skip leading + or -
name|ch
operator|=
name|s
operator|.
name|charAt
argument_list|(
name|pos
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'+'
operator|||
name|ch
operator|==
literal|'-'
condition|)
block|{
name|pos
operator|++
expr_stmt|;
block|}
comment|// we don't need to explicitly check for end of string
comment|// since ':' will act as our sentinal
comment|// first char can't be '-' or '.'
name|ch
operator|=
name|s
operator|.
name|charAt
argument_list|(
name|pos
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
name|Character
operator|.
name|isJavaIdentifierPart
argument_list|(
name|ch
argument_list|)
condition|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
name|ch
operator|=
name|s
operator|.
name|charAt
argument_list|(
name|pos
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|Character
operator|.
name|isJavaIdentifierPart
argument_list|(
name|ch
argument_list|)
operator|||
name|ch
operator|==
literal|'-'
operator|||
name|ch
operator|==
literal|'.'
operator|)
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
name|pos
operator|<=
name|i
condition|)
block|{
comment|// OK, we got to the ':' and everything looked like a valid fieldname, so
comment|// don't escape the ':'
name|sb
operator|.
name|append
argument_list|(
literal|':'
argument_list|)
expr_stmt|;
continue|continue;
comment|// jump back to start of outer-most loop
block|}
block|}
block|}
block|}
comment|// we fell through to here, so we should escape this like other reserved chars.
name|sb
operator|.
name|append
argument_list|(
literal|'\\'
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\\'
operator|||
name|c
operator|==
literal|'!'
operator|||
name|c
operator|==
literal|'('
operator|||
name|c
operator|==
literal|')'
operator|||
name|c
operator|==
literal|'^'
operator|||
name|c
operator|==
literal|'['
operator|||
name|c
operator|==
literal|']'
operator|||
name|c
operator|==
literal|'{'
operator|||
name|c
operator|==
literal|'}'
operator|||
name|c
operator|==
literal|'~'
operator|||
name|c
operator|==
literal|'*'
operator|||
name|c
operator|==
literal|'?'
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|'\\'
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
return|return
name|sb
return|;
block|}
DECL|class|Clause
specifier|static
class|class
name|Clause
block|{
DECL|method|isBareWord
name|boolean
name|isBareWord
parameter_list|()
block|{
return|return
name|must
operator|==
literal|0
operator|&&
operator|!
name|isPhrase
return|;
block|}
DECL|field|field
name|String
name|field
decl_stmt|;
DECL|field|isPhrase
name|boolean
name|isPhrase
decl_stmt|;
DECL|field|hasWhitespace
name|boolean
name|hasWhitespace
decl_stmt|;
DECL|field|hasSpecialSyntax
name|boolean
name|hasSpecialSyntax
decl_stmt|;
DECL|field|syntaxError
name|boolean
name|syntaxError
decl_stmt|;
DECL|field|must
name|char
name|must
decl_stmt|;
comment|// + or -
DECL|field|val
name|String
name|val
decl_stmt|;
comment|// the field value (minus the field name, +/-, quotes)
DECL|field|raw
name|String
name|raw
decl_stmt|;
comment|// the raw clause w/o leading/trailing whitespace
block|}
DECL|method|splitIntoClauses
specifier|public
name|List
argument_list|<
name|Clause
argument_list|>
name|splitIntoClauses
parameter_list|(
name|String
name|s
parameter_list|,
name|boolean
name|ignoreQuote
parameter_list|)
block|{
name|ArrayList
argument_list|<
name|Clause
argument_list|>
name|lst
init|=
operator|new
name|ArrayList
argument_list|<
name|Clause
argument_list|>
argument_list|(
literal|4
argument_list|)
decl_stmt|;
name|Clause
name|clause
init|=
operator|new
name|Clause
argument_list|()
decl_stmt|;
name|int
name|pos
init|=
literal|0
decl_stmt|;
name|int
name|end
init|=
name|s
operator|.
name|length
argument_list|()
decl_stmt|;
name|char
name|ch
init|=
literal|0
decl_stmt|;
name|int
name|start
decl_stmt|;
name|outer
label|:
while|while
condition|(
name|pos
operator|<
name|end
condition|)
block|{
name|ch
operator|=
name|s
operator|.
name|charAt
argument_list|(
name|pos
argument_list|)
expr_stmt|;
while|while
condition|(
name|Character
operator|.
name|isWhitespace
argument_list|(
name|ch
argument_list|)
condition|)
block|{
if|if
condition|(
operator|++
name|pos
operator|>=
name|end
condition|)
break|break;
name|ch
operator|=
name|s
operator|.
name|charAt
argument_list|(
name|pos
argument_list|)
expr_stmt|;
block|}
name|start
operator|=
name|pos
expr_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'+'
operator|||
name|ch
operator|==
literal|'-'
condition|)
block|{
name|clause
operator|.
name|must
operator|=
name|ch
expr_stmt|;
name|pos
operator|++
expr_stmt|;
block|}
name|clause
operator|.
name|field
operator|=
name|getFieldName
argument_list|(
name|s
argument_list|,
name|pos
argument_list|,
name|end
argument_list|)
expr_stmt|;
if|if
condition|(
name|clause
operator|.
name|field
operator|!=
literal|null
condition|)
block|{
name|pos
operator|+=
name|clause
operator|.
name|field
operator|.
name|length
argument_list|()
expr_stmt|;
comment|// skip the field name
name|pos
operator|++
expr_stmt|;
comment|// skip the ':'
block|}
if|if
condition|(
name|pos
operator|>=
name|end
condition|)
break|break;
name|char
name|inString
init|=
literal|0
decl_stmt|;
name|ch
operator|=
name|s
operator|.
name|charAt
argument_list|(
name|pos
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ignoreQuote
operator|&&
name|ch
operator|==
literal|'"'
condition|)
block|{
name|clause
operator|.
name|isPhrase
operator|=
literal|true
expr_stmt|;
name|inString
operator|=
literal|'"'
expr_stmt|;
name|pos
operator|++
expr_stmt|;
block|}
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
while|while
condition|(
name|pos
operator|<
name|end
condition|)
block|{
name|ch
operator|=
name|s
operator|.
name|charAt
argument_list|(
name|pos
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'\\'
condition|)
block|{
comment|// skip escaped chars, but leave escaped
name|sb
operator|.
name|append
argument_list|(
name|ch
argument_list|)
expr_stmt|;
if|if
condition|(
name|pos
operator|>=
name|end
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|ch
argument_list|)
expr_stmt|;
comment|// double backslash if we are at the end of the string
break|break;
block|}
name|ch
operator|=
name|s
operator|.
name|charAt
argument_list|(
name|pos
operator|++
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|ch
argument_list|)
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|inString
operator|!=
literal|0
operator|&&
name|ch
operator|==
name|inString
condition|)
block|{
name|inString
operator|=
literal|0
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|Character
operator|.
name|isWhitespace
argument_list|(
name|ch
argument_list|)
condition|)
block|{
name|clause
operator|.
name|hasWhitespace
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|inString
operator|==
literal|0
condition|)
block|{
comment|// end of the token if we aren't in a string, backing
comment|// up the position.
name|pos
operator|--
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|inString
operator|==
literal|0
condition|)
block|{
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'!'
case|:
case|case
literal|'('
case|:
case|case
literal|')'
case|:
case|case
literal|':'
case|:
case|case
literal|'^'
case|:
case|case
literal|'['
case|:
case|case
literal|']'
case|:
case|case
literal|'{'
case|:
case|case
literal|'}'
case|:
case|case
literal|'~'
case|:
case|case
literal|'*'
case|:
case|case
literal|'?'
case|:
case|case
literal|'"'
case|:
case|case
literal|'+'
case|:
case|case
literal|'-'
case|:
name|clause
operator|.
name|hasSpecialSyntax
operator|=
literal|true
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|'\\'
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
literal|'"'
condition|)
block|{
comment|// only char we need to escape in a string is double quote
name|sb
operator|.
name|append
argument_list|(
literal|'\\'
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
name|ch
argument_list|)
expr_stmt|;
block|}
name|clause
operator|.
name|val
operator|=
name|sb
operator|.
name|toString
argument_list|()
expr_stmt|;
if|if
condition|(
name|clause
operator|.
name|isPhrase
condition|)
block|{
if|if
condition|(
name|inString
operator|!=
literal|0
condition|)
block|{
comment|// detected bad quote balancing... retry
comment|// parsing with quotes like any other char
return|return
name|splitIntoClauses
argument_list|(
name|s
argument_list|,
literal|true
argument_list|)
return|;
block|}
comment|// special syntax in a string isn't special
name|clause
operator|.
name|hasSpecialSyntax
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
comment|// an empty clause... must be just a + or - on it's own
if|if
condition|(
name|clause
operator|.
name|val
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
block|{
name|clause
operator|.
name|syntaxError
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|clause
operator|.
name|must
operator|!=
literal|0
condition|)
block|{
name|clause
operator|.
name|val
operator|=
literal|"\\"
operator|+
name|clause
operator|.
name|must
expr_stmt|;
name|clause
operator|.
name|must
operator|=
literal|0
expr_stmt|;
name|clause
operator|.
name|hasSpecialSyntax
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
comment|// uh.. this shouldn't happen.
name|clause
operator|=
literal|null
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|clause
operator|!=
literal|null
condition|)
block|{
name|clause
operator|.
name|raw
operator|=
name|s
operator|.
name|substring
argument_list|(
name|start
argument_list|,
name|pos
argument_list|)
expr_stmt|;
name|lst
operator|.
name|add
argument_list|(
name|clause
argument_list|)
expr_stmt|;
block|}
name|clause
operator|=
operator|new
name|Clause
argument_list|()
expr_stmt|;
block|}
return|return
name|lst
return|;
block|}
DECL|method|getFieldName
specifier|public
name|String
name|getFieldName
parameter_list|(
name|String
name|s
parameter_list|,
name|int
name|pos
parameter_list|,
name|int
name|end
parameter_list|)
block|{
if|if
condition|(
name|pos
operator|>=
name|end
condition|)
return|return
literal|null
return|;
name|int
name|p
init|=
name|pos
decl_stmt|;
name|int
name|colon
init|=
name|s
operator|.
name|indexOf
argument_list|(
literal|':'
argument_list|,
name|pos
argument_list|)
decl_stmt|;
comment|// make sure there is space after the colon, but not whitespace
if|if
condition|(
name|colon
operator|<=
name|pos
operator|||
name|colon
operator|+
literal|1
operator|>=
name|end
operator|||
name|Character
operator|.
name|isWhitespace
argument_list|(
name|s
operator|.
name|charAt
argument_list|(
name|colon
operator|+
literal|1
argument_list|)
argument_list|)
condition|)
return|return
literal|null
return|;
name|char
name|ch
init|=
name|s
operator|.
name|charAt
argument_list|(
name|p
operator|++
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|Character
operator|.
name|isJavaIdentifierPart
argument_list|(
name|ch
argument_list|)
condition|)
return|return
literal|null
return|;
while|while
condition|(
name|p
operator|<
name|colon
condition|)
block|{
name|ch
operator|=
name|s
operator|.
name|charAt
argument_list|(
name|p
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|Character
operator|.
name|isJavaIdentifierPart
argument_list|(
name|ch
argument_list|)
operator|||
name|ch
operator|==
literal|'-'
operator|||
name|ch
operator|==
literal|'.'
operator|)
condition|)
return|return
literal|null
return|;
block|}
name|String
name|fname
init|=
name|s
operator|.
name|substring
argument_list|(
name|pos
argument_list|,
name|p
argument_list|)
decl_stmt|;
return|return
name|getReq
argument_list|()
operator|.
name|getSchema
argument_list|()
operator|.
name|getFieldTypeNoEx
argument_list|(
name|fname
argument_list|)
operator|==
literal|null
condition|?
literal|null
else|:
name|fname
return|;
block|}
DECL|method|split
specifier|public
specifier|static
name|List
argument_list|<
name|String
argument_list|>
name|split
parameter_list|(
name|String
name|s
parameter_list|,
name|boolean
name|ignoreQuote
parameter_list|)
block|{
name|ArrayList
argument_list|<
name|String
argument_list|>
name|lst
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|(
literal|4
argument_list|)
decl_stmt|;
name|int
name|pos
init|=
literal|0
decl_stmt|,
name|start
init|=
literal|0
decl_stmt|,
name|end
init|=
name|s
operator|.
name|length
argument_list|()
decl_stmt|;
name|char
name|inString
init|=
literal|0
decl_stmt|;
name|char
name|ch
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|pos
operator|<
name|end
condition|)
block|{
name|char
name|prevChar
init|=
name|ch
decl_stmt|;
name|ch
operator|=
name|s
operator|.
name|charAt
argument_list|(
name|pos
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'\\'
condition|)
block|{
comment|// skip escaped chars
name|pos
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|inString
operator|!=
literal|0
operator|&&
name|ch
operator|==
name|inString
condition|)
block|{
name|inString
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|ignoreQuote
operator|&&
name|ch
operator|==
literal|'"'
condition|)
block|{
comment|// If char is directly preceeded by a number or letter
comment|// then don't treat it as the start of a string.
if|if
condition|(
operator|!
name|Character
operator|.
name|isLetterOrDigit
argument_list|(
name|prevChar
argument_list|)
condition|)
block|{
name|inString
operator|=
name|ch
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|Character
operator|.
name|isWhitespace
argument_list|(
name|ch
argument_list|)
operator|&&
name|inString
operator|==
literal|0
condition|)
block|{
name|lst
operator|.
name|add
argument_list|(
name|s
operator|.
name|substring
argument_list|(
name|start
argument_list|,
name|pos
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|start
operator|=
name|pos
expr_stmt|;
block|}
block|}
if|if
condition|(
name|start
operator|<
name|end
condition|)
block|{
name|lst
operator|.
name|add
argument_list|(
name|s
operator|.
name|substring
argument_list|(
name|start
argument_list|,
name|end
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|inString
operator|!=
literal|0
condition|)
block|{
comment|// unbalanced quote... ignore them
return|return
name|split
argument_list|(
name|s
argument_list|,
literal|true
argument_list|)
return|;
block|}
return|return
name|lst
return|;
block|}
DECL|enum|QType
enum|enum
name|QType
block|{
DECL|enum constant|FIELD
name|FIELD
block|,
DECL|enum constant|PHRASE
name|PHRASE
block|,
DECL|enum constant|PREFIX
name|PREFIX
block|,
DECL|enum constant|WILDCARD
name|WILDCARD
block|,
DECL|enum constant|FUZZY
name|FUZZY
block|,
DECL|enum constant|RANGE
name|RANGE
block|}
DECL|field|unknownField
specifier|static
specifier|final
name|RuntimeException
name|unknownField
init|=
operator|new
name|RuntimeException
argument_list|(
literal|"UnknownField"
argument_list|)
decl_stmt|;
static|static
block|{
name|unknownField
operator|.
name|fillInStackTrace
argument_list|()
expr_stmt|;
block|}
comment|/**    * A subclass of SolrQueryParser that supports aliasing fields for    * constructing DisjunctionMaxQueries.    */
DECL|class|ExtendedSolrQueryParser
class|class
name|ExtendedSolrQueryParser
extends|extends
name|SolrQueryParser
block|{
comment|/** A simple container for storing alias info      */
DECL|class|Alias
specifier|protected
class|class
name|Alias
block|{
DECL|field|tie
specifier|public
name|float
name|tie
decl_stmt|;
DECL|field|fields
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|Float
argument_list|>
name|fields
decl_stmt|;
block|}
DECL|field|makeDismax
name|boolean
name|makeDismax
init|=
literal|true
decl_stmt|;
DECL|field|disableCoord
name|boolean
name|disableCoord
init|=
literal|true
decl_stmt|;
DECL|field|allowWildcard
name|boolean
name|allowWildcard
init|=
literal|true
decl_stmt|;
DECL|field|minClauseSize
name|int
name|minClauseSize
init|=
literal|0
decl_stmt|;
comment|// minimum number of clauses per phrase query...
comment|// used when constructing boosting part of query via sloppy phrases
DECL|field|exceptions
name|boolean
name|exceptions
decl_stmt|;
comment|//  allow exceptions to be thrown (for example on a missing field)
DECL|field|analyzer
name|ExtendedAnalyzer
name|analyzer
decl_stmt|;
comment|/**      * Where we store a map from field name we expect to see in our query      * string, to Alias object containing the fields to use in our      * DisjunctionMaxQuery and the tiebreaker to use.      */
DECL|field|aliases
specifier|protected
name|Map
argument_list|<
name|String
argument_list|,
name|Alias
argument_list|>
name|aliases
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Alias
argument_list|>
argument_list|(
literal|3
argument_list|)
decl_stmt|;
DECL|method|ExtendedSolrQueryParser
specifier|public
name|ExtendedSolrQueryParser
parameter_list|(
name|QParser
name|parser
parameter_list|,
name|String
name|defaultField
parameter_list|)
block|{
name|super
argument_list|(
name|parser
argument_list|,
name|defaultField
argument_list|,
operator|new
name|ExtendedAnalyzer
argument_list|(
name|parser
argument_list|)
argument_list|)
expr_stmt|;
name|analyzer
operator|=
operator|(
name|ExtendedAnalyzer
operator|)
name|getAnalyzer
argument_list|()
expr_stmt|;
comment|// don't trust that our parent class won't ever change it's default
name|setDefaultOperator
argument_list|(
name|QueryParser
operator|.
name|Operator
operator|.
name|OR
argument_list|)
expr_stmt|;
block|}
DECL|method|setRemoveStopFilter
specifier|public
name|void
name|setRemoveStopFilter
parameter_list|(
name|boolean
name|remove
parameter_list|)
block|{
name|analyzer
operator|.
name|removeStopFilter
operator|=
name|remove
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|getBooleanQuery
specifier|protected
name|Query
name|getBooleanQuery
parameter_list|(
name|List
name|clauses
parameter_list|,
name|boolean
name|disableCoord
parameter_list|)
throws|throws
name|ParseException
block|{
name|Query
name|q
init|=
name|super
operator|.
name|getBooleanQuery
argument_list|(
name|clauses
argument_list|,
name|disableCoord
argument_list|)
decl_stmt|;
if|if
condition|(
name|q
operator|!=
literal|null
condition|)
block|{
name|q
operator|=
name|QueryUtils
operator|.
name|makeQueryable
argument_list|(
name|q
argument_list|)
expr_stmt|;
block|}
return|return
name|q
return|;
block|}
comment|////////////////////////////////////////////////////////////////////////////
comment|////////////////////////////////////////////////////////////////////////////
comment|////////////////////////////////////////////////////////////////////////////
comment|////////////////////////////////////////////////////////////////////////////
annotation|@
name|Override
DECL|method|addClause
specifier|protected
name|void
name|addClause
parameter_list|(
name|List
name|clauses
parameter_list|,
name|int
name|conj
parameter_list|,
name|int
name|mods
parameter_list|,
name|Query
name|q
parameter_list|)
block|{
comment|//System.out.println("addClause:clauses="+clauses+" conj="+conj+" mods="+mods+" q="+q);
name|super
operator|.
name|addClause
argument_list|(
name|clauses
argument_list|,
name|conj
argument_list|,
name|mods
argument_list|,
name|q
argument_list|)
expr_stmt|;
block|}
comment|/**      * Add an alias to this query parser.      *      * @param field the field name that should trigger alias mapping      * @param fieldBoosts the mapping from fieldname to boost value that      *                    should be used to build up the clauses of the      *                    DisjunctionMaxQuery.      * @param tiebreaker to the tiebreaker to be used in the      *                   DisjunctionMaxQuery      * @see SolrPluginUtils#parseFieldBoosts      */
DECL|method|addAlias
specifier|public
name|void
name|addAlias
parameter_list|(
name|String
name|field
parameter_list|,
name|float
name|tiebreaker
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|Float
argument_list|>
name|fieldBoosts
parameter_list|)
block|{
name|Alias
name|a
init|=
operator|new
name|Alias
argument_list|()
decl_stmt|;
name|a
operator|.
name|tie
operator|=
name|tiebreaker
expr_stmt|;
name|a
operator|.
name|fields
operator|=
name|fieldBoosts
expr_stmt|;
name|aliases
operator|.
name|put
argument_list|(
name|field
argument_list|,
name|a
argument_list|)
expr_stmt|;
block|}
DECL|field|type
name|QType
name|type
decl_stmt|;
DECL|field|field
name|String
name|field
decl_stmt|;
DECL|field|val
name|String
name|val
decl_stmt|;
DECL|field|val2
name|String
name|val2
decl_stmt|;
DECL|field|bool
name|boolean
name|bool
decl_stmt|;
DECL|field|bool2
name|boolean
name|bool2
decl_stmt|;
DECL|field|flt
name|float
name|flt
decl_stmt|;
DECL|field|slop
name|int
name|slop
decl_stmt|;
annotation|@
name|Override
DECL|method|getFieldQuery
specifier|protected
name|Query
name|getFieldQuery
parameter_list|(
name|String
name|field
parameter_list|,
name|String
name|val
parameter_list|,
name|boolean
name|quoted
parameter_list|)
throws|throws
name|ParseException
block|{
comment|//System.out.println("getFieldQuery: val="+val);
name|this
operator|.
name|type
operator|=
name|QType
operator|.
name|FIELD
expr_stmt|;
name|this
operator|.
name|field
operator|=
name|field
expr_stmt|;
name|this
operator|.
name|val
operator|=
name|val
expr_stmt|;
name|this
operator|.
name|slop
operator|=
name|getPhraseSlop
argument_list|()
expr_stmt|;
comment|// unspecified
return|return
name|getAliasedQuery
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|getFieldQuery
specifier|protected
name|Query
name|getFieldQuery
parameter_list|(
name|String
name|field
parameter_list|,
name|String
name|val
parameter_list|,
name|int
name|slop
parameter_list|)
throws|throws
name|ParseException
block|{
comment|//System.out.println("getFieldQuery: val="+val+" slop="+slop);
name|this
operator|.
name|type
operator|=
name|QType
operator|.
name|PHRASE
expr_stmt|;
name|this
operator|.
name|field
operator|=
name|field
expr_stmt|;
name|this
operator|.
name|val
operator|=
name|val
expr_stmt|;
name|this
operator|.
name|slop
operator|=
name|slop
expr_stmt|;
return|return
name|getAliasedQuery
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|getPrefixQuery
specifier|protected
name|Query
name|getPrefixQuery
parameter_list|(
name|String
name|field
parameter_list|,
name|String
name|val
parameter_list|)
throws|throws
name|ParseException
block|{
comment|//System.out.println("getPrefixQuery: val="+val);
if|if
condition|(
name|val
operator|.
name|equals
argument_list|(
literal|""
argument_list|)
operator|&&
name|field
operator|.
name|equals
argument_list|(
literal|"*"
argument_list|)
condition|)
block|{
return|return
operator|new
name|MatchAllDocsQuery
argument_list|()
return|;
block|}
name|this
operator|.
name|type
operator|=
name|QType
operator|.
name|PREFIX
expr_stmt|;
name|this
operator|.
name|field
operator|=
name|field
expr_stmt|;
name|this
operator|.
name|val
operator|=
name|val
expr_stmt|;
return|return
name|getAliasedQuery
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|getRangeQuery
specifier|protected
name|Query
name|getRangeQuery
parameter_list|(
name|String
name|field
parameter_list|,
name|String
name|a
parameter_list|,
name|String
name|b
parameter_list|,
name|boolean
name|startInclusive
parameter_list|,
name|boolean
name|endInclusive
parameter_list|)
throws|throws
name|ParseException
block|{
comment|//System.out.println("getRangeQuery:");
name|this
operator|.
name|type
operator|=
name|QType
operator|.
name|RANGE
expr_stmt|;
name|this
operator|.
name|field
operator|=
name|field
expr_stmt|;
name|this
operator|.
name|val
operator|=
name|a
expr_stmt|;
name|this
operator|.
name|val2
operator|=
name|b
expr_stmt|;
name|this
operator|.
name|bool
operator|=
name|startInclusive
expr_stmt|;
name|this
operator|.
name|bool2
operator|=
name|endInclusive
expr_stmt|;
return|return
name|getAliasedQuery
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|getWildcardQuery
specifier|protected
name|Query
name|getWildcardQuery
parameter_list|(
name|String
name|field
parameter_list|,
name|String
name|val
parameter_list|)
throws|throws
name|ParseException
block|{
comment|//System.out.println("getWildcardQuery: val="+val);
if|if
condition|(
name|val
operator|.
name|equals
argument_list|(
literal|"*"
argument_list|)
condition|)
block|{
if|if
condition|(
name|field
operator|.
name|equals
argument_list|(
literal|"*"
argument_list|)
condition|)
block|{
return|return
operator|new
name|MatchAllDocsQuery
argument_list|()
return|;
block|}
else|else
block|{
return|return
name|getPrefixQuery
argument_list|(
name|field
argument_list|,
literal|""
argument_list|)
return|;
block|}
block|}
name|this
operator|.
name|type
operator|=
name|QType
operator|.
name|WILDCARD
expr_stmt|;
name|this
operator|.
name|field
operator|=
name|field
expr_stmt|;
name|this
operator|.
name|val
operator|=
name|val
expr_stmt|;
return|return
name|getAliasedQuery
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|getFuzzyQuery
specifier|protected
name|Query
name|getFuzzyQuery
parameter_list|(
name|String
name|field
parameter_list|,
name|String
name|val
parameter_list|,
name|float
name|minSimilarity
parameter_list|)
throws|throws
name|ParseException
block|{
comment|//System.out.println("getFuzzyQuery: val="+val);
name|this
operator|.
name|type
operator|=
name|QType
operator|.
name|FUZZY
expr_stmt|;
name|this
operator|.
name|field
operator|=
name|field
expr_stmt|;
name|this
operator|.
name|val
operator|=
name|val
expr_stmt|;
name|this
operator|.
name|flt
operator|=
name|minSimilarity
expr_stmt|;
return|return
name|getAliasedQuery
argument_list|()
return|;
block|}
comment|/**      * Delegates to the super class unless the field has been specified      * as an alias -- in which case we recurse on each of      * the aliased fields, and the results are composed into a      * DisjunctionMaxQuery.  (so yes: aliases which point at other      * aliases should work)      */
DECL|method|getAliasedQuery
specifier|protected
name|Query
name|getAliasedQuery
parameter_list|()
throws|throws
name|ParseException
block|{
name|Alias
name|a
init|=
name|aliases
operator|.
name|get
argument_list|(
name|field
argument_list|)
decl_stmt|;
if|if
condition|(
name|a
operator|!=
literal|null
condition|)
block|{
name|List
argument_list|<
name|Query
argument_list|>
name|lst
init|=
name|getQueries
argument_list|(
name|a
argument_list|)
decl_stmt|;
if|if
condition|(
name|lst
operator|==
literal|null
operator|||
name|lst
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
return|return
name|getQuery
argument_list|()
return|;
comment|// make a DisjunctionMaxQuery in this case too... it will stop
comment|// the "mm" processing from making everything required in the case
comment|// that the query expanded to multiple clauses.
comment|// DisMaxQuery.rewrite() removes itself if there is just a single clause anyway.
comment|// if (lst.size()==1) return lst.get(0);
if|if
condition|(
name|makeDismax
condition|)
block|{
name|DisjunctionMaxQuery
name|q
init|=
operator|new
name|DisjunctionMaxQuery
argument_list|(
name|lst
argument_list|,
name|a
operator|.
name|tie
argument_list|)
decl_stmt|;
return|return
name|q
return|;
block|}
else|else
block|{
comment|// should we disable coord?
name|BooleanQuery
name|q
init|=
operator|new
name|BooleanQuery
argument_list|(
name|disableCoord
argument_list|)
decl_stmt|;
for|for
control|(
name|Query
name|sub
range|:
name|lst
control|)
block|{
name|q
operator|.
name|add
argument_list|(
name|sub
argument_list|,
name|BooleanClause
operator|.
name|Occur
operator|.
name|SHOULD
argument_list|)
expr_stmt|;
block|}
return|return
name|q
return|;
block|}
block|}
else|else
block|{
comment|// verify that a fielded query is actually on a field that exists... if not,
comment|// then throw an exception to get us out of here, and we'll treat it like a
comment|// literal when we try the escape+re-parse.
if|if
condition|(
name|exceptions
condition|)
block|{
name|FieldType
name|ft
init|=
name|schema
operator|.
name|getFieldTypeNoEx
argument_list|(
name|field
argument_list|)
decl_stmt|;
if|if
condition|(
name|ft
operator|==
literal|null
condition|)
throw|throw
name|unknownField
throw|;
block|}
return|return
name|getQuery
argument_list|()
return|;
block|}
block|}
DECL|method|getQueries
specifier|protected
name|List
argument_list|<
name|Query
argument_list|>
name|getQueries
parameter_list|(
name|Alias
name|a
parameter_list|)
throws|throws
name|ParseException
block|{
if|if
condition|(
name|a
operator|==
literal|null
condition|)
return|return
literal|null
return|;
if|if
condition|(
name|a
operator|.
name|fields
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
return|return
literal|null
return|;
name|List
argument_list|<
name|Query
argument_list|>
name|lst
init|=
operator|new
name|ArrayList
argument_list|<
name|Query
argument_list|>
argument_list|(
literal|4
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|f
range|:
name|a
operator|.
name|fields
operator|.
name|keySet
argument_list|()
control|)
block|{
name|this
operator|.
name|field
operator|=
name|f
expr_stmt|;
name|Query
name|sub
init|=
name|getQuery
argument_list|()
decl_stmt|;
if|if
condition|(
name|sub
operator|!=
literal|null
condition|)
block|{
name|Float
name|boost
init|=
name|a
operator|.
name|fields
operator|.
name|get
argument_list|(
name|f
argument_list|)
decl_stmt|;
if|if
condition|(
name|boost
operator|!=
literal|null
condition|)
block|{
name|sub
operator|.
name|setBoost
argument_list|(
name|boost
argument_list|)
expr_stmt|;
block|}
name|lst
operator|.
name|add
argument_list|(
name|sub
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|lst
return|;
block|}
DECL|method|getQuery
specifier|private
name|Query
name|getQuery
parameter_list|()
throws|throws
name|ParseException
block|{
try|try
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|FIELD
case|:
comment|// fallthrough
case|case
name|PHRASE
case|:
name|Query
name|query
init|=
name|super
operator|.
name|getFieldQuery
argument_list|(
name|field
argument_list|,
name|val
argument_list|,
name|type
operator|==
name|QType
operator|.
name|PHRASE
argument_list|)
decl_stmt|;
if|if
condition|(
name|query
operator|instanceof
name|PhraseQuery
condition|)
block|{
name|PhraseQuery
name|pq
init|=
operator|(
name|PhraseQuery
operator|)
name|query
decl_stmt|;
if|if
condition|(
name|minClauseSize
operator|>
literal|1
operator|&&
name|pq
operator|.
name|getTerms
argument_list|()
operator|.
name|length
operator|<
name|minClauseSize
condition|)
return|return
literal|null
return|;
operator|(
operator|(
name|PhraseQuery
operator|)
name|query
operator|)
operator|.
name|setSlop
argument_list|(
name|slop
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|query
operator|instanceof
name|MultiPhraseQuery
condition|)
block|{
name|MultiPhraseQuery
name|pq
init|=
operator|(
name|MultiPhraseQuery
operator|)
name|query
decl_stmt|;
if|if
condition|(
name|minClauseSize
operator|>
literal|1
operator|&&
name|pq
operator|.
name|getTermArrays
argument_list|()
operator|.
name|size
argument_list|()
operator|<
name|minClauseSize
condition|)
return|return
literal|null
return|;
operator|(
operator|(
name|MultiPhraseQuery
operator|)
name|query
operator|)
operator|.
name|setSlop
argument_list|(
name|slop
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|minClauseSize
operator|>
literal|1
condition|)
block|{
comment|// if it's not a type of phrase query, it doesn't meet the minClauseSize requirements
return|return
literal|null
return|;
block|}
return|return
name|query
return|;
case|case
name|PREFIX
case|:
return|return
name|super
operator|.
name|getPrefixQuery
argument_list|(
name|field
argument_list|,
name|val
argument_list|)
return|;
case|case
name|WILDCARD
case|:
return|return
name|super
operator|.
name|getWildcardQuery
argument_list|(
name|field
argument_list|,
name|val
argument_list|)
return|;
case|case
name|FUZZY
case|:
return|return
name|super
operator|.
name|getFuzzyQuery
argument_list|(
name|field
argument_list|,
name|val
argument_list|,
name|flt
argument_list|)
return|;
case|case
name|RANGE
case|:
return|return
name|super
operator|.
name|getRangeQuery
argument_list|(
name|field
argument_list|,
name|val
argument_list|,
name|val2
argument_list|,
name|bool
argument_list|,
name|bool2
argument_list|)
return|;
block|}
return|return
literal|null
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
comment|// an exception here is due to the field query not being compatible with the input text
comment|// for example, passing a string to a numeric field.
return|return
literal|null
return|;
block|}
block|}
block|}
DECL|method|isEmpty
specifier|static
name|boolean
name|isEmpty
parameter_list|(
name|Query
name|q
parameter_list|)
block|{
if|if
condition|(
name|q
operator|==
literal|null
condition|)
return|return
literal|true
return|;
if|if
condition|(
name|q
operator|instanceof
name|BooleanQuery
operator|&&
operator|(
operator|(
name|BooleanQuery
operator|)
name|q
operator|)
operator|.
name|clauses
argument_list|()
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
return|return
literal|true
return|;
return|return
literal|false
return|;
block|}
block|}
end_class
begin_class
DECL|class|ExtendedAnalyzer
specifier|final
class|class
name|ExtendedAnalyzer
extends|extends
name|Analyzer
block|{
DECL|field|map
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|Analyzer
argument_list|>
name|map
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Analyzer
argument_list|>
argument_list|()
decl_stmt|;
DECL|field|parser
specifier|final
name|QParser
name|parser
decl_stmt|;
DECL|field|queryAnalyzer
specifier|final
name|Analyzer
name|queryAnalyzer
decl_stmt|;
DECL|field|removeStopFilter
specifier|public
name|boolean
name|removeStopFilter
init|=
literal|false
decl_stmt|;
DECL|method|getQueryTokenizerChain
specifier|public
specifier|static
name|TokenizerChain
name|getQueryTokenizerChain
parameter_list|(
name|QParser
name|parser
parameter_list|,
name|String
name|fieldName
parameter_list|)
block|{
name|FieldType
name|ft
init|=
name|parser
operator|.
name|getReq
argument_list|()
operator|.
name|getSchema
argument_list|()
operator|.
name|getFieldType
argument_list|(
name|fieldName
argument_list|)
decl_stmt|;
name|Analyzer
name|qa
init|=
name|ft
operator|.
name|getQueryAnalyzer
argument_list|()
decl_stmt|;
return|return
name|qa
operator|instanceof
name|TokenizerChain
condition|?
operator|(
name|TokenizerChain
operator|)
name|qa
else|:
literal|null
return|;
block|}
DECL|method|getQueryStopFilter
specifier|public
specifier|static
name|StopFilterFactory
name|getQueryStopFilter
parameter_list|(
name|QParser
name|parser
parameter_list|,
name|String
name|fieldName
parameter_list|)
block|{
name|TokenizerChain
name|tcq
init|=
name|getQueryTokenizerChain
argument_list|(
name|parser
argument_list|,
name|fieldName
argument_list|)
decl_stmt|;
if|if
condition|(
name|tcq
operator|==
literal|null
condition|)
return|return
literal|null
return|;
name|TokenFilterFactory
index|[]
name|facs
init|=
name|tcq
operator|.
name|getTokenFilterFactories
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|facs
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|TokenFilterFactory
name|tf
init|=
name|facs
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|tf
operator|instanceof
name|StopFilterFactory
condition|)
block|{
return|return
operator|(
name|StopFilterFactory
operator|)
name|tf
return|;
block|}
block|}
return|return
literal|null
return|;
block|}
DECL|method|ExtendedAnalyzer
specifier|public
name|ExtendedAnalyzer
parameter_list|(
name|QParser
name|parser
parameter_list|)
block|{
name|this
operator|.
name|parser
operator|=
name|parser
expr_stmt|;
name|this
operator|.
name|queryAnalyzer
operator|=
name|parser
operator|.
name|getReq
argument_list|()
operator|.
name|getSchema
argument_list|()
operator|.
name|getQueryAnalyzer
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|tokenStream
specifier|public
name|TokenStream
name|tokenStream
parameter_list|(
name|String
name|fieldName
parameter_list|,
name|Reader
name|reader
parameter_list|)
block|{
if|if
condition|(
operator|!
name|removeStopFilter
condition|)
block|{
return|return
name|queryAnalyzer
operator|.
name|tokenStream
argument_list|(
name|fieldName
argument_list|,
name|reader
argument_list|)
return|;
block|}
name|Analyzer
name|a
init|=
name|map
operator|.
name|get
argument_list|(
name|fieldName
argument_list|)
decl_stmt|;
if|if
condition|(
name|a
operator|!=
literal|null
condition|)
block|{
return|return
name|a
operator|.
name|tokenStream
argument_list|(
name|fieldName
argument_list|,
name|reader
argument_list|)
return|;
block|}
name|FieldType
name|ft
init|=
name|parser
operator|.
name|getReq
argument_list|()
operator|.
name|getSchema
argument_list|()
operator|.
name|getFieldType
argument_list|(
name|fieldName
argument_list|)
decl_stmt|;
name|Analyzer
name|qa
init|=
name|ft
operator|.
name|getQueryAnalyzer
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|qa
operator|instanceof
name|TokenizerChain
operator|)
condition|)
block|{
name|map
operator|.
name|put
argument_list|(
name|fieldName
argument_list|,
name|qa
argument_list|)
expr_stmt|;
return|return
name|qa
operator|.
name|tokenStream
argument_list|(
name|fieldName
argument_list|,
name|reader
argument_list|)
return|;
block|}
name|TokenizerChain
name|tcq
init|=
operator|(
name|TokenizerChain
operator|)
name|qa
decl_stmt|;
name|Analyzer
name|ia
init|=
name|ft
operator|.
name|getAnalyzer
argument_list|()
decl_stmt|;
if|if
condition|(
name|ia
operator|==
name|qa
operator|||
operator|!
operator|(
name|ia
operator|instanceof
name|TokenizerChain
operator|)
condition|)
block|{
name|map
operator|.
name|put
argument_list|(
name|fieldName
argument_list|,
name|qa
argument_list|)
expr_stmt|;
return|return
name|qa
operator|.
name|tokenStream
argument_list|(
name|fieldName
argument_list|,
name|reader
argument_list|)
return|;
block|}
name|TokenizerChain
name|tci
init|=
operator|(
name|TokenizerChain
operator|)
name|ia
decl_stmt|;
comment|// make sure that there isn't a stop filter in the indexer
for|for
control|(
name|TokenFilterFactory
name|tf
range|:
name|tci
operator|.
name|getTokenFilterFactories
argument_list|()
control|)
block|{
if|if
condition|(
name|tf
operator|instanceof
name|StopFilterFactory
condition|)
block|{
name|map
operator|.
name|put
argument_list|(
name|fieldName
argument_list|,
name|qa
argument_list|)
expr_stmt|;
return|return
name|qa
operator|.
name|tokenStream
argument_list|(
name|fieldName
argument_list|,
name|reader
argument_list|)
return|;
block|}
block|}
comment|// now if there is a stop filter in the query analyzer, remove it
name|int
name|stopIdx
init|=
operator|-
literal|1
decl_stmt|;
name|TokenFilterFactory
index|[]
name|facs
init|=
name|tcq
operator|.
name|getTokenFilterFactories
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|facs
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|TokenFilterFactory
name|tf
init|=
name|facs
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|tf
operator|instanceof
name|StopFilterFactory
condition|)
block|{
name|stopIdx
operator|=
name|i
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|stopIdx
operator|==
operator|-
literal|1
condition|)
block|{
comment|// no stop filter exists
name|map
operator|.
name|put
argument_list|(
name|fieldName
argument_list|,
name|qa
argument_list|)
expr_stmt|;
return|return
name|qa
operator|.
name|tokenStream
argument_list|(
name|fieldName
argument_list|,
name|reader
argument_list|)
return|;
block|}
name|TokenFilterFactory
index|[]
name|newtf
init|=
operator|new
name|TokenFilterFactory
index|[
name|facs
operator|.
name|length
operator|-
literal|1
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|,
name|j
init|=
literal|0
init|;
name|i
operator|<
name|facs
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|==
name|stopIdx
condition|)
continue|continue;
name|newtf
index|[
name|j
operator|++
index|]
operator|=
name|facs
index|[
name|i
index|]
expr_stmt|;
block|}
name|TokenizerChain
name|newa
init|=
operator|new
name|TokenizerChain
argument_list|(
name|tcq
operator|.
name|getTokenizerFactory
argument_list|()
argument_list|,
name|newtf
argument_list|)
decl_stmt|;
name|newa
operator|.
name|setPositionIncrementGap
argument_list|(
name|tcq
operator|.
name|getPositionIncrementGap
argument_list|(
name|fieldName
argument_list|)
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
name|fieldName
argument_list|,
name|newa
argument_list|)
expr_stmt|;
return|return
name|newa
operator|.
name|tokenStream
argument_list|(
name|fieldName
argument_list|,
name|reader
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|getPositionIncrementGap
specifier|public
name|int
name|getPositionIncrementGap
parameter_list|(
name|String
name|fieldName
parameter_list|)
block|{
return|return
name|queryAnalyzer
operator|.
name|getPositionIncrementGap
argument_list|(
name|fieldName
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|reusableTokenStream
specifier|public
name|TokenStream
name|reusableTokenStream
parameter_list|(
name|String
name|fieldName
parameter_list|,
name|Reader
name|reader
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|removeStopFilter
condition|)
block|{
return|return
name|queryAnalyzer
operator|.
name|reusableTokenStream
argument_list|(
name|fieldName
argument_list|,
name|reader
argument_list|)
return|;
block|}
comment|// TODO: done to fix stop word removal bug - could be done while still using resusable?
return|return
name|tokenStream
argument_list|(
name|fieldName
argument_list|,
name|reader
argument_list|)
return|;
block|}
block|}
end_class
end_unit
