begin_unit
begin_package
DECL|package|org.apache.lucene.queryparser.classic
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|queryparser
operator|.
name|classic
package|;
end_package
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Reader
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|*
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|tokenattributes
operator|.
name|OffsetAttribute
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|tokenattributes
operator|.
name|PositionIncrementAttribute
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|tokenattributes
operator|.
name|CharTermAttribute
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|tokenattributes
operator|.
name|TypeAttribute
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|Query
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|Version
import|;
end_import
begin_comment
comment|/**  * Test QueryParser's ability to deal with Analyzers that return more  * than one token per position or that return tokens with a position  * increment&gt; 1.  *  */
end_comment
begin_class
DECL|class|TestMultiAnalyzer
specifier|public
class|class
name|TestMultiAnalyzer
extends|extends
name|BaseTokenStreamTestCase
block|{
DECL|field|multiToken
specifier|private
specifier|static
name|int
name|multiToken
init|=
literal|0
decl_stmt|;
DECL|method|testMultiAnalyzer
specifier|public
name|void
name|testMultiAnalyzer
parameter_list|()
throws|throws
name|ParseException
block|{
name|QueryParser
name|qp
init|=
operator|new
name|QueryParser
argument_list|(
name|TEST_VERSION_CURRENT
argument_list|,
literal|""
argument_list|,
operator|new
name|MultiAnalyzer
argument_list|()
argument_list|)
decl_stmt|;
comment|// trivial, no multiple tokens:
name|assertEquals
argument_list|(
literal|"foo"
argument_list|,
name|qp
operator|.
name|parse
argument_list|(
literal|"foo"
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"foo"
argument_list|,
name|qp
operator|.
name|parse
argument_list|(
literal|"\"foo\""
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"foo foobar"
argument_list|,
name|qp
operator|.
name|parse
argument_list|(
literal|"foo foobar"
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"\"foo foobar\""
argument_list|,
name|qp
operator|.
name|parse
argument_list|(
literal|"\"foo foobar\""
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"\"foo foobar blah\""
argument_list|,
name|qp
operator|.
name|parse
argument_list|(
literal|"\"foo foobar blah\""
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
comment|// two tokens at the same position:
name|assertEquals
argument_list|(
literal|"(multi multi2) foo"
argument_list|,
name|qp
operator|.
name|parse
argument_list|(
literal|"multi foo"
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"foo (multi multi2)"
argument_list|,
name|qp
operator|.
name|parse
argument_list|(
literal|"foo multi"
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"(multi multi2) (multi multi2)"
argument_list|,
name|qp
operator|.
name|parse
argument_list|(
literal|"multi multi"
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"+(foo (multi multi2)) +(bar (multi multi2))"
argument_list|,
name|qp
operator|.
name|parse
argument_list|(
literal|"+(foo multi) +(bar multi)"
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"+(foo (multi multi2)) field:\"bar (multi multi2)\""
argument_list|,
name|qp
operator|.
name|parse
argument_list|(
literal|"+(foo multi) field:\"bar multi\""
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
comment|// phrases:
name|assertEquals
argument_list|(
literal|"\"(multi multi2) foo\""
argument_list|,
name|qp
operator|.
name|parse
argument_list|(
literal|"\"multi foo\""
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"\"foo (multi multi2)\""
argument_list|,
name|qp
operator|.
name|parse
argument_list|(
literal|"\"foo multi\""
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"\"foo (multi multi2) foobar (multi multi2)\""
argument_list|,
name|qp
operator|.
name|parse
argument_list|(
literal|"\"foo multi foobar multi\""
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
comment|// fields:
name|assertEquals
argument_list|(
literal|"(field:multi field:multi2) field:foo"
argument_list|,
name|qp
operator|.
name|parse
argument_list|(
literal|"field:multi field:foo"
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"field:\"(multi multi2) foo\""
argument_list|,
name|qp
operator|.
name|parse
argument_list|(
literal|"field:\"multi foo\""
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
comment|// three tokens at one position:
name|assertEquals
argument_list|(
literal|"triplemulti multi3 multi2"
argument_list|,
name|qp
operator|.
name|parse
argument_list|(
literal|"triplemulti"
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"foo (triplemulti multi3 multi2) foobar"
argument_list|,
name|qp
operator|.
name|parse
argument_list|(
literal|"foo triplemulti foobar"
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
comment|// phrase with non-default slop:
name|assertEquals
argument_list|(
literal|"\"(multi multi2) foo\"~10"
argument_list|,
name|qp
operator|.
name|parse
argument_list|(
literal|"\"multi foo\"~10"
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
comment|// phrase with non-default boost:
name|assertEquals
argument_list|(
literal|"\"(multi multi2) foo\"^2.0"
argument_list|,
name|qp
operator|.
name|parse
argument_list|(
literal|"\"multi foo\"^2"
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
comment|// phrase after changing default slop
name|qp
operator|.
name|setPhraseSlop
argument_list|(
literal|99
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"\"(multi multi2) foo\"~99 bar"
argument_list|,
name|qp
operator|.
name|parse
argument_list|(
literal|"\"multi foo\" bar"
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"\"(multi multi2) foo\"~99 \"foo bar\"~2"
argument_list|,
name|qp
operator|.
name|parse
argument_list|(
literal|"\"multi foo\" \"foo bar\"~2"
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|qp
operator|.
name|setPhraseSlop
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|// non-default operator:
name|qp
operator|.
name|setDefaultOperator
argument_list|(
name|QueryParserBase
operator|.
name|AND_OPERATOR
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"+(multi multi2) +foo"
argument_list|,
name|qp
operator|.
name|parse
argument_list|(
literal|"multi foo"
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|testMultiAnalyzerWithSubclassOfQueryParser
specifier|public
name|void
name|testMultiAnalyzerWithSubclassOfQueryParser
parameter_list|()
throws|throws
name|ParseException
block|{
name|DumbQueryParser
name|qp
init|=
operator|new
name|DumbQueryParser
argument_list|(
literal|""
argument_list|,
operator|new
name|MultiAnalyzer
argument_list|()
argument_list|)
decl_stmt|;
name|qp
operator|.
name|setPhraseSlop
argument_list|(
literal|99
argument_list|)
expr_stmt|;
comment|// modified default slop
comment|// direct call to (super's) getFieldQuery to demonstrate differnce
comment|// between phrase and multiphrase with modified default slop
name|assertEquals
argument_list|(
literal|"\"foo bar\"~99"
argument_list|,
name|qp
operator|.
name|getSuperFieldQuery
argument_list|(
literal|""
argument_list|,
literal|"foo bar"
argument_list|,
literal|true
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"\"(multi multi2) bar\"~99"
argument_list|,
name|qp
operator|.
name|getSuperFieldQuery
argument_list|(
literal|""
argument_list|,
literal|"multi bar"
argument_list|,
literal|true
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
comment|// ask sublcass to parse phrase with modified default slop
name|assertEquals
argument_list|(
literal|"\"(multi multi2) foo\"~99 bar"
argument_list|,
name|qp
operator|.
name|parse
argument_list|(
literal|"\"multi foo\" bar"
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|testPosIncrementAnalyzer
specifier|public
name|void
name|testPosIncrementAnalyzer
parameter_list|()
throws|throws
name|ParseException
block|{
name|QueryParser
name|qp
init|=
operator|new
name|QueryParser
argument_list|(
name|Version
operator|.
name|LUCENE_40
argument_list|,
literal|""
argument_list|,
operator|new
name|PosIncrementAnalyzer
argument_list|()
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|"quick brown"
argument_list|,
name|qp
operator|.
name|parse
argument_list|(
literal|"the quick brown"
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"quick brown fox"
argument_list|,
name|qp
operator|.
name|parse
argument_list|(
literal|"the quick brown fox"
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * Expands "multi" to "multi" and "multi2", both at the same position,    * and expands "triplemulti" to "triplemulti", "multi3", and "multi2".      */
DECL|class|MultiAnalyzer
specifier|private
class|class
name|MultiAnalyzer
extends|extends
name|Analyzer
block|{
annotation|@
name|Override
DECL|method|createComponents
specifier|public
name|TokenStreamComponents
name|createComponents
parameter_list|(
name|String
name|fieldName
parameter_list|,
name|Reader
name|reader
parameter_list|)
block|{
name|Tokenizer
name|result
init|=
operator|new
name|MockTokenizer
argument_list|(
name|reader
argument_list|,
name|MockTokenizer
operator|.
name|WHITESPACE
argument_list|,
literal|true
argument_list|)
decl_stmt|;
return|return
operator|new
name|TokenStreamComponents
argument_list|(
name|result
argument_list|,
operator|new
name|TestFilter
argument_list|(
name|result
argument_list|)
argument_list|)
return|;
block|}
block|}
DECL|class|TestFilter
specifier|private
specifier|final
class|class
name|TestFilter
extends|extends
name|TokenFilter
block|{
DECL|field|prevType
specifier|private
name|String
name|prevType
decl_stmt|;
DECL|field|prevStartOffset
specifier|private
name|int
name|prevStartOffset
decl_stmt|;
DECL|field|prevEndOffset
specifier|private
name|int
name|prevEndOffset
decl_stmt|;
DECL|field|termAtt
specifier|private
specifier|final
name|CharTermAttribute
name|termAtt
decl_stmt|;
DECL|field|posIncrAtt
specifier|private
specifier|final
name|PositionIncrementAttribute
name|posIncrAtt
decl_stmt|;
DECL|field|offsetAtt
specifier|private
specifier|final
name|OffsetAttribute
name|offsetAtt
decl_stmt|;
DECL|field|typeAtt
specifier|private
specifier|final
name|TypeAttribute
name|typeAtt
decl_stmt|;
DECL|method|TestFilter
specifier|public
name|TestFilter
parameter_list|(
name|TokenStream
name|in
parameter_list|)
block|{
name|super
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|termAtt
operator|=
name|addAttribute
argument_list|(
name|CharTermAttribute
operator|.
name|class
argument_list|)
expr_stmt|;
name|posIncrAtt
operator|=
name|addAttribute
argument_list|(
name|PositionIncrementAttribute
operator|.
name|class
argument_list|)
expr_stmt|;
name|offsetAtt
operator|=
name|addAttribute
argument_list|(
name|OffsetAttribute
operator|.
name|class
argument_list|)
expr_stmt|;
name|typeAtt
operator|=
name|addAttribute
argument_list|(
name|TypeAttribute
operator|.
name|class
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|incrementToken
specifier|public
specifier|final
name|boolean
name|incrementToken
parameter_list|()
throws|throws
name|java
operator|.
name|io
operator|.
name|IOException
block|{
if|if
condition|(
name|multiToken
operator|>
literal|0
condition|)
block|{
name|termAtt
operator|.
name|setEmpty
argument_list|()
operator|.
name|append
argument_list|(
literal|"multi"
operator|+
operator|(
name|multiToken
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
name|offsetAtt
operator|.
name|setOffset
argument_list|(
name|prevStartOffset
argument_list|,
name|prevEndOffset
argument_list|)
expr_stmt|;
name|typeAtt
operator|.
name|setType
argument_list|(
name|prevType
argument_list|)
expr_stmt|;
name|posIncrAtt
operator|.
name|setPositionIncrement
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|multiToken
operator|--
expr_stmt|;
return|return
literal|true
return|;
block|}
else|else
block|{
name|boolean
name|next
init|=
name|input
operator|.
name|incrementToken
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|next
condition|)
block|{
return|return
literal|false
return|;
block|}
name|prevType
operator|=
name|typeAtt
operator|.
name|type
argument_list|()
expr_stmt|;
name|prevStartOffset
operator|=
name|offsetAtt
operator|.
name|startOffset
argument_list|()
expr_stmt|;
name|prevEndOffset
operator|=
name|offsetAtt
operator|.
name|endOffset
argument_list|()
expr_stmt|;
name|String
name|text
init|=
name|termAtt
operator|.
name|toString
argument_list|()
decl_stmt|;
if|if
condition|(
name|text
operator|.
name|equals
argument_list|(
literal|"triplemulti"
argument_list|)
condition|)
block|{
name|multiToken
operator|=
literal|2
expr_stmt|;
return|return
literal|true
return|;
block|}
elseif|else
if|if
condition|(
name|text
operator|.
name|equals
argument_list|(
literal|"multi"
argument_list|)
condition|)
block|{
name|multiToken
operator|=
literal|1
expr_stmt|;
return|return
literal|true
return|;
block|}
else|else
block|{
return|return
literal|true
return|;
block|}
block|}
block|}
DECL|method|reset
specifier|public
name|void
name|reset
parameter_list|()
throws|throws
name|IOException
block|{
name|super
operator|.
name|reset
argument_list|()
expr_stmt|;
name|this
operator|.
name|prevType
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|prevStartOffset
operator|=
literal|0
expr_stmt|;
name|this
operator|.
name|prevEndOffset
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/**    * Analyzes "the quick brown" as: quick(incr=2) brown(incr=1).    * Does not work correctly for input other than "the quick brown ...".    */
DECL|class|PosIncrementAnalyzer
specifier|private
class|class
name|PosIncrementAnalyzer
extends|extends
name|Analyzer
block|{
annotation|@
name|Override
DECL|method|createComponents
specifier|public
name|TokenStreamComponents
name|createComponents
parameter_list|(
name|String
name|fieldName
parameter_list|,
name|Reader
name|reader
parameter_list|)
block|{
name|Tokenizer
name|result
init|=
operator|new
name|MockTokenizer
argument_list|(
name|reader
argument_list|,
name|MockTokenizer
operator|.
name|WHITESPACE
argument_list|,
literal|true
argument_list|)
decl_stmt|;
return|return
operator|new
name|TokenStreamComponents
argument_list|(
name|result
argument_list|,
operator|new
name|TestPosIncrementFilter
argument_list|(
name|result
argument_list|)
argument_list|)
return|;
block|}
block|}
DECL|class|TestPosIncrementFilter
specifier|private
specifier|final
class|class
name|TestPosIncrementFilter
extends|extends
name|TokenFilter
block|{
DECL|field|termAtt
name|CharTermAttribute
name|termAtt
decl_stmt|;
DECL|field|posIncrAtt
name|PositionIncrementAttribute
name|posIncrAtt
decl_stmt|;
DECL|method|TestPosIncrementFilter
specifier|public
name|TestPosIncrementFilter
parameter_list|(
name|TokenStream
name|in
parameter_list|)
block|{
name|super
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|termAtt
operator|=
name|addAttribute
argument_list|(
name|CharTermAttribute
operator|.
name|class
argument_list|)
expr_stmt|;
name|posIncrAtt
operator|=
name|addAttribute
argument_list|(
name|PositionIncrementAttribute
operator|.
name|class
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|incrementToken
specifier|public
specifier|final
name|boolean
name|incrementToken
parameter_list|()
throws|throws
name|java
operator|.
name|io
operator|.
name|IOException
block|{
while|while
condition|(
name|input
operator|.
name|incrementToken
argument_list|()
condition|)
block|{
if|if
condition|(
name|termAtt
operator|.
name|toString
argument_list|()
operator|.
name|equals
argument_list|(
literal|"the"
argument_list|)
condition|)
block|{
comment|// stopword, do nothing
block|}
elseif|else
if|if
condition|(
name|termAtt
operator|.
name|toString
argument_list|()
operator|.
name|equals
argument_list|(
literal|"quick"
argument_list|)
condition|)
block|{
name|posIncrAtt
operator|.
name|setPositionIncrement
argument_list|(
literal|2
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
else|else
block|{
name|posIncrAtt
operator|.
name|setPositionIncrement
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
block|}
comment|/** a very simple subclass of QueryParser */
DECL|class|DumbQueryParser
specifier|private
specifier|final
specifier|static
class|class
name|DumbQueryParser
extends|extends
name|QueryParser
block|{
DECL|method|DumbQueryParser
specifier|public
name|DumbQueryParser
parameter_list|(
name|String
name|f
parameter_list|,
name|Analyzer
name|a
parameter_list|)
block|{
name|super
argument_list|(
name|TEST_VERSION_CURRENT
argument_list|,
name|f
argument_list|,
name|a
argument_list|)
expr_stmt|;
block|}
comment|/** expose super's version */
DECL|method|getSuperFieldQuery
specifier|public
name|Query
name|getSuperFieldQuery
parameter_list|(
name|String
name|f
parameter_list|,
name|String
name|t
parameter_list|,
name|boolean
name|quoted
parameter_list|)
throws|throws
name|ParseException
block|{
return|return
name|super
operator|.
name|getFieldQuery
argument_list|(
name|f
argument_list|,
name|t
argument_list|,
name|quoted
argument_list|)
return|;
block|}
comment|/** wrap super's version */
annotation|@
name|Override
DECL|method|getFieldQuery
specifier|protected
name|Query
name|getFieldQuery
parameter_list|(
name|String
name|f
parameter_list|,
name|String
name|t
parameter_list|,
name|boolean
name|quoted
parameter_list|)
throws|throws
name|ParseException
block|{
return|return
operator|new
name|DumbQueryWrapper
argument_list|(
name|getSuperFieldQuery
argument_list|(
name|f
argument_list|,
name|t
argument_list|,
name|quoted
argument_list|)
argument_list|)
return|;
block|}
block|}
comment|/**      * A very simple wrapper to prevent instanceof checks but uses      * the toString of the query it wraps.      */
DECL|class|DumbQueryWrapper
specifier|private
specifier|final
specifier|static
class|class
name|DumbQueryWrapper
extends|extends
name|Query
block|{
DECL|field|q
specifier|private
name|Query
name|q
decl_stmt|;
DECL|method|DumbQueryWrapper
specifier|public
name|DumbQueryWrapper
parameter_list|(
name|Query
name|q
parameter_list|)
block|{
name|super
argument_list|()
expr_stmt|;
name|this
operator|.
name|q
operator|=
name|q
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|(
name|String
name|f
parameter_list|)
block|{
return|return
name|q
operator|.
name|toString
argument_list|(
name|f
argument_list|)
return|;
block|}
block|}
block|}
end_class
end_unit
