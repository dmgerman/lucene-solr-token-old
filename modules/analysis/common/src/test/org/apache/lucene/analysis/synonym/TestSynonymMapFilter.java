begin_unit
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_package
DECL|package|org.apache.lucene.analysis.synonym
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|synonym
package|;
end_package
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Reader
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|StringReader
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|Analyzer
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|BaseTokenStreamTestCase
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|MockAnalyzer
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|MockTokenizer
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|Tokenizer
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|tokenattributes
operator|.
name|*
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|CharsRef
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|_TestUtil
import|;
end_import
begin_class
DECL|class|TestSynonymMapFilter
specifier|public
class|class
name|TestSynonymMapFilter
extends|extends
name|BaseTokenStreamTestCase
block|{
DECL|field|b
specifier|private
name|SynonymMap
operator|.
name|Builder
name|b
decl_stmt|;
DECL|field|tokensIn
specifier|private
name|Tokenizer
name|tokensIn
decl_stmt|;
DECL|field|tokensOut
specifier|private
name|SynonymFilter
name|tokensOut
decl_stmt|;
DECL|field|termAtt
specifier|private
name|CharTermAttribute
name|termAtt
decl_stmt|;
DECL|field|posIncrAtt
specifier|private
name|PositionIncrementAttribute
name|posIncrAtt
decl_stmt|;
DECL|field|offsetAtt
specifier|private
name|OffsetAttribute
name|offsetAtt
decl_stmt|;
DECL|method|add
specifier|private
name|void
name|add
parameter_list|(
name|String
name|input
parameter_list|,
name|String
name|output
parameter_list|,
name|boolean
name|keepOrig
parameter_list|)
block|{
name|b
operator|.
name|add
argument_list|(
operator|new
name|CharsRef
argument_list|(
name|input
operator|.
name|replaceAll
argument_list|(
literal|" +"
argument_list|,
literal|"\u0000"
argument_list|)
argument_list|)
argument_list|,
operator|new
name|CharsRef
argument_list|(
name|output
operator|.
name|replaceAll
argument_list|(
literal|" +"
argument_list|,
literal|"\u0000"
argument_list|)
argument_list|)
argument_list|,
name|keepOrig
argument_list|)
expr_stmt|;
block|}
DECL|method|assertEquals
specifier|private
name|void
name|assertEquals
parameter_list|(
name|CharTermAttribute
name|term
parameter_list|,
name|String
name|expected
parameter_list|)
block|{
name|assertEquals
argument_list|(
name|expected
operator|.
name|length
argument_list|()
argument_list|,
name|term
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
specifier|final
name|char
index|[]
name|buffer
init|=
name|term
operator|.
name|buffer
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|chIDX
init|=
literal|0
init|;
name|chIDX
operator|<
name|expected
operator|.
name|length
argument_list|()
condition|;
name|chIDX
operator|++
control|)
block|{
name|assertEquals
argument_list|(
name|expected
operator|.
name|charAt
argument_list|(
name|chIDX
argument_list|)
argument_list|,
name|buffer
index|[
name|chIDX
index|]
argument_list|)
expr_stmt|;
block|}
block|}
comment|// todo: we should probably refactor this guy to use/take analyzer,
comment|// the tests are a little messy
DECL|method|verify
specifier|private
name|void
name|verify
parameter_list|(
name|String
name|input
parameter_list|,
name|String
name|output
parameter_list|)
throws|throws
name|Exception
block|{
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"TEST: verify input="
operator|+
name|input
operator|+
literal|" expectedOutput="
operator|+
name|output
argument_list|)
expr_stmt|;
block|}
name|tokensIn
operator|.
name|reset
argument_list|(
operator|new
name|StringReader
argument_list|(
name|input
argument_list|)
argument_list|)
expr_stmt|;
name|tokensOut
operator|.
name|reset
argument_list|()
expr_stmt|;
specifier|final
name|String
index|[]
name|expected
init|=
name|output
operator|.
name|split
argument_list|(
literal|" "
argument_list|)
decl_stmt|;
name|int
name|expectedUpto
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|tokensOut
operator|.
name|incrementToken
argument_list|()
condition|)
block|{
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"  incr token="
operator|+
name|termAtt
operator|.
name|toString
argument_list|()
operator|+
literal|" posIncr="
operator|+
name|posIncrAtt
operator|.
name|getPositionIncrement
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|assertTrue
argument_list|(
name|expectedUpto
operator|<
name|expected
operator|.
name|length
argument_list|)
expr_stmt|;
specifier|final
name|int
name|startOffset
init|=
name|offsetAtt
operator|.
name|startOffset
argument_list|()
decl_stmt|;
specifier|final
name|int
name|endOffset
init|=
name|offsetAtt
operator|.
name|endOffset
argument_list|()
decl_stmt|;
specifier|final
name|String
index|[]
name|expectedAtPos
init|=
name|expected
index|[
name|expectedUpto
operator|++
index|]
operator|.
name|split
argument_list|(
literal|"/"
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|atPos
init|=
literal|0
init|;
name|atPos
operator|<
name|expectedAtPos
operator|.
name|length
condition|;
name|atPos
operator|++
control|)
block|{
if|if
condition|(
name|atPos
operator|>
literal|0
condition|)
block|{
name|assertTrue
argument_list|(
name|tokensOut
operator|.
name|incrementToken
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"  incr token="
operator|+
name|termAtt
operator|.
name|toString
argument_list|()
operator|+
literal|" posIncr="
operator|+
name|posIncrAtt
operator|.
name|getPositionIncrement
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|assertEquals
argument_list|(
name|termAtt
argument_list|,
name|expectedAtPos
index|[
name|atPos
index|]
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|atPos
operator|==
literal|0
condition|?
literal|1
else|:
literal|0
argument_list|,
name|posIncrAtt
operator|.
name|getPositionIncrement
argument_list|()
argument_list|)
expr_stmt|;
comment|// start/end offset of all tokens at same pos should
comment|// be the same:
name|assertEquals
argument_list|(
name|startOffset
argument_list|,
name|offsetAtt
operator|.
name|startOffset
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|endOffset
argument_list|,
name|offsetAtt
operator|.
name|endOffset
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|tokensOut
operator|.
name|end
argument_list|()
expr_stmt|;
name|tokensOut
operator|.
name|close
argument_list|()
expr_stmt|;
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"  incr: END"
argument_list|)
expr_stmt|;
block|}
name|assertEquals
argument_list|(
name|expectedUpto
argument_list|,
name|expected
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
DECL|method|testBasic
specifier|public
name|void
name|testBasic
parameter_list|()
throws|throws
name|Exception
block|{
name|b
operator|=
operator|new
name|SynonymMap
operator|.
name|Builder
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|add
argument_list|(
literal|"a"
argument_list|,
literal|"foo"
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|add
argument_list|(
literal|"a b"
argument_list|,
literal|"bar fee"
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|add
argument_list|(
literal|"b c"
argument_list|,
literal|"dog collar"
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|add
argument_list|(
literal|"c d"
argument_list|,
literal|"dog harness holder extras"
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|add
argument_list|(
literal|"m c e"
argument_list|,
literal|"dog barks loudly"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|add
argument_list|(
literal|"e f"
argument_list|,
literal|"foo bar"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|add
argument_list|(
literal|"e f"
argument_list|,
literal|"baz bee"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|add
argument_list|(
literal|"z"
argument_list|,
literal|"boo"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|add
argument_list|(
literal|"y"
argument_list|,
literal|"bee"
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|tokensIn
operator|=
operator|new
name|MockTokenizer
argument_list|(
operator|new
name|StringReader
argument_list|(
literal|"a"
argument_list|)
argument_list|,
name|MockTokenizer
operator|.
name|WHITESPACE
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|tokensIn
operator|.
name|reset
argument_list|()
expr_stmt|;
name|assertTrue
argument_list|(
name|tokensIn
operator|.
name|incrementToken
argument_list|()
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|tokensIn
operator|.
name|incrementToken
argument_list|()
argument_list|)
expr_stmt|;
name|tokensIn
operator|.
name|end
argument_list|()
expr_stmt|;
name|tokensIn
operator|.
name|close
argument_list|()
expr_stmt|;
name|tokensOut
operator|=
operator|new
name|SynonymFilter
argument_list|(
name|tokensIn
argument_list|,
name|b
operator|.
name|build
argument_list|()
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|termAtt
operator|=
name|tokensOut
operator|.
name|addAttribute
argument_list|(
name|CharTermAttribute
operator|.
name|class
argument_list|)
expr_stmt|;
name|posIncrAtt
operator|=
name|tokensOut
operator|.
name|addAttribute
argument_list|(
name|PositionIncrementAttribute
operator|.
name|class
argument_list|)
expr_stmt|;
name|offsetAtt
operator|=
name|tokensOut
operator|.
name|addAttribute
argument_list|(
name|OffsetAttribute
operator|.
name|class
argument_list|)
expr_stmt|;
name|verify
argument_list|(
literal|"a b c"
argument_list|,
literal|"a/bar b/fee c"
argument_list|)
expr_stmt|;
comment|// syn output extends beyond input tokens
name|verify
argument_list|(
literal|"x a b c d"
argument_list|,
literal|"x a/bar b/fee c/dog d/harness holder extras"
argument_list|)
expr_stmt|;
name|verify
argument_list|(
literal|"a b a"
argument_list|,
literal|"a/bar b/fee a/foo"
argument_list|)
expr_stmt|;
comment|// outputs that add to one another:
name|verify
argument_list|(
literal|"c d c d"
argument_list|,
literal|"c/dog d/harness c/holder/dog d/extras/harness holder extras"
argument_list|)
expr_stmt|;
comment|// two outputs for same input
name|verify
argument_list|(
literal|"e f"
argument_list|,
literal|"foo/baz bar/bee"
argument_list|)
expr_stmt|;
comment|// mixed keepOrig true/false:
name|verify
argument_list|(
literal|"a m c e x"
argument_list|,
literal|"a/foo dog barks loudly x"
argument_list|)
expr_stmt|;
name|verify
argument_list|(
literal|"c d m c e x"
argument_list|,
literal|"c/dog d/harness holder/dog extras/barks loudly x"
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|tokensOut
operator|.
name|getCaptureCount
argument_list|()
operator|>
literal|0
argument_list|)
expr_stmt|;
comment|// no captureStates when no syns matched
name|verify
argument_list|(
literal|"p q r s t"
argument_list|,
literal|"p q r s t"
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|tokensOut
operator|.
name|getCaptureCount
argument_list|()
argument_list|)
expr_stmt|;
comment|// no captureStates when only single-input syns, w/ no
comment|// lookahead needed, matched
name|verify
argument_list|(
literal|"p q z y t"
argument_list|,
literal|"p q boo y/bee t"
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|tokensOut
operator|.
name|getCaptureCount
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|getRandomString
specifier|private
name|String
name|getRandomString
parameter_list|(
name|char
name|start
parameter_list|,
name|int
name|alphabetSize
parameter_list|,
name|int
name|length
parameter_list|)
block|{
assert|assert
name|alphabetSize
operator|<=
literal|26
assert|;
name|char
index|[]
name|s
init|=
operator|new
name|char
index|[
literal|2
operator|*
name|length
index|]
decl_stmt|;
for|for
control|(
name|int
name|charIDX
init|=
literal|0
init|;
name|charIDX
operator|<
name|length
condition|;
name|charIDX
operator|++
control|)
block|{
name|s
index|[
literal|2
operator|*
name|charIDX
index|]
operator|=
call|(
name|char
call|)
argument_list|(
name|start
operator|+
name|random
operator|.
name|nextInt
argument_list|(
name|alphabetSize
argument_list|)
argument_list|)
expr_stmt|;
name|s
index|[
literal|2
operator|*
name|charIDX
operator|+
literal|1
index|]
operator|=
literal|' '
expr_stmt|;
block|}
return|return
operator|new
name|String
argument_list|(
name|s
argument_list|)
return|;
block|}
DECL|class|OneSyn
specifier|private
specifier|static
class|class
name|OneSyn
block|{
DECL|field|in
name|String
name|in
decl_stmt|;
DECL|field|out
name|List
argument_list|<
name|String
argument_list|>
name|out
decl_stmt|;
DECL|field|keepOrig
name|boolean
name|keepOrig
decl_stmt|;
block|}
DECL|method|slowSynMatcher
specifier|public
name|String
name|slowSynMatcher
parameter_list|(
name|String
name|doc
parameter_list|,
name|List
argument_list|<
name|OneSyn
argument_list|>
name|syns
parameter_list|,
name|int
name|maxOutputLength
parameter_list|)
block|{
name|assertTrue
argument_list|(
name|doc
operator|.
name|length
argument_list|()
operator|%
literal|2
operator|==
literal|0
argument_list|)
expr_stmt|;
specifier|final
name|int
name|numInputs
init|=
name|doc
operator|.
name|length
argument_list|()
operator|/
literal|2
decl_stmt|;
name|boolean
index|[]
name|keepOrigs
init|=
operator|new
name|boolean
index|[
name|numInputs
index|]
decl_stmt|;
name|boolean
index|[]
name|hasMatch
init|=
operator|new
name|boolean
index|[
name|numInputs
index|]
decl_stmt|;
name|Arrays
operator|.
name|fill
argument_list|(
name|keepOrigs
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|String
index|[]
name|outputs
init|=
operator|new
name|String
index|[
name|numInputs
operator|+
name|maxOutputLength
index|]
decl_stmt|;
name|OneSyn
index|[]
name|matches
init|=
operator|new
name|OneSyn
index|[
name|numInputs
index|]
decl_stmt|;
for|for
control|(
name|OneSyn
name|syn
range|:
name|syns
control|)
block|{
name|int
name|idx
init|=
operator|-
literal|1
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|idx
operator|=
name|doc
operator|.
name|indexOf
argument_list|(
name|syn
operator|.
name|in
argument_list|,
literal|1
operator|+
name|idx
argument_list|)
expr_stmt|;
if|if
condition|(
name|idx
operator|==
operator|-
literal|1
condition|)
block|{
break|break;
block|}
name|assertTrue
argument_list|(
name|idx
operator|%
literal|2
operator|==
literal|0
argument_list|)
expr_stmt|;
specifier|final
name|int
name|matchIDX
init|=
name|idx
operator|/
literal|2
decl_stmt|;
name|assertTrue
argument_list|(
name|syn
operator|.
name|in
operator|.
name|length
argument_list|()
operator|%
literal|2
operator|==
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|matches
index|[
name|matchIDX
index|]
operator|==
literal|null
condition|)
block|{
name|matches
index|[
name|matchIDX
index|]
operator|=
name|syn
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|syn
operator|.
name|in
operator|.
name|length
argument_list|()
operator|>
name|matches
index|[
name|matchIDX
index|]
operator|.
name|in
operator|.
name|length
argument_list|()
condition|)
block|{
comment|// Greedy conflict resolution: longer match wins:
name|matches
index|[
name|matchIDX
index|]
operator|=
name|syn
expr_stmt|;
block|}
else|else
block|{
name|assertTrue
argument_list|(
name|syn
operator|.
name|in
operator|.
name|length
argument_list|()
operator|<
name|matches
index|[
name|matchIDX
index|]
operator|.
name|in
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// Greedy conflict resolution: if syn matches a range of inputs,
comment|// it prevents other syns from matching that range
for|for
control|(
name|int
name|inputIDX
init|=
literal|0
init|;
name|inputIDX
operator|<
name|numInputs
condition|;
name|inputIDX
operator|++
control|)
block|{
specifier|final
name|OneSyn
name|match
init|=
name|matches
index|[
name|inputIDX
index|]
decl_stmt|;
if|if
condition|(
name|match
operator|!=
literal|null
condition|)
block|{
specifier|final
name|int
name|synInLength
init|=
operator|(
literal|1
operator|+
name|match
operator|.
name|in
operator|.
name|length
argument_list|()
operator|)
operator|/
literal|2
decl_stmt|;
for|for
control|(
name|int
name|nextInputIDX
init|=
name|inputIDX
operator|+
literal|1
init|;
name|nextInputIDX
operator|<
name|numInputs
operator|&&
name|nextInputIDX
operator|<
operator|(
name|inputIDX
operator|+
name|synInLength
operator|)
condition|;
name|nextInputIDX
operator|++
control|)
block|{
name|matches
index|[
name|nextInputIDX
index|]
operator|=
literal|null
expr_stmt|;
block|}
block|}
block|}
comment|// Fill overlapping outputs:
for|for
control|(
name|int
name|inputIDX
init|=
literal|0
init|;
name|inputIDX
operator|<
name|numInputs
condition|;
name|inputIDX
operator|++
control|)
block|{
specifier|final
name|OneSyn
name|syn
init|=
name|matches
index|[
name|inputIDX
index|]
decl_stmt|;
if|if
condition|(
name|syn
operator|==
literal|null
condition|)
block|{
continue|continue;
block|}
for|for
control|(
name|int
name|idx
init|=
literal|0
init|;
name|idx
operator|<
operator|(
literal|1
operator|+
name|syn
operator|.
name|in
operator|.
name|length
argument_list|()
operator|)
operator|/
literal|2
condition|;
name|idx
operator|++
control|)
block|{
name|hasMatch
index|[
name|inputIDX
operator|+
name|idx
index|]
operator|=
literal|true
expr_stmt|;
name|keepOrigs
index|[
name|inputIDX
operator|+
name|idx
index|]
operator||=
name|syn
operator|.
name|keepOrig
expr_stmt|;
block|}
for|for
control|(
name|String
name|synOut
range|:
name|syn
operator|.
name|out
control|)
block|{
specifier|final
name|String
index|[]
name|synOutputs
init|=
name|synOut
operator|.
name|split
argument_list|(
literal|" "
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|synOutputs
operator|.
name|length
argument_list|,
operator|(
literal|1
operator|+
name|synOut
operator|.
name|length
argument_list|()
operator|)
operator|/
literal|2
argument_list|)
expr_stmt|;
specifier|final
name|int
name|matchEnd
init|=
name|inputIDX
operator|+
name|synOutputs
operator|.
name|length
decl_stmt|;
name|int
name|synUpto
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|matchIDX
init|=
name|inputIDX
init|;
name|matchIDX
operator|<
name|matchEnd
condition|;
name|matchIDX
operator|++
control|)
block|{
if|if
condition|(
name|outputs
index|[
name|matchIDX
index|]
operator|==
literal|null
condition|)
block|{
name|outputs
index|[
name|matchIDX
index|]
operator|=
name|synOutputs
index|[
name|synUpto
operator|++
index|]
expr_stmt|;
block|}
else|else
block|{
name|outputs
index|[
name|matchIDX
index|]
operator|=
name|outputs
index|[
name|matchIDX
index|]
operator|+
literal|"/"
operator|+
name|synOutputs
index|[
name|synUpto
operator|++
index|]
expr_stmt|;
block|}
block|}
block|}
block|}
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|String
index|[]
name|inputTokens
init|=
name|doc
operator|.
name|split
argument_list|(
literal|" "
argument_list|)
decl_stmt|;
specifier|final
name|int
name|limit
init|=
name|inputTokens
operator|.
name|length
operator|+
name|maxOutputLength
decl_stmt|;
for|for
control|(
name|int
name|inputIDX
init|=
literal|0
init|;
name|inputIDX
operator|<
name|limit
condition|;
name|inputIDX
operator|++
control|)
block|{
name|boolean
name|posHasOutput
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|inputIDX
operator|>=
name|numInputs
operator|&&
name|outputs
index|[
name|inputIDX
index|]
operator|==
literal|null
condition|)
block|{
break|break;
block|}
if|if
condition|(
name|inputIDX
operator|<
name|numInputs
operator|&&
operator|(
operator|!
name|hasMatch
index|[
name|inputIDX
index|]
operator|||
name|keepOrigs
index|[
name|inputIDX
index|]
operator|)
condition|)
block|{
name|assertTrue
argument_list|(
name|inputTokens
index|[
name|inputIDX
index|]
operator|.
name|length
argument_list|()
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|inputTokens
index|[
name|inputIDX
index|]
argument_list|)
expr_stmt|;
name|posHasOutput
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|outputs
index|[
name|inputIDX
index|]
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|posHasOutput
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|'/'
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
name|outputs
index|[
name|inputIDX
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|posHasOutput
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|inputIDX
operator|<
name|limit
operator|-
literal|1
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
DECL|method|testRandom
specifier|public
name|void
name|testRandom
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|int
name|alphabetSize
init|=
name|_TestUtil
operator|.
name|nextInt
argument_list|(
name|random
argument_list|,
literal|2
argument_list|,
literal|7
argument_list|)
decl_stmt|;
specifier|final
name|int
name|docLen
init|=
name|atLeast
argument_list|(
literal|3000
argument_list|)
decl_stmt|;
comment|//final int docLen = 50;
specifier|final
name|String
name|document
init|=
name|getRandomString
argument_list|(
literal|'a'
argument_list|,
name|alphabetSize
argument_list|,
name|docLen
argument_list|)
decl_stmt|;
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"TEST: doc="
operator|+
name|document
argument_list|)
expr_stmt|;
block|}
specifier|final
name|int
name|numSyn
init|=
name|atLeast
argument_list|(
literal|5
argument_list|)
decl_stmt|;
comment|//final int numSyn = 2;
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|OneSyn
argument_list|>
name|synMap
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|OneSyn
argument_list|>
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|OneSyn
argument_list|>
name|syns
init|=
operator|new
name|ArrayList
argument_list|<
name|OneSyn
argument_list|>
argument_list|()
decl_stmt|;
specifier|final
name|boolean
name|dedup
init|=
name|random
operator|.
name|nextBoolean
argument_list|()
decl_stmt|;
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"  dedup="
operator|+
name|dedup
argument_list|)
expr_stmt|;
block|}
name|b
operator|=
operator|new
name|SynonymMap
operator|.
name|Builder
argument_list|(
name|dedup
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|synIDX
init|=
literal|0
init|;
name|synIDX
operator|<
name|numSyn
condition|;
name|synIDX
operator|++
control|)
block|{
specifier|final
name|String
name|synIn
init|=
name|getRandomString
argument_list|(
literal|'a'
argument_list|,
name|alphabetSize
argument_list|,
name|_TestUtil
operator|.
name|nextInt
argument_list|(
name|random
argument_list|,
literal|1
argument_list|,
literal|5
argument_list|)
argument_list|)
operator|.
name|trim
argument_list|()
decl_stmt|;
name|OneSyn
name|s
init|=
name|synMap
operator|.
name|get
argument_list|(
name|synIn
argument_list|)
decl_stmt|;
if|if
condition|(
name|s
operator|==
literal|null
condition|)
block|{
name|s
operator|=
operator|new
name|OneSyn
argument_list|()
expr_stmt|;
name|s
operator|.
name|in
operator|=
name|synIn
expr_stmt|;
name|syns
operator|.
name|add
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|s
operator|.
name|out
operator|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
expr_stmt|;
name|synMap
operator|.
name|put
argument_list|(
name|synIn
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|s
operator|.
name|keepOrig
operator|=
name|random
operator|.
name|nextBoolean
argument_list|()
expr_stmt|;
block|}
specifier|final
name|String
name|synOut
init|=
name|getRandomString
argument_list|(
literal|'0'
argument_list|,
literal|10
argument_list|,
name|_TestUtil
operator|.
name|nextInt
argument_list|(
name|random
argument_list|,
literal|1
argument_list|,
literal|5
argument_list|)
argument_list|)
operator|.
name|trim
argument_list|()
decl_stmt|;
name|s
operator|.
name|out
operator|.
name|add
argument_list|(
name|synOut
argument_list|)
expr_stmt|;
name|add
argument_list|(
name|synIn
argument_list|,
name|synOut
argument_list|,
name|s
operator|.
name|keepOrig
argument_list|)
expr_stmt|;
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"  syns["
operator|+
name|synIDX
operator|+
literal|"] = "
operator|+
name|s
operator|.
name|in
operator|+
literal|" -> "
operator|+
name|s
operator|.
name|out
operator|+
literal|" keepOrig="
operator|+
name|s
operator|.
name|keepOrig
argument_list|)
expr_stmt|;
block|}
block|}
name|tokensIn
operator|=
operator|new
name|MockTokenizer
argument_list|(
operator|new
name|StringReader
argument_list|(
literal|"a"
argument_list|)
argument_list|,
name|MockTokenizer
operator|.
name|WHITESPACE
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|tokensIn
operator|.
name|reset
argument_list|()
expr_stmt|;
name|assertTrue
argument_list|(
name|tokensIn
operator|.
name|incrementToken
argument_list|()
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|tokensIn
operator|.
name|incrementToken
argument_list|()
argument_list|)
expr_stmt|;
name|tokensIn
operator|.
name|end
argument_list|()
expr_stmt|;
name|tokensIn
operator|.
name|close
argument_list|()
expr_stmt|;
name|tokensOut
operator|=
operator|new
name|SynonymFilter
argument_list|(
name|tokensIn
argument_list|,
name|b
operator|.
name|build
argument_list|()
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|termAtt
operator|=
name|tokensOut
operator|.
name|addAttribute
argument_list|(
name|CharTermAttribute
operator|.
name|class
argument_list|)
expr_stmt|;
name|posIncrAtt
operator|=
name|tokensOut
operator|.
name|addAttribute
argument_list|(
name|PositionIncrementAttribute
operator|.
name|class
argument_list|)
expr_stmt|;
name|offsetAtt
operator|=
name|tokensOut
operator|.
name|addAttribute
argument_list|(
name|OffsetAttribute
operator|.
name|class
argument_list|)
expr_stmt|;
if|if
condition|(
name|dedup
condition|)
block|{
name|pruneDups
argument_list|(
name|syns
argument_list|)
expr_stmt|;
block|}
specifier|final
name|String
name|expected
init|=
name|slowSynMatcher
argument_list|(
name|document
argument_list|,
name|syns
argument_list|,
literal|5
argument_list|)
decl_stmt|;
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"TEST: expected="
operator|+
name|expected
argument_list|)
expr_stmt|;
block|}
name|verify
argument_list|(
name|document
argument_list|,
name|expected
argument_list|)
expr_stmt|;
block|}
DECL|method|pruneDups
specifier|private
name|void
name|pruneDups
parameter_list|(
name|List
argument_list|<
name|OneSyn
argument_list|>
name|syns
parameter_list|)
block|{
name|Set
argument_list|<
name|String
argument_list|>
name|seen
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|OneSyn
name|syn
range|:
name|syns
control|)
block|{
name|int
name|idx
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|idx
operator|<
name|syn
operator|.
name|out
operator|.
name|size
argument_list|()
condition|)
block|{
name|String
name|out
init|=
name|syn
operator|.
name|out
operator|.
name|get
argument_list|(
name|idx
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|seen
operator|.
name|contains
argument_list|(
name|out
argument_list|)
condition|)
block|{
name|seen
operator|.
name|add
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|idx
operator|++
expr_stmt|;
block|}
else|else
block|{
name|syn
operator|.
name|out
operator|.
name|remove
argument_list|(
name|idx
argument_list|)
expr_stmt|;
block|}
block|}
name|seen
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|randomNonEmptyString
specifier|private
name|String
name|randomNonEmptyString
parameter_list|()
block|{
while|while
condition|(
literal|true
condition|)
block|{
specifier|final
name|String
name|s
init|=
name|_TestUtil
operator|.
name|randomUnicodeString
argument_list|(
name|random
argument_list|)
operator|.
name|trim
argument_list|()
decl_stmt|;
if|if
condition|(
name|s
operator|.
name|length
argument_list|()
operator|!=
literal|0
operator|&&
name|s
operator|.
name|indexOf
argument_list|(
literal|'\u0000'
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
return|return
name|s
return|;
block|}
block|}
block|}
comment|/** simple random test, doesn't verify correctness.    *  does verify it doesnt throw exceptions, or that the stream doesn't misbehave    */
DECL|method|testRandom2
specifier|public
name|void
name|testRandom2
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|int
name|numIters
init|=
name|atLeast
argument_list|(
literal|10
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numIters
condition|;
name|i
operator|++
control|)
block|{
name|b
operator|=
operator|new
name|SynonymMap
operator|.
name|Builder
argument_list|(
name|random
operator|.
name|nextBoolean
argument_list|()
argument_list|)
expr_stmt|;
specifier|final
name|int
name|numEntries
init|=
name|atLeast
argument_list|(
literal|10
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|numEntries
condition|;
name|j
operator|++
control|)
block|{
name|add
argument_list|(
name|randomNonEmptyString
argument_list|()
argument_list|,
name|randomNonEmptyString
argument_list|()
argument_list|,
name|random
operator|.
name|nextBoolean
argument_list|()
argument_list|)
expr_stmt|;
block|}
specifier|final
name|SynonymMap
name|map
init|=
name|b
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|boolean
name|ignoreCase
init|=
name|random
operator|.
name|nextBoolean
argument_list|()
decl_stmt|;
specifier|final
name|Analyzer
name|analyzer
init|=
operator|new
name|Analyzer
argument_list|()
block|{
annotation|@
name|Override
specifier|protected
name|TokenStreamComponents
name|createComponents
parameter_list|(
name|String
name|fieldName
parameter_list|,
name|Reader
name|reader
parameter_list|)
block|{
name|Tokenizer
name|tokenizer
init|=
operator|new
name|MockTokenizer
argument_list|(
name|reader
argument_list|,
name|MockTokenizer
operator|.
name|SIMPLE
argument_list|,
literal|true
argument_list|)
decl_stmt|;
return|return
operator|new
name|TokenStreamComponents
argument_list|(
name|tokenizer
argument_list|,
operator|new
name|SynonymFilter
argument_list|(
name|tokenizer
argument_list|,
name|map
argument_list|,
name|ignoreCase
argument_list|)
argument_list|)
return|;
block|}
block|}
decl_stmt|;
name|checkRandomData
argument_list|(
name|random
argument_list|,
name|analyzer
argument_list|,
literal|1000
operator|*
name|RANDOM_MULTIPLIER
argument_list|)
expr_stmt|;
block|}
block|}
comment|// LUCENE-3375
DECL|method|testVanishingTerms
specifier|public
name|void
name|testVanishingTerms
parameter_list|()
throws|throws
name|Exception
block|{
name|String
name|testFile
init|=
literal|"aaa => aaaa1 aaaa2 aaaa3\n"
operator|+
literal|"bbb => bbbb1 bbbb2\n"
decl_stmt|;
name|SolrSynonymParser
name|parser
init|=
operator|new
name|SolrSynonymParser
argument_list|(
literal|true
argument_list|,
literal|true
argument_list|,
operator|new
name|MockAnalyzer
argument_list|(
name|random
argument_list|)
argument_list|)
decl_stmt|;
name|parser
operator|.
name|add
argument_list|(
operator|new
name|StringReader
argument_list|(
name|testFile
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|SynonymMap
name|map
init|=
name|parser
operator|.
name|build
argument_list|()
decl_stmt|;
name|Analyzer
name|analyzer
init|=
operator|new
name|Analyzer
argument_list|()
block|{
annotation|@
name|Override
specifier|protected
name|TokenStreamComponents
name|createComponents
parameter_list|(
name|String
name|fieldName
parameter_list|,
name|Reader
name|reader
parameter_list|)
block|{
name|Tokenizer
name|tokenizer
init|=
operator|new
name|MockTokenizer
argument_list|(
name|reader
argument_list|,
name|MockTokenizer
operator|.
name|WHITESPACE
argument_list|,
literal|true
argument_list|)
decl_stmt|;
return|return
operator|new
name|TokenStreamComponents
argument_list|(
name|tokenizer
argument_list|,
operator|new
name|SynonymFilter
argument_list|(
name|tokenizer
argument_list|,
name|map
argument_list|,
literal|true
argument_list|)
argument_list|)
return|;
block|}
block|}
decl_stmt|;
comment|// where did my pot go?!
name|assertAnalyzesTo
argument_list|(
name|analyzer
argument_list|,
literal|"xyzzy bbb pot of gold"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"xyzzy"
block|,
literal|"bbbb1"
block|,
literal|"pot"
block|,
literal|"bbbb2"
block|,
literal|"of"
block|,
literal|"gold"
block|}
argument_list|)
expr_stmt|;
comment|// this one nukes 'pot' and 'of'
comment|// xyzzy aaa pot of gold -> xyzzy aaaa1 aaaa2 aaaa3 gold
name|assertAnalyzesTo
argument_list|(
name|analyzer
argument_list|,
literal|"xyzzy aaa pot of gold"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"xyzzy"
block|,
literal|"aaaa1"
block|,
literal|"pot"
block|,
literal|"aaaa2"
block|,
literal|"of"
block|,
literal|"aaaa3"
block|,
literal|"gold"
block|}
argument_list|)
expr_stmt|;
block|}
DECL|method|testBasic2
specifier|public
name|void
name|testBasic2
parameter_list|()
throws|throws
name|Exception
block|{
name|b
operator|=
operator|new
name|SynonymMap
operator|.
name|Builder
argument_list|(
literal|true
argument_list|)
expr_stmt|;
specifier|final
name|boolean
name|keepOrig
init|=
literal|false
decl_stmt|;
name|add
argument_list|(
literal|"aaa"
argument_list|,
literal|"aaaa1 aaaa2 aaaa3"
argument_list|,
name|keepOrig
argument_list|)
expr_stmt|;
name|add
argument_list|(
literal|"bbb"
argument_list|,
literal|"bbbb1 bbbb2"
argument_list|,
name|keepOrig
argument_list|)
expr_stmt|;
name|tokensIn
operator|=
operator|new
name|MockTokenizer
argument_list|(
operator|new
name|StringReader
argument_list|(
literal|"a"
argument_list|)
argument_list|,
name|MockTokenizer
operator|.
name|WHITESPACE
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|tokensIn
operator|.
name|reset
argument_list|()
expr_stmt|;
name|assertTrue
argument_list|(
name|tokensIn
operator|.
name|incrementToken
argument_list|()
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|tokensIn
operator|.
name|incrementToken
argument_list|()
argument_list|)
expr_stmt|;
name|tokensIn
operator|.
name|end
argument_list|()
expr_stmt|;
name|tokensIn
operator|.
name|close
argument_list|()
expr_stmt|;
name|tokensOut
operator|=
operator|new
name|SynonymFilter
argument_list|(
name|tokensIn
argument_list|,
name|b
operator|.
name|build
argument_list|()
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|termAtt
operator|=
name|tokensOut
operator|.
name|addAttribute
argument_list|(
name|CharTermAttribute
operator|.
name|class
argument_list|)
expr_stmt|;
name|posIncrAtt
operator|=
name|tokensOut
operator|.
name|addAttribute
argument_list|(
name|PositionIncrementAttribute
operator|.
name|class
argument_list|)
expr_stmt|;
name|offsetAtt
operator|=
name|tokensOut
operator|.
name|addAttribute
argument_list|(
name|OffsetAttribute
operator|.
name|class
argument_list|)
expr_stmt|;
if|if
condition|(
name|keepOrig
condition|)
block|{
name|verify
argument_list|(
literal|"xyzzy bbb pot of gold"
argument_list|,
literal|"xyzzy bbb/bbbb1 pot/bbbb2 of gold"
argument_list|)
expr_stmt|;
name|verify
argument_list|(
literal|"xyzzy aaa pot of gold"
argument_list|,
literal|"xyzzy aaa/aaaa1 pot/aaaa2 of/aaaa3 gold"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|verify
argument_list|(
literal|"xyzzy bbb pot of gold"
argument_list|,
literal|"xyzzy bbbb1 pot/bbbb2 of gold"
argument_list|)
expr_stmt|;
name|verify
argument_list|(
literal|"xyzzy aaa pot of gold"
argument_list|,
literal|"xyzzy aaaa1 pot/aaaa2 of/aaaa3 gold"
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|testMatching
specifier|public
name|void
name|testMatching
parameter_list|()
throws|throws
name|Exception
block|{
name|b
operator|=
operator|new
name|SynonymMap
operator|.
name|Builder
argument_list|(
literal|true
argument_list|)
expr_stmt|;
specifier|final
name|boolean
name|keepOrig
init|=
literal|false
decl_stmt|;
name|add
argument_list|(
literal|"a b"
argument_list|,
literal|"ab"
argument_list|,
name|keepOrig
argument_list|)
expr_stmt|;
name|add
argument_list|(
literal|"a c"
argument_list|,
literal|"ac"
argument_list|,
name|keepOrig
argument_list|)
expr_stmt|;
name|add
argument_list|(
literal|"a"
argument_list|,
literal|"aa"
argument_list|,
name|keepOrig
argument_list|)
expr_stmt|;
name|add
argument_list|(
literal|"b"
argument_list|,
literal|"bb"
argument_list|,
name|keepOrig
argument_list|)
expr_stmt|;
name|add
argument_list|(
literal|"z x c v"
argument_list|,
literal|"zxcv"
argument_list|,
name|keepOrig
argument_list|)
expr_stmt|;
name|add
argument_list|(
literal|"x c"
argument_list|,
literal|"xc"
argument_list|,
name|keepOrig
argument_list|)
expr_stmt|;
specifier|final
name|SynonymMap
name|map
init|=
name|b
operator|.
name|build
argument_list|()
decl_stmt|;
name|Analyzer
name|a
init|=
operator|new
name|Analyzer
argument_list|()
block|{
annotation|@
name|Override
specifier|protected
name|TokenStreamComponents
name|createComponents
parameter_list|(
name|String
name|fieldName
parameter_list|,
name|Reader
name|reader
parameter_list|)
block|{
name|Tokenizer
name|tokenizer
init|=
operator|new
name|MockTokenizer
argument_list|(
name|reader
argument_list|,
name|MockTokenizer
operator|.
name|WHITESPACE
argument_list|,
literal|false
argument_list|)
decl_stmt|;
return|return
operator|new
name|TokenStreamComponents
argument_list|(
name|tokenizer
argument_list|,
operator|new
name|SynonymFilter
argument_list|(
name|tokenizer
argument_list|,
name|map
argument_list|,
literal|true
argument_list|)
argument_list|)
return|;
block|}
block|}
decl_stmt|;
name|checkOneTerm
argument_list|(
name|a
argument_list|,
literal|"$"
argument_list|,
literal|"$"
argument_list|)
expr_stmt|;
name|checkOneTerm
argument_list|(
name|a
argument_list|,
literal|"a"
argument_list|,
literal|"aa"
argument_list|)
expr_stmt|;
name|checkOneTerm
argument_list|(
name|a
argument_list|,
literal|"b"
argument_list|,
literal|"bb"
argument_list|)
expr_stmt|;
name|assertAnalyzesTo
argument_list|(
name|a
argument_list|,
literal|"a $"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"aa"
block|,
literal|"$"
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|,
literal|1
block|}
argument_list|)
expr_stmt|;
name|assertAnalyzesTo
argument_list|(
name|a
argument_list|,
literal|"$ a"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"$"
block|,
literal|"aa"
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|,
literal|1
block|}
argument_list|)
expr_stmt|;
name|assertAnalyzesTo
argument_list|(
name|a
argument_list|,
literal|"a a"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"aa"
block|,
literal|"aa"
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|,
literal|1
block|}
argument_list|)
expr_stmt|;
name|assertAnalyzesTo
argument_list|(
name|a
argument_list|,
literal|"z x c v"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"zxcv"
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|}
argument_list|)
expr_stmt|;
name|assertAnalyzesTo
argument_list|(
name|a
argument_list|,
literal|"z x c $"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"z"
block|,
literal|"xc"
block|,
literal|"$"
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|,
literal|1
block|,
literal|1
block|}
argument_list|)
expr_stmt|;
block|}
DECL|method|testRepeatsOff
specifier|public
name|void
name|testRepeatsOff
parameter_list|()
throws|throws
name|Exception
block|{
name|b
operator|=
operator|new
name|SynonymMap
operator|.
name|Builder
argument_list|(
literal|true
argument_list|)
expr_stmt|;
specifier|final
name|boolean
name|keepOrig
init|=
literal|false
decl_stmt|;
name|add
argument_list|(
literal|"a b"
argument_list|,
literal|"ab"
argument_list|,
name|keepOrig
argument_list|)
expr_stmt|;
name|add
argument_list|(
literal|"a b"
argument_list|,
literal|"ab"
argument_list|,
name|keepOrig
argument_list|)
expr_stmt|;
name|add
argument_list|(
literal|"a b"
argument_list|,
literal|"ab"
argument_list|,
name|keepOrig
argument_list|)
expr_stmt|;
specifier|final
name|SynonymMap
name|map
init|=
name|b
operator|.
name|build
argument_list|()
decl_stmt|;
name|Analyzer
name|a
init|=
operator|new
name|Analyzer
argument_list|()
block|{
annotation|@
name|Override
specifier|protected
name|TokenStreamComponents
name|createComponents
parameter_list|(
name|String
name|fieldName
parameter_list|,
name|Reader
name|reader
parameter_list|)
block|{
name|Tokenizer
name|tokenizer
init|=
operator|new
name|MockTokenizer
argument_list|(
name|reader
argument_list|,
name|MockTokenizer
operator|.
name|WHITESPACE
argument_list|,
literal|false
argument_list|)
decl_stmt|;
return|return
operator|new
name|TokenStreamComponents
argument_list|(
name|tokenizer
argument_list|,
operator|new
name|SynonymFilter
argument_list|(
name|tokenizer
argument_list|,
name|map
argument_list|,
literal|true
argument_list|)
argument_list|)
return|;
block|}
block|}
decl_stmt|;
name|assertAnalyzesTo
argument_list|(
name|a
argument_list|,
literal|"a b"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"ab"
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|}
argument_list|)
expr_stmt|;
block|}
DECL|method|testRepeatsOn
specifier|public
name|void
name|testRepeatsOn
parameter_list|()
throws|throws
name|Exception
block|{
name|b
operator|=
operator|new
name|SynonymMap
operator|.
name|Builder
argument_list|(
literal|false
argument_list|)
expr_stmt|;
specifier|final
name|boolean
name|keepOrig
init|=
literal|false
decl_stmt|;
name|add
argument_list|(
literal|"a b"
argument_list|,
literal|"ab"
argument_list|,
name|keepOrig
argument_list|)
expr_stmt|;
name|add
argument_list|(
literal|"a b"
argument_list|,
literal|"ab"
argument_list|,
name|keepOrig
argument_list|)
expr_stmt|;
name|add
argument_list|(
literal|"a b"
argument_list|,
literal|"ab"
argument_list|,
name|keepOrig
argument_list|)
expr_stmt|;
specifier|final
name|SynonymMap
name|map
init|=
name|b
operator|.
name|build
argument_list|()
decl_stmt|;
name|Analyzer
name|a
init|=
operator|new
name|Analyzer
argument_list|()
block|{
annotation|@
name|Override
specifier|protected
name|TokenStreamComponents
name|createComponents
parameter_list|(
name|String
name|fieldName
parameter_list|,
name|Reader
name|reader
parameter_list|)
block|{
name|Tokenizer
name|tokenizer
init|=
operator|new
name|MockTokenizer
argument_list|(
name|reader
argument_list|,
name|MockTokenizer
operator|.
name|WHITESPACE
argument_list|,
literal|false
argument_list|)
decl_stmt|;
return|return
operator|new
name|TokenStreamComponents
argument_list|(
name|tokenizer
argument_list|,
operator|new
name|SynonymFilter
argument_list|(
name|tokenizer
argument_list|,
name|map
argument_list|,
literal|true
argument_list|)
argument_list|)
return|;
block|}
block|}
decl_stmt|;
name|assertAnalyzesTo
argument_list|(
name|a
argument_list|,
literal|"a b"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"ab"
block|,
literal|"ab"
block|,
literal|"ab"
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|,
literal|0
block|,
literal|0
block|}
argument_list|)
expr_stmt|;
block|}
DECL|method|testRecursion
specifier|public
name|void
name|testRecursion
parameter_list|()
throws|throws
name|Exception
block|{
name|b
operator|=
operator|new
name|SynonymMap
operator|.
name|Builder
argument_list|(
literal|true
argument_list|)
expr_stmt|;
specifier|final
name|boolean
name|keepOrig
init|=
literal|false
decl_stmt|;
name|add
argument_list|(
literal|"zoo"
argument_list|,
literal|"zoo"
argument_list|,
name|keepOrig
argument_list|)
expr_stmt|;
specifier|final
name|SynonymMap
name|map
init|=
name|b
operator|.
name|build
argument_list|()
decl_stmt|;
name|Analyzer
name|a
init|=
operator|new
name|Analyzer
argument_list|()
block|{
annotation|@
name|Override
specifier|protected
name|TokenStreamComponents
name|createComponents
parameter_list|(
name|String
name|fieldName
parameter_list|,
name|Reader
name|reader
parameter_list|)
block|{
name|Tokenizer
name|tokenizer
init|=
operator|new
name|MockTokenizer
argument_list|(
name|reader
argument_list|,
name|MockTokenizer
operator|.
name|WHITESPACE
argument_list|,
literal|false
argument_list|)
decl_stmt|;
return|return
operator|new
name|TokenStreamComponents
argument_list|(
name|tokenizer
argument_list|,
operator|new
name|SynonymFilter
argument_list|(
name|tokenizer
argument_list|,
name|map
argument_list|,
literal|true
argument_list|)
argument_list|)
return|;
block|}
block|}
decl_stmt|;
name|assertAnalyzesTo
argument_list|(
name|a
argument_list|,
literal|"zoo zoo $ zoo"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"zoo"
block|,
literal|"zoo"
block|,
literal|"$"
block|,
literal|"zoo"
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|}
argument_list|)
expr_stmt|;
block|}
DECL|method|testRecursion2
specifier|public
name|void
name|testRecursion2
parameter_list|()
throws|throws
name|Exception
block|{
name|b
operator|=
operator|new
name|SynonymMap
operator|.
name|Builder
argument_list|(
literal|true
argument_list|)
expr_stmt|;
specifier|final
name|boolean
name|keepOrig
init|=
literal|false
decl_stmt|;
name|add
argument_list|(
literal|"zoo"
argument_list|,
literal|"zoo"
argument_list|,
name|keepOrig
argument_list|)
expr_stmt|;
name|add
argument_list|(
literal|"zoo"
argument_list|,
literal|"zoo zoo"
argument_list|,
name|keepOrig
argument_list|)
expr_stmt|;
specifier|final
name|SynonymMap
name|map
init|=
name|b
operator|.
name|build
argument_list|()
decl_stmt|;
name|Analyzer
name|a
init|=
operator|new
name|Analyzer
argument_list|()
block|{
annotation|@
name|Override
specifier|protected
name|TokenStreamComponents
name|createComponents
parameter_list|(
name|String
name|fieldName
parameter_list|,
name|Reader
name|reader
parameter_list|)
block|{
name|Tokenizer
name|tokenizer
init|=
operator|new
name|MockTokenizer
argument_list|(
name|reader
argument_list|,
name|MockTokenizer
operator|.
name|WHITESPACE
argument_list|,
literal|false
argument_list|)
decl_stmt|;
return|return
operator|new
name|TokenStreamComponents
argument_list|(
name|tokenizer
argument_list|,
operator|new
name|SynonymFilter
argument_list|(
name|tokenizer
argument_list|,
name|map
argument_list|,
literal|true
argument_list|)
argument_list|)
return|;
block|}
block|}
decl_stmt|;
comment|// verify("zoo zoo $ zoo", "zoo/zoo zoo/zoo/zoo $/zoo zoo/zoo zoo");
name|assertAnalyzesTo
argument_list|(
name|a
argument_list|,
literal|"zoo zoo $ zoo"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"zoo"
block|,
literal|"zoo"
block|,
literal|"zoo"
block|,
literal|"zoo"
block|,
literal|"zoo"
block|,
literal|"$"
block|,
literal|"zoo"
block|,
literal|"zoo"
block|,
literal|"zoo"
block|,
literal|"zoo"
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|}
argument_list|)
expr_stmt|;
block|}
DECL|method|testIncludeOrig
specifier|public
name|void
name|testIncludeOrig
parameter_list|()
throws|throws
name|Exception
block|{
name|b
operator|=
operator|new
name|SynonymMap
operator|.
name|Builder
argument_list|(
literal|true
argument_list|)
expr_stmt|;
specifier|final
name|boolean
name|keepOrig
init|=
literal|true
decl_stmt|;
name|add
argument_list|(
literal|"a b"
argument_list|,
literal|"ab"
argument_list|,
name|keepOrig
argument_list|)
expr_stmt|;
name|add
argument_list|(
literal|"a c"
argument_list|,
literal|"ac"
argument_list|,
name|keepOrig
argument_list|)
expr_stmt|;
name|add
argument_list|(
literal|"a"
argument_list|,
literal|"aa"
argument_list|,
name|keepOrig
argument_list|)
expr_stmt|;
name|add
argument_list|(
literal|"b"
argument_list|,
literal|"bb"
argument_list|,
name|keepOrig
argument_list|)
expr_stmt|;
name|add
argument_list|(
literal|"z x c v"
argument_list|,
literal|"zxcv"
argument_list|,
name|keepOrig
argument_list|)
expr_stmt|;
name|add
argument_list|(
literal|"x c"
argument_list|,
literal|"xc"
argument_list|,
name|keepOrig
argument_list|)
expr_stmt|;
specifier|final
name|SynonymMap
name|map
init|=
name|b
operator|.
name|build
argument_list|()
decl_stmt|;
name|Analyzer
name|a
init|=
operator|new
name|Analyzer
argument_list|()
block|{
annotation|@
name|Override
specifier|protected
name|TokenStreamComponents
name|createComponents
parameter_list|(
name|String
name|fieldName
parameter_list|,
name|Reader
name|reader
parameter_list|)
block|{
name|Tokenizer
name|tokenizer
init|=
operator|new
name|MockTokenizer
argument_list|(
name|reader
argument_list|,
name|MockTokenizer
operator|.
name|WHITESPACE
argument_list|,
literal|false
argument_list|)
decl_stmt|;
return|return
operator|new
name|TokenStreamComponents
argument_list|(
name|tokenizer
argument_list|,
operator|new
name|SynonymFilter
argument_list|(
name|tokenizer
argument_list|,
name|map
argument_list|,
literal|true
argument_list|)
argument_list|)
return|;
block|}
block|}
decl_stmt|;
name|assertAnalyzesTo
argument_list|(
name|a
argument_list|,
literal|"$"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"$"
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|}
argument_list|)
expr_stmt|;
name|assertAnalyzesTo
argument_list|(
name|a
argument_list|,
literal|"a"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"a"
block|,
literal|"aa"
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|,
literal|0
block|}
argument_list|)
expr_stmt|;
name|assertAnalyzesTo
argument_list|(
name|a
argument_list|,
literal|"a"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"a"
block|,
literal|"aa"
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|,
literal|0
block|}
argument_list|)
expr_stmt|;
name|assertAnalyzesTo
argument_list|(
name|a
argument_list|,
literal|"$ a"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"$"
block|,
literal|"a"
block|,
literal|"aa"
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|}
argument_list|)
expr_stmt|;
name|assertAnalyzesTo
argument_list|(
name|a
argument_list|,
literal|"a $"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"a"
block|,
literal|"aa"
block|,
literal|"$"
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|,
literal|0
block|,
literal|1
block|}
argument_list|)
expr_stmt|;
name|assertAnalyzesTo
argument_list|(
name|a
argument_list|,
literal|"$ a !"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"$"
block|,
literal|"a"
block|,
literal|"aa"
block|,
literal|"!"
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|}
argument_list|)
expr_stmt|;
name|assertAnalyzesTo
argument_list|(
name|a
argument_list|,
literal|"a a"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"a"
block|,
literal|"aa"
block|,
literal|"a"
block|,
literal|"aa"
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|}
argument_list|)
expr_stmt|;
name|assertAnalyzesTo
argument_list|(
name|a
argument_list|,
literal|"b"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"b"
block|,
literal|"bb"
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|,
literal|0
block|}
argument_list|)
expr_stmt|;
name|assertAnalyzesTo
argument_list|(
name|a
argument_list|,
literal|"z x c v"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"z"
block|,
literal|"zxcv"
block|,
literal|"x"
block|,
literal|"c"
block|,
literal|"v"
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|}
argument_list|)
expr_stmt|;
name|assertAnalyzesTo
argument_list|(
name|a
argument_list|,
literal|"z x c $"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"z"
block|,
literal|"x"
block|,
literal|"xc"
block|,
literal|"c"
block|,
literal|"$"
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|}
argument_list|)
expr_stmt|;
block|}
DECL|method|testRecursion3
specifier|public
name|void
name|testRecursion3
parameter_list|()
throws|throws
name|Exception
block|{
name|b
operator|=
operator|new
name|SynonymMap
operator|.
name|Builder
argument_list|(
literal|true
argument_list|)
expr_stmt|;
specifier|final
name|boolean
name|keepOrig
init|=
literal|true
decl_stmt|;
name|add
argument_list|(
literal|"zoo zoo"
argument_list|,
literal|"zoo"
argument_list|,
name|keepOrig
argument_list|)
expr_stmt|;
specifier|final
name|SynonymMap
name|map
init|=
name|b
operator|.
name|build
argument_list|()
decl_stmt|;
name|Analyzer
name|a
init|=
operator|new
name|Analyzer
argument_list|()
block|{
annotation|@
name|Override
specifier|protected
name|TokenStreamComponents
name|createComponents
parameter_list|(
name|String
name|fieldName
parameter_list|,
name|Reader
name|reader
parameter_list|)
block|{
name|Tokenizer
name|tokenizer
init|=
operator|new
name|MockTokenizer
argument_list|(
name|reader
argument_list|,
name|MockTokenizer
operator|.
name|WHITESPACE
argument_list|,
literal|false
argument_list|)
decl_stmt|;
return|return
operator|new
name|TokenStreamComponents
argument_list|(
name|tokenizer
argument_list|,
operator|new
name|SynonymFilter
argument_list|(
name|tokenizer
argument_list|,
name|map
argument_list|,
literal|true
argument_list|)
argument_list|)
return|;
block|}
block|}
decl_stmt|;
name|assertAnalyzesTo
argument_list|(
name|a
argument_list|,
literal|"zoo zoo $ zoo"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"zoo"
block|,
literal|"zoo"
block|,
literal|"zoo"
block|,
literal|"$"
block|,
literal|"zoo"
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|}
argument_list|)
expr_stmt|;
block|}
DECL|method|testRecursion4
specifier|public
name|void
name|testRecursion4
parameter_list|()
throws|throws
name|Exception
block|{
name|b
operator|=
operator|new
name|SynonymMap
operator|.
name|Builder
argument_list|(
literal|true
argument_list|)
expr_stmt|;
specifier|final
name|boolean
name|keepOrig
init|=
literal|true
decl_stmt|;
name|add
argument_list|(
literal|"zoo zoo"
argument_list|,
literal|"zoo"
argument_list|,
name|keepOrig
argument_list|)
expr_stmt|;
name|add
argument_list|(
literal|"zoo"
argument_list|,
literal|"zoo zoo"
argument_list|,
name|keepOrig
argument_list|)
expr_stmt|;
specifier|final
name|SynonymMap
name|map
init|=
name|b
operator|.
name|build
argument_list|()
decl_stmt|;
name|Analyzer
name|a
init|=
operator|new
name|Analyzer
argument_list|()
block|{
annotation|@
name|Override
specifier|protected
name|TokenStreamComponents
name|createComponents
parameter_list|(
name|String
name|fieldName
parameter_list|,
name|Reader
name|reader
parameter_list|)
block|{
name|Tokenizer
name|tokenizer
init|=
operator|new
name|MockTokenizer
argument_list|(
name|reader
argument_list|,
name|MockTokenizer
operator|.
name|WHITESPACE
argument_list|,
literal|false
argument_list|)
decl_stmt|;
return|return
operator|new
name|TokenStreamComponents
argument_list|(
name|tokenizer
argument_list|,
operator|new
name|SynonymFilter
argument_list|(
name|tokenizer
argument_list|,
name|map
argument_list|,
literal|true
argument_list|)
argument_list|)
return|;
block|}
block|}
decl_stmt|;
name|assertAnalyzesTo
argument_list|(
name|a
argument_list|,
literal|"zoo zoo $ zoo"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"zoo"
block|,
literal|"zoo"
block|,
literal|"zoo"
block|,
literal|"$"
block|,
literal|"zoo"
block|,
literal|"zoo"
block|,
literal|"zoo"
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|}
argument_list|)
expr_stmt|;
block|}
block|}
end_class
end_unit
