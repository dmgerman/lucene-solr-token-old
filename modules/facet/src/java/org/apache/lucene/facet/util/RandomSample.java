begin_unit
begin_package
DECL|package|org.apache.lucene.facet.util
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|facet
operator|.
name|util
package|;
end_package
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|logging
operator|.
name|Level
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|logging
operator|.
name|Logger
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|core
operator|.
name|KeywordAnalyzer
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|document
operator|.
name|Document
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|CorruptIndexException
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|IndexReader
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|IndexWriter
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|IndexWriterConfig
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|Directory
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|LockObtainFailedException
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|RAMDirectory
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|PriorityQueue
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|Version
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|facet
operator|.
name|search
operator|.
name|ScoredDocIDs
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|facet
operator|.
name|search
operator|.
name|ScoredDocIDsIterator
import|;
end_import
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_comment
comment|/**  * Take random samples of large collections.  *   * @lucene.experimental  */
end_comment
begin_class
DECL|class|RandomSample
specifier|public
class|class
name|RandomSample
block|{
DECL|field|logger
specifier|private
specifier|static
specifier|final
name|Logger
name|logger
init|=
name|Logger
operator|.
name|getLogger
argument_list|(
name|RandomSample
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
comment|/**    * Returns<code>sampleSize</code> values from the first<code>collectionSize</code>    * locations of<code>collection</code>, chosen using    * the<code>TRAVERSAL</code> algorithm. The sample values are not sorted.    * @param collection The values from which a sample is wanted.    * @param collectionSize The number of values (from the first) from which to draw the sample.    * @param sampleSize The number of values to return.    * @return An array of values chosen from the collection.    * @see Algorithm#TRAVERSAL    */
DECL|method|repeatableSample
specifier|public
specifier|static
name|int
index|[]
name|repeatableSample
parameter_list|(
name|ScoredDocIDs
name|collection
parameter_list|,
name|int
name|collectionSize
parameter_list|,
name|int
name|sampleSize
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|RandomSample
operator|.
name|repeatableSample
argument_list|(
name|collection
argument_list|,
name|collectionSize
argument_list|,
name|sampleSize
argument_list|,
name|Algorithm
operator|.
name|HASHING
argument_list|,
name|Sorted
operator|.
name|NO
argument_list|)
return|;
block|}
comment|/**    * Returns<code>sampleSize</code> values from the first<code>collectionSize</code>    * locations of<code>collection</code>, chosen using<code>algorithm</code>.    * @param collection The values from which a sample is wanted.    * @param collectionSize The number of values (from the first) from which to draw the sample.    * @param sampleSize The number of values to return.    * @param algorithm Which algorithm to use.    * @param sorted Sorted.YES to sort the sample values in ascending order before returning;    * Sorted.NO to return them in essentially random order.    * @return An array of values chosen from the collection.    */
DECL|method|repeatableSample
specifier|public
specifier|static
name|int
index|[]
name|repeatableSample
parameter_list|(
name|ScoredDocIDs
name|collection
parameter_list|,
name|int
name|collectionSize
parameter_list|,
name|int
name|sampleSize
parameter_list|,
name|Algorithm
name|algorithm
parameter_list|,
name|Sorted
name|sorted
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|collection
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"docIdSet is null"
argument_list|)
throw|;
block|}
if|if
condition|(
name|sampleSize
operator|<
literal|1
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"sampleSize< 1 ("
operator|+
name|sampleSize
operator|+
literal|")"
argument_list|)
throw|;
block|}
if|if
condition|(
name|collectionSize
operator|<
name|sampleSize
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"collectionSize ("
operator|+
name|collectionSize
operator|+
literal|") less than sampleSize ("
operator|+
name|sampleSize
operator|+
literal|")"
argument_list|)
throw|;
block|}
name|int
index|[]
name|sample
init|=
operator|new
name|int
index|[
name|sampleSize
index|]
decl_stmt|;
name|long
index|[]
name|times
init|=
operator|new
name|long
index|[
literal|4
index|]
decl_stmt|;
if|if
condition|(
name|algorithm
operator|==
name|Algorithm
operator|.
name|TRAVERSAL
condition|)
block|{
name|RandomSample
operator|.
name|sample1
argument_list|(
name|collection
argument_list|,
name|collectionSize
argument_list|,
name|sample
argument_list|,
name|times
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|algorithm
operator|==
name|Algorithm
operator|.
name|HASHING
condition|)
block|{
name|RandomSample
operator|.
name|sample2
argument_list|(
name|collection
argument_list|,
name|collectionSize
argument_list|,
name|sample
argument_list|,
name|times
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Invalid algorithm selection"
argument_list|)
throw|;
block|}
if|if
condition|(
name|sorted
operator|==
name|Sorted
operator|.
name|YES
condition|)
block|{
name|Arrays
operator|.
name|sort
argument_list|(
name|sample
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|RandomSample
operator|.
name|returnTimings
condition|)
block|{
name|times
index|[
literal|3
index|]
operator|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
expr_stmt|;
if|if
condition|(
name|logger
operator|.
name|isLoggable
argument_list|(
name|Level
operator|.
name|FINEST
argument_list|)
condition|)
block|{
name|logger
operator|.
name|finest
argument_list|(
literal|"Times: "
operator|+
operator|(
name|times
index|[
literal|1
index|]
operator|-
name|times
index|[
literal|0
index|]
operator|)
operator|+
literal|"ms, "
operator|+
operator|(
name|times
index|[
literal|2
index|]
operator|-
name|times
index|[
literal|1
index|]
operator|)
operator|+
literal|"ms, "
operator|+
operator|(
name|times
index|[
literal|3
index|]
operator|-
name|times
index|[
literal|2
index|]
operator|)
operator|+
literal|"ms"
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|sample
return|;
block|}
comment|/**    * Returns<code>sample</code>.length values chosen from the first<code>collectionSize</code>    * locations of<code>collection</code>, using the TRAVERSAL algorithm. The sample is    * pseudorandom: no subset of the original collection    * is in principle more likely to occur than any other, but for a given collection    * and sample size, the same sample will always be returned. This algorithm walks the    * original collection in a methodical way that is guaranteed not to visit any location    * more than once, which makes sampling without replacement faster because removals don't    * have to be tracked, and the number of operations is proportional to the sample size,    * not the collection size.    * Times for performance measurement    * are returned in<code>times</code>, which must be an array of at least three longs, containing    * nanosecond event times. The first    * is set when the algorithm starts; the second, when the step size has been calculated;    * and the third when the sample has been taken.    * @param collection The set to be sampled.    * @param collectionSize The number of values to use (starting from first).    * @param sample The array in which to return the sample.    * @param times The times of three events, for measuring performance.    */
DECL|method|sample1
specifier|private
specifier|static
name|void
name|sample1
parameter_list|(
name|ScoredDocIDs
name|collection
parameter_list|,
name|int
name|collectionSize
parameter_list|,
name|int
index|[]
name|sample
parameter_list|,
name|long
index|[]
name|times
parameter_list|)
throws|throws
name|IOException
block|{
name|ScoredDocIDsIterator
name|it
init|=
name|collection
operator|.
name|iterator
argument_list|()
decl_stmt|;
if|if
condition|(
name|RandomSample
operator|.
name|returnTimings
condition|)
block|{
name|times
index|[
literal|0
index|]
operator|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
expr_stmt|;
block|}
name|int
name|sampleSize
init|=
name|sample
operator|.
name|length
decl_stmt|;
name|int
name|prime
init|=
name|RandomSample
operator|.
name|findGoodStepSize
argument_list|(
name|collectionSize
argument_list|,
name|sampleSize
argument_list|)
decl_stmt|;
name|int
name|mod
init|=
name|prime
operator|%
name|collectionSize
decl_stmt|;
if|if
condition|(
name|RandomSample
operator|.
name|returnTimings
condition|)
block|{
name|times
index|[
literal|1
index|]
operator|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
expr_stmt|;
block|}
name|int
name|sampleCount
init|=
literal|0
decl_stmt|;
name|int
name|index
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
name|sampleCount
operator|<
name|sampleSize
condition|;
control|)
block|{
if|if
condition|(
name|index
operator|+
name|mod
operator|<
name|collectionSize
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|mod
condition|;
name|i
operator|++
operator|,
name|index
operator|++
control|)
block|{
name|it
operator|.
name|next
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
name|index
operator|=
name|index
operator|+
name|mod
operator|-
name|collectionSize
expr_stmt|;
name|it
operator|=
name|collection
operator|.
name|iterator
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|index
condition|;
name|i
operator|++
control|)
block|{
name|it
operator|.
name|next
argument_list|()
expr_stmt|;
block|}
block|}
name|sample
index|[
name|sampleCount
operator|++
index|]
operator|=
name|it
operator|.
name|getDocID
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|RandomSample
operator|.
name|returnTimings
condition|)
block|{
name|times
index|[
literal|2
index|]
operator|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
expr_stmt|;
block|}
block|}
comment|// end RandomSample.sample1()
comment|/**    * Returns a value which will allow the caller to walk    * a collection of<code>collectionSize</code> values, without repeating or missing    * any, and spanning the collection from beginning to end at least once with    *<code>sampleSize</code> visited locations. Choosing a value    * that is relatively prime to the collection size ensures that stepping by that size (modulo    * the collection size) will hit all locations without repeating, eliminating the need to    * track previously visited locations for a "without replacement" sample. Starting with the    * square root of the collection size ensures that either the first or second prime tried will    * work (they can't both divide the collection size). It also has the property that N steps of    * size N will span a collection of N**2 elements once. If the sample is bigger than N, it will    * wrap multiple times (without repeating). If the sample is smaller, a step size is chosen    * that will result in at least one spanning of the collection.    *     * @param collectionSize The number of values in the collection to be sampled.    * @param sampleSize The number of values wanted in the sample.    * @return A good increment value for walking the collection.    */
DECL|method|findGoodStepSize
specifier|private
specifier|static
name|int
name|findGoodStepSize
parameter_list|(
name|int
name|collectionSize
parameter_list|,
name|int
name|sampleSize
parameter_list|)
block|{
name|int
name|i
init|=
operator|(
name|int
operator|)
name|Math
operator|.
name|sqrt
argument_list|(
name|collectionSize
argument_list|)
decl_stmt|;
if|if
condition|(
name|sampleSize
operator|<
name|i
condition|)
block|{
name|i
operator|=
name|collectionSize
operator|/
name|sampleSize
expr_stmt|;
block|}
do|do
block|{
name|i
operator|=
name|RandomSample
operator|.
name|findNextPrimeAfter
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|collectionSize
operator|%
name|i
operator|==
literal|0
condition|)
do|;
return|return
name|i
return|;
block|}
comment|// end RandomSample.findGoodStepSize()
comment|/**    * Returns the first prime number that is larger than<code>n</code>.    * @param n A number less than the prime to be returned.    * @return The smallest prime larger than<code>n</code>.    */
DECL|method|findNextPrimeAfter
specifier|private
specifier|static
name|int
name|findNextPrimeAfter
parameter_list|(
name|int
name|n
parameter_list|)
block|{
name|n
operator|+=
operator|(
name|n
operator|%
literal|2
operator|==
literal|0
operator|)
condition|?
literal|1
else|:
literal|2
expr_stmt|;
comment|// next odd
name|foundFactor
label|:
for|for
control|(
init|;
condition|;
name|n
operator|+=
literal|2
control|)
block|{
name|int
name|sri
init|=
call|(
name|int
call|)
argument_list|(
name|Math
operator|.
name|sqrt
argument_list|(
name|n
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|primeIndex
init|=
literal|0
init|;
name|primeIndex
operator|<
name|RandomSample
operator|.
name|N_PRIMES
condition|;
name|primeIndex
operator|++
control|)
block|{
name|int
name|p
init|=
name|RandomSample
operator|.
name|primes
index|[
name|primeIndex
index|]
decl_stmt|;
if|if
condition|(
name|p
operator|>
name|sri
condition|)
block|{
return|return
name|n
return|;
block|}
if|if
condition|(
name|n
operator|%
name|p
operator|==
literal|0
condition|)
block|{
continue|continue
name|foundFactor
continue|;
block|}
block|}
for|for
control|(
name|int
name|p
init|=
name|RandomSample
operator|.
name|primes
index|[
name|RandomSample
operator|.
name|N_PRIMES
operator|-
literal|1
index|]
operator|+
literal|2
init|;
condition|;
name|p
operator|+=
literal|2
control|)
block|{
if|if
condition|(
name|p
operator|>
name|sri
condition|)
block|{
return|return
name|n
return|;
block|}
if|if
condition|(
name|n
operator|%
name|p
operator|==
literal|0
condition|)
block|{
continue|continue
name|foundFactor
continue|;
block|}
block|}
block|}
block|}
comment|// end RandomSample.findNextPrimeAfter()
comment|/**    * Divides the values in<code>collection</code> into<code>numSubranges</code>    * subranges from<code>minValue</code> to<code>maxValue</code> and returns the    * number of values in each subrange. (For testing the flatness of distribution of    * a sample.)    * @param collection The collection of values to be counted.    * @param range The number of possible values.    * @param numSubranges How many intervals to divide the value range into.    */
DECL|method|countsBySubrange
specifier|private
specifier|static
name|int
index|[]
name|countsBySubrange
parameter_list|(
name|int
index|[]
name|collection
parameter_list|,
name|int
name|range
parameter_list|,
name|int
name|numSubranges
parameter_list|)
block|{
name|int
index|[]
name|counts
init|=
operator|new
name|int
index|[
name|numSubranges
index|]
decl_stmt|;
name|Arrays
operator|.
name|fill
argument_list|(
name|counts
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|int
name|numInSubrange
init|=
name|range
operator|/
name|numSubranges
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|collection
operator|.
name|length
condition|;
name|j
operator|++
control|)
block|{
name|counts
index|[
name|collection
index|[
name|j
index|]
operator|/
name|numInSubrange
index|]
operator|++
expr_stmt|;
block|}
return|return
name|counts
return|;
block|}
comment|// end RandomSample.countsBySubrange()
comment|/**    * Factors<code>value</code> into primes.    */
DECL|method|factor
specifier|public
specifier|static
name|int
index|[]
name|factor
parameter_list|(
name|long
name|value
parameter_list|)
block|{
name|ArrayList
argument_list|<
name|Integer
argument_list|>
name|list
init|=
operator|new
name|ArrayList
argument_list|<
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
while|while
condition|(
name|value
operator|>
literal|1
operator|&&
name|value
operator|%
literal|2
operator|==
literal|0
condition|)
block|{
name|list
operator|.
name|add
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|value
operator|/=
literal|2
expr_stmt|;
block|}
name|long
name|sqrt
init|=
name|Math
operator|.
name|round
argument_list|(
name|Math
operator|.
name|sqrt
argument_list|(
name|value
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|pIndex
init|=
literal|0
init|,
name|lim
init|=
name|RandomSample
operator|.
name|primes
operator|.
name|length
init|;
name|pIndex
operator|<
name|lim
condition|;
name|pIndex
operator|++
control|)
block|{
name|int
name|p
init|=
name|RandomSample
operator|.
name|primes
index|[
name|pIndex
index|]
decl_stmt|;
if|if
condition|(
name|p
operator|>=
name|sqrt
condition|)
block|{
break|break;
block|}
while|while
condition|(
name|value
operator|%
name|p
operator|==
literal|0
condition|)
block|{
name|list
operator|.
name|add
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|value
operator|/=
name|p
expr_stmt|;
name|sqrt
operator|=
name|Math
operator|.
name|round
argument_list|(
name|Math
operator|.
name|sqrt
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|list
operator|.
name|size
argument_list|()
operator|==
literal|0
operator|||
name|value
operator|>
name|Integer
operator|.
name|MAX_VALUE
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Prime or too large to factor: "
operator|+
name|value
argument_list|)
throw|;
block|}
if|if
condition|(
operator|(
name|int
operator|)
name|value
operator|>
literal|1
condition|)
block|{
name|list
operator|.
name|add
argument_list|(
operator|(
name|int
operator|)
name|value
argument_list|)
expr_stmt|;
block|}
name|int
index|[]
name|factors
init|=
operator|new
name|int
index|[
name|list
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|factors
operator|.
name|length
condition|;
name|j
operator|++
control|)
block|{
name|factors
index|[
name|j
index|]
operator|=
name|list
operator|.
name|get
argument_list|(
name|j
argument_list|)
operator|.
name|intValue
argument_list|()
expr_stmt|;
block|}
return|return
name|factors
return|;
block|}
comment|// end RandomSample.factor()
comment|/**    * The first N_PRIMES primes, after 2.    */
DECL|field|N_PRIMES
specifier|private
specifier|static
specifier|final
name|int
name|N_PRIMES
init|=
literal|4000
decl_stmt|;
DECL|field|primes
specifier|private
specifier|static
name|int
index|[]
name|primes
init|=
operator|new
name|int
index|[
name|RandomSample
operator|.
name|N_PRIMES
index|]
decl_stmt|;
static|static
block|{
name|RandomSample
operator|.
name|primes
index|[
literal|0
index|]
operator|=
literal|3
expr_stmt|;
for|for
control|(
name|int
name|count
init|=
literal|1
init|;
name|count
operator|<
name|RandomSample
operator|.
name|N_PRIMES
condition|;
name|count
operator|++
control|)
block|{
name|primes
index|[
name|count
index|]
operator|=
name|RandomSample
operator|.
name|findNextPrimeAfter
argument_list|(
name|primes
index|[
name|count
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Returns<code>sample</code>.length values chosen from the first<code>collectionSize</code>    * locations of<code>collection</code>, using the HASHING algorithm. Performance measurements    * are returned in<code>times</code>, which must be an array of at least three longs. The first    * will be set when the algorithm starts; the second, when a hash key has been calculated and    * inserted into the priority queue for every element in the collection; and the third when the    * original elements associated with the keys remaining in the PQ have been stored in the sample    * array for return.    *<P>    * This algorithm slows as the sample size becomes a significant fraction of the collection    * size, because the PQ is as large as the sample set, and will not do early rejection of values    * below the minimum until it fills up, and a larger PQ contains more small values to be purged,    * resulting in less early rejection and more logN insertions.    *     * @param collection The set to be sampled.    * @param collectionSize The number of values to use (starting from first).    * @param sample The array in which to return the sample.    * @param times The times of three events, for measuring performance.    */
DECL|method|sample2
specifier|private
specifier|static
name|void
name|sample2
parameter_list|(
name|ScoredDocIDs
name|collection
parameter_list|,
name|int
name|collectionSize
parameter_list|,
name|int
index|[]
name|sample
parameter_list|,
name|long
index|[]
name|times
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|RandomSample
operator|.
name|returnTimings
condition|)
block|{
name|times
index|[
literal|0
index|]
operator|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
expr_stmt|;
block|}
name|int
name|sampleSize
init|=
name|sample
operator|.
name|length
decl_stmt|;
name|IntPriorityQueue
name|pq
init|=
operator|new
name|IntPriorityQueue
argument_list|(
name|sampleSize
argument_list|)
decl_stmt|;
comment|/*      * Convert every value in the collection to a hashed "weight" value, and insert      * into a bounded PQ (retains only sampleSize highest weights).      */
name|ScoredDocIDsIterator
name|it
init|=
name|collection
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|next
argument_list|()
condition|)
block|{
name|pq
operator|.
name|insertWithReuse
argument_list|(
call|(
name|int
call|)
argument_list|(
name|it
operator|.
name|getDocID
argument_list|()
operator|*
name|PHI_32
argument_list|)
operator|&
literal|0x7FFFFFFF
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|RandomSample
operator|.
name|returnTimings
condition|)
block|{
name|times
index|[
literal|1
index|]
operator|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
expr_stmt|;
block|}
comment|/*      * Extract heap, convert weights back to original values, and return as integers.      */
name|Object
index|[]
name|heap
init|=
name|pq
operator|.
name|getHeap
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|si
init|=
literal|0
init|;
name|si
operator|<
name|sampleSize
condition|;
name|si
operator|++
control|)
block|{
name|sample
index|[
name|si
index|]
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
call|(
name|IntPriorityQueue
operator|.
name|MI
call|)
argument_list|(
name|heap
index|[
name|si
operator|+
literal|1
index|]
argument_list|)
operator|)
operator|.
name|value
operator|*
name|PHI_32I
argument_list|)
operator|&
literal|0x7FFFFFFF
expr_stmt|;
block|}
if|if
condition|(
name|RandomSample
operator|.
name|returnTimings
condition|)
block|{
name|times
index|[
literal|2
index|]
operator|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
expr_stmt|;
block|}
block|}
comment|// end RandomSample.sample2()
comment|/**    * A bounded priority queue for Integers, to retain a specified number of    * the highest-weighted values for return as a random sample.    */
DECL|class|IntPriorityQueue
specifier|private
specifier|static
class|class
name|IntPriorityQueue
extends|extends
name|PriorityQueue
argument_list|<
name|Object
argument_list|>
block|{
comment|/**      * Creates a bounded PQ of size<code>size</code>.      * @param size The number of elements to retain.      */
DECL|method|IntPriorityQueue
specifier|public
name|IntPriorityQueue
parameter_list|(
name|int
name|size
parameter_list|)
block|{
name|super
argument_list|(
name|size
argument_list|)
expr_stmt|;
block|}
comment|/**      * Inserts an integer with overflow and object reuse.      */
DECL|method|insertWithReuse
specifier|public
name|void
name|insertWithReuse
parameter_list|(
name|int
name|intval
parameter_list|)
block|{
if|if
condition|(
name|this
operator|.
name|mi
operator|==
literal|null
condition|)
block|{
name|this
operator|.
name|mi
operator|=
operator|new
name|MI
argument_list|()
expr_stmt|;
block|}
name|this
operator|.
name|mi
operator|.
name|value
operator|=
name|intval
expr_stmt|;
name|this
operator|.
name|mi
operator|=
operator|(
name|MI
operator|)
name|this
operator|.
name|insertWithOverflow
argument_list|(
name|this
operator|.
name|mi
argument_list|)
expr_stmt|;
block|}
comment|// end IntPriorityQueue.insertWithReuse()
comment|/**      * Returns the underlying data structure for faster access. Extracting elements      * one at a time would require N logN time, and since we want the elements sorted      * in ascending order by value (not weight), the array is useful as-is.      * @return The underlying heap array.      */
DECL|method|getHeap
specifier|public
name|Object
index|[]
name|getHeap
parameter_list|()
block|{
return|return
name|getHeapArray
argument_list|()
return|;
block|}
comment|/**      * Returns true if<code>o1<code>'s weight is less than that of<code>o2</code>, for      * ordering in the PQ.      * @return True if<code>o1</code> weighs less than<code>o2</code>.      */
annotation|@
name|Override
DECL|method|lessThan
specifier|public
name|boolean
name|lessThan
parameter_list|(
name|Object
name|o1
parameter_list|,
name|Object
name|o2
parameter_list|)
block|{
return|return
operator|(
operator|(
name|MI
operator|)
name|o1
operator|)
operator|.
name|value
operator|<
operator|(
operator|(
name|MI
operator|)
name|o2
operator|)
operator|.
name|value
return|;
block|}
comment|/**      * A mutable integer that lets queue objects be reused once they start overflowing.      */
DECL|class|MI
specifier|private
specifier|static
class|class
name|MI
block|{
DECL|method|MI
name|MI
parameter_list|()
block|{ }
DECL|field|value
specifier|public
name|int
name|value
decl_stmt|;
block|}
comment|// end class RandomSample.IntPriorityQueue.MI
comment|/**      * The mutable integer instance for reuse after first overflow.      */
DECL|field|mi
specifier|private
name|MI
name|mi
decl_stmt|;
block|}
comment|// end class RandomSample.IntPriorityQueue
comment|/**    * For specifying which sampling algorithm to use.    */
DECL|class|Algorithm
specifier|public
specifier|static
class|class
name|Algorithm
block|{
comment|/**      * Specifies a methodical traversal algorithm, which is guaranteed to span the collection      * at least once, and never to return duplicates. Faster than the hashing algorithm and      * uses much less space, but the randomness of the sample may be affected by systematic      * variations in the collection. Requires only an array for the sample, and visits only      * the number of elements in the sample set, not the full set.      */
comment|// TODO (Facet): This one produces a bimodal distribution (very flat around
comment|// each peak!) for collection size 10M and sample sizes 10k and 10544.
comment|// Figure out why.
DECL|field|TRAVERSAL
specifier|public
specifier|static
specifier|final
name|Algorithm
name|TRAVERSAL
init|=
operator|new
name|Algorithm
argument_list|(
literal|"Traversal"
argument_list|)
decl_stmt|;
comment|/**      * Specifies a Fibonacci-style hash algorithm (see Knuth, S&S), which generates a less      * systematically distributed subset of the sampled collection than the traversal method,      * but requires a bounded priority queue the size of the sample, and creates an object      * containing a sampled value and its hash, for every element in the full set.       */
DECL|field|HASHING
specifier|public
specifier|static
specifier|final
name|Algorithm
name|HASHING
init|=
operator|new
name|Algorithm
argument_list|(
literal|"Hashing"
argument_list|)
decl_stmt|;
comment|/**      * Constructs an instance of an algorithm.      * @param name An ID for printing.      */
DECL|method|Algorithm
specifier|private
name|Algorithm
parameter_list|(
name|String
name|name
parameter_list|)
block|{
name|this
operator|.
name|name
operator|=
name|name
expr_stmt|;
block|}
comment|/**      * Prints this algorithm's name.      */
annotation|@
name|Override
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|this
operator|.
name|name
return|;
block|}
comment|/**      * The name of this algorithm, for printing.      */
DECL|field|name
specifier|private
name|String
name|name
decl_stmt|;
block|}
comment|// end class RandomSample.Algorithm
comment|/**    * For specifying whether to sort the sample.    */
DECL|class|Sorted
specifier|public
specifier|static
class|class
name|Sorted
block|{
comment|/**      * Specifies sorting the resulting sample before returning.      */
DECL|field|YES
specifier|public
specifier|static
specifier|final
name|Sorted
name|YES
init|=
operator|new
name|Sorted
argument_list|(
literal|"sorted"
argument_list|)
decl_stmt|;
comment|/**      * Specifies not sorting the resulting sample.       */
DECL|field|NO
specifier|public
specifier|static
specifier|final
name|Sorted
name|NO
init|=
operator|new
name|Sorted
argument_list|(
literal|"unsorted"
argument_list|)
decl_stmt|;
comment|/**      * Constructs an instance of a "sorted" selector.      * @param name An ID for printing.      */
DECL|method|Sorted
specifier|private
name|Sorted
parameter_list|(
name|String
name|name
parameter_list|)
block|{
name|this
operator|.
name|name
operator|=
name|name
expr_stmt|;
block|}
comment|/**      * Prints this selector's name.      */
annotation|@
name|Override
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|this
operator|.
name|name
return|;
block|}
comment|/**      * The name of this selector, for printing.      */
DECL|field|name
specifier|private
name|String
name|name
decl_stmt|;
block|}
comment|// end class RandomSample.Sorted
comment|/**    * Magic number 1: prime closest to phi, in 32 bits.    */
DECL|field|PHI_32
specifier|private
specifier|static
specifier|final
name|long
name|PHI_32
init|=
literal|2654435769L
decl_stmt|;
comment|/**    * Magic number 2: multiplicative inverse of PHI_32, modulo 2**32.    */
DECL|field|PHI_32I
specifier|private
specifier|static
specifier|final
name|long
name|PHI_32I
init|=
literal|340573321L
decl_stmt|;
comment|/**    * Switch to cause methods to return timings.    */
DECL|field|returnTimings
specifier|private
specifier|static
name|boolean
name|returnTimings
init|=
literal|false
decl_stmt|;
comment|/**    * Self-test.    */
DECL|method|main
specifier|public
specifier|static
name|void
name|main
parameter_list|(
name|String
index|[]
name|args
parameter_list|)
throws|throws
name|Exception
block|{
name|RandomSample
operator|.
name|returnTimings
operator|=
literal|true
expr_stmt|;
comment|/*      * Create an array of sequential integers, from which samples will be taken.      */
specifier|final
name|int
name|COLLECTION_SIZE
init|=
literal|10
operator|*
literal|1000
operator|*
literal|1000
decl_stmt|;
name|ScoredDocIDs
name|collection
init|=
name|createAllScoredDocs
argument_list|(
name|COLLECTION_SIZE
argument_list|)
decl_stmt|;
comment|/*      * Factor PHI.      *         int[] factors = RandomSample.factor(PHI_32);         System.out.print("Factors of PHI_32: ");         for (int k : factors) {           System.out.print(k+", ");         }         System.out.println("");       * Verify inverse relationship of PHI& phi.      *         boolean inverseValid = true;         for (int j = 0; j< Integer.MAX_VALUE; j++) {           int k = (int)(j * PHI_32)& 0x7FFFFFFF;           int m = (int)(k * PHI_32I)& 0X7FFFFFFF;           if (j != m) {             System.out.println("Inverse not valid for "+j);             inverseValid = false;           }         }         System.out.println("Inverse valid? "+inverseValid);      */
comment|/*      * Take samples of various sizes from the full set, verify no duplicates,      * check flatness.      */
name|int
index|[]
name|sampleSizes
init|=
block|{
literal|10
block|,
literal|57
block|,
literal|100
block|,
literal|333
block|,
literal|1000
block|,
literal|2154
block|,
literal|10000
block|}
decl_stmt|;
name|Algorithm
index|[]
name|algorithms
init|=
block|{
name|Algorithm
operator|.
name|HASHING
block|,
name|Algorithm
operator|.
name|TRAVERSAL
block|}
decl_stmt|;
for|for
control|(
name|int
name|sampleSize
range|:
name|sampleSizes
control|)
block|{
for|for
control|(
name|Algorithm
name|algorithm
range|:
name|algorithms
control|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Sample size "
operator|+
name|sampleSize
operator|+
literal|", algorithm "
operator|+
name|algorithm
operator|+
literal|"..."
argument_list|)
expr_stmt|;
comment|/*          * Take the sample.          */
name|int
index|[]
name|sample
init|=
name|RandomSample
operator|.
name|repeatableSample
argument_list|(
name|collection
argument_list|,
name|COLLECTION_SIZE
argument_list|,
name|sampleSize
argument_list|,
name|algorithm
argument_list|,
name|Sorted
operator|.
name|YES
argument_list|)
decl_stmt|;
comment|/*          * Check for duplicates.          */
name|boolean
name|noDups
init|=
literal|true
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|sampleSize
operator|-
literal|1
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|sample
index|[
name|j
index|]
operator|==
name|sample
index|[
name|j
operator|+
literal|1
index|]
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Duplicate value "
operator|+
name|sample
index|[
name|j
index|]
operator|+
literal|" at "
operator|+
name|j
operator|+
literal|", "
operator|+
operator|(
name|j
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
name|noDups
operator|=
literal|false
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|noDups
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"No duplicates."
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|algorithm
operator|==
name|Algorithm
operator|.
name|HASHING
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|print
argument_list|(
literal|"Hashed sample, up to 100 of "
operator|+
name|sampleSize
operator|+
literal|": "
argument_list|)
expr_stmt|;
name|int
name|lim
init|=
name|Math
operator|.
name|min
argument_list|(
literal|100
argument_list|,
name|sampleSize
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|k
init|=
literal|0
init|;
name|k
operator|<
name|lim
condition|;
name|k
operator|++
control|)
block|{
name|System
operator|.
name|out
operator|.
name|print
argument_list|(
name|sample
index|[
name|k
index|]
operator|+
literal|", "
argument_list|)
expr_stmt|;
block|}
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|""
argument_list|)
expr_stmt|;
block|}
comment|/*          * Check flatness of distribution in sample.          */
specifier|final
name|int
name|N_INTERVALS
init|=
literal|100
decl_stmt|;
name|int
index|[]
name|counts
init|=
name|RandomSample
operator|.
name|countsBySubrange
argument_list|(
name|sample
argument_list|,
name|COLLECTION_SIZE
argument_list|,
name|N_INTERVALS
argument_list|)
decl_stmt|;
name|int
name|minCount
init|=
name|Integer
operator|.
name|MAX_VALUE
decl_stmt|;
name|int
name|maxCount
init|=
name|Integer
operator|.
name|MIN_VALUE
decl_stmt|;
name|int
name|avgCount
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|N_INTERVALS
condition|;
name|j
operator|++
control|)
block|{
name|int
name|count
init|=
name|counts
index|[
name|j
index|]
decl_stmt|;
if|if
condition|(
name|count
operator|<
name|minCount
condition|)
block|{
name|minCount
operator|=
name|count
expr_stmt|;
block|}
if|if
condition|(
name|count
operator|>
name|maxCount
condition|)
block|{
name|maxCount
operator|=
name|count
expr_stmt|;
block|}
name|avgCount
operator|+=
name|count
expr_stmt|;
block|}
name|avgCount
operator|/=
name|N_INTERVALS
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Min, max, avg: "
operator|+
name|minCount
operator|+
literal|", "
operator|+
name|maxCount
operator|+
literal|", "
operator|+
name|avgCount
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|double
operator|)
name|minCount
operator|-
name|avgCount
operator|)
operator|/
name|avgCount
operator|<
operator|-
literal|0.05
operator|&&
operator|(
name|minCount
operator|-
name|avgCount
operator|)
operator|<
operator|-
literal|5
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Not flat enough."
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|(
name|double
operator|)
name|maxCount
operator|-
name|avgCount
operator|)
operator|/
name|avgCount
operator|>
literal|0.05
operator|&&
operator|(
name|maxCount
operator|-
name|avgCount
operator|)
operator|>
literal|5
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Not flat enough."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Flat enough."
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sampleSize
operator|==
literal|10544
operator|&&
name|algorithm
operator|==
name|Algorithm
operator|.
name|TRAVERSAL
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|print
argument_list|(
literal|"Counts of interest: "
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|N_INTERVALS
condition|;
name|j
operator|++
control|)
block|{
name|System
operator|.
name|out
operator|.
name|print
argument_list|(
name|counts
index|[
name|j
index|]
operator|+
literal|", "
argument_list|)
expr_stmt|;
block|}
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|""
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Last prime is "
operator|+
name|RandomSample
operator|.
name|primes
index|[
name|RandomSample
operator|.
name|N_PRIMES
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
DECL|method|createAllScoredDocs
specifier|private
specifier|static
name|ScoredDocIDs
name|createAllScoredDocs
parameter_list|(
specifier|final
name|int
name|COLLECTION_SIZE
parameter_list|)
throws|throws
name|CorruptIndexException
throws|,
name|LockObtainFailedException
throws|,
name|IOException
block|{
name|ScoredDocIDs
name|collection
decl_stmt|;
name|IndexReader
name|reader
init|=
literal|null
decl_stmt|;
name|Directory
name|ramDir
init|=
operator|new
name|RAMDirectory
argument_list|()
decl_stmt|;
try|try
block|{
name|IndexWriter
name|writer
init|=
operator|new
name|IndexWriter
argument_list|(
name|ramDir
argument_list|,
operator|new
name|IndexWriterConfig
argument_list|(
name|Version
operator|.
name|LUCENE_30
argument_list|,
operator|new
name|KeywordAnalyzer
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|COLLECTION_SIZE
condition|;
name|i
operator|++
control|)
block|{
name|writer
operator|.
name|addDocument
argument_list|(
operator|new
name|Document
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|writer
operator|.
name|commit
argument_list|()
expr_stmt|;
name|writer
operator|.
name|close
argument_list|()
expr_stmt|;
name|reader
operator|=
name|IndexReader
operator|.
name|open
argument_list|(
name|ramDir
argument_list|)
expr_stmt|;
name|collection
operator|=
name|ScoredDocIdsUtils
operator|.
name|createAllDocsScoredDocIDs
argument_list|(
name|reader
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
name|reader
operator|!=
literal|null
condition|)
block|{
name|reader
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
name|ramDir
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
return|return
name|collection
return|;
block|}
block|}
end_class
begin_comment
comment|// end class RandomSample
end_comment
end_unit
