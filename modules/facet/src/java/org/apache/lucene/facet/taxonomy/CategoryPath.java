begin_unit
begin_package
DECL|package|org.apache.lucene.facet.taxonomy
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|facet
operator|.
name|taxonomy
package|;
end_package
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStreamReader
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStreamWriter
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Serializable
import|;
end_import
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_comment
comment|/**  * A CategoryPath holds a sequence of string components, specifying the  * hierarchical name of a category.  *<P>  * CategoryPath is designed to reduce the number of object allocations, in two  * ways: First, it keeps the components internally in two arrays, rather than  * keeping individual strings. Second, it allows reusing the same CategoryPath  * object (which can be clear()ed and new components add()ed again) and of  * add()'s parameter (which can be a reusable object, not just a string).  *   * @lucene.experimental  */
end_comment
begin_class
DECL|class|CategoryPath
specifier|public
class|class
name|CategoryPath
implements|implements
name|Serializable
implements|,
name|Cloneable
implements|,
name|Comparable
argument_list|<
name|CategoryPath
argument_list|>
block|{
comment|// A category path is a sequence of string components. It is kept
comment|// internally as one large character array "chars" with all the string
comment|// concatenated (without separators), and an array of integers "ends"
comment|// pointing to the/ end of each component. Both arrays may be larger
comment|// than actually in use. An additional integer, "ncomponents" specifies
comment|// how many components are actually set.
comment|// We use shorts instead of ints for "ends" to save a bit of space. This
comment|// means that our path lengths are limited to 32767 characters - which
comment|// should not be a problem in any realistic scenario.
DECL|field|chars
specifier|protected
name|char
index|[]
name|chars
decl_stmt|;
DECL|field|ends
specifier|protected
name|short
index|[]
name|ends
decl_stmt|;
DECL|field|ncomponents
specifier|protected
name|short
name|ncomponents
decl_stmt|;
comment|/**    * Return the number of components in the facet path. Note that this is    *<I>not</I> the number of characters, but the number of components.    */
DECL|method|length
specifier|public
name|short
name|length
parameter_list|()
block|{
return|return
name|ncomponents
return|;
block|}
comment|/**    * Trim the last components from the path.    *     * @param nTrim    *            Number of components to trim. If larger than the number of    *            components this path has, the entire path will be cleared.    */
DECL|method|trim
specifier|public
name|void
name|trim
parameter_list|(
name|int
name|nTrim
parameter_list|)
block|{
if|if
condition|(
name|nTrim
operator|>=
name|this
operator|.
name|ncomponents
condition|)
block|{
name|clear
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nTrim
operator|>
literal|0
condition|)
block|{
name|this
operator|.
name|ncomponents
operator|-=
name|nTrim
expr_stmt|;
block|}
block|}
comment|/**    * Returns the current character capacity of the CategoryPath. The character    * capacity is the size of the internal buffer used to hold the characters    * of all the path's components. When a component is added and the capacity    * is not big enough, the buffer is automatically grown, and capacityChars()    * increases.    */
DECL|method|capacityChars
specifier|public
name|int
name|capacityChars
parameter_list|()
block|{
return|return
name|chars
operator|.
name|length
return|;
block|}
comment|/**    * Returns the current component capacity of the CategoryPath. The component    * capacity is the maximum number of components that the internal buffer can    * currently hold. When a component is added beyond this capacity, the    * buffer is automatically grown, and capacityComponents() increases.    */
DECL|method|capacityComponents
specifier|public
name|int
name|capacityComponents
parameter_list|()
block|{
return|return
name|ends
operator|.
name|length
return|;
block|}
comment|/**    * Construct a new empty CategoryPath object. CategoryPath objects are meant    * to be reused, by add()ing components, and later clear()ing, and add()ing    * components again. The CategoryPath object is created with a buffer    * pre-allocated for a given number of characters and components, but the    * buffer will grow as necessary (see {@link #capacityChars()} and    * {@link #capacityComponents()}).    */
DECL|method|CategoryPath
specifier|public
name|CategoryPath
parameter_list|(
name|int
name|capacityChars
parameter_list|,
name|int
name|capacityComponents
parameter_list|)
block|{
name|ncomponents
operator|=
literal|0
expr_stmt|;
name|chars
operator|=
operator|new
name|char
index|[
name|capacityChars
index|]
expr_stmt|;
name|ends
operator|=
operator|new
name|short
index|[
name|capacityComponents
index|]
expr_stmt|;
block|}
comment|/**    * Create an empty CategoryPath object. Equivalent to the constructor    * {@link #CategoryPath(int, int)} with the two initial-capacity arguments    * set to zero.    */
DECL|method|CategoryPath
specifier|public
name|CategoryPath
parameter_list|()
block|{
name|this
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/**    * Add the given component to the end of the path.    *<P>    * Note that when a String object is passed to this method, a reference to    * it is not saved (rather, its content is copied), which will lead to that    * String object being gc'ed. To reduce the number of garbage objects, you    * can pass a mutable CharBuffer instead of an immutable String to this    * method.    */
DECL|method|add
specifier|public
name|void
name|add
parameter_list|(
name|CharSequence
name|component
parameter_list|)
block|{
comment|// Set the new end, increasing the "ends" array sizes if necessary:
if|if
condition|(
name|ncomponents
operator|>=
name|ends
operator|.
name|length
condition|)
block|{
name|short
index|[]
name|newends
init|=
operator|new
name|short
index|[
operator|(
name|ends
operator|.
name|length
operator|+
literal|1
operator|)
operator|*
literal|2
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|ends
argument_list|,
literal|0
argument_list|,
name|newends
argument_list|,
literal|0
argument_list|,
name|ends
operator|.
name|length
argument_list|)
expr_stmt|;
name|ends
operator|=
name|newends
expr_stmt|;
block|}
name|short
name|prevend
init|=
operator|(
name|ncomponents
operator|==
literal|0
operator|)
condition|?
literal|0
else|:
name|ends
index|[
name|ncomponents
operator|-
literal|1
index|]
decl_stmt|;
name|int
name|cmplen
init|=
name|component
operator|.
name|length
argument_list|()
decl_stmt|;
name|ends
index|[
name|ncomponents
index|]
operator|=
call|(
name|short
call|)
argument_list|(
name|prevend
operator|+
name|cmplen
argument_list|)
expr_stmt|;
comment|// Copy the new component's characters, increasing the "chars" array
comment|// sizes if necessary:
if|if
condition|(
name|ends
index|[
name|ncomponents
index|]
operator|>
name|chars
operator|.
name|length
condition|)
block|{
name|char
index|[]
name|newchars
init|=
operator|new
name|char
index|[
name|ends
index|[
name|ncomponents
index|]
operator|*
literal|2
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|chars
argument_list|,
literal|0
argument_list|,
name|newchars
argument_list|,
literal|0
argument_list|,
name|chars
operator|.
name|length
argument_list|)
expr_stmt|;
name|chars
operator|=
name|newchars
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|cmplen
condition|;
name|i
operator|++
control|)
block|{
name|chars
index|[
name|prevend
operator|++
index|]
operator|=
name|component
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
name|ncomponents
operator|++
expr_stmt|;
block|}
comment|/**    * Empty the CategoryPath object, so that it has zero components. The    * capacity of the object (see {@link #capacityChars()} and    * {@link #capacityComponents()}) is not reduced, so that the object can be    * reused without frequent reallocations.    */
DECL|method|clear
specifier|public
name|void
name|clear
parameter_list|()
block|{
name|ncomponents
operator|=
literal|0
expr_stmt|;
block|}
comment|/**    * Build a string representation of the path, with its components separated    * by the given delimiter character. The resulting string is appended to a    * given Appendable, e.g., a StringBuilder, CharBuffer or Writer.    *<P>    * Note that the two cases of zero components and one component with zero    * length produce indistinguishable results (both of them append nothing).    * This is normally not a problem, because components should not normally    * have zero lengths.    *<P>    * An IOException can be thrown if the given Appendable's append() throws    * this exception.    */
DECL|method|appendTo
specifier|public
name|void
name|appendTo
parameter_list|(
name|Appendable
name|out
parameter_list|,
name|char
name|delimiter
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|ncomponents
operator|==
literal|0
condition|)
block|{
return|return;
comment|// just append nothing...
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ends
index|[
literal|0
index|]
condition|;
name|i
operator|++
control|)
block|{
name|out
operator|.
name|append
argument_list|(
name|chars
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|j
init|=
literal|1
init|;
name|j
operator|<
name|ncomponents
condition|;
name|j
operator|++
control|)
block|{
name|out
operator|.
name|append
argument_list|(
name|delimiter
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
name|ends
index|[
name|j
operator|-
literal|1
index|]
init|;
name|i
operator|<
name|ends
index|[
name|j
index|]
condition|;
name|i
operator|++
control|)
block|{
name|out
operator|.
name|append
argument_list|(
name|chars
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * like {@link #appendTo(Appendable, char)}, but takes only a prefix of the    * path, rather than the whole path.    *<P>    * If the given prefix length is negative or bigger than the path's actual    * length, the whole path is taken.    */
DECL|method|appendTo
specifier|public
name|void
name|appendTo
parameter_list|(
name|Appendable
name|out
parameter_list|,
name|char
name|delimiter
parameter_list|,
name|int
name|prefixLen
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|prefixLen
argument_list|<
literal|0
operator|||
name|prefixLen
argument_list|>
name|ncomponents
condition|)
block|{
name|prefixLen
operator|=
name|ncomponents
expr_stmt|;
block|}
if|if
condition|(
name|prefixLen
operator|==
literal|0
condition|)
block|{
return|return;
comment|// just append nothing...
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ends
index|[
literal|0
index|]
condition|;
name|i
operator|++
control|)
block|{
name|out
operator|.
name|append
argument_list|(
name|chars
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|j
init|=
literal|1
init|;
name|j
operator|<
name|prefixLen
condition|;
name|j
operator|++
control|)
block|{
name|out
operator|.
name|append
argument_list|(
name|delimiter
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
name|ends
index|[
name|j
operator|-
literal|1
index|]
init|;
name|i
operator|<
name|ends
index|[
name|j
index|]
condition|;
name|i
operator|++
control|)
block|{
name|out
operator|.
name|append
argument_list|(
name|chars
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * like {@link #appendTo(Appendable, char)}, but takes only a part of the    * path, rather than the whole path.    *<P>    *<code>start</code> specifies the first component in the subpath, and    *<code>end</code> is one past the last component. If<code>start</code> is    * negative, 0 is assumed, and if<code>end</code> is negative or past the    * end of the path, the path is taken until the end. Otherwise, if    *<code>end<=start</code>, nothing is appended. Nothing is appended also in    * the case that the path is empty.    */
DECL|method|appendTo
specifier|public
name|void
name|appendTo
parameter_list|(
name|Appendable
name|out
parameter_list|,
name|char
name|delimiter
parameter_list|,
name|int
name|start
parameter_list|,
name|int
name|end
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|start
operator|<
literal|0
condition|)
block|{
name|start
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|end
argument_list|<
literal|0
operator|||
name|end
argument_list|>
name|ncomponents
condition|)
block|{
name|end
operator|=
name|ncomponents
expr_stmt|;
block|}
if|if
condition|(
name|end
operator|<=
name|start
condition|)
block|{
return|return;
comment|// just append nothing...
block|}
for|for
control|(
name|int
name|i
init|=
operator|(
name|start
operator|==
literal|0
condition|?
literal|0
else|:
name|ends
index|[
name|start
operator|-
literal|1
index|]
operator|)
init|;
name|i
operator|<
name|ends
index|[
name|start
index|]
condition|;
name|i
operator|++
control|)
block|{
name|out
operator|.
name|append
argument_list|(
name|chars
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|j
init|=
name|start
operator|+
literal|1
init|;
name|j
operator|<
name|end
condition|;
name|j
operator|++
control|)
block|{
name|out
operator|.
name|append
argument_list|(
name|delimiter
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
name|ends
index|[
name|j
operator|-
literal|1
index|]
init|;
name|i
operator|<
name|ends
index|[
name|j
index|]
condition|;
name|i
operator|++
control|)
block|{
name|out
operator|.
name|append
argument_list|(
name|chars
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Build a string representation of the path, with its components separated    * by the given delimiter character. The resulting string is returned as a    * new String object. To avoid this temporary object creation, consider    * using {@link #appendTo(Appendable, char)} instead.    *<P>    * Note that the two cases of zero components and one component with zero    * length produce indistinguishable results (both of them return an empty    * string). This is normally not a problem, because components should not    * normally have zero lengths.    */
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|(
name|char
name|delimiter
parameter_list|)
block|{
if|if
condition|(
name|ncomponents
operator|==
literal|0
condition|)
block|{
return|return
literal|""
return|;
block|}
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|(
name|ends
index|[
name|ncomponents
operator|-
literal|1
index|]
operator|+
operator|(
name|ncomponents
operator|-
literal|1
operator|)
argument_list|)
decl_stmt|;
try|try
block|{
name|this
operator|.
name|appendTo
argument_list|(
name|sb
argument_list|,
name|delimiter
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|// can't happen, because StringBuilder.append() never actually
comment|// throws an exception!
block|}
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**    * This method, an implementation of the {@link Object#toString()}    * interface, is to allow simple printing of a CategoryPath, for debugging    * purposes. When possible, it recommended to avoid using it it, and rather,    * if you want to output the path with its components separated by a    * delimiter character, specify the delimiter explicitly, with    * {@link #toString(char)}.    */
annotation|@
name|Override
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|toString
argument_list|(
literal|'/'
argument_list|)
return|;
block|}
comment|/**    * like {@link #toString(char)}, but takes only a prefix with a given number    * of components, rather than the whole path.    *<P>    * If the given length is negative or bigger than the path's actual length,    * the whole path is taken.    */
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|(
name|char
name|delimiter
parameter_list|,
name|int
name|prefixLen
parameter_list|)
block|{
if|if
condition|(
name|prefixLen
argument_list|<
literal|0
operator|||
name|prefixLen
argument_list|>
name|ncomponents
condition|)
block|{
name|prefixLen
operator|=
name|ncomponents
expr_stmt|;
block|}
if|if
condition|(
name|prefixLen
operator|==
literal|0
condition|)
block|{
return|return
literal|""
return|;
block|}
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|(
name|ends
index|[
name|prefixLen
operator|-
literal|1
index|]
operator|+
operator|(
name|prefixLen
operator|-
literal|1
operator|)
argument_list|)
decl_stmt|;
try|try
block|{
name|this
operator|.
name|appendTo
argument_list|(
name|sb
argument_list|,
name|delimiter
argument_list|,
name|prefixLen
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|// can't happen, because sb.append() never actually throws an
comment|// exception
block|}
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**    * like {@link #toString(char)}, but takes only a part of the path, rather    * than the whole path.    *<P>    *<code>start</code> specifies the first component in the subpath, and    *<code>end</code> is one past the last component. If<code>start</code> is    * negative, 0 is assumed, and if<code>end</code> is negative or past the    * end of the path, the path is taken until the end. Otherwise, if    *<code>end<=start</code>, an empty string is returned. An emptry string is    * returned also in the case that the path is empty.    */
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|(
name|char
name|delimiter
parameter_list|,
name|int
name|start
parameter_list|,
name|int
name|end
parameter_list|)
block|{
if|if
condition|(
name|start
operator|<
literal|0
condition|)
block|{
name|start
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|end
argument_list|<
literal|0
operator|||
name|end
argument_list|>
name|ncomponents
condition|)
block|{
name|end
operator|=
name|ncomponents
expr_stmt|;
block|}
if|if
condition|(
name|end
operator|<=
name|start
condition|)
block|{
return|return
literal|""
return|;
block|}
name|int
name|startchar
init|=
operator|(
name|start
operator|==
literal|0
operator|)
condition|?
literal|0
else|:
name|ends
index|[
name|start
operator|-
literal|1
index|]
decl_stmt|;
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|(
name|ends
index|[
name|end
operator|-
literal|1
index|]
operator|-
name|startchar
operator|+
operator|(
name|end
operator|-
name|start
operator|)
operator|-
literal|1
argument_list|)
decl_stmt|;
try|try
block|{
name|this
operator|.
name|appendTo
argument_list|(
name|sb
argument_list|,
name|delimiter
argument_list|,
name|start
argument_list|,
name|end
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|// can't happen, because sb.append() never actually throws an
comment|// exception
block|}
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**    * Return the i'th component of the path, in a new String object. If there    * is no i'th component, a null is returned.    */
DECL|method|getComponent
specifier|public
name|String
name|getComponent
parameter_list|(
name|int
name|i
parameter_list|)
block|{
if|if
condition|(
name|i
operator|<
literal|0
operator|||
name|i
operator|>=
name|ncomponents
condition|)
block|{
return|return
literal|null
return|;
block|}
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
return|return
operator|new
name|String
argument_list|(
name|chars
argument_list|,
literal|0
argument_list|,
name|ends
index|[
literal|0
index|]
argument_list|)
return|;
block|}
return|return
operator|new
name|String
argument_list|(
name|chars
argument_list|,
name|ends
index|[
name|i
operator|-
literal|1
index|]
argument_list|,
name|ends
index|[
name|i
index|]
operator|-
name|ends
index|[
name|i
operator|-
literal|1
index|]
argument_list|)
return|;
block|}
comment|/**    * Return the last component of the path, in a new String object. If the    * path is empty, a null is returned.    */
DECL|method|lastComponent
specifier|public
name|String
name|lastComponent
parameter_list|()
block|{
if|if
condition|(
name|ncomponents
operator|==
literal|0
condition|)
block|{
return|return
literal|null
return|;
block|}
if|if
condition|(
name|ncomponents
operator|==
literal|1
condition|)
block|{
return|return
operator|new
name|String
argument_list|(
name|chars
argument_list|,
literal|0
argument_list|,
name|ends
index|[
literal|0
index|]
argument_list|)
return|;
block|}
return|return
operator|new
name|String
argument_list|(
name|chars
argument_list|,
name|ends
index|[
name|ncomponents
operator|-
literal|2
index|]
argument_list|,
name|ends
index|[
name|ncomponents
operator|-
literal|1
index|]
operator|-
name|ends
index|[
name|ncomponents
operator|-
literal|2
index|]
argument_list|)
return|;
block|}
comment|/**    * Copies the specified number of components from this category path to the    * specified character array, with the components separated by a given    * delimiter character. The array must be large enough to hold the    * components and separators - the amount of needed space can be calculated    * with {@link #charsNeededForFullPath()}.    *<P>    * This method returns the number of characters written to the array.    *     * @param outputBuffer    *            The destination character array.    * @param outputBufferStart    *            The first location to write in the output array.    * @param numberOfComponentsToCopy    *            The number of path components to write to the destination    *            buffer.    * @param separatorChar    *            The separator inserted between every pair of path components    *            in the output buffer.    * @see #charsNeededForFullPath()    */
DECL|method|copyToCharArray
specifier|public
name|int
name|copyToCharArray
parameter_list|(
name|char
index|[]
name|outputBuffer
parameter_list|,
name|int
name|outputBufferStart
parameter_list|,
name|int
name|numberOfComponentsToCopy
parameter_list|,
name|char
name|separatorChar
parameter_list|)
block|{
if|if
condition|(
name|numberOfComponentsToCopy
operator|==
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
if|if
condition|(
name|numberOfComponentsToCopy
argument_list|<
literal|0
operator|||
name|numberOfComponentsToCopy
argument_list|>
name|ncomponents
condition|)
block|{
name|numberOfComponentsToCopy
operator|=
name|ncomponents
expr_stmt|;
block|}
name|int
name|outputBufferInitialStart
init|=
name|outputBufferStart
decl_stmt|;
comment|// for calculating
comment|// chars copied.
name|int
name|sourceStart
init|=
literal|0
decl_stmt|;
name|int
name|sourceLength
init|=
name|ends
index|[
literal|0
index|]
decl_stmt|;
for|for
control|(
name|int
name|component
init|=
literal|0
init|;
name|component
operator|<
name|numberOfComponentsToCopy
condition|;
name|component
operator|++
control|)
block|{
if|if
condition|(
name|component
operator|>
literal|0
condition|)
block|{
name|sourceStart
operator|=
name|ends
index|[
name|component
operator|-
literal|1
index|]
expr_stmt|;
name|sourceLength
operator|=
name|ends
index|[
name|component
index|]
operator|-
name|sourceStart
expr_stmt|;
name|outputBuffer
index|[
name|outputBufferStart
operator|++
index|]
operator|=
name|separatorChar
expr_stmt|;
block|}
name|System
operator|.
name|arraycopy
argument_list|(
name|chars
argument_list|,
name|sourceStart
argument_list|,
name|outputBuffer
argument_list|,
name|outputBufferStart
argument_list|,
name|sourceLength
argument_list|)
expr_stmt|;
name|outputBufferStart
operator|+=
name|sourceLength
expr_stmt|;
block|}
return|return
name|outputBufferStart
operator|-
name|outputBufferInitialStart
return|;
block|}
comment|/**    * Returns the number of characters required to represent this entire    * category path, if written using    * {@link #copyToCharArray(char[], int, int, char)} or    * {@link #appendTo(Appendable, char)}. This includes the number of    * characters in all the components, plus the number of separators between    * them (each one character in the aforementioned methods).    */
DECL|method|charsNeededForFullPath
specifier|public
name|int
name|charsNeededForFullPath
parameter_list|()
block|{
if|if
condition|(
name|ncomponents
operator|==
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
return|return
name|ends
index|[
name|ncomponents
operator|-
literal|1
index|]
operator|+
name|ncomponents
operator|-
literal|1
return|;
block|}
comment|/**    * Construct a new CategoryPath object, given a single string with    * components separated by a given delimiter character.    *<P>    * The initial capacity of the constructed object will be exactly what is    * needed to hold the given path. This fact is convenient when creating a    * temporary object that will not be reused later.    */
DECL|method|CategoryPath
specifier|public
name|CategoryPath
parameter_list|(
name|String
name|pathString
parameter_list|,
name|char
name|delimiter
parameter_list|)
block|{
if|if
condition|(
name|pathString
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
block|{
name|ncomponents
operator|=
literal|0
expr_stmt|;
name|chars
operator|=
operator|new
name|char
index|[
literal|0
index|]
expr_stmt|;
name|ends
operator|=
operator|new
name|short
index|[
literal|0
index|]
expr_stmt|;
return|return;
block|}
comment|// This constructor is often used for creating a temporary object
comment|// (one which will not be reused to hold multiple paths), so we want
comment|// to do our best to allocate exactly the needed size - not less (to
comment|// avoid reallocation) and not more (so as not to waste space).
comment|// To do this, we unfortunately need to make an additional pass on the
comment|// given string:
name|int
name|nparts
init|=
literal|1
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|pathString
operator|.
name|indexOf
argument_list|(
name|delimiter
argument_list|)
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|=
name|pathString
operator|.
name|indexOf
argument_list|(
name|delimiter
argument_list|,
name|i
operator|+
literal|1
argument_list|)
control|)
block|{
name|nparts
operator|++
expr_stmt|;
block|}
name|ends
operator|=
operator|new
name|short
index|[
name|nparts
index|]
expr_stmt|;
name|chars
operator|=
operator|new
name|char
index|[
name|pathString
operator|.
name|length
argument_list|()
operator|-
name|nparts
operator|+
literal|1
index|]
expr_stmt|;
name|ncomponents
operator|=
literal|0
expr_stmt|;
name|add
argument_list|(
name|pathString
argument_list|,
name|delimiter
argument_list|)
expr_stmt|;
block|}
comment|/**    * Add the given components to the end of the path. The components are given    * in a single string, separated by a given delimiter character. If the    * given string is empty, it is assumed to refer to the root (empty)    * category, and nothing is added to the path (rather than adding a single    * empty component).    *<P>    * Note that when a String object is passed to this method, a reference to    * it is not saved (rather, its content is copied), which will lead to that    * String object being gc'ed. To reduce the number of garbage objects, you    * can pass a mutable CharBuffer instead of an immutable String to this    * method.    */
DECL|method|add
specifier|public
name|void
name|add
parameter_list|(
name|CharSequence
name|pathString
parameter_list|,
name|char
name|delimiter
parameter_list|)
block|{
name|int
name|len
init|=
name|pathString
operator|.
name|length
argument_list|()
decl_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
return|return;
comment|// assume root category meant, so add nothing.
block|}
name|short
name|pos
init|=
operator|(
name|ncomponents
operator|==
literal|0
operator|)
condition|?
literal|0
else|:
name|ends
index|[
name|ncomponents
operator|-
literal|1
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|char
name|c
init|=
name|pathString
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|==
name|delimiter
condition|)
block|{
if|if
condition|(
name|ncomponents
operator|>=
name|ends
operator|.
name|length
condition|)
block|{
name|short
index|[]
name|newends
init|=
operator|new
name|short
index|[
operator|(
name|ends
operator|.
name|length
operator|+
literal|1
operator|)
operator|*
literal|2
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|ends
argument_list|,
literal|0
argument_list|,
name|newends
argument_list|,
literal|0
argument_list|,
name|ends
operator|.
name|length
argument_list|)
expr_stmt|;
name|ends
operator|=
name|newends
expr_stmt|;
block|}
name|ends
index|[
name|ncomponents
operator|++
index|]
operator|=
name|pos
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|pos
operator|>=
name|chars
operator|.
name|length
condition|)
block|{
name|char
index|[]
name|newchars
init|=
operator|new
name|char
index|[
operator|(
name|chars
operator|.
name|length
operator|+
literal|1
operator|)
operator|*
literal|2
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|chars
argument_list|,
literal|0
argument_list|,
name|newchars
argument_list|,
literal|0
argument_list|,
name|chars
operator|.
name|length
argument_list|)
expr_stmt|;
name|chars
operator|=
name|newchars
expr_stmt|;
block|}
name|chars
index|[
name|pos
operator|++
index|]
operator|=
name|c
expr_stmt|;
block|}
block|}
comment|// Don't forget to count the last component!
if|if
condition|(
name|ncomponents
operator|>=
name|ends
operator|.
name|length
condition|)
block|{
name|short
index|[]
name|newends
init|=
operator|new
name|short
index|[
operator|(
name|ends
operator|.
name|length
operator|+
literal|1
operator|)
operator|*
literal|2
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|ends
argument_list|,
literal|0
argument_list|,
name|newends
argument_list|,
literal|0
argument_list|,
name|ends
operator|.
name|length
argument_list|)
expr_stmt|;
name|ends
operator|=
name|newends
expr_stmt|;
block|}
name|ends
index|[
name|ncomponents
operator|++
index|]
operator|=
name|pos
expr_stmt|;
block|}
comment|/**    * Construct a new CategoryPath object, copying an existing path given as an    * array of strings.    *<P>    * The new object occupies exactly the space it needs, without any spare    * capacity. This is the expected behavior in the typical use case, where    * this constructor is used to create a temporary object which is never    * reused.    */
DECL|method|CategoryPath
specifier|public
name|CategoryPath
parameter_list|(
name|CharSequence
modifier|...
name|components
parameter_list|)
block|{
name|this
operator|.
name|ncomponents
operator|=
operator|(
name|short
operator|)
name|components
operator|.
name|length
expr_stmt|;
name|this
operator|.
name|ends
operator|=
operator|new
name|short
index|[
name|ncomponents
index|]
expr_stmt|;
if|if
condition|(
name|ncomponents
operator|>
literal|0
condition|)
block|{
name|this
operator|.
name|ends
index|[
literal|0
index|]
operator|=
operator|(
name|short
operator|)
name|components
index|[
literal|0
index|]
operator|.
name|length
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|ncomponents
condition|;
name|i
operator|++
control|)
block|{
name|this
operator|.
name|ends
index|[
name|i
index|]
operator|=
call|(
name|short
call|)
argument_list|(
name|this
operator|.
name|ends
index|[
name|i
operator|-
literal|1
index|]
operator|+
name|components
index|[
name|i
index|]
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|chars
operator|=
operator|new
name|char
index|[
name|this
operator|.
name|ends
index|[
name|ncomponents
operator|-
literal|1
index|]
index|]
expr_stmt|;
name|CharSequence
name|cs
init|=
name|components
index|[
literal|0
index|]
decl_stmt|;
if|if
condition|(
name|cs
operator|instanceof
name|String
condition|)
block|{
operator|(
operator|(
name|String
operator|)
name|cs
operator|)
operator|.
name|getChars
argument_list|(
literal|0
argument_list|,
name|cs
operator|.
name|length
argument_list|()
argument_list|,
name|this
operator|.
name|chars
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|int
name|j
init|=
literal|0
init|,
name|k
init|=
name|cs
operator|.
name|length
argument_list|()
init|;
name|j
operator|<
name|k
condition|;
name|j
operator|++
control|)
block|{
name|this
operator|.
name|chars
index|[
name|j
index|]
operator|=
name|cs
operator|.
name|charAt
argument_list|(
name|j
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|ncomponents
condition|;
name|i
operator|++
control|)
block|{
name|cs
operator|=
name|components
index|[
name|i
index|]
expr_stmt|;
name|int
name|offset
init|=
name|this
operator|.
name|ends
index|[
name|i
operator|-
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|cs
operator|instanceof
name|String
condition|)
block|{
operator|(
operator|(
name|String
operator|)
name|cs
operator|)
operator|.
name|getChars
argument_list|(
literal|0
argument_list|,
name|cs
operator|.
name|length
argument_list|()
argument_list|,
name|this
operator|.
name|chars
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|int
name|j
init|=
literal|0
init|,
name|k
init|=
name|cs
operator|.
name|length
argument_list|()
init|;
name|j
operator|<
name|k
condition|;
name|j
operator|++
control|)
block|{
name|this
operator|.
name|chars
index|[
name|j
operator|+
name|offset
index|]
operator|=
name|cs
operator|.
name|charAt
argument_list|(
name|j
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
block|{
name|this
operator|.
name|chars
operator|=
operator|new
name|char
index|[
literal|0
index|]
expr_stmt|;
block|}
block|}
comment|/**    * Construct a new CategoryPath object, copying the path given in an    * existing CategoryPath object.    *<P>    * This copy-constructor is handy when you need to save a reference to a    * CategoryPath (e.g., when it serves as a key to a hash-table), but cannot    * save a reference to the original object because its contents can be    * changed later by the user. Copying the contents into a new object is a    * solution.    *<P>    * This constructor</I>does not</I> copy the capacity (spare buffer size)    * of the existing CategoryPath. Rather, the new object occupies exactly the    * space it needs, without any spare. This is the expected behavior in the    * typical use case outlined in the previous paragraph.    */
DECL|method|CategoryPath
specifier|public
name|CategoryPath
parameter_list|(
name|CategoryPath
name|existing
parameter_list|)
block|{
name|ncomponents
operator|=
name|existing
operator|.
name|ncomponents
expr_stmt|;
if|if
condition|(
name|ncomponents
operator|==
literal|0
condition|)
block|{
name|chars
operator|=
operator|new
name|char
index|[
literal|0
index|]
expr_stmt|;
name|ends
operator|=
operator|new
name|short
index|[
literal|0
index|]
expr_stmt|;
return|return;
block|}
name|chars
operator|=
operator|new
name|char
index|[
name|existing
operator|.
name|ends
index|[
name|ncomponents
operator|-
literal|1
index|]
index|]
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|existing
operator|.
name|chars
argument_list|,
literal|0
argument_list|,
name|chars
argument_list|,
literal|0
argument_list|,
name|chars
operator|.
name|length
argument_list|)
expr_stmt|;
name|ends
operator|=
operator|new
name|short
index|[
name|ncomponents
index|]
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|existing
operator|.
name|ends
argument_list|,
literal|0
argument_list|,
name|ends
argument_list|,
literal|0
argument_list|,
name|ends
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
comment|/**    * Construct a new CategoryPath object, copying a prefix with the given    * number of components of the path given in an existing CategoryPath    * object.    *<P>    * If the given length is negative or bigger than the given path's actual    * length, the full path is taken.    *<P>    * This constructor is often convenient for creating a temporary object with    * a path's prefix, but this practice is wasteful, and therefore    * inadvisable. Rather, the application should be written in a way that    * allows considering only a prefix of a given path, without needing to make    * a copy of that path.    */
DECL|method|CategoryPath
specifier|public
name|CategoryPath
parameter_list|(
name|CategoryPath
name|existing
parameter_list|,
name|int
name|prefixLen
parameter_list|)
block|{
if|if
condition|(
name|prefixLen
argument_list|<
literal|0
operator|||
name|prefixLen
argument_list|>
name|existing
operator|.
name|ncomponents
condition|)
block|{
name|ncomponents
operator|=
name|existing
operator|.
name|ncomponents
expr_stmt|;
block|}
else|else
block|{
name|ncomponents
operator|=
operator|(
name|short
operator|)
name|prefixLen
expr_stmt|;
block|}
if|if
condition|(
name|ncomponents
operator|==
literal|0
condition|)
block|{
name|chars
operator|=
operator|new
name|char
index|[
literal|0
index|]
expr_stmt|;
name|ends
operator|=
operator|new
name|short
index|[
literal|0
index|]
expr_stmt|;
return|return;
block|}
name|chars
operator|=
operator|new
name|char
index|[
name|existing
operator|.
name|ends
index|[
name|ncomponents
operator|-
literal|1
index|]
index|]
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|existing
operator|.
name|chars
argument_list|,
literal|0
argument_list|,
name|chars
argument_list|,
literal|0
argument_list|,
name|chars
operator|.
name|length
argument_list|)
expr_stmt|;
name|ends
operator|=
operator|new
name|short
index|[
name|ncomponents
index|]
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|existing
operator|.
name|ends
argument_list|,
literal|0
argument_list|,
name|ends
argument_list|,
literal|0
argument_list|,
name|ends
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|clone
specifier|public
name|Object
name|clone
parameter_list|()
block|{
return|return
operator|new
name|CategoryPath
argument_list|(
name|this
argument_list|)
return|;
block|}
comment|/**    * Compare the given CategoryPath to another one. For two category paths to    * be considered equal, only the path they contain needs to be identical The    * unused capacity of the objects is not considered in the comparison.    */
annotation|@
name|Override
DECL|method|equals
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|obj
parameter_list|)
block|{
if|if
condition|(
name|obj
operator|instanceof
name|CategoryPath
condition|)
block|{
name|CategoryPath
name|other
init|=
operator|(
name|CategoryPath
operator|)
name|obj
decl_stmt|;
if|if
condition|(
name|other
operator|.
name|ncomponents
operator|!=
name|this
operator|.
name|ncomponents
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|// Unfortunately, Arrays.equal() can only compare entire arrays,
comment|// and in our case we potentially have unused parts of the arrays
comment|// that must not be compared... I wish that some future version
comment|// of Java has a offset and length parameter to Arrays.equal
comment|// (sort of like System.arraycopy()).
if|if
condition|(
name|ncomponents
operator|==
literal|0
condition|)
block|{
return|return
literal|true
return|;
comment|// nothing to compare...
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ncomponents
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|this
operator|.
name|ends
index|[
name|i
index|]
operator|!=
name|other
operator|.
name|ends
index|[
name|i
index|]
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
name|int
name|len
init|=
name|ends
index|[
name|ncomponents
operator|-
literal|1
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|this
operator|.
name|chars
index|[
name|i
index|]
operator|!=
name|other
operator|.
name|chars
index|[
name|i
index|]
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
comment|/**    * Test whether this object is a descendant of another CategoryPath. This is    * true if the other CategoryPath is the prefix of this.    */
DECL|method|isDescendantOf
specifier|public
name|boolean
name|isDescendantOf
parameter_list|(
name|CategoryPath
name|other
parameter_list|)
block|{
if|if
condition|(
name|this
operator|.
name|ncomponents
operator|<
name|other
operator|.
name|ncomponents
condition|)
block|{
return|return
literal|false
return|;
block|}
name|int
name|j
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|other
operator|.
name|ncomponents
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ends
index|[
name|i
index|]
operator|!=
name|other
operator|.
name|ends
index|[
name|i
index|]
condition|)
block|{
return|return
literal|false
return|;
block|}
for|for
control|(
init|;
name|j
operator|<
name|ends
index|[
name|i
index|]
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|this
operator|.
name|chars
index|[
name|j
index|]
operator|!=
name|other
operator|.
name|chars
index|[
name|j
index|]
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
block|}
return|return
literal|true
return|;
block|}
comment|/**    * Calculate a hashCode for this path, used when a CategoryPath serves as a    * hash-table key. If two objects are equal(), their hashCodes need to be    * equal, so like in equal(), hashCode does not consider unused portions of    * the internal buffers in its calculation.    *<P>    * The hash function used is modeled after Java's String.hashCode() - a    * simple multiplicative hash function with the multiplier 31. The same hash    * function also appeared in Kernighan& Ritchie's second edition of    * "The C Programming Language" (1988).    */
annotation|@
name|Override
DECL|method|hashCode
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
if|if
condition|(
name|ncomponents
operator|==
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
name|int
name|hash
init|=
name|ncomponents
decl_stmt|;
comment|// Unfortunately, Arrays.hashCode() can only calculate a hash code
comment|// for an entire arrays, and in our case we potentially have unused
comment|// parts of the arrays that must be ignored, so must use our own loop
comment|// over the characters. I wish that some future version of Java will
comment|// add offset and length parameters to Arrays.hashCode (sort of like
comment|// System.arraycopy()'s parameters).
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ncomponents
condition|;
name|i
operator|++
control|)
block|{
name|hash
operator|=
name|hash
operator|*
literal|31
operator|+
name|ends
index|[
name|i
index|]
expr_stmt|;
block|}
name|int
name|len
init|=
name|ends
index|[
name|ncomponents
operator|-
literal|1
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|hash
operator|=
name|hash
operator|*
literal|31
operator|+
name|chars
index|[
name|i
index|]
expr_stmt|;
block|}
return|return
name|hash
return|;
block|}
comment|/**    * Like {@link #hashCode()}, but find the hash function of a prefix with the    * given number of components, rather than of the entire path.    */
DECL|method|hashCode
specifier|public
name|int
name|hashCode
parameter_list|(
name|int
name|prefixLen
parameter_list|)
block|{
if|if
condition|(
name|prefixLen
argument_list|<
literal|0
operator|||
name|prefixLen
argument_list|>
name|ncomponents
condition|)
block|{
name|prefixLen
operator|=
name|ncomponents
expr_stmt|;
block|}
if|if
condition|(
name|prefixLen
operator|==
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
name|int
name|hash
init|=
name|prefixLen
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|prefixLen
condition|;
name|i
operator|++
control|)
block|{
name|hash
operator|=
name|hash
operator|*
literal|31
operator|+
name|ends
index|[
name|i
index|]
expr_stmt|;
block|}
name|int
name|len
init|=
name|ends
index|[
name|prefixLen
operator|-
literal|1
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|hash
operator|=
name|hash
operator|*
literal|31
operator|+
name|chars
index|[
name|i
index|]
expr_stmt|;
block|}
return|return
name|hash
return|;
block|}
comment|/**    * Calculate a 64-bit hash function for this path. Unlike    * {@link #hashCode()}, this method is not part of the Java standard, and is    * only used if explicitly called by the user.    *<P>    * If two objects are equal(), their hash codes need to be equal, so like in    * {@link #equals(Object)}, longHashCode does not consider unused portions    * of the internal buffers in its calculation.    *<P>    * The hash function used is a simple multiplicative hash function, with the    * multiplier 65599. While Java's standard multiplier 31 (used in    * {@link #hashCode()}) gives a good distribution for ASCII strings, it    * turns out that for foreign-language strings (with 16-bit characters) it    * gives too many collisions, and a bigger multiplier produces fewer    * collisions in this case.    */
DECL|method|longHashCode
specifier|public
name|long
name|longHashCode
parameter_list|()
block|{
if|if
condition|(
name|ncomponents
operator|==
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
name|long
name|hash
init|=
name|ncomponents
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ncomponents
condition|;
name|i
operator|++
control|)
block|{
name|hash
operator|=
name|hash
operator|*
literal|65599
operator|+
name|ends
index|[
name|i
index|]
expr_stmt|;
block|}
name|int
name|len
init|=
name|ends
index|[
name|ncomponents
operator|-
literal|1
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|hash
operator|=
name|hash
operator|*
literal|65599
operator|+
name|chars
index|[
name|i
index|]
expr_stmt|;
block|}
return|return
name|hash
return|;
block|}
comment|/**    * Like {@link #longHashCode()}, but find the hash function of a prefix with    * the given number of components, rather than of the entire path.    */
DECL|method|longHashCode
specifier|public
name|long
name|longHashCode
parameter_list|(
name|int
name|prefixLen
parameter_list|)
block|{
if|if
condition|(
name|prefixLen
argument_list|<
literal|0
operator|||
name|prefixLen
argument_list|>
name|ncomponents
condition|)
block|{
name|prefixLen
operator|=
name|ncomponents
expr_stmt|;
block|}
if|if
condition|(
name|prefixLen
operator|==
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
name|long
name|hash
init|=
name|prefixLen
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|prefixLen
condition|;
name|i
operator|++
control|)
block|{
name|hash
operator|=
name|hash
operator|*
literal|65599
operator|+
name|ends
index|[
name|i
index|]
expr_stmt|;
block|}
name|int
name|len
init|=
name|ends
index|[
name|prefixLen
operator|-
literal|1
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|hash
operator|=
name|hash
operator|*
literal|65599
operator|+
name|chars
index|[
name|i
index|]
expr_stmt|;
block|}
return|return
name|hash
return|;
block|}
comment|/**    * Write out a serialized (as a character sequence) representation of the    * path to a given Appendable (e.g., a StringBuilder, CharBuffer, Writer, or    * something similar.    *<P>    * This method may throw a IOException if the given Appendable threw this    * exception while appending.    */
DECL|method|serializeAppendTo
specifier|public
name|void
name|serializeAppendTo
parameter_list|(
name|Appendable
name|out
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Note that we use the fact that ncomponents and ends[] are shorts,
comment|// so we can write them as chars:
name|out
operator|.
name|append
argument_list|(
operator|(
name|char
operator|)
name|ncomponents
argument_list|)
expr_stmt|;
if|if
condition|(
name|ncomponents
operator|==
literal|0
condition|)
block|{
return|return;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ncomponents
condition|;
name|i
operator|++
control|)
block|{
name|out
operator|.
name|append
argument_list|(
operator|(
name|char
operator|)
name|ends
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|int
name|usedchars
init|=
name|ends
index|[
name|ncomponents
operator|-
literal|1
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|usedchars
condition|;
name|i
operator|++
control|)
block|{
name|out
operator|.
name|append
argument_list|(
name|chars
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Just like {@link #serializeAppendTo(Appendable)}, but writes only a    * prefix of the CategoryPath.    */
DECL|method|serializeAppendTo
specifier|public
name|void
name|serializeAppendTo
parameter_list|(
name|int
name|prefixLen
parameter_list|,
name|Appendable
name|out
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|prefixLen
argument_list|<
literal|0
operator|||
name|prefixLen
argument_list|>
name|ncomponents
condition|)
block|{
name|prefixLen
operator|=
name|ncomponents
expr_stmt|;
block|}
comment|// Note that we use the fact that ncomponents and ends[] are shorts,
comment|// so we can write them as chars:
name|out
operator|.
name|append
argument_list|(
operator|(
name|char
operator|)
name|prefixLen
argument_list|)
expr_stmt|;
if|if
condition|(
name|prefixLen
operator|==
literal|0
condition|)
block|{
return|return;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|prefixLen
condition|;
name|i
operator|++
control|)
block|{
name|out
operator|.
name|append
argument_list|(
operator|(
name|char
operator|)
name|ends
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|int
name|usedchars
init|=
name|ends
index|[
name|prefixLen
operator|-
literal|1
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|usedchars
condition|;
name|i
operator|++
control|)
block|{
name|out
operator|.
name|append
argument_list|(
name|chars
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Set a CategoryPath from a character-sequence representation written by    * {@link #serializeAppendTo(Appendable)}.    *<P>    * Reading starts at the given offset into the given character sequence, and    * the offset right after the end of this path is returned.    */
DECL|method|setFromSerialized
specifier|public
name|int
name|setFromSerialized
parameter_list|(
name|CharSequence
name|buffer
parameter_list|,
name|int
name|offset
parameter_list|)
block|{
name|ncomponents
operator|=
operator|(
name|short
operator|)
name|buffer
operator|.
name|charAt
argument_list|(
name|offset
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
name|ncomponents
operator|==
literal|0
condition|)
block|{
return|return
name|offset
return|;
block|}
if|if
condition|(
name|ncomponents
operator|>=
name|ends
operator|.
name|length
condition|)
block|{
name|ends
operator|=
operator|new
name|short
index|[
name|Math
operator|.
name|max
argument_list|(
name|ends
operator|.
name|length
operator|*
literal|2
argument_list|,
name|ncomponents
argument_list|)
index|]
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ncomponents
condition|;
name|i
operator|++
control|)
block|{
name|ends
index|[
name|i
index|]
operator|=
operator|(
name|short
operator|)
name|buffer
operator|.
name|charAt
argument_list|(
name|offset
operator|++
argument_list|)
expr_stmt|;
block|}
name|int
name|usedchars
init|=
name|ends
index|[
name|ncomponents
operator|-
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|usedchars
operator|>
name|chars
operator|.
name|length
condition|)
block|{
name|chars
operator|=
operator|new
name|char
index|[
name|Math
operator|.
name|max
argument_list|(
name|chars
operator|.
name|length
operator|*
literal|2
argument_list|,
name|usedchars
argument_list|)
index|]
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|usedchars
condition|;
name|i
operator|++
control|)
block|{
name|chars
index|[
name|i
index|]
operator|=
name|buffer
operator|.
name|charAt
argument_list|(
name|offset
operator|++
argument_list|)
expr_stmt|;
block|}
return|return
name|offset
return|;
block|}
comment|/**    * Check whether the current path is identical to the one serialized (with    * {@link #serializeAppendTo(Appendable)}) in the given buffer, at the given    * offset.    */
DECL|method|equalsToSerialized
specifier|public
name|boolean
name|equalsToSerialized
parameter_list|(
name|CharSequence
name|buffer
parameter_list|,
name|int
name|offset
parameter_list|)
block|{
name|int
name|n
init|=
operator|(
name|short
operator|)
name|buffer
operator|.
name|charAt
argument_list|(
name|offset
operator|++
argument_list|)
decl_stmt|;
if|if
condition|(
name|ncomponents
operator|!=
name|n
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|ncomponents
operator|==
literal|0
condition|)
block|{
return|return
literal|true
return|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ncomponents
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ends
index|[
name|i
index|]
operator|!=
operator|(
name|short
operator|)
name|buffer
operator|.
name|charAt
argument_list|(
name|offset
operator|++
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
name|int
name|usedchars
init|=
name|ends
index|[
name|ncomponents
operator|-
literal|1
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|usedchars
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|chars
index|[
name|i
index|]
operator|!=
name|buffer
operator|.
name|charAt
argument_list|(
name|offset
operator|++
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
comment|/**    * Just like {@link #equalsToSerialized(CharSequence, int)}, but compare to    * a prefix of the CategoryPath, instead of the whole CategoryPath.    */
DECL|method|equalsToSerialized
specifier|public
name|boolean
name|equalsToSerialized
parameter_list|(
name|int
name|prefixLen
parameter_list|,
name|CharSequence
name|buffer
parameter_list|,
name|int
name|offset
parameter_list|)
block|{
if|if
condition|(
name|prefixLen
argument_list|<
literal|0
operator|||
name|prefixLen
argument_list|>
name|ncomponents
condition|)
block|{
name|prefixLen
operator|=
name|ncomponents
expr_stmt|;
block|}
name|int
name|n
init|=
operator|(
name|short
operator|)
name|buffer
operator|.
name|charAt
argument_list|(
name|offset
operator|++
argument_list|)
decl_stmt|;
if|if
condition|(
name|prefixLen
operator|!=
name|n
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|prefixLen
operator|==
literal|0
condition|)
block|{
return|return
literal|true
return|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|prefixLen
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ends
index|[
name|i
index|]
operator|!=
operator|(
name|short
operator|)
name|buffer
operator|.
name|charAt
argument_list|(
name|offset
operator|++
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
name|int
name|usedchars
init|=
name|ends
index|[
name|prefixLen
operator|-
literal|1
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|usedchars
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|chars
index|[
name|i
index|]
operator|!=
name|buffer
operator|.
name|charAt
argument_list|(
name|offset
operator|++
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
comment|/**    * This method calculates a hash function of a path that has been written to    * (using {@link #serializeAppendTo(Appendable)}) a character buffer. It is    * guaranteed that the value returned is identical to that which    * {@link #hashCode()} would have produced for the original object before it    * was serialized.    */
DECL|method|hashCodeOfSerialized
specifier|public
specifier|static
name|int
name|hashCodeOfSerialized
parameter_list|(
name|CharSequence
name|buffer
parameter_list|,
name|int
name|offset
parameter_list|)
block|{
comment|// Note: the algorithm here must be identical to that of hashCode(),
comment|// in order that they produce identical results!
name|int
name|ncomponents
init|=
operator|(
name|short
operator|)
name|buffer
operator|.
name|charAt
argument_list|(
name|offset
operator|++
argument_list|)
decl_stmt|;
if|if
condition|(
name|ncomponents
operator|==
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
name|int
name|hash
init|=
name|ncomponents
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ncomponents
condition|;
name|i
operator|++
control|)
block|{
name|hash
operator|=
name|hash
operator|*
literal|31
operator|+
name|buffer
operator|.
name|charAt
argument_list|(
name|offset
operator|++
argument_list|)
expr_stmt|;
block|}
name|int
name|len
init|=
name|buffer
operator|.
name|charAt
argument_list|(
name|offset
operator|-
literal|1
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|hash
operator|=
name|hash
operator|*
literal|31
operator|+
name|buffer
operator|.
name|charAt
argument_list|(
name|offset
operator|++
argument_list|)
expr_stmt|;
block|}
return|return
name|hash
return|;
block|}
comment|/**    * Serializes the content of this CategoryPath to a byte stream, using UTF-8    * encoding to convert characters to bytes, and treating the ends as 16-bit    * characters.     *     * @param osw    *          The output byte stream.    * @throws IOException    *           If there are encoding errors.    */
comment|// TODO (Facet): consolidate all de/serialize method names to
comment|// serialize() and unserialize()
DECL|method|serializeToStreamWriter
specifier|public
name|void
name|serializeToStreamWriter
parameter_list|(
name|OutputStreamWriter
name|osw
parameter_list|)
throws|throws
name|IOException
block|{
name|osw
operator|.
name|write
argument_list|(
name|this
operator|.
name|ncomponents
argument_list|)
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|ncomponents
operator|<=
literal|0
condition|)
block|{
return|return;
block|}
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|this
operator|.
name|ncomponents
condition|;
name|j
operator|++
control|)
block|{
name|osw
operator|.
name|write
argument_list|(
name|this
operator|.
name|ends
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
name|osw
operator|.
name|write
argument_list|(
name|this
operator|.
name|chars
argument_list|,
literal|0
argument_list|,
name|this
operator|.
name|ends
index|[
name|this
operator|.
name|ncomponents
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
comment|/**    * Serializes the content of this CategoryPath to a byte stream, using UTF-8    * encoding to convert characters to bytes, and treating the ends as 16-bit    * characters.    *     * @param isr    *            The input stream.    * @throws IOException    *             If there are encoding errors.    */
DECL|method|deserializeFromStreamReader
specifier|public
name|void
name|deserializeFromStreamReader
parameter_list|(
name|InputStreamReader
name|isr
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|ncomponents
operator|=
operator|(
name|short
operator|)
name|isr
operator|.
name|read
argument_list|()
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|ncomponents
operator|<=
literal|0
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|this
operator|.
name|ends
operator|==
literal|null
operator|||
name|this
operator|.
name|ends
operator|.
name|length
operator|<
name|this
operator|.
name|ncomponents
condition|)
block|{
name|this
operator|.
name|ends
operator|=
operator|new
name|short
index|[
name|this
operator|.
name|ncomponents
index|]
expr_stmt|;
block|}
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|this
operator|.
name|ncomponents
condition|;
name|j
operator|++
control|)
block|{
name|this
operator|.
name|ends
index|[
name|j
index|]
operator|=
operator|(
name|short
operator|)
name|isr
operator|.
name|read
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|this
operator|.
name|chars
operator|==
literal|null
operator|||
name|this
operator|.
name|ends
index|[
name|this
operator|.
name|ncomponents
operator|-
literal|1
index|]
operator|>
name|chars
operator|.
name|length
condition|)
block|{
name|this
operator|.
name|chars
operator|=
operator|new
name|char
index|[
name|this
operator|.
name|ends
index|[
name|this
operator|.
name|ncomponents
operator|-
literal|1
index|]
index|]
expr_stmt|;
block|}
name|isr
operator|.
name|read
argument_list|(
name|this
operator|.
name|chars
argument_list|,
literal|0
argument_list|,
name|this
operator|.
name|ends
index|[
name|this
operator|.
name|ncomponents
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
DECL|method|writeObject
specifier|private
name|void
name|writeObject
parameter_list|(
name|java
operator|.
name|io
operator|.
name|ObjectOutputStream
name|out
parameter_list|)
throws|throws
name|IOException
block|{
name|OutputStreamWriter
name|osw
init|=
operator|new
name|OutputStreamWriter
argument_list|(
name|out
argument_list|,
literal|"UTF-8"
argument_list|)
decl_stmt|;
name|this
operator|.
name|serializeToStreamWriter
argument_list|(
name|osw
argument_list|)
expr_stmt|;
name|osw
operator|.
name|flush
argument_list|()
expr_stmt|;
block|}
DECL|method|readObject
specifier|private
name|void
name|readObject
parameter_list|(
name|java
operator|.
name|io
operator|.
name|ObjectInputStream
name|in
parameter_list|)
throws|throws
name|IOException
throws|,
name|ClassNotFoundException
block|{
name|InputStreamReader
name|isr
init|=
operator|new
name|InputStreamReader
argument_list|(
name|in
argument_list|,
literal|"UTF-8"
argument_list|)
decl_stmt|;
name|this
operator|.
name|deserializeFromStreamReader
argument_list|(
name|isr
argument_list|)
expr_stmt|;
block|}
comment|/**    * Compares this CategoryPath with the other CategoryPath for lexicographic    * order.     * Returns a negative integer, zero, or a positive integer as this    * CategoryPath lexicographically precedes, equals to, or lexicographically follows     * the other CategoryPath.    */
DECL|method|compareTo
specifier|public
name|int
name|compareTo
parameter_list|(
name|CategoryPath
name|other
parameter_list|)
block|{
name|int
name|minlength
init|=
operator|(
name|this
operator|.
name|length
argument_list|()
operator|<
name|other
operator|.
name|length
argument_list|()
operator|)
condition|?
name|this
operator|.
name|length
argument_list|()
else|:
name|other
operator|.
name|length
argument_list|()
decl_stmt|;
name|int
name|ch
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|co
init|=
literal|0
init|;
name|co
operator|<
name|minlength
condition|;
name|co
operator|++
control|)
block|{
if|if
condition|(
name|this
operator|.
name|ends
index|[
name|co
index|]
operator|<=
name|other
operator|.
name|ends
index|[
name|co
index|]
condition|)
block|{
for|for
control|(
init|;
name|ch
operator|<
name|this
operator|.
name|ends
index|[
name|co
index|]
condition|;
name|ch
operator|++
control|)
block|{
if|if
condition|(
name|this
operator|.
name|chars
index|[
name|ch
index|]
operator|!=
name|other
operator|.
name|chars
index|[
name|ch
index|]
condition|)
block|{
return|return
name|this
operator|.
name|chars
index|[
name|ch
index|]
operator|-
name|other
operator|.
name|chars
index|[
name|ch
index|]
return|;
block|}
block|}
if|if
condition|(
name|this
operator|.
name|ends
index|[
name|co
index|]
operator|<
name|other
operator|.
name|ends
index|[
name|co
index|]
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
block|}
else|else
comment|/* this.ends[co]> other.ends[co] */
block|{
for|for
control|(
init|;
name|ch
operator|<
name|other
operator|.
name|ends
index|[
name|co
index|]
condition|;
name|ch
operator|++
control|)
block|{
if|if
condition|(
name|this
operator|.
name|chars
index|[
name|ch
index|]
operator|!=
name|other
operator|.
name|chars
index|[
name|ch
index|]
condition|)
block|{
return|return
name|this
operator|.
name|chars
index|[
name|ch
index|]
operator|-
name|other
operator|.
name|chars
index|[
name|ch
index|]
return|;
block|}
block|}
return|return
operator|+
literal|1
return|;
block|}
block|}
comment|// one is a prefix of the other
return|return
name|this
operator|.
name|length
argument_list|()
operator|-
name|other
operator|.
name|length
argument_list|()
return|;
block|}
block|}
end_class
end_unit
