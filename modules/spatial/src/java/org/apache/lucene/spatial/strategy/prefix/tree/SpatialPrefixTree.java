begin_unit
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_package
DECL|package|org.apache.lucene.spatial.strategy.prefix.tree
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|spatial
operator|.
name|strategy
operator|.
name|prefix
operator|.
name|tree
package|;
end_package
begin_import
import|import
name|com
operator|.
name|spatial4j
operator|.
name|core
operator|.
name|context
operator|.
name|SpatialContext
import|;
end_import
begin_import
import|import
name|com
operator|.
name|spatial4j
operator|.
name|core
operator|.
name|shape
operator|.
name|Point
import|;
end_import
begin_import
import|import
name|com
operator|.
name|spatial4j
operator|.
name|core
operator|.
name|shape
operator|.
name|Shape
import|;
end_import
begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|charset
operator|.
name|Charset
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import
begin_comment
comment|/**  * A Spatial Prefix Tree, or Trie, which decomposes shapes into prefixed strings at variable lengths corresponding to  * variable precision.  Each string corresponds to a spatial region.  *  * Implementations of this class should be thread-safe and immutable once initialized.  */
end_comment
begin_class
DECL|class|SpatialPrefixTree
specifier|public
specifier|abstract
class|class
name|SpatialPrefixTree
block|{
DECL|field|UTF8
specifier|protected
specifier|static
specifier|final
name|Charset
name|UTF8
init|=
name|Charset
operator|.
name|forName
argument_list|(
literal|"UTF-8"
argument_list|)
decl_stmt|;
DECL|field|maxLevels
specifier|protected
specifier|final
name|int
name|maxLevels
decl_stmt|;
DECL|field|ctx
specifier|protected
specifier|final
name|SpatialContext
name|ctx
decl_stmt|;
DECL|method|SpatialPrefixTree
specifier|public
name|SpatialPrefixTree
parameter_list|(
name|SpatialContext
name|ctx
parameter_list|,
name|int
name|maxLevels
parameter_list|)
block|{
assert|assert
name|maxLevels
operator|>
literal|0
assert|;
name|this
operator|.
name|ctx
operator|=
name|ctx
expr_stmt|;
name|this
operator|.
name|maxLevels
operator|=
name|maxLevels
expr_stmt|;
block|}
DECL|method|getSpatialContext
specifier|public
name|SpatialContext
name|getSpatialContext
parameter_list|()
block|{
return|return
name|ctx
return|;
block|}
DECL|method|getMaxLevels
specifier|public
name|int
name|getMaxLevels
parameter_list|()
block|{
return|return
name|maxLevels
return|;
block|}
annotation|@
name|Override
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|"(maxLevels:"
operator|+
name|maxLevels
operator|+
literal|",ctx:"
operator|+
name|ctx
operator|+
literal|")"
return|;
block|}
comment|/**    * See {@link com.spatial4j.core.query.SpatialArgs#getDistPrecision()}.    * A grid level looked up via {@link #getLevelForDistance(double)} is returned.    *    * @param shape    * @param precision 0-0.5    * @return 1-maxLevels    */
DECL|method|getMaxLevelForPrecision
specifier|public
name|int
name|getMaxLevelForPrecision
parameter_list|(
name|Shape
name|shape
parameter_list|,
name|double
name|precision
parameter_list|)
block|{
if|if
condition|(
name|precision
argument_list|<
literal|0
operator|||
name|precision
argument_list|>
literal|0.5
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Precision "
operator|+
name|precision
operator|+
literal|" must be between [0-0.5]"
argument_list|)
throw|;
block|}
if|if
condition|(
name|precision
operator|==
literal|0
operator|||
name|shape
operator|instanceof
name|Point
condition|)
block|{
return|return
name|maxLevels
return|;
block|}
name|double
name|bboxArea
init|=
name|shape
operator|.
name|getBoundingBox
argument_list|()
operator|.
name|getArea
argument_list|()
decl_stmt|;
if|if
condition|(
name|bboxArea
operator|==
literal|0
condition|)
block|{
return|return
name|maxLevels
return|;
block|}
name|double
name|avgSideLenFromCenter
init|=
name|Math
operator|.
name|sqrt
argument_list|(
name|bboxArea
argument_list|)
operator|/
literal|2
decl_stmt|;
return|return
name|getLevelForDistance
argument_list|(
name|avgSideLenFromCenter
operator|*
name|precision
argument_list|)
return|;
block|}
comment|/**    * Returns the level of the smallest grid size with a side length that is greater or equal to the provided    * distance.    *    * @param dist>= 0    * @return level [1-maxLevels]    */
DECL|method|getLevelForDistance
specifier|public
specifier|abstract
name|int
name|getLevelForDistance
parameter_list|(
name|double
name|dist
parameter_list|)
function_decl|;
comment|//TODO double getDistanceForLevel(int level)
DECL|field|worldNode
specifier|private
specifier|transient
name|Node
name|worldNode
decl_stmt|;
comment|//cached
comment|/**    * Returns the level 0 cell which encompasses all spatial data. Equivalent to {@link #getNode(String)} with "".    * This cell is threadsafe, just like a spatial prefix grid is, although cells aren't    * generally threadsafe.    * TODO rename to getTopCell or is this fine?    */
DECL|method|getWorldNode
specifier|public
name|Node
name|getWorldNode
parameter_list|()
block|{
if|if
condition|(
name|worldNode
operator|==
literal|null
condition|)
block|{
name|worldNode
operator|=
name|getNode
argument_list|(
literal|""
argument_list|)
expr_stmt|;
block|}
return|return
name|worldNode
return|;
block|}
comment|/**    * The cell for the specified token. The empty string should be equal to {@link #getWorldNode()}.    * Precondition: Never called when token length> maxLevel.    */
DECL|method|getNode
specifier|public
specifier|abstract
name|Node
name|getNode
parameter_list|(
name|String
name|token
parameter_list|)
function_decl|;
DECL|method|getNode
specifier|public
specifier|abstract
name|Node
name|getNode
parameter_list|(
name|byte
index|[]
name|bytes
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|len
parameter_list|)
function_decl|;
DECL|method|getNode
specifier|public
specifier|final
name|Node
name|getNode
parameter_list|(
name|byte
index|[]
name|bytes
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|len
parameter_list|,
name|Node
name|target
parameter_list|)
block|{
if|if
condition|(
name|target
operator|==
literal|null
condition|)
block|{
return|return
name|getNode
argument_list|(
name|bytes
argument_list|,
name|offset
argument_list|,
name|len
argument_list|)
return|;
block|}
name|target
operator|.
name|reset
argument_list|(
name|bytes
argument_list|,
name|offset
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
DECL|method|getNode
specifier|protected
name|Node
name|getNode
parameter_list|(
name|Point
name|p
parameter_list|,
name|int
name|level
parameter_list|)
block|{
return|return
name|getNodes
argument_list|(
name|p
argument_list|,
name|level
argument_list|,
literal|false
argument_list|)
operator|.
name|get
argument_list|(
literal|0
argument_list|)
return|;
block|}
comment|/**    * Gets the intersecting& including cells for the specified shape, without exceeding detail level.    * The result is a set of cells (no dups), sorted. Unmodifiable.    *<p/>    * This implementation checks if shape is a Point and if so uses an implementation that    * recursively calls {@link Node#getSubCell(com.spatial4j.core.shape.Point)}. Cell subclasses    * ideally implement that method with a quick implementation, otherwise, subclasses should    * override this method to invoke {@link #getNodesAltPoint(com.spatial4j.core.shape.Point, int, boolean)}.    * TODO consider another approach returning an iterator -- won't build up all cells in memory.    */
DECL|method|getNodes
specifier|public
name|List
argument_list|<
name|Node
argument_list|>
name|getNodes
parameter_list|(
name|Shape
name|shape
parameter_list|,
name|int
name|detailLevel
parameter_list|,
name|boolean
name|inclParents
parameter_list|)
block|{
if|if
condition|(
name|detailLevel
operator|>
name|maxLevels
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"detailLevel> maxLevels"
argument_list|)
throw|;
block|}
name|List
argument_list|<
name|Node
argument_list|>
name|cells
decl_stmt|;
if|if
condition|(
name|shape
operator|instanceof
name|Point
condition|)
block|{
comment|//optimized point algorithm
specifier|final
name|int
name|initialCapacity
init|=
name|inclParents
condition|?
literal|1
operator|+
name|detailLevel
else|:
literal|1
decl_stmt|;
name|cells
operator|=
operator|new
name|ArrayList
argument_list|<
name|Node
argument_list|>
argument_list|(
name|initialCapacity
argument_list|)
expr_stmt|;
name|recursiveGetNodes
argument_list|(
name|getWorldNode
argument_list|()
argument_list|,
operator|(
name|Point
operator|)
name|shape
argument_list|,
name|detailLevel
argument_list|,
literal|true
argument_list|,
name|cells
argument_list|)
expr_stmt|;
assert|assert
name|cells
operator|.
name|size
argument_list|()
operator|==
name|initialCapacity
assert|;
block|}
else|else
block|{
name|cells
operator|=
operator|new
name|ArrayList
argument_list|<
name|Node
argument_list|>
argument_list|(
name|inclParents
condition|?
literal|1024
else|:
literal|512
argument_list|)
expr_stmt|;
name|recursiveGetNodes
argument_list|(
name|getWorldNode
argument_list|()
argument_list|,
name|shape
argument_list|,
name|detailLevel
argument_list|,
name|inclParents
argument_list|,
name|cells
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|inclParents
condition|)
block|{
name|Node
name|c
init|=
name|cells
operator|.
name|remove
argument_list|(
literal|0
argument_list|)
decl_stmt|;
comment|//remove getWorldNode()
assert|assert
name|c
operator|.
name|getLevel
argument_list|()
operator|==
literal|0
assert|;
block|}
return|return
name|cells
return|;
block|}
DECL|method|recursiveGetNodes
specifier|private
name|void
name|recursiveGetNodes
parameter_list|(
name|Node
name|node
parameter_list|,
name|Shape
name|shape
parameter_list|,
name|int
name|detailLevel
parameter_list|,
name|boolean
name|inclParents
parameter_list|,
name|Collection
argument_list|<
name|Node
argument_list|>
name|result
parameter_list|)
block|{
if|if
condition|(
name|node
operator|.
name|isLeaf
argument_list|()
condition|)
block|{
comment|//cell is within shape
name|result
operator|.
name|add
argument_list|(
name|node
argument_list|)
expr_stmt|;
return|return;
block|}
specifier|final
name|Collection
argument_list|<
name|Node
argument_list|>
name|subCells
init|=
name|node
operator|.
name|getSubCells
argument_list|(
name|shape
argument_list|)
decl_stmt|;
if|if
condition|(
name|node
operator|.
name|getLevel
argument_list|()
operator|==
name|detailLevel
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|subCells
operator|.
name|size
argument_list|()
operator|<
name|node
operator|.
name|getSubCellsSize
argument_list|()
condition|)
block|{
if|if
condition|(
name|inclParents
condition|)
name|result
operator|.
name|add
argument_list|(
name|node
argument_list|)
expr_stmt|;
for|for
control|(
name|Node
name|subCell
range|:
name|subCells
control|)
block|{
name|subCell
operator|.
name|setLeaf
argument_list|()
expr_stmt|;
block|}
name|result
operator|.
name|addAll
argument_list|(
name|subCells
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|//a bottom level (i.e. detail level) optimization where all boxes intersect, so use parent cell.
name|node
operator|.
name|setLeaf
argument_list|()
expr_stmt|;
name|result
operator|.
name|add
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|inclParents
condition|)
block|{
name|result
operator|.
name|add
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|Node
name|subCell
range|:
name|subCells
control|)
block|{
name|recursiveGetNodes
argument_list|(
name|subCell
argument_list|,
name|shape
argument_list|,
name|detailLevel
argument_list|,
name|inclParents
argument_list|,
name|result
argument_list|)
expr_stmt|;
comment|//tail call
block|}
block|}
block|}
DECL|method|recursiveGetNodes
specifier|private
name|void
name|recursiveGetNodes
parameter_list|(
name|Node
name|node
parameter_list|,
name|Point
name|point
parameter_list|,
name|int
name|detailLevel
parameter_list|,
name|boolean
name|inclParents
parameter_list|,
name|Collection
argument_list|<
name|Node
argument_list|>
name|result
parameter_list|)
block|{
if|if
condition|(
name|inclParents
condition|)
block|{
name|result
operator|.
name|add
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
specifier|final
name|Node
name|pCell
init|=
name|node
operator|.
name|getSubCell
argument_list|(
name|point
argument_list|)
decl_stmt|;
if|if
condition|(
name|node
operator|.
name|getLevel
argument_list|()
operator|==
name|detailLevel
operator|-
literal|1
condition|)
block|{
name|pCell
operator|.
name|setLeaf
argument_list|()
expr_stmt|;
name|result
operator|.
name|add
argument_list|(
name|pCell
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|recursiveGetNodes
argument_list|(
name|pCell
argument_list|,
name|point
argument_list|,
name|detailLevel
argument_list|,
name|inclParents
argument_list|,
name|result
argument_list|)
expr_stmt|;
comment|//tail call
block|}
block|}
comment|/**    * Subclasses might override {@link #getNodes(com.spatial4j.core.shape.Shape, int, boolean)}    * and check if the argument is a shape and if so, delegate    * to this implementation, which calls {@link #getNode(com.spatial4j.core.shape.Point, int)} and    * then calls {@link #getNode(String)} repeatedly if inclParents is true.    */
DECL|method|getNodesAltPoint
specifier|protected
specifier|final
name|List
argument_list|<
name|Node
argument_list|>
name|getNodesAltPoint
parameter_list|(
name|Point
name|p
parameter_list|,
name|int
name|detailLevel
parameter_list|,
name|boolean
name|inclParents
parameter_list|)
block|{
name|Node
name|cell
init|=
name|getNode
argument_list|(
name|p
argument_list|,
name|detailLevel
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|inclParents
condition|)
block|{
return|return
name|Collections
operator|.
name|singletonList
argument_list|(
name|cell
argument_list|)
return|;
block|}
name|String
name|endToken
init|=
name|cell
operator|.
name|getTokenString
argument_list|()
decl_stmt|;
assert|assert
name|endToken
operator|.
name|length
argument_list|()
operator|==
name|detailLevel
assert|;
name|List
argument_list|<
name|Node
argument_list|>
name|cells
init|=
operator|new
name|ArrayList
argument_list|<
name|Node
argument_list|>
argument_list|(
name|detailLevel
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|detailLevel
condition|;
name|i
operator|++
control|)
block|{
name|cells
operator|.
name|add
argument_list|(
name|getNode
argument_list|(
name|endToken
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|cells
operator|.
name|add
argument_list|(
name|cell
argument_list|)
expr_stmt|;
return|return
name|cells
return|;
block|}
comment|/**    * Will add the trailing leaf byte for leaves. This isn't particularly efficient.    */
DECL|method|nodesToTokenStrings
specifier|public
specifier|static
name|List
argument_list|<
name|String
argument_list|>
name|nodesToTokenStrings
parameter_list|(
name|Collection
argument_list|<
name|Node
argument_list|>
name|nodes
parameter_list|)
block|{
name|List
argument_list|<
name|String
argument_list|>
name|tokens
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|(
operator|(
name|nodes
operator|.
name|size
argument_list|()
operator|)
argument_list|)
decl_stmt|;
for|for
control|(
name|Node
name|node
range|:
name|nodes
control|)
block|{
specifier|final
name|String
name|token
init|=
name|node
operator|.
name|getTokenString
argument_list|()
decl_stmt|;
if|if
condition|(
name|node
operator|.
name|isLeaf
argument_list|()
condition|)
block|{
name|tokens
operator|.
name|add
argument_list|(
name|token
operator|+
operator|(
name|char
operator|)
name|Node
operator|.
name|LEAF_BYTE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tokens
operator|.
name|add
argument_list|(
name|token
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|tokens
return|;
block|}
block|}
end_class
end_unit
