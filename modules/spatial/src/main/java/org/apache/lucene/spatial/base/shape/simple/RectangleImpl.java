begin_unit
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_package
DECL|package|org.apache.lucene.spatial.base.shape.simple
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|spatial
operator|.
name|base
operator|.
name|shape
operator|.
name|simple
package|;
end_package
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|lang
operator|.
name|builder
operator|.
name|EqualsBuilder
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|lang
operator|.
name|builder
operator|.
name|HashCodeBuilder
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|spatial
operator|.
name|base
operator|.
name|shape
operator|.
name|SpatialRelation
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|spatial
operator|.
name|base
operator|.
name|context
operator|.
name|SpatialContext
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|spatial
operator|.
name|base
operator|.
name|distance
operator|.
name|DistanceUtils
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|spatial
operator|.
name|base
operator|.
name|shape
operator|.
name|*
import|;
end_import
begin_comment
comment|/**  * A simple Rectangle implementation that also supports a longitudinal wrap-around. When minX> maxX, this will assume  * it is world coordinates that cross the date line using degrees.  * Immutable& threadsafe.  */
end_comment
begin_class
DECL|class|RectangleImpl
specifier|public
class|class
name|RectangleImpl
implements|implements
name|Rectangle
block|{
DECL|field|minX
specifier|private
specifier|final
name|double
name|minX
decl_stmt|;
DECL|field|maxX
specifier|private
specifier|final
name|double
name|maxX
decl_stmt|;
DECL|field|minY
specifier|private
specifier|final
name|double
name|minY
decl_stmt|;
DECL|field|maxY
specifier|private
specifier|final
name|double
name|maxY
decl_stmt|;
comment|//TODO change to West South East North to be more consistent with OGC?
DECL|method|RectangleImpl
specifier|public
name|RectangleImpl
parameter_list|(
name|double
name|minX
parameter_list|,
name|double
name|maxX
parameter_list|,
name|double
name|minY
parameter_list|,
name|double
name|maxY
parameter_list|)
block|{
comment|//We assume any normalization / validation of params already occurred.
name|this
operator|.
name|minX
operator|=
name|minX
expr_stmt|;
name|this
operator|.
name|maxX
operator|=
name|maxX
expr_stmt|;
name|this
operator|.
name|minY
operator|=
name|minY
expr_stmt|;
name|this
operator|.
name|maxY
operator|=
name|maxY
expr_stmt|;
assert|assert
name|minY
operator|<=
name|maxY
assert|;
block|}
comment|/** Copy constructor. */
DECL|method|RectangleImpl
specifier|public
name|RectangleImpl
parameter_list|(
name|Rectangle
name|r
parameter_list|)
block|{
name|this
argument_list|(
name|r
operator|.
name|getMinX
argument_list|()
argument_list|,
name|r
operator|.
name|getMaxX
argument_list|()
argument_list|,
name|r
operator|.
name|getMinY
argument_list|()
argument_list|,
name|r
operator|.
name|getMaxY
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|hasArea
specifier|public
name|boolean
name|hasArea
parameter_list|()
block|{
return|return
name|maxX
operator|!=
name|minX
operator|&&
name|maxY
operator|!=
name|minY
return|;
block|}
annotation|@
name|Override
DECL|method|getArea
specifier|public
name|double
name|getArea
parameter_list|()
block|{
return|return
name|getWidth
argument_list|()
operator|*
name|getHeight
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|getCrossesDateLine
specifier|public
name|boolean
name|getCrossesDateLine
parameter_list|()
block|{
return|return
operator|(
name|minX
operator|>
name|maxX
operator|)
return|;
block|}
annotation|@
name|Override
DECL|method|getHeight
specifier|public
name|double
name|getHeight
parameter_list|()
block|{
return|return
name|maxY
operator|-
name|minY
return|;
block|}
annotation|@
name|Override
DECL|method|getWidth
specifier|public
name|double
name|getWidth
parameter_list|()
block|{
name|double
name|w
init|=
name|maxX
operator|-
name|minX
decl_stmt|;
if|if
condition|(
name|w
operator|<
literal|0
condition|)
block|{
comment|//only true when minX> maxX (WGS84 assumed)
name|w
operator|+=
literal|360
expr_stmt|;
assert|assert
name|w
operator|>=
literal|0
assert|;
block|}
return|return
name|w
return|;
block|}
annotation|@
name|Override
DECL|method|getMaxX
specifier|public
name|double
name|getMaxX
parameter_list|()
block|{
return|return
name|maxX
return|;
block|}
annotation|@
name|Override
DECL|method|getMaxY
specifier|public
name|double
name|getMaxY
parameter_list|()
block|{
return|return
name|maxY
return|;
block|}
annotation|@
name|Override
DECL|method|getMinX
specifier|public
name|double
name|getMinX
parameter_list|()
block|{
return|return
name|minX
return|;
block|}
annotation|@
name|Override
DECL|method|getMinY
specifier|public
name|double
name|getMinY
parameter_list|()
block|{
return|return
name|minY
return|;
block|}
annotation|@
name|Override
DECL|method|getBoundingBox
specifier|public
name|Rectangle
name|getBoundingBox
parameter_list|()
block|{
return|return
name|this
return|;
block|}
annotation|@
name|Override
DECL|method|relate
specifier|public
name|SpatialRelation
name|relate
parameter_list|(
name|Shape
name|other
parameter_list|,
name|SpatialContext
name|ctx
parameter_list|)
block|{
if|if
condition|(
name|other
operator|instanceof
name|Point
condition|)
block|{
return|return
name|relate
argument_list|(
operator|(
name|Point
operator|)
name|other
argument_list|,
name|ctx
argument_list|)
return|;
block|}
if|if
condition|(
name|other
operator|instanceof
name|Rectangle
condition|)
block|{
return|return
name|relate
argument_list|(
operator|(
name|Rectangle
operator|)
name|other
argument_list|,
name|ctx
argument_list|)
return|;
block|}
return|return
name|other
operator|.
name|relate
argument_list|(
name|this
argument_list|,
name|ctx
argument_list|)
operator|.
name|transpose
argument_list|()
return|;
block|}
DECL|method|relate
specifier|public
name|SpatialRelation
name|relate
parameter_list|(
name|Point
name|point
parameter_list|,
name|SpatialContext
name|ctx
parameter_list|)
block|{
if|if
condition|(
name|point
operator|.
name|getY
argument_list|()
operator|>
name|getMaxY
argument_list|()
operator|||
name|point
operator|.
name|getY
argument_list|()
operator|<
name|getMinY
argument_list|()
operator|||
operator|(
name|getCrossesDateLine
argument_list|()
condition|?
operator|(
name|point
operator|.
name|getX
argument_list|()
operator|<
name|minX
operator|&&
name|point
operator|.
name|getX
argument_list|()
operator|>
name|maxX
operator|)
else|:
operator|(
name|point
operator|.
name|getX
argument_list|()
operator|<
name|minX
operator|||
name|point
operator|.
name|getX
argument_list|()
operator|>
name|maxX
operator|)
operator|)
condition|)
return|return
name|SpatialRelation
operator|.
name|DISJOINT
return|;
return|return
name|SpatialRelation
operator|.
name|CONTAINS
return|;
block|}
DECL|method|relate
specifier|public
name|SpatialRelation
name|relate
parameter_list|(
name|Rectangle
name|rect
parameter_list|,
name|SpatialContext
name|ctx
parameter_list|)
block|{
name|SpatialRelation
name|yIntersect
init|=
name|relate_yRange
argument_list|(
name|rect
operator|.
name|getMinY
argument_list|()
argument_list|,
name|rect
operator|.
name|getMaxY
argument_list|()
argument_list|,
name|ctx
argument_list|)
decl_stmt|;
if|if
condition|(
name|yIntersect
operator|==
name|SpatialRelation
operator|.
name|DISJOINT
condition|)
return|return
name|SpatialRelation
operator|.
name|DISJOINT
return|;
name|SpatialRelation
name|xIntersect
init|=
name|relate_xRange
argument_list|(
name|rect
operator|.
name|getMinX
argument_list|()
argument_list|,
name|rect
operator|.
name|getMaxX
argument_list|()
argument_list|,
name|ctx
argument_list|)
decl_stmt|;
if|if
condition|(
name|xIntersect
operator|==
name|SpatialRelation
operator|.
name|DISJOINT
condition|)
return|return
name|SpatialRelation
operator|.
name|DISJOINT
return|;
if|if
condition|(
name|xIntersect
operator|==
name|yIntersect
condition|)
comment|//in agreement
return|return
name|xIntersect
return|;
comment|//if one side is equal, return the other
if|if
condition|(
name|getMinX
argument_list|()
operator|==
name|rect
operator|.
name|getMinX
argument_list|()
operator|&&
name|getMaxX
argument_list|()
operator|==
name|rect
operator|.
name|getMaxX
argument_list|()
condition|)
return|return
name|yIntersect
return|;
if|if
condition|(
name|getMinY
argument_list|()
operator|==
name|rect
operator|.
name|getMinY
argument_list|()
operator|&&
name|getMaxY
argument_list|()
operator|==
name|rect
operator|.
name|getMaxY
argument_list|()
condition|)
return|return
name|xIntersect
return|;
return|return
name|SpatialRelation
operator|.
name|INTERSECTS
return|;
block|}
DECL|method|relate_yRange
specifier|public
name|SpatialRelation
name|relate_yRange
parameter_list|(
name|double
name|ext_minY
parameter_list|,
name|double
name|ext_maxY
parameter_list|,
name|SpatialContext
name|ctx
parameter_list|)
block|{
if|if
condition|(
name|ext_minY
operator|>
name|maxY
operator|||
name|ext_maxY
operator|<
name|minY
condition|)
block|{
return|return
name|SpatialRelation
operator|.
name|DISJOINT
return|;
block|}
if|if
condition|(
name|ext_minY
operator|>=
name|minY
operator|&&
name|ext_maxY
operator|<=
name|maxY
condition|)
block|{
return|return
name|SpatialRelation
operator|.
name|CONTAINS
return|;
block|}
if|if
condition|(
name|ext_minY
operator|<=
name|minY
operator|&&
name|ext_maxY
operator|>=
name|maxY
condition|)
block|{
return|return
name|SpatialRelation
operator|.
name|WITHIN
return|;
block|}
return|return
name|SpatialRelation
operator|.
name|INTERSECTS
return|;
block|}
annotation|@
name|Override
DECL|method|relate_xRange
specifier|public
name|SpatialRelation
name|relate_xRange
parameter_list|(
name|double
name|ext_minX
parameter_list|,
name|double
name|ext_maxX
parameter_list|,
name|SpatialContext
name|ctx
parameter_list|)
block|{
comment|//For ext& this we have local minX and maxX variable pairs. We rotate them so that minX<= maxX
name|double
name|minX
init|=
name|this
operator|.
name|minX
decl_stmt|;
name|double
name|maxX
init|=
name|this
operator|.
name|maxX
decl_stmt|;
if|if
condition|(
name|ctx
operator|.
name|isGeo
argument_list|()
condition|)
block|{
comment|//the 360 check is an edge-case for complete world-wrap
name|double
name|ext_width
init|=
name|ext_maxX
operator|-
name|ext_minX
decl_stmt|;
if|if
condition|(
name|ext_width
operator|<
literal|0
condition|)
comment|//this logic unfortunately duplicates getWidth()
name|ext_width
operator|+=
literal|360
expr_stmt|;
if|if
condition|(
name|ext_width
operator|<
literal|360
condition|)
block|{
name|ext_maxX
operator|=
name|ext_minX
operator|+
name|ext_width
expr_stmt|;
block|}
else|else
block|{
name|ext_maxX
operator|=
literal|180
operator|+
literal|360
expr_stmt|;
block|}
if|if
condition|(
name|getWidth
argument_list|()
operator|<
literal|360
condition|)
block|{
name|maxX
operator|=
name|minX
operator|+
name|getWidth
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|maxX
operator|=
literal|180
operator|+
literal|360
expr_stmt|;
block|}
if|if
condition|(
name|maxX
operator|<
name|ext_minX
condition|)
block|{
name|minX
operator|+=
literal|360
expr_stmt|;
name|maxX
operator|+=
literal|360
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ext_maxX
operator|<
name|minX
condition|)
block|{
name|ext_minX
operator|+=
literal|360
expr_stmt|;
name|ext_maxX
operator|+=
literal|360
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ext_minX
operator|>
name|maxX
operator|||
name|ext_maxX
operator|<
name|minX
condition|)
block|{
return|return
name|SpatialRelation
operator|.
name|DISJOINT
return|;
block|}
if|if
condition|(
name|ext_minX
operator|>=
name|minX
operator|&&
name|ext_maxX
operator|<=
name|maxX
condition|)
block|{
return|return
name|SpatialRelation
operator|.
name|CONTAINS
return|;
block|}
if|if
condition|(
name|ext_minX
operator|<=
name|minX
operator|&&
name|ext_maxX
operator|>=
name|maxX
condition|)
block|{
return|return
name|SpatialRelation
operator|.
name|WITHIN
return|;
block|}
return|return
name|SpatialRelation
operator|.
name|INTERSECTS
return|;
block|}
annotation|@
name|Override
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"Rect(minX="
operator|+
name|minX
operator|+
literal|",maxX="
operator|+
name|maxX
operator|+
literal|",minY="
operator|+
name|minY
operator|+
literal|",maxY="
operator|+
name|maxY
operator|+
literal|")"
return|;
block|}
annotation|@
name|Override
DECL|method|getCenter
specifier|public
name|Point
name|getCenter
parameter_list|()
block|{
specifier|final
name|double
name|y
init|=
name|getHeight
argument_list|()
operator|/
literal|2
operator|+
name|minY
decl_stmt|;
name|double
name|x
init|=
name|getWidth
argument_list|()
operator|/
literal|2
operator|+
name|minX
decl_stmt|;
if|if
condition|(
name|minX
operator|>
name|maxX
condition|)
comment|//WGS84
name|x
operator|=
name|DistanceUtils
operator|.
name|normLonDEG
argument_list|(
name|x
argument_list|)
expr_stmt|;
return|return
operator|new
name|PointImpl
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|equals
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|obj
parameter_list|)
block|{
if|if
condition|(
name|obj
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|obj
operator|==
name|this
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
name|obj
operator|.
name|getClass
argument_list|()
operator|!=
name|getClass
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
name|RectangleImpl
name|rhs
init|=
operator|(
name|RectangleImpl
operator|)
name|obj
decl_stmt|;
return|return
operator|new
name|EqualsBuilder
argument_list|()
operator|.
name|append
argument_list|(
name|minX
argument_list|,
name|rhs
operator|.
name|minX
argument_list|)
operator|.
name|append
argument_list|(
name|minY
argument_list|,
name|rhs
operator|.
name|minY
argument_list|)
operator|.
name|append
argument_list|(
name|maxX
argument_list|,
name|rhs
operator|.
name|maxX
argument_list|)
operator|.
name|append
argument_list|(
name|maxY
argument_list|,
name|rhs
operator|.
name|maxY
argument_list|)
operator|.
name|isEquals
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|hashCode
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
operator|new
name|HashCodeBuilder
argument_list|(
literal|41
argument_list|,
literal|37
argument_list|)
operator|.
name|append
argument_list|(
name|minX
argument_list|)
operator|.
name|append
argument_list|(
name|minY
argument_list|)
operator|.
name|append
argument_list|(
name|maxX
argument_list|)
operator|.
name|append
argument_list|(
name|maxY
argument_list|)
operator|.
name|toHashCode
argument_list|()
return|;
block|}
block|}
end_class
end_unit
