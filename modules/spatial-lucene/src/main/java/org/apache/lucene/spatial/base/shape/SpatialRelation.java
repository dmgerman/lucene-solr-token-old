begin_unit
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_package
DECL|package|org.apache.lucene.spatial.base.shape
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|spatial
operator|.
name|base
operator|.
name|shape
package|;
end_package
begin_comment
comment|/**  * The set of spatial relationships.  Naming is consistent with OGC spec conventions as seen in SQL/MM and others.  * No equality case.  If two Shape instances are equal then the result might be CONTAINS or WITHIN, and  * some logic might fail under this edge condition when it's not careful to check.  * Client code must be written to detect this and act accordingly.  In RectangleImpl.relate(), it checks  * for this explicitly, for example.  TestShapes2D.assertRelation() checks too.  */
end_comment
begin_enum
DECL|enum|SpatialRelation
specifier|public
enum|enum
name|SpatialRelation
block|{
DECL|enum constant|WITHIN
name|WITHIN
block|,
DECL|enum constant|CONTAINS
name|CONTAINS
block|,
DECL|enum constant|DISJOINT
name|DISJOINT
block|,
DECL|enum constant|INTERSECTS
name|INTERSECTS
block|;
comment|//Don't have these: TOUCHES, CROSSES, OVERLAPS
DECL|method|transpose
specifier|public
name|SpatialRelation
name|transpose
parameter_list|()
block|{
switch|switch
condition|(
name|this
condition|)
block|{
case|case
name|CONTAINS
case|:
return|return
name|SpatialRelation
operator|.
name|WITHIN
return|;
case|case
name|WITHIN
case|:
return|return
name|SpatialRelation
operator|.
name|CONTAINS
return|;
default|default:
return|return
name|this
return|;
block|}
block|}
comment|/**    * If you were to call aShape.relate(bShape) and aShape.relate(cShape), you could call    * this to merge the intersect results as if bShape& cShape were combined into {@link MultiShape}.    * @param other    * @return    */
DECL|method|combine
specifier|public
name|SpatialRelation
name|combine
parameter_list|(
name|SpatialRelation
name|other
parameter_list|)
block|{
if|if
condition|(
name|this
operator|==
name|other
condition|)
return|return
name|this
return|;
if|if
condition|(
name|this
operator|==
name|WITHIN
operator|||
name|other
operator|==
name|WITHIN
condition|)
return|return
name|WITHIN
return|;
return|return
name|INTERSECTS
return|;
block|}
DECL|method|intersects
specifier|public
name|boolean
name|intersects
parameter_list|()
block|{
return|return
name|this
operator|!=
name|DISJOINT
return|;
block|}
comment|/** Not commutative!  WITHIN.inverse().inverse() != WITHIN. */
DECL|method|inverse
specifier|public
name|SpatialRelation
name|inverse
parameter_list|()
block|{
switch|switch
condition|(
name|this
condition|)
block|{
case|case
name|DISJOINT
case|:
return|return
name|CONTAINS
return|;
case|case
name|CONTAINS
case|:
return|return
name|DISJOINT
return|;
case|case
name|WITHIN
case|:
return|return
name|INTERSECTS
return|;
comment|//not commutative!
block|}
return|return
name|INTERSECTS
return|;
block|}
block|}
end_enum
end_unit
